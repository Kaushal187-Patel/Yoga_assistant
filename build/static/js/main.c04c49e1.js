/*! For license information please see main.c04c49e1.js.LICENSE.txt */
(()=>{var e={16(e,t,n){var a;!function(e,s){function r(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var a=0;a<n.length+64;a++)t.x^=0|n.charCodeAt(a),a==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function i(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function o(e,t){var n=new r(e),a=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,a&&("object"==typeof a&&i(a,n),s.state=function(){return i(n,{})}),s}s&&s.exports?s.exports=o:n.amdD&&n.amdO?void 0===(a=function(){return o}.call(t,n,t,s))||(s.exports=a):this.xorwow=o}(0,e=n.nmd(e),n.amdD)},29(e,t,n){var a;a=function(e){return function(e){var t={};function n(a){if(t[a])return t[a].exports;var s=t[a]={i:a,l:!1,exports:{}};return e[a].call(s.exports,s,s.exports,n),s.l=!0,s.exports}return n.m=e,n.c=t,n.d=function(e,t,a){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:a})},n.r=function(e){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"===typeof e&&e&&e.__esModule)return e;var a=Object.create(null);if(n.r(a),Object.defineProperty(a,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var s in e)n.d(a,s,function(t){return e[t]}.bind(null,s));return a},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s="./src/react-webcam.tsx")}({"./src/react-webcam.tsx":function(e,t,n){"use strict";n.r(t);var a=n("react"),s=function(){var e=function(t,n){return e=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)t.hasOwnProperty(n)&&(e[n]=t[n])},e(t,n)};return function(t,n){function a(){this.constructor=t}e(t,n),t.prototype=null===n?Object.create(n):(a.prototype=n.prototype,new a)}}(),r=function(){return r=Object.assign||function(e){for(var t,n=1,a=arguments.length;n<a;n++)for(var s in t=arguments[n])Object.prototype.hasOwnProperty.call(t,s)&&(e[s]=t[s]);return e},r.apply(this,arguments)},i=function(e,t){var n={};for(var a in e)Object.prototype.hasOwnProperty.call(e,a)&&t.indexOf(a)<0&&(n[a]=e[a]);if(null!=e&&"function"===typeof Object.getOwnPropertySymbols){var s=0;for(a=Object.getOwnPropertySymbols(e);s<a.length;s++)t.indexOf(a[s])<0&&Object.prototype.propertyIsEnumerable.call(e,a[s])&&(n[a[s]]=e[a[s]])}return n};function o(){return!(!navigator.mediaDevices||!navigator.mediaDevices.getUserMedia)}"undefined"!==typeof window&&(void 0===navigator.mediaDevices&&(navigator.mediaDevices={}),void 0===navigator.mediaDevices.getUserMedia&&(navigator.mediaDevices.getUserMedia=function(e){var t=navigator.getUserMedia||navigator.webkitGetUserMedia||navigator.mozGetUserMedia||navigator.msGetUserMedia;return t?new Promise(function(n,a){t.call(navigator,e,n,a)}):Promise.reject(new Error("getUserMedia is not implemented in this browser"))}));var c=function(e){function t(t){var n=e.call(this,t)||this;return n.canvas=null,n.ctx=null,n.requestUserMediaId=0,n.unmounted=!1,n.state={hasUserMedia:!1},n}return s(t,e),t.prototype.componentDidMount=function(){var e=this.state,t=this.props;this.unmounted=!1,o()?(e.hasUserMedia||this.requestUserMedia(),t.children&&"function"!=typeof t.children&&console.warn("children must be a function")):t.onUserMediaError("getUserMedia not supported")},t.prototype.componentDidUpdate=function(e){var t=this.props;if(o()){var n=JSON.stringify(e.audioConstraints)!==JSON.stringify(t.audioConstraints),a=JSON.stringify(e.videoConstraints)!==JSON.stringify(t.videoConstraints),s=e.minScreenshotWidth!==t.minScreenshotWidth,r=e.minScreenshotHeight!==t.minScreenshotHeight;(a||s||r)&&(this.canvas=null,this.ctx=null),(n||a)&&(this.stopAndCleanup(),this.requestUserMedia())}else t.onUserMediaError("getUserMedia not supported")},t.prototype.componentWillUnmount=function(){this.unmounted=!0,this.stopAndCleanup()},t.stopMediaStream=function(e){e&&(e.getVideoTracks&&e.getAudioTracks?(e.getVideoTracks().map(function(t){e.removeTrack(t),t.stop()}),e.getAudioTracks().map(function(t){e.removeTrack(t),t.stop()})):e.stop())},t.prototype.stopAndCleanup=function(){var e=this.state;e.hasUserMedia&&(t.stopMediaStream(this.stream),e.src&&window.URL.revokeObjectURL(e.src))},t.prototype.getScreenshot=function(e){var t=this.state,n=this.props;if(!t.hasUserMedia)return null;var a=this.getCanvas(e);return a&&a.toDataURL(n.screenshotFormat,n.screenshotQuality)},t.prototype.getCanvas=function(e){var t=this.state,n=this.props;if(!this.video)return null;if(!t.hasUserMedia||!this.video.videoHeight)return null;if(!this.ctx){var a=this.video.videoWidth,s=this.video.videoHeight;if(!this.props.forceScreenshotSourceSize){var r=a/s;s=(a=n.minScreenshotWidth||this.video.clientWidth)/r,n.minScreenshotHeight&&s<n.minScreenshotHeight&&(a=(s=n.minScreenshotHeight)*r)}this.canvas=document.createElement("canvas"),this.canvas.width=(null===e||void 0===e?void 0:e.width)||a,this.canvas.height=(null===e||void 0===e?void 0:e.height)||s,this.ctx=this.canvas.getContext("2d")}var i=this.ctx,o=this.canvas;return i&&o&&(o.width=(null===e||void 0===e?void 0:e.width)||o.width,o.height=(null===e||void 0===e?void 0:e.height)||o.height,n.mirrored&&(i.translate(o.width,0),i.scale(-1,1)),i.imageSmoothingEnabled=n.imageSmoothing,i.drawImage(this.video,0,0,(null===e||void 0===e?void 0:e.width)||o.width,(null===e||void 0===e?void 0:e.height)||o.height),n.mirrored&&(i.scale(-1,1),i.translate(-o.width,0))),o},t.prototype.requestUserMedia=function(){var e=this,n=this.props,a=function(a,s){var r={video:"undefined"===typeof s||s};n.audio&&(r.audio="undefined"===typeof a||a),e.requestUserMediaId++;var i=e.requestUserMediaId;navigator.mediaDevices.getUserMedia(r).then(function(n){e.unmounted||i!==e.requestUserMediaId?t.stopMediaStream(n):e.handleUserMedia(null,n)}).catch(function(t){e.handleUserMedia(t)})};if("mediaDevices"in navigator)a(n.audioConstraints,n.videoConstraints);else{var s=function(e){return{optional:[{sourceId:e}]}},r=function(e){var t=e.deviceId;return"string"===typeof t?t:Array.isArray(t)&&t.length>0?t[0]:"object"===typeof t&&t.ideal?t.ideal:null};MediaStreamTrack.getSources(function(e){var t=null,i=null;e.forEach(function(e){"audio"===e.kind?t=e.id:"video"===e.kind&&(i=e.id)});var o=r(n.audioConstraints);o&&(t=o);var c=r(n.videoConstraints);c&&(i=c),a(s(t),s(i))})}},t.prototype.handleUserMedia=function(e,t){var n=this.props;if(e||!t)return this.setState({hasUserMedia:!1}),void n.onUserMediaError(e);this.stream=t;try{this.video&&(this.video.srcObject=t),this.setState({hasUserMedia:!0})}catch(a){this.setState({hasUserMedia:!0,src:window.URL.createObjectURL(t)})}n.onUserMedia(t)},t.prototype.render=function(){var e=this,t=this.state,n=this.props,s=n.audio,o=(n.forceScreenshotSourceSize,n.disablePictureInPicture),c=(n.onUserMedia,n.onUserMediaError,n.screenshotFormat,n.screenshotQuality,n.minScreenshotWidth,n.minScreenshotHeight,n.audioConstraints,n.videoConstraints,n.imageSmoothing,n.mirrored),l=n.style,u=void 0===l?{}:l,h=n.children,d=i(n,["audio","forceScreenshotSourceSize","disablePictureInPicture","onUserMedia","onUserMediaError","screenshotFormat","screenshotQuality","minScreenshotWidth","minScreenshotHeight","audioConstraints","videoConstraints","imageSmoothing","mirrored","style","children"]),p=c?r(r({},u),{transform:(u.transform||"")+" scaleX(-1)"}):u,f={getScreenshot:this.getScreenshot.bind(this)};return a.createElement(a.Fragment,null,a.createElement("video",r({autoPlay:!0,disablePictureInPicture:o,src:t.src,muted:!s,playsInline:!0,ref:function(t){e.video=t},style:p},d)),h&&h(f))},t.defaultProps={audio:!1,disablePictureInPicture:!1,forceScreenshotSourceSize:!1,imageSmoothing:!0,mirrored:!1,onUserMedia:function(){},onUserMediaError:function(){},screenshotFormat:"image/webp",screenshotQuality:.92},t}(a.Component);t.default=c},react:function(t,n){t.exports=e}}).default},e.exports=a(n(43))},43(e,t,n){"use strict";e.exports=n(202)},66(e,t,n){var a;!function(e,s){function r(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var a=0;a<n.length+64;a++)t.x^=0|n.charCodeAt(a),t.next()}function i(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function o(e,t){var n=new r(e),a=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,a&&("object"==typeof a&&i(a,n),s.state=function(){return i(n,{})}),s}s&&s.exports?s.exports=o:n.amdD&&n.amdO?void 0===(a=function(){return o}.call(t,n,t,s))||(s.exports=a):this.xor128=o}(0,e=n.nmd(e),n.amdD)},108(){},153(e,t,n){"use strict";var a=n(43),s=Symbol.for("react.element"),r=Symbol.for("react.fragment"),i=Object.prototype.hasOwnProperty,o=a.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,c={key:!0,ref:!0,__self:!0,__source:!0};function l(e,t,n){var a,r={},l=null,u=null;for(a in void 0!==n&&(l=""+n),void 0!==t.key&&(l=""+t.key),void 0!==t.ref&&(u=t.ref),t)i.call(t,a)&&!c.hasOwnProperty(a)&&(r[a]=t[a]);if(e&&e.defaultProps)for(a in t=e.defaultProps)void 0===r[a]&&(r[a]=t[a]);return{$$typeof:s,type:e,key:l,ref:u,props:r,_owner:o.current}}t.Fragment=r,t.jsx=l,t.jsxs=l},202(e,t){"use strict";var n=Symbol.for("react.element"),a=Symbol.for("react.portal"),s=Symbol.for("react.fragment"),r=Symbol.for("react.strict_mode"),i=Symbol.for("react.profiler"),o=Symbol.for("react.provider"),c=Symbol.for("react.context"),l=Symbol.for("react.forward_ref"),u=Symbol.for("react.suspense"),h=Symbol.for("react.memo"),d=Symbol.for("react.lazy"),p=Symbol.iterator;var f={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},m=Object.assign,g={};function y(e,t,n){this.props=e,this.context=t,this.refs=g,this.updater=n||f}function b(){}function x(e,t,n){this.props=e,this.context=t,this.refs=g,this.updater=n||f}y.prototype.isReactComponent={},y.prototype.setState=function(e,t){if("object"!==typeof e&&"function"!==typeof e&&null!=e)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,e,t,"setState")},y.prototype.forceUpdate=function(e){this.updater.enqueueForceUpdate(this,e,"forceUpdate")},b.prototype=y.prototype;var v=x.prototype=new b;v.constructor=x,m(v,y.prototype),v.isPureReactComponent=!0;var w=Array.isArray,k=Object.prototype.hasOwnProperty,S={current:null},C={key:!0,ref:!0,__self:!0,__source:!0};function I(e,t,a){var s,r={},i=null,o=null;if(null!=t)for(s in void 0!==t.ref&&(o=t.ref),void 0!==t.key&&(i=""+t.key),t)k.call(t,s)&&!C.hasOwnProperty(s)&&(r[s]=t[s]);var c=arguments.length-2;if(1===c)r.children=a;else if(1<c){for(var l=Array(c),u=0;u<c;u++)l[u]=arguments[u+2];r.children=l}if(e&&e.defaultProps)for(s in c=e.defaultProps)void 0===r[s]&&(r[s]=c[s]);return{$$typeof:n,type:e,key:i,ref:o,props:r,_owner:S.current}}function N(e){return"object"===typeof e&&null!==e&&e.$$typeof===n}var T=/\/+/g;function E(e,t){return"object"===typeof e&&null!==e&&null!=e.key?function(e){var t={"=":"=0",":":"=2"};return"$"+e.replace(/[=:]/g,function(e){return t[e]})}(""+e.key):t.toString(36)}function R(e,t,s,r,i){var o=typeof e;"undefined"!==o&&"boolean"!==o||(e=null);var c=!1;if(null===e)c=!0;else switch(o){case"string":case"number":c=!0;break;case"object":switch(e.$$typeof){case n:case a:c=!0}}if(c)return i=i(c=e),e=""===r?"."+E(c,0):r,w(i)?(s="",null!=e&&(s=e.replace(T,"$&/")+"/"),R(i,t,s,"",function(e){return e})):null!=i&&(N(i)&&(i=function(e,t){return{$$typeof:n,type:e.type,key:t,ref:e.ref,props:e.props,_owner:e._owner}}(i,s+(!i.key||c&&c.key===i.key?"":(""+i.key).replace(T,"$&/")+"/")+e)),t.push(i)),1;if(c=0,r=""===r?".":r+":",w(e))for(var l=0;l<e.length;l++){var u=r+E(o=e[l],l);c+=R(o,t,s,u,i)}else if(u=function(e){return null===e||"object"!==typeof e?null:"function"===typeof(e=p&&e[p]||e["@@iterator"])?e:null}(e),"function"===typeof u)for(e=u.call(e),l=0;!(o=e.next()).done;)c+=R(o=o.value,t,s,u=r+E(o,l++),i);else if("object"===o)throw t=String(e),Error("Objects are not valid as a React child (found: "+("[object Object]"===t?"object with keys {"+Object.keys(e).join(", ")+"}":t)+"). If you meant to render a collection of children, use an array instead.");return c}function _(e,t,n){if(null==e)return e;var a=[],s=0;return R(e,a,"","",function(e){return t.call(n,e,s++)}),a}function A(e){if(-1===e._status){var t=e._result;(t=t()).then(function(t){0!==e._status&&-1!==e._status||(e._status=1,e._result=t)},function(t){0!==e._status&&-1!==e._status||(e._status=2,e._result=t)}),-1===e._status&&(e._status=0,e._result=t)}if(1===e._status)return e._result.default;throw e._result}var M={current:null},P={transition:null},D={ReactCurrentDispatcher:M,ReactCurrentBatchConfig:P,ReactCurrentOwner:S};function O(){throw Error("act(...) is not supported in production builds of React.")}t.Children={map:_,forEach:function(e,t,n){_(e,function(){t.apply(this,arguments)},n)},count:function(e){var t=0;return _(e,function(){t++}),t},toArray:function(e){return _(e,function(e){return e})||[]},only:function(e){if(!N(e))throw Error("React.Children.only expected to receive a single React element child.");return e}},t.Component=y,t.Fragment=s,t.Profiler=i,t.PureComponent=x,t.StrictMode=r,t.Suspense=u,t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=D,t.act=O,t.cloneElement=function(e,t,a){if(null===e||void 0===e)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+e+".");var s=m({},e.props),r=e.key,i=e.ref,o=e._owner;if(null!=t){if(void 0!==t.ref&&(i=t.ref,o=S.current),void 0!==t.key&&(r=""+t.key),e.type&&e.type.defaultProps)var c=e.type.defaultProps;for(l in t)k.call(t,l)&&!C.hasOwnProperty(l)&&(s[l]=void 0===t[l]&&void 0!==c?c[l]:t[l])}var l=arguments.length-2;if(1===l)s.children=a;else if(1<l){c=Array(l);for(var u=0;u<l;u++)c[u]=arguments[u+2];s.children=c}return{$$typeof:n,type:e.type,key:r,ref:i,props:s,_owner:o}},t.createContext=function(e){return(e={$$typeof:c,_currentValue:e,_currentValue2:e,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null}).Provider={$$typeof:o,_context:e},e.Consumer=e},t.createElement=I,t.createFactory=function(e){var t=I.bind(null,e);return t.type=e,t},t.createRef=function(){return{current:null}},t.forwardRef=function(e){return{$$typeof:l,render:e}},t.isValidElement=N,t.lazy=function(e){return{$$typeof:d,_payload:{_status:-1,_result:e},_init:A}},t.memo=function(e,t){return{$$typeof:h,type:e,compare:void 0===t?null:t}},t.startTransition=function(e){var t=P.transition;P.transition={};try{e()}finally{P.transition=t}},t.unstable_act=O,t.useCallback=function(e,t){return M.current.useCallback(e,t)},t.useContext=function(e){return M.current.useContext(e)},t.useDebugValue=function(){},t.useDeferredValue=function(e){return M.current.useDeferredValue(e)},t.useEffect=function(e,t){return M.current.useEffect(e,t)},t.useId=function(){return M.current.useId()},t.useImperativeHandle=function(e,t,n){return M.current.useImperativeHandle(e,t,n)},t.useInsertionEffect=function(e,t){return M.current.useInsertionEffect(e,t)},t.useLayoutEffect=function(e,t){return M.current.useLayoutEffect(e,t)},t.useMemo=function(e,t){return M.current.useMemo(e,t)},t.useReducer=function(e,t,n){return M.current.useReducer(e,t,n)},t.useRef=function(e){return M.current.useRef(e)},t.useState=function(e){return M.current.useState(e)},t.useSyncExternalStore=function(e,t,n){return M.current.useSyncExternalStore(e,t,n)},t.useTransition=function(){return M.current.useTransition()},t.version="18.3.1"},234(e,t){"use strict";function n(e,t){var n=e.length;e.push(t);e:for(;0<n;){var a=n-1>>>1,s=e[a];if(!(0<r(s,t)))break e;e[a]=t,e[n]=s,n=a}}function a(e){return 0===e.length?null:e[0]}function s(e){if(0===e.length)return null;var t=e[0],n=e.pop();if(n!==t){e[0]=n;e:for(var a=0,s=e.length,i=s>>>1;a<i;){var o=2*(a+1)-1,c=e[o],l=o+1,u=e[l];if(0>r(c,n))l<s&&0>r(u,c)?(e[a]=u,e[l]=n,a=l):(e[a]=c,e[o]=n,a=o);else{if(!(l<s&&0>r(u,n)))break e;e[a]=u,e[l]=n,a=l}}}return t}function r(e,t){var n=e.sortIndex-t.sortIndex;return 0!==n?n:e.id-t.id}if("object"===typeof performance&&"function"===typeof performance.now){var i=performance;t.unstable_now=function(){return i.now()}}else{var o=Date,c=o.now();t.unstable_now=function(){return o.now()-c}}var l=[],u=[],h=1,d=null,p=3,f=!1,m=!1,g=!1,y="function"===typeof setTimeout?setTimeout:null,b="function"===typeof clearTimeout?clearTimeout:null,x="undefined"!==typeof setImmediate?setImmediate:null;function v(e){for(var t=a(u);null!==t;){if(null===t.callback)s(u);else{if(!(t.startTime<=e))break;s(u),t.sortIndex=t.expirationTime,n(l,t)}t=a(u)}}function w(e){if(g=!1,v(e),!m)if(null!==a(l))m=!0,P(k);else{var t=a(u);null!==t&&D(w,t.startTime-e)}}function k(e,n){m=!1,g&&(g=!1,b(N),N=-1),f=!0;var r=p;try{for(v(n),d=a(l);null!==d&&(!(d.expirationTime>n)||e&&!R());){var i=d.callback;if("function"===typeof i){d.callback=null,p=d.priorityLevel;var o=i(d.expirationTime<=n);n=t.unstable_now(),"function"===typeof o?d.callback=o:d===a(l)&&s(l),v(n)}else s(l);d=a(l)}if(null!==d)var c=!0;else{var h=a(u);null!==h&&D(w,h.startTime-n),c=!1}return c}finally{d=null,p=r,f=!1}}"undefined"!==typeof navigator&&void 0!==navigator.scheduling&&void 0!==navigator.scheduling.isInputPending&&navigator.scheduling.isInputPending.bind(navigator.scheduling);var S,C=!1,I=null,N=-1,T=5,E=-1;function R(){return!(t.unstable_now()-E<T)}function _(){if(null!==I){var e=t.unstable_now();E=e;var n=!0;try{n=I(!0,e)}finally{n?S():(C=!1,I=null)}}else C=!1}if("function"===typeof x)S=function(){x(_)};else if("undefined"!==typeof MessageChannel){var A=new MessageChannel,M=A.port2;A.port1.onmessage=_,S=function(){M.postMessage(null)}}else S=function(){y(_,0)};function P(e){I=e,C||(C=!0,S())}function D(e,n){N=y(function(){e(t.unstable_now())},n)}t.unstable_IdlePriority=5,t.unstable_ImmediatePriority=1,t.unstable_LowPriority=4,t.unstable_NormalPriority=3,t.unstable_Profiling=null,t.unstable_UserBlockingPriority=2,t.unstable_cancelCallback=function(e){e.callback=null},t.unstable_continueExecution=function(){m||f||(m=!0,P(k))},t.unstable_forceFrameRate=function(e){0>e||125<e?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):T=0<e?Math.floor(1e3/e):5},t.unstable_getCurrentPriorityLevel=function(){return p},t.unstable_getFirstCallbackNode=function(){return a(l)},t.unstable_next=function(e){switch(p){case 1:case 2:case 3:var t=3;break;default:t=p}var n=p;p=t;try{return e()}finally{p=n}},t.unstable_pauseExecution=function(){},t.unstable_requestPaint=function(){},t.unstable_runWithPriority=function(e,t){switch(e){case 1:case 2:case 3:case 4:case 5:break;default:e=3}var n=p;p=e;try{return t()}finally{p=n}},t.unstable_scheduleCallback=function(e,s,r){var i=t.unstable_now();switch("object"===typeof r&&null!==r?r="number"===typeof(r=r.delay)&&0<r?i+r:i:r=i,e){case 1:var o=-1;break;case 2:o=250;break;case 5:o=1073741823;break;case 4:o=1e4;break;default:o=5e3}return e={id:h++,callback:s,priorityLevel:e,startTime:r,expirationTime:o=r+o,sortIndex:-1},r>i?(e.sortIndex=r,n(u,e),null===a(l)&&e===a(u)&&(g?(b(N),N=-1):g=!0,D(w,r-i))):(e.sortIndex=o,n(l,e),m||f||(m=!0,P(k))),e},t.unstable_shouldYield=R,t.unstable_wrapCallback=function(e){var t=p;return function(){var n=p;p=t;try{return e.apply(this,arguments)}finally{p=n}}}},262(e,t,n){var a;!function(e,s){function r(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,a=t.d,s=t.a;return e=e<<25^e>>>7^n,n=n-a|0,a=a<<24^a>>>8^s,s=s-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-a|0,t.d=a<<16^n>>>16^s,t.a=s-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var a=0;a<n.length+20;a++)t.b^=0|n.charCodeAt(a),t.next()}function i(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function o(e,t){var n=new r(e),a=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,a&&("object"==typeof a&&i(a,n),s.state=function(){return i(n,{})}),s}s&&s.exports?s.exports=o:n.amdD&&n.amdO?void 0===(a=function(){return o}.call(t,n,t,s))||(s.exports=a):this.tychei=o}(0,e=n.nmd(e),n.amdD)},288(e,t,n){var a;!function(e,s){function r(e){var t=this;t.next=function(){var e,n,a=t.w,s=t.X,r=t.i;return t.w=a=a+1640531527|0,n=s[r+34&127],e=s[r=r+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=s[r]=n^e,t.i=r,n+(a^a>>>16)|0},function(e,t){var n,a,s,r,i,o=[],c=128;for(t===(0|t)?(a=t,t=null):(t+="\0",a=0,c=Math.max(c,t.length)),s=0,r=-32;r<c;++r)t&&(a^=t.charCodeAt((r+32)%t.length)),0===r&&(i=a),a^=a<<10,a^=a>>>15,a^=a<<4,a^=a>>>13,r>=0&&(i=i+1640531527|0,s=0==(n=o[127&r]^=a+i)?s+1:0);for(s>=128&&(o[127&(t&&t.length||0)]=-1),s=127,r=512;r>0;--r)a=o[s+34&127],n=o[s=s+1&127],a^=a<<13,n^=n<<17,a^=a>>>15,n^=n>>>12,o[s]=a^n;e.w=i,e.X=o,e.i=s}(t,e)}function i(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function o(e,t){null==e&&(e=+new Date);var n=new r(e),a=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,a&&(a.X&&i(a,n),s.state=function(){return i(n,{})}),s}s&&s.exports?s.exports=o:n.amdD&&n.amdO?void 0===(a=function(){return o}.call(t,n,t,s))||(s.exports=a):this.xor4096=o}(0,e=n.nmd(e),n.amdD)},334(e,t,n){var a=n(359),s=n(66),r=n(16),i=n(538),o=n(288),c=n(262),l=n(430);l.alea=a,l.xor128=s,l.xorwow=r,l.xorshift7=i,l.xor4096=o,l.tychei=c,e.exports=l},353(e){e.exports=n;var t=null;try{t=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(I){}function n(e,t,n){this.low=0|e,this.high=0|t,this.unsigned=!!n}function a(e){return!0===(e&&e.__isLong__)}n.prototype.__isLong__,Object.defineProperty(n.prototype,"__isLong__",{value:!0}),n.isLong=a;var s={},r={};function i(e,t){var n,a,i;return t?(i=0<=(e>>>=0)&&e<256)&&(a=r[e])?a:(n=c(e,(0|e)<0?-1:0,!0),i&&(r[e]=n),n):(i=-128<=(e|=0)&&e<128)&&(a=s[e])?a:(n=c(e,e<0?-1:0,!1),i&&(s[e]=n),n)}function o(e,t){if(isNaN(e))return t?y:g;if(t){if(e<0)return y;if(e>=p)return k}else{if(e<=-f)return S;if(e+1>=f)return w}return e<0?o(-e,t).neg():c(e%d|0,e/d|0,t)}function c(e,t,a){return new n(e,t,a)}n.fromInt=i,n.fromNumber=o,n.fromBits=c;var l=Math.pow;function u(e,t,n){if(0===e.length)throw Error("empty string");if("NaN"===e||"Infinity"===e||"+Infinity"===e||"-Infinity"===e)return g;if("number"===typeof t?(n=t,t=!1):t=!!t,(n=n||10)<2||36<n)throw RangeError("radix");var a;if((a=e.indexOf("-"))>0)throw Error("interior hyphen");if(0===a)return u(e.substring(1),t,n).neg();for(var s=o(l(n,8)),r=g,i=0;i<e.length;i+=8){var c=Math.min(8,e.length-i),h=parseInt(e.substring(i,i+c),n);if(c<8){var d=o(l(n,c));r=r.mul(d).add(o(h))}else r=(r=r.mul(s)).add(o(h))}return r.unsigned=t,r}function h(e,t){return"number"===typeof e?o(e,t):"string"===typeof e?u(e,t):c(e.low,e.high,"boolean"===typeof t?t:e.unsigned)}n.fromString=u,n.fromValue=h;var d=4294967296,p=d*d,f=p/2,m=i(1<<24),g=i(0);n.ZERO=g;var y=i(0,!0);n.UZERO=y;var b=i(1);n.ONE=b;var x=i(1,!0);n.UONE=x;var v=i(-1);n.NEG_ONE=v;var w=c(-1,2147483647,!1);n.MAX_VALUE=w;var k=c(-1,-1,!0);n.MAX_UNSIGNED_VALUE=k;var S=c(0,-2147483648,!1);n.MIN_VALUE=S;var C=n.prototype;C.toInt=function(){return this.unsigned?this.low>>>0:this.low},C.toNumber=function(){return this.unsigned?(this.high>>>0)*d+(this.low>>>0):this.high*d+(this.low>>>0)},C.toString=function(e){if((e=e||10)<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(S)){var t=o(e),n=this.div(t),a=n.mul(t).sub(this);return n.toString(e)+a.toInt().toString(e)}return"-"+this.neg().toString(e)}for(var s=o(l(e,6),this.unsigned),r=this,i="";;){var c=r.div(s),u=(r.sub(c.mul(s)).toInt()>>>0).toString(e);if((r=c).isZero())return u+i;for(;u.length<6;)u="0"+u;i=""+u+i}},C.getHighBits=function(){return this.high},C.getHighBitsUnsigned=function(){return this.high>>>0},C.getLowBits=function(){return this.low},C.getLowBitsUnsigned=function(){return this.low>>>0},C.getNumBitsAbs=function(){if(this.isNegative())return this.eq(S)?64:this.neg().getNumBitsAbs();for(var e=0!=this.high?this.high:this.low,t=31;t>0&&0==(e&1<<t);t--);return 0!=this.high?t+33:t+1},C.isZero=function(){return 0===this.high&&0===this.low},C.eqz=C.isZero,C.isNegative=function(){return!this.unsigned&&this.high<0},C.isPositive=function(){return this.unsigned||this.high>=0},C.isOdd=function(){return 1===(1&this.low)},C.isEven=function(){return 0===(1&this.low)},C.equals=function(e){return a(e)||(e=h(e)),(this.unsigned===e.unsigned||this.high>>>31!==1||e.high>>>31!==1)&&(this.high===e.high&&this.low===e.low)},C.eq=C.equals,C.notEquals=function(e){return!this.eq(e)},C.neq=C.notEquals,C.ne=C.notEquals,C.lessThan=function(e){return this.comp(e)<0},C.lt=C.lessThan,C.lessThanOrEqual=function(e){return this.comp(e)<=0},C.lte=C.lessThanOrEqual,C.le=C.lessThanOrEqual,C.greaterThan=function(e){return this.comp(e)>0},C.gt=C.greaterThan,C.greaterThanOrEqual=function(e){return this.comp(e)>=0},C.gte=C.greaterThanOrEqual,C.ge=C.greaterThanOrEqual,C.compare=function(e){if(a(e)||(e=h(e)),this.eq(e))return 0;var t=this.isNegative(),n=e.isNegative();return t&&!n?-1:!t&&n?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1},C.comp=C.compare,C.negate=function(){return!this.unsigned&&this.eq(S)?S:this.not().add(b)},C.neg=C.negate,C.add=function(e){a(e)||(e=h(e));var t=this.high>>>16,n=65535&this.high,s=this.low>>>16,r=65535&this.low,i=e.high>>>16,o=65535&e.high,l=e.low>>>16,u=0,d=0,p=0,f=0;return p+=(f+=r+(65535&e.low))>>>16,d+=(p+=s+l)>>>16,u+=(d+=n+o)>>>16,u+=t+i,c((p&=65535)<<16|(f&=65535),(u&=65535)<<16|(d&=65535),this.unsigned)},C.subtract=function(e){return a(e)||(e=h(e)),this.add(e.neg())},C.sub=C.subtract,C.multiply=function(e){if(this.isZero())return g;if(a(e)||(e=h(e)),t)return c(t.mul(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned);if(e.isZero())return g;if(this.eq(S))return e.isOdd()?S:g;if(e.eq(S))return this.isOdd()?S:g;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(m)&&e.lt(m))return o(this.toNumber()*e.toNumber(),this.unsigned);var n=this.high>>>16,s=65535&this.high,r=this.low>>>16,i=65535&this.low,l=e.high>>>16,u=65535&e.high,d=e.low>>>16,p=65535&e.low,f=0,y=0,b=0,x=0;return b+=(x+=i*p)>>>16,y+=(b+=r*p)>>>16,b&=65535,y+=(b+=i*d)>>>16,f+=(y+=s*p)>>>16,y&=65535,f+=(y+=r*d)>>>16,y&=65535,f+=(y+=i*u)>>>16,f+=n*p+s*d+r*u+i*l,c((b&=65535)<<16|(x&=65535),(f&=65535)<<16|(y&=65535),this.unsigned)},C.mul=C.multiply,C.divide=function(e){if(a(e)||(e=h(e)),e.isZero())throw Error("division by zero");var n,s,r;if(t)return this.unsigned||-2147483648!==this.high||-1!==e.low||-1!==e.high?c((this.unsigned?t.div_u:t.div_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?y:g;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return y;if(e.gt(this.shru(1)))return x;r=y}else{if(this.eq(S))return e.eq(b)||e.eq(v)?S:e.eq(S)?b:(n=this.shr(1).div(e).shl(1)).eq(g)?e.isNegative()?b:v:(s=this.sub(e.mul(n)),r=n.add(s.div(e)));if(e.eq(S))return this.unsigned?y:g;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();r=g}for(s=this;s.gte(e);){n=Math.max(1,Math.floor(s.toNumber()/e.toNumber()));for(var i=Math.ceil(Math.log(n)/Math.LN2),u=i<=48?1:l(2,i-48),d=o(n),p=d.mul(e);p.isNegative()||p.gt(s);)p=(d=o(n-=u,this.unsigned)).mul(e);d.isZero()&&(d=b),r=r.add(d),s=s.sub(p)}return r},C.div=C.divide,C.modulo=function(e){return a(e)||(e=h(e)),t?c((this.unsigned?t.rem_u:t.rem_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this.sub(this.div(e).mul(e))},C.mod=C.modulo,C.rem=C.modulo,C.not=function(){return c(~this.low,~this.high,this.unsigned)},C.and=function(e){return a(e)||(e=h(e)),c(this.low&e.low,this.high&e.high,this.unsigned)},C.or=function(e){return a(e)||(e=h(e)),c(this.low|e.low,this.high|e.high,this.unsigned)},C.xor=function(e){return a(e)||(e=h(e)),c(this.low^e.low,this.high^e.high,this.unsigned)},C.shiftLeft=function(e){return a(e)&&(e=e.toInt()),0===(e&=63)?this:e<32?c(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):c(0,this.low<<e-32,this.unsigned)},C.shl=C.shiftLeft,C.shiftRight=function(e){return a(e)&&(e=e.toInt()),0===(e&=63)?this:e<32?c(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):c(this.high>>e-32,this.high>=0?0:-1,this.unsigned)},C.shr=C.shiftRight,C.shiftRightUnsigned=function(e){if(a(e)&&(e=e.toInt()),0===(e&=63))return this;var t=this.high;return e<32?c(this.low>>>e|t<<32-e,t>>>e,this.unsigned):c(32===e?t:t>>>e-32,0,this.unsigned)},C.shru=C.shiftRightUnsigned,C.shr_u=C.shiftRightUnsigned,C.toSigned=function(){return this.unsigned?c(this.low,this.high,!1):this},C.toUnsigned=function(){return this.unsigned?this:c(this.low,this.high,!0)},C.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()},C.toBytesLE=function(){var e=this.high,t=this.low;return[255&t,t>>>8&255,t>>>16&255,t>>>24,255&e,e>>>8&255,e>>>16&255,e>>>24]},C.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,255&e,t>>>24,t>>>16&255,t>>>8&255,255&t]},n.fromBytes=function(e,t,a){return a?n.fromBytesLE(e,t):n.fromBytesBE(e,t)},n.fromBytesLE=function(e,t){return new n(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)},n.fromBytesBE=function(e,t){return new n(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)}},359(e,t,n){var a;!function(e,s){function r(e){var t=this,n=function(){var e=4022871197,t=function(t){t=String(t);for(var n=0;n<t.length;n++){var a=.02519603282416938*(e+=t.charCodeAt(n));a-=e=a>>>0,e=(a*=e)>>>0,e+=4294967296*(a-=e)}return 2.3283064365386963e-10*(e>>>0)};return t}();t.next=function(){var e=2091639*t.s0+2.3283064365386963e-10*t.c;return t.s0=t.s1,t.s1=t.s2,t.s2=e-(t.c=0|e)},t.c=1,t.s0=n(" "),t.s1=n(" "),t.s2=n(" "),t.s0-=n(e),t.s0<0&&(t.s0+=1),t.s1-=n(e),t.s1<0&&(t.s1+=1),t.s2-=n(e),t.s2<0&&(t.s2+=1),n=null}function i(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function o(e,t){var n=new r(e),a=t&&t.state,s=n.next;return s.int32=function(){return 4294967296*n.next()|0},s.double=function(){return s()+11102230246251565e-32*(2097152*s()|0)},s.quick=s,a&&("object"==typeof a&&i(a,n),s.state=function(){return i(n,{})}),s}s&&s.exports?s.exports=o:n.amdD&&n.amdO?void 0===(a=function(){return o}.call(t,n,t,s))||(s.exports=a):this.alea=o}(0,e=n.nmd(e),n.amdD)},391(e,t,n){"use strict";var a=n(950);t.createRoot=a.createRoot,t.hydrateRoot=a.hydrateRoot},430(e,t,n){var a;!function(s,r,i){var o,c=256,l=i.pow(c,6),u=i.pow(2,52),h=2*u,d=255;function p(e,t,n){var a=[],d=y(g((t=1==t?{entropy:!0}:t||{}).entropy?[e,b(r)]:null==e?function(){try{var e;return o&&(e=o.randomBytes)?e=e(c):(e=new Uint8Array(c),(s.crypto||s.msCrypto).getRandomValues(e)),b(e)}catch(a){var t=s.navigator,n=t&&t.plugins;return[+new Date,s,n,s.screen,b(r)]}}():e,3),a),p=new f(a),x=function(){for(var e=p.g(6),t=l,n=0;e<u;)e=(e+n)*c,t*=c,n=p.g(1);for(;e>=h;)e/=2,t/=2,n>>>=1;return(e+n)/t};return x.int32=function(){return 0|p.g(4)},x.quick=function(){return p.g(4)/4294967296},x.double=x,y(b(p.S),r),(t.pass||n||function(e,t,n,a){return a&&(a.S&&m(a,p),e.state=function(){return m(p,{})}),n?(i.random=e,t):e})(x,d,"global"in t?t.global:this==i,t.state)}function f(e){var t,n=e.length,a=this,s=0,r=a.i=a.j=0,i=a.S=[];for(n||(e=[n++]);s<c;)i[s]=s++;for(s=0;s<c;s++)i[s]=i[r=d&r+e[s%n]+(t=i[s])],i[r]=t;(a.g=function(e){for(var t,n=0,s=a.i,r=a.j,i=a.S;e--;)t=i[s=d&s+1],n=n*c+i[d&(i[s]=i[r=d&r+t])+(i[r]=t)];return a.i=s,a.j=r,n})(c)}function m(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function g(e,t){var n,a=[],s=typeof e;if(t&&"object"==s)for(n in e)try{a.push(g(e[n],t-1))}catch(r){}return a.length?a:"string"==s?e:e+"\0"}function y(e,t){for(var n,a=e+"",s=0;s<a.length;)t[d&s]=d&(n^=19*t[d&s])+a.charCodeAt(s++);return b(t)}function b(e){return String.fromCharCode.apply(0,e)}if(y(i.random(),r),e.exports){e.exports=p;try{o=n(996)}catch(x){}}else void 0===(a=function(){return p}.call(t,n,t,e))||(e.exports=a)}("undefined"!==typeof self?self:this,[],Math)},530(){},538(e,t,n){var a;!function(e,s){function r(e){var t=this;t.next=function(){var e,n,a=t.x,s=t.i;return e=a[s],n=(e^=e>>>7)^e<<24,n^=(e=a[s+1&7])^e>>>10,n^=(e=a[s+3&7])^e>>>3,n^=(e=a[s+4&7])^e<<7,e=a[s+7&7],n^=(e^=e<<13)^e<<9,a[s]=n,t.i=s+1&7,n},function(e,t){var n,a=[];if(t===(0|t))a[0]=t;else for(t=""+t,n=0;n<t.length;++n)a[7&n]=a[7&n]<<15^t.charCodeAt(n)+a[n+1&7]<<13;for(;a.length<8;)a.push(0);for(n=0;n<8&&0===a[n];++n);for(8==n?a[7]=-1:a[n],e.x=a,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function i(e,t){return t.x=e.x.slice(),t.i=e.i,t}function o(e,t){null==e&&(e=+new Date);var n=new r(e),a=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,a&&(a.x&&i(a,n),s.state=function(){return i(n,{})}),s}s&&s.exports?s.exports=o:n.amdD&&n.amdO?void 0===(a=function(){return o}.call(t,n,t,s))||(s.exports=a):this.xorshift7=o}(0,e=n.nmd(e),n.amdD)},551(){},579(e,t,n){"use strict";e.exports=n(153)},590(){},730(e,t,n){"use strict";var a=n(43),s=n(853);function r(e){for(var t="https://reactjs.org/docs/error-decoder.html?invariant="+e,n=1;n<arguments.length;n++)t+="&args[]="+encodeURIComponent(arguments[n]);return"Minified React error #"+e+"; visit "+t+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var i=new Set,o={};function c(e,t){l(e,t),l(e+"Capture",t)}function l(e,t){for(o[e]=t,e=0;e<t.length;e++)i.add(t[e])}var u=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),h=Object.prototype.hasOwnProperty,d=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,p={},f={};function m(e,t,n,a,s,r,i){this.acceptsBooleans=2===t||3===t||4===t,this.attributeName=a,this.attributeNamespace=s,this.mustUseProperty=n,this.propertyName=e,this.type=t,this.sanitizeURL=r,this.removeEmptyString=i}var g={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(e){g[e]=new m(e,0,!1,e,null,!1,!1)}),[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(e){var t=e[0];g[t]=new m(t,1,!1,e[1],null,!1,!1)}),["contentEditable","draggable","spellCheck","value"].forEach(function(e){g[e]=new m(e,2,!1,e.toLowerCase(),null,!1,!1)}),["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(e){g[e]=new m(e,2,!1,e,null,!1,!1)}),"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(e){g[e]=new m(e,3,!1,e.toLowerCase(),null,!1,!1)}),["checked","multiple","muted","selected"].forEach(function(e){g[e]=new m(e,3,!0,e,null,!1,!1)}),["capture","download"].forEach(function(e){g[e]=new m(e,4,!1,e,null,!1,!1)}),["cols","rows","size","span"].forEach(function(e){g[e]=new m(e,6,!1,e,null,!1,!1)}),["rowSpan","start"].forEach(function(e){g[e]=new m(e,5,!1,e.toLowerCase(),null,!1,!1)});var y=/[\-:]([a-z])/g;function b(e){return e[1].toUpperCase()}function x(e,t,n,a){var s=g.hasOwnProperty(t)?g[t]:null;(null!==s?0!==s.type:a||!(2<t.length)||"o"!==t[0]&&"O"!==t[0]||"n"!==t[1]&&"N"!==t[1])&&(function(e,t,n,a){if(null===t||"undefined"===typeof t||function(e,t,n,a){if(null!==n&&0===n.type)return!1;switch(typeof t){case"function":case"symbol":return!0;case"boolean":return!a&&(null!==n?!n.acceptsBooleans:"data-"!==(e=e.toLowerCase().slice(0,5))&&"aria-"!==e);default:return!1}}(e,t,n,a))return!0;if(a)return!1;if(null!==n)switch(n.type){case 3:return!t;case 4:return!1===t;case 5:return isNaN(t);case 6:return isNaN(t)||1>t}return!1}(t,n,s,a)&&(n=null),a||null===s?function(e){return!!h.call(f,e)||!h.call(p,e)&&(d.test(e)?f[e]=!0:(p[e]=!0,!1))}(t)&&(null===n?e.removeAttribute(t):e.setAttribute(t,""+n)):s.mustUseProperty?e[s.propertyName]=null===n?3!==s.type&&"":n:(t=s.attributeName,a=s.attributeNamespace,null===n?e.removeAttribute(t):(n=3===(s=s.type)||4===s&&!0===n?"":""+n,a?e.setAttributeNS(a,t,n):e.setAttribute(t,n))))}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(e){var t=e.replace(y,b);g[t]=new m(t,1,!1,e,null,!1,!1)}),"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(e){var t=e.replace(y,b);g[t]=new m(t,1,!1,e,"http://www.w3.org/1999/xlink",!1,!1)}),["xml:base","xml:lang","xml:space"].forEach(function(e){var t=e.replace(y,b);g[t]=new m(t,1,!1,e,"http://www.w3.org/XML/1998/namespace",!1,!1)}),["tabIndex","crossOrigin"].forEach(function(e){g[e]=new m(e,1,!1,e.toLowerCase(),null,!1,!1)}),g.xlinkHref=new m("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1),["src","href","action","formAction"].forEach(function(e){g[e]=new m(e,1,!1,e.toLowerCase(),null,!0,!0)});var v=a.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,w=Symbol.for("react.element"),k=Symbol.for("react.portal"),S=Symbol.for("react.fragment"),C=Symbol.for("react.strict_mode"),I=Symbol.for("react.profiler"),N=Symbol.for("react.provider"),T=Symbol.for("react.context"),E=Symbol.for("react.forward_ref"),R=Symbol.for("react.suspense"),_=Symbol.for("react.suspense_list"),A=Symbol.for("react.memo"),M=Symbol.for("react.lazy");Symbol.for("react.scope"),Symbol.for("react.debug_trace_mode");var P=Symbol.for("react.offscreen");Symbol.for("react.legacy_hidden"),Symbol.for("react.cache"),Symbol.for("react.tracing_marker");var D=Symbol.iterator;function O(e){return null===e||"object"!==typeof e?null:"function"===typeof(e=D&&e[D]||e["@@iterator"])?e:null}var F,L=Object.assign;function z(e){if(void 0===F)try{throw Error()}catch(n){var t=n.stack.trim().match(/\n( *(at )?)/);F=t&&t[1]||""}return"\n"+F+e}var B=!1;function j(e,t){if(!e||B)return"";B=!0;var n=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(t)if(t=function(){throw Error()},Object.defineProperty(t.prototype,"props",{set:function(){throw Error()}}),"object"===typeof Reflect&&Reflect.construct){try{Reflect.construct(t,[])}catch(l){var a=l}Reflect.construct(e,[],t)}else{try{t.call()}catch(l){a=l}e.call(t.prototype)}else{try{throw Error()}catch(l){a=l}e()}}catch(l){if(l&&a&&"string"===typeof l.stack){for(var s=l.stack.split("\n"),r=a.stack.split("\n"),i=s.length-1,o=r.length-1;1<=i&&0<=o&&s[i]!==r[o];)o--;for(;1<=i&&0<=o;i--,o--)if(s[i]!==r[o]){if(1!==i||1!==o)do{if(i--,0>--o||s[i]!==r[o]){var c="\n"+s[i].replace(" at new "," at ");return e.displayName&&c.includes("<anonymous>")&&(c=c.replace("<anonymous>",e.displayName)),c}}while(1<=i&&0<=o);break}}}finally{B=!1,Error.prepareStackTrace=n}return(e=e?e.displayName||e.name:"")?z(e):""}function W(e){switch(e.tag){case 5:return z(e.type);case 16:return z("Lazy");case 13:return z("Suspense");case 19:return z("SuspenseList");case 0:case 2:case 15:return e=j(e.type,!1);case 11:return e=j(e.type.render,!1);case 1:return e=j(e.type,!0);default:return""}}function V(e){if(null==e)return null;if("function"===typeof e)return e.displayName||e.name||null;if("string"===typeof e)return e;switch(e){case S:return"Fragment";case k:return"Portal";case I:return"Profiler";case C:return"StrictMode";case R:return"Suspense";case _:return"SuspenseList"}if("object"===typeof e)switch(e.$$typeof){case T:return(e.displayName||"Context")+".Consumer";case N:return(e._context.displayName||"Context")+".Provider";case E:var t=e.render;return(e=e.displayName)||(e=""!==(e=t.displayName||t.name||"")?"ForwardRef("+e+")":"ForwardRef"),e;case A:return null!==(t=e.displayName||null)?t:V(e.type)||"Memo";case M:t=e._payload,e=e._init;try{return V(e(t))}catch(n){}}return null}function U(e){var t=e.type;switch(e.tag){case 24:return"Cache";case 9:return(t.displayName||"Context")+".Consumer";case 10:return(t._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return e=(e=t.render).displayName||e.name||"",t.displayName||(""!==e?"ForwardRef("+e+")":"ForwardRef");case 7:return"Fragment";case 5:return t;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return V(t);case 8:return t===C?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if("function"===typeof t)return t.displayName||t.name||null;if("string"===typeof t)return t}return null}function H(e){switch(typeof e){case"boolean":case"number":case"string":case"undefined":case"object":return e;default:return""}}function G(e){var t=e.type;return(e=e.nodeName)&&"input"===e.toLowerCase()&&("checkbox"===t||"radio"===t)}function q(e){e._valueTracker||(e._valueTracker=function(e){var t=G(e)?"checked":"value",n=Object.getOwnPropertyDescriptor(e.constructor.prototype,t),a=""+e[t];if(!e.hasOwnProperty(t)&&"undefined"!==typeof n&&"function"===typeof n.get&&"function"===typeof n.set){var s=n.get,r=n.set;return Object.defineProperty(e,t,{configurable:!0,get:function(){return s.call(this)},set:function(e){a=""+e,r.call(this,e)}}),Object.defineProperty(e,t,{enumerable:n.enumerable}),{getValue:function(){return a},setValue:function(e){a=""+e},stopTracking:function(){e._valueTracker=null,delete e[t]}}}}(e))}function K(e){if(!e)return!1;var t=e._valueTracker;if(!t)return!0;var n=t.getValue(),a="";return e&&(a=G(e)?e.checked?"true":"false":e.value),(e=a)!==n&&(t.setValue(e),!0)}function X(e){if("undefined"===typeof(e=e||("undefined"!==typeof document?document:void 0)))return null;try{return e.activeElement||e.body}catch(t){return e.body}}function Y(e,t){var n=t.checked;return L({},t,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=n?n:e._wrapperState.initialChecked})}function Q(e,t){var n=null==t.defaultValue?"":t.defaultValue,a=null!=t.checked?t.checked:t.defaultChecked;n=H(null!=t.value?t.value:n),e._wrapperState={initialChecked:a,initialValue:n,controlled:"checkbox"===t.type||"radio"===t.type?null!=t.checked:null!=t.value}}function Z(e,t){null!=(t=t.checked)&&x(e,"checked",t,!1)}function J(e,t){Z(e,t);var n=H(t.value),a=t.type;if(null!=n)"number"===a?(0===n&&""===e.value||e.value!=n)&&(e.value=""+n):e.value!==""+n&&(e.value=""+n);else if("submit"===a||"reset"===a)return void e.removeAttribute("value");t.hasOwnProperty("value")?ee(e,t.type,n):t.hasOwnProperty("defaultValue")&&ee(e,t.type,H(t.defaultValue)),null==t.checked&&null!=t.defaultChecked&&(e.defaultChecked=!!t.defaultChecked)}function $(e,t,n){if(t.hasOwnProperty("value")||t.hasOwnProperty("defaultValue")){var a=t.type;if(!("submit"!==a&&"reset"!==a||void 0!==t.value&&null!==t.value))return;t=""+e._wrapperState.initialValue,n||t===e.value||(e.value=t),e.defaultValue=t}""!==(n=e.name)&&(e.name=""),e.defaultChecked=!!e._wrapperState.initialChecked,""!==n&&(e.name=n)}function ee(e,t,n){"number"===t&&X(e.ownerDocument)===e||(null==n?e.defaultValue=""+e._wrapperState.initialValue:e.defaultValue!==""+n&&(e.defaultValue=""+n))}var te=Array.isArray;function ne(e,t,n,a){if(e=e.options,t){t={};for(var s=0;s<n.length;s++)t["$"+n[s]]=!0;for(n=0;n<e.length;n++)s=t.hasOwnProperty("$"+e[n].value),e[n].selected!==s&&(e[n].selected=s),s&&a&&(e[n].defaultSelected=!0)}else{for(n=""+H(n),t=null,s=0;s<e.length;s++){if(e[s].value===n)return e[s].selected=!0,void(a&&(e[s].defaultSelected=!0));null!==t||e[s].disabled||(t=e[s])}null!==t&&(t.selected=!0)}}function ae(e,t){if(null!=t.dangerouslySetInnerHTML)throw Error(r(91));return L({},t,{value:void 0,defaultValue:void 0,children:""+e._wrapperState.initialValue})}function se(e,t){var n=t.value;if(null==n){if(n=t.children,t=t.defaultValue,null!=n){if(null!=t)throw Error(r(92));if(te(n)){if(1<n.length)throw Error(r(93));n=n[0]}t=n}null==t&&(t=""),n=t}e._wrapperState={initialValue:H(n)}}function re(e,t){var n=H(t.value),a=H(t.defaultValue);null!=n&&((n=""+n)!==e.value&&(e.value=n),null==t.defaultValue&&e.defaultValue!==n&&(e.defaultValue=n)),null!=a&&(e.defaultValue=""+a)}function ie(e){var t=e.textContent;t===e._wrapperState.initialValue&&""!==t&&null!==t&&(e.value=t)}function oe(e){switch(e){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function ce(e,t){return null==e||"http://www.w3.org/1999/xhtml"===e?oe(t):"http://www.w3.org/2000/svg"===e&&"foreignObject"===t?"http://www.w3.org/1999/xhtml":e}var le,ue,he=(ue=function(e,t){if("http://www.w3.org/2000/svg"!==e.namespaceURI||"innerHTML"in e)e.innerHTML=t;else{for((le=le||document.createElement("div")).innerHTML="<svg>"+t.valueOf().toString()+"</svg>",t=le.firstChild;e.firstChild;)e.removeChild(e.firstChild);for(;t.firstChild;)e.appendChild(t.firstChild)}},"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(e,t,n,a){MSApp.execUnsafeLocalFunction(function(){return ue(e,t)})}:ue);function de(e,t){if(t){var n=e.firstChild;if(n&&n===e.lastChild&&3===n.nodeType)return void(n.nodeValue=t)}e.textContent=t}var pe={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},fe=["Webkit","ms","Moz","O"];function me(e,t,n){return null==t||"boolean"===typeof t||""===t?"":n||"number"!==typeof t||0===t||pe.hasOwnProperty(e)&&pe[e]?(""+t).trim():t+"px"}function ge(e,t){for(var n in e=e.style,t)if(t.hasOwnProperty(n)){var a=0===n.indexOf("--"),s=me(n,t[n],a);"float"===n&&(n="cssFloat"),a?e.setProperty(n,s):e[n]=s}}Object.keys(pe).forEach(function(e){fe.forEach(function(t){t=t+e.charAt(0).toUpperCase()+e.substring(1),pe[t]=pe[e]})});var ye=L({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function be(e,t){if(t){if(ye[e]&&(null!=t.children||null!=t.dangerouslySetInnerHTML))throw Error(r(137,e));if(null!=t.dangerouslySetInnerHTML){if(null!=t.children)throw Error(r(60));if("object"!==typeof t.dangerouslySetInnerHTML||!("__html"in t.dangerouslySetInnerHTML))throw Error(r(61))}if(null!=t.style&&"object"!==typeof t.style)throw Error(r(62))}}function xe(e,t){if(-1===e.indexOf("-"))return"string"===typeof t.is;switch(e){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var ve=null;function we(e){return(e=e.target||e.srcElement||window).correspondingUseElement&&(e=e.correspondingUseElement),3===e.nodeType?e.parentNode:e}var ke=null,Se=null,Ce=null;function Ie(e){if(e=xs(e)){if("function"!==typeof ke)throw Error(r(280));var t=e.stateNode;t&&(t=ws(t),ke(e.stateNode,e.type,t))}}function Ne(e){Se?Ce?Ce.push(e):Ce=[e]:Se=e}function Te(){if(Se){var e=Se,t=Ce;if(Ce=Se=null,Ie(e),t)for(e=0;e<t.length;e++)Ie(t[e])}}function Ee(e,t){return e(t)}function Re(){}var _e=!1;function Ae(e,t,n){if(_e)return e(t,n);_e=!0;try{return Ee(e,t,n)}finally{_e=!1,(null!==Se||null!==Ce)&&(Re(),Te())}}function Me(e,t){var n=e.stateNode;if(null===n)return null;var a=ws(n);if(null===a)return null;n=a[t];e:switch(t){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(a=!a.disabled)||(a=!("button"===(e=e.type)||"input"===e||"select"===e||"textarea"===e)),e=!a;break e;default:e=!1}if(e)return null;if(n&&"function"!==typeof n)throw Error(r(231,t,typeof n));return n}var Pe=!1;if(u)try{var De={};Object.defineProperty(De,"passive",{get:function(){Pe=!0}}),window.addEventListener("test",De,De),window.removeEventListener("test",De,De)}catch(ue){Pe=!1}function Oe(e,t,n,a,s,r,i,o,c){var l=Array.prototype.slice.call(arguments,3);try{t.apply(n,l)}catch(u){this.onError(u)}}var Fe=!1,Le=null,ze=!1,Be=null,je={onError:function(e){Fe=!0,Le=e}};function We(e,t,n,a,s,r,i,o,c){Fe=!1,Le=null,Oe.apply(je,arguments)}function Ve(e){var t=e,n=e;if(e.alternate)for(;t.return;)t=t.return;else{e=t;do{0!==(4098&(t=e).flags)&&(n=t.return),e=t.return}while(e)}return 3===t.tag?n:null}function Ue(e){if(13===e.tag){var t=e.memoizedState;if(null===t&&(null!==(e=e.alternate)&&(t=e.memoizedState)),null!==t)return t.dehydrated}return null}function He(e){if(Ve(e)!==e)throw Error(r(188))}function Ge(e){return null!==(e=function(e){var t=e.alternate;if(!t){if(null===(t=Ve(e)))throw Error(r(188));return t!==e?null:e}for(var n=e,a=t;;){var s=n.return;if(null===s)break;var i=s.alternate;if(null===i){if(null!==(a=s.return)){n=a;continue}break}if(s.child===i.child){for(i=s.child;i;){if(i===n)return He(s),e;if(i===a)return He(s),t;i=i.sibling}throw Error(r(188))}if(n.return!==a.return)n=s,a=i;else{for(var o=!1,c=s.child;c;){if(c===n){o=!0,n=s,a=i;break}if(c===a){o=!0,a=s,n=i;break}c=c.sibling}if(!o){for(c=i.child;c;){if(c===n){o=!0,n=i,a=s;break}if(c===a){o=!0,a=i,n=s;break}c=c.sibling}if(!o)throw Error(r(189))}}if(n.alternate!==a)throw Error(r(190))}if(3!==n.tag)throw Error(r(188));return n.stateNode.current===n?e:t}(e))?qe(e):null}function qe(e){if(5===e.tag||6===e.tag)return e;for(e=e.child;null!==e;){var t=qe(e);if(null!==t)return t;e=e.sibling}return null}var Ke=s.unstable_scheduleCallback,Xe=s.unstable_cancelCallback,Ye=s.unstable_shouldYield,Qe=s.unstable_requestPaint,Ze=s.unstable_now,Je=s.unstable_getCurrentPriorityLevel,$e=s.unstable_ImmediatePriority,et=s.unstable_UserBlockingPriority,tt=s.unstable_NormalPriority,nt=s.unstable_LowPriority,at=s.unstable_IdlePriority,st=null,rt=null;var it=Math.clz32?Math.clz32:function(e){return e>>>=0,0===e?32:31-(ot(e)/ct|0)|0},ot=Math.log,ct=Math.LN2;var lt=64,ut=4194304;function ht(e){switch(e&-e){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return 4194240&e;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return 130023424&e;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return e}}function dt(e,t){var n=e.pendingLanes;if(0===n)return 0;var a=0,s=e.suspendedLanes,r=e.pingedLanes,i=268435455&n;if(0!==i){var o=i&~s;0!==o?a=ht(o):0!==(r&=i)&&(a=ht(r))}else 0!==(i=n&~s)?a=ht(i):0!==r&&(a=ht(r));if(0===a)return 0;if(0!==t&&t!==a&&0===(t&s)&&((s=a&-a)>=(r=t&-t)||16===s&&0!==(4194240&r)))return t;if(0!==(4&a)&&(a|=16&n),0!==(t=e.entangledLanes))for(e=e.entanglements,t&=a;0<t;)s=1<<(n=31-it(t)),a|=e[n],t&=~s;return a}function pt(e,t){switch(e){case 1:case 2:case 4:return t+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return t+5e3;default:return-1}}function ft(e){return 0!==(e=-1073741825&e.pendingLanes)?e:1073741824&e?1073741824:0}function mt(){var e=lt;return 0===(4194240&(lt<<=1))&&(lt=64),e}function gt(e){for(var t=[],n=0;31>n;n++)t.push(e);return t}function yt(e,t,n){e.pendingLanes|=t,536870912!==t&&(e.suspendedLanes=0,e.pingedLanes=0),(e=e.eventTimes)[t=31-it(t)]=n}function bt(e,t){var n=e.entangledLanes|=t;for(e=e.entanglements;n;){var a=31-it(n),s=1<<a;s&t|e[a]&t&&(e[a]|=t),n&=~s}}var xt=0;function vt(e){return 1<(e&=-e)?4<e?0!==(268435455&e)?16:536870912:4:1}var wt,kt,St,Ct,It,Nt=!1,Tt=[],Et=null,Rt=null,_t=null,At=new Map,Mt=new Map,Pt=[],Dt="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function Ot(e,t){switch(e){case"focusin":case"focusout":Et=null;break;case"dragenter":case"dragleave":Rt=null;break;case"mouseover":case"mouseout":_t=null;break;case"pointerover":case"pointerout":At.delete(t.pointerId);break;case"gotpointercapture":case"lostpointercapture":Mt.delete(t.pointerId)}}function Ft(e,t,n,a,s,r){return null===e||e.nativeEvent!==r?(e={blockedOn:t,domEventName:n,eventSystemFlags:a,nativeEvent:r,targetContainers:[s]},null!==t&&(null!==(t=xs(t))&&kt(t)),e):(e.eventSystemFlags|=a,t=e.targetContainers,null!==s&&-1===t.indexOf(s)&&t.push(s),e)}function Lt(e){var t=bs(e.target);if(null!==t){var n=Ve(t);if(null!==n)if(13===(t=n.tag)){if(null!==(t=Ue(n)))return e.blockedOn=t,void It(e.priority,function(){St(n)})}else if(3===t&&n.stateNode.current.memoizedState.isDehydrated)return void(e.blockedOn=3===n.tag?n.stateNode.containerInfo:null)}e.blockedOn=null}function zt(e){if(null!==e.blockedOn)return!1;for(var t=e.targetContainers;0<t.length;){var n=Yt(e.domEventName,e.eventSystemFlags,t[0],e.nativeEvent);if(null!==n)return null!==(t=xs(n))&&kt(t),e.blockedOn=n,!1;var a=new(n=e.nativeEvent).constructor(n.type,n);ve=a,n.target.dispatchEvent(a),ve=null,t.shift()}return!0}function Bt(e,t,n){zt(e)&&n.delete(t)}function jt(){Nt=!1,null!==Et&&zt(Et)&&(Et=null),null!==Rt&&zt(Rt)&&(Rt=null),null!==_t&&zt(_t)&&(_t=null),At.forEach(Bt),Mt.forEach(Bt)}function Wt(e,t){e.blockedOn===t&&(e.blockedOn=null,Nt||(Nt=!0,s.unstable_scheduleCallback(s.unstable_NormalPriority,jt)))}function Vt(e){function t(t){return Wt(t,e)}if(0<Tt.length){Wt(Tt[0],e);for(var n=1;n<Tt.length;n++){var a=Tt[n];a.blockedOn===e&&(a.blockedOn=null)}}for(null!==Et&&Wt(Et,e),null!==Rt&&Wt(Rt,e),null!==_t&&Wt(_t,e),At.forEach(t),Mt.forEach(t),n=0;n<Pt.length;n++)(a=Pt[n]).blockedOn===e&&(a.blockedOn=null);for(;0<Pt.length&&null===(n=Pt[0]).blockedOn;)Lt(n),null===n.blockedOn&&Pt.shift()}var Ut=v.ReactCurrentBatchConfig,Ht=!0;function Gt(e,t,n,a){var s=xt,r=Ut.transition;Ut.transition=null;try{xt=1,Kt(e,t,n,a)}finally{xt=s,Ut.transition=r}}function qt(e,t,n,a){var s=xt,r=Ut.transition;Ut.transition=null;try{xt=4,Kt(e,t,n,a)}finally{xt=s,Ut.transition=r}}function Kt(e,t,n,a){if(Ht){var s=Yt(e,t,n,a);if(null===s)Ha(e,t,a,Xt,n),Ot(e,a);else if(function(e,t,n,a,s){switch(t){case"focusin":return Et=Ft(Et,e,t,n,a,s),!0;case"dragenter":return Rt=Ft(Rt,e,t,n,a,s),!0;case"mouseover":return _t=Ft(_t,e,t,n,a,s),!0;case"pointerover":var r=s.pointerId;return At.set(r,Ft(At.get(r)||null,e,t,n,a,s)),!0;case"gotpointercapture":return r=s.pointerId,Mt.set(r,Ft(Mt.get(r)||null,e,t,n,a,s)),!0}return!1}(s,e,t,n,a))a.stopPropagation();else if(Ot(e,a),4&t&&-1<Dt.indexOf(e)){for(;null!==s;){var r=xs(s);if(null!==r&&wt(r),null===(r=Yt(e,t,n,a))&&Ha(e,t,a,Xt,n),r===s)break;s=r}null!==s&&a.stopPropagation()}else Ha(e,t,a,null,n)}}var Xt=null;function Yt(e,t,n,a){if(Xt=null,null!==(e=bs(e=we(a))))if(null===(t=Ve(e)))e=null;else if(13===(n=t.tag)){if(null!==(e=Ue(t)))return e;e=null}else if(3===n){if(t.stateNode.current.memoizedState.isDehydrated)return 3===t.tag?t.stateNode.containerInfo:null;e=null}else t!==e&&(e=null);return Xt=e,null}function Qt(e){switch(e){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 1;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 4;case"message":switch(Je()){case $e:return 1;case et:return 4;case tt:case nt:return 16;case at:return 536870912;default:return 16}default:return 16}}var Zt=null,Jt=null,$t=null;function en(){if($t)return $t;var e,t,n=Jt,a=n.length,s="value"in Zt?Zt.value:Zt.textContent,r=s.length;for(e=0;e<a&&n[e]===s[e];e++);var i=a-e;for(t=1;t<=i&&n[a-t]===s[r-t];t++);return $t=s.slice(e,1<t?1-t:void 0)}function tn(e){var t=e.keyCode;return"charCode"in e?0===(e=e.charCode)&&13===t&&(e=13):e=t,10===e&&(e=13),32<=e||13===e?e:0}function nn(){return!0}function an(){return!1}function sn(e){function t(t,n,a,s,r){for(var i in this._reactName=t,this._targetInst=a,this.type=n,this.nativeEvent=s,this.target=r,this.currentTarget=null,e)e.hasOwnProperty(i)&&(t=e[i],this[i]=t?t(s):s[i]);return this.isDefaultPrevented=(null!=s.defaultPrevented?s.defaultPrevented:!1===s.returnValue)?nn:an,this.isPropagationStopped=an,this}return L(t.prototype,{preventDefault:function(){this.defaultPrevented=!0;var e=this.nativeEvent;e&&(e.preventDefault?e.preventDefault():"unknown"!==typeof e.returnValue&&(e.returnValue=!1),this.isDefaultPrevented=nn)},stopPropagation:function(){var e=this.nativeEvent;e&&(e.stopPropagation?e.stopPropagation():"unknown"!==typeof e.cancelBubble&&(e.cancelBubble=!0),this.isPropagationStopped=nn)},persist:function(){},isPersistent:nn}),t}var rn,on,cn,ln={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(e){return e.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},un=sn(ln),hn=L({},ln,{view:0,detail:0}),dn=sn(hn),pn=L({},hn,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:In,button:0,buttons:0,relatedTarget:function(e){return void 0===e.relatedTarget?e.fromElement===e.srcElement?e.toElement:e.fromElement:e.relatedTarget},movementX:function(e){return"movementX"in e?e.movementX:(e!==cn&&(cn&&"mousemove"===e.type?(rn=e.screenX-cn.screenX,on=e.screenY-cn.screenY):on=rn=0,cn=e),rn)},movementY:function(e){return"movementY"in e?e.movementY:on}}),fn=sn(pn),mn=sn(L({},pn,{dataTransfer:0})),gn=sn(L({},hn,{relatedTarget:0})),yn=sn(L({},ln,{animationName:0,elapsedTime:0,pseudoElement:0})),bn=L({},ln,{clipboardData:function(e){return"clipboardData"in e?e.clipboardData:window.clipboardData}}),xn=sn(bn),vn=sn(L({},ln,{data:0})),wn={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},kn={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},Sn={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function Cn(e){var t=this.nativeEvent;return t.getModifierState?t.getModifierState(e):!!(e=Sn[e])&&!!t[e]}function In(){return Cn}var Nn=L({},hn,{key:function(e){if(e.key){var t=wn[e.key]||e.key;if("Unidentified"!==t)return t}return"keypress"===e.type?13===(e=tn(e))?"Enter":String.fromCharCode(e):"keydown"===e.type||"keyup"===e.type?kn[e.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:In,charCode:function(e){return"keypress"===e.type?tn(e):0},keyCode:function(e){return"keydown"===e.type||"keyup"===e.type?e.keyCode:0},which:function(e){return"keypress"===e.type?tn(e):"keydown"===e.type||"keyup"===e.type?e.keyCode:0}}),Tn=sn(Nn),En=sn(L({},pn,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0})),Rn=sn(L({},hn,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:In})),_n=sn(L({},ln,{propertyName:0,elapsedTime:0,pseudoElement:0})),An=L({},pn,{deltaX:function(e){return"deltaX"in e?e.deltaX:"wheelDeltaX"in e?-e.wheelDeltaX:0},deltaY:function(e){return"deltaY"in e?e.deltaY:"wheelDeltaY"in e?-e.wheelDeltaY:"wheelDelta"in e?-e.wheelDelta:0},deltaZ:0,deltaMode:0}),Mn=sn(An),Pn=[9,13,27,32],Dn=u&&"CompositionEvent"in window,On=null;u&&"documentMode"in document&&(On=document.documentMode);var Fn=u&&"TextEvent"in window&&!On,Ln=u&&(!Dn||On&&8<On&&11>=On),zn=String.fromCharCode(32),Bn=!1;function jn(e,t){switch(e){case"keyup":return-1!==Pn.indexOf(t.keyCode);case"keydown":return 229!==t.keyCode;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function Wn(e){return"object"===typeof(e=e.detail)&&"data"in e?e.data:null}var Vn=!1;var Un={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function Hn(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return"input"===t?!!Un[e.type]:"textarea"===t}function Gn(e,t,n,a){Ne(a),0<(t=qa(t,"onChange")).length&&(n=new un("onChange","change",null,n,a),e.push({event:n,listeners:t}))}var qn=null,Kn=null;function Xn(e){za(e,0)}function Yn(e){if(K(vs(e)))return e}function Qn(e,t){if("change"===e)return t}var Zn=!1;if(u){var Jn;if(u){var $n="oninput"in document;if(!$n){var ea=document.createElement("div");ea.setAttribute("oninput","return;"),$n="function"===typeof ea.oninput}Jn=$n}else Jn=!1;Zn=Jn&&(!document.documentMode||9<document.documentMode)}function ta(){qn&&(qn.detachEvent("onpropertychange",na),Kn=qn=null)}function na(e){if("value"===e.propertyName&&Yn(Kn)){var t=[];Gn(t,Kn,e,we(e)),Ae(Xn,t)}}function aa(e,t,n){"focusin"===e?(ta(),Kn=n,(qn=t).attachEvent("onpropertychange",na)):"focusout"===e&&ta()}function sa(e){if("selectionchange"===e||"keyup"===e||"keydown"===e)return Yn(Kn)}function ra(e,t){if("click"===e)return Yn(t)}function ia(e,t){if("input"===e||"change"===e)return Yn(t)}var oa="function"===typeof Object.is?Object.is:function(e,t){return e===t&&(0!==e||1/e===1/t)||e!==e&&t!==t};function ca(e,t){if(oa(e,t))return!0;if("object"!==typeof e||null===e||"object"!==typeof t||null===t)return!1;var n=Object.keys(e),a=Object.keys(t);if(n.length!==a.length)return!1;for(a=0;a<n.length;a++){var s=n[a];if(!h.call(t,s)||!oa(e[s],t[s]))return!1}return!0}function la(e){for(;e&&e.firstChild;)e=e.firstChild;return e}function ua(e,t){var n,a=la(e);for(e=0;a;){if(3===a.nodeType){if(n=e+a.textContent.length,e<=t&&n>=t)return{node:a,offset:t-e};e=n}e:{for(;a;){if(a.nextSibling){a=a.nextSibling;break e}a=a.parentNode}a=void 0}a=la(a)}}function ha(e,t){return!(!e||!t)&&(e===t||(!e||3!==e.nodeType)&&(t&&3===t.nodeType?ha(e,t.parentNode):"contains"in e?e.contains(t):!!e.compareDocumentPosition&&!!(16&e.compareDocumentPosition(t))))}function da(){for(var e=window,t=X();t instanceof e.HTMLIFrameElement;){try{var n="string"===typeof t.contentWindow.location.href}catch(a){n=!1}if(!n)break;t=X((e=t.contentWindow).document)}return t}function pa(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return t&&("input"===t&&("text"===e.type||"search"===e.type||"tel"===e.type||"url"===e.type||"password"===e.type)||"textarea"===t||"true"===e.contentEditable)}function fa(e){var t=da(),n=e.focusedElem,a=e.selectionRange;if(t!==n&&n&&n.ownerDocument&&ha(n.ownerDocument.documentElement,n)){if(null!==a&&pa(n))if(t=a.start,void 0===(e=a.end)&&(e=t),"selectionStart"in n)n.selectionStart=t,n.selectionEnd=Math.min(e,n.value.length);else if((e=(t=n.ownerDocument||document)&&t.defaultView||window).getSelection){e=e.getSelection();var s=n.textContent.length,r=Math.min(a.start,s);a=void 0===a.end?r:Math.min(a.end,s),!e.extend&&r>a&&(s=a,a=r,r=s),s=ua(n,r);var i=ua(n,a);s&&i&&(1!==e.rangeCount||e.anchorNode!==s.node||e.anchorOffset!==s.offset||e.focusNode!==i.node||e.focusOffset!==i.offset)&&((t=t.createRange()).setStart(s.node,s.offset),e.removeAllRanges(),r>a?(e.addRange(t),e.extend(i.node,i.offset)):(t.setEnd(i.node,i.offset),e.addRange(t)))}for(t=[],e=n;e=e.parentNode;)1===e.nodeType&&t.push({element:e,left:e.scrollLeft,top:e.scrollTop});for("function"===typeof n.focus&&n.focus(),n=0;n<t.length;n++)(e=t[n]).element.scrollLeft=e.left,e.element.scrollTop=e.top}}var ma=u&&"documentMode"in document&&11>=document.documentMode,ga=null,ya=null,ba=null,xa=!1;function va(e,t,n){var a=n.window===n?n.document:9===n.nodeType?n:n.ownerDocument;xa||null==ga||ga!==X(a)||("selectionStart"in(a=ga)&&pa(a)?a={start:a.selectionStart,end:a.selectionEnd}:a={anchorNode:(a=(a.ownerDocument&&a.ownerDocument.defaultView||window).getSelection()).anchorNode,anchorOffset:a.anchorOffset,focusNode:a.focusNode,focusOffset:a.focusOffset},ba&&ca(ba,a)||(ba=a,0<(a=qa(ya,"onSelect")).length&&(t=new un("onSelect","select",null,t,n),e.push({event:t,listeners:a}),t.target=ga)))}function wa(e,t){var n={};return n[e.toLowerCase()]=t.toLowerCase(),n["Webkit"+e]="webkit"+t,n["Moz"+e]="moz"+t,n}var ka={animationend:wa("Animation","AnimationEnd"),animationiteration:wa("Animation","AnimationIteration"),animationstart:wa("Animation","AnimationStart"),transitionend:wa("Transition","TransitionEnd")},Sa={},Ca={};function Ia(e){if(Sa[e])return Sa[e];if(!ka[e])return e;var t,n=ka[e];for(t in n)if(n.hasOwnProperty(t)&&t in Ca)return Sa[e]=n[t];return e}u&&(Ca=document.createElement("div").style,"AnimationEvent"in window||(delete ka.animationend.animation,delete ka.animationiteration.animation,delete ka.animationstart.animation),"TransitionEvent"in window||delete ka.transitionend.transition);var Na=Ia("animationend"),Ta=Ia("animationiteration"),Ea=Ia("animationstart"),Ra=Ia("transitionend"),_a=new Map,Aa="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function Ma(e,t){_a.set(e,t),c(t,[e])}for(var Pa=0;Pa<Aa.length;Pa++){var Da=Aa[Pa];Ma(Da.toLowerCase(),"on"+(Da[0].toUpperCase()+Da.slice(1)))}Ma(Na,"onAnimationEnd"),Ma(Ta,"onAnimationIteration"),Ma(Ea,"onAnimationStart"),Ma("dblclick","onDoubleClick"),Ma("focusin","onFocus"),Ma("focusout","onBlur"),Ma(Ra,"onTransitionEnd"),l("onMouseEnter",["mouseout","mouseover"]),l("onMouseLeave",["mouseout","mouseover"]),l("onPointerEnter",["pointerout","pointerover"]),l("onPointerLeave",["pointerout","pointerover"]),c("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),c("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),c("onBeforeInput",["compositionend","keypress","textInput","paste"]),c("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),c("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),c("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var Oa="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Fa=new Set("cancel close invalid load scroll toggle".split(" ").concat(Oa));function La(e,t,n){var a=e.type||"unknown-event";e.currentTarget=n,function(e,t,n,a,s,i,o,c,l){if(We.apply(this,arguments),Fe){if(!Fe)throw Error(r(198));var u=Le;Fe=!1,Le=null,ze||(ze=!0,Be=u)}}(a,t,void 0,e),e.currentTarget=null}function za(e,t){t=0!==(4&t);for(var n=0;n<e.length;n++){var a=e[n],s=a.event;a=a.listeners;e:{var r=void 0;if(t)for(var i=a.length-1;0<=i;i--){var o=a[i],c=o.instance,l=o.currentTarget;if(o=o.listener,c!==r&&s.isPropagationStopped())break e;La(s,o,l),r=c}else for(i=0;i<a.length;i++){if(c=(o=a[i]).instance,l=o.currentTarget,o=o.listener,c!==r&&s.isPropagationStopped())break e;La(s,o,l),r=c}}}if(ze)throw e=Be,ze=!1,Be=null,e}function Ba(e,t){var n=t[ms];void 0===n&&(n=t[ms]=new Set);var a=e+"__bubble";n.has(a)||(Ua(t,e,2,!1),n.add(a))}function ja(e,t,n){var a=0;t&&(a|=4),Ua(n,e,a,t)}var Wa="_reactListening"+Math.random().toString(36).slice(2);function Va(e){if(!e[Wa]){e[Wa]=!0,i.forEach(function(t){"selectionchange"!==t&&(Fa.has(t)||ja(t,!1,e),ja(t,!0,e))});var t=9===e.nodeType?e:e.ownerDocument;null===t||t[Wa]||(t[Wa]=!0,ja("selectionchange",!1,t))}}function Ua(e,t,n,a){switch(Qt(t)){case 1:var s=Gt;break;case 4:s=qt;break;default:s=Kt}n=s.bind(null,t,n,e),s=void 0,!Pe||"touchstart"!==t&&"touchmove"!==t&&"wheel"!==t||(s=!0),a?void 0!==s?e.addEventListener(t,n,{capture:!0,passive:s}):e.addEventListener(t,n,!0):void 0!==s?e.addEventListener(t,n,{passive:s}):e.addEventListener(t,n,!1)}function Ha(e,t,n,a,s){var r=a;if(0===(1&t)&&0===(2&t)&&null!==a)e:for(;;){if(null===a)return;var i=a.tag;if(3===i||4===i){var o=a.stateNode.containerInfo;if(o===s||8===o.nodeType&&o.parentNode===s)break;if(4===i)for(i=a.return;null!==i;){var c=i.tag;if((3===c||4===c)&&((c=i.stateNode.containerInfo)===s||8===c.nodeType&&c.parentNode===s))return;i=i.return}for(;null!==o;){if(null===(i=bs(o)))return;if(5===(c=i.tag)||6===c){a=r=i;continue e}o=o.parentNode}}a=a.return}Ae(function(){var a=r,s=we(n),i=[];e:{var o=_a.get(e);if(void 0!==o){var c=un,l=e;switch(e){case"keypress":if(0===tn(n))break e;case"keydown":case"keyup":c=Tn;break;case"focusin":l="focus",c=gn;break;case"focusout":l="blur",c=gn;break;case"beforeblur":case"afterblur":c=gn;break;case"click":if(2===n.button)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":c=fn;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":c=mn;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":c=Rn;break;case Na:case Ta:case Ea:c=yn;break;case Ra:c=_n;break;case"scroll":c=dn;break;case"wheel":c=Mn;break;case"copy":case"cut":case"paste":c=xn;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":c=En}var u=0!==(4&t),h=!u&&"scroll"===e,d=u?null!==o?o+"Capture":null:o;u=[];for(var p,f=a;null!==f;){var m=(p=f).stateNode;if(5===p.tag&&null!==m&&(p=m,null!==d&&(null!=(m=Me(f,d))&&u.push(Ga(f,m,p)))),h)break;f=f.return}0<u.length&&(o=new c(o,l,null,n,s),i.push({event:o,listeners:u}))}}if(0===(7&t)){if(c="mouseout"===e||"pointerout"===e,(!(o="mouseover"===e||"pointerover"===e)||n===ve||!(l=n.relatedTarget||n.fromElement)||!bs(l)&&!l[fs])&&(c||o)&&(o=s.window===s?s:(o=s.ownerDocument)?o.defaultView||o.parentWindow:window,c?(c=a,null!==(l=(l=n.relatedTarget||n.toElement)?bs(l):null)&&(l!==(h=Ve(l))||5!==l.tag&&6!==l.tag)&&(l=null)):(c=null,l=a),c!==l)){if(u=fn,m="onMouseLeave",d="onMouseEnter",f="mouse","pointerout"!==e&&"pointerover"!==e||(u=En,m="onPointerLeave",d="onPointerEnter",f="pointer"),h=null==c?o:vs(c),p=null==l?o:vs(l),(o=new u(m,f+"leave",c,n,s)).target=h,o.relatedTarget=p,m=null,bs(s)===a&&((u=new u(d,f+"enter",l,n,s)).target=p,u.relatedTarget=h,m=u),h=m,c&&l)e:{for(d=l,f=0,p=u=c;p;p=Ka(p))f++;for(p=0,m=d;m;m=Ka(m))p++;for(;0<f-p;)u=Ka(u),f--;for(;0<p-f;)d=Ka(d),p--;for(;f--;){if(u===d||null!==d&&u===d.alternate)break e;u=Ka(u),d=Ka(d)}u=null}else u=null;null!==c&&Xa(i,o,c,u,!1),null!==l&&null!==h&&Xa(i,h,l,u,!0)}if("select"===(c=(o=a?vs(a):window).nodeName&&o.nodeName.toLowerCase())||"input"===c&&"file"===o.type)var g=Qn;else if(Hn(o))if(Zn)g=ia;else{g=sa;var y=aa}else(c=o.nodeName)&&"input"===c.toLowerCase()&&("checkbox"===o.type||"radio"===o.type)&&(g=ra);switch(g&&(g=g(e,a))?Gn(i,g,n,s):(y&&y(e,o,a),"focusout"===e&&(y=o._wrapperState)&&y.controlled&&"number"===o.type&&ee(o,"number",o.value)),y=a?vs(a):window,e){case"focusin":(Hn(y)||"true"===y.contentEditable)&&(ga=y,ya=a,ba=null);break;case"focusout":ba=ya=ga=null;break;case"mousedown":xa=!0;break;case"contextmenu":case"mouseup":case"dragend":xa=!1,va(i,n,s);break;case"selectionchange":if(ma)break;case"keydown":case"keyup":va(i,n,s)}var b;if(Dn)e:{switch(e){case"compositionstart":var x="onCompositionStart";break e;case"compositionend":x="onCompositionEnd";break e;case"compositionupdate":x="onCompositionUpdate";break e}x=void 0}else Vn?jn(e,n)&&(x="onCompositionEnd"):"keydown"===e&&229===n.keyCode&&(x="onCompositionStart");x&&(Ln&&"ko"!==n.locale&&(Vn||"onCompositionStart"!==x?"onCompositionEnd"===x&&Vn&&(b=en()):(Jt="value"in(Zt=s)?Zt.value:Zt.textContent,Vn=!0)),0<(y=qa(a,x)).length&&(x=new vn(x,e,null,n,s),i.push({event:x,listeners:y}),b?x.data=b:null!==(b=Wn(n))&&(x.data=b))),(b=Fn?function(e,t){switch(e){case"compositionend":return Wn(t);case"keypress":return 32!==t.which?null:(Bn=!0,zn);case"textInput":return(e=t.data)===zn&&Bn?null:e;default:return null}}(e,n):function(e,t){if(Vn)return"compositionend"===e||!Dn&&jn(e,t)?(e=en(),$t=Jt=Zt=null,Vn=!1,e):null;switch(e){case"paste":default:return null;case"keypress":if(!(t.ctrlKey||t.altKey||t.metaKey)||t.ctrlKey&&t.altKey){if(t.char&&1<t.char.length)return t.char;if(t.which)return String.fromCharCode(t.which)}return null;case"compositionend":return Ln&&"ko"!==t.locale?null:t.data}}(e,n))&&(0<(a=qa(a,"onBeforeInput")).length&&(s=new vn("onBeforeInput","beforeinput",null,n,s),i.push({event:s,listeners:a}),s.data=b))}za(i,t)})}function Ga(e,t,n){return{instance:e,listener:t,currentTarget:n}}function qa(e,t){for(var n=t+"Capture",a=[];null!==e;){var s=e,r=s.stateNode;5===s.tag&&null!==r&&(s=r,null!=(r=Me(e,n))&&a.unshift(Ga(e,r,s)),null!=(r=Me(e,t))&&a.push(Ga(e,r,s))),e=e.return}return a}function Ka(e){if(null===e)return null;do{e=e.return}while(e&&5!==e.tag);return e||null}function Xa(e,t,n,a,s){for(var r=t._reactName,i=[];null!==n&&n!==a;){var o=n,c=o.alternate,l=o.stateNode;if(null!==c&&c===a)break;5===o.tag&&null!==l&&(o=l,s?null!=(c=Me(n,r))&&i.unshift(Ga(n,c,o)):s||null!=(c=Me(n,r))&&i.push(Ga(n,c,o))),n=n.return}0!==i.length&&e.push({event:t,listeners:i})}var Ya=/\r\n?/g,Qa=/\u0000|\uFFFD/g;function Za(e){return("string"===typeof e?e:""+e).replace(Ya,"\n").replace(Qa,"")}function Ja(e,t,n){if(t=Za(t),Za(e)!==t&&n)throw Error(r(425))}function $a(){}var es=null,ts=null;function ns(e,t){return"textarea"===e||"noscript"===e||"string"===typeof t.children||"number"===typeof t.children||"object"===typeof t.dangerouslySetInnerHTML&&null!==t.dangerouslySetInnerHTML&&null!=t.dangerouslySetInnerHTML.__html}var as="function"===typeof setTimeout?setTimeout:void 0,ss="function"===typeof clearTimeout?clearTimeout:void 0,rs="function"===typeof Promise?Promise:void 0,is="function"===typeof queueMicrotask?queueMicrotask:"undefined"!==typeof rs?function(e){return rs.resolve(null).then(e).catch(os)}:as;function os(e){setTimeout(function(){throw e})}function cs(e,t){var n=t,a=0;do{var s=n.nextSibling;if(e.removeChild(n),s&&8===s.nodeType)if("/$"===(n=s.data)){if(0===a)return e.removeChild(s),void Vt(t);a--}else"$"!==n&&"$?"!==n&&"$!"!==n||a++;n=s}while(n);Vt(t)}function ls(e){for(;null!=e;e=e.nextSibling){var t=e.nodeType;if(1===t||3===t)break;if(8===t){if("$"===(t=e.data)||"$!"===t||"$?"===t)break;if("/$"===t)return null}}return e}function us(e){e=e.previousSibling;for(var t=0;e;){if(8===e.nodeType){var n=e.data;if("$"===n||"$!"===n||"$?"===n){if(0===t)return e;t--}else"/$"===n&&t++}e=e.previousSibling}return null}var hs=Math.random().toString(36).slice(2),ds="__reactFiber$"+hs,ps="__reactProps$"+hs,fs="__reactContainer$"+hs,ms="__reactEvents$"+hs,gs="__reactListeners$"+hs,ys="__reactHandles$"+hs;function bs(e){var t=e[ds];if(t)return t;for(var n=e.parentNode;n;){if(t=n[fs]||n[ds]){if(n=t.alternate,null!==t.child||null!==n&&null!==n.child)for(e=us(e);null!==e;){if(n=e[ds])return n;e=us(e)}return t}n=(e=n).parentNode}return null}function xs(e){return!(e=e[ds]||e[fs])||5!==e.tag&&6!==e.tag&&13!==e.tag&&3!==e.tag?null:e}function vs(e){if(5===e.tag||6===e.tag)return e.stateNode;throw Error(r(33))}function ws(e){return e[ps]||null}var ks=[],Ss=-1;function Cs(e){return{current:e}}function Is(e){0>Ss||(e.current=ks[Ss],ks[Ss]=null,Ss--)}function Ns(e,t){Ss++,ks[Ss]=e.current,e.current=t}var Ts={},Es=Cs(Ts),Rs=Cs(!1),_s=Ts;function As(e,t){var n=e.type.contextTypes;if(!n)return Ts;var a=e.stateNode;if(a&&a.__reactInternalMemoizedUnmaskedChildContext===t)return a.__reactInternalMemoizedMaskedChildContext;var s,r={};for(s in n)r[s]=t[s];return a&&((e=e.stateNode).__reactInternalMemoizedUnmaskedChildContext=t,e.__reactInternalMemoizedMaskedChildContext=r),r}function Ms(e){return null!==(e=e.childContextTypes)&&void 0!==e}function Ps(){Is(Rs),Is(Es)}function Ds(e,t,n){if(Es.current!==Ts)throw Error(r(168));Ns(Es,t),Ns(Rs,n)}function Os(e,t,n){var a=e.stateNode;if(t=t.childContextTypes,"function"!==typeof a.getChildContext)return n;for(var s in a=a.getChildContext())if(!(s in t))throw Error(r(108,U(e)||"Unknown",s));return L({},n,a)}function Fs(e){return e=(e=e.stateNode)&&e.__reactInternalMemoizedMergedChildContext||Ts,_s=Es.current,Ns(Es,e),Ns(Rs,Rs.current),!0}function Ls(e,t,n){var a=e.stateNode;if(!a)throw Error(r(169));n?(e=Os(e,t,_s),a.__reactInternalMemoizedMergedChildContext=e,Is(Rs),Is(Es),Ns(Es,e)):Is(Rs),Ns(Rs,n)}var zs=null,Bs=!1,js=!1;function Ws(e){null===zs?zs=[e]:zs.push(e)}function Vs(){if(!js&&null!==zs){js=!0;var e=0,t=xt;try{var n=zs;for(xt=1;e<n.length;e++){var a=n[e];do{a=a(!0)}while(null!==a)}zs=null,Bs=!1}catch(s){throw null!==zs&&(zs=zs.slice(e+1)),Ke($e,Vs),s}finally{xt=t,js=!1}}return null}var Us=[],Hs=0,Gs=null,qs=0,Ks=[],Xs=0,Ys=null,Qs=1,Zs="";function Js(e,t){Us[Hs++]=qs,Us[Hs++]=Gs,Gs=e,qs=t}function $s(e,t,n){Ks[Xs++]=Qs,Ks[Xs++]=Zs,Ks[Xs++]=Ys,Ys=e;var a=Qs;e=Zs;var s=32-it(a)-1;a&=~(1<<s),n+=1;var r=32-it(t)+s;if(30<r){var i=s-s%5;r=(a&(1<<i)-1).toString(32),a>>=i,s-=i,Qs=1<<32-it(t)+s|n<<s|a,Zs=r+e}else Qs=1<<r|n<<s|a,Zs=e}function er(e){null!==e.return&&(Js(e,1),$s(e,1,0))}function tr(e){for(;e===Gs;)Gs=Us[--Hs],Us[Hs]=null,qs=Us[--Hs],Us[Hs]=null;for(;e===Ys;)Ys=Ks[--Xs],Ks[Xs]=null,Zs=Ks[--Xs],Ks[Xs]=null,Qs=Ks[--Xs],Ks[Xs]=null}var nr=null,ar=null,sr=!1,rr=null;function ir(e,t){var n=_l(5,null,null,0);n.elementType="DELETED",n.stateNode=t,n.return=e,null===(t=e.deletions)?(e.deletions=[n],e.flags|=16):t.push(n)}function or(e,t){switch(e.tag){case 5:var n=e.type;return null!==(t=1!==t.nodeType||n.toLowerCase()!==t.nodeName.toLowerCase()?null:t)&&(e.stateNode=t,nr=e,ar=ls(t.firstChild),!0);case 6:return null!==(t=""===e.pendingProps||3!==t.nodeType?null:t)&&(e.stateNode=t,nr=e,ar=null,!0);case 13:return null!==(t=8!==t.nodeType?null:t)&&(n=null!==Ys?{id:Qs,overflow:Zs}:null,e.memoizedState={dehydrated:t,treeContext:n,retryLane:1073741824},(n=_l(18,null,null,0)).stateNode=t,n.return=e,e.child=n,nr=e,ar=null,!0);default:return!1}}function cr(e){return 0!==(1&e.mode)&&0===(128&e.flags)}function lr(e){if(sr){var t=ar;if(t){var n=t;if(!or(e,t)){if(cr(e))throw Error(r(418));t=ls(n.nextSibling);var a=nr;t&&or(e,t)?ir(a,n):(e.flags=-4097&e.flags|2,sr=!1,nr=e)}}else{if(cr(e))throw Error(r(418));e.flags=-4097&e.flags|2,sr=!1,nr=e}}}function ur(e){for(e=e.return;null!==e&&5!==e.tag&&3!==e.tag&&13!==e.tag;)e=e.return;nr=e}function hr(e){if(e!==nr)return!1;if(!sr)return ur(e),sr=!0,!1;var t;if((t=3!==e.tag)&&!(t=5!==e.tag)&&(t="head"!==(t=e.type)&&"body"!==t&&!ns(e.type,e.memoizedProps)),t&&(t=ar)){if(cr(e))throw dr(),Error(r(418));for(;t;)ir(e,t),t=ls(t.nextSibling)}if(ur(e),13===e.tag){if(!(e=null!==(e=e.memoizedState)?e.dehydrated:null))throw Error(r(317));e:{for(e=e.nextSibling,t=0;e;){if(8===e.nodeType){var n=e.data;if("/$"===n){if(0===t){ar=ls(e.nextSibling);break e}t--}else"$"!==n&&"$!"!==n&&"$?"!==n||t++}e=e.nextSibling}ar=null}}else ar=nr?ls(e.stateNode.nextSibling):null;return!0}function dr(){for(var e=ar;e;)e=ls(e.nextSibling)}function pr(){ar=nr=null,sr=!1}function fr(e){null===rr?rr=[e]:rr.push(e)}var mr=v.ReactCurrentBatchConfig;function gr(e,t,n){if(null!==(e=n.ref)&&"function"!==typeof e&&"object"!==typeof e){if(n._owner){if(n=n._owner){if(1!==n.tag)throw Error(r(309));var a=n.stateNode}if(!a)throw Error(r(147,e));var s=a,i=""+e;return null!==t&&null!==t.ref&&"function"===typeof t.ref&&t.ref._stringRef===i?t.ref:(t=function(e){var t=s.refs;null===e?delete t[i]:t[i]=e},t._stringRef=i,t)}if("string"!==typeof e)throw Error(r(284));if(!n._owner)throw Error(r(290,e))}return e}function yr(e,t){throw e=Object.prototype.toString.call(t),Error(r(31,"[object Object]"===e?"object with keys {"+Object.keys(t).join(", ")+"}":e))}function br(e){return(0,e._init)(e._payload)}function xr(e){function t(t,n){if(e){var a=t.deletions;null===a?(t.deletions=[n],t.flags|=16):a.push(n)}}function n(n,a){if(!e)return null;for(;null!==a;)t(n,a),a=a.sibling;return null}function a(e,t){for(e=new Map;null!==t;)null!==t.key?e.set(t.key,t):e.set(t.index,t),t=t.sibling;return e}function s(e,t){return(e=Ml(e,t)).index=0,e.sibling=null,e}function i(t,n,a){return t.index=a,e?null!==(a=t.alternate)?(a=a.index)<n?(t.flags|=2,n):a:(t.flags|=2,n):(t.flags|=1048576,n)}function o(t){return e&&null===t.alternate&&(t.flags|=2),t}function c(e,t,n,a){return null===t||6!==t.tag?((t=Fl(n,e.mode,a)).return=e,t):((t=s(t,n)).return=e,t)}function l(e,t,n,a){var r=n.type;return r===S?h(e,t,n.props.children,a,n.key):null!==t&&(t.elementType===r||"object"===typeof r&&null!==r&&r.$$typeof===M&&br(r)===t.type)?((a=s(t,n.props)).ref=gr(e,t,n),a.return=e,a):((a=Pl(n.type,n.key,n.props,null,e.mode,a)).ref=gr(e,t,n),a.return=e,a)}function u(e,t,n,a){return null===t||4!==t.tag||t.stateNode.containerInfo!==n.containerInfo||t.stateNode.implementation!==n.implementation?((t=Ll(n,e.mode,a)).return=e,t):((t=s(t,n.children||[])).return=e,t)}function h(e,t,n,a,r){return null===t||7!==t.tag?((t=Dl(n,e.mode,a,r)).return=e,t):((t=s(t,n)).return=e,t)}function d(e,t,n){if("string"===typeof t&&""!==t||"number"===typeof t)return(t=Fl(""+t,e.mode,n)).return=e,t;if("object"===typeof t&&null!==t){switch(t.$$typeof){case w:return(n=Pl(t.type,t.key,t.props,null,e.mode,n)).ref=gr(e,null,t),n.return=e,n;case k:return(t=Ll(t,e.mode,n)).return=e,t;case M:return d(e,(0,t._init)(t._payload),n)}if(te(t)||O(t))return(t=Dl(t,e.mode,n,null)).return=e,t;yr(e,t)}return null}function p(e,t,n,a){var s=null!==t?t.key:null;if("string"===typeof n&&""!==n||"number"===typeof n)return null!==s?null:c(e,t,""+n,a);if("object"===typeof n&&null!==n){switch(n.$$typeof){case w:return n.key===s?l(e,t,n,a):null;case k:return n.key===s?u(e,t,n,a):null;case M:return p(e,t,(s=n._init)(n._payload),a)}if(te(n)||O(n))return null!==s?null:h(e,t,n,a,null);yr(e,n)}return null}function f(e,t,n,a,s){if("string"===typeof a&&""!==a||"number"===typeof a)return c(t,e=e.get(n)||null,""+a,s);if("object"===typeof a&&null!==a){switch(a.$$typeof){case w:return l(t,e=e.get(null===a.key?n:a.key)||null,a,s);case k:return u(t,e=e.get(null===a.key?n:a.key)||null,a,s);case M:return f(e,t,n,(0,a._init)(a._payload),s)}if(te(a)||O(a))return h(t,e=e.get(n)||null,a,s,null);yr(t,a)}return null}function m(s,r,o,c){for(var l=null,u=null,h=r,m=r=0,g=null;null!==h&&m<o.length;m++){h.index>m?(g=h,h=null):g=h.sibling;var y=p(s,h,o[m],c);if(null===y){null===h&&(h=g);break}e&&h&&null===y.alternate&&t(s,h),r=i(y,r,m),null===u?l=y:u.sibling=y,u=y,h=g}if(m===o.length)return n(s,h),sr&&Js(s,m),l;if(null===h){for(;m<o.length;m++)null!==(h=d(s,o[m],c))&&(r=i(h,r,m),null===u?l=h:u.sibling=h,u=h);return sr&&Js(s,m),l}for(h=a(s,h);m<o.length;m++)null!==(g=f(h,s,m,o[m],c))&&(e&&null!==g.alternate&&h.delete(null===g.key?m:g.key),r=i(g,r,m),null===u?l=g:u.sibling=g,u=g);return e&&h.forEach(function(e){return t(s,e)}),sr&&Js(s,m),l}function g(s,o,c,l){var u=O(c);if("function"!==typeof u)throw Error(r(150));if(null==(c=u.call(c)))throw Error(r(151));for(var h=u=null,m=o,g=o=0,y=null,b=c.next();null!==m&&!b.done;g++,b=c.next()){m.index>g?(y=m,m=null):y=m.sibling;var x=p(s,m,b.value,l);if(null===x){null===m&&(m=y);break}e&&m&&null===x.alternate&&t(s,m),o=i(x,o,g),null===h?u=x:h.sibling=x,h=x,m=y}if(b.done)return n(s,m),sr&&Js(s,g),u;if(null===m){for(;!b.done;g++,b=c.next())null!==(b=d(s,b.value,l))&&(o=i(b,o,g),null===h?u=b:h.sibling=b,h=b);return sr&&Js(s,g),u}for(m=a(s,m);!b.done;g++,b=c.next())null!==(b=f(m,s,g,b.value,l))&&(e&&null!==b.alternate&&m.delete(null===b.key?g:b.key),o=i(b,o,g),null===h?u=b:h.sibling=b,h=b);return e&&m.forEach(function(e){return t(s,e)}),sr&&Js(s,g),u}return function e(a,r,i,c){if("object"===typeof i&&null!==i&&i.type===S&&null===i.key&&(i=i.props.children),"object"===typeof i&&null!==i){switch(i.$$typeof){case w:e:{for(var l=i.key,u=r;null!==u;){if(u.key===l){if((l=i.type)===S){if(7===u.tag){n(a,u.sibling),(r=s(u,i.props.children)).return=a,a=r;break e}}else if(u.elementType===l||"object"===typeof l&&null!==l&&l.$$typeof===M&&br(l)===u.type){n(a,u.sibling),(r=s(u,i.props)).ref=gr(a,u,i),r.return=a,a=r;break e}n(a,u);break}t(a,u),u=u.sibling}i.type===S?((r=Dl(i.props.children,a.mode,c,i.key)).return=a,a=r):((c=Pl(i.type,i.key,i.props,null,a.mode,c)).ref=gr(a,r,i),c.return=a,a=c)}return o(a);case k:e:{for(u=i.key;null!==r;){if(r.key===u){if(4===r.tag&&r.stateNode.containerInfo===i.containerInfo&&r.stateNode.implementation===i.implementation){n(a,r.sibling),(r=s(r,i.children||[])).return=a,a=r;break e}n(a,r);break}t(a,r),r=r.sibling}(r=Ll(i,a.mode,c)).return=a,a=r}return o(a);case M:return e(a,r,(u=i._init)(i._payload),c)}if(te(i))return m(a,r,i,c);if(O(i))return g(a,r,i,c);yr(a,i)}return"string"===typeof i&&""!==i||"number"===typeof i?(i=""+i,null!==r&&6===r.tag?(n(a,r.sibling),(r=s(r,i)).return=a,a=r):(n(a,r),(r=Fl(i,a.mode,c)).return=a,a=r),o(a)):n(a,r)}}var vr=xr(!0),wr=xr(!1),kr=Cs(null),Sr=null,Cr=null,Ir=null;function Nr(){Ir=Cr=Sr=null}function Tr(e){var t=kr.current;Is(kr),e._currentValue=t}function Er(e,t,n){for(;null!==e;){var a=e.alternate;if((e.childLanes&t)!==t?(e.childLanes|=t,null!==a&&(a.childLanes|=t)):null!==a&&(a.childLanes&t)!==t&&(a.childLanes|=t),e===n)break;e=e.return}}function Rr(e,t){Sr=e,Ir=Cr=null,null!==(e=e.dependencies)&&null!==e.firstContext&&(0!==(e.lanes&t)&&(xo=!0),e.firstContext=null)}function _r(e){var t=e._currentValue;if(Ir!==e)if(e={context:e,memoizedValue:t,next:null},null===Cr){if(null===Sr)throw Error(r(308));Cr=e,Sr.dependencies={lanes:0,firstContext:e}}else Cr=Cr.next=e;return t}var Ar=null;function Mr(e){null===Ar?Ar=[e]:Ar.push(e)}function Pr(e,t,n,a){var s=t.interleaved;return null===s?(n.next=n,Mr(t)):(n.next=s.next,s.next=n),t.interleaved=n,Dr(e,a)}function Dr(e,t){e.lanes|=t;var n=e.alternate;for(null!==n&&(n.lanes|=t),n=e,e=e.return;null!==e;)e.childLanes|=t,null!==(n=e.alternate)&&(n.childLanes|=t),n=e,e=e.return;return 3===n.tag?n.stateNode:null}var Or=!1;function Fr(e){e.updateQueue={baseState:e.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function Lr(e,t){e=e.updateQueue,t.updateQueue===e&&(t.updateQueue={baseState:e.baseState,firstBaseUpdate:e.firstBaseUpdate,lastBaseUpdate:e.lastBaseUpdate,shared:e.shared,effects:e.effects})}function zr(e,t){return{eventTime:e,lane:t,tag:0,payload:null,callback:null,next:null}}function Br(e,t,n){var a=e.updateQueue;if(null===a)return null;if(a=a.shared,0!==(2&Tc)){var s=a.pending;return null===s?t.next=t:(t.next=s.next,s.next=t),a.pending=t,Dr(e,n)}return null===(s=a.interleaved)?(t.next=t,Mr(a)):(t.next=s.next,s.next=t),a.interleaved=t,Dr(e,n)}function jr(e,t,n){if(null!==(t=t.updateQueue)&&(t=t.shared,0!==(4194240&n))){var a=t.lanes;n|=a&=e.pendingLanes,t.lanes=n,bt(e,n)}}function Wr(e,t){var n=e.updateQueue,a=e.alternate;if(null!==a&&n===(a=a.updateQueue)){var s=null,r=null;if(null!==(n=n.firstBaseUpdate)){do{var i={eventTime:n.eventTime,lane:n.lane,tag:n.tag,payload:n.payload,callback:n.callback,next:null};null===r?s=r=i:r=r.next=i,n=n.next}while(null!==n);null===r?s=r=t:r=r.next=t}else s=r=t;return n={baseState:a.baseState,firstBaseUpdate:s,lastBaseUpdate:r,shared:a.shared,effects:a.effects},void(e.updateQueue=n)}null===(e=n.lastBaseUpdate)?n.firstBaseUpdate=t:e.next=t,n.lastBaseUpdate=t}function Vr(e,t,n,a){var s=e.updateQueue;Or=!1;var r=s.firstBaseUpdate,i=s.lastBaseUpdate,o=s.shared.pending;if(null!==o){s.shared.pending=null;var c=o,l=c.next;c.next=null,null===i?r=l:i.next=l,i=c;var u=e.alternate;null!==u&&((o=(u=u.updateQueue).lastBaseUpdate)!==i&&(null===o?u.firstBaseUpdate=l:o.next=l,u.lastBaseUpdate=c))}if(null!==r){var h=s.baseState;for(i=0,u=l=c=null,o=r;;){var d=o.lane,p=o.eventTime;if((a&d)===d){null!==u&&(u=u.next={eventTime:p,lane:0,tag:o.tag,payload:o.payload,callback:o.callback,next:null});e:{var f=e,m=o;switch(d=t,p=n,m.tag){case 1:if("function"===typeof(f=m.payload)){h=f.call(p,h,d);break e}h=f;break e;case 3:f.flags=-65537&f.flags|128;case 0:if(null===(d="function"===typeof(f=m.payload)?f.call(p,h,d):f)||void 0===d)break e;h=L({},h,d);break e;case 2:Or=!0}}null!==o.callback&&0!==o.lane&&(e.flags|=64,null===(d=s.effects)?s.effects=[o]:d.push(o))}else p={eventTime:p,lane:d,tag:o.tag,payload:o.payload,callback:o.callback,next:null},null===u?(l=u=p,c=h):u=u.next=p,i|=d;if(null===(o=o.next)){if(null===(o=s.shared.pending))break;o=(d=o).next,d.next=null,s.lastBaseUpdate=d,s.shared.pending=null}}if(null===u&&(c=h),s.baseState=c,s.firstBaseUpdate=l,s.lastBaseUpdate=u,null!==(t=s.shared.interleaved)){s=t;do{i|=s.lane,s=s.next}while(s!==t)}else null===r&&(s.shared.lanes=0);Oc|=i,e.lanes=i,e.memoizedState=h}}function Ur(e,t,n){if(e=t.effects,t.effects=null,null!==e)for(t=0;t<e.length;t++){var a=e[t],s=a.callback;if(null!==s){if(a.callback=null,a=n,"function"!==typeof s)throw Error(r(191,s));s.call(a)}}}var Hr={},Gr=Cs(Hr),qr=Cs(Hr),Kr=Cs(Hr);function Xr(e){if(e===Hr)throw Error(r(174));return e}function Yr(e,t){switch(Ns(Kr,t),Ns(qr,e),Ns(Gr,Hr),e=t.nodeType){case 9:case 11:t=(t=t.documentElement)?t.namespaceURI:ce(null,"");break;default:t=ce(t=(e=8===e?t.parentNode:t).namespaceURI||null,e=e.tagName)}Is(Gr),Ns(Gr,t)}function Qr(){Is(Gr),Is(qr),Is(Kr)}function Zr(e){Xr(Kr.current);var t=Xr(Gr.current),n=ce(t,e.type);t!==n&&(Ns(qr,e),Ns(Gr,n))}function Jr(e){qr.current===e&&(Is(Gr),Is(qr))}var $r=Cs(0);function ei(e){for(var t=e;null!==t;){if(13===t.tag){var n=t.memoizedState;if(null!==n&&(null===(n=n.dehydrated)||"$?"===n.data||"$!"===n.data))return t}else if(19===t.tag&&void 0!==t.memoizedProps.revealOrder){if(0!==(128&t.flags))return t}else if(null!==t.child){t.child.return=t,t=t.child;continue}if(t===e)break;for(;null===t.sibling;){if(null===t.return||t.return===e)return null;t=t.return}t.sibling.return=t.return,t=t.sibling}return null}var ti=[];function ni(){for(var e=0;e<ti.length;e++)ti[e]._workInProgressVersionPrimary=null;ti.length=0}var ai=v.ReactCurrentDispatcher,si=v.ReactCurrentBatchConfig,ri=0,ii=null,oi=null,ci=null,li=!1,ui=!1,hi=0,di=0;function pi(){throw Error(r(321))}function fi(e,t){if(null===t)return!1;for(var n=0;n<t.length&&n<e.length;n++)if(!oa(e[n],t[n]))return!1;return!0}function mi(e,t,n,a,s,i){if(ri=i,ii=t,t.memoizedState=null,t.updateQueue=null,t.lanes=0,ai.current=null===e||null===e.memoizedState?Ji:$i,e=n(a,s),ui){i=0;do{if(ui=!1,hi=0,25<=i)throw Error(r(301));i+=1,ci=oi=null,t.updateQueue=null,ai.current=eo,e=n(a,s)}while(ui)}if(ai.current=Zi,t=null!==oi&&null!==oi.next,ri=0,ci=oi=ii=null,li=!1,t)throw Error(r(300));return e}function gi(){var e=0!==hi;return hi=0,e}function yi(){var e={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return null===ci?ii.memoizedState=ci=e:ci=ci.next=e,ci}function bi(){if(null===oi){var e=ii.alternate;e=null!==e?e.memoizedState:null}else e=oi.next;var t=null===ci?ii.memoizedState:ci.next;if(null!==t)ci=t,oi=e;else{if(null===e)throw Error(r(310));e={memoizedState:(oi=e).memoizedState,baseState:oi.baseState,baseQueue:oi.baseQueue,queue:oi.queue,next:null},null===ci?ii.memoizedState=ci=e:ci=ci.next=e}return ci}function xi(e,t){return"function"===typeof t?t(e):t}function vi(e){var t=bi(),n=t.queue;if(null===n)throw Error(r(311));n.lastRenderedReducer=e;var a=oi,s=a.baseQueue,i=n.pending;if(null!==i){if(null!==s){var o=s.next;s.next=i.next,i.next=o}a.baseQueue=s=i,n.pending=null}if(null!==s){i=s.next,a=a.baseState;var c=o=null,l=null,u=i;do{var h=u.lane;if((ri&h)===h)null!==l&&(l=l.next={lane:0,action:u.action,hasEagerState:u.hasEagerState,eagerState:u.eagerState,next:null}),a=u.hasEagerState?u.eagerState:e(a,u.action);else{var d={lane:h,action:u.action,hasEagerState:u.hasEagerState,eagerState:u.eagerState,next:null};null===l?(c=l=d,o=a):l=l.next=d,ii.lanes|=h,Oc|=h}u=u.next}while(null!==u&&u!==i);null===l?o=a:l.next=c,oa(a,t.memoizedState)||(xo=!0),t.memoizedState=a,t.baseState=o,t.baseQueue=l,n.lastRenderedState=a}if(null!==(e=n.interleaved)){s=e;do{i=s.lane,ii.lanes|=i,Oc|=i,s=s.next}while(s!==e)}else null===s&&(n.lanes=0);return[t.memoizedState,n.dispatch]}function wi(e){var t=bi(),n=t.queue;if(null===n)throw Error(r(311));n.lastRenderedReducer=e;var a=n.dispatch,s=n.pending,i=t.memoizedState;if(null!==s){n.pending=null;var o=s=s.next;do{i=e(i,o.action),o=o.next}while(o!==s);oa(i,t.memoizedState)||(xo=!0),t.memoizedState=i,null===t.baseQueue&&(t.baseState=i),n.lastRenderedState=i}return[i,a]}function ki(){}function Si(e,t){var n=ii,a=bi(),s=t(),i=!oa(a.memoizedState,s);if(i&&(a.memoizedState=s,xo=!0),a=a.queue,Oi(Ni.bind(null,n,a,e),[e]),a.getSnapshot!==t||i||null!==ci&&1&ci.memoizedState.tag){if(n.flags|=2048,_i(9,Ii.bind(null,n,a,s,t),void 0,null),null===Ec)throw Error(r(349));0!==(30&ri)||Ci(n,t,s)}return s}function Ci(e,t,n){e.flags|=16384,e={getSnapshot:t,value:n},null===(t=ii.updateQueue)?(t={lastEffect:null,stores:null},ii.updateQueue=t,t.stores=[e]):null===(n=t.stores)?t.stores=[e]:n.push(e)}function Ii(e,t,n,a){t.value=n,t.getSnapshot=a,Ti(t)&&Ei(e)}function Ni(e,t,n){return n(function(){Ti(t)&&Ei(e)})}function Ti(e){var t=e.getSnapshot;e=e.value;try{var n=t();return!oa(e,n)}catch(a){return!0}}function Ei(e){var t=Dr(e,1);null!==t&&tl(t,e,1,-1)}function Ri(e){var t=yi();return"function"===typeof e&&(e=e()),t.memoizedState=t.baseState=e,e={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:xi,lastRenderedState:e},t.queue=e,e=e.dispatch=Ki.bind(null,ii,e),[t.memoizedState,e]}function _i(e,t,n,a){return e={tag:e,create:t,destroy:n,deps:a,next:null},null===(t=ii.updateQueue)?(t={lastEffect:null,stores:null},ii.updateQueue=t,t.lastEffect=e.next=e):null===(n=t.lastEffect)?t.lastEffect=e.next=e:(a=n.next,n.next=e,e.next=a,t.lastEffect=e),e}function Ai(){return bi().memoizedState}function Mi(e,t,n,a){var s=yi();ii.flags|=e,s.memoizedState=_i(1|t,n,void 0,void 0===a?null:a)}function Pi(e,t,n,a){var s=bi();a=void 0===a?null:a;var r=void 0;if(null!==oi){var i=oi.memoizedState;if(r=i.destroy,null!==a&&fi(a,i.deps))return void(s.memoizedState=_i(t,n,r,a))}ii.flags|=e,s.memoizedState=_i(1|t,n,r,a)}function Di(e,t){return Mi(8390656,8,e,t)}function Oi(e,t){return Pi(2048,8,e,t)}function Fi(e,t){return Pi(4,2,e,t)}function Li(e,t){return Pi(4,4,e,t)}function zi(e,t){return"function"===typeof t?(e=e(),t(e),function(){t(null)}):null!==t&&void 0!==t?(e=e(),t.current=e,function(){t.current=null}):void 0}function Bi(e,t,n){return n=null!==n&&void 0!==n?n.concat([e]):null,Pi(4,4,zi.bind(null,t,e),n)}function ji(){}function Wi(e,t){var n=bi();t=void 0===t?null:t;var a=n.memoizedState;return null!==a&&null!==t&&fi(t,a[1])?a[0]:(n.memoizedState=[e,t],e)}function Vi(e,t){var n=bi();t=void 0===t?null:t;var a=n.memoizedState;return null!==a&&null!==t&&fi(t,a[1])?a[0]:(e=e(),n.memoizedState=[e,t],e)}function Ui(e,t,n){return 0===(21&ri)?(e.baseState&&(e.baseState=!1,xo=!0),e.memoizedState=n):(oa(n,t)||(n=mt(),ii.lanes|=n,Oc|=n,e.baseState=!0),t)}function Hi(e,t){var n=xt;xt=0!==n&&4>n?n:4,e(!0);var a=si.transition;si.transition={};try{e(!1),t()}finally{xt=n,si.transition=a}}function Gi(){return bi().memoizedState}function qi(e,t,n){var a=el(e);if(n={lane:a,action:n,hasEagerState:!1,eagerState:null,next:null},Xi(e))Yi(t,n);else if(null!==(n=Pr(e,t,n,a))){tl(n,e,a,$c()),Qi(n,t,a)}}function Ki(e,t,n){var a=el(e),s={lane:a,action:n,hasEagerState:!1,eagerState:null,next:null};if(Xi(e))Yi(t,s);else{var r=e.alternate;if(0===e.lanes&&(null===r||0===r.lanes)&&null!==(r=t.lastRenderedReducer))try{var i=t.lastRenderedState,o=r(i,n);if(s.hasEagerState=!0,s.eagerState=o,oa(o,i)){var c=t.interleaved;return null===c?(s.next=s,Mr(t)):(s.next=c.next,c.next=s),void(t.interleaved=s)}}catch(l){}null!==(n=Pr(e,t,s,a))&&(tl(n,e,a,s=$c()),Qi(n,t,a))}}function Xi(e){var t=e.alternate;return e===ii||null!==t&&t===ii}function Yi(e,t){ui=li=!0;var n=e.pending;null===n?t.next=t:(t.next=n.next,n.next=t),e.pending=t}function Qi(e,t,n){if(0!==(4194240&n)){var a=t.lanes;n|=a&=e.pendingLanes,t.lanes=n,bt(e,n)}}var Zi={readContext:_r,useCallback:pi,useContext:pi,useEffect:pi,useImperativeHandle:pi,useInsertionEffect:pi,useLayoutEffect:pi,useMemo:pi,useReducer:pi,useRef:pi,useState:pi,useDebugValue:pi,useDeferredValue:pi,useTransition:pi,useMutableSource:pi,useSyncExternalStore:pi,useId:pi,unstable_isNewReconciler:!1},Ji={readContext:_r,useCallback:function(e,t){return yi().memoizedState=[e,void 0===t?null:t],e},useContext:_r,useEffect:Di,useImperativeHandle:function(e,t,n){return n=null!==n&&void 0!==n?n.concat([e]):null,Mi(4194308,4,zi.bind(null,t,e),n)},useLayoutEffect:function(e,t){return Mi(4194308,4,e,t)},useInsertionEffect:function(e,t){return Mi(4,2,e,t)},useMemo:function(e,t){var n=yi();return t=void 0===t?null:t,e=e(),n.memoizedState=[e,t],e},useReducer:function(e,t,n){var a=yi();return t=void 0!==n?n(t):t,a.memoizedState=a.baseState=t,e={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:e,lastRenderedState:t},a.queue=e,e=e.dispatch=qi.bind(null,ii,e),[a.memoizedState,e]},useRef:function(e){return e={current:e},yi().memoizedState=e},useState:Ri,useDebugValue:ji,useDeferredValue:function(e){return yi().memoizedState=e},useTransition:function(){var e=Ri(!1),t=e[0];return e=Hi.bind(null,e[1]),yi().memoizedState=e,[t,e]},useMutableSource:function(){},useSyncExternalStore:function(e,t,n){var a=ii,s=yi();if(sr){if(void 0===n)throw Error(r(407));n=n()}else{if(n=t(),null===Ec)throw Error(r(349));0!==(30&ri)||Ci(a,t,n)}s.memoizedState=n;var i={value:n,getSnapshot:t};return s.queue=i,Di(Ni.bind(null,a,i,e),[e]),a.flags|=2048,_i(9,Ii.bind(null,a,i,n,t),void 0,null),n},useId:function(){var e=yi(),t=Ec.identifierPrefix;if(sr){var n=Zs;t=":"+t+"R"+(n=(Qs&~(1<<32-it(Qs)-1)).toString(32)+n),0<(n=hi++)&&(t+="H"+n.toString(32)),t+=":"}else t=":"+t+"r"+(n=di++).toString(32)+":";return e.memoizedState=t},unstable_isNewReconciler:!1},$i={readContext:_r,useCallback:Wi,useContext:_r,useEffect:Oi,useImperativeHandle:Bi,useInsertionEffect:Fi,useLayoutEffect:Li,useMemo:Vi,useReducer:vi,useRef:Ai,useState:function(){return vi(xi)},useDebugValue:ji,useDeferredValue:function(e){return Ui(bi(),oi.memoizedState,e)},useTransition:function(){return[vi(xi)[0],bi().memoizedState]},useMutableSource:ki,useSyncExternalStore:Si,useId:Gi,unstable_isNewReconciler:!1},eo={readContext:_r,useCallback:Wi,useContext:_r,useEffect:Oi,useImperativeHandle:Bi,useInsertionEffect:Fi,useLayoutEffect:Li,useMemo:Vi,useReducer:wi,useRef:Ai,useState:function(){return wi(xi)},useDebugValue:ji,useDeferredValue:function(e){var t=bi();return null===oi?t.memoizedState=e:Ui(t,oi.memoizedState,e)},useTransition:function(){return[wi(xi)[0],bi().memoizedState]},useMutableSource:ki,useSyncExternalStore:Si,useId:Gi,unstable_isNewReconciler:!1};function to(e,t){if(e&&e.defaultProps){for(var n in t=L({},t),e=e.defaultProps)void 0===t[n]&&(t[n]=e[n]);return t}return t}function no(e,t,n,a){n=null===(n=n(a,t=e.memoizedState))||void 0===n?t:L({},t,n),e.memoizedState=n,0===e.lanes&&(e.updateQueue.baseState=n)}var ao={isMounted:function(e){return!!(e=e._reactInternals)&&Ve(e)===e},enqueueSetState:function(e,t,n){e=e._reactInternals;var a=$c(),s=el(e),r=zr(a,s);r.payload=t,void 0!==n&&null!==n&&(r.callback=n),null!==(t=Br(e,r,s))&&(tl(t,e,s,a),jr(t,e,s))},enqueueReplaceState:function(e,t,n){e=e._reactInternals;var a=$c(),s=el(e),r=zr(a,s);r.tag=1,r.payload=t,void 0!==n&&null!==n&&(r.callback=n),null!==(t=Br(e,r,s))&&(tl(t,e,s,a),jr(t,e,s))},enqueueForceUpdate:function(e,t){e=e._reactInternals;var n=$c(),a=el(e),s=zr(n,a);s.tag=2,void 0!==t&&null!==t&&(s.callback=t),null!==(t=Br(e,s,a))&&(tl(t,e,a,n),jr(t,e,a))}};function so(e,t,n,a,s,r,i){return"function"===typeof(e=e.stateNode).shouldComponentUpdate?e.shouldComponentUpdate(a,r,i):!t.prototype||!t.prototype.isPureReactComponent||(!ca(n,a)||!ca(s,r))}function ro(e,t,n){var a=!1,s=Ts,r=t.contextType;return"object"===typeof r&&null!==r?r=_r(r):(s=Ms(t)?_s:Es.current,r=(a=null!==(a=t.contextTypes)&&void 0!==a)?As(e,s):Ts),t=new t(n,r),e.memoizedState=null!==t.state&&void 0!==t.state?t.state:null,t.updater=ao,e.stateNode=t,t._reactInternals=e,a&&((e=e.stateNode).__reactInternalMemoizedUnmaskedChildContext=s,e.__reactInternalMemoizedMaskedChildContext=r),t}function io(e,t,n,a){e=t.state,"function"===typeof t.componentWillReceiveProps&&t.componentWillReceiveProps(n,a),"function"===typeof t.UNSAFE_componentWillReceiveProps&&t.UNSAFE_componentWillReceiveProps(n,a),t.state!==e&&ao.enqueueReplaceState(t,t.state,null)}function oo(e,t,n,a){var s=e.stateNode;s.props=n,s.state=e.memoizedState,s.refs={},Fr(e);var r=t.contextType;"object"===typeof r&&null!==r?s.context=_r(r):(r=Ms(t)?_s:Es.current,s.context=As(e,r)),s.state=e.memoizedState,"function"===typeof(r=t.getDerivedStateFromProps)&&(no(e,t,r,n),s.state=e.memoizedState),"function"===typeof t.getDerivedStateFromProps||"function"===typeof s.getSnapshotBeforeUpdate||"function"!==typeof s.UNSAFE_componentWillMount&&"function"!==typeof s.componentWillMount||(t=s.state,"function"===typeof s.componentWillMount&&s.componentWillMount(),"function"===typeof s.UNSAFE_componentWillMount&&s.UNSAFE_componentWillMount(),t!==s.state&&ao.enqueueReplaceState(s,s.state,null),Vr(e,n,s,a),s.state=e.memoizedState),"function"===typeof s.componentDidMount&&(e.flags|=4194308)}function co(e,t){try{var n="",a=t;do{n+=W(a),a=a.return}while(a);var s=n}catch(r){s="\nError generating stack: "+r.message+"\n"+r.stack}return{value:e,source:t,stack:s,digest:null}}function lo(e,t,n){return{value:e,source:null,stack:null!=n?n:null,digest:null!=t?t:null}}function uo(e,t){try{console.error(t.value)}catch(n){setTimeout(function(){throw n})}}var ho="function"===typeof WeakMap?WeakMap:Map;function po(e,t,n){(n=zr(-1,n)).tag=3,n.payload={element:null};var a=t.value;return n.callback=function(){Uc||(Uc=!0,Hc=a),uo(0,t)},n}function fo(e,t,n){(n=zr(-1,n)).tag=3;var a=e.type.getDerivedStateFromError;if("function"===typeof a){var s=t.value;n.payload=function(){return a(s)},n.callback=function(){uo(0,t)}}var r=e.stateNode;return null!==r&&"function"===typeof r.componentDidCatch&&(n.callback=function(){uo(0,t),"function"!==typeof a&&(null===Gc?Gc=new Set([this]):Gc.add(this));var e=t.stack;this.componentDidCatch(t.value,{componentStack:null!==e?e:""})}),n}function mo(e,t,n){var a=e.pingCache;if(null===a){a=e.pingCache=new ho;var s=new Set;a.set(t,s)}else void 0===(s=a.get(t))&&(s=new Set,a.set(t,s));s.has(n)||(s.add(n),e=Cl.bind(null,e,t,n),t.then(e,e))}function go(e){do{var t;if((t=13===e.tag)&&(t=null===(t=e.memoizedState)||null!==t.dehydrated),t)return e;e=e.return}while(null!==e);return null}function yo(e,t,n,a,s){return 0===(1&e.mode)?(e===t?e.flags|=65536:(e.flags|=128,n.flags|=131072,n.flags&=-52805,1===n.tag&&(null===n.alternate?n.tag=17:((t=zr(-1,1)).tag=2,Br(n,t,1))),n.lanes|=1),e):(e.flags|=65536,e.lanes=s,e)}var bo=v.ReactCurrentOwner,xo=!1;function vo(e,t,n,a){t.child=null===e?wr(t,null,n,a):vr(t,e.child,n,a)}function wo(e,t,n,a,s){n=n.render;var r=t.ref;return Rr(t,s),a=mi(e,t,n,a,r,s),n=gi(),null===e||xo?(sr&&n&&er(t),t.flags|=1,vo(e,t,a,s),t.child):(t.updateQueue=e.updateQueue,t.flags&=-2053,e.lanes&=~s,Uo(e,t,s))}function ko(e,t,n,a,s){if(null===e){var r=n.type;return"function"!==typeof r||Al(r)||void 0!==r.defaultProps||null!==n.compare||void 0!==n.defaultProps?((e=Pl(n.type,null,a,t,t.mode,s)).ref=t.ref,e.return=t,t.child=e):(t.tag=15,t.type=r,So(e,t,r,a,s))}if(r=e.child,0===(e.lanes&s)){var i=r.memoizedProps;if((n=null!==(n=n.compare)?n:ca)(i,a)&&e.ref===t.ref)return Uo(e,t,s)}return t.flags|=1,(e=Ml(r,a)).ref=t.ref,e.return=t,t.child=e}function So(e,t,n,a,s){if(null!==e){var r=e.memoizedProps;if(ca(r,a)&&e.ref===t.ref){if(xo=!1,t.pendingProps=a=r,0===(e.lanes&s))return t.lanes=e.lanes,Uo(e,t,s);0!==(131072&e.flags)&&(xo=!0)}}return No(e,t,n,a,s)}function Co(e,t,n){var a=t.pendingProps,s=a.children,r=null!==e?e.memoizedState:null;if("hidden"===a.mode)if(0===(1&t.mode))t.memoizedState={baseLanes:0,cachePool:null,transitions:null},Ns(Mc,Ac),Ac|=n;else{if(0===(1073741824&n))return e=null!==r?r.baseLanes|n:n,t.lanes=t.childLanes=1073741824,t.memoizedState={baseLanes:e,cachePool:null,transitions:null},t.updateQueue=null,Ns(Mc,Ac),Ac|=e,null;t.memoizedState={baseLanes:0,cachePool:null,transitions:null},a=null!==r?r.baseLanes:n,Ns(Mc,Ac),Ac|=a}else null!==r?(a=r.baseLanes|n,t.memoizedState=null):a=n,Ns(Mc,Ac),Ac|=a;return vo(e,t,s,n),t.child}function Io(e,t){var n=t.ref;(null===e&&null!==n||null!==e&&e.ref!==n)&&(t.flags|=512,t.flags|=2097152)}function No(e,t,n,a,s){var r=Ms(n)?_s:Es.current;return r=As(t,r),Rr(t,s),n=mi(e,t,n,a,r,s),a=gi(),null===e||xo?(sr&&a&&er(t),t.flags|=1,vo(e,t,n,s),t.child):(t.updateQueue=e.updateQueue,t.flags&=-2053,e.lanes&=~s,Uo(e,t,s))}function To(e,t,n,a,s){if(Ms(n)){var r=!0;Fs(t)}else r=!1;if(Rr(t,s),null===t.stateNode)Vo(e,t),ro(t,n,a),oo(t,n,a,s),a=!0;else if(null===e){var i=t.stateNode,o=t.memoizedProps;i.props=o;var c=i.context,l=n.contextType;"object"===typeof l&&null!==l?l=_r(l):l=As(t,l=Ms(n)?_s:Es.current);var u=n.getDerivedStateFromProps,h="function"===typeof u||"function"===typeof i.getSnapshotBeforeUpdate;h||"function"!==typeof i.UNSAFE_componentWillReceiveProps&&"function"!==typeof i.componentWillReceiveProps||(o!==a||c!==l)&&io(t,i,a,l),Or=!1;var d=t.memoizedState;i.state=d,Vr(t,a,i,s),c=t.memoizedState,o!==a||d!==c||Rs.current||Or?("function"===typeof u&&(no(t,n,u,a),c=t.memoizedState),(o=Or||so(t,n,o,a,d,c,l))?(h||"function"!==typeof i.UNSAFE_componentWillMount&&"function"!==typeof i.componentWillMount||("function"===typeof i.componentWillMount&&i.componentWillMount(),"function"===typeof i.UNSAFE_componentWillMount&&i.UNSAFE_componentWillMount()),"function"===typeof i.componentDidMount&&(t.flags|=4194308)):("function"===typeof i.componentDidMount&&(t.flags|=4194308),t.memoizedProps=a,t.memoizedState=c),i.props=a,i.state=c,i.context=l,a=o):("function"===typeof i.componentDidMount&&(t.flags|=4194308),a=!1)}else{i=t.stateNode,Lr(e,t),o=t.memoizedProps,l=t.type===t.elementType?o:to(t.type,o),i.props=l,h=t.pendingProps,d=i.context,"object"===typeof(c=n.contextType)&&null!==c?c=_r(c):c=As(t,c=Ms(n)?_s:Es.current);var p=n.getDerivedStateFromProps;(u="function"===typeof p||"function"===typeof i.getSnapshotBeforeUpdate)||"function"!==typeof i.UNSAFE_componentWillReceiveProps&&"function"!==typeof i.componentWillReceiveProps||(o!==h||d!==c)&&io(t,i,a,c),Or=!1,d=t.memoizedState,i.state=d,Vr(t,a,i,s);var f=t.memoizedState;o!==h||d!==f||Rs.current||Or?("function"===typeof p&&(no(t,n,p,a),f=t.memoizedState),(l=Or||so(t,n,l,a,d,f,c)||!1)?(u||"function"!==typeof i.UNSAFE_componentWillUpdate&&"function"!==typeof i.componentWillUpdate||("function"===typeof i.componentWillUpdate&&i.componentWillUpdate(a,f,c),"function"===typeof i.UNSAFE_componentWillUpdate&&i.UNSAFE_componentWillUpdate(a,f,c)),"function"===typeof i.componentDidUpdate&&(t.flags|=4),"function"===typeof i.getSnapshotBeforeUpdate&&(t.flags|=1024)):("function"!==typeof i.componentDidUpdate||o===e.memoizedProps&&d===e.memoizedState||(t.flags|=4),"function"!==typeof i.getSnapshotBeforeUpdate||o===e.memoizedProps&&d===e.memoizedState||(t.flags|=1024),t.memoizedProps=a,t.memoizedState=f),i.props=a,i.state=f,i.context=c,a=l):("function"!==typeof i.componentDidUpdate||o===e.memoizedProps&&d===e.memoizedState||(t.flags|=4),"function"!==typeof i.getSnapshotBeforeUpdate||o===e.memoizedProps&&d===e.memoizedState||(t.flags|=1024),a=!1)}return Eo(e,t,n,a,r,s)}function Eo(e,t,n,a,s,r){Io(e,t);var i=0!==(128&t.flags);if(!a&&!i)return s&&Ls(t,n,!1),Uo(e,t,r);a=t.stateNode,bo.current=t;var o=i&&"function"!==typeof n.getDerivedStateFromError?null:a.render();return t.flags|=1,null!==e&&i?(t.child=vr(t,e.child,null,r),t.child=vr(t,null,o,r)):vo(e,t,o,r),t.memoizedState=a.state,s&&Ls(t,n,!0),t.child}function Ro(e){var t=e.stateNode;t.pendingContext?Ds(0,t.pendingContext,t.pendingContext!==t.context):t.context&&Ds(0,t.context,!1),Yr(e,t.containerInfo)}function _o(e,t,n,a,s){return pr(),fr(s),t.flags|=256,vo(e,t,n,a),t.child}var Ao,Mo,Po,Do={dehydrated:null,treeContext:null,retryLane:0};function Oo(e){return{baseLanes:e,cachePool:null,transitions:null}}function Fo(e,t,n){var a,s=t.pendingProps,i=$r.current,o=!1,c=0!==(128&t.flags);if((a=c)||(a=(null===e||null!==e.memoizedState)&&0!==(2&i)),a?(o=!0,t.flags&=-129):null!==e&&null===e.memoizedState||(i|=1),Ns($r,1&i),null===e)return lr(t),null!==(e=t.memoizedState)&&null!==(e=e.dehydrated)?(0===(1&t.mode)?t.lanes=1:"$!"===e.data?t.lanes=8:t.lanes=1073741824,null):(c=s.children,e=s.fallback,o?(s=t.mode,o=t.child,c={mode:"hidden",children:c},0===(1&s)&&null!==o?(o.childLanes=0,o.pendingProps=c):o=Ol(c,s,0,null),e=Dl(e,s,n,null),o.return=t,e.return=t,o.sibling=e,t.child=o,t.child.memoizedState=Oo(n),t.memoizedState=Do,e):Lo(t,c));if(null!==(i=e.memoizedState)&&null!==(a=i.dehydrated))return function(e,t,n,a,s,i,o){if(n)return 256&t.flags?(t.flags&=-257,zo(e,t,o,a=lo(Error(r(422))))):null!==t.memoizedState?(t.child=e.child,t.flags|=128,null):(i=a.fallback,s=t.mode,a=Ol({mode:"visible",children:a.children},s,0,null),(i=Dl(i,s,o,null)).flags|=2,a.return=t,i.return=t,a.sibling=i,t.child=a,0!==(1&t.mode)&&vr(t,e.child,null,o),t.child.memoizedState=Oo(o),t.memoizedState=Do,i);if(0===(1&t.mode))return zo(e,t,o,null);if("$!"===s.data){if(a=s.nextSibling&&s.nextSibling.dataset)var c=a.dgst;return a=c,zo(e,t,o,a=lo(i=Error(r(419)),a,void 0))}if(c=0!==(o&e.childLanes),xo||c){if(null!==(a=Ec)){switch(o&-o){case 4:s=2;break;case 16:s=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:s=32;break;case 536870912:s=268435456;break;default:s=0}0!==(s=0!==(s&(a.suspendedLanes|o))?0:s)&&s!==i.retryLane&&(i.retryLane=s,Dr(e,s),tl(a,e,s,-1))}return fl(),zo(e,t,o,a=lo(Error(r(421))))}return"$?"===s.data?(t.flags|=128,t.child=e.child,t=Nl.bind(null,e),s._reactRetry=t,null):(e=i.treeContext,ar=ls(s.nextSibling),nr=t,sr=!0,rr=null,null!==e&&(Ks[Xs++]=Qs,Ks[Xs++]=Zs,Ks[Xs++]=Ys,Qs=e.id,Zs=e.overflow,Ys=t),t=Lo(t,a.children),t.flags|=4096,t)}(e,t,c,s,a,i,n);if(o){o=s.fallback,c=t.mode,a=(i=e.child).sibling;var l={mode:"hidden",children:s.children};return 0===(1&c)&&t.child!==i?((s=t.child).childLanes=0,s.pendingProps=l,t.deletions=null):(s=Ml(i,l)).subtreeFlags=14680064&i.subtreeFlags,null!==a?o=Ml(a,o):(o=Dl(o,c,n,null)).flags|=2,o.return=t,s.return=t,s.sibling=o,t.child=s,s=o,o=t.child,c=null===(c=e.child.memoizedState)?Oo(n):{baseLanes:c.baseLanes|n,cachePool:null,transitions:c.transitions},o.memoizedState=c,o.childLanes=e.childLanes&~n,t.memoizedState=Do,s}return e=(o=e.child).sibling,s=Ml(o,{mode:"visible",children:s.children}),0===(1&t.mode)&&(s.lanes=n),s.return=t,s.sibling=null,null!==e&&(null===(n=t.deletions)?(t.deletions=[e],t.flags|=16):n.push(e)),t.child=s,t.memoizedState=null,s}function Lo(e,t){return(t=Ol({mode:"visible",children:t},e.mode,0,null)).return=e,e.child=t}function zo(e,t,n,a){return null!==a&&fr(a),vr(t,e.child,null,n),(e=Lo(t,t.pendingProps.children)).flags|=2,t.memoizedState=null,e}function Bo(e,t,n){e.lanes|=t;var a=e.alternate;null!==a&&(a.lanes|=t),Er(e.return,t,n)}function jo(e,t,n,a,s){var r=e.memoizedState;null===r?e.memoizedState={isBackwards:t,rendering:null,renderingStartTime:0,last:a,tail:n,tailMode:s}:(r.isBackwards=t,r.rendering=null,r.renderingStartTime=0,r.last=a,r.tail=n,r.tailMode=s)}function Wo(e,t,n){var a=t.pendingProps,s=a.revealOrder,r=a.tail;if(vo(e,t,a.children,n),0!==(2&(a=$r.current)))a=1&a|2,t.flags|=128;else{if(null!==e&&0!==(128&e.flags))e:for(e=t.child;null!==e;){if(13===e.tag)null!==e.memoizedState&&Bo(e,n,t);else if(19===e.tag)Bo(e,n,t);else if(null!==e.child){e.child.return=e,e=e.child;continue}if(e===t)break e;for(;null===e.sibling;){if(null===e.return||e.return===t)break e;e=e.return}e.sibling.return=e.return,e=e.sibling}a&=1}if(Ns($r,a),0===(1&t.mode))t.memoizedState=null;else switch(s){case"forwards":for(n=t.child,s=null;null!==n;)null!==(e=n.alternate)&&null===ei(e)&&(s=n),n=n.sibling;null===(n=s)?(s=t.child,t.child=null):(s=n.sibling,n.sibling=null),jo(t,!1,s,n,r);break;case"backwards":for(n=null,s=t.child,t.child=null;null!==s;){if(null!==(e=s.alternate)&&null===ei(e)){t.child=s;break}e=s.sibling,s.sibling=n,n=s,s=e}jo(t,!0,n,null,r);break;case"together":jo(t,!1,null,null,void 0);break;default:t.memoizedState=null}return t.child}function Vo(e,t){0===(1&t.mode)&&null!==e&&(e.alternate=null,t.alternate=null,t.flags|=2)}function Uo(e,t,n){if(null!==e&&(t.dependencies=e.dependencies),Oc|=t.lanes,0===(n&t.childLanes))return null;if(null!==e&&t.child!==e.child)throw Error(r(153));if(null!==t.child){for(n=Ml(e=t.child,e.pendingProps),t.child=n,n.return=t;null!==e.sibling;)e=e.sibling,(n=n.sibling=Ml(e,e.pendingProps)).return=t;n.sibling=null}return t.child}function Ho(e,t){if(!sr)switch(e.tailMode){case"hidden":t=e.tail;for(var n=null;null!==t;)null!==t.alternate&&(n=t),t=t.sibling;null===n?e.tail=null:n.sibling=null;break;case"collapsed":n=e.tail;for(var a=null;null!==n;)null!==n.alternate&&(a=n),n=n.sibling;null===a?t||null===e.tail?e.tail=null:e.tail.sibling=null:a.sibling=null}}function Go(e){var t=null!==e.alternate&&e.alternate.child===e.child,n=0,a=0;if(t)for(var s=e.child;null!==s;)n|=s.lanes|s.childLanes,a|=14680064&s.subtreeFlags,a|=14680064&s.flags,s.return=e,s=s.sibling;else for(s=e.child;null!==s;)n|=s.lanes|s.childLanes,a|=s.subtreeFlags,a|=s.flags,s.return=e,s=s.sibling;return e.subtreeFlags|=a,e.childLanes=n,t}function qo(e,t,n){var a=t.pendingProps;switch(tr(t),t.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return Go(t),null;case 1:case 17:return Ms(t.type)&&Ps(),Go(t),null;case 3:return a=t.stateNode,Qr(),Is(Rs),Is(Es),ni(),a.pendingContext&&(a.context=a.pendingContext,a.pendingContext=null),null!==e&&null!==e.child||(hr(t)?t.flags|=4:null===e||e.memoizedState.isDehydrated&&0===(256&t.flags)||(t.flags|=1024,null!==rr&&(rl(rr),rr=null))),Go(t),null;case 5:Jr(t);var s=Xr(Kr.current);if(n=t.type,null!==e&&null!=t.stateNode)Mo(e,t,n,a),e.ref!==t.ref&&(t.flags|=512,t.flags|=2097152);else{if(!a){if(null===t.stateNode)throw Error(r(166));return Go(t),null}if(e=Xr(Gr.current),hr(t)){a=t.stateNode,n=t.type;var i=t.memoizedProps;switch(a[ds]=t,a[ps]=i,e=0!==(1&t.mode),n){case"dialog":Ba("cancel",a),Ba("close",a);break;case"iframe":case"object":case"embed":Ba("load",a);break;case"video":case"audio":for(s=0;s<Oa.length;s++)Ba(Oa[s],a);break;case"source":Ba("error",a);break;case"img":case"image":case"link":Ba("error",a),Ba("load",a);break;case"details":Ba("toggle",a);break;case"input":Q(a,i),Ba("invalid",a);break;case"select":a._wrapperState={wasMultiple:!!i.multiple},Ba("invalid",a);break;case"textarea":se(a,i),Ba("invalid",a)}for(var c in be(n,i),s=null,i)if(i.hasOwnProperty(c)){var l=i[c];"children"===c?"string"===typeof l?a.textContent!==l&&(!0!==i.suppressHydrationWarning&&Ja(a.textContent,l,e),s=["children",l]):"number"===typeof l&&a.textContent!==""+l&&(!0!==i.suppressHydrationWarning&&Ja(a.textContent,l,e),s=["children",""+l]):o.hasOwnProperty(c)&&null!=l&&"onScroll"===c&&Ba("scroll",a)}switch(n){case"input":q(a),$(a,i,!0);break;case"textarea":q(a),ie(a);break;case"select":case"option":break;default:"function"===typeof i.onClick&&(a.onclick=$a)}a=s,t.updateQueue=a,null!==a&&(t.flags|=4)}else{c=9===s.nodeType?s:s.ownerDocument,"http://www.w3.org/1999/xhtml"===e&&(e=oe(n)),"http://www.w3.org/1999/xhtml"===e?"script"===n?((e=c.createElement("div")).innerHTML="<script><\/script>",e=e.removeChild(e.firstChild)):"string"===typeof a.is?e=c.createElement(n,{is:a.is}):(e=c.createElement(n),"select"===n&&(c=e,a.multiple?c.multiple=!0:a.size&&(c.size=a.size))):e=c.createElementNS(e,n),e[ds]=t,e[ps]=a,Ao(e,t),t.stateNode=e;e:{switch(c=xe(n,a),n){case"dialog":Ba("cancel",e),Ba("close",e),s=a;break;case"iframe":case"object":case"embed":Ba("load",e),s=a;break;case"video":case"audio":for(s=0;s<Oa.length;s++)Ba(Oa[s],e);s=a;break;case"source":Ba("error",e),s=a;break;case"img":case"image":case"link":Ba("error",e),Ba("load",e),s=a;break;case"details":Ba("toggle",e),s=a;break;case"input":Q(e,a),s=Y(e,a),Ba("invalid",e);break;case"option":default:s=a;break;case"select":e._wrapperState={wasMultiple:!!a.multiple},s=L({},a,{value:void 0}),Ba("invalid",e);break;case"textarea":se(e,a),s=ae(e,a),Ba("invalid",e)}for(i in be(n,s),l=s)if(l.hasOwnProperty(i)){var u=l[i];"style"===i?ge(e,u):"dangerouslySetInnerHTML"===i?null!=(u=u?u.__html:void 0)&&he(e,u):"children"===i?"string"===typeof u?("textarea"!==n||""!==u)&&de(e,u):"number"===typeof u&&de(e,""+u):"suppressContentEditableWarning"!==i&&"suppressHydrationWarning"!==i&&"autoFocus"!==i&&(o.hasOwnProperty(i)?null!=u&&"onScroll"===i&&Ba("scroll",e):null!=u&&x(e,i,u,c))}switch(n){case"input":q(e),$(e,a,!1);break;case"textarea":q(e),ie(e);break;case"option":null!=a.value&&e.setAttribute("value",""+H(a.value));break;case"select":e.multiple=!!a.multiple,null!=(i=a.value)?ne(e,!!a.multiple,i,!1):null!=a.defaultValue&&ne(e,!!a.multiple,a.defaultValue,!0);break;default:"function"===typeof s.onClick&&(e.onclick=$a)}switch(n){case"button":case"input":case"select":case"textarea":a=!!a.autoFocus;break e;case"img":a=!0;break e;default:a=!1}}a&&(t.flags|=4)}null!==t.ref&&(t.flags|=512,t.flags|=2097152)}return Go(t),null;case 6:if(e&&null!=t.stateNode)Po(0,t,e.memoizedProps,a);else{if("string"!==typeof a&&null===t.stateNode)throw Error(r(166));if(n=Xr(Kr.current),Xr(Gr.current),hr(t)){if(a=t.stateNode,n=t.memoizedProps,a[ds]=t,(i=a.nodeValue!==n)&&null!==(e=nr))switch(e.tag){case 3:Ja(a.nodeValue,n,0!==(1&e.mode));break;case 5:!0!==e.memoizedProps.suppressHydrationWarning&&Ja(a.nodeValue,n,0!==(1&e.mode))}i&&(t.flags|=4)}else(a=(9===n.nodeType?n:n.ownerDocument).createTextNode(a))[ds]=t,t.stateNode=a}return Go(t),null;case 13:if(Is($r),a=t.memoizedState,null===e||null!==e.memoizedState&&null!==e.memoizedState.dehydrated){if(sr&&null!==ar&&0!==(1&t.mode)&&0===(128&t.flags))dr(),pr(),t.flags|=98560,i=!1;else if(i=hr(t),null!==a&&null!==a.dehydrated){if(null===e){if(!i)throw Error(r(318));if(!(i=null!==(i=t.memoizedState)?i.dehydrated:null))throw Error(r(317));i[ds]=t}else pr(),0===(128&t.flags)&&(t.memoizedState=null),t.flags|=4;Go(t),i=!1}else null!==rr&&(rl(rr),rr=null),i=!0;if(!i)return 65536&t.flags?t:null}return 0!==(128&t.flags)?(t.lanes=n,t):((a=null!==a)!==(null!==e&&null!==e.memoizedState)&&a&&(t.child.flags|=8192,0!==(1&t.mode)&&(null===e||0!==(1&$r.current)?0===Pc&&(Pc=3):fl())),null!==t.updateQueue&&(t.flags|=4),Go(t),null);case 4:return Qr(),null===e&&Va(t.stateNode.containerInfo),Go(t),null;case 10:return Tr(t.type._context),Go(t),null;case 19:if(Is($r),null===(i=t.memoizedState))return Go(t),null;if(a=0!==(128&t.flags),null===(c=i.rendering))if(a)Ho(i,!1);else{if(0!==Pc||null!==e&&0!==(128&e.flags))for(e=t.child;null!==e;){if(null!==(c=ei(e))){for(t.flags|=128,Ho(i,!1),null!==(a=c.updateQueue)&&(t.updateQueue=a,t.flags|=4),t.subtreeFlags=0,a=n,n=t.child;null!==n;)e=a,(i=n).flags&=14680066,null===(c=i.alternate)?(i.childLanes=0,i.lanes=e,i.child=null,i.subtreeFlags=0,i.memoizedProps=null,i.memoizedState=null,i.updateQueue=null,i.dependencies=null,i.stateNode=null):(i.childLanes=c.childLanes,i.lanes=c.lanes,i.child=c.child,i.subtreeFlags=0,i.deletions=null,i.memoizedProps=c.memoizedProps,i.memoizedState=c.memoizedState,i.updateQueue=c.updateQueue,i.type=c.type,e=c.dependencies,i.dependencies=null===e?null:{lanes:e.lanes,firstContext:e.firstContext}),n=n.sibling;return Ns($r,1&$r.current|2),t.child}e=e.sibling}null!==i.tail&&Ze()>Wc&&(t.flags|=128,a=!0,Ho(i,!1),t.lanes=4194304)}else{if(!a)if(null!==(e=ei(c))){if(t.flags|=128,a=!0,null!==(n=e.updateQueue)&&(t.updateQueue=n,t.flags|=4),Ho(i,!0),null===i.tail&&"hidden"===i.tailMode&&!c.alternate&&!sr)return Go(t),null}else 2*Ze()-i.renderingStartTime>Wc&&1073741824!==n&&(t.flags|=128,a=!0,Ho(i,!1),t.lanes=4194304);i.isBackwards?(c.sibling=t.child,t.child=c):(null!==(n=i.last)?n.sibling=c:t.child=c,i.last=c)}return null!==i.tail?(t=i.tail,i.rendering=t,i.tail=t.sibling,i.renderingStartTime=Ze(),t.sibling=null,n=$r.current,Ns($r,a?1&n|2:1&n),t):(Go(t),null);case 22:case 23:return ul(),a=null!==t.memoizedState,null!==e&&null!==e.memoizedState!==a&&(t.flags|=8192),a&&0!==(1&t.mode)?0!==(1073741824&Ac)&&(Go(t),6&t.subtreeFlags&&(t.flags|=8192)):Go(t),null;case 24:case 25:return null}throw Error(r(156,t.tag))}function Ko(e,t){switch(tr(t),t.tag){case 1:return Ms(t.type)&&Ps(),65536&(e=t.flags)?(t.flags=-65537&e|128,t):null;case 3:return Qr(),Is(Rs),Is(Es),ni(),0!==(65536&(e=t.flags))&&0===(128&e)?(t.flags=-65537&e|128,t):null;case 5:return Jr(t),null;case 13:if(Is($r),null!==(e=t.memoizedState)&&null!==e.dehydrated){if(null===t.alternate)throw Error(r(340));pr()}return 65536&(e=t.flags)?(t.flags=-65537&e|128,t):null;case 19:return Is($r),null;case 4:return Qr(),null;case 10:return Tr(t.type._context),null;case 22:case 23:return ul(),null;default:return null}}Ao=function(e,t){for(var n=t.child;null!==n;){if(5===n.tag||6===n.tag)e.appendChild(n.stateNode);else if(4!==n.tag&&null!==n.child){n.child.return=n,n=n.child;continue}if(n===t)break;for(;null===n.sibling;){if(null===n.return||n.return===t)return;n=n.return}n.sibling.return=n.return,n=n.sibling}},Mo=function(e,t,n,a){var s=e.memoizedProps;if(s!==a){e=t.stateNode,Xr(Gr.current);var r,i=null;switch(n){case"input":s=Y(e,s),a=Y(e,a),i=[];break;case"select":s=L({},s,{value:void 0}),a=L({},a,{value:void 0}),i=[];break;case"textarea":s=ae(e,s),a=ae(e,a),i=[];break;default:"function"!==typeof s.onClick&&"function"===typeof a.onClick&&(e.onclick=$a)}for(u in be(n,a),n=null,s)if(!a.hasOwnProperty(u)&&s.hasOwnProperty(u)&&null!=s[u])if("style"===u){var c=s[u];for(r in c)c.hasOwnProperty(r)&&(n||(n={}),n[r]="")}else"dangerouslySetInnerHTML"!==u&&"children"!==u&&"suppressContentEditableWarning"!==u&&"suppressHydrationWarning"!==u&&"autoFocus"!==u&&(o.hasOwnProperty(u)?i||(i=[]):(i=i||[]).push(u,null));for(u in a){var l=a[u];if(c=null!=s?s[u]:void 0,a.hasOwnProperty(u)&&l!==c&&(null!=l||null!=c))if("style"===u)if(c){for(r in c)!c.hasOwnProperty(r)||l&&l.hasOwnProperty(r)||(n||(n={}),n[r]="");for(r in l)l.hasOwnProperty(r)&&c[r]!==l[r]&&(n||(n={}),n[r]=l[r])}else n||(i||(i=[]),i.push(u,n)),n=l;else"dangerouslySetInnerHTML"===u?(l=l?l.__html:void 0,c=c?c.__html:void 0,null!=l&&c!==l&&(i=i||[]).push(u,l)):"children"===u?"string"!==typeof l&&"number"!==typeof l||(i=i||[]).push(u,""+l):"suppressContentEditableWarning"!==u&&"suppressHydrationWarning"!==u&&(o.hasOwnProperty(u)?(null!=l&&"onScroll"===u&&Ba("scroll",e),i||c===l||(i=[])):(i=i||[]).push(u,l))}n&&(i=i||[]).push("style",n);var u=i;(t.updateQueue=u)&&(t.flags|=4)}},Po=function(e,t,n,a){n!==a&&(t.flags|=4)};var Xo=!1,Yo=!1,Qo="function"===typeof WeakSet?WeakSet:Set,Zo=null;function Jo(e,t){var n=e.ref;if(null!==n)if("function"===typeof n)try{n(null)}catch(a){Sl(e,t,a)}else n.current=null}function $o(e,t,n){try{n()}catch(a){Sl(e,t,a)}}var ec=!1;function tc(e,t,n){var a=t.updateQueue;if(null!==(a=null!==a?a.lastEffect:null)){var s=a=a.next;do{if((s.tag&e)===e){var r=s.destroy;s.destroy=void 0,void 0!==r&&$o(t,n,r)}s=s.next}while(s!==a)}}function nc(e,t){if(null!==(t=null!==(t=t.updateQueue)?t.lastEffect:null)){var n=t=t.next;do{if((n.tag&e)===e){var a=n.create;n.destroy=a()}n=n.next}while(n!==t)}}function ac(e){var t=e.ref;if(null!==t){var n=e.stateNode;e.tag,e=n,"function"===typeof t?t(e):t.current=e}}function sc(e){var t=e.alternate;null!==t&&(e.alternate=null,sc(t)),e.child=null,e.deletions=null,e.sibling=null,5===e.tag&&(null!==(t=e.stateNode)&&(delete t[ds],delete t[ps],delete t[ms],delete t[gs],delete t[ys])),e.stateNode=null,e.return=null,e.dependencies=null,e.memoizedProps=null,e.memoizedState=null,e.pendingProps=null,e.stateNode=null,e.updateQueue=null}function rc(e){return 5===e.tag||3===e.tag||4===e.tag}function ic(e){e:for(;;){for(;null===e.sibling;){if(null===e.return||rc(e.return))return null;e=e.return}for(e.sibling.return=e.return,e=e.sibling;5!==e.tag&&6!==e.tag&&18!==e.tag;){if(2&e.flags)continue e;if(null===e.child||4===e.tag)continue e;e.child.return=e,e=e.child}if(!(2&e.flags))return e.stateNode}}function oc(e,t,n){var a=e.tag;if(5===a||6===a)e=e.stateNode,t?8===n.nodeType?n.parentNode.insertBefore(e,t):n.insertBefore(e,t):(8===n.nodeType?(t=n.parentNode).insertBefore(e,n):(t=n).appendChild(e),null!==(n=n._reactRootContainer)&&void 0!==n||null!==t.onclick||(t.onclick=$a));else if(4!==a&&null!==(e=e.child))for(oc(e,t,n),e=e.sibling;null!==e;)oc(e,t,n),e=e.sibling}function cc(e,t,n){var a=e.tag;if(5===a||6===a)e=e.stateNode,t?n.insertBefore(e,t):n.appendChild(e);else if(4!==a&&null!==(e=e.child))for(cc(e,t,n),e=e.sibling;null!==e;)cc(e,t,n),e=e.sibling}var lc=null,uc=!1;function hc(e,t,n){for(n=n.child;null!==n;)dc(e,t,n),n=n.sibling}function dc(e,t,n){if(rt&&"function"===typeof rt.onCommitFiberUnmount)try{rt.onCommitFiberUnmount(st,n)}catch(o){}switch(n.tag){case 5:Yo||Jo(n,t);case 6:var a=lc,s=uc;lc=null,hc(e,t,n),uc=s,null!==(lc=a)&&(uc?(e=lc,n=n.stateNode,8===e.nodeType?e.parentNode.removeChild(n):e.removeChild(n)):lc.removeChild(n.stateNode));break;case 18:null!==lc&&(uc?(e=lc,n=n.stateNode,8===e.nodeType?cs(e.parentNode,n):1===e.nodeType&&cs(e,n),Vt(e)):cs(lc,n.stateNode));break;case 4:a=lc,s=uc,lc=n.stateNode.containerInfo,uc=!0,hc(e,t,n),lc=a,uc=s;break;case 0:case 11:case 14:case 15:if(!Yo&&(null!==(a=n.updateQueue)&&null!==(a=a.lastEffect))){s=a=a.next;do{var r=s,i=r.destroy;r=r.tag,void 0!==i&&(0!==(2&r)||0!==(4&r))&&$o(n,t,i),s=s.next}while(s!==a)}hc(e,t,n);break;case 1:if(!Yo&&(Jo(n,t),"function"===typeof(a=n.stateNode).componentWillUnmount))try{a.props=n.memoizedProps,a.state=n.memoizedState,a.componentWillUnmount()}catch(o){Sl(n,t,o)}hc(e,t,n);break;case 21:hc(e,t,n);break;case 22:1&n.mode?(Yo=(a=Yo)||null!==n.memoizedState,hc(e,t,n),Yo=a):hc(e,t,n);break;default:hc(e,t,n)}}function pc(e){var t=e.updateQueue;if(null!==t){e.updateQueue=null;var n=e.stateNode;null===n&&(n=e.stateNode=new Qo),t.forEach(function(t){var a=Tl.bind(null,e,t);n.has(t)||(n.add(t),t.then(a,a))})}}function fc(e,t){var n=t.deletions;if(null!==n)for(var a=0;a<n.length;a++){var s=n[a];try{var i=e,o=t,c=o;e:for(;null!==c;){switch(c.tag){case 5:lc=c.stateNode,uc=!1;break e;case 3:case 4:lc=c.stateNode.containerInfo,uc=!0;break e}c=c.return}if(null===lc)throw Error(r(160));dc(i,o,s),lc=null,uc=!1;var l=s.alternate;null!==l&&(l.return=null),s.return=null}catch(u){Sl(s,t,u)}}if(12854&t.subtreeFlags)for(t=t.child;null!==t;)mc(t,e),t=t.sibling}function mc(e,t){var n=e.alternate,a=e.flags;switch(e.tag){case 0:case 11:case 14:case 15:if(fc(t,e),gc(e),4&a){try{tc(3,e,e.return),nc(3,e)}catch(g){Sl(e,e.return,g)}try{tc(5,e,e.return)}catch(g){Sl(e,e.return,g)}}break;case 1:fc(t,e),gc(e),512&a&&null!==n&&Jo(n,n.return);break;case 5:if(fc(t,e),gc(e),512&a&&null!==n&&Jo(n,n.return),32&e.flags){var s=e.stateNode;try{de(s,"")}catch(g){Sl(e,e.return,g)}}if(4&a&&null!=(s=e.stateNode)){var i=e.memoizedProps,o=null!==n?n.memoizedProps:i,c=e.type,l=e.updateQueue;if(e.updateQueue=null,null!==l)try{"input"===c&&"radio"===i.type&&null!=i.name&&Z(s,i),xe(c,o);var u=xe(c,i);for(o=0;o<l.length;o+=2){var h=l[o],d=l[o+1];"style"===h?ge(s,d):"dangerouslySetInnerHTML"===h?he(s,d):"children"===h?de(s,d):x(s,h,d,u)}switch(c){case"input":J(s,i);break;case"textarea":re(s,i);break;case"select":var p=s._wrapperState.wasMultiple;s._wrapperState.wasMultiple=!!i.multiple;var f=i.value;null!=f?ne(s,!!i.multiple,f,!1):p!==!!i.multiple&&(null!=i.defaultValue?ne(s,!!i.multiple,i.defaultValue,!0):ne(s,!!i.multiple,i.multiple?[]:"",!1))}s[ps]=i}catch(g){Sl(e,e.return,g)}}break;case 6:if(fc(t,e),gc(e),4&a){if(null===e.stateNode)throw Error(r(162));s=e.stateNode,i=e.memoizedProps;try{s.nodeValue=i}catch(g){Sl(e,e.return,g)}}break;case 3:if(fc(t,e),gc(e),4&a&&null!==n&&n.memoizedState.isDehydrated)try{Vt(t.containerInfo)}catch(g){Sl(e,e.return,g)}break;case 4:default:fc(t,e),gc(e);break;case 13:fc(t,e),gc(e),8192&(s=e.child).flags&&(i=null!==s.memoizedState,s.stateNode.isHidden=i,!i||null!==s.alternate&&null!==s.alternate.memoizedState||(jc=Ze())),4&a&&pc(e);break;case 22:if(h=null!==n&&null!==n.memoizedState,1&e.mode?(Yo=(u=Yo)||h,fc(t,e),Yo=u):fc(t,e),gc(e),8192&a){if(u=null!==e.memoizedState,(e.stateNode.isHidden=u)&&!h&&0!==(1&e.mode))for(Zo=e,h=e.child;null!==h;){for(d=Zo=h;null!==Zo;){switch(f=(p=Zo).child,p.tag){case 0:case 11:case 14:case 15:tc(4,p,p.return);break;case 1:Jo(p,p.return);var m=p.stateNode;if("function"===typeof m.componentWillUnmount){a=p,n=p.return;try{t=a,m.props=t.memoizedProps,m.state=t.memoizedState,m.componentWillUnmount()}catch(g){Sl(a,n,g)}}break;case 5:Jo(p,p.return);break;case 22:if(null!==p.memoizedState){vc(d);continue}}null!==f?(f.return=p,Zo=f):vc(d)}h=h.sibling}e:for(h=null,d=e;;){if(5===d.tag){if(null===h){h=d;try{s=d.stateNode,u?"function"===typeof(i=s.style).setProperty?i.setProperty("display","none","important"):i.display="none":(c=d.stateNode,o=void 0!==(l=d.memoizedProps.style)&&null!==l&&l.hasOwnProperty("display")?l.display:null,c.style.display=me("display",o))}catch(g){Sl(e,e.return,g)}}}else if(6===d.tag){if(null===h)try{d.stateNode.nodeValue=u?"":d.memoizedProps}catch(g){Sl(e,e.return,g)}}else if((22!==d.tag&&23!==d.tag||null===d.memoizedState||d===e)&&null!==d.child){d.child.return=d,d=d.child;continue}if(d===e)break e;for(;null===d.sibling;){if(null===d.return||d.return===e)break e;h===d&&(h=null),d=d.return}h===d&&(h=null),d.sibling.return=d.return,d=d.sibling}}break;case 19:fc(t,e),gc(e),4&a&&pc(e);case 21:}}function gc(e){var t=e.flags;if(2&t){try{e:{for(var n=e.return;null!==n;){if(rc(n)){var a=n;break e}n=n.return}throw Error(r(160))}switch(a.tag){case 5:var s=a.stateNode;32&a.flags&&(de(s,""),a.flags&=-33),cc(e,ic(e),s);break;case 3:case 4:var i=a.stateNode.containerInfo;oc(e,ic(e),i);break;default:throw Error(r(161))}}catch(o){Sl(e,e.return,o)}e.flags&=-3}4096&t&&(e.flags&=-4097)}function yc(e,t,n){Zo=e,bc(e,t,n)}function bc(e,t,n){for(var a=0!==(1&e.mode);null!==Zo;){var s=Zo,r=s.child;if(22===s.tag&&a){var i=null!==s.memoizedState||Xo;if(!i){var o=s.alternate,c=null!==o&&null!==o.memoizedState||Yo;o=Xo;var l=Yo;if(Xo=i,(Yo=c)&&!l)for(Zo=s;null!==Zo;)c=(i=Zo).child,22===i.tag&&null!==i.memoizedState?wc(s):null!==c?(c.return=i,Zo=c):wc(s);for(;null!==r;)Zo=r,bc(r,t,n),r=r.sibling;Zo=s,Xo=o,Yo=l}xc(e)}else 0!==(8772&s.subtreeFlags)&&null!==r?(r.return=s,Zo=r):xc(e)}}function xc(e){for(;null!==Zo;){var t=Zo;if(0!==(8772&t.flags)){var n=t.alternate;try{if(0!==(8772&t.flags))switch(t.tag){case 0:case 11:case 15:Yo||nc(5,t);break;case 1:var a=t.stateNode;if(4&t.flags&&!Yo)if(null===n)a.componentDidMount();else{var s=t.elementType===t.type?n.memoizedProps:to(t.type,n.memoizedProps);a.componentDidUpdate(s,n.memoizedState,a.__reactInternalSnapshotBeforeUpdate)}var i=t.updateQueue;null!==i&&Ur(t,i,a);break;case 3:var o=t.updateQueue;if(null!==o){if(n=null,null!==t.child)switch(t.child.tag){case 5:case 1:n=t.child.stateNode}Ur(t,o,n)}break;case 5:var c=t.stateNode;if(null===n&&4&t.flags){n=c;var l=t.memoizedProps;switch(t.type){case"button":case"input":case"select":case"textarea":l.autoFocus&&n.focus();break;case"img":l.src&&(n.src=l.src)}}break;case 6:case 4:case 12:case 19:case 17:case 21:case 22:case 23:case 25:break;case 13:if(null===t.memoizedState){var u=t.alternate;if(null!==u){var h=u.memoizedState;if(null!==h){var d=h.dehydrated;null!==d&&Vt(d)}}}break;default:throw Error(r(163))}Yo||512&t.flags&&ac(t)}catch(p){Sl(t,t.return,p)}}if(t===e){Zo=null;break}if(null!==(n=t.sibling)){n.return=t.return,Zo=n;break}Zo=t.return}}function vc(e){for(;null!==Zo;){var t=Zo;if(t===e){Zo=null;break}var n=t.sibling;if(null!==n){n.return=t.return,Zo=n;break}Zo=t.return}}function wc(e){for(;null!==Zo;){var t=Zo;try{switch(t.tag){case 0:case 11:case 15:var n=t.return;try{nc(4,t)}catch(c){Sl(t,n,c)}break;case 1:var a=t.stateNode;if("function"===typeof a.componentDidMount){var s=t.return;try{a.componentDidMount()}catch(c){Sl(t,s,c)}}var r=t.return;try{ac(t)}catch(c){Sl(t,r,c)}break;case 5:var i=t.return;try{ac(t)}catch(c){Sl(t,i,c)}}}catch(c){Sl(t,t.return,c)}if(t===e){Zo=null;break}var o=t.sibling;if(null!==o){o.return=t.return,Zo=o;break}Zo=t.return}}var kc,Sc=Math.ceil,Cc=v.ReactCurrentDispatcher,Ic=v.ReactCurrentOwner,Nc=v.ReactCurrentBatchConfig,Tc=0,Ec=null,Rc=null,_c=0,Ac=0,Mc=Cs(0),Pc=0,Dc=null,Oc=0,Fc=0,Lc=0,zc=null,Bc=null,jc=0,Wc=1/0,Vc=null,Uc=!1,Hc=null,Gc=null,qc=!1,Kc=null,Xc=0,Yc=0,Qc=null,Zc=-1,Jc=0;function $c(){return 0!==(6&Tc)?Ze():-1!==Zc?Zc:Zc=Ze()}function el(e){return 0===(1&e.mode)?1:0!==(2&Tc)&&0!==_c?_c&-_c:null!==mr.transition?(0===Jc&&(Jc=mt()),Jc):0!==(e=xt)?e:e=void 0===(e=window.event)?16:Qt(e.type)}function tl(e,t,n,a){if(50<Yc)throw Yc=0,Qc=null,Error(r(185));yt(e,n,a),0!==(2&Tc)&&e===Ec||(e===Ec&&(0===(2&Tc)&&(Fc|=n),4===Pc&&il(e,_c)),nl(e,a),1===n&&0===Tc&&0===(1&t.mode)&&(Wc=Ze()+500,Bs&&Vs()))}function nl(e,t){var n=e.callbackNode;!function(e,t){for(var n=e.suspendedLanes,a=e.pingedLanes,s=e.expirationTimes,r=e.pendingLanes;0<r;){var i=31-it(r),o=1<<i,c=s[i];-1===c?0!==(o&n)&&0===(o&a)||(s[i]=pt(o,t)):c<=t&&(e.expiredLanes|=o),r&=~o}}(e,t);var a=dt(e,e===Ec?_c:0);if(0===a)null!==n&&Xe(n),e.callbackNode=null,e.callbackPriority=0;else if(t=a&-a,e.callbackPriority!==t){if(null!=n&&Xe(n),1===t)0===e.tag?function(e){Bs=!0,Ws(e)}(ol.bind(null,e)):Ws(ol.bind(null,e)),is(function(){0===(6&Tc)&&Vs()}),n=null;else{switch(vt(a)){case 1:n=$e;break;case 4:n=et;break;case 16:default:n=tt;break;case 536870912:n=at}n=El(n,al.bind(null,e))}e.callbackPriority=t,e.callbackNode=n}}function al(e,t){if(Zc=-1,Jc=0,0!==(6&Tc))throw Error(r(327));var n=e.callbackNode;if(wl()&&e.callbackNode!==n)return null;var a=dt(e,e===Ec?_c:0);if(0===a)return null;if(0!==(30&a)||0!==(a&e.expiredLanes)||t)t=ml(e,a);else{t=a;var s=Tc;Tc|=2;var i=pl();for(Ec===e&&_c===t||(Vc=null,Wc=Ze()+500,hl(e,t));;)try{yl();break}catch(c){dl(e,c)}Nr(),Cc.current=i,Tc=s,null!==Rc?t=0:(Ec=null,_c=0,t=Pc)}if(0!==t){if(2===t&&(0!==(s=ft(e))&&(a=s,t=sl(e,s))),1===t)throw n=Dc,hl(e,0),il(e,a),nl(e,Ze()),n;if(6===t)il(e,a);else{if(s=e.current.alternate,0===(30&a)&&!function(e){for(var t=e;;){if(16384&t.flags){var n=t.updateQueue;if(null!==n&&null!==(n=n.stores))for(var a=0;a<n.length;a++){var s=n[a],r=s.getSnapshot;s=s.value;try{if(!oa(r(),s))return!1}catch(o){return!1}}}if(n=t.child,16384&t.subtreeFlags&&null!==n)n.return=t,t=n;else{if(t===e)break;for(;null===t.sibling;){if(null===t.return||t.return===e)return!0;t=t.return}t.sibling.return=t.return,t=t.sibling}}return!0}(s)&&(2===(t=ml(e,a))&&(0!==(i=ft(e))&&(a=i,t=sl(e,i))),1===t))throw n=Dc,hl(e,0),il(e,a),nl(e,Ze()),n;switch(e.finishedWork=s,e.finishedLanes=a,t){case 0:case 1:throw Error(r(345));case 2:case 5:vl(e,Bc,Vc);break;case 3:if(il(e,a),(130023424&a)===a&&10<(t=jc+500-Ze())){if(0!==dt(e,0))break;if(((s=e.suspendedLanes)&a)!==a){$c(),e.pingedLanes|=e.suspendedLanes&s;break}e.timeoutHandle=as(vl.bind(null,e,Bc,Vc),t);break}vl(e,Bc,Vc);break;case 4:if(il(e,a),(4194240&a)===a)break;for(t=e.eventTimes,s=-1;0<a;){var o=31-it(a);i=1<<o,(o=t[o])>s&&(s=o),a&=~i}if(a=s,10<(a=(120>(a=Ze()-a)?120:480>a?480:1080>a?1080:1920>a?1920:3e3>a?3e3:4320>a?4320:1960*Sc(a/1960))-a)){e.timeoutHandle=as(vl.bind(null,e,Bc,Vc),a);break}vl(e,Bc,Vc);break;default:throw Error(r(329))}}}return nl(e,Ze()),e.callbackNode===n?al.bind(null,e):null}function sl(e,t){var n=zc;return e.current.memoizedState.isDehydrated&&(hl(e,t).flags|=256),2!==(e=ml(e,t))&&(t=Bc,Bc=n,null!==t&&rl(t)),e}function rl(e){null===Bc?Bc=e:Bc.push.apply(Bc,e)}function il(e,t){for(t&=~Lc,t&=~Fc,e.suspendedLanes|=t,e.pingedLanes&=~t,e=e.expirationTimes;0<t;){var n=31-it(t),a=1<<n;e[n]=-1,t&=~a}}function ol(e){if(0!==(6&Tc))throw Error(r(327));wl();var t=dt(e,0);if(0===(1&t))return nl(e,Ze()),null;var n=ml(e,t);if(0!==e.tag&&2===n){var a=ft(e);0!==a&&(t=a,n=sl(e,a))}if(1===n)throw n=Dc,hl(e,0),il(e,t),nl(e,Ze()),n;if(6===n)throw Error(r(345));return e.finishedWork=e.current.alternate,e.finishedLanes=t,vl(e,Bc,Vc),nl(e,Ze()),null}function cl(e,t){var n=Tc;Tc|=1;try{return e(t)}finally{0===(Tc=n)&&(Wc=Ze()+500,Bs&&Vs())}}function ll(e){null!==Kc&&0===Kc.tag&&0===(6&Tc)&&wl();var t=Tc;Tc|=1;var n=Nc.transition,a=xt;try{if(Nc.transition=null,xt=1,e)return e()}finally{xt=a,Nc.transition=n,0===(6&(Tc=t))&&Vs()}}function ul(){Ac=Mc.current,Is(Mc)}function hl(e,t){e.finishedWork=null,e.finishedLanes=0;var n=e.timeoutHandle;if(-1!==n&&(e.timeoutHandle=-1,ss(n)),null!==Rc)for(n=Rc.return;null!==n;){var a=n;switch(tr(a),a.tag){case 1:null!==(a=a.type.childContextTypes)&&void 0!==a&&Ps();break;case 3:Qr(),Is(Rs),Is(Es),ni();break;case 5:Jr(a);break;case 4:Qr();break;case 13:case 19:Is($r);break;case 10:Tr(a.type._context);break;case 22:case 23:ul()}n=n.return}if(Ec=e,Rc=e=Ml(e.current,null),_c=Ac=t,Pc=0,Dc=null,Lc=Fc=Oc=0,Bc=zc=null,null!==Ar){for(t=0;t<Ar.length;t++)if(null!==(a=(n=Ar[t]).interleaved)){n.interleaved=null;var s=a.next,r=n.pending;if(null!==r){var i=r.next;r.next=s,a.next=i}n.pending=a}Ar=null}return e}function dl(e,t){for(;;){var n=Rc;try{if(Nr(),ai.current=Zi,li){for(var a=ii.memoizedState;null!==a;){var s=a.queue;null!==s&&(s.pending=null),a=a.next}li=!1}if(ri=0,ci=oi=ii=null,ui=!1,hi=0,Ic.current=null,null===n||null===n.return){Pc=1,Dc=t,Rc=null;break}e:{var i=e,o=n.return,c=n,l=t;if(t=_c,c.flags|=32768,null!==l&&"object"===typeof l&&"function"===typeof l.then){var u=l,h=c,d=h.tag;if(0===(1&h.mode)&&(0===d||11===d||15===d)){var p=h.alternate;p?(h.updateQueue=p.updateQueue,h.memoizedState=p.memoizedState,h.lanes=p.lanes):(h.updateQueue=null,h.memoizedState=null)}var f=go(o);if(null!==f){f.flags&=-257,yo(f,o,c,0,t),1&f.mode&&mo(i,u,t),l=u;var m=(t=f).updateQueue;if(null===m){var g=new Set;g.add(l),t.updateQueue=g}else m.add(l);break e}if(0===(1&t)){mo(i,u,t),fl();break e}l=Error(r(426))}else if(sr&&1&c.mode){var y=go(o);if(null!==y){0===(65536&y.flags)&&(y.flags|=256),yo(y,o,c,0,t),fr(co(l,c));break e}}i=l=co(l,c),4!==Pc&&(Pc=2),null===zc?zc=[i]:zc.push(i),i=o;do{switch(i.tag){case 3:i.flags|=65536,t&=-t,i.lanes|=t,Wr(i,po(0,l,t));break e;case 1:c=l;var b=i.type,x=i.stateNode;if(0===(128&i.flags)&&("function"===typeof b.getDerivedStateFromError||null!==x&&"function"===typeof x.componentDidCatch&&(null===Gc||!Gc.has(x)))){i.flags|=65536,t&=-t,i.lanes|=t,Wr(i,fo(i,c,t));break e}}i=i.return}while(null!==i)}xl(n)}catch(v){t=v,Rc===n&&null!==n&&(Rc=n=n.return);continue}break}}function pl(){var e=Cc.current;return Cc.current=Zi,null===e?Zi:e}function fl(){0!==Pc&&3!==Pc&&2!==Pc||(Pc=4),null===Ec||0===(268435455&Oc)&&0===(268435455&Fc)||il(Ec,_c)}function ml(e,t){var n=Tc;Tc|=2;var a=pl();for(Ec===e&&_c===t||(Vc=null,hl(e,t));;)try{gl();break}catch(s){dl(e,s)}if(Nr(),Tc=n,Cc.current=a,null!==Rc)throw Error(r(261));return Ec=null,_c=0,Pc}function gl(){for(;null!==Rc;)bl(Rc)}function yl(){for(;null!==Rc&&!Ye();)bl(Rc)}function bl(e){var t=kc(e.alternate,e,Ac);e.memoizedProps=e.pendingProps,null===t?xl(e):Rc=t,Ic.current=null}function xl(e){var t=e;do{var n=t.alternate;if(e=t.return,0===(32768&t.flags)){if(null!==(n=qo(n,t,Ac)))return void(Rc=n)}else{if(null!==(n=Ko(n,t)))return n.flags&=32767,void(Rc=n);if(null===e)return Pc=6,void(Rc=null);e.flags|=32768,e.subtreeFlags=0,e.deletions=null}if(null!==(t=t.sibling))return void(Rc=t);Rc=t=e}while(null!==t);0===Pc&&(Pc=5)}function vl(e,t,n){var a=xt,s=Nc.transition;try{Nc.transition=null,xt=1,function(e,t,n,a){do{wl()}while(null!==Kc);if(0!==(6&Tc))throw Error(r(327));n=e.finishedWork;var s=e.finishedLanes;if(null===n)return null;if(e.finishedWork=null,e.finishedLanes=0,n===e.current)throw Error(r(177));e.callbackNode=null,e.callbackPriority=0;var i=n.lanes|n.childLanes;if(function(e,t){var n=e.pendingLanes&~t;e.pendingLanes=t,e.suspendedLanes=0,e.pingedLanes=0,e.expiredLanes&=t,e.mutableReadLanes&=t,e.entangledLanes&=t,t=e.entanglements;var a=e.eventTimes;for(e=e.expirationTimes;0<n;){var s=31-it(n),r=1<<s;t[s]=0,a[s]=-1,e[s]=-1,n&=~r}}(e,i),e===Ec&&(Rc=Ec=null,_c=0),0===(2064&n.subtreeFlags)&&0===(2064&n.flags)||qc||(qc=!0,El(tt,function(){return wl(),null})),i=0!==(15990&n.flags),0!==(15990&n.subtreeFlags)||i){i=Nc.transition,Nc.transition=null;var o=xt;xt=1;var c=Tc;Tc|=4,Ic.current=null,function(e,t){if(es=Ht,pa(e=da())){if("selectionStart"in e)var n={start:e.selectionStart,end:e.selectionEnd};else e:{var a=(n=(n=e.ownerDocument)&&n.defaultView||window).getSelection&&n.getSelection();if(a&&0!==a.rangeCount){n=a.anchorNode;var s=a.anchorOffset,i=a.focusNode;a=a.focusOffset;try{n.nodeType,i.nodeType}catch(w){n=null;break e}var o=0,c=-1,l=-1,u=0,h=0,d=e,p=null;t:for(;;){for(var f;d!==n||0!==s&&3!==d.nodeType||(c=o+s),d!==i||0!==a&&3!==d.nodeType||(l=o+a),3===d.nodeType&&(o+=d.nodeValue.length),null!==(f=d.firstChild);)p=d,d=f;for(;;){if(d===e)break t;if(p===n&&++u===s&&(c=o),p===i&&++h===a&&(l=o),null!==(f=d.nextSibling))break;p=(d=p).parentNode}d=f}n=-1===c||-1===l?null:{start:c,end:l}}else n=null}n=n||{start:0,end:0}}else n=null;for(ts={focusedElem:e,selectionRange:n},Ht=!1,Zo=t;null!==Zo;)if(e=(t=Zo).child,0!==(1028&t.subtreeFlags)&&null!==e)e.return=t,Zo=e;else for(;null!==Zo;){t=Zo;try{var m=t.alternate;if(0!==(1024&t.flags))switch(t.tag){case 0:case 11:case 15:case 5:case 6:case 4:case 17:break;case 1:if(null!==m){var g=m.memoizedProps,y=m.memoizedState,b=t.stateNode,x=b.getSnapshotBeforeUpdate(t.elementType===t.type?g:to(t.type,g),y);b.__reactInternalSnapshotBeforeUpdate=x}break;case 3:var v=t.stateNode.containerInfo;1===v.nodeType?v.textContent="":9===v.nodeType&&v.documentElement&&v.removeChild(v.documentElement);break;default:throw Error(r(163))}}catch(w){Sl(t,t.return,w)}if(null!==(e=t.sibling)){e.return=t.return,Zo=e;break}Zo=t.return}m=ec,ec=!1}(e,n),mc(n,e),fa(ts),Ht=!!es,ts=es=null,e.current=n,yc(n,e,s),Qe(),Tc=c,xt=o,Nc.transition=i}else e.current=n;if(qc&&(qc=!1,Kc=e,Xc=s),i=e.pendingLanes,0===i&&(Gc=null),function(e){if(rt&&"function"===typeof rt.onCommitFiberRoot)try{rt.onCommitFiberRoot(st,e,void 0,128===(128&e.current.flags))}catch(t){}}(n.stateNode),nl(e,Ze()),null!==t)for(a=e.onRecoverableError,n=0;n<t.length;n++)s=t[n],a(s.value,{componentStack:s.stack,digest:s.digest});if(Uc)throw Uc=!1,e=Hc,Hc=null,e;0!==(1&Xc)&&0!==e.tag&&wl(),i=e.pendingLanes,0!==(1&i)?e===Qc?Yc++:(Yc=0,Qc=e):Yc=0,Vs()}(e,t,n,a)}finally{Nc.transition=s,xt=a}return null}function wl(){if(null!==Kc){var e=vt(Xc),t=Nc.transition,n=xt;try{if(Nc.transition=null,xt=16>e?16:e,null===Kc)var a=!1;else{if(e=Kc,Kc=null,Xc=0,0!==(6&Tc))throw Error(r(331));var s=Tc;for(Tc|=4,Zo=e.current;null!==Zo;){var i=Zo,o=i.child;if(0!==(16&Zo.flags)){var c=i.deletions;if(null!==c){for(var l=0;l<c.length;l++){var u=c[l];for(Zo=u;null!==Zo;){var h=Zo;switch(h.tag){case 0:case 11:case 15:tc(8,h,i)}var d=h.child;if(null!==d)d.return=h,Zo=d;else for(;null!==Zo;){var p=(h=Zo).sibling,f=h.return;if(sc(h),h===u){Zo=null;break}if(null!==p){p.return=f,Zo=p;break}Zo=f}}}var m=i.alternate;if(null!==m){var g=m.child;if(null!==g){m.child=null;do{var y=g.sibling;g.sibling=null,g=y}while(null!==g)}}Zo=i}}if(0!==(2064&i.subtreeFlags)&&null!==o)o.return=i,Zo=o;else e:for(;null!==Zo;){if(0!==(2048&(i=Zo).flags))switch(i.tag){case 0:case 11:case 15:tc(9,i,i.return)}var b=i.sibling;if(null!==b){b.return=i.return,Zo=b;break e}Zo=i.return}}var x=e.current;for(Zo=x;null!==Zo;){var v=(o=Zo).child;if(0!==(2064&o.subtreeFlags)&&null!==v)v.return=o,Zo=v;else e:for(o=x;null!==Zo;){if(0!==(2048&(c=Zo).flags))try{switch(c.tag){case 0:case 11:case 15:nc(9,c)}}catch(k){Sl(c,c.return,k)}if(c===o){Zo=null;break e}var w=c.sibling;if(null!==w){w.return=c.return,Zo=w;break e}Zo=c.return}}if(Tc=s,Vs(),rt&&"function"===typeof rt.onPostCommitFiberRoot)try{rt.onPostCommitFiberRoot(st,e)}catch(k){}a=!0}return a}finally{xt=n,Nc.transition=t}}return!1}function kl(e,t,n){e=Br(e,t=po(0,t=co(n,t),1),1),t=$c(),null!==e&&(yt(e,1,t),nl(e,t))}function Sl(e,t,n){if(3===e.tag)kl(e,e,n);else for(;null!==t;){if(3===t.tag){kl(t,e,n);break}if(1===t.tag){var a=t.stateNode;if("function"===typeof t.type.getDerivedStateFromError||"function"===typeof a.componentDidCatch&&(null===Gc||!Gc.has(a))){t=Br(t,e=fo(t,e=co(n,e),1),1),e=$c(),null!==t&&(yt(t,1,e),nl(t,e));break}}t=t.return}}function Cl(e,t,n){var a=e.pingCache;null!==a&&a.delete(t),t=$c(),e.pingedLanes|=e.suspendedLanes&n,Ec===e&&(_c&n)===n&&(4===Pc||3===Pc&&(130023424&_c)===_c&&500>Ze()-jc?hl(e,0):Lc|=n),nl(e,t)}function Il(e,t){0===t&&(0===(1&e.mode)?t=1:(t=ut,0===(130023424&(ut<<=1))&&(ut=4194304)));var n=$c();null!==(e=Dr(e,t))&&(yt(e,t,n),nl(e,n))}function Nl(e){var t=e.memoizedState,n=0;null!==t&&(n=t.retryLane),Il(e,n)}function Tl(e,t){var n=0;switch(e.tag){case 13:var a=e.stateNode,s=e.memoizedState;null!==s&&(n=s.retryLane);break;case 19:a=e.stateNode;break;default:throw Error(r(314))}null!==a&&a.delete(t),Il(e,n)}function El(e,t){return Ke(e,t)}function Rl(e,t,n,a){this.tag=e,this.key=n,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=t,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=a,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function _l(e,t,n,a){return new Rl(e,t,n,a)}function Al(e){return!(!(e=e.prototype)||!e.isReactComponent)}function Ml(e,t){var n=e.alternate;return null===n?((n=_l(e.tag,t,e.key,e.mode)).elementType=e.elementType,n.type=e.type,n.stateNode=e.stateNode,n.alternate=e,e.alternate=n):(n.pendingProps=t,n.type=e.type,n.flags=0,n.subtreeFlags=0,n.deletions=null),n.flags=14680064&e.flags,n.childLanes=e.childLanes,n.lanes=e.lanes,n.child=e.child,n.memoizedProps=e.memoizedProps,n.memoizedState=e.memoizedState,n.updateQueue=e.updateQueue,t=e.dependencies,n.dependencies=null===t?null:{lanes:t.lanes,firstContext:t.firstContext},n.sibling=e.sibling,n.index=e.index,n.ref=e.ref,n}function Pl(e,t,n,a,s,i){var o=2;if(a=e,"function"===typeof e)Al(e)&&(o=1);else if("string"===typeof e)o=5;else e:switch(e){case S:return Dl(n.children,s,i,t);case C:o=8,s|=8;break;case I:return(e=_l(12,n,t,2|s)).elementType=I,e.lanes=i,e;case R:return(e=_l(13,n,t,s)).elementType=R,e.lanes=i,e;case _:return(e=_l(19,n,t,s)).elementType=_,e.lanes=i,e;case P:return Ol(n,s,i,t);default:if("object"===typeof e&&null!==e)switch(e.$$typeof){case N:o=10;break e;case T:o=9;break e;case E:o=11;break e;case A:o=14;break e;case M:o=16,a=null;break e}throw Error(r(130,null==e?e:typeof e,""))}return(t=_l(o,n,t,s)).elementType=e,t.type=a,t.lanes=i,t}function Dl(e,t,n,a){return(e=_l(7,e,a,t)).lanes=n,e}function Ol(e,t,n,a){return(e=_l(22,e,a,t)).elementType=P,e.lanes=n,e.stateNode={isHidden:!1},e}function Fl(e,t,n){return(e=_l(6,e,null,t)).lanes=n,e}function Ll(e,t,n){return(t=_l(4,null!==e.children?e.children:[],e.key,t)).lanes=n,t.stateNode={containerInfo:e.containerInfo,pendingChildren:null,implementation:e.implementation},t}function zl(e,t,n,a,s){this.tag=t,this.containerInfo=e,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=gt(0),this.expirationTimes=gt(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=gt(0),this.identifierPrefix=a,this.onRecoverableError=s,this.mutableSourceEagerHydrationData=null}function Bl(e,t,n,a,s,r,i,o,c){return e=new zl(e,t,n,o,c),1===t?(t=1,!0===r&&(t|=8)):t=0,r=_l(3,null,null,t),e.current=r,r.stateNode=e,r.memoizedState={element:a,isDehydrated:n,cache:null,transitions:null,pendingSuspenseBoundaries:null},Fr(r),e}function jl(e){if(!e)return Ts;e:{if(Ve(e=e._reactInternals)!==e||1!==e.tag)throw Error(r(170));var t=e;do{switch(t.tag){case 3:t=t.stateNode.context;break e;case 1:if(Ms(t.type)){t=t.stateNode.__reactInternalMemoizedMergedChildContext;break e}}t=t.return}while(null!==t);throw Error(r(171))}if(1===e.tag){var n=e.type;if(Ms(n))return Os(e,n,t)}return t}function Wl(e,t,n,a,s,r,i,o,c){return(e=Bl(n,a,!0,e,0,r,0,o,c)).context=jl(null),n=e.current,(r=zr(a=$c(),s=el(n))).callback=void 0!==t&&null!==t?t:null,Br(n,r,s),e.current.lanes=s,yt(e,s,a),nl(e,a),e}function Vl(e,t,n,a){var s=t.current,r=$c(),i=el(s);return n=jl(n),null===t.context?t.context=n:t.pendingContext=n,(t=zr(r,i)).payload={element:e},null!==(a=void 0===a?null:a)&&(t.callback=a),null!==(e=Br(s,t,i))&&(tl(e,s,i,r),jr(e,s,i)),i}function Ul(e){return(e=e.current).child?(e.child.tag,e.child.stateNode):null}function Hl(e,t){if(null!==(e=e.memoizedState)&&null!==e.dehydrated){var n=e.retryLane;e.retryLane=0!==n&&n<t?n:t}}function Gl(e,t){Hl(e,t),(e=e.alternate)&&Hl(e,t)}kc=function(e,t,n){if(null!==e)if(e.memoizedProps!==t.pendingProps||Rs.current)xo=!0;else{if(0===(e.lanes&n)&&0===(128&t.flags))return xo=!1,function(e,t,n){switch(t.tag){case 3:Ro(t),pr();break;case 5:Zr(t);break;case 1:Ms(t.type)&&Fs(t);break;case 4:Yr(t,t.stateNode.containerInfo);break;case 10:var a=t.type._context,s=t.memoizedProps.value;Ns(kr,a._currentValue),a._currentValue=s;break;case 13:if(null!==(a=t.memoizedState))return null!==a.dehydrated?(Ns($r,1&$r.current),t.flags|=128,null):0!==(n&t.child.childLanes)?Fo(e,t,n):(Ns($r,1&$r.current),null!==(e=Uo(e,t,n))?e.sibling:null);Ns($r,1&$r.current);break;case 19:if(a=0!==(n&t.childLanes),0!==(128&e.flags)){if(a)return Wo(e,t,n);t.flags|=128}if(null!==(s=t.memoizedState)&&(s.rendering=null,s.tail=null,s.lastEffect=null),Ns($r,$r.current),a)break;return null;case 22:case 23:return t.lanes=0,Co(e,t,n)}return Uo(e,t,n)}(e,t,n);xo=0!==(131072&e.flags)}else xo=!1,sr&&0!==(1048576&t.flags)&&$s(t,qs,t.index);switch(t.lanes=0,t.tag){case 2:var a=t.type;Vo(e,t),e=t.pendingProps;var s=As(t,Es.current);Rr(t,n),s=mi(null,t,a,e,s,n);var i=gi();return t.flags|=1,"object"===typeof s&&null!==s&&"function"===typeof s.render&&void 0===s.$$typeof?(t.tag=1,t.memoizedState=null,t.updateQueue=null,Ms(a)?(i=!0,Fs(t)):i=!1,t.memoizedState=null!==s.state&&void 0!==s.state?s.state:null,Fr(t),s.updater=ao,t.stateNode=s,s._reactInternals=t,oo(t,a,e,n),t=Eo(null,t,a,!0,i,n)):(t.tag=0,sr&&i&&er(t),vo(null,t,s,n),t=t.child),t;case 16:a=t.elementType;e:{switch(Vo(e,t),e=t.pendingProps,a=(s=a._init)(a._payload),t.type=a,s=t.tag=function(e){if("function"===typeof e)return Al(e)?1:0;if(void 0!==e&&null!==e){if((e=e.$$typeof)===E)return 11;if(e===A)return 14}return 2}(a),e=to(a,e),s){case 0:t=No(null,t,a,e,n);break e;case 1:t=To(null,t,a,e,n);break e;case 11:t=wo(null,t,a,e,n);break e;case 14:t=ko(null,t,a,to(a.type,e),n);break e}throw Error(r(306,a,""))}return t;case 0:return a=t.type,s=t.pendingProps,No(e,t,a,s=t.elementType===a?s:to(a,s),n);case 1:return a=t.type,s=t.pendingProps,To(e,t,a,s=t.elementType===a?s:to(a,s),n);case 3:e:{if(Ro(t),null===e)throw Error(r(387));a=t.pendingProps,s=(i=t.memoizedState).element,Lr(e,t),Vr(t,a,null,n);var o=t.memoizedState;if(a=o.element,i.isDehydrated){if(i={element:a,isDehydrated:!1,cache:o.cache,pendingSuspenseBoundaries:o.pendingSuspenseBoundaries,transitions:o.transitions},t.updateQueue.baseState=i,t.memoizedState=i,256&t.flags){t=_o(e,t,a,n,s=co(Error(r(423)),t));break e}if(a!==s){t=_o(e,t,a,n,s=co(Error(r(424)),t));break e}for(ar=ls(t.stateNode.containerInfo.firstChild),nr=t,sr=!0,rr=null,n=wr(t,null,a,n),t.child=n;n;)n.flags=-3&n.flags|4096,n=n.sibling}else{if(pr(),a===s){t=Uo(e,t,n);break e}vo(e,t,a,n)}t=t.child}return t;case 5:return Zr(t),null===e&&lr(t),a=t.type,s=t.pendingProps,i=null!==e?e.memoizedProps:null,o=s.children,ns(a,s)?o=null:null!==i&&ns(a,i)&&(t.flags|=32),Io(e,t),vo(e,t,o,n),t.child;case 6:return null===e&&lr(t),null;case 13:return Fo(e,t,n);case 4:return Yr(t,t.stateNode.containerInfo),a=t.pendingProps,null===e?t.child=vr(t,null,a,n):vo(e,t,a,n),t.child;case 11:return a=t.type,s=t.pendingProps,wo(e,t,a,s=t.elementType===a?s:to(a,s),n);case 7:return vo(e,t,t.pendingProps,n),t.child;case 8:case 12:return vo(e,t,t.pendingProps.children,n),t.child;case 10:e:{if(a=t.type._context,s=t.pendingProps,i=t.memoizedProps,o=s.value,Ns(kr,a._currentValue),a._currentValue=o,null!==i)if(oa(i.value,o)){if(i.children===s.children&&!Rs.current){t=Uo(e,t,n);break e}}else for(null!==(i=t.child)&&(i.return=t);null!==i;){var c=i.dependencies;if(null!==c){o=i.child;for(var l=c.firstContext;null!==l;){if(l.context===a){if(1===i.tag){(l=zr(-1,n&-n)).tag=2;var u=i.updateQueue;if(null!==u){var h=(u=u.shared).pending;null===h?l.next=l:(l.next=h.next,h.next=l),u.pending=l}}i.lanes|=n,null!==(l=i.alternate)&&(l.lanes|=n),Er(i.return,n,t),c.lanes|=n;break}l=l.next}}else if(10===i.tag)o=i.type===t.type?null:i.child;else if(18===i.tag){if(null===(o=i.return))throw Error(r(341));o.lanes|=n,null!==(c=o.alternate)&&(c.lanes|=n),Er(o,n,t),o=i.sibling}else o=i.child;if(null!==o)o.return=i;else for(o=i;null!==o;){if(o===t){o=null;break}if(null!==(i=o.sibling)){i.return=o.return,o=i;break}o=o.return}i=o}vo(e,t,s.children,n),t=t.child}return t;case 9:return s=t.type,a=t.pendingProps.children,Rr(t,n),a=a(s=_r(s)),t.flags|=1,vo(e,t,a,n),t.child;case 14:return s=to(a=t.type,t.pendingProps),ko(e,t,a,s=to(a.type,s),n);case 15:return So(e,t,t.type,t.pendingProps,n);case 17:return a=t.type,s=t.pendingProps,s=t.elementType===a?s:to(a,s),Vo(e,t),t.tag=1,Ms(a)?(e=!0,Fs(t)):e=!1,Rr(t,n),ro(t,a,s),oo(t,a,s,n),Eo(null,t,a,!0,e,n);case 19:return Wo(e,t,n);case 22:return Co(e,t,n)}throw Error(r(156,t.tag))};var ql="function"===typeof reportError?reportError:function(e){console.error(e)};function Kl(e){this._internalRoot=e}function Xl(e){this._internalRoot=e}function Yl(e){return!(!e||1!==e.nodeType&&9!==e.nodeType&&11!==e.nodeType)}function Ql(e){return!(!e||1!==e.nodeType&&9!==e.nodeType&&11!==e.nodeType&&(8!==e.nodeType||" react-mount-point-unstable "!==e.nodeValue))}function Zl(){}function Jl(e,t,n,a,s){var r=n._reactRootContainer;if(r){var i=r;if("function"===typeof s){var o=s;s=function(){var e=Ul(i);o.call(e)}}Vl(t,i,e,s)}else i=function(e,t,n,a,s){if(s){if("function"===typeof a){var r=a;a=function(){var e=Ul(i);r.call(e)}}var i=Wl(t,a,e,0,null,!1,0,"",Zl);return e._reactRootContainer=i,e[fs]=i.current,Va(8===e.nodeType?e.parentNode:e),ll(),i}for(;s=e.lastChild;)e.removeChild(s);if("function"===typeof a){var o=a;a=function(){var e=Ul(c);o.call(e)}}var c=Bl(e,0,!1,null,0,!1,0,"",Zl);return e._reactRootContainer=c,e[fs]=c.current,Va(8===e.nodeType?e.parentNode:e),ll(function(){Vl(t,c,n,a)}),c}(n,t,e,s,a);return Ul(i)}Xl.prototype.render=Kl.prototype.render=function(e){var t=this._internalRoot;if(null===t)throw Error(r(409));Vl(e,t,null,null)},Xl.prototype.unmount=Kl.prototype.unmount=function(){var e=this._internalRoot;if(null!==e){this._internalRoot=null;var t=e.containerInfo;ll(function(){Vl(null,e,null,null)}),t[fs]=null}},Xl.prototype.unstable_scheduleHydration=function(e){if(e){var t=Ct();e={blockedOn:null,target:e,priority:t};for(var n=0;n<Pt.length&&0!==t&&t<Pt[n].priority;n++);Pt.splice(n,0,e),0===n&&Lt(e)}},wt=function(e){switch(e.tag){case 3:var t=e.stateNode;if(t.current.memoizedState.isDehydrated){var n=ht(t.pendingLanes);0!==n&&(bt(t,1|n),nl(t,Ze()),0===(6&Tc)&&(Wc=Ze()+500,Vs()))}break;case 13:ll(function(){var t=Dr(e,1);if(null!==t){var n=$c();tl(t,e,1,n)}}),Gl(e,1)}},kt=function(e){if(13===e.tag){var t=Dr(e,134217728);if(null!==t)tl(t,e,134217728,$c());Gl(e,134217728)}},St=function(e){if(13===e.tag){var t=el(e),n=Dr(e,t);if(null!==n)tl(n,e,t,$c());Gl(e,t)}},Ct=function(){return xt},It=function(e,t){var n=xt;try{return xt=e,t()}finally{xt=n}},ke=function(e,t,n){switch(t){case"input":if(J(e,n),t=n.name,"radio"===n.type&&null!=t){for(n=e;n.parentNode;)n=n.parentNode;for(n=n.querySelectorAll("input[name="+JSON.stringify(""+t)+'][type="radio"]'),t=0;t<n.length;t++){var a=n[t];if(a!==e&&a.form===e.form){var s=ws(a);if(!s)throw Error(r(90));K(a),J(a,s)}}}break;case"textarea":re(e,n);break;case"select":null!=(t=n.value)&&ne(e,!!n.multiple,t,!1)}},Ee=cl,Re=ll;var $l={usingClientEntryPoint:!1,Events:[xs,vs,ws,Ne,Te,cl]},eu={findFiberByHostInstance:bs,bundleType:0,version:"18.3.1",rendererPackageName:"react-dom"},tu={bundleType:eu.bundleType,version:eu.version,rendererPackageName:eu.rendererPackageName,rendererConfig:eu.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:v.ReactCurrentDispatcher,findHostInstanceByFiber:function(e){return null===(e=Ge(e))?null:e.stateNode},findFiberByHostInstance:eu.findFiberByHostInstance||function(){return null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.3.1-next-f1338f8080-20240426"};if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__){var nu=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!nu.isDisabled&&nu.supportsFiber)try{st=nu.inject(tu),rt=nu}catch(ue){}}t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=$l,t.createPortal=function(e,t){var n=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;if(!Yl(t))throw Error(r(200));return function(e,t,n){var a=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:k,key:null==a?null:""+a,children:e,containerInfo:t,implementation:n}}(e,t,null,n)},t.createRoot=function(e,t){if(!Yl(e))throw Error(r(299));var n=!1,a="",s=ql;return null!==t&&void 0!==t&&(!0===t.unstable_strictMode&&(n=!0),void 0!==t.identifierPrefix&&(a=t.identifierPrefix),void 0!==t.onRecoverableError&&(s=t.onRecoverableError)),t=Bl(e,1,!1,null,0,n,0,a,s),e[fs]=t.current,Va(8===e.nodeType?e.parentNode:e),new Kl(t)},t.findDOMNode=function(e){if(null==e)return null;if(1===e.nodeType)return e;var t=e._reactInternals;if(void 0===t){if("function"===typeof e.render)throw Error(r(188));throw e=Object.keys(e).join(","),Error(r(268,e))}return e=null===(e=Ge(t))?null:e.stateNode},t.flushSync=function(e){return ll(e)},t.hydrate=function(e,t,n){if(!Ql(t))throw Error(r(200));return Jl(null,e,t,!0,n)},t.hydrateRoot=function(e,t,n){if(!Yl(e))throw Error(r(405));var a=null!=n&&n.hydratedSources||null,s=!1,i="",o=ql;if(null!==n&&void 0!==n&&(!0===n.unstable_strictMode&&(s=!0),void 0!==n.identifierPrefix&&(i=n.identifierPrefix),void 0!==n.onRecoverableError&&(o=n.onRecoverableError)),t=Wl(t,null,e,1,null!=n?n:null,s,0,i,o),e[fs]=t.current,Va(e),a)for(e=0;e<a.length;e++)s=(s=(n=a[e])._getVersion)(n._source),null==t.mutableSourceEagerHydrationData?t.mutableSourceEagerHydrationData=[n,s]:t.mutableSourceEagerHydrationData.push(n,s);return new Xl(t)},t.render=function(e,t,n){if(!Ql(t))throw Error(r(200));return Jl(null,e,t,!1,n)},t.unmountComponentAtNode=function(e){if(!Ql(e))throw Error(r(40));return!!e._reactRootContainer&&(ll(function(){Jl(null,null,e,!1,function(){e._reactRootContainer=null,e[fs]=null})}),!0)},t.unstable_batchedUpdates=cl,t.unstable_renderSubtreeIntoContainer=function(e,t,n,a){if(!Ql(n))throw Error(r(200));if(null==e||void 0===e._reactInternals)throw Error(r(38));return Jl(e,t,n,!1,a)},t.version="18.3.1-next-f1338f8080-20240426"},817(){},853(e,t,n){"use strict";e.exports=n(234)},879(e,t,n){(function(){"use strict";var e;function t(e){var t=0;return function(){return t<e.length?{done:!1,value:e[t++]}:{done:!0}}}var a="function"==typeof Object.defineProperties?Object.defineProperty:function(e,t,n){return e==Array.prototype||e==Object.prototype||(e[t]=n.value),e};var s=function(e){e=["object"==typeof globalThis&&globalThis,e,"object"==typeof window&&window,"object"==typeof self&&self,"object"==typeof n.g&&n.g];for(var t=0;t<e.length;++t){var a=e[t];if(a&&a.Math==Math)return a}throw Error("Cannot find global object")}(this);function r(e,t){if(t)e:{var n=s;e=e.split(".");for(var r=0;r<e.length-1;r++){var i=e[r];if(!(i in n))break e;n=n[i]}(t=t(r=n[e=e[e.length-1]]))!=r&&null!=t&&a(n,e,{configurable:!0,writable:!0,value:t})}}function i(e){return(e={next:e})[Symbol.iterator]=function(){return this},e}function o(e){var n="undefined"!=typeof Symbol&&Symbol.iterator&&e[Symbol.iterator];return n?n.call(e):{next:t(e)}}function c(e){if(!(e instanceof Array)){e=o(e);for(var t,n=[];!(t=e.next()).done;)n.push(t.value);e=n}return e}r("Symbol",function(e){function t(e,t){this.h=e,a(this,"description",{configurable:!0,writable:!0,value:t})}if(e)return e;t.prototype.toString=function(){return this.h};var n="jscomp_symbol_"+(1e9*Math.random()>>>0)+"_",s=0;return function e(a){if(this instanceof e)throw new TypeError("Symbol is not a constructor");return new t(n+(a||"")+"_"+s++,a)}}),r("Symbol.iterator",function(e){if(e)return e;e=Symbol("Symbol.iterator");for(var n="Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "),r=0;r<n.length;r++){var o=s[n[r]];"function"===typeof o&&"function"!=typeof o.prototype[e]&&a(o.prototype,e,{configurable:!0,writable:!0,value:function(){return i(t(this))}})}return e});var l="function"==typeof Object.assign?Object.assign:function(e,t){for(var n=1;n<arguments.length;n++){var a=arguments[n];if(a)for(var s in a)Object.prototype.hasOwnProperty.call(a,s)&&(e[s]=a[s])}return e};r("Object.assign",function(e){return e||l});var u,h="function"==typeof Object.create?Object.create:function(e){function t(){}return t.prototype=e,new t};if("function"==typeof Object.setPrototypeOf)u=Object.setPrototypeOf;else{var d;e:{var p={};try{p.__proto__={a:!0},d=p.a;break e}catch(vn){}d=!1}u=d?function(e,t){if(e.__proto__=t,e.__proto__!==t)throw new TypeError(e+" is not extensible");return e}:null}var f=u;function m(e,t){if(e.prototype=h(t.prototype),e.prototype.constructor=e,f)f(e,t);else for(var n in t)if("prototype"!=n)if(Object.defineProperties){var a=Object.getOwnPropertyDescriptor(t,n);a&&Object.defineProperty(e,n,a)}else e[n]=t[n];e.za=t.prototype}function g(){this.m=!1,this.j=null,this.i=void 0,this.h=1,this.v=this.s=0,this.l=null}function y(e){if(e.m)throw new TypeError("Generator is already running");e.m=!0}function b(e,t){e.l={ma:t,na:!0},e.h=e.s||e.v}function x(e,t,n){return e.h=n,{value:t}}function v(e){this.h=new g,this.i=e}function w(e,t,n,a){try{var s=t.call(e.h.j,n);if(!(s instanceof Object))throw new TypeError("Iterator result "+s+" is not an object");if(!s.done)return e.h.m=!1,s;var r=s.value}catch(i){return e.h.j=null,b(e.h,i),k(e)}return e.h.j=null,a.call(e.h,r),k(e)}function k(e){for(;e.h.h;)try{var t=e.i(e.h);if(t)return e.h.m=!1,{value:t.value,done:!1}}catch(n){e.h.i=void 0,b(e.h,n)}if(e.h.m=!1,e.h.l){if(t=e.h.l,e.h.l=null,t.na)throw t.ma;return{value:t.return,done:!0}}return{value:void 0,done:!0}}function S(e){this.next=function(t){return y(e.h),e.h.j?t=w(e,e.h.j.next,t,e.h.u):(e.h.u(t),t=k(e)),t},this.throw=function(t){return y(e.h),e.h.j?t=w(e,e.h.j.throw,t,e.h.u):(b(e.h,t),t=k(e)),t},this.return=function(t){return function(e,t){y(e.h);var n=e.h.j;return n?w(e,"return"in n?n.return:function(e){return{value:e,done:!0}},t,e.h.return):(e.h.return(t),k(e))}(e,t)},this[Symbol.iterator]=function(){return this}}function C(e){return function(e){function t(t){return e.next(t)}function n(t){return e.throw(t)}return new Promise(function(a,s){!function e(r){r.done?a(r.value):Promise.resolve(r.value).then(t,n).then(e,s)}(e.next())})}(new S(new v(e)))}function I(e){return e||Array.prototype.fill}g.prototype.u=function(e){this.i=e},g.prototype.return=function(e){this.l={return:e},this.h=this.v},r("Promise",function(e){function t(e){this.i=0,this.j=void 0,this.h=[],this.u=!1;var t=this.l();try{e(t.resolve,t.reject)}catch(n){t.reject(n)}}function n(){this.h=null}function a(e){return e instanceof t?e:new t(function(t){t(e)})}if(e)return e;n.prototype.i=function(e){if(null==this.h){this.h=[];var t=this;this.j(function(){t.m()})}this.h.push(e)};var r=s.setTimeout;n.prototype.j=function(e){r(e,0)},n.prototype.m=function(){for(;this.h&&this.h.length;){var e=this.h;this.h=[];for(var t=0;t<e.length;++t){var n=e[t];e[t]=null;try{n()}catch(a){this.l(a)}}}this.h=null},n.prototype.l=function(e){this.j(function(){throw e})},t.prototype.l=function(){function e(e){return function(a){n||(n=!0,e.call(t,a))}}var t=this,n=!1;return{resolve:e(this.I),reject:e(this.m)}},t.prototype.I=function(e){if(e===this)this.m(new TypeError("A Promise cannot resolve to itself"));else if(e instanceof t)this.L(e);else{e:switch(typeof e){case"object":var n=null!=e;break e;case"function":n=!0;break e;default:n=!1}n?this.F(e):this.s(e)}},t.prototype.F=function(e){var t=void 0;try{t=e.then}catch(n){return void this.m(n)}"function"==typeof t?this.M(t,e):this.s(e)},t.prototype.m=function(e){this.v(2,e)},t.prototype.s=function(e){this.v(1,e)},t.prototype.v=function(e,t){if(0!=this.i)throw Error("Cannot settle("+e+", "+t+"): Promise already settled in state"+this.i);this.i=e,this.j=t,2===this.i&&this.K(),this.H()},t.prototype.K=function(){var e=this;r(function(){if(e.D()){var t=s.console;"undefined"!==typeof t&&t.error(e.j)}},1)},t.prototype.D=function(){if(this.u)return!1;var e=s.CustomEvent,t=s.Event,n=s.dispatchEvent;return"undefined"===typeof n||("function"===typeof e?e=new e("unhandledrejection",{cancelable:!0}):"function"===typeof t?e=new t("unhandledrejection",{cancelable:!0}):(e=s.document.createEvent("CustomEvent")).initCustomEvent("unhandledrejection",!1,!0,e),e.promise=this,e.reason=this.j,n(e))},t.prototype.H=function(){if(null!=this.h){for(var e=0;e<this.h.length;++e)i.i(this.h[e]);this.h=null}};var i=new n;return t.prototype.L=function(e){var t=this.l();e.T(t.resolve,t.reject)},t.prototype.M=function(e,t){var n=this.l();try{e.call(t,n.resolve,n.reject)}catch(a){n.reject(a)}},t.prototype.then=function(e,n){function a(e,t){return"function"==typeof e?function(t){try{s(e(t))}catch(n){r(n)}}:t}var s,r,i=new t(function(e,t){s=e,r=t});return this.T(a(e,s),a(n,r)),i},t.prototype.catch=function(e){return this.then(void 0,e)},t.prototype.T=function(e,t){function n(){switch(a.i){case 1:e(a.j);break;case 2:t(a.j);break;default:throw Error("Unexpected state: "+a.i)}}var a=this;null==this.h?i.i(n):this.h.push(n),this.u=!0},t.resolve=a,t.reject=function(e){return new t(function(t,n){n(e)})},t.race=function(e){return new t(function(t,n){for(var s=o(e),r=s.next();!r.done;r=s.next())a(r.value).T(t,n)})},t.all=function(e){var n=o(e),s=n.next();return s.done?a([]):new t(function(e,t){function r(t){return function(n){i[t]=n,0==--o&&e(i)}}var i=[],o=0;do{i.push(void 0),o++,a(s.value).T(r(i.length-1),t),s=n.next()}while(!s.done)})},t}),r("Array.prototype.keys",function(e){return e||function(){return function(e,t){e instanceof String&&(e+="");var n=0,a=!1,s={next:function(){if(!a&&n<e.length){var s=n++;return{value:t(s,e[s]),done:!1}}return a=!0,{done:!0,value:void 0}}};return s[Symbol.iterator]=function(){return s},s}(this,function(e){return e})}}),r("Array.prototype.fill",function(e){return e||function(e,t,n){var a=this.length||0;for(0>t&&(t=Math.max(0,a+t)),(null==n||n>a)&&(n=a),0>(n=Number(n))&&(n=Math.max(0,a+n)),t=Number(t||0);t<n;t++)this[t]=e;return this}}),r("Int8Array.prototype.fill",I),r("Uint8Array.prototype.fill",I),r("Uint8ClampedArray.prototype.fill",I),r("Int16Array.prototype.fill",I),r("Uint16Array.prototype.fill",I),r("Int32Array.prototype.fill",I),r("Uint32Array.prototype.fill",I),r("Float32Array.prototype.fill",I),r("Float64Array.prototype.fill",I),r("Object.is",function(e){return e||function(e,t){return e===t?0!==e||1/e===1/t:e!==e&&t!==t}}),r("Array.prototype.includes",function(e){return e||function(e,t){var n=this;n instanceof String&&(n=String(n));var a=n.length;for(0>(t=t||0)&&(t=Math.max(t+a,0));t<a;t++){var s=n[t];if(s===e||Object.is(s,e))return!0}return!1}}),r("String.prototype.includes",function(e){return e||function(e,t){if(null==this)throw new TypeError("The 'this' value for String.prototype.includes must not be null or undefined");if(e instanceof RegExp)throw new TypeError("First argument to String.prototype.includes must not be a regular expression");return-1!==this.indexOf(e,t||0)}});var N=this||self;function T(e,t){e=e.split(".");var n,a=N;e[0]in a||"undefined"==typeof a.execScript||a.execScript("var "+e[0]);for(;e.length&&(n=e.shift());)e.length||void 0===t?a=a[n]&&a[n]!==Object.prototype[n]?a[n]:a[n]={}:a[n]=t}function E(e){var t;return(t=N.navigator)&&(t=t.userAgent)||(t=""),-1!=t.indexOf(e)}var R=Array.prototype.map?function(e,t){return Array.prototype.map.call(e,t,void 0)}:function(e,t){for(var n=e.length,a=Array(n),s="string"===typeof e?e.split(""):e,r=0;r<n;r++)r in s&&(a[r]=t.call(void 0,s[r],r,e));return a},_={},A=null;function M(e){var t=e.length,n=3*t/4;n%3?n=Math.floor(n):-1!="=.".indexOf(e[t-1])&&(n=-1!="=.".indexOf(e[t-2])?n-2:n-1);var a=new Uint8Array(n),s=0;return function(e,t){function n(t){for(;a<e.length;){var n=e.charAt(a++),s=A[n];if(null!=s)return s;if(!/^[\s\xa0]*$/.test(n))throw Error("Unknown base64 encoding at char: "+n)}return t}P();for(var a=0;;){var s=n(-1),r=n(0),i=n(64),o=n(64);if(64===o&&-1===s)break;t(s<<2|r>>4),64!=i&&(t(r<<4&240|i>>2),64!=o&&t(i<<6&192|o))}}(e,function(e){a[s++]=e}),s!==n?a.subarray(0,s):a}function P(){if(!A){A={};for(var e="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""),t=["+/=","+/","-_=","-_.","-_"],n=0;5>n;n++){var a=e.concat(t[n].split(""));_[n]=a;for(var s=0;s<a.length;s++){var r=a[s];void 0===A[r]&&(A[r]=s)}}}}var D="undefined"!==typeof Uint8Array,O=!(E("Trident")||E("MSIE"))&&"function"===typeof N.btoa;function F(e){if(!O){var t;void 0===t&&(t=0),P(),t=_[t];for(var n=Array(Math.floor(e.length/3)),a=t[64]||"",s=0,r=0;s<e.length-2;s+=3){var i=e[s],o=e[s+1],c=e[s+2],l=t[i>>2];i=t[(3&i)<<4|o>>4],o=t[(15&o)<<2|c>>6],c=t[63&c],n[r++]=l+i+o+c}switch(l=0,c=a,e.length-s){case 2:c=t[(15&(l=e[s+1]))<<2]||a;case 1:e=e[s],n[r]=t[e>>2]+t[(3&e)<<4|l>>4]+c+a}return n.join("")}for(t="";10240<e.length;)t+=String.fromCharCode.apply(null,e.subarray(0,10240)),e=e.subarray(10240);return t+=String.fromCharCode.apply(null,e),btoa(t)}var L,z=RegExp("[-_.]","g");function B(e){switch(e){case"-":return"+";case"_":return"/";case".":return"=";default:return""}}function j(e){if(!O)return M(e);z.test(e)&&(e=e.replace(z,B)),e=atob(e);for(var t=new Uint8Array(e.length),n=0;n<e.length;n++)t[n]=e.charCodeAt(n);return t}function W(){return L||(L=new Uint8Array(0))}var V={},U="function"===typeof Uint8Array.prototype.slice,H=0,G=0;function q(e){var t=0>e,n=(e=Math.abs(e))>>>0;e=Math.floor((e-n)/4294967296),t&&(t=(n=o(Y(n,e))).next().value,e=n.next().value,n=t),H=n>>>0,G=e>>>0}var K,X="function"===typeof BigInt;function Y(e,t){return t=~t,e?e=1+~e:t+=1,[e,t]}function Q(e,t){this.i=e>>>0,this.h=t>>>0}function Z(e){if(!e)return K||(K=new Q(0,0));if(!/^-?\d+$/.test(e))return null;if(16>e.length)q(Number(e));else if(X)e=BigInt(e),H=Number(e&BigInt(4294967295))>>>0,G=Number(e>>BigInt(32)&BigInt(4294967295));else{var t=+("-"===e[0]);G=H=0;for(var n=e.length,a=t,s=(n-t)%6+t;s<=n;a=s,s+=6)a=Number(e.slice(a,s)),G*=1e6,4294967296<=(H=1e6*H+a)&&(G+=H/4294967296|0,H%=4294967296);t&&(e=(t=o(Y(H,G))).next().value,t=t.next().value,H=e,G=t)}return new Q(H,G)}function J(e,t){return Error("Invalid wire type: "+e+" (at position "+t+")")}function $(){return Error("Failed to read varint, encoding is invalid.")}function ee(e,t){return Error("Tried to read past the end of the data "+t+" > "+e)}function te(){throw Error("Invalid UTF8")}function ne(e,t){return t=String.fromCharCode.apply(null,t),null==e?t:e+t}var ae,se,re,ie=void 0,oe="undefined"!==typeof TextDecoder,ce="undefined"!==typeof TextEncoder;function le(e){if(e!==V)throw Error("illegal external caller")}function ue(e,t){if(le(t),this.V=e,null!=e&&0===e.length)throw Error("ByteString should be constructed with non-empty values")}function he(){return re||(re=new ue(null,V))}function de(e){le(V);var t=e.V;return null==(t=null==t||D&&null!=t&&t instanceof Uint8Array?t:"string"===typeof t?j(t):null)?t:e.V=t}function pe(e,t){this.i=null,this.m=!1,this.h=this.j=this.l=0,fe(this,e,t)}function fe(e,t,n){n=void 0===n?{}:n,e.S=void 0!==n.S&&n.S,t&&(t=function(e){if("string"===typeof e)return{buffer:j(e),C:!1};if(Array.isArray(e))return{buffer:new Uint8Array(e),C:!1};if(e.constructor===Uint8Array)return{buffer:e,C:!1};if(e.constructor===ArrayBuffer)return{buffer:new Uint8Array(e),C:!1};if(e.constructor===ue)return{buffer:de(e)||W(),C:!0};if(e instanceof Uint8Array)return{buffer:new Uint8Array(e.buffer,e.byteOffset,e.byteLength),C:!1};throw Error("Type not convertible to a Uint8Array, expected a Uint8Array, an ArrayBuffer, a base64 encoded string, a ByteString or an Array of numbers")}(t),e.i=t.buffer,e.m=t.C,e.l=0,e.j=e.i.length,e.h=e.l)}function me(e,t){if(e.h=t,t>e.j)throw ee(e.j,t)}function ge(e){var t=e.i,n=e.h,a=t[n++],s=127&a;if(128&a&&(s|=(127&(a=t[n++]))<<7,128&a&&(s|=(127&(a=t[n++]))<<14,128&a&&(s|=(127&(a=t[n++]))<<21,128&a&&(s|=(a=t[n++])<<28,128&a&&128&t[n++]&&128&t[n++]&&128&t[n++]&&128&t[n++]&&128&t[n++])))))throw $();return me(e,n),s}function ye(e,t){if(0>t)throw Error("Tried to read a negative byte length: "+t);var n=e.h,a=n+t;if(a>e.j)throw ee(t,e.j-n);return e.h=a,n}pe.prototype.reset=function(){this.h=this.l};var be=[];function xe(){this.h=[]}function ve(e,t,n){for(;0<n||127<t;)e.h.push(127&t|128),t=(t>>>7|n<<25)>>>0,n>>>=7;e.h.push(t)}function we(e,t){for(;127<t;)e.h.push(127&t|128),t>>>=7;e.h.push(t)}function ke(e,t){if(be.length){var n=be.pop();fe(n,e,t),e=n}else e=new pe(e,t);this.h=e,this.j=this.h.h,this.i=this.l=-1,this.setOptions(t)}function Se(e){var t=e.h;if(t.h==t.j)return!1;e.j=e.h.h;var n=ge(e.h)>>>0;if(t=n>>>3,!(0<=(n&=7)&&5>=n))throw J(n,e.j);if(1>t)throw Error("Invalid field number: "+t+" (at position "+e.j+")");return e.l=t,e.i=n,!0}function Ce(e){switch(e.i){case 0:if(0!=e.i)Ce(e);else e:{for(var t=(e=e.h).h,n=t+10,a=e.i;t<n;)if(0===(128&a[t++])){me(e,t);break e}throw $()}break;case 1:me(e=e.h,e.h+8);break;case 2:2!=e.i?Ce(e):(t=ge(e.h)>>>0,me(e=e.h,e.h+t));break;case 5:me(e=e.h,e.h+4);break;case 3:for(t=e.l;;){if(!Se(e))throw Error("Unmatched start-group tag: stream EOF");if(4==e.i){if(e.l!=t)throw Error("Unmatched end-group tag");break}Ce(e)}break;default:throw J(e.i,e.j)}}xe.prototype.length=function(){return this.h.length},xe.prototype.end=function(){var e=this.h;return this.h=[],e},ke.prototype.setOptions=function(e){e=void 0===e?{}:e,this.ca=void 0!==e.ca&&e.ca},ke.prototype.reset=function(){this.h.reset(),this.j=this.h.h,this.i=this.l=-1};var Ie=[];function Ne(){this.j=[],this.i=0,this.h=new xe}function Te(e,t){0!==t.length&&(e.j.push(t),e.i+=t.length)}var Ee="function"===typeof Symbol&&"symbol"===typeof Symbol()?Symbol():void 0;function Re(e,t){return Ee?e[Ee]|=t:void 0!==e.A?e.A|=t:(Object.defineProperties(e,{A:{value:t,configurable:!0,writable:!0,enumerable:!1}}),t)}function _e(e,t){Ee?e[Ee]&&(e[Ee]&=~t):void 0!==e.A&&(e.A&=~t)}function Ae(e){var t;return null==(t=Ee?e[Ee]:e.A)?0:t}function Me(e,t){Ee?e[Ee]=t:void 0!==e.A?e.A=t:Object.defineProperties(e,{A:{value:t,configurable:!0,writable:!0,enumerable:!1}})}function Pe(e){return Re(e,1),e}function De(e,t){Me(t,-51&e)}function Oe(e,t){Me(t,-41&e|18)}var Fe={};function Le(e){return null!==e&&"object"===typeof e&&!Array.isArray(e)&&e.constructor===Object}var ze,Be,je=[];function We(e){if(2&Ae(e.o))throw Error("Cannot mutate an immutable Message")}function Ve(e){var t=e.length;(t=t?e[t-1]:void 0)&&Le(t)?t.g=1:(t={},e.push((t.g=1,t)))}function Ue(e){var t=e.i+e.G;return e.B||(e.B=e.o[t]={})}function He(e,t){return-1===t?null:t>=e.i?e.B?e.B[t]:void 0:e.o[t+e.G]}function Ge(e,t,n,a){We(e),qe(e,t,n,a)}function qe(e,t,n,a){e.j&&(e.j=void 0),t>=e.i||a?Ue(e)[t]=n:(e.o[t+e.G]=n,(e=e.B)&&t in e&&delete e[t])}function Ke(e,t,n,a){var s=He(e,t);Array.isArray(s)||(s=ze);var r=Ae(s);if(1&r||Pe(s),a)2&r||Re(s,2),1&n||Object.freeze(s);else{a=!(2&n);var i=2&r;1&n||!i?a&&16&r&&!i&&_e(s,16):qe(e,t,s=Pe(Array.prototype.slice.call(s)))}return s}function Xe(e,t){var n=He(e,t),a=null==n?n:"number"===typeof n||"NaN"===n||"Infinity"===n||"-Infinity"===n?Number(n):void 0;return null!=a&&a!==n&&qe(e,t,a),a}function Ye(e,t,n,a,s){e.h||(e.h={});var r=e.h[n],i=Ke(e,n,3,s);if(!r){var o=i;r=[];var c=!!(16&Ae(e.o));i=!!(2&Ae(o));var l=o;!s&&i&&(o=Array.prototype.slice.call(o));for(var u=i,h=0;h<o.length;h++){var d=o[h],p=t,f=!1;if(f=void 0!==f&&f,void 0!==(d=Array.isArray(d)?new p(d):f?new p:void 0)){var m=f=Ae(p=d.o);i&&(m|=2),c&&(m|=16),m!=f&&Me(p,m),p=m,u=u||!!(2&p),r.push(d)}}return e.h[n]=r,t=33|(c=Ae(o)),c!=(t=u?-9&t:8|t)&&(u=o,Object.isFrozen(u)&&(u=Array.prototype.slice.call(u)),Me(u,t),o=u),l!==o&&qe(e,n,o),(s||a&&i)&&Re(r,2),a&&Object.freeze(r),r}return s||(s=Object.isFrozen(r),a&&!s?Object.freeze(r):!a&&s&&(r=Array.prototype.slice.call(r),e.h[n]=r)),r}function Qe(e,t,n){var a=!!(2&Ae(e.o));if(t=Ye(e,t,n,a,a),e=Ke(e,n,3,a),!(a||8&Ae(e))){for(a=0;a<t.length;a++){if(2&Ae((n=t[a]).o)){var s=ct(n,!1);s.j=n}else s=n;n!==s&&(t[a]=s,e[a]=s.o)}Re(e,8)}return t}function Ze(e,t,n){if(null!=n&&"number"!==typeof n)throw Error("Value of float/double field must be a number|null|undefined, found "+typeof n+": "+n);Ge(e,t,n)}function Je(e,t,n,a,s){We(e);var r=Ye(e,n,t,!1,!1);return n=null!=a?a:new n,e=Ke(e,t,2,!1),void 0!=s?(r.splice(s,0,n),e.splice(s,0,n.o)):(r.push(n),e.push(n.o)),n.C()&&_e(e,8),n}function $e(e,t){return null==e?t:e}function et(e,t,n){return n=void 0===n?0:n,$e(Xe(e,t),n)}function tt(e,t,n,a){if(null!=e){if(Array.isArray(e))e=nt(e,t,n,void 0!==a);else if(Le(e)){var s,r={};for(s in e)r[s]=tt(e[s],t,n,a);e=r}else e=t(e,a);return e}}function nt(e,t,n,a){var s=Ae(e);a=a?!!(16&s):void 0,e=Array.prototype.slice.call(e);for(var r=0;r<e.length;r++)e[r]=tt(e[r],t,n,a);return n(s,e),e}function at(e){return e.ja===Fe?e.toJSON():function(e){switch(typeof e){case"number":return isFinite(e)?e:String(e);case"object":if(e)if(Array.isArray(e)){if(0!==(128&Ae(e)))return Ve(e=Array.prototype.slice.call(e)),e}else{if(D&&null!=e&&e instanceof Uint8Array)return F(e);if(e instanceof ue){var t=e.V;return null==t?"":"string"===typeof t?t:e.V=F(t)}}}return e}(e)}function st(e,t){128&e&&Ve(t)}function rt(e,t,n){if(n=void 0===n?Oe:n,null!=e){if(D&&e instanceof Uint8Array)return e.length?new ue(new Uint8Array(e),V):he();if(Array.isArray(e)){var a=Ae(e);return 2&a?e:!t||32&a||!(16&a||0===a)?(4&(t=Ae(e=nt(e,rt,4&a?Oe:n,!0)))&&2&t&&Object.freeze(e),e):(Me(e,2|a),e)}return e.ja===Fe?ot(e):e}}function it(e,t,n,a,s,r,i){if(e=e.h&&e.h[n]){if(2&(a=Ae(e))?a=e:(Oe(a,r=R(e,ot)),Object.freeze(r),a=r),We(t),i=null==a?ze:Pe([]),null!=a){for(r=!!a.length,e=0;e<a.length;e++){var o=a[e];r=r&&!(2&Ae(o.o)),i[e]=o.o}r=1|(r?8:0),((e=Ae(i))&r)!==r&&(Object.isFrozen(i)&&(i=Array.prototype.slice.call(i)),Me(i,e|r)),t.h||(t.h={}),t.h[n]=a}else t.h&&(t.h[n]=void 0);qe(t,n,i,s)}else Ge(t,n,rt(a,r,i),s)}function ot(e){return 2&Ae(e.o)||Re((e=ct(e,!0)).o,2),e}function ct(e,t){var n=e.o,a=[];Re(a,16);var s=e.constructor.h;if(s&&a.push(s),s=e.B){a.length=n.length,a.fill(void 0,a.length,n.length);var r={};a[a.length-1]=r}0!==(128&Ae(n))&&Ve(a),t=t||e.C()?Oe:De,r=e.constructor,Be=a,a=new r(a),Be=void 0,e.R&&(a.R=e.R.slice()),r=!!(16&Ae(n));for(var i=s?n.length-1:n.length,o=0;o<i;o++)it(e,a,o-e.G,n[o],!1,r,t);if(s)for(var c in s)it(e,a,+c,s[c],!0,r,t);return a}function lt(e,t,n){null==e&&(e=Be),Be=void 0;var a,s=this.constructor.i||0,r=0<s,i=this.constructor.h,o=!1;if(null==e){var c=48,l=!0;r&&(s=0,c|=128),Me(e=i?[i]:[],c)}else{if(!Array.isArray(e))throw Error();if(i&&i!==e[0])throw Error();var u=c=Re(e,0);if((l=0!==(16&u))&&((o=0!==(32&u))||(u|=32)),r){if(128&u)s=0;else if(0<e.length){var h=e[e.length-1];if(Le(h)&&"g"in h){s=0,u|=128,delete h.g;var d,p=!0;for(d in h){p=!1;break}p&&e.pop()}}}else if(128&u)throw Error();c!==u&&Me(e,u)}if(this.G=(i?0:-1)-s,this.h=void 0,this.o=e,s=(i=this.o.length)-1,i&&Le(i=this.o[s])?(this.B=i,this.i=s-this.G):void 0!==t&&-1<t?(this.i=Math.max(t,s+1-this.G),this.B=void 0):this.i=Number.MAX_VALUE,!r&&this.B&&"g"in this.B)throw Error('Unexpected "g" flag in sparse object of message that is not a group type.');if(n)for(t=l&&!o&&!0,r=this.i,l=0;l<n.length;l++)(o=n[l])<r?(s=e[o+=this.G])?ut(s,t):e[o]=ze:(a||(a=Ue(this)),(s=a[o])?ut(s,t):a[o]=ze)}function ut(e,t){if(Array.isArray(e)){var n=Ae(e),a=1;!t||2&n||(a|=16),(n&a)!==a&&Me(e,n|a)}}function ht(e,t,n){if(n){var a,s={};for(a in n){var r=n[a],i=r.ra;i||(s.J=r.xa||r.oa.W,r.ia?(s.aa=xt(r.ia),i=function(e){return function(t,n,a){return e.J(t,n,a,e.aa)}}(s)):r.ka?(s.Z=vt(r.da.P,r.ka),i=function(e){return function(t,n,a){return e.J(t,n,a,e.Z)}}(s)):i=s.J,r.ra=i),i(t,e,r.da),s={J:s.J,aa:s.aa,Z:s.Z}}}!function(e,t){if(t=t.R){Te(e,e.h.end());for(var n=0;n<t.length;n++)Te(e,de(t[n])||W())}}(t,e)}Me(je,23),ze=Object.freeze(je),lt.prototype.toJSON=function(){return nt(this.o,at,st)},lt.prototype.C=function(){return!!(2&Ae(this.o))},lt.prototype.ja=Fe,lt.prototype.toString=function(){return this.o.toString()};var dt=Symbol();function pt(e,t,n){return e[dt]||(e[dt]=function(e,a){return t(e,a,n)})}function ft(e){var t=e[dt];if(!t){var n=Mt(e);t=function(e,t){return Pt(e,t,n)},e[dt]=t}return t}function mt(e){var t=function(e){var t=e.ia;return t?ft(t):(t=e.wa)?pt(e.da.P,t,e.ka):void 0}(e),n=e.da,a=e.oa.U;return t?function(e,s){return a(e,s,n,t)}:function(e,t){return a(e,t,n)}}function gt(e,t){var n=e[t];return"function"==typeof n&&0===n.length&&(n=n(),e[t]=n),Array.isArray(n)&&(Tt in n||wt in n||0<n.length&&"function"==typeof n[0])?n:void 0}function yt(e,t,n,a,s,r){t.P=e[0];var i=1;if(e.length>i&&"number"!==typeof e[i]){var o=e[i++];n(t,o)}for(;i<e.length;){n=e[i++];for(var c=i+1;c<e.length&&"number"!==typeof e[c];)c++;switch(o=e[i++],c-=i){case 0:a(t,n,o);break;case 1:(c=gt(e,i))?(i++,s(t,n,o,c)):a(t,n,o,e[i++]);break;case 2:s(t,n,o,c=gt(e,c=i++),e[i++]);break;case 3:r(t,n,o,e[i++],e[i++],e[i++]);break;case 4:r(t,n,o,e[i++],e[i++],e[i++],e[i++]);break;default:throw Error("unexpected number of binary field arguments: "+c)}}return t}var bt=Symbol();function xt(e){var t=e[bt];if(!t){var n=Nt(e);t=function(e,t){return Dt(e,t,n)},e[bt]=t}return t}function vt(e,t){var n=e[bt];return n||(n=function(e,n){return ht(e,n,t)},e[bt]=n),n}var wt=Symbol();function kt(e,t){e.push(t)}function St(e,t,n){e.push(t,n.W)}function Ct(e,t,n,a){var s=xt(a),r=Nt(a).P,i=n.W;e.push(t,function(e,t,n){return i(e,t,n,r,s)})}function It(e,t,n,a,s,r){var i=vt(a,r),o=n.W;e.push(t,function(e,t,n){return o(e,t,n,a,i)})}function Nt(e){var t=e[wt];return t||(t=yt(e,e[wt]=[],kt,St,Ct,It),Tt in e&&wt in e&&(e.length=0),t)}var Tt=Symbol();function Et(e,t){e[0]=t}function Rt(e,t,n,a){var s=n.U;e[t]=a?function(e,t,n){return s(e,t,n,a)}:s}function _t(e,t,n,a,s){var r=n.U,i=ft(a),o=Mt(a).P;e[t]=function(e,t,n){return r(e,t,n,o,i,s)}}function At(e,t,n,a,s,r,i){var o=n.U,c=pt(a,s,r);e[t]=function(e,t,n){return o(e,t,n,a,c,i)}}function Mt(e){var t=e[Tt];return t||(t=yt(e,e[Tt]={},Et,Rt,_t,At),Tt in e&&wt in e&&(e.length=0),t)}function Pt(e,t,n){for(;Se(t)&&4!=t.i;){var a=t.l,s=n[a];if(!s){var r=n[0];r&&(r=r[a])&&(s=n[a]=mt(r))}if(!s||!s(t,e,a)){a=e,r=(s=t).j,Ce(s);var i=s;if(!i.ca){if(s=i.h.h-r,i.h.h=r,i=i.h,0==s)s=he();else{if(r=ye(i,s),i.S&&i.m)s=i.i.subarray(r,r+s);else{i=i.i;var o=r;s=o===(s=r+s)?W():U?i.slice(o,s):new Uint8Array(i.subarray(o,s))}s=0==s.length?he():new ue(s,V)}(r=a.R)?r.push(s):a.R=[s]}}}return e}function Dt(e,t,n){for(var a=n.length,s=1==a%2,r=s?1:0;r<a;r+=2)(0,n[r+1])(t,e,n[r]);ht(e,t,s?n[0]:void 0)}function Ot(e,t){return{U:e,W:t}}var Ft=Ot(function(e,t,n){if(5!==e.i)return!1;var a=(e=e.h).i,s=e.h,r=a[s],i=a[s+1],o=a[s+2];return a=a[s+3],me(e,e.h+4),e=2*((i=(r|i<<8|o<<16|a<<24)>>>0)>>31)+1,r=i>>>23&255,i&=8388607,Ge(t,n,255==r?i?NaN:1/0*e:0==r?e*Math.pow(2,-149)*i:e*Math.pow(2,r-150)*(i+Math.pow(2,23))),!0},function(e,t,n){if(null!=(t=Xe(t,n))){we(e.h,8*n+5),e=e.h;var a=+t;0===a?0<1/a?H=G=0:(G=0,H=2147483648):isNaN(a)?(G=0,H=2147483647):34028234663852886e22<(a=(n=0>a?-2147483648:0)?-a:a)?(G=0,H=(2139095040|n)>>>0):11754943508222875e-54>a?(a=Math.round(a/Math.pow(2,-149)),G=0,H=(n|a)>>>0):(t=Math.floor(Math.log(a)/Math.LN2),a*=Math.pow(2,-t),16777216<=(a=Math.round(8388608*a))&&++t,G=0,H=(n|t+127<<23|8388607&a)>>>0),n=H,e.h.push(n>>>0&255),e.h.push(n>>>8&255),e.h.push(n>>>16&255),e.h.push(n>>>24&255)}}),Lt=Ot(function(e,t,n){if(0!==e.i)return!1;var a=e.h,s=0,r=e=0,i=a.i,o=a.h;do{var c=i[o++];s|=(127&c)<<r,r+=7}while(32>r&&128&c);for(32<r&&(e|=(127&c)>>4),r=3;32>r&&128&c;r+=7)e|=(127&(c=i[o++]))<<r;if(me(a,o),!(128>c))throw $();return a=s>>>0,(e=2147483648&(c=e>>>0))&&(c=~c>>>0,0==(a=1+~a>>>0)&&(c=c+1>>>0)),a=4294967296*c+(a>>>0),Ge(t,n,e?-a:a),!0},function(e,t,n){null!=(t=He(t,n))&&("string"===typeof t&&Z(t),null!=t&&(we(e.h,8*n),"number"===typeof t?(e=e.h,q(t),ve(e,H,G)):(n=Z(t),ve(e.h,n.i,n.h))))}),zt=Ot(function(e,t,n){return 0===e.i&&(Ge(t,n,ge(e.h)),!0)},function(e,t,n){if(null!=(t=He(t,n))&&null!=t)if(we(e.h,8*n),e=e.h,0<=(n=t))we(e,n);else{for(t=0;9>t;t++)e.h.push(127&n|128),n>>=7;e.h.push(1)}}),Bt=Ot(function(e,t,n){if(2!==e.i)return!1;var a=ge(e.h)>>>0,s=ye(e=e.h,a);if(e=e.i,oe){var r,i=e;(r=ae)||(r=ae=new TextDecoder("utf-8",{fatal:!0})),e=s+a,i=0===s&&e===i.length?i:i.subarray(s,e);try{var o=r.decode(i)}catch(h){if(void 0===ie){try{r.decode(new Uint8Array([128]))}catch(d){}try{r.decode(new Uint8Array([97])),ie=!0}catch(d){ie=!1}}throw!ie&&(ae=void 0),h}}else{a=(o=s)+a,s=[];for(var c,l,u=null;o<a;)128>(c=e[o++])?s.push(c):224>c?o>=a?te():(l=e[o++],194>c||128!==(192&l)?(o--,te()):s.push((31&c)<<6|63&l)):240>c?o>=a-1?te():128!==(192&(l=e[o++]))||224===c&&160>l||237===c&&160<=l||128!==(192&(i=e[o++]))?(o--,te()):s.push((15&c)<<12|(63&l)<<6|63&i):244>=c?o>=a-2?te():128!==(192&(l=e[o++]))||0!==l-144+(c<<28)>>30||128!==(192&(i=e[o++]))||128!==(192&(r=e[o++]))?(o--,te()):(c=(7&c)<<18|(63&l)<<12|(63&i)<<6|63&r,c-=65536,s.push(55296+(c>>10&1023),56320+(1023&c))):te(),8192<=s.length&&(u=ne(u,s),s.length=0);o=ne(u,s)}return Ge(t,n,o),!0},function(e,t,n){if(null!=(t=He(t,n))){var a=!1;if(a=void 0!==a&&a,ce){if(a&&/(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])/.test(t))throw Error("Found an unpaired surrogate");t=(se||(se=new TextEncoder)).encode(t)}else{for(var s=0,r=new Uint8Array(3*t.length),i=0;i<t.length;i++){var o=t.charCodeAt(i);if(128>o)r[s++]=o;else{if(2048>o)r[s++]=o>>6|192;else{if(55296<=o&&57343>=o){if(56319>=o&&i<t.length){var c=t.charCodeAt(++i);if(56320<=c&&57343>=c){o=1024*(o-55296)+c-56320+65536,r[s++]=o>>18|240,r[s++]=o>>12&63|128,r[s++]=o>>6&63|128,r[s++]=63&o|128;continue}i--}if(a)throw Error("Found an unpaired surrogate");o=65533}r[s++]=o>>12|224,r[s++]=o>>6&63|128}r[s++]=63&o|128}}t=s===r.length?r:r.subarray(0,s)}we(e.h,8*n+2),we(e.h,t.length),Te(e,e.h.end()),Te(e,t)}}),jt=Ot(function(e,t,n,a,s){if(2!==e.i)return!1;t=Je(t,n,a),n=e.h.j,a=ge(e.h)>>>0;var r=e.h.h+a,i=r-n;if(0>=i&&(e.h.j=r,s(t,e,void 0,void 0,void 0),i=r-e.h.h),i)throw Error("Message parsing ended unexpectedly. Expected to read "+a+" bytes, instead read "+(a-i)+" bytes, either the data ended unexpectedly or the message misreported its own length");return e.h.h=r,e.h.j=n,!0},function(e,t,n,a,s){if(null!=(t=Qe(t,a,n)))for(a=0;a<t.length;a++){var r=e;we(r.h,8*n+2);var i=r.h.end();Te(r,i),i.push(r.i),r=i,s(t[a],e),i=e;var o=r.pop();for(o=i.i+i.h.length()-o;127<o;)r.push(127&o|128),o>>>=7,i.i++;r.push(o),i.i++}});function Wt(e){return function(t,n){e:{if(Ie.length){var a=Ie.pop();a.setOptions(n),fe(a.h,t,n),t=a}else t=new ke(t,n);try{var s=Mt(e),r=Pt(new s.P,t,s);break e}finally{(s=t.h).i=null,s.m=!1,s.l=0,s.j=0,s.h=0,s.S=!1,t.l=-1,t.i=-1,100>Ie.length&&Ie.push(t)}r=void 0}return r}}function Vt(e){return function(){var t=new Ne;Dt(this,t,Nt(e)),Te(t,t.h.end());for(var n=new Uint8Array(t.i),a=t.j,s=a.length,r=0,i=0;i<s;i++){var o=a[i];n.set(o,r),r+=o.length}return t.j=[n],n}}function Ut(e){lt.call(this,e)}m(Ut,lt);var Ht=[Ut,1,zt,2,Ft,3,Bt,4,Bt];function Gt(e){lt.call(this,e,-1,qt)}Ut.prototype.l=Vt(Ht),m(Gt,lt),Gt.prototype.addClassification=function(e,t){return Je(this,1,Ut,e,t),this};var qt=[1],Kt=Wt([Gt,1,jt,Ht]);function Xt(e){lt.call(this,e)}m(Xt,lt);var Yt=[Xt,1,Ft,2,Ft,3,Ft,4,Ft,5,Ft];function Qt(e){lt.call(this,e,-1,Zt)}Xt.prototype.l=Vt(Yt),m(Qt,lt);var Zt=[1],Jt=Wt([Qt,1,jt,Yt]);function $t(e){lt.call(this,e)}m($t,lt);var en=[$t,1,Ft,2,Ft,3,Ft,4,Ft,5,Ft,6,Lt],tn=Wt(en);function nn(e,t,n){if(n=e.createShader(0===n?e.VERTEX_SHADER:e.FRAGMENT_SHADER),e.shaderSource(n,t),e.compileShader(n),!e.getShaderParameter(n,e.COMPILE_STATUS))throw Error("Could not compile WebGL shader.\n\n"+e.getShaderInfoLog(n));return n}function an(e){return Qe(e,Ut,1).map(function(e){var t=He(e,1);return{index:null==t?0:t,qa:et(e,2),label:null!=He(e,3)?$e(He(e,3),""):void 0,displayName:null!=He(e,4)?$e(He(e,4),""):void 0}})}function sn(e){return{x:et(e,1),y:et(e,2),z:et(e,3),visibility:null!=Xe(e,4)?et(e,4):void 0}}function rn(e){return Qe(Jt(e),Xt,1).map(sn)}function on(e,t){this.i=e,this.h=t,this.m=0}function cn(e,t,n){return function(e,t){var n=e.h;if(void 0===e.s){var a=nn(n,"\n  attribute vec2 aVertex;\n  attribute vec2 aTex;\n  varying vec2 vTex;\n  void main(void) {\n    gl_Position = vec4(aVertex, 0.0, 1.0);\n    vTex = aTex;\n  }",0),s=nn(n,"\n  precision mediump float;\n  varying vec2 vTex;\n  uniform sampler2D sampler0;\n  void main(){\n    gl_FragColor = texture2D(sampler0, vTex);\n  }",1),r=n.createProgram();if(n.attachShader(r,a),n.attachShader(r,s),n.linkProgram(r),!n.getProgramParameter(r,n.LINK_STATUS))throw Error("Could not compile WebGL program.\n\n"+n.getProgramInfoLog(r));a=e.s=r,n.useProgram(a),s=n.getUniformLocation(a,"sampler0"),e.l={O:n.getAttribLocation(a,"aVertex"),N:n.getAttribLocation(a,"aTex"),ya:s},e.v=n.createBuffer(),n.bindBuffer(n.ARRAY_BUFFER,e.v),n.enableVertexAttribArray(e.l.O),n.vertexAttribPointer(e.l.O,2,n.FLOAT,!1,0,0),n.bufferData(n.ARRAY_BUFFER,new Float32Array([-1,-1,-1,1,1,1,1,-1]),n.STATIC_DRAW),n.bindBuffer(n.ARRAY_BUFFER,null),e.u=n.createBuffer(),n.bindBuffer(n.ARRAY_BUFFER,e.u),n.enableVertexAttribArray(e.l.N),n.vertexAttribPointer(e.l.N,2,n.FLOAT,!1,0,0),n.bufferData(n.ARRAY_BUFFER,new Float32Array([0,1,0,0,1,0,1,1]),n.STATIC_DRAW),n.bindBuffer(n.ARRAY_BUFFER,null),n.uniform1i(s,0)}a=e.l,n.useProgram(e.s),n.canvas.width=t.width,n.canvas.height=t.height,n.viewport(0,0,t.width,t.height),n.activeTexture(n.TEXTURE0),e.i.bindTexture2d(t.glName),n.enableVertexAttribArray(a.O),n.bindBuffer(n.ARRAY_BUFFER,e.v),n.vertexAttribPointer(a.O,2,n.FLOAT,!1,0,0),n.enableVertexAttribArray(a.N),n.bindBuffer(n.ARRAY_BUFFER,e.u),n.vertexAttribPointer(a.N,2,n.FLOAT,!1,0,0),n.bindFramebuffer(n.DRAW_FRAMEBUFFER?n.DRAW_FRAMEBUFFER:n.FRAMEBUFFER,null),n.clearColor(0,0,0,0),n.clear(n.COLOR_BUFFER_BIT),n.colorMask(!0,!0,!0,!0),n.drawArrays(n.TRIANGLE_FAN,0,4),n.disableVertexAttribArray(a.O),n.disableVertexAttribArray(a.N),n.bindBuffer(n.ARRAY_BUFFER,null),e.i.bindTexture2d(0)}(e,t),"function"===typeof e.h.canvas.transferToImageBitmap?Promise.resolve(e.h.canvas.transferToImageBitmap()):n?Promise.resolve(e.h.canvas):"function"===typeof createImageBitmap?createImageBitmap(e.h.canvas):(void 0===e.j&&(e.j=document.createElement("canvas")),new Promise(function(t){e.j.height=e.h.canvas.height,e.j.width=e.h.canvas.width,e.j.getContext("2d",{}).drawImage(e.h.canvas,0,0,e.h.canvas.width,e.h.canvas.height),t(e.j)}))}function ln(e){this.h=e}$t.prototype.l=Vt(en);var un=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]);function hn(e,t){return t+e}function dn(e,t){window[e]=t}function pn(e){if(this.h=e,this.listeners={},this.l={},this.L={},this.s={},this.v={},this.M=this.u=this.ga=!0,this.I=Promise.resolve(),this.fa="",this.D={},this.locateFile=e&&e.locateFile||hn,"object"===typeof window)var t=window.location.pathname.toString().substring(0,window.location.pathname.toString().lastIndexOf("/"))+"/";else{if("undefined"===typeof location)throw Error("solutions can only be loaded on a web page or in a web worker");t=location.pathname.toString().substring(0,location.pathname.toString().lastIndexOf("/"))+"/"}if(this.ha=t,e.options)for(var n=(t=o(Object.keys(e.options))).next();!n.done;n=t.next()){n=n.value;var a=e.options[n].default;void 0!==a&&(this.l[n]="function"===typeof a?a():a)}}function fn(e){var t,n,a,s,r,i,o,l,u,h,d;return C(function(p){switch(p.h){case 1:return e.ga?(t=void 0===e.h.files?[]:"function"===typeof e.h.files?e.h.files(e.l):e.h.files,x(p,C(function(e){switch(e.h){case 1:return e.s=2,x(e,WebAssembly.instantiate(un),4);case 4:e.h=3,e.s=0;break;case 2:return e.s=0,e.l=null,e.return(!1);case 3:return e.return(!0)}}),2)):p.return();case 2:if(n=p.i,"object"===typeof window)return dn("createMediapipeSolutionsWasm",{locateFile:e.locateFile}),dn("createMediapipeSolutionsPackedAssets",{locateFile:e.locateFile}),i=t.filter(function(e){return void 0!==e.data}),o=t.filter(function(e){return void 0===e.data}),l=Promise.all(i.map(function(t){var n=mn(e,t.url);if(void 0!==t.path){var a=t.path;n=n.then(function(t){return e.overrideFile(a,t),Promise.resolve(t)})}return n})),u=Promise.all(o.map(function(t){return void 0===t.simd||t.simd&&n||!t.simd&&!n?function(e){var t=document.createElement("script");return t.setAttribute("src",e),t.setAttribute("crossorigin","anonymous"),new Promise(function(e){t.addEventListener("load",function(){e()},!1),t.addEventListener("error",function(){e()},!1),document.body.appendChild(t)})}(e.locateFile(t.url,e.ha)):Promise.resolve()})).then(function(){var t,n,a;return C(function(s){if(1==s.h)return t=window.createMediapipeSolutionsWasm,n=window.createMediapipeSolutionsPackedAssets,a=e,x(s,t(n),2);a.i=s.i,s.h=0})}),h=C(function(t){return e.h.graph&&e.h.graph.url?t=x(t,mn(e,e.h.graph.url),0):(t.h=0,t=void 0),t}),x(p,Promise.all([u,l,h]),7);if("function"!==typeof importScripts)throw Error("solutions can only be loaded on a web page or in a web worker");return a=t.filter(function(e){return void 0===e.simd||e.simd&&n||!e.simd&&!n}).map(function(t){return e.locateFile(t.url,e.ha)}),importScripts.apply(null,c(a)),s=e,x(p,createMediapipeSolutionsWasm(Module),6);case 6:s.i=p.i,e.m=new OffscreenCanvas(1,1),e.i.canvas=e.m,r=e.i.GL.createContext(e.m,{antialias:!1,alpha:!1,va:"undefined"!==typeof WebGL2RenderingContext?2:1}),e.i.GL.makeContextCurrent(r),p.h=4;break;case 7:if(e.m=document.createElement("canvas"),!(d=e.m.getContext("webgl2",{}))&&!(d=e.m.getContext("webgl",{})))return alert("Failed to create WebGL canvas context when passing video frame."),p.return();e.K=d,e.i.canvas=e.m,e.i.createContext(e.m,!0,!0,{});case 4:e.j=new e.i.SolutionWasm,e.ga=!1,p.h=0}})}function mn(e,t){var n,a;return C(function(s){return t in e.L?s.return(e.L[t]):(n=e.locateFile(t,""),a=fetch(n).then(function(e){return e.arrayBuffer()}),e.L[t]=a,s.return(a))})}function gn(e,t,n){var a,s,r,i,c,l,u,h,d,p,f,m,g,y;return C(function(b){switch(b.h){case 1:if(!n)return b.return(t);for(a={},s=0,r=o(Object.keys(n)),i=r.next();!i.done;i=r.next())c=i.value,"string"!==typeof(l=n[c])&&"texture"===l.type&&void 0!==t[l.stream]&&++s;1<s&&(e.M=!1),u=o(Object.keys(n)),i=u.next();case 2:if(i.done){b.h=4;break}if(h=i.value,"string"===typeof(d=n[h]))return g=a,y=h,x(b,function(e,t,n){var a;return C(function(s){return"number"===typeof n||n instanceof Uint8Array||n instanceof e.i.Uint8BlobList?s.return(n):n instanceof e.i.Texture2dDataOut?((a=e.v[t])||(a=new on(e.i,e.K),e.v[t]=a),s.return(cn(a,n,e.M))):s.return(void 0)})}(e,h,t[d]),14);if(p=t[d.stream],"detection_list"===d.type){if(p){for(var v=p.getRectList(),w=p.getLandmarksList(),k=p.getClassificationsList(),S=[],I=0;I<v.size();++I){var N=tn(v.get(I)),T=void 0;T=void 0===T?0:T,N={la:{sa:et(N,1),ta:et(N,2),height:et(N,3),width:et(N,4),rotation:et(N,5,0),pa:$e(He(N,6),T)},ea:rn(w.get(I)),ba:an(Kt(k.get(I)))},S.push(N)}v=S}else v=[];a[h]=v,b.h=7;break}if("proto_list"===d.type){if(p){for(v=Array(p.size()),w=0;w<p.size();w++)v[w]=p.get(w);p.delete()}else v=[];a[h]=v,b.h=7;break}if(void 0===p){b.h=3;break}if("float_list"===d.type){a[h]=p,b.h=7;break}if("proto"===d.type){a[h]=p,b.h=7;break}if("texture"!==d.type)throw Error("Unknown output config type: '"+d.type+"'");return(f=e.v[h])||(f=new on(e.i,e.K),e.v[h]=f),x(b,cn(f,p,e.M),13);case 13:m=b.i,a[h]=m;case 7:d.transform&&a[h]&&(a[h]=d.transform(a[h])),b.h=3;break;case 14:g[y]=b.i;case 3:i=u.next(),b.h=2;break;case 4:return b.return(a)}})}function yn(e,t){for(var n=t.name||"$",a=[].concat(c(t.wants)),s=new e.i.StringList,r=o(t.wants),i=r.next();!i.done;i=r.next())s.push_back(i.value);r=e.i.PacketListener.implement({onResults:function(s){for(var r={},i=0;i<t.wants.length;++i)r[a[i]]=s.get(i);var o=e.listeners[n];o&&(e.I=gn(e,r,t.outs).then(function(n){n=o(n);for(var s=0;s<t.wants.length;++s){var i=r[a[s]];"object"===typeof i&&i.hasOwnProperty&&i.hasOwnProperty("delete")&&i.delete()}n&&(e.I=n)}))}}),e.j.attachMultiListener(s,r),s.delete()}function bn(e){switch(void 0===e&&(e=0),e){case 1:return"pose_landmark_full.tflite";case 2:return"pose_landmark_heavy.tflite";default:return"pose_landmark_lite.tflite"}}function xn(e){var t=this;e=e||{},this.h=new pn({locateFile:e.locateFile,files:function(e){return[{url:"pose_solution_packed_assets_loader.js"},{simd:!1,url:"pose_solution_wasm_bin.js"},{simd:!0,url:"pose_solution_simd_wasm_bin.js"},{data:!0,url:bn(e.modelComplexity)}]},graph:{url:"pose_web.binarypb"},listeners:[{wants:["pose_landmarks","world_landmarks","segmentation_mask","image_transformed"],outs:{image:{type:"texture",stream:"image_transformed"},poseLandmarks:{type:"proto",stream:"pose_landmarks",transform:rn},poseWorldLandmarks:{type:"proto",stream:"world_landmarks",transform:rn},segmentationMask:{type:"texture",stream:"segmentation_mask"}}}],inputs:{image:{type:"video",stream:"input_frames_gpu"}},options:{useCpuInference:{type:0,graphOptionXref:{calculatorType:"InferenceCalculator",fieldName:"use_cpu_inference"},default:"object"===typeof window&&void 0!==window.navigator&&("iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform)||navigator.userAgent.includes("Mac")&&"ontouchend"in document)},selfieMode:{type:0,graphOptionXref:{calculatorType:"GlScalerCalculator",calculatorIndex:1,fieldName:"flip_horizontal"}},modelComplexity:{type:1,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorModelComplexity",fieldName:"int_value"},onChange:function(e){var n,a,s;return C(function(r){return 1==r.h?(n=bn(e),a="third_party/mediapipe/modules/pose_landmark/"+n,x(r,mn(t.h,n),2)):(s=r.i,t.h.overrideFile(a,s),r.return(!0))})}},smoothLandmarks:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothLandmarks",fieldName:"bool_value"}},enableSegmentation:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorEnableSegmentation",fieldName:"bool_value"}},smoothSegmentation:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothSegmentation",fieldName:"bool_value"}},minDetectionConfidence:{type:1,graphOptionXref:{calculatorType:"TensorsToDetectionsCalculator",calculatorName:"poselandmarkgpu__posedetectiongpu__TensorsToDetectionsCalculator",fieldName:"min_score_thresh"}},minTrackingConfidence:{type:1,graphOptionXref:{calculatorType:"ThresholdingCalculator",calculatorName:"poselandmarkgpu__poselandmarkbyroigpu__tensorstoposelandmarksandsegmentation__ThresholdingCalculator",fieldName:"threshold"}}}})}(e=pn.prototype).close=function(){return this.j&&this.j.delete(),Promise.resolve()},e.reset=function(){var e=this;return C(function(t){e.j&&(e.j.reset(),e.s={},e.v={}),t.h=0})},e.setOptions=function(e,t){var n=this;if(t=t||this.h.options){for(var a=[],s=[],r={},i=o(Object.keys(e)),c=i.next();!c.done;r={X:r.X,Y:r.Y},c=i.next())if(!((c=c.value)in this.l)||this.l[c]!==e[c]){this.l[c]=e[c];var l=t[c];void 0!==l&&(l.onChange&&(r.X=l.onChange,r.Y=e[c],a.push(function(e){return function(){return C(function(t){if(1==t.h)return x(t,e.X(e.Y),2);!0===t.i&&(n.u=!0),t.h=0})}}(r))),l.graphOptionXref&&(c=Object.assign({},{calculatorName:"",calculatorIndex:0},l.graphOptionXref,{valueNumber:1===l.type?e[c]:0,valueBoolean:0===l.type&&e[c],valueString:2===l.type?e[c]:""}),s.push(c)))}0===a.length&&0===s.length||(this.u=!0,this.H=(void 0===this.H?[]:this.H).concat(s),this.F=(void 0===this.F?[]:this.F).concat(a))}},e.initialize=function(){var e=this;return C(function(t){return 1==t.h?x(t,fn(e),2):3!=t.h?x(t,function(e){var t,n,a,s,r,i,c,l;return C(function(u){if(1==u.h)return e.h.graph&&e.h.graph.url&&e.fa===e.h.graph.url?u.return():(e.u=!0,e.h.graph&&e.h.graph.url?(e.fa=e.h.graph.url,x(u,mn(e,e.h.graph.url),3)):void(u.h=2));for(2!=u.h&&(t=u.i,e.j.loadGraph(t)),n=o(Object.keys(e.D)),a=n.next();!a.done;a=n.next())s=a.value,e.j.overrideFile(s,e.D[s]);if(e.D={},e.h.listeners)for(r=o(e.h.listeners),i=r.next();!i.done;i=r.next())c=i.value,yn(e,c);l=e.l,e.l={},e.setOptions(l),u.h=0})}(e),3):x(t,function(e){var t,n,a,s,r,i;return C(function(c){switch(c.h){case 1:if(!e.u)return c.return();if(!e.F){c.h=2;break}t=o(e.F),n=t.next();case 3:if(n.done){c.h=5;break}return x(c,(0,n.value)(),4);case 4:n=t.next(),c.h=3;break;case 5:e.F=void 0;case 2:if(e.H){for(a=new e.i.GraphOptionChangeRequestList,s=o(e.H),r=s.next();!r.done;r=s.next())i=r.value,a.push_back(i);e.j.changeOptions(a),a.delete(),e.H=void 0}e.u=!1,c.h=0}})}(e),0)})},e.overrideFile=function(e,t){this.j?this.j.overrideFile(e,t):this.D[e]=t},e.clearOverriddenFiles=function(){this.D={},this.j&&this.j.clearOverriddenFiles()},e.send=function(e,t){var n,a,s,r,i,c,l,u,h,d=this;return C(function(p){switch(p.h){case 1:return d.h.inputs?(n=1e3*(void 0===t||null===t?performance.now():t),x(p,d.I,2)):p.return();case 2:return x(p,d.initialize(),3);case 3:for(a=new d.i.PacketDataList,s=o(Object.keys(e)),r=s.next();!r.done;r=s.next())if(i=r.value,c=d.h.inputs[i]){e:{var f=e[i];switch(c.type){case"video":var m=d.s[c.stream];if(m||(m=new on(d.i,d.K),d.s[c.stream]=m),0===m.m&&(m.m=m.i.createTexture()),"undefined"!==typeof HTMLVideoElement&&f instanceof HTMLVideoElement)var g=f.videoWidth,y=f.videoHeight;else"undefined"!==typeof HTMLImageElement&&f instanceof HTMLImageElement?(g=f.naturalWidth,y=f.naturalHeight):(g=f.width,y=f.height);y={glName:m.m,width:g,height:y},(g=m.h).canvas.width=y.width,g.canvas.height=y.height,g.activeTexture(g.TEXTURE0),m.i.bindTexture2d(m.m),g.texImage2D(g.TEXTURE_2D,0,g.RGBA,g.RGBA,g.UNSIGNED_BYTE,f),m.i.bindTexture2d(0),m=y;break e;case"detections":for((m=d.s[c.stream])||(m=new ln(d.i),d.s[c.stream]=m),m.data||(m.data=new m.h.DetectionListData),m.data.reset(f.length),y=0;y<f.length;++y){g=f[y];var b=m.data,v=b.setBoundingBox,w=y,k=g.la,S=new $t;if(Ze(S,1,k.sa),Ze(S,2,k.ta),Ze(S,3,k.height),Ze(S,4,k.width),Ze(S,5,k.rotation),Ge(S,6,k.pa),k=S.l(),v.call(b,w,k),g.ea)for(b=0;b<g.ea.length;++b){S=g.ea[b],w=(v=m.data).addNormalizedLandmark,k=y,S=Object.assign({},S,{visibility:S.visibility?S.visibility:0});var C=new Xt;Ze(C,1,S.x),Ze(C,2,S.y),Ze(C,3,S.z),S.visibility&&Ze(C,4,S.visibility),S=C.l(),w.call(v,k,S)}if(g.ba)for(b=0;b<g.ba.length;++b)w=(v=m.data).addClassification,k=y,S=g.ba[b],Ze(C=new Ut,2,S.qa),S.index&&Ge(C,1,S.index),S.label&&Ge(C,3,S.label),S.displayName&&Ge(C,4,S.displayName),S=C.l(),w.call(v,k,S)}m=m.data;break e;default:m={}}}switch(l=m,u=c.stream,c.type){case"video":a.pushTexture2d(Object.assign({},l,{stream:u,timestamp:n}));break;case"detections":(h=l).stream=u,h.timestamp=n,a.pushDetectionList(h);break;default:throw Error("Unknown input config type: '"+c.type+"'")}}return d.j.send(a),x(p,d.I,4);case 4:a.delete(),p.h=0}})},e.onResults=function(e,t){this.listeners[t||"$"]=e},T("Solution",pn),T("OptionType",{BOOL:0,NUMBER:1,ua:2,0:"BOOL",1:"NUMBER",2:"STRING"}),(e=xn.prototype).reset=function(){this.h.reset()},e.close=function(){return this.h.close(),Promise.resolve()},e.onResults=function(e){this.h.onResults(e)},e.initialize=function(){var e=this;return C(function(t){return x(t,e.h.initialize(),0)})},e.send=function(e,t){var n=this;return C(function(a){return x(a,n.h.send(e,t),0)})},e.setOptions=function(e){this.h.setOptions(e)},T("Pose",xn),T("POSE_CONNECTIONS",[[0,1],[1,2],[2,3],[3,7],[0,4],[4,5],[5,6],[6,8],[9,10],[11,12],[11,13],[13,15],[15,17],[15,19],[15,21],[17,19],[12,14],[14,16],[16,18],[16,20],[16,22],[18,20],[11,23],[12,24],[23,24],[23,25],[24,26],[25,27],[26,28],[27,29],[28,30],[29,31],[30,32],[27,31],[28,32]]),T("POSE_LANDMARKS",{NOSE:0,LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,LEFT_EAR:7,RIGHT_EAR:8,LEFT_RIGHT:9,RIGHT_LEFT:10,LEFT_SHOULDER:11,RIGHT_SHOULDER:12,LEFT_ELBOW:13,RIGHT_ELBOW:14,LEFT_WRIST:15,RIGHT_WRIST:16,LEFT_PINKY:17,RIGHT_PINKY:18,LEFT_INDEX:19,RIGHT_INDEX:20,LEFT_THUMB:21,RIGHT_THUMB:22,LEFT_HIP:23,RIGHT_HIP:24,LEFT_KNEE:25,RIGHT_KNEE:26,LEFT_ANKLE:27,RIGHT_ANKLE:28,LEFT_HEEL:29,RIGHT_HEEL:30,LEFT_FOOT_INDEX:31,RIGHT_FOOT_INDEX:32}),T("POSE_LANDMARKS_LEFT",{LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,LEFT_EAR:7,LEFT_RIGHT:9,LEFT_SHOULDER:11,LEFT_ELBOW:13,LEFT_WRIST:15,LEFT_PINKY:17,LEFT_INDEX:19,LEFT_THUMB:21,LEFT_HIP:23,LEFT_KNEE:25,LEFT_ANKLE:27,LEFT_HEEL:29,LEFT_FOOT_INDEX:31}),T("POSE_LANDMARKS_RIGHT",{RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,RIGHT_EAR:8,RIGHT_LEFT:10,RIGHT_SHOULDER:12,RIGHT_ELBOW:14,RIGHT_WRIST:16,RIGHT_PINKY:18,RIGHT_INDEX:20,RIGHT_THUMB:22,RIGHT_HIP:24,RIGHT_KNEE:26,RIGHT_ANKLE:28,RIGHT_HEEL:30,RIGHT_FOOT_INDEX:32}),T("POSE_LANDMARKS_NEUTRAL",{NOSE:0}),T("VERSION","0.5.1675469404")}).call(this)},950(e,t,n){"use strict";!function e(){if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__&&"function"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE)try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)}catch(t){console.error(t)}}(),e.exports=n(730)},996(){}},t={};function n(a){var s=t[a];if(void 0!==s)return s.exports;var r=t[a]={id:a,loaded:!1,exports:{}};return e[a].call(r.exports,r,r.exports,n),r.loaded=!0,r.exports}n.amdD=function(){throw new Error("define cannot be used indirect")},n.amdO={},n.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return n.d(t,{a:t}),t},(()=>{var e,t=Object.getPrototypeOf?e=>Object.getPrototypeOf(e):e=>e.__proto__;n.t=function(a,s){if(1&s&&(a=this(a)),8&s)return a;if("object"===typeof a&&a){if(4&s&&a.__esModule)return a;if(16&s&&"function"===typeof a.then)return a}var r=Object.create(null);n.r(r);var i={};e=e||[null,t({}),t([]),t(t)];for(var o=2&s&&a;("object"==typeof o||"function"==typeof o)&&!~e.indexOf(o);o=t(o))Object.getOwnPropertyNames(o).forEach(e=>i[e]=()=>a[e]);return i.default=()=>a,n.d(r,i),r}})(),n.d=(e,t)=>{for(var a in t)n.o(t,a)&&!n.o(e,a)&&Object.defineProperty(e,a,{enumerable:!0,get:t[a]})},n.g=function(){if("object"===typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"===typeof window)return window}}(),n.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),n.r=e=>{"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.nmd=e=>(e.paths=[],e.children||(e.children=[]),e),(()=>{"use strict";var e={};n.r(e),n.d(e,{CompositeArrayBuffer:()=>Hm,browserFiles:()=>By,browserHTTPRequest:()=>Xy,concatenateArrayBuffers:()=>ug,copyModel:()=>Yg,decodeWeights:()=>tg,decodeWeightsStream:()=>ig,encodeWeights:()=>eg,fromMemory:()=>Jy,fromMemorySync:()=>$y,getLoadHandlers:()=>wg,getModelArtifactsForJSON:()=>fg,getModelArtifactsForJSONSync:()=>pg,getModelArtifactsInfoForJSON:()=>mg,getSaveHandlers:()=>vg,getWeightSpecs:()=>gg,http:()=>Ky,isHTTPScheme:()=>Gy,listModels:()=>Kg,loadWeights:()=>Vy,moveModel:()=>Qg,registerLoadRouter:()=>xg,registerSaveRouter:()=>bg,removeModel:()=>Xg,weightsLoaderFactory:()=>Uy,withSaveHandler:()=>eb,withSaveHandlerSync:()=>tb});var t={};n.r(t),n.d(t,{assertParamsValid:()=>hb,computeFlatOffset:()=>Cb,computeOutShape:()=>pb,getNormalizedAxes:()=>yb,isSliceContinous:()=>Sb,maskToAxes:()=>db,parseSliceParams:()=>Ib,sliceInfo:()=>Nb,startForAxis:()=>wb,startIndicesWithElidedDims:()=>bb,stopForAxis:()=>kb,stopIndicesWithElidedDims:()=>xb,stridesForAxis:()=>vb,stridesWithElidedDims:()=>fb});var a={};n.r(a),n.d(a,{conv2d:()=>Bk,depthwiseConv2d:()=>Vk,matMul:()=>Uk});var s={};n.r(s),n.d(s,{collectGatherOpShapeInfo:()=>eI,computeOutShape:()=>$C,segOpComputeOptimalWindowSize:()=>JC});var r={};n.r(r),n.d(r,{ERF_A1:()=>gC,ERF_A2:()=>yC,ERF_A3:()=>bC,ERF_A4:()=>xC,ERF_A5:()=>vC,ERF_P:()=>mC,PARALLELIZE_THRESHOLD:()=>sC,RowPartitionType:()=>$S,SELU_SCALE:()=>fC,SELU_SCALEALPHA:()=>pC,applyActivation:()=>Lk,assertAndGetBroadcastShape:()=>Ry,assertAxesAreInnerMostDims:()=>$x,assertParamsConsistent:()=>ZS,assignToTypedArray:()=>NC,axesAreInnerMostDims:()=>Yx,calculateShapes:()=>pk,checkEinsumDimSizes:()=>OC,checkPadOnDimRoundingMode:()=>ex,combineLocations:()=>Qx,combineRaggedTensorToTensorShapes:()=>eC,complexWithEvenIndex:()=>SC,complexWithOddIndex:()=>CC,computeConv2DInfo:()=>Ub,computeConv3DInfo:()=>Hb,computeDefaultPad:()=>Gb,computeDilation2DInfo:()=>jb,computeOptimalWindowSize:()=>rC,computeOutAndReduceShapes:()=>Zx,computeOutShape:()=>JS,computePool2DInfo:()=>Wb,computePool3DInfo:()=>Vb,convertConv2DDataFormat:()=>$b,decodeEinsumEquation:()=>PC,eitherStridesOrDilationsAreOne:()=>Zb,expandShapeToKeepDim:()=>Jx,exponent:()=>EC,exponents:()=>TC,fromStringArrayToUint8:()=>nI,fromUint8ToStringArray:()=>tI,getAxesPermutation:()=>ev,getBroadcastDims:()=>Ty,getComplexWithIndex:()=>IC,getEinsumComputePath:()=>FC,getEinsumPermutation:()=>DC,getFusedBiasGradient:()=>Fk,getFusedDyActivation:()=>Ok,getImageCenter:()=>iC,getInnerMostAxes:()=>nv,getPermuted:()=>cC,getRaggedRank:()=>nC,getReductionAxes:()=>Ey,getReshaped:()=>oC,getReshapedPermuted:()=>lC,getRowPartitionTypesHelper:()=>tC,getSliceBeginCoords:()=>uC,getSliceSize:()=>hC,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>jC,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>WC,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>VC,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>GC,getSparseReshapeInputOutputMismatchErrorMessage:()=>KC,getSparseReshapeInputOutputMultipleErrorMessage:()=>qC,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>UC,getSparseReshapeNegativeOutputDimErrorMessage:()=>HC,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>ZC,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>XC,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>YC,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>QC,getUndoAxesPermutation:()=>tv,isIdentityPermutation:()=>LC,log:()=>yf,mergeRealAndImagArrays:()=>wC,prepareAndValidate:()=>dC,prepareSplitSize:()=>BC,segment_util:()=>s,shouldFuse:()=>zk,slice_util:()=>t,splitRealAndImagArrays:()=>kC,stridesOrDilationsArePositive:()=>Jb,tupleValuesAreOne:()=>Qb,upcastType:()=>mm,validateDefaultValueShape:()=>aC,validateInput:()=>dk,validateUpdateShape:()=>hk,warn:()=>gf});var i={};n.r(i),n.d(i,{json:()=>TM});var o={};n.r(o),n.d(o,{json:()=>EM});var c={};n.r(c),n.d(c,{json:()=>RM});var l={};n.r(l),n.d(l,{json:()=>_M});var u={};n.r(u),n.d(u,{json:()=>AM});var h={};n.r(h),n.d(h,{json:()=>MM});var d={};n.r(d),n.d(d,{json:()=>PM});var p={};n.r(p),n.d(p,{json:()=>DM});var f={};n.r(f),n.d(f,{json:()=>OM});var m={};n.r(m),n.d(m,{json:()=>FM});var g={};n.r(g),n.d(g,{json:()=>LM});var y={};n.r(y),n.d(y,{json:()=>zM});var b={};n.r(b),n.d(b,{json:()=>BM});var x={};n.r(x),n.d(x,{json:()=>jM});var v={};n.r(v),n.d(v,{json:()=>WM});var w={};n.r(w),n.d(w,{json:()=>VM});var k={};n.r(k),n.d(k,{json:()=>UM});var S={};n.r(S),n.d(S,{json:()=>HM});var C={};n.r(C),n.d(C,{json:()=>GM});var I={};n.r(I),n.d(I,{OP_SCOPE_SUFFIX:()=>zm,abs:()=>Ny,acos:()=>Eb,acosh:()=>Rb,add:()=>ry,addN:()=>_b,all:()=>Ab,any:()=>Mb,argMax:()=>Pb,argMin:()=>Db,asin:()=>Ob,asinh:()=>Fb,atan:()=>Lb,atan2:()=>zb,atanh:()=>Bb,avgPool:()=>nx,avgPool3d:()=>ax,basicLSTMCell:()=>lx,batchNorm:()=>hx,batchNorm2d:()=>dx,batchNorm3d:()=>px,batchNorm4d:()=>fx,batchToSpaceND:()=>ux,bincount:()=>mx,bitwiseAnd:()=>gx,booleanMaskAsync:()=>Ck,broadcastArgs:()=>yx,broadcastTo:()=>bx,buffer:()=>ty,cast:()=>ny,ceil:()=>xx,clipByValue:()=>vx,clone:()=>ay,complex:()=>jm,concat:()=>sx,concat1d:()=>wx,concat2d:()=>kx,concat3d:()=>Sx,concat4d:()=>Cx,conv1d:()=>Nx,conv2d:()=>Ix,conv2dTranspose:()=>Ex,conv3d:()=>Rx,conv3dTranspose:()=>Ax,cos:()=>Mx,cosh:()=>Px,cosineWindow:()=>Mk,cumprod:()=>Dx,cumsum:()=>Ox,denseBincount:()=>Fx,depthToSpace:()=>Lx,depthwiseConv2d:()=>zx,diag:()=>Bx,dilation2d:()=>jx,div:()=>oy,divNoNan:()=>Ux,dot:()=>Hx,dropout:()=>_k,einsum:()=>Gx,elu:()=>qx,enclosingPowerOfTwo:()=>Ak,ensureShape:()=>Kx,equal:()=>Wx,erf:()=>Xx,euclideanNorm:()=>cv,exp:()=>lv,expandDims:()=>uv,expm1:()=>hv,eye:()=>pv,fft:()=>Yw,fill:()=>wy,floor:()=>fv,floorDiv:()=>iy,fused:()=>a,gather:()=>mv,gatherND:()=>Rk,greater:()=>gv,greaterEqual:()=>yv,ifft:()=>Qw,imag:()=>bv,image:()=>US,inTopKAsync:()=>Pk,irfft:()=>Zw,isFinite:()=>xv,isInf:()=>vv,isNaN:()=>wv,leakyRelu:()=>kv,less:()=>Sv,lessEqual:()=>Cv,linalg:()=>HS,linspace:()=>Iv,localResponseNormalization:()=>Nv,log:()=>Tv,log1p:()=>Ev,logSigmoid:()=>Av,logSoftmax:()=>Mv,logSumExp:()=>Pv,logicalAnd:()=>Dv,logicalNot:()=>Ov,logicalOr:()=>Fv,logicalXor:()=>Lv,losses:()=>GS,lowerBound:()=>jv,matMul:()=>rx,max:()=>av,maxPool:()=>Wv,maxPool3d:()=>Vv,maxPoolWithArgmax:()=>Uv,maximum:()=>_y,mean:()=>Hv,meshgrid:()=>Kv,min:()=>sv,minimum:()=>Xv,mirrorPad:()=>Yv,mod:()=>Qv,moments:()=>Zv,movingAverage:()=>Nk,mul:()=>cy,multiRNNCell:()=>Jv,multinomial:()=>$v,neg:()=>Rv,norm:()=>ov,notEqual:()=>ew,oneHot:()=>tw,ones:()=>qv,onesLike:()=>nw,op:()=>Bm,outerProduct:()=>aw,pad:()=>sw,pad1d:()=>rw,pad2d:()=>iw,pad3d:()=>ow,pad4d:()=>cw,pool:()=>uw,pow:()=>Sy,prelu:()=>hw,print:()=>sy,prod:()=>dw,raggedGather:()=>pw,raggedRange:()=>fw,raggedTensorToTensor:()=>mw,rand:()=>gw,randomGamma:()=>ww,randomNormal:()=>kw,randomStandardNormal:()=>Sw,randomUniform:()=>Cw,randomUniformInt:()=>Iw,range:()=>Nw,real:()=>Tw,reciprocal:()=>Ew,relu:()=>Rw,relu6:()=>_w,reshape:()=>tx,reverse:()=>Aw,reverse1d:()=>Mw,reverse2d:()=>Pw,reverse3d:()=>Dw,reverse4d:()=>Ow,rfft:()=>$w,round:()=>Fw,rsqrt:()=>Lw,scalar:()=>py,scatterND:()=>Tk,searchSorted:()=>Bv,selu:()=>zw,separableConv2d:()=>Bw,setdiff1dAsync:()=>jw,sigmoid:()=>ix,sign:()=>Ww,signal:()=>VS,sin:()=>Vw,sinh:()=>Uw,slice:()=>ox,slice1d:()=>Hw,slice2d:()=>Gw,slice3d:()=>qw,slice4d:()=>Kw,softmax:()=>Xw,softplus:()=>_v,spaceToBatchND:()=>lw,sparse:()=>qS,sparseToDense:()=>Ek,spectral:()=>WS,split:()=>Jw,sqrt:()=>ly,square:()=>uy,squaredDifference:()=>ek,squeeze:()=>tk,stack:()=>nk,step:()=>ak,stridedSlice:()=>sk,string:()=>KS,sub:()=>Cy,sum:()=>rv,tan:()=>rk,tanh:()=>cx,tensor:()=>Vm,tensor1d:()=>ik,tensor2d:()=>ok,tensor3d:()=>nb,tensor4d:()=>ck,tensor5d:()=>lk,tensor6d:()=>uk,tensorScatterUpdate:()=>fk,tile:()=>dv,topk:()=>mk,transpose:()=>Ik,truncatedNormal:()=>gk,unique:()=>yk,unsortedSegmentSum:()=>bk,unstack:()=>xk,upperBound:()=>vk,variable:()=>wk,where:()=>Vx,whereAsync:()=>Sk,zeros:()=>Gv,zerosLike:()=>hy});var N={};n.r(N),n.d(N,{mx:()=>qD,XI:()=>zO,Nk:()=>BO,f6:()=>WO,ct:()=>WD,YG:()=>GO,hH:()=>ZO,z3:()=>OF,sG:()=>qF,uM:()=>ZF,C1:()=>yL,vS:()=>fL,qB:()=>kL,GG:()=>CL,lg:()=>RL,rq:()=>NL,cu:()=>VL,WR:()=>BL,GE:()=>GL,px:()=>KL,jC:()=>cz,He:()=>hz,hE:()=>wz,BF:()=>TF,Dk:()=>Az,cl:()=>Bz,_B:()=>Jz,ub:()=>aB,_f:()=>iB,Ku:()=>dB,qy:()=>fB,Zy:()=>NB,bu:()=>RB,zv:()=>MD,dH:()=>tO,HS:()=>DO,yH:()=>YB,l3:()=>ZB,z9:()=>$B,x6:()=>sj,_m:()=>hj,eW:()=>gj,GK:()=>xj,SP:()=>kj,yr:()=>Cj,dl:()=>aL,Dw:()=>_j,xT:()=>Dj,_X:()=>cO,wz:()=>Wj});var T,E=n(43),R=n.t(E,2),_=n(391),A=n(950),M=n.t(A,2);function P(){return P=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},P.apply(this,arguments)}!function(e){e.Pop="POP",e.Push="PUSH",e.Replace="REPLACE"}(T||(T={}));const D="popstate";function O(e,t){if(!1===e||null===e||"undefined"===typeof e)throw new Error(t)}function F(e,t){if(!e){"undefined"!==typeof console&&console.warn(t);try{throw new Error(t)}catch(n){}}}function L(e,t){return{usr:e.state,key:e.key,idx:t}}function z(e,t,n,a){return void 0===n&&(n=null),P({pathname:"string"===typeof e?e:e.pathname,search:"",hash:""},"string"===typeof t?j(t):t,{state:n,key:t&&t.key||a||Math.random().toString(36).substr(2,8)})}function B(e){let{pathname:t="/",search:n="",hash:a=""}=e;return n&&"?"!==n&&(t+="?"===n.charAt(0)?n:"?"+n),a&&"#"!==a&&(t+="#"===a.charAt(0)?a:"#"+a),t}function j(e){let t={};if(e){let n=e.indexOf("#");n>=0&&(t.hash=e.substr(n),e=e.substr(0,n));let a=e.indexOf("?");a>=0&&(t.search=e.substr(a),e=e.substr(0,a)),e&&(t.pathname=e)}return t}function W(e,t,n,a){void 0===a&&(a={});let{window:s=document.defaultView,v5Compat:r=!1}=a,i=s.history,o=T.Pop,c=null,l=u();function u(){return(i.state||{idx:null}).idx}function h(){o=T.Pop;let e=u(),t=null==e?null:e-l;l=e,c&&c({action:o,location:p.location,delta:t})}function d(e){let t="null"!==s.location.origin?s.location.origin:s.location.href,n="string"===typeof e?e:B(e);return n=n.replace(/ $/,"%20"),O(t,"No window.location.(origin|href) available to create URL for href: "+n),new URL(n,t)}null==l&&(l=0,i.replaceState(P({},i.state,{idx:l}),""));let p={get action(){return o},get location(){return e(s,i)},listen(e){if(c)throw new Error("A history only accepts one active listener");return s.addEventListener(D,h),c=e,()=>{s.removeEventListener(D,h),c=null}},createHref:e=>t(s,e),createURL:d,encodeLocation(e){let t=d(e);return{pathname:t.pathname,search:t.search,hash:t.hash}},push:function(e,t){o=T.Push;let a=z(p.location,e,t);n&&n(a,e),l=u()+1;let h=L(a,l),d=p.createHref(a);try{i.pushState(h,"",d)}catch(f){if(f instanceof DOMException&&"DataCloneError"===f.name)throw f;s.location.assign(d)}r&&c&&c({action:o,location:p.location,delta:1})},replace:function(e,t){o=T.Replace;let a=z(p.location,e,t);n&&n(a,e),l=u();let s=L(a,l),h=p.createHref(a);i.replaceState(s,"",h),r&&c&&c({action:o,location:p.location,delta:0})},go:e=>i.go(e)};return p}var V;!function(e){e.data="data",e.deferred="deferred",e.redirect="redirect",e.error="error"}(V||(V={}));new Set(["lazy","caseSensitive","path","id","index","children"]);function U(e,t,n){return void 0===n&&(n="/"),H(e,t,n,!1)}function H(e,t,n,a){let s=se(("string"===typeof t?j(t):t).pathname||"/",n);if(null==s)return null;let r=G(e);!function(e){e.sort((e,t)=>e.score!==t.score?t.score-e.score:function(e,t){let n=e.length===t.length&&e.slice(0,-1).every((e,n)=>e===t[n]);return n?e[e.length-1]-t[t.length-1]:0}(e.routesMeta.map(e=>e.childrenIndex),t.routesMeta.map(e=>e.childrenIndex)))}(r);let i=null;for(let o=0;null==i&&o<r.length;++o){let e=ae(s);i=te(r[o],e,a)}return i}function G(e,t,n,a){void 0===t&&(t=[]),void 0===n&&(n=[]),void 0===a&&(a="");let s=(e,s,r)=>{let i={relativePath:void 0===r?e.path||"":r,caseSensitive:!0===e.caseSensitive,childrenIndex:s,route:e};i.relativePath.startsWith("/")&&(O(i.relativePath.startsWith(a),'Absolute route path "'+i.relativePath+'" nested under path "'+a+'" is not valid. An absolute child route path must start with the combined path of all its parent routes.'),i.relativePath=i.relativePath.slice(a.length));let o=de([a,i.relativePath]),c=n.concat(i);e.children&&e.children.length>0&&(O(!0!==e.index,'Index routes must not have child routes. Please remove all child routes from route path "'+o+'".'),G(e.children,t,c,o)),(null!=e.path||e.index)&&t.push({path:o,score:ee(o,e.index),routesMeta:c})};return e.forEach((e,t)=>{var n;if(""!==e.path&&null!=(n=e.path)&&n.includes("?"))for(let a of q(e.path))s(e,t,a);else s(e,t)}),t}function q(e){let t=e.split("/");if(0===t.length)return[];let[n,...a]=t,s=n.endsWith("?"),r=n.replace(/\?$/,"");if(0===a.length)return s?[r,""]:[r];let i=q(a.join("/")),o=[];return o.push(...i.map(e=>""===e?r:[r,e].join("/"))),s&&o.push(...i),o.map(t=>e.startsWith("/")&&""===t?"/":t)}const K=/^:[\w-]+$/,X=3,Y=2,Q=1,Z=10,J=-2,$=e=>"*"===e;function ee(e,t){let n=e.split("/"),a=n.length;return n.some($)&&(a+=J),t&&(a+=Y),n.filter(e=>!$(e)).reduce((e,t)=>e+(K.test(t)?X:""===t?Q:Z),a)}function te(e,t,n){void 0===n&&(n=!1);let{routesMeta:a}=e,s={},r="/",i=[];for(let o=0;o<a.length;++o){let e=a[o],c=o===a.length-1,l="/"===r?t:t.slice(r.length)||"/",u=ne({path:e.relativePath,caseSensitive:e.caseSensitive,end:c},l),h=e.route;if(!u&&c&&n&&!a[a.length-1].route.index&&(u=ne({path:e.relativePath,caseSensitive:e.caseSensitive,end:!1},l)),!u)return null;Object.assign(s,u.params),i.push({params:s,pathname:de([r,u.pathname]),pathnameBase:pe(de([r,u.pathnameBase])),route:h}),"/"!==u.pathnameBase&&(r=de([r,u.pathnameBase]))}return i}function ne(e,t){"string"===typeof e&&(e={path:e,caseSensitive:!1,end:!0});let[n,a]=function(e,t,n){void 0===t&&(t=!1);void 0===n&&(n=!0);F("*"===e||!e.endsWith("*")||e.endsWith("/*"),'Route path "'+e+'" will be treated as if it were "'+e.replace(/\*$/,"/*")+'" because the `*` character must always follow a `/` in the pattern. To get rid of this warning, please change the route path to "'+e.replace(/\*$/,"/*")+'".');let a=[],s="^"+e.replace(/\/*\*?$/,"").replace(/^\/*/,"/").replace(/[\\.*+^${}|()[\]]/g,"\\$&").replace(/\/:([\w-]+)(\?)?/g,(e,t,n)=>(a.push({paramName:t,isOptional:null!=n}),n?"/?([^\\/]+)?":"/([^\\/]+)"));e.endsWith("*")?(a.push({paramName:"*"}),s+="*"===e||"/*"===e?"(.*)$":"(?:\\/(.+)|\\/*)$"):n?s+="\\/*$":""!==e&&"/"!==e&&(s+="(?:(?=\\/|$))");let r=new RegExp(s,t?void 0:"i");return[r,a]}(e.path,e.caseSensitive,e.end),s=t.match(n);if(!s)return null;let r=s[0],i=r.replace(/(.)\/+$/,"$1"),o=s.slice(1),c=a.reduce((e,t,n)=>{let{paramName:a,isOptional:s}=t;if("*"===a){let e=o[n]||"";i=r.slice(0,r.length-e.length).replace(/(.)\/+$/,"$1")}const c=o[n];return e[a]=s&&!c?void 0:(c||"").replace(/%2F/g,"/"),e},{});return{params:c,pathname:r,pathnameBase:i,pattern:e}}function ae(e){try{return e.split("/").map(e=>decodeURIComponent(e).replace(/\//g,"%2F")).join("/")}catch(t){return F(!1,'The URL path "'+e+'" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent encoding ('+t+")."),e}}function se(e,t){if("/"===t)return e;if(!e.toLowerCase().startsWith(t.toLowerCase()))return null;let n=t.endsWith("/")?t.length-1:t.length,a=e.charAt(n);return a&&"/"!==a?null:e.slice(n)||"/"}const re=/^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;function ie(e,t){void 0===t&&(t="/");let n,{pathname:a,search:s="",hash:r=""}="string"===typeof e?j(e):e;if(a)if(i=a,re.test(i))n=a;else{if(a.includes("//")){let e=a;a=a.replace(/\/\/+/g,"/"),F(!1,"Pathnames cannot have embedded double slashes - normalizing "+e+" -> "+a)}n=a.startsWith("/")?oe(a.substring(1),"/"):oe(a,t)}else n=t;var i;return{pathname:n,search:fe(s),hash:me(r)}}function oe(e,t){let n=t.replace(/\/+$/,"").split("/");return e.split("/").forEach(e=>{".."===e?n.length>1&&n.pop():"."!==e&&n.push(e)}),n.length>1?n.join("/"):"/"}function ce(e,t,n,a){return"Cannot include a '"+e+"' character in a manually specified `to."+t+"` field ["+JSON.stringify(a)+"].  Please separate it out to the `to."+n+'` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.'}function le(e){return e.filter((e,t)=>0===t||e.route.path&&e.route.path.length>0)}function ue(e,t){let n=le(e);return t?n.map((e,t)=>t===n.length-1?e.pathname:e.pathnameBase):n.map(e=>e.pathnameBase)}function he(e,t,n,a){let s;void 0===a&&(a=!1),"string"===typeof e?s=j(e):(s=P({},e),O(!s.pathname||!s.pathname.includes("?"),ce("?","pathname","search",s)),O(!s.pathname||!s.pathname.includes("#"),ce("#","pathname","hash",s)),O(!s.search||!s.search.includes("#"),ce("#","search","hash",s)));let r,i=""===e||""===s.pathname,o=i?"/":s.pathname;if(null==o)r=n;else{let e=t.length-1;if(!a&&o.startsWith("..")){let t=o.split("/");for(;".."===t[0];)t.shift(),e-=1;s.pathname=t.join("/")}r=e>=0?t[e]:"/"}let c=ie(s,r),l=o&&"/"!==o&&o.endsWith("/"),u=(i||"."===o)&&n.endsWith("/");return c.pathname.endsWith("/")||!l&&!u||(c.pathname+="/"),c}const de=e=>e.join("/").replace(/\/\/+/g,"/"),pe=e=>e.replace(/\/+$/,"").replace(/^\/*/,"/"),fe=e=>e&&"?"!==e?e.startsWith("?")?e:"?"+e:"",me=e=>e&&"#"!==e?e.startsWith("#")?e:"#"+e:"";Error;function ge(e){return null!=e&&"number"===typeof e.status&&"string"===typeof e.statusText&&"boolean"===typeof e.internal&&"data"in e}const ye=["post","put","patch","delete"],be=(new Set(ye),["get",...ye]);new Set(be),new Set([301,302,303,307,308]),new Set([307,308]);Symbol("deferred");function xe(){return xe=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},xe.apply(this,arguments)}const ve=E.createContext(null);const we=E.createContext(null);const ke=E.createContext(null);const Se=E.createContext(null);const Ce=E.createContext({outlet:null,matches:[],isDataRoute:!1});const Ie=E.createContext(null);function Ne(){return null!=E.useContext(Se)}function Te(){return Ne()||O(!1),E.useContext(Se).location}function Ee(e){E.useContext(ke).static||E.useLayoutEffect(e)}function Re(){let{isDataRoute:e}=E.useContext(Ce);return e?function(){let{router:e}=Be(Le.UseNavigateStable),t=We(ze.UseNavigateStable),n=E.useRef(!1);Ee(()=>{n.current=!0});let a=E.useCallback(function(a,s){void 0===s&&(s={}),n.current&&("number"===typeof a?e.navigate(a):e.navigate(a,xe({fromRouteId:t},s)))},[e,t]);return a}():function(){Ne()||O(!1);let e=E.useContext(ve),{basename:t,future:n,navigator:a}=E.useContext(ke),{matches:s}=E.useContext(Ce),{pathname:r}=Te(),i=JSON.stringify(ue(s,n.v7_relativeSplatPath)),o=E.useRef(!1);Ee(()=>{o.current=!0});let c=E.useCallback(function(n,s){if(void 0===s&&(s={}),!o.current)return;if("number"===typeof n)return void a.go(n);let c=he(n,JSON.parse(i),r,"path"===s.relative);null==e&&"/"!==t&&(c.pathname="/"===c.pathname?t:de([t,c.pathname])),(s.replace?a.replace:a.push)(c,s.state,s)},[t,a,i,r,e]);return c}()}function _e(e,t){let{relative:n}=void 0===t?{}:t,{future:a}=E.useContext(ke),{matches:s}=E.useContext(Ce),{pathname:r}=Te(),i=JSON.stringify(ue(s,a.v7_relativeSplatPath));return E.useMemo(()=>he(e,JSON.parse(i),r,"path"===n),[e,i,r,n])}function Ae(e,t,n,a){Ne()||O(!1);let{navigator:s}=E.useContext(ke),{matches:r}=E.useContext(Ce),i=r[r.length-1],o=i?i.params:{},c=(i&&i.pathname,i?i.pathnameBase:"/");i&&i.route;let l,u=Te();if(t){var h;let e="string"===typeof t?j(t):t;"/"===c||(null==(h=e.pathname)?void 0:h.startsWith(c))||O(!1),l=e}else l=u;let d=l.pathname||"/",p=d;if("/"!==c){let e=c.replace(/^\//,"").split("/");p="/"+d.replace(/^\//,"").split("/").slice(e.length).join("/")}let f=U(e,{pathname:p});let m=Fe(f&&f.map(e=>Object.assign({},e,{params:Object.assign({},o,e.params),pathname:de([c,s.encodeLocation?s.encodeLocation(e.pathname).pathname:e.pathname]),pathnameBase:"/"===e.pathnameBase?c:de([c,s.encodeLocation?s.encodeLocation(e.pathnameBase).pathname:e.pathnameBase])})),r,n,a);return t&&m?E.createElement(Se.Provider,{value:{location:xe({pathname:"/",search:"",hash:"",state:null,key:"default"},l),navigationType:T.Pop}},m):m}function Me(){let e=function(){var e;let t=E.useContext(Ie),n=je(ze.UseRouteError),a=We(ze.UseRouteError);if(void 0!==t)return t;return null==(e=n.errors)?void 0:e[a]}(),t=ge(e)?e.status+" "+e.statusText:e instanceof Error?e.message:JSON.stringify(e),n=e instanceof Error?e.stack:null,a="rgba(200,200,200, 0.5)",s={padding:"0.5rem",backgroundColor:a};return E.createElement(E.Fragment,null,E.createElement("h2",null,"Unexpected Application Error!"),E.createElement("h3",{style:{fontStyle:"italic"}},t),n?E.createElement("pre",{style:s},n):null,null)}const Pe=E.createElement(Me,null);class De extends E.Component{constructor(e){super(e),this.state={location:e.location,revalidation:e.revalidation,error:e.error}}static getDerivedStateFromError(e){return{error:e}}static getDerivedStateFromProps(e,t){return t.location!==e.location||"idle"!==t.revalidation&&"idle"===e.revalidation?{error:e.error,location:e.location,revalidation:e.revalidation}:{error:void 0!==e.error?e.error:t.error,location:t.location,revalidation:e.revalidation||t.revalidation}}componentDidCatch(e,t){console.error("React Router caught the following error during render",e,t)}render(){return void 0!==this.state.error?E.createElement(Ce.Provider,{value:this.props.routeContext},E.createElement(Ie.Provider,{value:this.state.error,children:this.props.component})):this.props.children}}function Oe(e){let{routeContext:t,match:n,children:a}=e,s=E.useContext(ve);return s&&s.static&&s.staticContext&&(n.route.errorElement||n.route.ErrorBoundary)&&(s.staticContext._deepestRenderedBoundaryId=n.route.id),E.createElement(Ce.Provider,{value:t},a)}function Fe(e,t,n,a){var s;if(void 0===t&&(t=[]),void 0===n&&(n=null),void 0===a&&(a=null),null==e){var r;if(!n)return null;if(n.errors)e=n.matches;else{if(!(null!=(r=a)&&r.v7_partialHydration&&0===t.length&&!n.initialized&&n.matches.length>0))return null;e=n.matches}}let i=e,o=null==(s=n)?void 0:s.errors;if(null!=o){let e=i.findIndex(e=>e.route.id&&void 0!==(null==o?void 0:o[e.route.id]));e>=0||O(!1),i=i.slice(0,Math.min(i.length,e+1))}let c=!1,l=-1;if(n&&a&&a.v7_partialHydration)for(let u=0;u<i.length;u++){let e=i[u];if((e.route.HydrateFallback||e.route.hydrateFallbackElement)&&(l=u),e.route.id){let{loaderData:t,errors:a}=n,s=e.route.loader&&void 0===t[e.route.id]&&(!a||void 0===a[e.route.id]);if(e.route.lazy||s){c=!0,i=l>=0?i.slice(0,l+1):[i[0]];break}}}return i.reduceRight((e,a,s)=>{let r,u=!1,h=null,d=null;var p;n&&(r=o&&a.route.id?o[a.route.id]:void 0,h=a.route.errorElement||Pe,c&&(l<0&&0===s?(p="route-fallback",!1||Ve[p]||(Ve[p]=!0),u=!0,d=null):l===s&&(u=!0,d=a.route.hydrateFallbackElement||null)));let f=t.concat(i.slice(0,s+1)),m=()=>{let t;return t=r?h:u?d:a.route.Component?E.createElement(a.route.Component,null):a.route.element?a.route.element:e,E.createElement(Oe,{match:a,routeContext:{outlet:e,matches:f,isDataRoute:null!=n},children:t})};return n&&(a.route.ErrorBoundary||a.route.errorElement||0===s)?E.createElement(De,{location:n.location,revalidation:n.revalidation,component:h,error:r,children:m(),routeContext:{outlet:null,matches:f,isDataRoute:!0}}):m()},null)}var Le=function(e){return e.UseBlocker="useBlocker",e.UseRevalidator="useRevalidator",e.UseNavigateStable="useNavigate",e}(Le||{}),ze=function(e){return e.UseBlocker="useBlocker",e.UseLoaderData="useLoaderData",e.UseActionData="useActionData",e.UseRouteError="useRouteError",e.UseNavigation="useNavigation",e.UseRouteLoaderData="useRouteLoaderData",e.UseMatches="useMatches",e.UseRevalidator="useRevalidator",e.UseNavigateStable="useNavigate",e.UseRouteId="useRouteId",e}(ze||{});function Be(e){let t=E.useContext(ve);return t||O(!1),t}function je(e){let t=E.useContext(we);return t||O(!1),t}function We(e){let t=function(){let e=E.useContext(Ce);return e||O(!1),e}(),n=t.matches[t.matches.length-1];return n.route.id||O(!1),n.route.id}const Ve={};function Ue(e,t){null==e||e.v7_startTransition,void 0===(null==e?void 0:e.v7_relativeSplatPath)&&(!t||t.v7_relativeSplatPath),t&&(t.v7_fetcherPersist,t.v7_normalizeFormMethod,t.v7_partialHydration,t.v7_skipActionErrorRevalidation)}R.startTransition;function He(e){O(!1)}function Ge(e){let{basename:t="/",children:n=null,location:a,navigationType:s=T.Pop,navigator:r,static:i=!1,future:o}=e;Ne()&&O(!1);let c=t.replace(/^\/*/,"/"),l=E.useMemo(()=>({basename:c,navigator:r,static:i,future:xe({v7_relativeSplatPath:!1},o)}),[c,o,r,i]);"string"===typeof a&&(a=j(a));let{pathname:u="/",search:h="",hash:d="",state:p=null,key:f="default"}=a,m=E.useMemo(()=>{let e=se(u,c);return null==e?null:{location:{pathname:e,search:h,hash:d,state:p,key:f},navigationType:s}},[c,u,h,d,p,f,s]);return null==m?null:E.createElement(ke.Provider,{value:l},E.createElement(Se.Provider,{children:n,value:m}))}function qe(e){let{children:t,location:n}=e;return Ae(Ke(t),n)}new Promise(()=>{});E.Component;function Ke(e,t){void 0===t&&(t=[]);let n=[];return E.Children.forEach(e,(e,a)=>{if(!E.isValidElement(e))return;let s=[...t,a];if(e.type===E.Fragment)return void n.push.apply(n,Ke(e.props.children,s));e.type!==He&&O(!1),e.props.index&&e.props.children&&O(!1);let r={id:e.props.id||s.join("-"),caseSensitive:e.props.caseSensitive,element:e.props.element,Component:e.props.Component,index:e.props.index,path:e.props.path,loader:e.props.loader,action:e.props.action,errorElement:e.props.errorElement,ErrorBoundary:e.props.ErrorBoundary,hasErrorBoundary:null!=e.props.ErrorBoundary||null!=e.props.errorElement,shouldRevalidate:e.props.shouldRevalidate,handle:e.props.handle,lazy:e.props.lazy};e.props.children&&(r.children=Ke(e.props.children,s)),n.push(r)}),n}function Xe(){return Xe=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},Xe.apply(this,arguments)}function Ye(e,t){if(null==e)return{};var n,a,s={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(s[n]=e[n]);return s}new Set(["application/x-www-form-urlencoded","multipart/form-data","text/plain"]);const Qe=["onClick","relative","reloadDocument","replace","state","target","to","preventScrollReset","viewTransition"];try{window.__reactRouterVersion="6"}catch(G5){}new Map;const Ze=R.startTransition;M.flushSync,R.useId;function Je(e){let{basename:t,children:n,future:a,window:s}=e,r=E.useRef();var i;null==r.current&&(r.current=(void 0===(i={window:s,v5Compat:!0})&&(i={}),W(function(e,t){let{pathname:n,search:a,hash:s}=e.location;return z("",{pathname:n,search:a,hash:s},t.state&&t.state.usr||null,t.state&&t.state.key||"default")},function(e,t){return"string"===typeof t?t:B(t)},null,i)));let o=r.current,[c,l]=E.useState({action:o.action,location:o.location}),{v7_startTransition:u}=a||{},h=E.useCallback(e=>{u&&Ze?Ze(()=>l(e)):l(e)},[l,u]);return E.useLayoutEffect(()=>o.listen(h),[o,h]),E.useEffect(()=>Ue(a),[a]),E.createElement(Ge,{basename:t,children:n,location:c.location,navigationType:c.action,navigator:o,future:a})}const $e="undefined"!==typeof window&&"undefined"!==typeof window.document&&"undefined"!==typeof window.document.createElement,et=/^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,tt=E.forwardRef(function(e,t){let n,{onClick:a,relative:s,reloadDocument:r,replace:i,state:o,target:c,to:l,preventScrollReset:u,viewTransition:h}=e,d=Ye(e,Qe),{basename:p}=E.useContext(ke),f=!1;if("string"===typeof l&&et.test(l)&&(n=l,$e))try{let e=new URL(window.location.href),t=l.startsWith("//")?new URL(e.protocol+l):new URL(l),n=se(t.pathname,p);t.origin===e.origin&&null!=n?l=n+t.search+t.hash:f=!0}catch(G5){}let m=function(e,t){let{relative:n}=void 0===t?{}:t;Ne()||O(!1);let{basename:a,navigator:s}=E.useContext(ke),{hash:r,pathname:i,search:o}=_e(e,{relative:n}),c=i;return"/"!==a&&(c="/"===i?a:de([a,i])),s.createHref({pathname:c,search:o,hash:r})}(l,{relative:s}),g=function(e,t){let{target:n,replace:a,state:s,preventScrollReset:r,relative:i,viewTransition:o}=void 0===t?{}:t,c=Re(),l=Te(),u=_e(e,{relative:i});return E.useCallback(t=>{if(function(e,t){return 0===e.button&&(!t||"_self"===t)&&!function(e){return!!(e.metaKey||e.altKey||e.ctrlKey||e.shiftKey)}(e)}(t,n)){t.preventDefault();let n=void 0!==a?a:B(l)===B(u);c(e,{replace:n,state:s,preventScrollReset:r,relative:i,viewTransition:o})}},[l,c,u,a,s,n,e,r,i,o])}(l,{replace:i,state:o,target:c,preventScrollReset:u,relative:s,viewTransition:h});return E.createElement("a",Xe({},d,{href:n||m,onClick:f||r?a:function(e){a&&a(e),e.defaultPrevented||g(e)},ref:t,target:c}))});var nt,at;(function(e){e.UseScrollRestoration="useScrollRestoration",e.UseSubmit="useSubmit",e.UseSubmitFetcher="useSubmitFetcher",e.UseFetcher="useFetcher",e.useViewTransitionState="useViewTransitionState"})(nt||(nt={})),function(e){e.UseFetcher="useFetcher",e.UseFetchers="useFetchers",e.UseScrollRestoration="useScrollRestoration"}(at||(at={}));var st={color:void 0,size:void 0,className:void 0,style:void 0,attr:void 0},rt=E.createContext&&E.createContext(st),it=function(){return it=Object.assign||function(e){for(var t,n=1,a=arguments.length;n<a;n++)for(var s in t=arguments[n])Object.prototype.hasOwnProperty.call(t,s)&&(e[s]=t[s]);return e},it.apply(this,arguments)},ot=function(e,t){var n={};for(var a in e)Object.prototype.hasOwnProperty.call(e,a)&&t.indexOf(a)<0&&(n[a]=e[a]);if(null!=e&&"function"===typeof Object.getOwnPropertySymbols){var s=0;for(a=Object.getOwnPropertySymbols(e);s<a.length;s++)t.indexOf(a[s])<0&&Object.prototype.propertyIsEnumerable.call(e,a[s])&&(n[a[s]]=e[a[s]])}return n};function ct(e){return e&&e.map(function(e,t){return E.createElement(e.tag,it({key:t},e.attr),ct(e.child))})}function lt(e){return function(t){return E.createElement(ut,it({attr:it({},e.attr)},t),ct(e.child))}}function ut(e){var t=function(t){var n,a=e.attr,s=e.size,r=e.title,i=ot(e,["attr","size","title"]),o=s||t.size||"1em";return t.className&&(n=t.className),e.className&&(n=(n?n+" ":"")+e.className),E.createElement("svg",it({stroke:"currentColor",fill:"currentColor",strokeWidth:"0"},t.attr,a,i,{className:n,style:it(it({color:e.color||t.color},t.style),e.style),height:o,width:o,xmlns:"http://www.w3.org/2000/svg"}),r&&E.createElement("title",null,r),e.children)};return void 0!==rt?E.createElement(rt.Consumer,null,function(e){return t(e)}):t(st)}function ht(e){return lt({tag:"svg",attr:{viewBox:"0 0 384 512"},child:[{tag:"path",attr:{d:"M0 32l34.9 395.8L192 480l157.1-52.2L384 32H0zm313.1 80l-4.8 47.3L193 208.6l-.3.1h111.5l-12.8 146.6-98.2 28.7-98.8-29.2-6.4-73.9h48.9l3.2 38.3 52.6 13.3 54.7-15.4 3.7-61.6-166.3-.5v-.1l-.2.1-3.6-46.3L193.1 162l6.5-2.7H76.7L70.9 112h242.2z"}}]})(e)}function dt(e){return lt({tag:"svg",attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{d:"M504 256C504 119 393 8 256 8S8 119 8 256c0 123.78 90.69 226.38 209.25 245V327.69h-63V256h63v-54.64c0-62.15 37-96.48 93.67-96.48 27.14 0 55.52 4.84 55.52 4.84v61h-31.28c-30.8 0-40.41 19.12-40.41 38.73V256h68.78l-11 71.69h-57.78V501C413.31 482.38 504 379.78 504 256z"}}]})(e)}function pt(e){return lt({tag:"svg",attr:{viewBox:"0 0 496 512"},child:[{tag:"path",attr:{d:"M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"}}]})(e)}function ft(e){return lt({tag:"svg",attr:{viewBox:"0 0 488 512"},child:[{tag:"path",attr:{d:"M488 261.8C488 403.3 391.1 504 248 504 110.8 504 0 393.2 0 256S110.8 8 248 8c66.8 0 123 24.5 166.3 64.9l-67.5 64.9C258.5 52.6 94.3 116.6 94.3 256c0 86.5 69.1 156.6 153.7 156.6 98.2 0 135-70.4 140.8-106.9H248v-85.3h236.1c2.3 12.7 3.9 24.9 3.9 41.4z"}}]})(e)}function mt(e){return lt({tag:"svg",attr:{viewBox:"0 0 384 512"},child:[{tag:"path",attr:{d:"M0 32l34.9 395.8L191.5 480l157.6-52.2L384 32H0zm308.2 127.9H124.4l4.1 49.4h175.6l-13.6 148.4-97.9 27v.3h-1.1l-98.7-27.3-6-75.8h47.7L138 320l53.5 14.5 53.7-14.5 6-62.2H84.3L71.5 112.2h241.1l-4.4 47.7z"}}]})(e)}function gt(e){return lt({tag:"svg",attr:{viewBox:"0 0 448 512"},child:[{tag:"path",attr:{d:"M224.1 141c-63.6 0-114.9 51.3-114.9 114.9s51.3 114.9 114.9 114.9S339 319.5 339 255.9 287.7 141 224.1 141zm0 189.6c-41.1 0-74.7-33.5-74.7-74.7s33.5-74.7 74.7-74.7 74.7 33.5 74.7 74.7-33.6 74.7-74.7 74.7zm146.4-194.3c0 14.9-12 26.8-26.8 26.8-14.9 0-26.8-12-26.8-26.8s12-26.8 26.8-26.8 26.8 12 26.8 26.8zm76.1 27.2c-1.7-35.9-9.9-67.7-36.2-93.9-26.2-26.2-58-34.4-93.9-36.2-37-2.1-147.9-2.1-184.9 0-35.8 1.7-67.6 9.9-93.9 36.1s-34.4 58-36.2 93.9c-2.1 37-2.1 147.9 0 184.9 1.7 35.9 9.9 67.7 36.2 93.9s58 34.4 93.9 36.2c37 2.1 147.9 2.1 184.9 0 35.9-1.7 67.7-9.9 93.9-36.2 26.2-26.2 34.4-58 36.2-93.9 2.1-37 2.1-147.8 0-184.8zM398.8 388c-7.8 19.6-22.9 34.7-42.6 42.6-29.5 11.7-99.5 9-132.1 9s-102.7 2.6-132.1-9c-19.6-7.8-34.7-22.9-42.6-42.6-11.7-29.5-9-99.5-9-132.1s-2.6-102.7 9-132.1c7.8-19.6 22.9-34.7 42.6-42.6 29.5-11.7 99.5-9 132.1-9s102.7-2.6 132.1 9c19.6 7.8 34.7 22.9 42.6 42.6 11.7 29.5 9 99.5 9 132.1s2.7 102.7-9 132.1z"}}]})(e)}function yt(e){return lt({tag:"svg",attr:{viewBox:"0 0 448 512"},child:[{tag:"path",attr:{d:"M0 32v448h448V32H0zm243.8 349.4c0 43.6-25.6 63.5-62.9 63.5-33.7 0-53.2-17.4-63.2-38.5l34.3-20.7c6.6 11.7 12.6 21.6 27.1 21.6 13.8 0 22.6-5.4 22.6-26.5V237.7h42.1v143.7zm99.6 63.5c-39.1 0-64.4-18.6-76.7-43l34.3-19.8c9 14.7 20.8 25.6 41.5 25.6 17.4 0 28.6-8.7 28.6-20.8 0-14.4-11.4-19.5-30.7-28l-10.5-4.5c-30.4-12.9-50.5-29.2-50.5-63.5 0-31.6 24.1-55.6 61.6-55.6 26.8 0 46 9.3 59.8 33.7L368 290c-7.2-12.9-15-18-27.1-18-12.3 0-20.1 7.8-20.1 18 0 12.6 7.8 17.7 25.9 25.6l10.5 4.5c35.8 15.3 55.9 31 55.9 66.2 0 37.8-29.8 58.6-69.7 58.6z"}}]})(e)}function bt(e){return lt({tag:"svg",attr:{viewBox:"0 0 448 512"},child:[{tag:"path",attr:{d:"M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"}}]})(e)}function xt(e){return lt({tag:"svg",attr:{viewBox:"0 0 448 512"},child:[{tag:"path",attr:{d:"M224 508c-6.7 0-13.5-1.8-19.4-5.2l-61.7-36.5c-9.2-5.2-4.7-7-1.7-8 12.3-4.3 14.8-5.2 27.9-12.7 1.4-.8 3.2-.5 4.6.4l47.4 28.1c1.7 1 4.1 1 5.7 0l184.7-106.6c1.7-1 2.8-3 2.8-5V149.3c0-2.1-1.1-4-2.9-5.1L226.8 37.7c-1.7-1-4-1-5.7 0L36.6 144.3c-1.8 1-2.9 3-2.9 5.1v213.1c0 2 1.1 4 2.9 4.9l50.6 29.2c27.5 13.7 44.3-2.4 44.3-18.7V167.5c0-3 2.4-5.3 5.4-5.3h23.4c2.9 0 5.4 2.3 5.4 5.3V378c0 36.6-20 57.6-54.7 57.6-10.7 0-19.1 0-42.5-11.6l-48.4-27.9C8.1 389.2.7 376.3.7 362.4V149.3c0-13.8 7.4-26.8 19.4-33.7L204.6 9c11.7-6.6 27.2-6.6 38.8 0l184.7 106.7c12 6.9 19.4 19.8 19.4 33.7v213.1c0 13.8-7.4 26.7-19.4 33.7L243.4 502.8c-5.9 3.4-12.6 5.2-19.4 5.2zm149.1-210.1c0-39.9-27-50.5-83.7-58-57.4-7.6-63.2-11.5-63.2-24.9 0-11.1 4.9-25.9 47.4-25.9 37.9 0 51.9 8.2 57.7 33.8.5 2.4 2.7 4.2 5.2 4.2h24c1.5 0 2.9-.6 3.9-1.7s1.5-2.6 1.4-4.1c-3.7-44.1-33-64.6-92.2-64.6-52.7 0-84.1 22.2-84.1 59.5 0 40.4 31.3 51.6 81.8 56.6 60.5 5.9 65.2 14.8 65.2 26.7 0 20.6-16.6 29.4-55.5 29.4-48.9 0-59.6-12.3-63.2-36.6-.4-2.6-2.6-4.5-5.3-4.5h-23.9c-3 0-5.3 2.4-5.3 5.3 0 31.1 16.9 68.2 97.8 68.2 58.4-.1 92-23.2 92-63.4z"}}]})(e)}function vt(e){return lt({tag:"svg",attr:{viewBox:"0 0 448 512"},child:[{tag:"path",attr:{d:"M439.8 200.5c-7.7-30.9-22.3-54.2-53.4-54.2h-40.1v47.4c0 36.8-31.2 67.8-66.8 67.8H172.7c-29.2 0-53.4 25-53.4 54.3v101.8c0 29 25.2 46 53.4 54.3 33.8 9.9 66.3 11.7 106.8 0 26.9-7.8 53.4-23.5 53.4-54.3v-40.7H226.2v-13.6h160.2c31.1 0 42.6-21.7 53.4-54.2 11.2-33.5 10.7-65.7 0-108.6zM286.2 404c11.1 0 20.1 9.1 20.1 20.3 0 11.3-9 20.4-20.1 20.4-11 0-20.1-9.2-20.1-20.4.1-11.3 9.1-20.3 20.1-20.3zM167.8 248.1h106.8c29.7 0 53.4-24.5 53.4-54.3V91.9c0-29-24.4-50.7-53.4-55.6-35.8-5.9-74.7-5.6-106.8.1-45.2 8-53.4 24.7-53.4 55.6v40.7h106.9v13.6h-147c-31.1 0-58.3 18.7-66.8 54.2-9.8 40.7-10.2 66.1 0 108.6 7.6 31.6 25.7 54.2 56.8 54.2H101v-48.8c0-35.3 30.5-66.4 66.8-66.4zm-6.7-142.6c-11.1 0-20.1-9.1-20.1-20.3.1-11.3 9-20.4 20.1-20.4 11 0 20.1 9.2 20.1 20.4s-9 20.3-20.1 20.3z"}}]})(e)}function wt(e){return lt({tag:"svg",attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{d:"M418.2 177.2c-5.4-1.8-10.8-3.5-16.2-5.1.9-3.7 1.7-7.4 2.5-11.1 12.3-59.6 4.2-107.5-23.1-123.3-26.3-15.1-69.2.6-112.6 38.4-4.3 3.7-8.5 7.6-12.5 11.5-2.7-2.6-5.5-5.2-8.3-7.7-45.5-40.4-91.1-57.4-118.4-41.5-26.2 15.2-34 60.3-23 116.7 1.1 5.6 2.3 11.1 3.7 16.7-6.4 1.8-12.7 3.8-18.6 5.9C38.3 196.2 0 225.4 0 255.6c0 31.2 40.8 62.5 96.3 81.5 4.5 1.5 9 3 13.6 4.3-1.5 6-2.8 11.9-4 18-10.5 55.5-2.3 99.5 23.9 114.6 27 15.6 72.4-.4 116.6-39.1 3.5-3.1 7-6.3 10.5-9.7 4.4 4.3 9 8.4 13.6 12.4 42.8 36.8 85.1 51.7 111.2 36.6 27-15.6 35.8-62.9 24.4-120.5-.9-4.4-1.9-8.9-3-13.5 3.2-.9 6.3-1.9 9.4-2.9 57.7-19.1 99.5-50 99.5-81.7 0-30.3-39.4-59.7-93.8-78.4zM282.9 92.3c37.2-32.4 71.9-45.1 87.7-36 16.9 9.7 23.4 48.9 12.8 100.4-.7 3.4-1.4 6.7-2.3 10-22.2-5-44.7-8.6-67.3-10.6-13-18.6-27.2-36.4-42.6-53.1 3.9-3.7 7.7-7.2 11.7-10.7zM167.2 307.5c5.1 8.7 10.3 17.4 15.8 25.9-15.6-1.7-31.1-4.2-46.4-7.5 4.4-14.4 9.9-29.3 16.3-44.5 4.6 8.8 9.3 17.5 14.3 26.1zm-30.3-120.3c14.4-3.2 29.7-5.8 45.6-7.8-5.3 8.3-10.5 16.8-15.4 25.4-4.9 8.5-9.7 17.2-14.2 26-6.3-14.9-11.6-29.5-16-43.6zm27.4 68.9c6.6-13.8 13.8-27.3 21.4-40.6s15.8-26.2 24.4-38.9c15-1.1 30.3-1.7 45.9-1.7s31 .6 45.9 1.7c8.5 12.6 16.6 25.5 24.3 38.7s14.9 26.7 21.7 40.4c-6.7 13.8-13.9 27.4-21.6 40.8-7.6 13.3-15.7 26.2-24.2 39-14.9 1.1-30.4 1.6-46.1 1.6s-30.9-.5-45.6-1.4c-8.7-12.7-16.9-25.7-24.6-39s-14.8-26.8-21.5-40.6zm180.6 51.2c5.1-8.8 9.9-17.7 14.6-26.7 6.4 14.5 12 29.2 16.9 44.3-15.5 3.5-31.2 6.2-47 8 5.4-8.4 10.5-17 15.5-25.6zm14.4-76.5c-4.7-8.8-9.5-17.6-14.5-26.2-4.9-8.5-10-16.9-15.3-25.2 16.1 2 31.5 4.7 45.9 8-4.6 14.8-10 29.2-16.1 43.4zM256.2 118.3c10.5 11.4 20.4 23.4 29.6 35.8-19.8-.9-39.7-.9-59.5 0 9.8-12.9 19.9-24.9 29.9-35.8zM140.2 57c16.8-9.8 54.1 4.2 93.4 39 2.5 2.2 5 4.6 7.6 7-15.5 16.7-29.8 34.5-42.9 53.1-22.6 2-45 5.5-67.2 10.4-1.3-5.1-2.4-10.3-3.5-15.5-9.4-48.4-3.2-84.9 12.6-94zm-24.5 263.6c-4.2-1.2-8.3-2.5-12.4-3.9-21.3-6.7-45.5-17.3-63-31.2-10.1-7-16.9-17.8-18.8-29.9 0-18.3 31.6-41.7 77.2-57.6 5.7-2 11.5-3.8 17.3-5.5 6.8 21.7 15 43 24.5 63.6-9.6 20.9-17.9 42.5-24.8 64.5zm116.6 98c-16.5 15.1-35.6 27.1-56.4 35.3-11.1 5.3-23.9 5.8-35.3 1.3-15.9-9.2-22.5-44.5-13.5-92 1.1-5.6 2.3-11.2 3.7-16.7 22.4 4.8 45 8.1 67.9 9.8 13.2 18.7 27.7 36.6 43.2 53.4-3.2 3.1-6.4 6.1-9.6 8.9zm24.5-24.3c-10.2-11-20.4-23.2-30.3-36.3 9.6.4 19.5.6 29.5.6 10.3 0 20.4-.2 30.4-.7-9.2 12.7-19.1 24.8-29.6 36.4zm130.7 30c-.9 12.2-6.9 23.6-16.5 31.3-15.9 9.2-49.8-2.8-86.4-34.2-4.2-3.6-8.4-7.5-12.7-11.5 15.3-16.9 29.4-34.8 42.2-53.6 22.9-1.9 45.7-5.4 68.2-10.5 1 4.1 1.9 8.2 2.7 12.2 4.9 21.6 5.7 44.1 2.5 66.3zm18.2-107.5c-2.8.9-5.6 1.8-8.5 2.6-7-21.8-15.6-43.1-25.5-63.8 9.6-20.4 17.7-41.4 24.5-62.9 5.2 1.5 10.2 3.1 15 4.7 46.6 16 79.3 39.8 79.3 58 0 19.6-34.9 44.9-84.8 61.4zm-149.7-15c25.3 0 45.8-20.5 45.8-45.8s-20.5-45.8-45.8-45.8c-25.3 0-45.8 20.5-45.8 45.8s20.5 45.8 45.8 45.8z"}}]})(e)}function kt(e){return lt({tag:"svg",attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{d:"M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"}}]})(e)}function St(e){return lt({tag:"svg",attr:{viewBox:"0 0 448 512"},child:[{tag:"path",attr:{d:"M380.9 97.1C339 55.1 283.2 32 223.9 32c-122.4 0-222 99.6-222 222 0 39.1 10.2 77.3 29.6 111L0 480l117.7-30.9c32.4 17.7 68.9 27 106.1 27h.1c122.3 0 224.1-99.6 224.1-222 0-59.3-25.2-115-67.1-157zm-157 341.6c-33.2 0-65.7-8.9-94-25.7l-6.7-4-69.8 18.3L72 359.2l-4.4-7c-18.5-29.4-28.2-63.3-28.2-98.2 0-101.7 82.8-184.5 184.6-184.5 49.3 0 95.6 19.2 130.4 54.1 34.8 34.9 56.2 81.2 56.1 130.5 0 101.8-84.9 184.6-186.6 184.6zm101.2-138.2c-5.5-2.8-32.8-16.2-37.9-18-5.1-1.9-8.8-2.8-12.5 2.8-3.7 5.6-14.3 18-17.6 21.8-3.2 3.7-6.5 4.2-12 1.4-32.6-16.3-54-29.1-75.5-66-5.7-9.8 5.7-9.1 16.3-30.3 1.8-3.7.9-6.9-.5-9.7-1.4-2.8-12.5-30.1-17.1-41.2-4.5-10.8-9.1-9.3-12.5-9.5-3.2-.2-6.9-.2-10.6-.2-3.7 0-9.7 1.4-14.8 6.9-5.1 5.6-19.4 19-19.4 46.3 0 27.3 19.9 53.7 22.6 57.4 2.8 3.7 39.1 59.7 94.8 83.8 35.2 15.2 49 16.5 66.6 13.9 10.7-1.6 32.8-13.4 37.4-26.4 4.6-13 4.6-24.1 3.2-26.4-1.3-2.5-5-3.9-10.5-6.6z"}}]})(e)}function Ct(e){return lt({tag:"svg",attr:{viewBox:"0 0 448 512"},child:[{tag:"path",attr:{d:"M257.5 445.1l-22.2 22.2c-9.4 9.4-24.6 9.4-33.9 0L7 273c-9.4-9.4-9.4-24.6 0-33.9L201.4 44.7c9.4-9.4 24.6-9.4 33.9 0l22.2 22.2c9.5 9.5 9.3 25-.4 34.3L136.6 216H424c13.3 0 24 10.7 24 24v32c0 13.3-10.7 24-24 24H136.6l120.5 114.8c9.8 9.3 10 24.8.4 34.3z"}}]})(e)}function It(e){return lt({tag:"svg",attr:{viewBox:"0 0 448 512"},child:[{tag:"path",attr:{d:"M190.5 66.9l22.2-22.2c9.4-9.4 24.6-9.4 33.9 0L441 239c9.4 9.4 9.4 24.6 0 33.9L246.6 467.3c-9.4 9.4-24.6 9.4-33.9 0l-22.2-22.2c-9.5-9.5-9.3-25 .4-34.3L311.4 296H24c-13.3 0-24-10.7-24-24v-32c0-13.3 10.7-24 24-24h287.4L190.9 101.2c-9.8-9.3-10-24.8-.4-34.3z"}}]})(e)}function Nt(e){return lt({tag:"svg",attr:{viewBox:"0 0 640 512"},child:[{tag:"path",attr:{d:"M256 336h-.02c0-16.18 1.34-8.73-85.05-181.51-17.65-35.29-68.19-35.36-85.87 0C-2.06 328.75.02 320.33.02 336H0c0 44.18 57.31 80 128 80s128-35.82 128-80zM128 176l72 144H56l72-144zm511.98 160c0-16.18 1.34-8.73-85.05-181.51-17.65-35.29-68.19-35.36-85.87 0-87.12 174.26-85.04 165.84-85.04 181.51H384c0 44.18 57.31 80 128 80s128-35.82 128-80h-.02zM440 320l72-144 72 144H440zm88 128H352V153.25c23.51-10.29 41.16-31.48 46.39-57.25H528c8.84 0 16-7.16 16-16V48c0-8.84-7.16-16-16-16H383.64C369.04 12.68 346.09 0 320 0s-49.04 12.68-63.64 32H112c-8.84 0-16 7.16-16 16v32c0 8.84 7.16 16 16 16h129.61c5.23 25.76 22.87 46.96 46.39 57.25V448H112c-8.84 0-16 7.16-16 16v32c0 8.84 7.16 16 16 16h416c8.84 0 16-7.16 16-16v-32c0-8.84-7.16-16-16-16z"}}]})(e)}function Tt(e){return lt({tag:"svg",attr:{viewBox:"0 0 448 512"},child:[{tag:"path",attr:{d:"M16 132h416c8.837 0 16-7.163 16-16V76c0-8.837-7.163-16-16-16H16C7.163 60 0 67.163 0 76v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16z"}}]})(e)}function Et(e){return lt({tag:"svg",attr:{viewBox:"0 0 576 512"},child:[{tag:"path",attr:{d:"M208 0c-29.9 0-54.7 20.5-61.8 48.2-.8 0-1.4-.2-2.2-.2-35.3 0-64 28.7-64 64 0 4.8.6 9.5 1.7 14C52.5 138 32 166.6 32 200c0 12.6 3.2 24.3 8.3 34.9C16.3 248.7 0 274.3 0 304c0 33.3 20.4 61.9 49.4 73.9-.9 4.6-1.4 9.3-1.4 14.1 0 39.8 32.2 72 72 72 4.1 0 8.1-.5 12-1.2 9.6 28.5 36.2 49.2 68 49.2 39.8 0 72-32.2 72-72V64c0-35.3-28.7-64-64-64zm368 304c0-29.7-16.3-55.3-40.3-69.1 5.2-10.6 8.3-22.3 8.3-34.9 0-33.4-20.5-62-49.7-74 1-4.5 1.7-9.2 1.7-14 0-35.3-28.7-64-64-64-.8 0-1.5.2-2.2.2C422.7 20.5 397.9 0 368 0c-35.3 0-64 28.6-64 64v376c0 39.8 32.2 72 72 72 31.8 0 58.4-20.7 68-49.2 3.9.7 7.9 1.2 12 1.2 39.8 0 72-32.2 72-72 0-4.8-.5-9.5-1.4-14.1 29-12 49.4-40.6 49.4-73.9z"}}]})(e)}function Rt(e){return lt({tag:"svg",attr:{viewBox:"0 0 448 512"},child:[{tag:"path",attr:{d:"M12 192h424c6.6 0 12 5.4 12 12v260c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V204c0-6.6 5.4-12 12-12zm436-44v-36c0-26.5-21.5-48-48-48h-48V12c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v52H160V12c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v52H48C21.5 64 0 85.5 0 112v36c0 6.6 5.4 12 12 12h424c6.6 0 12-5.4 12-12z"}}]})(e)}function _t(e){return lt({tag:"svg",attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{d:"M512 144v288c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V144c0-26.5 21.5-48 48-48h88l12.3-32.9c7-18.7 24.9-31.1 44.9-31.1h125.5c20 0 37.9 12.4 44.9 31.1L376 96h88c26.5 0 48 21.5 48 48zM376 288c0-66.2-53.8-120-120-120s-120 53.8-120 120 53.8 120 120 120 120-53.8 120-120zm-32 0c0 48.5-39.5 88-88 88s-88-39.5-88-88 39.5-88 88-88 88 39.5 88 88z"}}]})(e)}function At(e){return lt({tag:"svg",attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{d:"M332.8 320h38.4c6.4 0 12.8-6.4 12.8-12.8V172.8c0-6.4-6.4-12.8-12.8-12.8h-38.4c-6.4 0-12.8 6.4-12.8 12.8v134.4c0 6.4 6.4 12.8 12.8 12.8zm96 0h38.4c6.4 0 12.8-6.4 12.8-12.8V76.8c0-6.4-6.4-12.8-12.8-12.8h-38.4c-6.4 0-12.8 6.4-12.8 12.8v230.4c0 6.4 6.4 12.8 12.8 12.8zm-288 0h38.4c6.4 0 12.8-6.4 12.8-12.8v-70.4c0-6.4-6.4-12.8-12.8-12.8h-38.4c-6.4 0-12.8 6.4-12.8 12.8v70.4c0 6.4 6.4 12.8 12.8 12.8zm96 0h38.4c6.4 0 12.8-6.4 12.8-12.8V108.8c0-6.4-6.4-12.8-12.8-12.8h-38.4c-6.4 0-12.8 6.4-12.8 12.8v198.4c0 6.4 6.4 12.8 12.8 12.8zM496 384H64V80c0-8.84-7.16-16-16-16H16C7.16 64 0 71.16 0 80v336c0 17.67 14.33 32 32 32h464c8.84 0 16-7.16 16-16v-32c0-8.84-7.16-16-16-16z"}}]})(e)}function Mt(e){return lt({tag:"svg",attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{d:"M496 384H64V80c0-8.84-7.16-16-16-16H16C7.16 64 0 71.16 0 80v336c0 17.67 14.33 32 32 32h464c8.84 0 16-7.16 16-16v-32c0-8.84-7.16-16-16-16zM464 96H345.94c-21.38 0-32.09 25.85-16.97 40.97l32.4 32.4L288 242.75l-73.37-73.37c-12.5-12.5-32.76-12.5-45.25 0l-68.69 68.69c-6.25 6.25-6.25 16.38 0 22.63l22.62 22.62c6.25 6.25 16.38 6.25 22.63 0L192 237.25l73.37 73.37c12.5 12.5 32.76 12.5 45.25 0l96-96 32.4 32.4c15.12 15.12 40.97 4.41 40.97-16.97V112c.01-8.84-7.15-16-15.99-16z"}}]})(e)}function Pt(e){return lt({tag:"svg",attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{d:"M504 256c0 136.967-111.033 248-248 248S8 392.967 8 256 119.033 8 256 8s248 111.033 248 248zM227.314 387.314l184-184c6.248-6.248 6.248-16.379 0-22.627l-22.627-22.627c-6.248-6.249-16.379-6.249-22.628 0L216 308.118l-70.059-70.059c-6.248-6.248-16.379-6.248-22.628 0l-22.627 22.627c-6.248 6.248-6.248 16.379 0 22.627l104 104c6.249 6.249 16.379 6.249 22.628.001z"}}]})(e)}function Dt(e){return lt({tag:"svg",attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{d:"M505 174.8l-39.6-39.6c-9.4-9.4-24.6-9.4-33.9 0L192 374.7 80.6 263.2c-9.4-9.4-24.6-9.4-33.9 0L7 302.9c-9.4 9.4-9.4 24.6 0 34L175 505c9.4 9.4 24.6 9.4 33.9 0l296-296.2c9.4-9.5 9.4-24.7.1-34zm-324.3 106c6.2 6.3 16.4 6.3 22.6 0l208-208.2c6.2-6.3 6.2-16.4 0-22.6L366.1 4.7c-6.2-6.3-16.4-6.3-22.6 0L192 156.2l-55.4-55.5c-6.2-6.3-16.4-6.3-22.6 0L68.7 146c-6.2 6.3-6.2 16.4 0 22.6l112 112.2z"}}]})(e)}function Ot(e){return lt({tag:"svg",attr:{viewBox:"0 0 448 512"},child:[{tag:"path",attr:{d:"M207.029 381.476L12.686 187.132c-9.373-9.373-9.373-24.569 0-33.941l22.667-22.667c9.357-9.357 24.522-9.375 33.901-.04L224 284.505l154.745-154.021c9.379-9.335 24.544-9.317 33.901.04l22.667 22.667c9.373 9.373 9.373 24.569 0 33.941L240.971 381.476c-9.373 9.372-24.569 9.372-33.942 0z"}}]})(e)}function Ft(e){return lt({tag:"svg",attr:{viewBox:"0 0 640 512"},child:[{tag:"path",attr:{d:"M278.9 511.5l-61-17.7c-6.4-1.8-10-8.5-8.2-14.9L346.2 8.7c1.8-6.4 8.5-10 14.9-8.2l61 17.7c6.4 1.8 10 8.5 8.2 14.9L293.8 503.3c-1.9 6.4-8.5 10.1-14.9 8.2zm-114-112.2l43.5-46.4c4.6-4.9 4.3-12.7-.8-17.2L117 256l90.6-79.7c5.1-4.5 5.5-12.3.8-17.2l-43.5-46.4c-4.5-4.8-12.1-5.1-17-.5L3.8 247.2c-5.1 4.7-5.1 12.8 0 17.5l144.1 135.1c4.9 4.6 12.5 4.4 17-.5zm327.2.6l144.1-135.1c5.1-4.7 5.1-12.8 0-17.5L492.1 112.1c-4.8-4.5-12.4-4.3-17 .5L431.6 159c-4.6 4.9-4.3 12.7.8 17.2L523 256l-90.6 79.7c-5.1 4.5-5.5 12.3-.8 17.2l43.5 46.4c4.5 4.9 12.1 5.1 17 .6z"}}]})(e)}function Lt(e){return lt({tag:"svg",attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{d:"M487.4 315.7l-42.6-24.6c4.3-23.2 4.3-47 0-70.2l42.6-24.6c4.9-2.8 7.1-8.6 5.5-14-11.1-35.6-30-67.8-54.7-94.6-3.8-4.1-10-5.1-14.8-2.3L380.8 110c-17.9-15.4-38.5-27.3-60.8-35.1V25.8c0-5.6-3.9-10.5-9.4-11.7-36.7-8.2-74.3-7.8-109.2 0-5.5 1.2-9.4 6.1-9.4 11.7V75c-22.2 7.9-42.8 19.8-60.8 35.1L88.7 85.5c-4.9-2.8-11-1.9-14.8 2.3-24.7 26.7-43.6 58.9-54.7 94.6-1.7 5.4.6 11.2 5.5 14L67.3 221c-4.3 23.2-4.3 47 0 70.2l-42.6 24.6c-4.9 2.8-7.1 8.6-5.5 14 11.1 35.6 30 67.8 54.7 94.6 3.8 4.1 10 5.1 14.8 2.3l42.6-24.6c17.9 15.4 38.5 27.3 60.8 35.1v49.2c0 5.6 3.9 10.5 9.4 11.7 36.7 8.2 74.3 7.8 109.2 0 5.5-1.2 9.4-6.1 9.4-11.7v-49.2c22.2-7.9 42.8-19.8 60.8-35.1l42.6 24.6c4.9 2.8 11 1.9 14.8-2.3 24.7-26.7 43.6-58.9 54.7-94.6 1.5-5.5-.7-11.3-5.6-14.1zM256 336c-44.1 0-80-35.9-80-80s35.9-80 80-80 80 35.9 80 80-35.9 80-80 80z"}}]})(e)}function zt(e){return lt({tag:"svg",attr:{viewBox:"0 0 640 512"},child:[{tag:"path",attr:{d:"M512.1 191l-8.2 14.3c-3 5.3-9.4 7.5-15.1 5.4-11.8-4.4-22.6-10.7-32.1-18.6-4.6-3.8-5.8-10.5-2.8-15.7l8.2-14.3c-6.9-8-12.3-17.3-15.9-27.4h-16.5c-6 0-11.2-4.3-12.2-10.3-2-12-2.1-24.6 0-37.1 1-6 6.2-10.4 12.2-10.4h16.5c3.6-10.1 9-19.4 15.9-27.4l-8.2-14.3c-3-5.2-1.9-11.9 2.8-15.7 9.5-7.9 20.4-14.2 32.1-18.6 5.7-2.1 12.1.1 15.1 5.4l8.2 14.3c10.5-1.9 21.2-1.9 31.7 0L552 6.3c3-5.3 9.4-7.5 15.1-5.4 11.8 4.4 22.6 10.7 32.1 18.6 4.6 3.8 5.8 10.5 2.8 15.7l-8.2 14.3c6.9 8 12.3 17.3 15.9 27.4h16.5c6 0 11.2 4.3 12.2 10.3 2 12 2.1 24.6 0 37.1-1 6-6.2 10.4-12.2 10.4h-16.5c-3.6 10.1-9 19.4-15.9 27.4l8.2 14.3c3 5.2 1.9 11.9-2.8 15.7-9.5 7.9-20.4 14.2-32.1 18.6-5.7 2.1-12.1-.1-15.1-5.4l-8.2-14.3c-10.4 1.9-21.2 1.9-31.7 0zm-10.5-58.8c38.5 29.6 82.4-14.3 52.8-52.8-38.5-29.7-82.4 14.3-52.8 52.8zM386.3 286.1l33.7 16.8c10.1 5.8 14.5 18.1 10.5 29.1-8.9 24.2-26.4 46.4-42.6 65.8-7.4 8.9-20.2 11.1-30.3 5.3l-29.1-16.8c-16 13.7-34.6 24.6-54.9 31.7v33.6c0 11.6-8.3 21.6-19.7 23.6-24.6 4.2-50.4 4.4-75.9 0-11.5-2-20-11.9-20-23.6V418c-20.3-7.2-38.9-18-54.9-31.7L74 403c-10 5.8-22.9 3.6-30.3-5.3-16.2-19.4-33.3-41.6-42.2-65.7-4-10.9.4-23.2 10.5-29.1l33.3-16.8c-3.9-20.9-3.9-42.4 0-63.4L12 205.8c-10.1-5.8-14.6-18.1-10.5-29 8.9-24.2 26-46.4 42.2-65.8 7.4-8.9 20.2-11.1 30.3-5.3l29.1 16.8c16-13.7 34.6-24.6 54.9-31.7V57.1c0-11.5 8.2-21.5 19.6-23.5 24.6-4.2 50.5-4.4 76-.1 11.5 2 20 11.9 20 23.6v33.6c20.3 7.2 38.9 18 54.9 31.7l29.1-16.8c10-5.8 22.9-3.6 30.3 5.3 16.2 19.4 33.2 41.6 42.1 65.8 4 10.9.1 23.2-10 29.1l-33.7 16.8c3.9 21 3.9 42.5 0 63.5zm-117.6 21.1c59.2-77-28.7-164.9-105.7-105.7-59.2 77 28.7 164.9 105.7 105.7zm243.4 182.7l-8.2 14.3c-3 5.3-9.4 7.5-15.1 5.4-11.8-4.4-22.6-10.7-32.1-18.6-4.6-3.8-5.8-10.5-2.8-15.7l8.2-14.3c-6.9-8-12.3-17.3-15.9-27.4h-16.5c-6 0-11.2-4.3-12.2-10.3-2-12-2.1-24.6 0-37.1 1-6 6.2-10.4 12.2-10.4h16.5c3.6-10.1 9-19.4 15.9-27.4l-8.2-14.3c-3-5.2-1.9-11.9 2.8-15.7 9.5-7.9 20.4-14.2 32.1-18.6 5.7-2.1 12.1.1 15.1 5.4l8.2 14.3c10.5-1.9 21.2-1.9 31.7 0l8.2-14.3c3-5.3 9.4-7.5 15.1-5.4 11.8 4.4 22.6 10.7 32.1 18.6 4.6 3.8 5.8 10.5 2.8 15.7l-8.2 14.3c6.9 8 12.3 17.3 15.9 27.4h16.5c6 0 11.2 4.3 12.2 10.3 2 12 2.1 24.6 0 37.1-1 6-6.2 10.4-12.2 10.4h-16.5c-3.6 10.1-9 19.4-15.9 27.4l8.2 14.3c3 5.2 1.9 11.9-2.8 15.7-9.5 7.9-20.4 14.2-32.1 18.6-5.7 2.1-12.1-.1-15.1-5.4l-8.2-14.3c-10.4 1.9-21.2 1.9-31.7 0zM501.6 431c38.5 29.6 82.4-14.3 52.8-52.8-38.5-29.6-82.4 14.3-52.8 52.8z"}}]})(e)}function Bt(e){return lt({tag:"svg",attr:{viewBox:"0 0 576 512"},child:[{tag:"path",attr:{d:"M416 192c0-88.4-93.1-160-208-160S0 103.6 0 192c0 34.3 14.1 65.9 38 92-13.4 30.2-35.5 54.2-35.8 54.5-2.2 2.3-2.8 5.7-1.5 8.7S4.8 352 8 352c36.6 0 66.9-12.3 88.7-25 32.2 15.7 70.3 25 111.3 25 114.9 0 208-71.6 208-160zm122 220c23.9-26 38-57.7 38-92 0-66.9-53.5-124.2-129.3-148.1.9 6.6 1.3 13.3 1.3 20.1 0 105.9-107.7 192-240 192-10.8 0-21.3-.8-31.7-1.9C207.8 439.6 281.8 480 368 480c41 0 79.1-9.2 111.3-25 21.8 12.7 52.1 25 88.7 25 3.2 0 6.1-1.9 7.3-4.8 1.3-2.9.7-6.3-1.5-8.7-.3-.3-22.4-24.2-35.8-54.5z"}}]})(e)}function jt(e){return lt({tag:"svg",attr:{viewBox:"0 0 448 512"},child:[{tag:"path",attr:{d:"M448 73.143v45.714C448 159.143 347.667 192 224 192S0 159.143 0 118.857V73.143C0 32.857 100.333 0 224 0s224 32.857 224 73.143zM448 176v102.857C448 319.143 347.667 352 224 352S0 319.143 0 278.857V176c48.125 33.143 136.208 48.572 224 48.572S399.874 209.143 448 176zm0 160v102.857C448 479.143 347.667 512 224 512S0 479.143 0 438.857V336c48.125 33.143 136.208 48.572 224 48.572S399.874 369.143 448 336z"}}]})(e)}function Wt(e){return lt({tag:"svg",attr:{viewBox:"0 0 576 512"},child:[{tag:"path",attr:{d:"M528 0H48C21.5 0 0 21.5 0 48v320c0 26.5 21.5 48 48 48h192l-16 48h-72c-13.3 0-24 10.7-24 24s10.7 24 24 24h272c13.3 0 24-10.7 24-24s-10.7-24-24-24h-72l-16-48h192c26.5 0 48-21.5 48-48V48c0-26.5-21.5-48-48-48zm-16 352H64V64h448v288z"}}]})(e)}function Vt(e){return lt({tag:"svg",attr:{viewBox:"0 0 640 512"},child:[{tag:"path",attr:{d:"M104 96H56c-13.3 0-24 10.7-24 24v104H8c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8h24v104c0 13.3 10.7 24 24 24h48c13.3 0 24-10.7 24-24V120c0-13.3-10.7-24-24-24zm528 128h-24V120c0-13.3-10.7-24-24-24h-48c-13.3 0-24 10.7-24 24v272c0 13.3 10.7 24 24 24h48c13.3 0 24-10.7 24-24V288h24c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8zM456 32h-48c-13.3 0-24 10.7-24 24v168H256V56c0-13.3-10.7-24-24-24h-48c-13.3 0-24 10.7-24 24v400c0 13.3 10.7 24 24 24h48c13.3 0 24-10.7 24-24V288h128v168c0 13.3 10.7 24 24 24h48c13.3 0 24-10.7 24-24V56c0-13.3-10.7-24-24-24z"}}]})(e)}function Ut(e){return lt({tag:"svg",attr:{viewBox:"0 0 576 512"},child:[{tag:"path",attr:{d:"M402.6 83.2l90.2 90.2c3.8 3.8 3.8 10 0 13.8L274.4 405.6l-92.8 10.3c-12.4 1.4-22.9-9.1-21.5-21.5l10.3-92.8L388.8 83.2c3.8-3.8 10-3.8 13.8 0zm162-22.9l-48.8-48.8c-15.2-15.2-39.9-15.2-55.2 0l-35.4 35.4c-3.8 3.8-3.8 10 0 13.8l90.2 90.2c3.8 3.8 10 3.8 13.8 0l35.4-35.4c15.2-15.3 15.2-40 0-55.2zM384 346.2V448H64V128h229.8c3.2 0 6.2-1.3 8.5-3.5l40-40c7.6-7.6 2.2-20.5-8.5-20.5H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V306.2c0-10.7-12.9-16-20.5-8.5l-40 40c-2.2 2.3-3.5 5.3-3.5 8.5z"}}]})(e)}function Ht(e){return lt({tag:"svg",attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{d:"M502.3 190.8c3.9-3.1 9.7-.2 9.7 4.7V400c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V195.6c0-5 5.7-7.8 9.7-4.7 22.4 17.4 52.1 39.5 154.1 113.6 21.1 15.4 56.7 47.8 92.2 47.6 35.7.3 72-32.8 92.3-47.6 102-74.1 131.6-96.3 154-113.7zM256 320c23.2.4 56.6-29.2 73.4-41.4 132.7-96.3 142.8-104.7 173.4-128.7 5.8-4.5 9.2-11.5 9.2-18.9v-19c0-26.5-21.5-48-48-48H48C21.5 64 0 85.5 0 112v19c0 7.4 3.4 14.3 9.2 18.9 30.6 23.9 40.7 32.4 173.4 128.7 16.8 12.2 50.2 41.8 73.4 41.4z"}}]})(e)}function Gt(e){return lt({tag:"svg",attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{d:"M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zm-248 50c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"}}]})(e)}function qt(e){return lt({tag:"svg",attr:{viewBox:"0 0 576 512"},child:[{tag:"path",attr:{d:"M569.517 440.013C587.975 472.007 564.806 512 527.94 512H48.054c-36.937 0-59.999-40.055-41.577-71.987L246.423 23.985c18.467-32.009 64.72-31.951 83.154 0l239.94 416.028zM288 354c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"}}]})(e)}function Kt(e){return lt({tag:"svg",attr:{viewBox:"0 0 640 512"},child:[{tag:"path",attr:{d:"M320 400c-75.85 0-137.25-58.71-142.9-133.11L72.2 185.82c-13.79 17.3-26.48 35.59-36.72 55.59a32.35 32.35 0 0 0 0 29.19C89.71 376.41 197.07 448 320 448c26.91 0 52.87-4 77.89-10.46L346 397.39a144.13 144.13 0 0 1-26 2.61zm313.82 58.1l-110.55-85.44a331.25 331.25 0 0 0 81.25-102.07 32.35 32.35 0 0 0 0-29.19C550.29 135.59 442.93 64 320 64a308.15 308.15 0 0 0-147.32 37.7L45.46 3.37A16 16 0 0 0 23 6.18L3.37 31.45A16 16 0 0 0 6.18 53.9l588.36 454.73a16 16 0 0 0 22.46-2.81l19.64-25.27a16 16 0 0 0-2.82-22.45zm-183.72-142l-39.3-30.38A94.75 94.75 0 0 0 416 256a94.76 94.76 0 0 0-121.31-92.21A47.65 47.65 0 0 1 304 192a46.64 46.64 0 0 1-1.54 10l-73.61-56.89A142.31 142.31 0 0 1 320 112a143.92 143.92 0 0 1 144 144c0 21.63-5.29 41.79-13.9 60.11z"}}]})(e)}function Xt(e){return lt({tag:"svg",attr:{viewBox:"0 0 576 512"},child:[{tag:"path",attr:{d:"M572.52 241.4C518.29 135.59 410.93 64 288 64S57.68 135.64 3.48 241.41a32.35 32.35 0 0 0 0 29.19C57.71 376.41 165.07 448 288 448s230.32-71.64 284.52-177.41a32.35 32.35 0 0 0 0-29.19zM288 400a144 144 0 1 1 144-144 143.93 143.93 0 0 1-144 144zm0-240a95.31 95.31 0 0 0-25.31 3.79 47.85 47.85 0 0 1-66.9 66.9A95.78 95.78 0 1 0 288 160z"}}]})(e)}function Yt(e){return lt({tag:"svg",attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{d:"M462.3 62.6C407.5 15.9 326 24.3 275.7 76.2L256 96.5l-19.7-20.3C186.1 24.3 104.5 15.9 49.7 62.6c-62.8 53.6-66.1 149.8-9.9 207.9l193.5 199.8c12.5 12.9 32.8 12.9 45.3 0l193.5-199.8c56.3-58.1 53-154.3-9.8-207.9z"}}]})(e)}function Qt(e){return lt({tag:"svg",attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{d:"M320.2 243.8l-49.7 99.4c-6 12.1-23.4 11.7-28.9-.6l-56.9-126.3-30 71.7H60.6l182.5 186.5c7.1 7.3 18.6 7.3 25.7 0L451.4 288H342.3l-22.1-44.2zM473.7 73.9l-2.4-2.5c-51.5-52.6-135.8-52.6-187.4 0L256 100l-27.9-28.5c-51.5-52.7-135.9-52.7-187.4 0l-2.4 2.4C-10.4 123.7-12.5 203 31 256h102.4l35.9-86.2c5.4-12.9 23.6-13.2 29.4-.4l58.2 129.3 49-97.9c5.9-11.8 22.7-11.8 28.6 0l27.6 55.2H481c43.5-53 41.4-132.3-7.3-182.1z"}}]})(e)}function Zt(e){return lt({tag:"svg",attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{d:"M256 8C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8zm0 110c23.196 0 42 18.804 42 42s-18.804 42-42 42-42-18.804-42-42 18.804-42 42-42zm56 254c0 6.627-5.373 12-12 12h-88c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h12v-64h-12c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h64c6.627 0 12 5.373 12 12v100h12c6.627 0 12 5.373 12 12v24z"}}]})(e)}function Jt(e){return lt({tag:"svg",attr:{viewBox:"0 0 640 512"},child:[{tag:"path",attr:{d:"M255.03 261.65c6.25 6.25 16.38 6.25 22.63 0l11.31-11.31c6.25-6.25 6.25-16.38 0-22.63L253.25 192l35.71-35.72c6.25-6.25 6.25-16.38 0-22.63l-11.31-11.31c-6.25-6.25-16.38-6.25-22.63 0l-58.34 58.34c-6.25 6.25-6.25 16.38 0 22.63l58.35 58.34zm96.01-11.3l11.31 11.31c6.25 6.25 16.38 6.25 22.63 0l58.34-58.34c6.25-6.25 6.25-16.38 0-22.63l-58.34-58.34c-6.25-6.25-16.38-6.25-22.63 0l-11.31 11.31c-6.25 6.25-6.25 16.38 0 22.63L386.75 192l-35.71 35.72c-6.25 6.25-6.25 16.38 0 22.63zM624 416H381.54c-.74 19.81-14.71 32-32.74 32H288c-18.69 0-33.02-17.47-32.77-32H16c-8.8 0-16 7.2-16 16v16c0 35.2 28.8 64 64 64h512c35.2 0 64-28.8 64-64v-16c0-8.8-7.2-16-16-16zM576 48c0-26.4-21.6-48-48-48H112C85.6 0 64 21.6 64 48v336h512V48zm-64 272H128V64h384v256z"}}]})(e)}function $t(e){return lt({tag:"svg",attr:{viewBox:"0 0 576 512"},child:[{tag:"path",attr:{d:"M546.2 9.7c-5.6-12.5-21.6-13-28.3-1.2C486.9 62.4 431.4 96 368 96h-80C182 96 96 182 96 288c0 7 .8 13.7 1.5 20.5C161.3 262.8 253.4 224 384 224c8.8 0 16 7.2 16 16s-7.2 16-16 16C132.6 256 26 410.1 2.4 468c-6.6 16.3 1.2 34.9 17.5 41.6 16.4 6.8 35-1.1 41.8-17.3 1.5-3.6 20.9-47.9 71.9-90.6 32.4 43.9 94 85.8 174.9 77.2C465.5 467.5 576 326.7 576 154.3c0-50.2-10.8-102.2-29.8-144.6z"}}]})(e)}function en(e){return lt({tag:"svg",attr:{viewBox:"0 0 352 512"},child:[{tag:"path",attr:{d:"M96.06 454.35c.01 6.29 1.87 12.45 5.36 17.69l17.09 25.69a31.99 31.99 0 0 0 26.64 14.28h61.71a31.99 31.99 0 0 0 26.64-14.28l17.09-25.69a31.989 31.989 0 0 0 5.36-17.69l.04-38.35H96.01l.05 38.35zM0 176c0 44.37 16.45 84.85 43.56 115.78 16.52 18.85 42.36 58.23 52.21 91.45.04.26.07.52.11.78h160.24c.04-.26.07-.51.11-.78 9.85-33.22 35.69-72.6 52.21-91.45C335.55 260.85 352 220.37 352 176 352 78.61 272.91-.3 175.45 0 73.44.31 0 82.97 0 176zm176-80c-44.11 0-80 35.89-80 80 0 8.84-7.16 16-16 16s-16-7.16-16-16c0-61.76 50.24-112 112-112 8.84 0 16 7.16 16 16s-7.16 16-16 16z"}}]})(e)}function tn(e){return lt({tag:"svg",attr:{viewBox:"0 0 448 512"},child:[{tag:"path",attr:{d:"M400 224h-24v-72C376 68.2 307.8 0 224 0S72 68.2 72 152v72H48c-26.5 0-48 21.5-48 48v192c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V272c0-26.5-21.5-48-48-48zm-104 0H152v-72c0-39.7 32.3-72 72-72s72 32.3 72 72v72z"}}]})(e)}function nn(e){return lt({tag:"svg",attr:{viewBox:"0 0 384 512"},child:[{tag:"path",attr:{d:"M172.268 501.67C26.97 291.031 0 269.413 0 192 0 85.961 85.961 0 192 0s192 85.961 192 192c0 77.413-26.97 99.031-172.268 309.67-9.535 13.774-29.93 13.773-39.464 0zM192 272c44.183 0 80-35.817 80-80s-35.817-80-80-80-80 35.817-80 80 35.817 80 80 80z"}}]})(e)}function an(e){return lt({tag:"svg",attr:{viewBox:"0 0 320 512"},child:[{tag:"path",attr:{d:"M272 0H48C21.5 0 0 21.5 0 48v416c0 26.5 21.5 48 48 48h224c26.5 0 48-21.5 48-48V48c0-26.5-21.5-48-48-48zM160 480c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32zm112-108c0 6.6-5.4 12-12 12H60c-6.6 0-12-5.4-12-12V60c0-6.6 5.4-12 12-12h200c6.6 0 12 5.4 12 12v312z"}}]})(e)}function sn(e){return lt({tag:"svg",attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{d:"M476 3.2L12.5 270.6c-18.1 10.4-15.8 35.6 2.2 43.2L121 358.4l287.3-253.2c5.5-4.9 13.3 2.6 8.6 8.3L176 407v80.5c0 23.6 28.5 32.9 42.5 15.8L282 426l124.6 52.2c14.2 6 30.4-2.9 33-18.2l72-432C515 7.8 493.3-6.8 476 3.2z"}}]})(e)}function rn(e){return lt({tag:"svg",attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{d:"M493.4 24.6l-104-24c-11.3-2.6-22.9 3.3-27.5 13.9l-48 112c-4.2 9.8-1.4 21.3 6.9 28l60.6 49.6c-36 76.7-98.9 140.5-177.2 177.2l-49.6-60.6c-6.8-8.3-18.2-11.1-28-6.9l-112 48C3.9 366.5-2 378.1.6 389.4l24 104C27.1 504.2 36.7 512 48 512c256.1 0 464-207.5 464-464 0-11.2-7.7-20.9-18.6-23.4z"}}]})(e)}function on(e){return lt({tag:"svg",attr:{viewBox:"0 0 448 512"},child:[{tag:"path",attr:{d:"M424.4 214.7L72.4 6.6C43.8-10.3 0 6.1 0 47.9V464c0 37.5 40.7 60.1 72.4 41.3l352-208c31.4-18.5 31.5-64.1 0-82.6z"}}]})(e)}function cn(e){return lt({tag:"svg",attr:{viewBox:"0 0 640 512"},child:[{tag:"path",attr:{d:"M384 320H256c-17.67 0-32 14.33-32 32v128c0 17.67 14.33 32 32 32h128c17.67 0 32-14.33 32-32V352c0-17.67-14.33-32-32-32zM192 32c0-17.67-14.33-32-32-32H32C14.33 0 0 14.33 0 32v128c0 17.67 14.33 32 32 32h95.72l73.16 128.04C211.98 300.98 232.4 288 256 288h.28L192 175.51V128h224V64H192V32zM608 0H480c-17.67 0-32 14.33-32 32v128c0 17.67 14.33 32 32 32h128c17.67 0 32-14.33 32-32V32c0-17.67-14.33-32-32-32z"}}]})(e)}function ln(e){return lt({tag:"svg",attr:{viewBox:"0 0 640 512"},child:[{tag:"path",attr:{d:"M32,224H64V416H32A31.96166,31.96166,0,0,1,0,384V256A31.96166,31.96166,0,0,1,32,224Zm512-48V448a64.06328,64.06328,0,0,1-64,64H160a64.06328,64.06328,0,0,1-64-64V176a79.974,79.974,0,0,1,80-80H288V32a32,32,0,0,1,64,0V96H464A79.974,79.974,0,0,1,544,176ZM264,256a40,40,0,1,0-40,40A39.997,39.997,0,0,0,264,256Zm-8,128H192v32h64Zm96,0H288v32h64ZM456,256a40,40,0,1,0-40,40A39.997,39.997,0,0,0,456,256Zm-8,128H384v32h64ZM640,256V384a31.96166,31.96166,0,0,1-32,32H576V224h32A31.96166,31.96166,0,0,1,640,256Z"}}]})(e)}function un(e){return lt({tag:"svg",attr:{viewBox:"0 0 448 512"},child:[{tag:"path",attr:{d:"M433.941 129.941l-83.882-83.882A48 48 0 0 0 316.118 32H48C21.49 32 0 53.49 0 80v352c0 26.51 21.49 48 48 48h352c26.51 0 48-21.49 48-48V163.882a48 48 0 0 0-14.059-33.941zM224 416c-35.346 0-64-28.654-64-64 0-35.346 28.654-64 64-64s64 28.654 64 64c0 35.346-28.654 64-64 64zm96-304.52V212c0 6.627-5.373 12-12 12H76c-6.627 0-12-5.373-12-12V108c0-6.627 5.373-12 12-12h228.52c3.183 0 6.235 1.264 8.485 3.515l3.48 3.48A11.996 11.996 0 0 1 320 111.48z"}}]})(e)}function hn(e){return lt({tag:"svg",attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{d:"M466.5 83.7l-192-80a48.15 48.15 0 0 0-36.9 0l-192 80C27.7 91.1 16 108.6 16 128c0 198.5 114.5 335.7 221.5 380.3 11.8 4.9 25.1 4.9 36.9 0C360.1 472.6 496 349.3 496 128c0-19.4-11.7-36.9-29.5-44.3zM256.1 446.3l-.1-381 175.9 73.3c-3.3 151.4-82.1 261.1-175.8 307.7z"}}]})(e)}function dn(e){return lt({tag:"svg",attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{d:"M497 273L329 441c-15 15-41 4.5-41-17v-96H152c-13.3 0-24-10.7-24-24v-96c0-13.3 10.7-24 24-24h136V88c0-21.4 25.9-32 41-17l168 168c9.3 9.4 9.3 24.6 0 34zM192 436v-40c0-6.6-5.4-12-12-12H96c-17.7 0-32-14.3-32-32V160c0-17.7 14.3-32 32-32h84c6.6 0 12-5.4 12-12V76c0-6.6-5.4-12-12-12H96c-53 0-96 43-96 96v192c0 53 43 96 96 96h84c6.6 0 12-5.4 12-12z"}}]})(e)}function pn(e){return lt({tag:"svg",attr:{viewBox:"0 0 448 512"},child:[{tag:"path",attr:{d:"M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48z"}}]})(e)}function fn(e){return lt({tag:"svg",attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{d:"M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm121.6 313.1c4.7 4.7 4.7 12.3 0 17L338 377.6c-4.7 4.7-12.3 4.7-17 0L256 312l-65.1 65.6c-4.7 4.7-12.3 4.7-17 0L134.4 338c-4.7-4.7-4.7-12.3 0-17l65.6-65-65.6-65.1c-4.7-4.7-4.7-12.3 0-17l39.6-39.6c4.7-4.7 12.3-4.7 17 0l65 65.7 65.1-65.6c4.7-4.7 12.3-4.7 17 0l39.6 39.6c4.7 4.7 4.7 12.3 0 17L312 256l65.6 65.1z"}}]})(e)}function mn(e){return lt({tag:"svg",attr:{viewBox:"0 0 352 512"},child:[{tag:"path",attr:{d:"M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"}}]})(e)}function gn(e){return lt({tag:"svg",attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{d:"M256 288c79.5 0 144-64.5 144-144S335.5 0 256 0 112 64.5 112 144s64.5 144 144 144zm128 32h-55.1c-22.2 10.2-46.9 16-72.9 16s-50.6-5.8-72.9-16H128C57.3 320 0 377.3 0 448v16c0 26.5 21.5 48 48 48h416c26.5 0 48-21.5 48-48v-16c0-70.7-57.3-128-128-128z"}}]})(e)}function yn(e){return lt({tag:"svg",attr:{viewBox:"0 0 640 512"},child:[{tag:"path",attr:{d:"M224 256c70.7 0 128-57.3 128-128S294.7 0 224 0 96 57.3 96 128s57.3 128 128 128zm89.6 32h-16.7c-22.2 10.2-46.9 16-72.9 16s-50.6-5.8-72.9-16h-16.7C60.2 288 0 348.2 0 422.4V464c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48v-41.6c0-74.2-60.2-134.4-134.4-134.4zm323-128.4l-27.8-28.1c-4.6-4.7-12.1-4.7-16.8-.1l-104.8 104-45.5-45.8c-4.6-4.7-12.1-4.7-16.8-.1l-28.1 27.9c-4.7 4.6-4.7 12.1-.1 16.8l81.7 82.3c4.6 4.7 12.1 4.7 16.8.1l141.3-140.2c4.6-4.7 4.7-12.2.1-16.8z"}}]})(e)}function bn(e){return lt({tag:"svg",attr:{viewBox:"0 0 448 512"},child:[{tag:"path",attr:{d:"M224 256c70.7 0 128-57.3 128-128S294.7 0 224 0 96 57.3 96 128s57.3 128 128 128zm89.6 32h-16.7c-22.2 10.2-46.9 16-72.9 16s-50.6-5.8-72.9-16h-16.7C60.2 288 0 348.2 0 422.4V464c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48v-41.6c0-74.2-60.2-134.4-134.4-134.4z"}}]})(e)}function xn(e){return lt({tag:"svg",attr:{viewBox:"0 0 576 512"},child:[{tag:"path",attr:{d:"M336.2 64H47.8C21.4 64 0 85.4 0 111.8v288.4C0 426.6 21.4 448 47.8 448h288.4c26.4 0 47.8-21.4 47.8-47.8V111.8c0-26.4-21.4-47.8-47.8-47.8zm189.4 37.7L416 177.3v157.4l109.6 75.5c21.2 14.6 50.4-.3 50.4-25.8V127.5c0-25.4-29.1-40.4-50.4-25.8z"}}]})(e)}var vn=n(579);const wn=()=>{const[e,t]=(0,E.useState)(!1),[n,a]=(0,E.useState)(!1),[s,r]=(0,E.useState)(!1),[i,o]=(0,E.useState)(null),c=Te(),l=Re();(0,E.useEffect)(()=>{const e=()=>{a(window.scrollY>50)};return window.addEventListener("scroll",e),()=>window.removeEventListener("scroll",e)},[]),(0,E.useEffect)(()=>{t(!1)},[c]),(0,E.useEffect)(()=>{const e=localStorage.getItem("token"),t=localStorage.getItem("user");if(e&&t)try{o(JSON.parse(t)),r(!0)}catch(n){console.error("Error parsing user data:",n),r(!1)}else r(!1),o(null)},[c]);return(0,vn.jsx)("nav",{className:"navbar ".concat(n?"scrolled":""),children:(0,vn.jsxs)("div",{className:"navbar-container",children:[(0,vn.jsxs)(tt,{to:"/",className:"navbar-logo",children:[(0,vn.jsx)("img",{src:"/yogaguru-icon-final.svg",alt:"YogaGuru Logo",className:"logo-icon"}),(0,vn.jsx)("span",{className:"logo-text",children:"YogaGuru"})]}),(0,vn.jsxs)("div",{className:"navbar-menu ".concat(e?"active":""),children:[(0,vn.jsx)("ul",{className:"navbar-links",children:[{path:"/",label:"Home"},{path:"/about",label:"About"},{path:"/features",label:"Features"},{path:"/how-it-works",label:"How It Works"},{path:"/pose-detection",label:"Pose Detection"},{path:"/tech-stack",label:"Tech Stack"},{path:"/results",label:"Results"},{path:"/team",label:"Team"},{path:"/contact",label:"Contact"}].map(e=>(0,vn.jsx)("li",{children:(0,vn.jsx)(tt,{to:e.path,className:c.pathname===e.path?"active":"",children:e.label})},e.path))}),(0,vn.jsxs)("div",{className:"navbar-mobile-footer",children:[(0,vn.jsxs)("div",{className:"mobile-contact",children:[(0,vn.jsx)("p",{children:"Contact for more information"}),(0,vn.jsx)("a",{href:"tel:+919265300000",children:"+91 92653***"})]}),(0,vn.jsxs)("div",{className:"mobile-social",children:[(0,vn.jsx)("a",{href:"https://github.com",target:"_blank",rel:"noopener noreferrer",children:(0,vn.jsx)(pt,{})}),(0,vn.jsx)("a",{href:"https://linkedin.com",target:"_blank",rel:"noopener noreferrer",children:(0,vn.jsx)(bt,{})}),(0,vn.jsx)("a",{href:"https://wa.me/919265300000",target:"_blank",rel:"noopener noreferrer",children:(0,vn.jsx)(St,{})}),(0,vn.jsx)("a",{href:"https://instagram.com",target:"_blank",rel:"noopener noreferrer",children:(0,vn.jsx)(gt,{})})]})]})]}),(0,vn.jsxs)("div",{className:"navbar-actions",children:[s?(0,vn.jsxs)(vn.Fragment,{children:[(0,vn.jsxs)(tt,{to:"/profile",className:"btn btn-profile",children:[(0,vn.jsx)(bn,{})," ",(null===i||void 0===i?void 0:i.name)||"Profile"]}),(0,vn.jsxs)("button",{className:"btn btn-logout-nav",onClick:()=>{localStorage.removeItem("token"),localStorage.removeItem("user"),r(!1),o(null),l("/"),window.location.reload()},children:[(0,vn.jsx)(dn,{})," Logout"]})]}):(0,vn.jsx)(tt,{to:"/login",className:"btn btn-secondary",children:"Login"}),(0,vn.jsx)("button",{className:"navbar-toggle",onClick:()=>t(!e),"aria-label":"Toggle navigation",children:e?(0,vn.jsx)(mn,{}):(0,vn.jsx)(Tt,{})})]})]})})},kn=()=>{const e=(new Date).getFullYear();return(0,vn.jsx)("footer",{className:"footer",children:(0,vn.jsxs)("div",{className:"footer-container",children:[(0,vn.jsxs)("div",{className:"footer-grid",children:[(0,vn.jsxs)("div",{className:"footer-brand",children:[(0,vn.jsxs)(tt,{to:"/",className:"footer-logo",children:[(0,vn.jsx)("img",{src:"/yogaguru-icon-final.svg",alt:"YogaGuru Logo",className:"footer-logo-icon"}),(0,vn.jsx)("span",{children:"YogaGuru"})]}),(0,vn.jsx)("p",{children:"AI-powered yoga pose detection platform helping you practice yoga correctly with real-time feedback and posture correction."}),(0,vn.jsxs)("div",{className:"footer-social",children:[(0,vn.jsx)("a",{href:"https://github.com",target:"_blank",rel:"noopener noreferrer","aria-label":"GitHub",children:(0,vn.jsx)(pt,{})}),(0,vn.jsx)("a",{href:"https://linkedin.com",target:"_blank",rel:"noopener noreferrer","aria-label":"LinkedIn",children:(0,vn.jsx)(bt,{})}),(0,vn.jsx)("a",{href:"https://twitter.com",target:"_blank",rel:"noopener noreferrer","aria-label":"Twitter",children:(0,vn.jsx)(kt,{})}),(0,vn.jsx)("a",{href:"https://instagram.com",target:"_blank",rel:"noopener noreferrer","aria-label":"Instagram",children:(0,vn.jsx)(gt,{})})]})]}),(0,vn.jsxs)("div",{className:"footer-links",children:[(0,vn.jsx)("h4",{children:"Quick Links"}),(0,vn.jsxs)("ul",{children:[(0,vn.jsx)("li",{children:(0,vn.jsx)(tt,{to:"/",children:"Home"})}),(0,vn.jsx)("li",{children:(0,vn.jsx)(tt,{to:"/about",children:"About Yoga"})}),(0,vn.jsx)("li",{children:(0,vn.jsx)(tt,{to:"/features",children:"Features"})}),(0,vn.jsx)("li",{children:(0,vn.jsx)(tt,{to:"/pose-detection",children:"Pose Detection"})})]})]}),(0,vn.jsxs)("div",{className:"footer-links",children:[(0,vn.jsx)("h4",{children:"Resources"}),(0,vn.jsxs)("ul",{children:[(0,vn.jsx)("li",{children:(0,vn.jsx)(tt,{to:"/how-it-works",children:"How It Works"})}),(0,vn.jsx)("li",{children:(0,vn.jsx)(tt,{to:"/tech-stack",children:"Technology"})}),(0,vn.jsx)("li",{children:(0,vn.jsx)(tt,{to:"/results",children:"Results"})}),(0,vn.jsx)("li",{children:(0,vn.jsx)(tt,{to:"/team",children:"Our Team"})})]})]}),(0,vn.jsxs)("div",{className:"footer-contact",children:[(0,vn.jsx)("h4",{children:"Contact"}),(0,vn.jsxs)("ul",{children:[(0,vn.jsxs)("li",{children:[(0,vn.jsx)("span",{children:"Email:"}),(0,vn.jsx)("a",{href:"mailto:contact@yogaguru.com",children:"contact@yogaguru.com"})]}),(0,vn.jsxs)("li",{children:[(0,vn.jsx)("span",{children:"Phone:"}),(0,vn.jsx)("a",{href:"tel:+919265300000",children:"+91 92653 00000"})]}),(0,vn.jsxs)("li",{children:[(0,vn.jsx)("span",{children:"Address:"}),(0,vn.jsx)("p",{children:"Your College Name, City, State"})]})]})]})]}),(0,vn.jsxs)("div",{className:"footer-bottom",children:[(0,vn.jsxs)("p",{children:["\xa9 ",e," Created with ",(0,vn.jsx)(Yt,{className:"heart-icon"})," by YogaGuru Team"]}),(0,vn.jsx)("p",{className:"footer-tagline",children:"All rights reserved."})]})]})})},Sn=()=>{const e=[{icon:(0,vn.jsx)(Qt,{}),title:"Improve Posture",description:"Get real-time feedback to correct your yoga poses and maintain proper alignment."},{icon:(0,vn.jsx)(hn,{}),title:"Reduce Injuries",description:"AI-powered detection helps prevent injuries by identifying incorrect poses early."},{icon:(0,vn.jsx)(Et,{}),title:"Reduce Stress",description:"Practice yoga with confidence, reducing anxiety and promoting mental wellness."},{icon:(0,vn.jsx)(Vt,{}),title:"Increase Strength",description:"Build flexibility and strength with guided yoga practice and proper form."}],t=[{category:"Wellness Tips",items:[{title:"Gratitude",text:"This can help you shift your focus from negative thoughts to positive ones and improve your mental health."},{title:"Be Consistent",text:"Practice yoga consistently to see the best results."},{title:"Practice on Light Stomach",text:"Practicing yoga on a light stomach helps prevent discomfort and allows for better movement."}]},{category:"Science Behind Yoga",items:[{title:"Stress Relief",text:"Reduces cortisol levels for mental peace."},{title:"Brain Boost",text:"Enhances focus and memory through blood circulation."},{title:"Heart Health",text:"Improves cardiovascular efficiency through relaxation."}]},{category:"Yoga Insights",items:[{title:"Active Meditation",text:"A practice that involves being mindful while performing daily activities."},{title:"Face Yoga",text:"A series of facial exercises to tone muscles and improve skin health."},{title:"Chair Yoga",text:"A gentle practice using a chair for support, ideal for seniors."}]},{category:"Myths & Truths",items:[{title:"Myth: Yoga is not a workout",text:"Truth: The physical aspect of yoga was created to exhaust the body and mind."},{title:"Myth: Yoga is just for women",text:"Truth: Around 25% to 35% of yoga practitioners are men."},{title:"Myth: Yoga is purely physical",text:"Truth: It integrates mind, body, and soul."}]}],n=["Halasana","Sarvangasana","Padmasana","Mudrasana","Chakrasana","Bhujangasana","Tadasana","Dhanurasana","Vajrasana","Garudasana"],[a,s]=E.useState(0),[r,i]=E.useState(0);return(0,vn.jsxs)("div",{className:"home-page",children:[(0,vn.jsxs)("section",{className:"hero",children:[(0,vn.jsx)("div",{className:"hero-bg",children:(0,vn.jsxs)("div",{className:"bubble-container",children:[(0,vn.jsx)("div",{className:"bubble bubble-1"}),(0,vn.jsx)("div",{className:"bubble bubble-2"}),(0,vn.jsx)("div",{className:"bubble bubble-3"})]})}),(0,vn.jsxs)("div",{className:"container",children:[(0,vn.jsxs)("div",{className:"hero-content",children:[(0,vn.jsxs)("h1",{className:"animate-fadeInUp",children:[(0,vn.jsx)("span",{children:"YogaGuru"}),(0,vn.jsx)("br",{}),(0,vn.jsx)("span",{className:"hero-subtitle",children:"Your Path To Wellness Starts Here"})]}),(0,vn.jsx)("p",{className:"hero-tagline animate-fadeInUp",style:{animationDelay:"0.2s"},children:'"Balance, Breathe, Strengthen, Thrive"'}),(0,vn.jsxs)("div",{className:"hero-buttons animate-fadeInUp",style:{animationDelay:"0.4s"},children:[(0,vn.jsx)(tt,{to:"/pose-detection",className:"btn btn-primary",children:"Start Pose Detection"}),(0,vn.jsx)(tt,{to:"/about",className:"btn btn-outline",children:"Learn More"})]})]}),(0,vn.jsxs)("div",{className:"hero-visual animate-fadeInUp",style:{animationDelay:"0.6s"},children:[(0,vn.jsx)("div",{className:"laptop-mockup",children:(0,vn.jsx)("div",{className:"laptop-screen",children:(0,vn.jsxs)("div",{className:"insights-selector",children:[(0,vn.jsx)("h3",{children:"Insights, Science, and Myths"}),(0,vn.jsx)("div",{className:"insight-cards",children:t.map((e,t)=>(0,vn.jsxs)("button",{className:"insight-card ".concat(a===t?"active":""),onClick:()=>s(t),children:[(0,vn.jsx)("span",{children:e.category}),0===t&&(0,vn.jsx)(en,{}),1===t&&(0,vn.jsx)(Et,{}),2===t&&(0,vn.jsx)(Mt,{}),3===t&&(0,vn.jsx)(yn,{})]},t))}),(0,vn.jsx)("div",{className:"insight-content",children:t[a].items.map((e,t)=>(0,vn.jsxs)("div",{className:"insight-item",children:[(0,vn.jsx)("h4",{children:e.title}),(0,vn.jsx)("p",{children:e.text})]},t))})]})})}),(0,vn.jsx)("div",{className:"yoga-person",children:(0,vn.jsxs)("svg",{viewBox:"0 0 275 494",fill:"none",xmlns:"http://www.w3.org/2000/svg",children:[(0,vn.jsx)("path",{d:"M192.631 259.732C192.717 257.924 193.198 256.157 194.04 254.555C194.883 252.953 196.066 251.556 197.507 250.461C198.949 249.366 200.612 248.6 202.381 248.217C204.15 247.835 205.982 247.845 207.746 248.247L224.118 225.174L240.566 231.704L216.988 263.962C216.117 266.882 214.204 269.381 211.613 270.985C209.023 272.589 205.933 273.187 202.931 272.666C199.929 272.144 197.222 270.54 195.324 268.156C193.425 265.772 192.467 262.775 192.631 259.732L192.631 259.732Z",fill:"#A0616A"}),(0,vn.jsx)("path",{d:"M149.887 449.434H133.701L126 387L149.89 387.001L149.887 449.434Z",fill:"#F7D6C3"}),(0,vn.jsx)("path",{d:"M117.887 445.768H153.872V465.423H103V460.655C103 456.707 104.568 452.92 107.36 450.128C110.152 447.337 113.939 445.768 117.887 445.768Z",fill:"#2F2E41"}),(0,vn.jsx)("path",{d:"M220.784 478.297H204.597L196.897 415.863L220.786 415.864L220.784 478.297Z",fill:"#F7D6C3"}),(0,vn.jsx)("path",{d:"M188.267 473.672H224.252V493.327H173.38V488.558C173.38 484.61 174.949 480.824 177.74 478.032C180.532 475.24 184.319 473.672 188.267 473.672V473.672Z",fill:"#2F2E41"}),(0,vn.jsx)("path",{d:"M226.54 250.407L225.22 342.828L223.9 464.295L194.853 461.654L179.5 294.5L175.5 292L145.5 336L152 432L124.5 427.5L104.5 324.5L139.401 250.407H226.54Z",fill:"#2F2E41"}),(0,vn.jsx)("path",{d:"M136.506 256.252L130 254.5L152.635 142.834L144.219 108.61C143.781 106.83 144.012 104.951 144.868 103.329C145.724 101.707 147.144 100.456 148.861 99.8116L164.003 94.1339L169.352 79.4225L211.558 83.9705L212.596 95.4678C217.17 96.9346 254.833 109.478 252.234 123.77C249.67 137.877 234.525 182.259 233.756 184.508L231.104 248.157L230.778 248.32C230.385 248.516 201.294 262.821 169.689 262.818C158.56 262.818 147.112 261.043 136.506 256.252Z",fill:"#3F3D56"}),(0,vn.jsxs)("g",{className:"turning-head",children:[(0,vn.jsx)("path",{d:"M215.466 56.3296C223.516 41.603 218.104 23.1388 203.378 15.0885C188.651 7.03825 170.187 12.4505 162.136 27.177C154.086 41.9036 159.498 60.3678 174.225 68.4181C188.952 76.4683 207.416 71.0562 215.466 56.3296Z",fill:"#F7D6C3"}),(0,vn.jsx)("path",{d:"M213.416 71.1705C207.625 77.3396 196.869 74.0279 196.115 65.6001C196.055 64.9457 196.06 64.2872 196.127 63.6337C196.517 59.9006 198.674 56.5113 198.157 52.5696C198.04 51.5886 197.675 50.6537 197.095 49.8535C192.48 43.6736 181.647 52.6176 177.292 47.0232C174.621 43.5928 177.76 38.1918 175.711 34.3577C173.006 29.2974 164.994 31.7937 159.97 29.0224C154.38 25.939 154.714 17.3622 158.394 12.1453C162.881 5.78305 170.75 2.38819 178.52 1.89892C186.29 1.40965 194.007 3.51014 201.261 6.33722C209.504 9.54935 217.677 13.9885 222.749 21.2361C228.918 30.0498 229.511 41.899 226.426 52.205C224.55 58.4743 218.145 66.1328 213.416 71.1705Z",fill:"#2F2E41"})]}),(0,vn.jsxs)("g",{className:"waving-arm",children:[(0,vn.jsx)("path",{d:"M12.4471 106.262C14.1354 105.61 15.9462 105.336 17.7519 105.459C19.5576 105.582 21.3144 106.099 22.8985 106.975C24.4826 107.85 25.8554 109.063 26.9203 110.526C27.9852 111.99 28.7163 113.669 29.0621 115.445L56.7836 121.095L57.4593 138.778L18.4233 130.251C15.4002 130.634 12.3417 129.894 9.8272 128.173C7.31275 126.452 5.51707 123.868 4.78044 120.911C4.0438 117.954 4.41739 114.83 5.83041 112.13C7.24343 109.43 9.5977 107.342 12.4471 106.262Z",fill:"#F7D6C3"}),(0,vn.jsx)("path",{d:"M42.7306 117.07L104.711 120.57L151 100.5L172 123L164 134.5L104.711 149.783L34.7306 135.787L42.7306 117.07Z",fill:"#3F3D56"})]})]})})]})]}),(0,vn.jsx)("div",{className:"scroll-indicator",children:(0,vn.jsx)(Ot,{})})]}),(0,vn.jsx)("section",{className:"yoga-marquee",children:(0,vn.jsx)("div",{className:"marquee-content",children:(0,vn.jsxs)("div",{className:"marquee-inner",children:[n.map((e,t)=>(0,vn.jsx)("span",{children:e},t)),n.map((e,t)=>(0,vn.jsx)("span",{children:e},"dup-".concat(t)))]})})}),(0,vn.jsx)("section",{className:"section about-home gradient-bg-light",children:(0,vn.jsx)("div",{className:"container",children:(0,vn.jsxs)("div",{className:"about-grid",children:[(0,vn.jsx)("div",{className:"about-image",children:(0,vn.jsx)("img",{src:"https://i.pinimg.com/originals/56/42/db/5642dbe39105d8cfd0d90fc5be597eb8.jpg",alt:"Yoga Practice"})}),(0,vn.jsxs)("div",{className:"about-content",children:[(0,vn.jsx)("span",{children:"About Us"}),(0,vn.jsx)("h2",{children:"YogaGuru"}),(0,vn.jsx)("p",{children:"At YogaGuru, our mission is to integrate technology with wellness, empowering people to enhance their yoga practice through personalized, data-driven insights. We aim to make yoga accessible and effective for everyone, ensuring correct posture and alignment in every session."}),(0,vn.jsx)("p",{children:"We specialize in AI-powered yoga pose detection to provide real-time feedback to users on their yoga practice. Our platform helps users achieve accurate poses, avoid injuries, and deepen their yoga journey through technology-driven solutions."}),(0,vn.jsx)(tt,{to:"/about",className:"btn btn-primary",children:"Learn More About Yoga"})]})]})})}),(0,vn.jsx)("section",{className:"section benefits",children:(0,vn.jsxs)("div",{className:"container",children:[(0,vn.jsxs)("div",{className:"section-title",children:[(0,vn.jsx)("span",{children:"Why Choose YogaGuru"}),(0,vn.jsx)("h2",{children:"Benefits of AI-Powered Yoga"})]}),(0,vn.jsx)("div",{className:"benefits-grid",children:e.map((e,t)=>(0,vn.jsxs)("div",{className:"benefit-card card",children:[(0,vn.jsx)("div",{className:"icon-box",children:e.icon}),(0,vn.jsx)("h3",{children:e.title}),(0,vn.jsx)("p",{children:e.description})]},t))})]})}),(0,vn.jsx)("section",{className:"cta-section",children:(0,vn.jsx)("div",{className:"container",children:(0,vn.jsxs)("div",{className:"cta-content",children:[(0,vn.jsxs)("div",{className:"cta-text",children:[(0,vn.jsx)("h2",{children:"Ready to Start Your Yoga Journey?"}),(0,vn.jsx)("p",{children:"Experience AI-powered pose detection and get real-time feedback on your practice."})]}),(0,vn.jsx)("div",{className:"cta-buttons",children:(0,vn.jsxs)(tt,{to:"/pose-detection",className:"btn btn-primary",children:[(0,vn.jsx)(_t,{})," Start Pose Detection"]})})]})})}),(0,vn.jsx)("section",{className:"section faq-section",children:(0,vn.jsxs)("div",{className:"container",children:[(0,vn.jsxs)("div",{className:"section-title",children:[(0,vn.jsx)("span",{children:"Common Questions"}),(0,vn.jsx)("h2",{children:"Frequently Asked Questions"})]}),(0,vn.jsx)("div",{className:"accordion",children:[{q:"Can anyone do yoga?",a:"Yes! Yoga is suitable for people of all ages and fitness levels. Modifications and beginner-friendly classes are available."},{q:"How often should I practice yoga?",a:"Practicing 2-3 times a week is a great start. For maximum benefits, try to incorporate yoga into your daily routine."},{q:"What is the best time to practice yoga?",a:"Early morning or evening is ideal, but you can practice anytime that fits your schedule."},{q:"Do I need special equipment for yoga?",a:"A yoga mat is essential. Optional props like blocks, straps, and bolsters can provide additional support."},{q:"Is yoga pose detection suitable for beginners?",a:"Yes! It can provide real-time feedback to help beginners learn proper form and avoid injuries."}].map((e,t)=>(0,vn.jsxs)("div",{className:"accordion-item ".concat(r===t?"active":""),children:[(0,vn.jsxs)("div",{className:"accordion-header",onClick:()=>i(r===t?-1:t),children:[(0,vn.jsx)("span",{children:e.q}),(0,vn.jsx)(Ot,{className:"icon"})]}),(0,vn.jsx)("div",{className:"accordion-content",children:(0,vn.jsx)("p",{children:e.a})})]},t))})]})}),(0,vn.jsx)("section",{className:"quote-section",children:(0,vn.jsx)("div",{className:"container",children:(0,vn.jsx)("blockquote",{children:'"Yoga for Every Body, Every Journey."'})})})]})},Cn=()=>{const e=[{icon:(0,vn.jsx)(Yt,{}),title:"Physical Health",description:"Improves flexibility, strength, and cardiovascular health through regular practice."},{icon:(0,vn.jsx)($t,{}),title:"Mental Wellness",description:"Reduces stress, anxiety, and promotes mental clarity through mindful breathing."},{icon:(0,vn.jsx)(Nt,{}),title:"Balance & Harmony",description:"Creates balance between body, mind, and spirit for holistic well-being."},{icon:(0,vn.jsx)(Et,{}),title:"Cognitive Benefits",description:"Enhances focus, memory, and cognitive function through meditation practices."}];return(0,vn.jsxs)("div",{className:"about-page",children:[(0,vn.jsx)("section",{className:"page-hero",children:(0,vn.jsxs)("div",{className:"container",children:[(0,vn.jsx)("span",{className:"page-label",children:"Learn About"}),(0,vn.jsx)("h1",{children:"What is Yoga?"}),(0,vn.jsx)("p",{children:"Discover the ancient practice that has transformed millions of lives and how AI technology can enhance your yoga journey."})]})}),(0,vn.jsx)("section",{className:"section",children:(0,vn.jsx)("div",{className:"container",children:(0,vn.jsxs)("div",{className:"content-grid",children:[(0,vn.jsx)("div",{className:"content-image",children:(0,vn.jsx)("img",{src:"https://images.unsplash.com/photo-1544367567-0f2fcb009e0b?w=600",alt:"Yoga Practice"})}),(0,vn.jsxs)("div",{className:"content-text",children:[(0,vn.jsx)("h2",{children:"The Art of Yoga"}),(0,vn.jsx)("p",{children:"Yoga is an ancient practice that originated in India over 5,000 years ago. It encompasses physical postures (asanas), breathing techniques (pranayama), and meditation (dhyana) to achieve harmony between body, mind, and spirit."}),(0,vn.jsx)("p",{children:'The word "Yoga" comes from the Sanskrit word "Yuj," meaning to unite or join. It represents the union of individual consciousness with universal consciousness, leading to a state of complete harmony and inner peace.'}),(0,vn.jsx)("p",{children:"Today, yoga has evolved into various styles including Hatha, Vinyasa, Ashtanga, Bikram, and many more, each offering unique benefits and approaches to this transformative practice."})]})]})})}),(0,vn.jsx)("section",{className:"section benefits-section gradient-bg-light",children:(0,vn.jsxs)("div",{className:"container",children:[(0,vn.jsxs)("div",{className:"section-title",children:[(0,vn.jsx)("span",{children:"Why Practice Yoga"}),(0,vn.jsx)("h2",{children:"Benefits of Regular Practice"})]}),(0,vn.jsx)("div",{className:"benefits-grid",children:e.map((e,t)=>(0,vn.jsxs)("div",{className:"benefit-card card",children:[(0,vn.jsx)("div",{className:"icon-box",children:e.icon}),(0,vn.jsx)("h3",{children:e.title}),(0,vn.jsx)("p",{children:e.description})]},t))})]})}),(0,vn.jsx)("section",{className:"section",children:(0,vn.jsx)("div",{className:"container",children:(0,vn.jsxs)("div",{className:"content-grid reverse",children:[(0,vn.jsxs)("div",{className:"content-text",children:[(0,vn.jsx)("h2",{children:"Importance of Correct Posture"}),(0,vn.jsx)("p",{children:"Proper alignment in yoga poses is crucial for maximizing benefits and preventing injuries. When poses are performed correctly, energy flows freely through the body, muscles are engaged appropriately, and the practice becomes both safe and effective."}),(0,vn.jsx)("p",{children:"Correct posture ensures that you're targeting the right muscle groups, maintaining proper breathing patterns, and building strength in a balanced way. It's the foundation of a sustainable yoga practice."}),(0,vn.jsxs)("div",{className:"highlight-box",children:[(0,vn.jsx)(Pt,{}),(0,vn.jsx)("span",{children:"Proper alignment can increase the effectiveness of your practice by up to 40%"})]})]}),(0,vn.jsx)("div",{className:"content-image",children:(0,vn.jsx)("img",{src:"https://images.unsplash.com/photo-1506126613408-eca07ce68773?w=600",alt:"Correct Yoga Posture"})})]})})}),(0,vn.jsx)("section",{className:"section problems-section",children:(0,vn.jsxs)("div",{className:"container",children:[(0,vn.jsxs)("div",{className:"section-title",children:[(0,vn.jsx)("span",{children:"Understanding the Risks"}),(0,vn.jsx)("h2",{children:"Problems with Incorrect Yoga Practice"})]}),(0,vn.jsxs)("div",{className:"problems-content",children:[(0,vn.jsx)("div",{className:"problems-image",children:(0,vn.jsx)(qt,{className:"warning-icon"})}),(0,vn.jsxs)("div",{className:"problems-list",children:[(0,vn.jsx)("p",{children:"Practicing yoga with incorrect form can lead to various issues that may hinder your progress and cause long-term damage:"}),(0,vn.jsx)("ul",{children:["Muscle strain and chronic pain","Joint injuries and inflammation","Reduced flexibility over time","Poor breathing patterns","Decreased benefits from practice","Long-term spinal issues"].map((e,t)=>(0,vn.jsxs)("li",{children:[(0,vn.jsx)("span",{className:"bullet"}),e]},t))}),(0,vn.jsx)("p",{className:"note",children:"This is why proper guidance and feedback are essential, especially for beginners who are still learning the correct forms."})]})]})]})}),(0,vn.jsx)("section",{className:"section ai-section gradient-bg-light",children:(0,vn.jsx)("div",{className:"container",children:(0,vn.jsxs)("div",{className:"content-grid",children:[(0,vn.jsxs)("div",{className:"content-text",children:[(0,vn.jsx)("span",{className:"section-label",children:"Technology Meets Tradition"}),(0,vn.jsx)("h2",{children:"How AI Helps in Yoga Training"}),(0,vn.jsx)("p",{children:"Artificial Intelligence has revolutionized how we approach yoga practice. By using computer vision and machine learning, AI can analyze your poses in real-time and provide instant feedback, just like having a personal yoga instructor available 24/7."}),(0,vn.jsx)("ul",{className:"ai-benefits-list",children:["Real-time pose detection and correction","Personalized feedback based on your body","Tracking progress over time","Preventing injuries before they happen","Making yoga accessible to beginners","Providing consistent guidance 24/7"].map((e,t)=>(0,vn.jsxs)("li",{children:[(0,vn.jsx)(ln,{}),(0,vn.jsx)("span",{children:e})]},t))})]}),(0,vn.jsx)("div",{className:"content-visual",children:(0,vn.jsxs)("div",{className:"ai-visual-card",children:[(0,vn.jsx)("div",{className:"ai-icon",children:(0,vn.jsx)(ln,{})}),(0,vn.jsx)("h3",{children:"AI-Powered Detection"}),(0,vn.jsx)("p",{children:"Our system uses advanced pose estimation algorithms to detect 33 body keypoints and analyze your posture with 95%+ accuracy."})]})})]})})}),(0,vn.jsx)("section",{className:"cta-section",children:(0,vn.jsxs)("div",{className:"container",children:[(0,vn.jsx)("h2",{children:"Ready to Transform Your Practice?"}),(0,vn.jsx)("p",{children:"Start your AI-guided yoga journey today and experience the difference."}),(0,vn.jsxs)("div",{className:"cta-buttons",children:[(0,vn.jsx)(tt,{to:"/pose-detection",className:"btn btn-primary",children:"Try Pose Detection"}),(0,vn.jsx)(tt,{to:"/features",className:"btn btn-outline",children:"Explore Features"})]})]})})]})},In=()=>{const e=[{icon:(0,vn.jsx)(xn,{}),title:"Real-time Pose Detection",description:"Our AI system analyzes your yoga poses in real-time using your webcam, providing instant feedback on your form and alignment.",color:"#a177b4"},{icon:(0,vn.jsx)(cn,{}),title:"Skeleton Keypoint Tracking",description:"Advanced pose estimation tracks 33 body keypoints to create a precise skeleton overlay, ensuring accurate pose analysis.",color:"#9fc5a7"},{icon:(0,vn.jsx)(Bt,{}),title:"Posture Correction Feedback",description:"Receive detailed instructions on how to correct your posture, with specific guidance for each body part.",color:"#f39c12"},{icon:(0,vn.jsx)(an,{}),title:"Beginner-Friendly UI",description:"Clean and intuitive interface designed for users of all skill levels, making yoga practice accessible to everyone.",color:"#3498db"},{icon:(0,vn.jsx)(_t,{}),title:"Camera-based Practice",description:"Simply use your device camera to practice yoga anywhere - no special equipment or sensors required.",color:"#e74c3c"},{icon:(0,vn.jsx)(At,{}),title:"ML-powered Accuracy",description:"Our machine learning models continuously improve, providing increasingly accurate pose detection over time.",color:"#2ecc71"}],t=[{icon:(0,vn.jsx)(Lt,{}),title:"Customizable Settings",description:"Adjust sensitivity, camera preferences, and feedback options to match your needs."},{icon:(0,vn.jsx)(hn,{}),title:"Privacy First",description:"All processing happens locally - your video never leaves your device."}];return(0,vn.jsxs)("div",{className:"features-page",children:[(0,vn.jsx)("section",{className:"page-hero",children:(0,vn.jsxs)("div",{className:"container",children:[(0,vn.jsx)("span",{className:"page-label",children:"Discover"}),(0,vn.jsx)("h1",{children:"Platform Features"}),(0,vn.jsx)("p",{children:"Explore the powerful features that make YogaGuru the ultimate AI-powered yoga practice companion."})]})}),(0,vn.jsx)("section",{className:"section",children:(0,vn.jsx)("div",{className:"container",children:(0,vn.jsx)("div",{className:"features-grid",children:e.map((e,t)=>(0,vn.jsxs)("div",{className:"feature-item card",children:[(0,vn.jsx)("div",{className:"feature-icon",style:{backgroundColor:"".concat(e.color,"20"),color:e.color},children:e.icon}),(0,vn.jsx)("h3",{children:e.title}),(0,vn.jsx)("p",{children:e.description})]},t))})})}),(0,vn.jsx)("section",{className:"section highlight-section gradient-bg-light",children:(0,vn.jsx)("div",{className:"container",children:(0,vn.jsxs)("div",{className:"highlight-grid",children:[(0,vn.jsxs)("div",{className:"highlight-content",children:[(0,vn.jsx)("span",{className:"section-label",children:"Core Technology"}),(0,vn.jsx)("h2",{children:"Advanced Pose Estimation"}),(0,vn.jsx)("p",{children:"Our system uses state-of-the-art TensorFlow.js and MediaPipe Pose models to detect and track body keypoints with exceptional accuracy. The AI analyzes your posture in real-time, comparing it against ideal yoga poses to provide actionable feedback."}),(0,vn.jsxs)("ul",{className:"highlight-list",children:[(0,vn.jsx)("li",{children:"33 body keypoints tracked simultaneously"}),(0,vn.jsx)("li",{children:"Real-time processing at 30+ FPS"}),(0,vn.jsx)("li",{children:"Works with any standard webcam"}),(0,vn.jsx)("li",{children:"Browser-based - no installation required"})]}),(0,vn.jsx)(tt,{to:"/pose-detection",className:"btn btn-primary",children:"Try It Now"})]}),(0,vn.jsx)("div",{className:"highlight-visual",children:(0,vn.jsxs)("div",{className:"pose-demo",children:[(0,vn.jsx)("div",{className:"skeleton-preview",children:(0,vn.jsxs)("svg",{viewBox:"0 0 200 300",fill:"none",children:[(0,vn.jsx)("circle",{cx:"100",cy:"30",r:"20",stroke:"#a177b4",strokeWidth:"3"}),(0,vn.jsx)("line",{x1:"100",y1:"50",x2:"100",y2:"120",stroke:"#a177b4",strokeWidth:"3"}),(0,vn.jsx)("line",{x1:"100",y1:"70",x2:"50",y2:"100",stroke:"#a177b4",strokeWidth:"3"}),(0,vn.jsx)("line",{x1:"100",y1:"70",x2:"150",y2:"100",stroke:"#a177b4",strokeWidth:"3"}),(0,vn.jsx)("line",{x1:"100",y1:"120",x2:"60",y2:"200",stroke:"#a177b4",strokeWidth:"3"}),(0,vn.jsx)("line",{x1:"100",y1:"120",x2:"140",y2:"200",stroke:"#a177b4",strokeWidth:"3"}),(0,vn.jsx)("line",{x1:"60",y1:"200",x2:"50",y2:"280",stroke:"#a177b4",strokeWidth:"3"}),(0,vn.jsx)("line",{x1:"140",y1:"200",x2:"150",y2:"280",stroke:"#a177b4",strokeWidth:"3"}),(0,vn.jsx)("circle",{cx:"100",cy:"30",r:"5",fill:"#a177b4"}),(0,vn.jsx)("circle",{cx:"100",cy:"70",r:"5",fill:"#a177b4"}),(0,vn.jsx)("circle",{cx:"50",cy:"100",r:"5",fill:"#a177b4"}),(0,vn.jsx)("circle",{cx:"150",cy:"100",r:"5",fill:"#a177b4"}),(0,vn.jsx)("circle",{cx:"100",cy:"120",r:"5",fill:"#a177b4"}),(0,vn.jsx)("circle",{cx:"60",cy:"200",r:"5",fill:"#a177b4"}),(0,vn.jsx)("circle",{cx:"140",cy:"200",r:"5",fill:"#a177b4"}),(0,vn.jsx)("circle",{cx:"50",cy:"280",r:"5",fill:"#a177b4"}),(0,vn.jsx)("circle",{cx:"150",cy:"280",r:"5",fill:"#a177b4"})]})}),(0,vn.jsxs)("div",{className:"demo-labels",children:[(0,vn.jsx)("span",{className:"label label-1",children:"Head Position"}),(0,vn.jsx)("span",{className:"label label-2",children:"Shoulder Alignment"}),(0,vn.jsx)("span",{className:"label label-3",children:"Hip Angle"})]})]})})]})})}),(0,vn.jsx)("section",{className:"section",children:(0,vn.jsxs)("div",{className:"container",children:[(0,vn.jsxs)("div",{className:"section-title",children:[(0,vn.jsx)("span",{children:"More Features"}),(0,vn.jsx)("h2",{children:"Designed for Your Practice"})]}),(0,vn.jsx)("div",{className:"additional-grid",children:t.map((e,t)=>(0,vn.jsxs)("div",{className:"additional-card",children:[(0,vn.jsx)("div",{className:"icon-box",children:e.icon}),(0,vn.jsxs)("div",{className:"additional-content",children:[(0,vn.jsx)("h3",{children:e.title}),(0,vn.jsx)("p",{children:e.description})]})]},t))})]})}),(0,vn.jsx)("section",{className:"cta-section",children:(0,vn.jsxs)("div",{className:"container",children:[(0,vn.jsx)("h2",{children:"Experience All Features"}),(0,vn.jsx)("p",{children:"Start your AI-guided yoga practice and discover the full potential of YogaGuru."}),(0,vn.jsx)(tt,{to:"/pose-detection",className:"btn btn-primary",children:"Start Pose Detection"})]})})]})},Nn=()=>{const e=[{number:"01",icon:(0,vn.jsx)(_t,{}),title:"Open Camera",description:"Grant camera access and position yourself in front of your device. Make sure you have enough space to perform yoga poses and good lighting for accurate detection.",tips:["Stand 6-8 feet from camera","Ensure good lighting","Wear fitted clothing"]},{number:"02",icon:(0,vn.jsx)(gn,{}),title:"Body Keypoint Detection",description:"Our AI system automatically detects 33 key points on your body including joints, extremities, and facial landmarks to create a precise skeleton model.",tips:["Stay within camera frame","Face the camera directly","Keep full body visible"]},{number:"03",icon:(0,vn.jsx)(Et,{}),title:"AI Pose Analysis",description:"The machine learning model analyzes the angles and positions of your keypoints, comparing them against our database of correct yoga poses.",tips:["Hold poses steadily","Follow on-screen guidance","Move slowly for best detection"]},{number:"04",icon:(0,vn.jsx)(Dt,{}),title:"Pose Classification",description:"Your pose is classified and matched against known yoga asanas. The system determines which pose you're attempting and evaluates your accuracy.",tips:["Start with basic poses","Practice one pose at a time","Be patient with learning"]},{number:"05",icon:(0,vn.jsx)(Wt,{}),title:"Real-time Feedback",description:"Receive instant visual and text feedback on your screen showing your accuracy percentage, corrections needed, and tips for improvement.",tips:["Follow correction suggestions","Track your progress","Practice regularly"]}];return(0,vn.jsxs)("div",{className:"how-it-works-page",children:[(0,vn.jsx)("section",{className:"page-hero",children:(0,vn.jsxs)("div",{className:"container",children:[(0,vn.jsx)("span",{className:"page-label",children:"Step by Step"}),(0,vn.jsx)("h1",{children:"How It Works"}),(0,vn.jsx)("p",{children:"Follow these simple steps to start practicing yoga with AI-powered pose detection and real-time feedback."})]})}),(0,vn.jsx)("section",{className:"section steps-section",children:(0,vn.jsx)("div",{className:"container",children:(0,vn.jsx)("div",{className:"steps-container",children:e.map((t,n)=>(0,vn.jsxs)("div",{className:"step-item ".concat(n%2===1?"reverse":""),children:[(0,vn.jsxs)("div",{className:"step-visual",children:[(0,vn.jsx)("div",{className:"step-number",children:t.number}),(0,vn.jsx)("div",{className:"step-icon-container",children:(0,vn.jsx)("div",{className:"step-icon",children:t.icon})})]}),(0,vn.jsxs)("div",{className:"step-content",children:[(0,vn.jsx)("h3",{children:t.title}),(0,vn.jsx)("p",{children:t.description}),(0,vn.jsxs)("div",{className:"step-tips",children:[(0,vn.jsx)("h4",{children:"Tips:"}),(0,vn.jsx)("ul",{children:t.tips.map((e,t)=>(0,vn.jsx)("li",{children:e},t))})]})]}),n<e.length-1&&(0,vn.jsx)("div",{className:"step-connector",children:(0,vn.jsx)(It,{})})]},n))})})}),(0,vn.jsx)("section",{className:"section flow-section gradient-bg-light",children:(0,vn.jsxs)("div",{className:"container",children:[(0,vn.jsxs)("div",{className:"section-title",children:[(0,vn.jsx)("span",{children:"Visual Overview"}),(0,vn.jsx)("h2",{children:"The Detection Flow"})]}),(0,vn.jsxs)("div",{className:"flow-diagram",children:[(0,vn.jsxs)("div",{className:"flow-item",children:[(0,vn.jsx)("div",{className:"flow-icon",children:(0,vn.jsx)(_t,{})}),(0,vn.jsx)("span",{children:"Camera Input"})]}),(0,vn.jsx)("div",{className:"flow-arrow",children:"\u2192"}),(0,vn.jsxs)("div",{className:"flow-item",children:[(0,vn.jsx)("div",{className:"flow-icon",children:(0,vn.jsx)(gn,{})}),(0,vn.jsx)("span",{children:"Keypoint Detection"})]}),(0,vn.jsx)("div",{className:"flow-arrow",children:"\u2192"}),(0,vn.jsxs)("div",{className:"flow-item",children:[(0,vn.jsx)("div",{className:"flow-icon",children:(0,vn.jsx)(Et,{})}),(0,vn.jsx)("span",{children:"ML Processing"})]}),(0,vn.jsx)("div",{className:"flow-arrow",children:"\u2192"}),(0,vn.jsxs)("div",{className:"flow-item",children:[(0,vn.jsx)("div",{className:"flow-icon",children:(0,vn.jsx)(Dt,{})}),(0,vn.jsx)("span",{children:"Classification"})]}),(0,vn.jsx)("div",{className:"flow-arrow",children:"\u2192"}),(0,vn.jsxs)("div",{className:"flow-item",children:[(0,vn.jsx)("div",{className:"flow-icon",children:(0,vn.jsx)(Wt,{})}),(0,vn.jsx)("span",{children:"Feedback Display"})]})]})]})}),(0,vn.jsx)("section",{className:"section requirements-section",children:(0,vn.jsxs)("div",{className:"container",children:[(0,vn.jsxs)("div",{className:"section-title",children:[(0,vn.jsx)("span",{children:"Before You Start"}),(0,vn.jsx)("h2",{children:"Requirements"})]}),(0,vn.jsxs)("div",{className:"requirements-grid",children:[(0,vn.jsxs)("div",{className:"requirement-card",children:[(0,vn.jsx)("h3",{children:"Device"}),(0,vn.jsxs)("ul",{children:[(0,vn.jsx)("li",{children:"Computer, tablet, or smartphone"}),(0,vn.jsx)("li",{children:"Working webcam or front camera"}),(0,vn.jsx)("li",{children:"Modern web browser (Chrome, Firefox, Safari)"})]})]}),(0,vn.jsxs)("div",{className:"requirement-card",children:[(0,vn.jsx)("h3",{children:"Environment"}),(0,vn.jsxs)("ul",{children:[(0,vn.jsx)("li",{children:"Well-lit room"}),(0,vn.jsx)("li",{children:"Plain background preferred"}),(0,vn.jsx)("li",{children:"Enough space to move freely"})]})]}),(0,vn.jsxs)("div",{className:"requirement-card",children:[(0,vn.jsx)("h3",{children:"Attire"}),(0,vn.jsxs)("ul",{children:[(0,vn.jsx)("li",{children:"Comfortable, fitted clothing"}),(0,vn.jsx)("li",{children:"Avoid baggy clothes"}),(0,vn.jsx)("li",{children:"Contrasting colors to background"})]})]})]})]})}),(0,vn.jsx)("section",{className:"cta-section",children:(0,vn.jsxs)("div",{className:"container",children:[(0,vn.jsx)("h2",{children:"Ready to Begin?"}),(0,vn.jsx)("p",{children:"Start practicing yoga with real-time AI guidance now."}),(0,vn.jsx)(tt,{to:"/pose-detection",className:"btn btn-primary",children:"Start Pose Detection"})]})})]})},Tn=()=>{const e=Re(),[t,n]=(0,E.useState)([]),[a,s]=(0,E.useState)(""),[r,i]=(0,E.useState)("all"),o=(e,t)=>{var n,a,s;const r={Tadasana:"https://images.unsplash.com/photo-1545389336-cf090694435e?w=600&h=400&fit=crop&auto=format&q=80",Vrikshasana:"https://images.unsplash.com/photo-1758274525911-402f99afec14?w=600&h=400&fit=crop&auto=format&q=80",Bhujangasana:"https://images.unsplash.com/photo-1717821552922-61e18814a44a?w=600&h=400&fit=crop&auto=format&q=80","Setu Bandhasana":"https://images.unsplash.com/photo-1767611086180-6b1176976371?w=600&h=400&fit=crop&auto=format&q=80",Virabhadrasana:"https://images.unsplash.com/photo-1758599878236-47f6a918aed2?w=600&h=400&fit=crop&auto=format&q=80",Anjaneyasana:"https://images.unsplash.com/photo-1506126613408-eca07ce68773?w=600&h=400&fit=crop&auto=format&q=80",Paschimottanasana:"https://images.unsplash.com/photo-1506126613408-eca07ce68773?w=600&h=400&fit=crop&auto=format&q=80","Ardha Matsyendrasana":"https://images.unsplash.com/photo-1506126613408-eca07ce68773?w=600&h=400&fit=crop&auto=format&q=80",Gomukhasana:"https://images.unsplash.com/photo-1506126613408-eca07ce68773?w=600&h=400&fit=crop&auto=format&q=80",Garudasana:"https://images.unsplash.com/photo-1506126613408-eca07ce68773?w=600&h=400&fit=crop&auto=format&q=80","Supta Padangusthasana":"https://images.unsplash.com/photo-1506126613408-eca07ce68773?w=600&h=400&fit=crop&auto=format&q=80",Marjariasana:"https://images.unsplash.com/photo-1758599881262-7b79a56ac284?w=600&h=400&fit=crop&auto=format&q=80",Pavanamuktasana:"https://images.unsplash.com/photo-1506126613408-eca07ce68773?w=600&h=400&fit=crop&auto=format&q=80",Uttanasana:"https://images.unsplash.com/photo-1506126613408-eca07ce68773?w=600&h=400&fit=crop&auto=format&q=80","Viparita Karani":"https://images.unsplash.com/photo-1506126613408-eca07ce68773?w=600&h=400&fit=crop&auto=format&q=80",Trikonasana:"https://images.unsplash.com/photo-1767611090899-163209a4ead1?w=600&h=400&fit=crop&auto=format&q=80","Adho Mukha Svanasana":"https://images.unsplash.com/photo-1767611121194-3cb554c9a9ec?w=600&h=400&fit=crop&auto=format&q=80","Surya Namaskar":"https://images.unsplash.com/photo-1606663368493-131f4f97c095?w=600&h=400&fit=crop&auto=format&q=80",Balasana:"https://images.unsplash.com/photo-1767611118672-d3887038786c?w=600&h=400&fit=crop&auto=format&q=80",Padmasana:"https://images.unsplash.com/photo-1577344718665-3e7c0c1ecf6b?w=600&h=400&fit=crop&auto=format&q=80",Vajrasana:"https://images.unsplash.com/photo-1697274834392-04ff3b76ef20?w=600&h=400&fit=crop&auto=format&q=80"};if(r[t])return r[t];const i=((null===(n=t.split("(")[1])||void 0===n||null===(a=n.split(")")[0])||void 0===a?void 0:a.trim())||(null===(s=t.split("-")[1])||void 0===s?void 0:s.trim())||"yoga pose").toLowerCase().replace(/\s+/g,"%20").replace(/[^a-z0-9%]/g,"");return"https://source.unsplash.com/600x400/?yoga%20".concat(i,"&sig=").concat(e)};(0,E.useEffect)(()=>{const e=[{id:1,name:"\u0aad\u0ac1\u0a9c\u0a82\u0a97\u0abe\u0ab8\u0aa8 (Bhujangasana) - Cobra Pose",image:o(1,"Bhujangasana"),description:"A gentle backbend that strengthens the spine and opens the chest. This pose helps relieve back pain by stretching the front body and strengthening the back muscles.",difficulty:"Beginner",duration:"30-60 seconds",category:"Pain Relief"},{id:2,name:"\u0ab5\u0ac0\u0ab0\u0aad\u0aa6\u0acd\u0ab0\u0abe\u0ab8\u0aa8 II (Virabhadrasana II) - Warrior II",image:"https://images.unsplash.com/photo-1758599878236-47f6a918aed2?w=600&h=400&fit=crop&auto=format&q=80",description:"A powerful standing pose that strengthens the legs and opens the hips.",difficulty:"Intermediate",duration:"30-60 seconds",category:"Pain Relief"},{id:3,name:"\u0aae\u0abe\u0ab0\u0acd\u0a9c\u0ab0\u0ac0\u0a86\u0ab8\u0aa8 (Marjariasana) - Cat-Cow Pose",image:o(3,"Marjariasana"),description:"A gentle flowing movement that warms up the spine.",difficulty:"Beginner",duration:"1-2 minutes",category:"Pain Relief"},{id:4,name:"\u0ab8\u0ac7\u0aa4\u0ac1 \u0aac\u0a82\u0aa7\u0abe\u0ab8\u0aa8 (Setu Bandhasana) - Bridge Pose",image:o(4,"Setu Bandhasana"),description:"A gentle backbend that strengthens the back muscles.",difficulty:"Beginner",duration:"30-60 seconds",category:"Pain Relief"},{id:5,name:"\u0aa4\u0acd\u0ab0\u0abf\u0a95\u0acb\u0aa3\u0abe\u0ab8\u0aa8 (Trikonasana) - Triangle Pose",image:o(14,"Trikonasana"),description:"A standing pose that strengthens legs and relieves back pain.",difficulty:"Intermediate",duration:"30-60 seconds",category:"Pain Relief"},{id:6,name:"\u0aa4\u0abe\u0aa1\u0abe\u0ab8\u0aa8 (Tadasana) - Mountain Pose",image:o(63,"Tadasana"),description:"A foundational standing pose that improves posture.",difficulty:"Beginner",duration:"30-60 seconds",category:"Age Groups"},{id:7,name:"\u0ab5\u0ac3\u0a95\u0acd\u0ab7\u0abe\u0ab8\u0aa8 (Vrikshasana) - Tree Pose",image:o(64,"Vrikshasana"),description:"A balancing pose that strengthens legs and improves focus.",difficulty:"Beginner",duration:"30-60 seconds",category:"Age Groups"},{id:8,name:"\u0a85\u0aa7\u0acb \u0aae\u0ac1\u0a96 \u0ab6\u0acd\u0ab5\u0abe\u0aa8\u0abe\u0ab8\u0aa8 (Adho Mukha Svanasana) - Downward-Facing Dog",image:o(15,"Adho Mukha Svanasana"),description:"An inversion that strengthens the entire body.",difficulty:"Beginner",duration:"30-60 seconds",category:"Pain Relief"},{id:9,name:"\u0ab8\u0ac2\u0ab0\u0acd\u0aaf \u0aa8\u0aae\u0ab8\u0acd\u0a95\u0abe\u0ab0 (Surya Namaskar) - Sun Salutation",image:o(16,"Surya Namaskar"),description:"A complete sequence of 12 poses for full-body workout.",difficulty:"Intermediate",duration:"5-10 minutes",category:"Disease-Specific"},{id:10,name:"\u0aac\u0abe\u0ab2\u0abe\u0ab8\u0aa8 (Balasana) - Child's Pose",image:o(48,"Balasana"),description:"A restorative pose that calms the mind and stretches the back.",difficulty:"Beginner",duration:"1-3 minutes",category:"Disease-Specific"},{id:11,name:"\u0aaa\u0aa6\u0acd\u0aae\u0abe\u0ab8\u0aa8 (Padmasana) - Lotus Pose",image:o(34,"Padmasana"),description:"A seated meditation pose that promotes calmness.",difficulty:"Intermediate",duration:"5-30 minutes",category:"Meditation"},{id:12,name:"\u0ab5\u0a9c\u0acd\u0ab0\u0abe\u0ab8\u0aa8 (Vajrasana) - Thunderbolt Pose",image:o(23,"Vajrasana"),description:"A seated pose that aids digestion and meditation.",difficulty:"Beginner",duration:"5-30 minutes",category:"Disease-Specific"}];n(e)},[]);const c=t.filter(e=>{const t=e.name.toLowerCase().includes(a.toLowerCase())||e.description.toLowerCase().includes(a.toLowerCase()),n="all"===r||e.difficulty.toLowerCase()===r.toLowerCase();return t&&n});return(0,vn.jsxs)("div",{className:"pose-detection-page",children:[(0,vn.jsx)("section",{className:"page-hero compact",children:(0,vn.jsxs)("div",{className:"container",children:[(0,vn.jsx)("h1",{children:"Yoga Pose Library"}),(0,vn.jsx)("p",{children:"Explore and practice yoga poses with real-time AI feedback"})]})}),(0,vn.jsx)("section",{className:"section filter-section",children:(0,vn.jsxs)("div",{className:"container",children:[(0,vn.jsxs)("div",{className:"search-filter-container",children:[(0,vn.jsx)("div",{className:"search-box",children:(0,vn.jsx)("input",{type:"text",placeholder:"Search poses...",value:a,onChange:e=>s(e.target.value),className:"search-input"})}),(0,vn.jsx)("div",{className:"filter-box",children:(0,vn.jsxs)("select",{value:r,onChange:e=>i(e.target.value),className:"filter-select",children:[(0,vn.jsx)("option",{value:"all",children:"All Difficulties"}),(0,vn.jsx)("option",{value:"beginner",children:"Beginner"}),(0,vn.jsx)("option",{value:"intermediate",children:"Intermediate"}),(0,vn.jsx)("option",{value:"advanced",children:"Advanced"})]})})]}),(0,vn.jsxs)("p",{className:"results-count",children:[c.length," pose",1!==c.length?"s":""," found"]})]})}),(0,vn.jsx)("section",{className:"section poses-grid-section",children:(0,vn.jsxs)("div",{className:"container",children:[(0,vn.jsx)("div",{className:"poses-grid",children:c.map(t=>(0,vn.jsxs)("div",{className:"pose-card-clickable",onClick:()=>(t=>{e("/pose/".concat(t.id),{state:{pose:t}})})(t),children:[(0,vn.jsxs)("div",{className:"pose-image-container",children:[(0,vn.jsx)("img",{src:t.image,alt:t.name,className:"pose-image",loading:"lazy",onError:e=>{const n="https://source.unsplash.com/400x300/?yoga&sig=".concat(t.id);e.target.src=n}}),(0,vn.jsx)("span",{className:"pose-difficulty-badge ".concat(t.difficulty.toLowerCase()),children:t.difficulty})]}),(0,vn.jsxs)("div",{className:"pose-content",children:[(0,vn.jsx)("h3",{className:"pose-name",children:t.name}),(0,vn.jsx)("p",{className:"pose-description",children:t.description}),(0,vn.jsxs)("div",{className:"pose-meta",children:[(0,vn.jsxs)("span",{className:"pose-duration",children:["\u23f1 ",t.duration]}),(0,vn.jsx)("span",{className:"pose-category",children:t.category})]}),(0,vn.jsx)("div",{className:"pose-action",children:(0,vn.jsxs)("span",{children:["View Details ",(0,vn.jsx)(It,{})]})})]})]},t.id))}),0===c.length&&(0,vn.jsx)("div",{className:"no-poses-found",children:(0,vn.jsx)("p",{children:"No poses found matching your search criteria."})})]})}),(0,vn.jsx)("section",{className:"section tips-section gradient-bg-light",children:(0,vn.jsxs)("div",{className:"container",children:[(0,vn.jsx)("div",{className:"section-title",children:(0,vn.jsx)("h2",{children:"Tips for Best Results"})}),(0,vn.jsxs)("div",{className:"tips-grid",children:[(0,vn.jsxs)("div",{className:"tip-card",children:[(0,vn.jsx)("div",{className:"tip-number",children:"1"}),(0,vn.jsx)("h4",{children:"Proper Lighting"}),(0,vn.jsx)("p",{children:"Ensure you have adequate lighting. Natural light works best for accurate detection."})]}),(0,vn.jsxs)("div",{className:"tip-card",children:[(0,vn.jsx)("div",{className:"tip-number",children:"2"}),(0,vn.jsx)("h4",{children:"Clear Background"}),(0,vn.jsx)("p",{children:"A plain background helps the AI distinguish your body more accurately."})]}),(0,vn.jsxs)("div",{className:"tip-card",children:[(0,vn.jsx)("div",{className:"tip-number",children:"3"}),(0,vn.jsx)("h4",{children:"Full Body View"}),(0,vn.jsx)("p",{children:"Position yourself so your entire body is visible in the camera frame."})]}),(0,vn.jsxs)("div",{className:"tip-card",children:[(0,vn.jsx)("div",{className:"tip-number",children:"4"}),(0,vn.jsx)("h4",{children:"Slow Movements"}),(0,vn.jsx)("p",{children:"Move slowly into poses to allow the system to track your movements accurately."})]})]})]})})]})};function En(e){return lt({tag:"svg",attr:{role:"img",viewBox:"0 0 24 24"},child:[{tag:"title",attr:{},child:[]},{tag:"path",attr:{d:"M7.157 22.201A1.784 1.799 0 0 1 5.374 24a1.784 1.799 0 0 1-1.784-1.799 1.784 1.799 0 0 1 1.784-1.799 1.784 1.799 0 0 1 1.783 1.799zM20.582 1.427a1.415 1.427 0 0 1-1.415 1.428 1.415 1.427 0 0 1-1.416-1.428A1.415 1.427 0 0 1 19.167 0a1.415 1.427 0 0 1 1.415 1.427zM4.992 3.336A1.047 1.056 0 0 1 3.946 4.39a1.047 1.056 0 0 1-1.047-1.055A1.047 1.056 0 0 1 3.946 2.28a1.047 1.056 0 0 1 1.046 1.056zm7.336 1.517c3.769 0 7.06 1.38 8.768 3.424a9.363 9.363 0 0 0-3.393-4.547 9.238 9.238 0 0 0-5.377-1.728A9.238 9.238 0 0 0 6.95 3.73a9.363 9.363 0 0 0-3.394 4.547c1.713-2.04 5.004-3.424 8.772-3.424zm.001 13.295c-3.768 0-7.06-1.381-8.768-3.425a9.363 9.363 0 0 0 3.394 4.547A9.238 9.238 0 0 0 12.33 21a9.238 9.238 0 0 0 5.377-1.729 9.363 9.363 0 0 0 3.393-4.547c-1.712 2.044-5.003 3.425-8.772 3.425Z"}}]})(e)}function Rn(e){return lt({tag:"svg",attr:{role:"img",viewBox:"0 0 24 24"},child:[{tag:"title",attr:{},child:[]},{tag:"path",attr:{d:"M11.8992.8525C8.735.8525 6.17 3.4175 6.17 6.5817c0 2.102 1.1321 3.9398 2.8198 4.9366l1.6412-2.7849c.0411-.0699.0176-.1593-.0495-.2048-.6233-.4227-1.0328-1.137-1.0328-1.947 0-1.298 1.0524-2.3504 2.3505-2.3504 1.2981 0 2.3505 1.0524 2.3505 2.3505 0 .8098-.4095 1.5242-1.0328 1.947-.0671.0454-.0907.1348-.0495.2047l1.6414 2.785c1.6878-.9969 2.8199-2.8346 2.8199-4.9367 0-3.1642-2.5653-5.7292-5.7295-5.7292zm-6.17 10.8366C2.565 11.6891 0 14.2541 0 17.4183c0 3.1642 2.565 5.7292 5.7292 5.7292 3.1798 0 5.8074-2.6995 5.7275-5.8762H8.2313c-.0847 0-.1513.0717-.1519.1564-.0082 1.266-1.0644 2.3411-2.3502 2.3411-1.2981 0-2.3505-1.0524-2.3505-2.3505 0-1.2982 1.0524-2.3505 2.3505-2.3505.34 0 .663.0724.9547.2022.0713.0318.1566.0077.1962-.0595l1.6464-2.7935c-.8273-.4636-1.7815-.7279-2.7973-.7279zm15.4424.7614l-1.6366 2.7878c-.041.07-.0172.1594.05.2048.624.4217 1.0348 1.1354 1.0363 1.9452.0022 1.298-1.0483 2.352-2.3465 2.3542-1.298.0023-2.3523-1.0482-2.3545-2.3462-.0015-.8098.4068-1.5248 1.0294-1.9486.067-.0457.0905-.1353.0492-.2051l-1.6464-2.7818c-1.6859.9998-2.8146 2.8394-2.811 4.9415.0056 3.1641 2.575 5.7248 5.7393 5.7192 3.1641-.0054 5.7246-2.575 5.7192-5.7392-.0037-2.1022-1.139-3.938-2.8284-4.9318z"}}]})(e)}function _n(e){return lt({tag:"svg",attr:{role:"img",viewBox:"0 0 24 24"},child:[{tag:"title",attr:{},child:[]},{tag:"path",attr:{d:"M1.292 5.856L11.54 0v24l-4.095-2.378V7.603l-6.168 3.564.015-5.31zm21.43 5.311l-.014-5.31L12.46 0v24l4.095-2.378V14.87l3.092 1.788-.018-4.618-3.074-1.756V7.603l6.168 3.564z"}}]})(e)}function An(e){return lt({tag:"svg",attr:{role:"img",viewBox:"0 0 24 24"},child:[{tag:"title",attr:{},child:[]},{tag:"path",attr:{d:"M23.15 2.587L18.21.21a1.494 1.494 0 0 0-1.705.29l-9.46 8.63-4.12-3.128a.999.999 0 0 0-1.276.057L.327 7.261A1 1 0 0 0 .326 8.74L3.899 12 .326 15.26a1 1 0 0 0 .001 1.479L1.65 17.94a.999.999 0 0 0 1.276.057l4.12-3.128 9.46 8.63a1.492 1.492 0 0 0 1.704.29l4.942-2.377A1.5 1.5 0 0 0 24 20.06V3.939a1.5 1.5 0 0 0-.85-1.352zm-5.146 14.861L10.826 12l7.178-5.448v10.896z"}}]})(e)}const Mn=()=>{const e=[{title:"Frontend Technologies",icon:(0,vn.jsx)(Jt,{}),color:"#61dafb",technologies:[{name:"HTML5",icon:(0,vn.jsx)(mt,{}),color:"#e34f26"},{name:"CSS3",icon:(0,vn.jsx)(ht,{}),color:"#1572b6"},{name:"JavaScript",icon:(0,vn.jsx)(yt,{}),color:"#f7df1e"},{name:"ReactJS",icon:(0,vn.jsx)(wt,{}),color:"#61dafb"}]},{title:"Backend Technologies",icon:(0,vn.jsx)(zt,{}),color:"#68a063",technologies:[{name:"Python",icon:(0,vn.jsx)(vt,{}),color:"#3776ab"},{name:"Node.js",icon:(0,vn.jsx)(xt,{}),color:"#68a063"},{name:"OpenCV",icon:(0,vn.jsx)(Rn,{}),color:"#5c3ee8"},{name:"TensorFlow",icon:(0,vn.jsx)(_n,{}),color:"#ff6f00"}]},{title:"Database",icon:(0,vn.jsx)(jt,{}),color:"#336791",technologies:[{name:"SQL Database",icon:(0,vn.jsx)(jt,{}),color:"#336791"}]},{title:"Development Tools",icon:(0,vn.jsx)(Ft,{}),color:"#007acc",technologies:[{name:"VS Code",icon:(0,vn.jsx)(An,{}),color:"#007acc"},{name:"Jupyter Notebook",icon:(0,vn.jsx)(En,{}),color:"#f37626"}]}];return(0,vn.jsxs)("div",{className:"tech-stack-page",children:[(0,vn.jsx)("section",{className:"page-hero",children:(0,vn.jsxs)("div",{className:"container",children:[(0,vn.jsx)("span",{className:"page-label",children:"Under the Hood"}),(0,vn.jsx)("h1",{children:"Technology Stack"}),(0,vn.jsx)("p",{children:"Explore the cutting-edge technologies powering YogaGuru's AI-based yoga pose detection platform."})]})}),(0,vn.jsx)("section",{className:"section",children:(0,vn.jsx)("div",{className:"container",children:(0,vn.jsx)("div",{className:"tech-categories",children:e.map((e,t)=>(0,vn.jsxs)("div",{className:"tech-category",children:[(0,vn.jsxs)("div",{className:"category-header",children:[(0,vn.jsx)("div",{className:"category-icon",style:{backgroundColor:"".concat(e.color,"20"),color:e.color},children:e.icon}),(0,vn.jsx)("h2",{children:e.title})]}),(0,vn.jsx)("div",{className:"tech-grid",children:e.technologies.map((e,t)=>(0,vn.jsxs)("div",{className:"tech-card",children:[(0,vn.jsx)("div",{className:"tech-icon",style:{color:e.color},children:e.icon}),(0,vn.jsx)("span",{children:e.name})]},t))})]},t))})})}),(0,vn.jsx)("section",{className:"section architecture-section gradient-bg-light",children:(0,vn.jsxs)("div",{className:"container",children:[(0,vn.jsxs)("div",{className:"section-title",children:[(0,vn.jsx)("span",{children:"System Design"}),(0,vn.jsx)("h2",{children:"Architecture Overview"})]}),(0,vn.jsx)("div",{className:"architecture-grid",children:[{layer:"Presentation Layer",description:"React-based user interface with responsive design",technologies:["React","CSS3","HTML5"]},{layer:"Application Layer",description:"Business logic and API endpoints",technologies:["Node.js","Python Flask"]},{layer:"ML Processing Layer",description:"Pose estimation and classification models",technologies:["TensorFlow.js","MediaPipe","OpenCV"]},{layer:"Data Layer",description:"User data and pose training datasets",technologies:["SQL Database","JSON"]}].map((e,t)=>(0,vn.jsxs)("div",{className:"layer-card",children:[(0,vn.jsx)("div",{className:"layer-number",children:t+1}),(0,vn.jsx)("h3",{children:e.layer}),(0,vn.jsx)("p",{children:e.description}),(0,vn.jsx)("div",{className:"layer-tech",children:e.technologies.map((e,t)=>(0,vn.jsx)("span",{className:"tech-tag",children:e},t))})]},t))})]})}),(0,vn.jsx)("section",{className:"section ml-section",children:(0,vn.jsx)("div",{className:"container",children:(0,vn.jsxs)("div",{className:"ml-content",children:[(0,vn.jsxs)("div",{className:"ml-text",children:[(0,vn.jsx)("span",{className:"section-label",children:"Core Technology"}),(0,vn.jsx)("h2",{children:"Machine Learning Models"}),(0,vn.jsx)("p",{children:"Our pose detection system uses state-of-the-art machine learning models to accurately identify and analyze yoga poses. The system combines multiple AI technologies to provide real-time feedback."}),(0,vn.jsxs)("div",{className:"ml-features",children:[(0,vn.jsxs)("div",{className:"ml-feature",children:[(0,vn.jsx)("h4",{children:"MediaPipe Pose"}),(0,vn.jsx)("p",{children:"Google's ML solution for high-fidelity body pose tracking"})]}),(0,vn.jsxs)("div",{className:"ml-feature",children:[(0,vn.jsx)("h4",{children:"TensorFlow.js"}),(0,vn.jsx)("p",{children:"Browser-based machine learning for real-time processing"})]}),(0,vn.jsxs)("div",{className:"ml-feature",children:[(0,vn.jsx)("h4",{children:"Custom Classifiers"}),(0,vn.jsx)("p",{children:"Trained models for yoga pose classification and scoring"})]})]})]}),(0,vn.jsx)("div",{className:"ml-visual",children:(0,vn.jsxs)("div",{className:"model-diagram",children:[(0,vn.jsx)("div",{className:"diagram-node input",children:(0,vn.jsx)("span",{children:"Camera Input"})}),(0,vn.jsx)("div",{className:"diagram-arrow",children:"\u2193"}),(0,vn.jsx)("div",{className:"diagram-node process",children:(0,vn.jsx)("span",{children:"Pose Estimation"})}),(0,vn.jsx)("div",{className:"diagram-arrow",children:"\u2193"}),(0,vn.jsx)("div",{className:"diagram-node process",children:(0,vn.jsx)("span",{children:"Keypoint Extraction"})}),(0,vn.jsx)("div",{className:"diagram-arrow",children:"\u2193"}),(0,vn.jsx)("div",{className:"diagram-node process",children:(0,vn.jsx)("span",{children:"Classification"})}),(0,vn.jsx)("div",{className:"diagram-arrow",children:"\u2193"}),(0,vn.jsx)("div",{className:"diagram-node output",children:(0,vn.jsx)("span",{children:"Feedback Output"})})]})})]})})}),(0,vn.jsx)("section",{className:"section stats-section",children:(0,vn.jsx)("div",{className:"container",children:(0,vn.jsxs)("div",{className:"stats-grid",children:[(0,vn.jsxs)("div",{className:"stat-item",children:[(0,vn.jsx)("h3",{children:"33"}),(0,vn.jsx)("p",{children:"Body Keypoints Tracked"})]}),(0,vn.jsxs)("div",{className:"stat-item",children:[(0,vn.jsx)("h3",{children:"30+"}),(0,vn.jsx)("p",{children:"FPS Real-time Processing"})]}),(0,vn.jsxs)("div",{className:"stat-item",children:[(0,vn.jsx)("h3",{children:"95%"}),(0,vn.jsx)("p",{children:"Detection Accuracy"})]}),(0,vn.jsxs)("div",{className:"stat-item",children:[(0,vn.jsx)("h3",{children:"10+"}),(0,vn.jsx)("p",{children:"Yoga Poses Supported"})]})]})})})]})};function Pn(e){return Pn="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},Pn(e)}function Dn(e){var t=function(e,t){if("object"!=Pn(e)||!e)return e;var n=e[Symbol.toPrimitive];if(void 0!==n){var a=n.call(e,t||"default");if("object"!=Pn(a))return a;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===t?String:Number)(e)}(e,"string");return"symbol"==Pn(t)?t:t+""}function On(e,t,n){return(t=Dn(t))in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function Fn(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter(function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable})),n.push.apply(n,a)}return n}function Ln(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?Fn(Object(n),!0).forEach(function(t){On(e,t,n[t])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):Fn(Object(n)).forEach(function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))})}return e}function zn(e){return e+.5|0}const Bn=(e,t,n)=>Math.max(Math.min(e,n),t);function jn(e){return Bn(zn(2.55*e),0,255)}function Wn(e){return Bn(zn(255*e),0,255)}function Vn(e){return Bn(zn(e/2.55)/100,0,1)}function Un(e){return Bn(zn(100*e),0,100)}const Hn={0:0,1:1,2:2,3:3,4:4,5:5,6:6,7:7,8:8,9:9,A:10,B:11,C:12,D:13,E:14,F:15,a:10,b:11,c:12,d:13,e:14,f:15},Gn=[..."0123456789ABCDEF"],qn=e=>Gn[15&e],Kn=e=>Gn[(240&e)>>4]+Gn[15&e],Xn=e=>(240&e)>>4===(15&e);function Yn(e){var t=(e=>Xn(e.r)&&Xn(e.g)&&Xn(e.b)&&Xn(e.a))(e)?qn:Kn;return e?"#"+t(e.r)+t(e.g)+t(e.b)+((e,t)=>e<255?t(e):"")(e.a,t):void 0}const Qn=/^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;function Zn(e,t,n){const a=t*Math.min(n,1-n),s=function(t){let s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:(t+e/30)%12;return n-a*Math.max(Math.min(s-3,9-s,1),-1)};return[s(0),s(8),s(4)]}function Jn(e,t,n){const a=function(a){let s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:(a+e/60)%6;return n-n*t*Math.max(Math.min(s,4-s,1),0)};return[a(5),a(3),a(1)]}function $n(e,t,n){const a=Zn(e,1,.5);let s;for(t+n>1&&(s=1/(t+n),t*=s,n*=s),s=0;s<3;s++)a[s]*=1-t-n,a[s]+=t;return a}function ea(e){const t=e.r/255,n=e.g/255,a=e.b/255,s=Math.max(t,n,a),r=Math.min(t,n,a),i=(s+r)/2;let o,c,l;return s!==r&&(l=s-r,c=i>.5?l/(2-s-r):l/(s+r),o=function(e,t,n,a,s){return e===s?(t-n)/a+(t<n?6:0):t===s?(n-e)/a+2:(e-t)/a+4}(t,n,a,l,s),o=60*o+.5),[0|o,c||0,i]}function ta(e,t,n,a){return(Array.isArray(t)?e(t[0],t[1],t[2]):e(t,n,a)).map(Wn)}function na(e,t,n){return ta(Zn,e,t,n)}function aa(e){return(e%360+360)%360}function sa(e){const t=Qn.exec(e);let n,a=255;if(!t)return;t[5]!==n&&(a=t[6]?jn(+t[5]):Wn(+t[5]));const s=aa(+t[2]),r=+t[3]/100,i=+t[4]/100;return n="hwb"===t[1]?function(e,t,n){return ta($n,e,t,n)}(s,r,i):"hsv"===t[1]?function(e,t,n){return ta(Jn,e,t,n)}(s,r,i):na(s,r,i),{r:n[0],g:n[1],b:n[2],a:a}}const ra={x:"dark",Z:"light",Y:"re",X:"blu",W:"gr",V:"medium",U:"slate",A:"ee",T:"ol",S:"or",B:"ra",C:"lateg",D:"ights",R:"in",Q:"turquois",E:"hi",P:"ro",O:"al",N:"le",M:"de",L:"yello",F:"en",K:"ch",G:"arks",H:"ea",I:"ightg",J:"wh"},ia={OiceXe:"f0f8ff",antiquewEte:"faebd7",aqua:"ffff",aquamarRe:"7fffd4",azuY:"f0ffff",beige:"f5f5dc",bisque:"ffe4c4",black:"0",blanKedOmond:"ffebcd",Xe:"ff",XeviTet:"8a2be2",bPwn:"a52a2a",burlywood:"deb887",caMtXe:"5f9ea0",KartYuse:"7fff00",KocTate:"d2691e",cSO:"ff7f50",cSnflowerXe:"6495ed",cSnsilk:"fff8dc",crimson:"dc143c",cyan:"ffff",xXe:"8b",xcyan:"8b8b",xgTMnPd:"b8860b",xWay:"a9a9a9",xgYF:"6400",xgYy:"a9a9a9",xkhaki:"bdb76b",xmagFta:"8b008b",xTivegYF:"556b2f",xSange:"ff8c00",xScEd:"9932cc",xYd:"8b0000",xsOmon:"e9967a",xsHgYF:"8fbc8f",xUXe:"483d8b",xUWay:"2f4f4f",xUgYy:"2f4f4f",xQe:"ced1",xviTet:"9400d3",dAppRk:"ff1493",dApskyXe:"bfff",dimWay:"696969",dimgYy:"696969",dodgerXe:"1e90ff",fiYbrick:"b22222",flSOwEte:"fffaf0",foYstWAn:"228b22",fuKsia:"ff00ff",gaRsbSo:"dcdcdc",ghostwEte:"f8f8ff",gTd:"ffd700",gTMnPd:"daa520",Way:"808080",gYF:"8000",gYFLw:"adff2f",gYy:"808080",honeyMw:"f0fff0",hotpRk:"ff69b4",RdianYd:"cd5c5c",Rdigo:"4b0082",ivSy:"fffff0",khaki:"f0e68c",lavFMr:"e6e6fa",lavFMrXsh:"fff0f5",lawngYF:"7cfc00",NmoncEffon:"fffacd",ZXe:"add8e6",ZcSO:"f08080",Zcyan:"e0ffff",ZgTMnPdLw:"fafad2",ZWay:"d3d3d3",ZgYF:"90ee90",ZgYy:"d3d3d3",ZpRk:"ffb6c1",ZsOmon:"ffa07a",ZsHgYF:"20b2aa",ZskyXe:"87cefa",ZUWay:"778899",ZUgYy:"778899",ZstAlXe:"b0c4de",ZLw:"ffffe0",lime:"ff00",limegYF:"32cd32",lRF:"faf0e6",magFta:"ff00ff",maPon:"800000",VaquamarRe:"66cdaa",VXe:"cd",VScEd:"ba55d3",VpurpN:"9370db",VsHgYF:"3cb371",VUXe:"7b68ee",VsprRggYF:"fa9a",VQe:"48d1cc",VviTetYd:"c71585",midnightXe:"191970",mRtcYam:"f5fffa",mistyPse:"ffe4e1",moccasR:"ffe4b5",navajowEte:"ffdead",navy:"80",Tdlace:"fdf5e6",Tive:"808000",TivedBb:"6b8e23",Sange:"ffa500",SangeYd:"ff4500",ScEd:"da70d6",pOegTMnPd:"eee8aa",pOegYF:"98fb98",pOeQe:"afeeee",pOeviTetYd:"db7093",papayawEp:"ffefd5",pHKpuff:"ffdab9",peru:"cd853f",pRk:"ffc0cb",plum:"dda0dd",powMrXe:"b0e0e6",purpN:"800080",YbeccapurpN:"663399",Yd:"ff0000",Psybrown:"bc8f8f",PyOXe:"4169e1",saddNbPwn:"8b4513",sOmon:"fa8072",sandybPwn:"f4a460",sHgYF:"2e8b57",sHshell:"fff5ee",siFna:"a0522d",silver:"c0c0c0",skyXe:"87ceeb",UXe:"6a5acd",UWay:"708090",UgYy:"708090",snow:"fffafa",sprRggYF:"ff7f",stAlXe:"4682b4",tan:"d2b48c",teO:"8080",tEstN:"d8bfd8",tomato:"ff6347",Qe:"40e0d0",viTet:"ee82ee",JHt:"f5deb3",wEte:"ffffff",wEtesmoke:"f5f5f5",Lw:"ffff00",LwgYF:"9acd32"};let oa;function ca(e){oa||(oa=function(){const e={},t=Object.keys(ia),n=Object.keys(ra);let a,s,r,i,o;for(a=0;a<t.length;a++){for(i=o=t[a],s=0;s<n.length;s++)r=n[s],o=o.replace(r,ra[r]);r=parseInt(ia[i],16),e[o]=[r>>16&255,r>>8&255,255&r]}return e}(),oa.transparent=[0,0,0,0]);const t=oa[e.toLowerCase()];return t&&{r:t[0],g:t[1],b:t[2],a:4===t.length?t[3]:255}}const la=/^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;const ua=e=>e<=.0031308?12.92*e:1.055*Math.pow(e,1/2.4)-.055,ha=e=>e<=.04045?e/12.92:Math.pow((e+.055)/1.055,2.4);function da(e,t,n){if(e){let a=ea(e);a[t]=Math.max(0,Math.min(a[t]+a[t]*n,0===t?360:1)),a=na(a),e.r=a[0],e.g=a[1],e.b=a[2]}}function pa(e,t){return e?Object.assign(t||{},e):e}function fa(e){var t={r:0,g:0,b:0,a:255};return Array.isArray(e)?e.length>=3&&(t={r:e[0],g:e[1],b:e[2],a:255},e.length>3&&(t.a=Wn(e[3]))):(t=pa(e,{r:0,g:0,b:0,a:1})).a=Wn(t.a),t}function ma(e){return"r"===e.charAt(0)?function(e){const t=la.exec(e);let n,a,s,r=255;if(t){if(t[7]!==n){const e=+t[7];r=t[8]?jn(e):Bn(255*e,0,255)}return n=+t[1],a=+t[3],s=+t[5],n=255&(t[2]?jn(n):Bn(n,0,255)),a=255&(t[4]?jn(a):Bn(a,0,255)),s=255&(t[6]?jn(s):Bn(s,0,255)),{r:n,g:a,b:s,a:r}}}(e):sa(e)}class ga{constructor(e){if(e instanceof ga)return e;const t=typeof e;let n;"object"===t?n=fa(e):"string"===t&&(n=function(e){var t,n=e.length;return"#"===e[0]&&(4===n||5===n?t={r:255&17*Hn[e[1]],g:255&17*Hn[e[2]],b:255&17*Hn[e[3]],a:5===n?17*Hn[e[4]]:255}:7!==n&&9!==n||(t={r:Hn[e[1]]<<4|Hn[e[2]],g:Hn[e[3]]<<4|Hn[e[4]],b:Hn[e[5]]<<4|Hn[e[6]],a:9===n?Hn[e[7]]<<4|Hn[e[8]]:255})),t}(e)||ca(e)||ma(e)),this._rgb=n,this._valid=!!n}get valid(){return this._valid}get rgb(){var e=pa(this._rgb);return e&&(e.a=Vn(e.a)),e}set rgb(e){this._rgb=fa(e)}rgbString(){return this._valid?(e=this._rgb)&&(e.a<255?"rgba(".concat(e.r,", ").concat(e.g,", ").concat(e.b,", ").concat(Vn(e.a),")"):"rgb(".concat(e.r,", ").concat(e.g,", ").concat(e.b,")")):void 0;var e}hexString(){return this._valid?Yn(this._rgb):void 0}hslString(){return this._valid?function(e){if(!e)return;const t=ea(e),n=t[0],a=Un(t[1]),s=Un(t[2]);return e.a<255?"hsla(".concat(n,", ").concat(a,"%, ").concat(s,"%, ").concat(Vn(e.a),")"):"hsl(".concat(n,", ").concat(a,"%, ").concat(s,"%)")}(this._rgb):void 0}mix(e,t){if(e){const n=this.rgb,a=e.rgb;let s;const r=t===s?.5:t,i=2*r-1,o=n.a-a.a,c=((i*o===-1?i:(i+o)/(1+i*o))+1)/2;s=1-c,n.r=255&c*n.r+s*a.r+.5,n.g=255&c*n.g+s*a.g+.5,n.b=255&c*n.b+s*a.b+.5,n.a=r*n.a+(1-r)*a.a,this.rgb=n}return this}interpolate(e,t){return e&&(this._rgb=function(e,t,n){const a=ha(Vn(e.r)),s=ha(Vn(e.g)),r=ha(Vn(e.b));return{r:Wn(ua(a+n*(ha(Vn(t.r))-a))),g:Wn(ua(s+n*(ha(Vn(t.g))-s))),b:Wn(ua(r+n*(ha(Vn(t.b))-r))),a:e.a+n*(t.a-e.a)}}(this._rgb,e._rgb,t)),this}clone(){return new ga(this.rgb)}alpha(e){return this._rgb.a=Wn(e),this}clearer(e){return this._rgb.a*=1-e,this}greyscale(){const e=this._rgb,t=zn(.3*e.r+.59*e.g+.11*e.b);return e.r=e.g=e.b=t,this}opaquer(e){return this._rgb.a*=1+e,this}negate(){const e=this._rgb;return e.r=255-e.r,e.g=255-e.g,e.b=255-e.b,this}lighten(e){return da(this._rgb,2,e),this}darken(e){return da(this._rgb,2,-e),this}saturate(e){return da(this._rgb,1,e),this}desaturate(e){return da(this._rgb,1,-e),this}rotate(e){return function(e,t){var n=ea(e);n[0]=aa(n[0]+t),n=na(n),e.r=n[0],e.g=n[1],e.b=n[2]}(this._rgb,e),this}}function ya(){}const ba=(()=>{let e=0;return()=>e++})();function xa(e){return null===e||void 0===e}function va(e){if(Array.isArray&&Array.isArray(e))return!0;const t=Object.prototype.toString.call(e);return"[object"===t.slice(0,7)&&"Array]"===t.slice(-6)}function wa(e){return null!==e&&"[object Object]"===Object.prototype.toString.call(e)}function ka(e){return("number"===typeof e||e instanceof Number)&&isFinite(+e)}function Sa(e,t){return ka(e)?e:t}function Ca(e,t){return"undefined"===typeof e?t:e}const Ia=(e,t)=>"string"===typeof e&&e.endsWith("%")?parseFloat(e)/100*t:+e;function Na(e,t,n){if(e&&"function"===typeof e.call)return e.apply(n,t)}function Ta(e,t,n,a){let s,r,i;if(va(e))if(r=e.length,a)for(s=r-1;s>=0;s--)t.call(n,e[s],s);else for(s=0;s<r;s++)t.call(n,e[s],s);else if(wa(e))for(i=Object.keys(e),r=i.length,s=0;s<r;s++)t.call(n,e[i[s]],i[s])}function Ea(e,t){let n,a,s,r;if(!e||!t||e.length!==t.length)return!1;for(n=0,a=e.length;n<a;++n)if(s=e[n],r=t[n],s.datasetIndex!==r.datasetIndex||s.index!==r.index)return!1;return!0}function Ra(e){if(va(e))return e.map(Ra);if(wa(e)){const t=Object.create(null),n=Object.keys(e),a=n.length;let s=0;for(;s<a;++s)t[n[s]]=Ra(e[n[s]]);return t}return e}function _a(e){return-1===["__proto__","prototype","constructor"].indexOf(e)}function Aa(e,t,n,a){if(!_a(e))return;const s=t[e],r=n[e];wa(s)&&wa(r)?Ma(s,r,a):t[e]=Ra(r)}function Ma(e,t,n){const a=va(t)?t:[t],s=a.length;if(!wa(e))return e;const r=(n=n||{}).merger||Aa;let i;for(let o=0;o<s;++o){if(i=a[o],!wa(i))continue;const t=Object.keys(i);for(let a=0,s=t.length;a<s;++a)r(t[a],e,i,n)}return e}function Pa(e,t){return Ma(e,t,{merger:Da})}function Da(e,t,n){if(!_a(e))return;const a=t[e],s=n[e];wa(a)&&wa(s)?Pa(a,s):Object.prototype.hasOwnProperty.call(t,e)||(t[e]=Ra(s))}const Oa={"":e=>e,x:e=>e.x,y:e=>e.y};function Fa(e,t){const n=Oa[t]||(Oa[t]=function(e){const t=function(e){const t=e.split("."),n=[];let a="";for(const s of t)a+=s,a.endsWith("\\")?a=a.slice(0,-1)+".":(n.push(a),a="");return n}(e);return e=>{for(const n of t){if(""===n)break;e=e&&e[n]}return e}}(t));return n(e)}function La(e){return e.charAt(0).toUpperCase()+e.slice(1)}const za=e=>"undefined"!==typeof e,Ba=e=>"function"===typeof e,ja=(e,t)=>{if(e.size!==t.size)return!1;for(const n of e)if(!t.has(n))return!1;return!0};const Wa=Math.PI,Va=2*Wa,Ua=Va+Wa,Ha=Number.POSITIVE_INFINITY,Ga=Wa/180,qa=Wa/2,Ka=Wa/4,Xa=2*Wa/3,Ya=Math.log10,Qa=Math.sign;function Za(e,t,n){return Math.abs(e-t)<n}function Ja(e){const t=Math.round(e);e=Za(e,t,e/1e3)?t:e;const n=Math.pow(10,Math.floor(Ya(e))),a=e/n;return(a<=1?1:a<=2?2:a<=5?5:10)*n}function $a(e){return!function(e){return"symbol"===typeof e||"object"===typeof e&&null!==e&&!(Symbol.toPrimitive in e||"toString"in e||"valueOf"in e)}(e)&&!isNaN(parseFloat(e))&&isFinite(e)}function es(e,t,n){let a,s,r;for(a=0,s=e.length;a<s;a++)r=e[a][n],isNaN(r)||(t.min=Math.min(t.min,r),t.max=Math.max(t.max,r))}function ts(e){return e*(Wa/180)}function ns(e){return e*(180/Wa)}function as(e){if(!ka(e))return;let t=1,n=0;for(;Math.round(e*t)/t!==e;)t*=10,n++;return n}function ss(e,t){const n=t.x-e.x,a=t.y-e.y,s=Math.sqrt(n*n+a*a);let r=Math.atan2(a,n);return r<-.5*Wa&&(r+=Va),{angle:r,distance:s}}function rs(e,t){return Math.sqrt(Math.pow(t.x-e.x,2)+Math.pow(t.y-e.y,2))}function is(e,t){return(e-t+Ua)%Va-Wa}function os(e){return(e%Va+Va)%Va}function cs(e,t,n,a){const s=os(e),r=os(t),i=os(n),o=os(r-s),c=os(i-s),l=os(s-r),u=os(s-i);return s===r||s===i||a&&r===i||o>c&&l<u}function ls(e,t,n){return Math.max(t,Math.min(n,e))}function us(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1e-6;return e>=Math.min(t,n)-a&&e<=Math.max(t,n)+a}function hs(e,t,n){n=n||(n=>e[n]<t);let a,s=e.length-1,r=0;for(;s-r>1;)a=r+s>>1,n(a)?r=a:s=a;return{lo:r,hi:s}}const ds=(e,t,n,a)=>hs(e,n,a?a=>{const s=e[a][t];return s<n||s===n&&e[a+1][t]===n}:a=>e[a][t]<n),ps=(e,t,n)=>hs(e,n,a=>e[a][t]>=n);const fs=["push","pop","shift","splice","unshift"];function ms(e,t){const n=e._chartjs;if(!n)return;const a=n.listeners,s=a.indexOf(t);-1!==s&&a.splice(s,1),a.length>0||(fs.forEach(t=>{delete e[t]}),delete e._chartjs)}function gs(e){const t=new Set(e);return t.size===e.length?e:Array.from(t)}const ys="undefined"===typeof window?function(e){return e()}:window.requestAnimationFrame;function bs(e,t){let n=[],a=!1;return function(){for(var s=arguments.length,r=new Array(s),i=0;i<s;i++)r[i]=arguments[i];n=r,a||(a=!0,ys.call(window,()=>{a=!1,e.apply(t,n)}))}}const xs=e=>"start"===e?"left":"end"===e?"right":"center",vs=(e,t,n)=>"start"===e?t:"end"===e?n:(t+n)/2;function ws(e,t,n){const a=t.length;let s=0,r=a;if(e._sorted){const{iScale:i,vScale:o,_parsed:c}=e,l=e.dataset&&e.dataset.options?e.dataset.options.spanGaps:null,u=i.axis,{min:h,max:d,minDefined:p,maxDefined:f}=i.getUserBounds();if(p){if(s=Math.min(ds(c,u,h).lo,n?a:ds(t,u,i.getPixelForValue(h)).lo),l){const e=c.slice(0,s+1).reverse().findIndex(e=>!xa(e[o.axis]));s-=Math.max(0,e)}s=ls(s,0,a-1)}if(f){let e=Math.max(ds(c,i.axis,d,!0).hi+1,n?0:ds(t,u,i.getPixelForValue(d),!0).hi+1);if(l){const t=c.slice(e-1).findIndex(e=>!xa(e[o.axis]));e+=Math.max(0,t)}r=ls(e,s,a)-s}else r=a-s}return{start:s,count:r}}function ks(e){const{xScale:t,yScale:n,_scaleRanges:a}=e,s={xmin:t.min,xmax:t.max,ymin:n.min,ymax:n.max};if(!a)return e._scaleRanges=s,!0;const r=a.xmin!==t.min||a.xmax!==t.max||a.ymin!==n.min||a.ymax!==n.max;return Object.assign(a,s),r}const Ss=e=>0===e||1===e,Cs=(e,t,n)=>-Math.pow(2,10*(e-=1))*Math.sin((e-t)*Va/n),Is=(e,t,n)=>Math.pow(2,-10*e)*Math.sin((e-t)*Va/n)+1,Ns={linear:e=>e,easeInQuad:e=>e*e,easeOutQuad:e=>-e*(e-2),easeInOutQuad:e=>(e/=.5)<1?.5*e*e:-.5*(--e*(e-2)-1),easeInCubic:e=>e*e*e,easeOutCubic:e=>(e-=1)*e*e+1,easeInOutCubic:e=>(e/=.5)<1?.5*e*e*e:.5*((e-=2)*e*e+2),easeInQuart:e=>e*e*e*e,easeOutQuart:e=>-((e-=1)*e*e*e-1),easeInOutQuart:e=>(e/=.5)<1?.5*e*e*e*e:-.5*((e-=2)*e*e*e-2),easeInQuint:e=>e*e*e*e*e,easeOutQuint:e=>(e-=1)*e*e*e*e+1,easeInOutQuint:e=>(e/=.5)<1?.5*e*e*e*e*e:.5*((e-=2)*e*e*e*e+2),easeInSine:e=>1-Math.cos(e*qa),easeOutSine:e=>Math.sin(e*qa),easeInOutSine:e=>-.5*(Math.cos(Wa*e)-1),easeInExpo:e=>0===e?0:Math.pow(2,10*(e-1)),easeOutExpo:e=>1===e?1:1-Math.pow(2,-10*e),easeInOutExpo:e=>Ss(e)?e:e<.5?.5*Math.pow(2,10*(2*e-1)):.5*(2-Math.pow(2,-10*(2*e-1))),easeInCirc:e=>e>=1?e:-(Math.sqrt(1-e*e)-1),easeOutCirc:e=>Math.sqrt(1-(e-=1)*e),easeInOutCirc:e=>(e/=.5)<1?-.5*(Math.sqrt(1-e*e)-1):.5*(Math.sqrt(1-(e-=2)*e)+1),easeInElastic:e=>Ss(e)?e:Cs(e,.075,.3),easeOutElastic:e=>Ss(e)?e:Is(e,.075,.3),easeInOutElastic(e){const t=.1125;return Ss(e)?e:e<.5?.5*Cs(2*e,t,.45):.5+.5*Is(2*e-1,t,.45)},easeInBack(e){const t=1.70158;return e*e*((t+1)*e-t)},easeOutBack(e){const t=1.70158;return(e-=1)*e*((t+1)*e+t)+1},easeInOutBack(e){let t=1.70158;return(e/=.5)<1?e*e*((1+(t*=1.525))*e-t)*.5:.5*((e-=2)*e*((1+(t*=1.525))*e+t)+2)},easeInBounce:e=>1-Ns.easeOutBounce(1-e),easeOutBounce(e){const t=7.5625,n=2.75;return e<1/n?t*e*e:e<2/n?t*(e-=1.5/n)*e+.75:e<2.5/n?t*(e-=2.25/n)*e+.9375:t*(e-=2.625/n)*e+.984375},easeInOutBounce:e=>e<.5?.5*Ns.easeInBounce(2*e):.5*Ns.easeOutBounce(2*e-1)+.5};function Ts(e){if(e&&"object"===typeof e){const t=e.toString();return"[object CanvasPattern]"===t||"[object CanvasGradient]"===t}return!1}function Es(e){return Ts(e)?e:new ga(e)}function Rs(e){return Ts(e)?e:new ga(e).saturate(.5).darken(.1).hexString()}const _s=["x","y","borderWidth","radius","tension"],As=["color","borderColor","backgroundColor"];const Ms=new Map;function Ps(e,t,n){return function(e,t){t=t||{};const n=e+JSON.stringify(t);let a=Ms.get(n);return a||(a=new Intl.NumberFormat(e,t),Ms.set(n,a)),a}(t,n).format(e)}const Ds={values:e=>va(e)?e:""+e,numeric(e,t,n){if(0===e)return"0";const a=this.chart.options.locale;let s,r=e;if(n.length>1){const t=Math.max(Math.abs(n[0].value),Math.abs(n[n.length-1].value));(t<1e-4||t>1e15)&&(s="scientific"),r=function(e,t){let n=t.length>3?t[2].value-t[1].value:t[1].value-t[0].value;Math.abs(n)>=1&&e!==Math.floor(e)&&(n=e-Math.floor(e));return n}(e,n)}const i=Ya(Math.abs(r)),o=isNaN(i)?1:Math.max(Math.min(-1*Math.floor(i),20),0),c={notation:s,minimumFractionDigits:o,maximumFractionDigits:o};return Object.assign(c,this.options.ticks.format),Ps(e,a,c)},logarithmic(e,t,n){if(0===e)return"0";const a=n[t].significand||e/Math.pow(10,Math.floor(Ya(e)));return[1,2,3,5,10,15].includes(a)||t>.8*n.length?Ds.numeric.call(this,e,t,n):""}};var Os={formatters:Ds};const Fs=Object.create(null),Ls=Object.create(null);function zs(e,t){if(!t)return e;const n=t.split(".");for(let a=0,s=n.length;a<s;++a){const t=n[a];e=e[t]||(e[t]=Object.create(null))}return e}function Bs(e,t,n){return"string"===typeof t?Ma(zs(e,t),n):Ma(zs(e,""),t)}class js{constructor(e,t){this.animation=void 0,this.backgroundColor="rgba(0,0,0,0.1)",this.borderColor="rgba(0,0,0,0.1)",this.color="#666",this.datasets={},this.devicePixelRatio=e=>e.chart.platform.getDevicePixelRatio(),this.elements={},this.events=["mousemove","mouseout","click","touchstart","touchmove"],this.font={family:"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",size:12,style:"normal",lineHeight:1.2,weight:null},this.hover={},this.hoverBackgroundColor=(e,t)=>Rs(t.backgroundColor),this.hoverBorderColor=(e,t)=>Rs(t.borderColor),this.hoverColor=(e,t)=>Rs(t.color),this.indexAxis="x",this.interaction={mode:"nearest",intersect:!0,includeInvisible:!1},this.maintainAspectRatio=!0,this.onHover=null,this.onClick=null,this.parsing=!0,this.plugins={},this.responsive=!0,this.scale=void 0,this.scales={},this.showLine=!0,this.drawActiveElementsOnTop=!0,this.describe(e),this.apply(t)}set(e,t){return Bs(this,e,t)}get(e){return zs(this,e)}describe(e,t){return Bs(Ls,e,t)}override(e,t){return Bs(Fs,e,t)}route(e,t,n,a){const s=zs(this,e),r=zs(this,n),i="_"+t;Object.defineProperties(s,{[i]:{value:s[t],writable:!0},[t]:{enumerable:!0,get(){const e=this[i],t=r[a];return wa(e)?Object.assign({},t,e):Ca(e,t)},set(e){this[i]=e}}})}apply(e){e.forEach(e=>e(this))}}var Ws=new js({_scriptable:e=>!e.startsWith("on"),_indexable:e=>"events"!==e,hover:{_fallback:"interaction"},interaction:{_scriptable:!1,_indexable:!1}},[function(e){e.set("animation",{delay:void 0,duration:1e3,easing:"easeOutQuart",fn:void 0,from:void 0,loop:void 0,to:void 0,type:void 0}),e.describe("animation",{_fallback:!1,_indexable:!1,_scriptable:e=>"onProgress"!==e&&"onComplete"!==e&&"fn"!==e}),e.set("animations",{colors:{type:"color",properties:As},numbers:{type:"number",properties:_s}}),e.describe("animations",{_fallback:"animation"}),e.set("transitions",{active:{animation:{duration:400}},resize:{animation:{duration:0}},show:{animations:{colors:{from:"transparent"},visible:{type:"boolean",duration:0}}},hide:{animations:{colors:{to:"transparent"},visible:{type:"boolean",easing:"linear",fn:e=>0|e}}}})},function(e){e.set("layout",{autoPadding:!0,padding:{top:0,right:0,bottom:0,left:0}})},function(e){e.set("scale",{display:!0,offset:!1,reverse:!1,beginAtZero:!1,bounds:"ticks",clip:!0,grace:0,grid:{display:!0,lineWidth:1,drawOnChartArea:!0,drawTicks:!0,tickLength:8,tickWidth:(e,t)=>t.lineWidth,tickColor:(e,t)=>t.color,offset:!1},border:{display:!0,dash:[],dashOffset:0,width:1},title:{display:!1,text:"",padding:{top:4,bottom:4}},ticks:{minRotation:0,maxRotation:50,mirror:!1,textStrokeWidth:0,textStrokeColor:"",padding:3,display:!0,autoSkip:!0,autoSkipPadding:3,labelOffset:0,callback:Os.formatters.values,minor:{},major:{},align:"center",crossAlign:"near",showLabelBackdrop:!1,backdropColor:"rgba(255, 255, 255, 0.75)",backdropPadding:2}}),e.route("scale.ticks","color","","color"),e.route("scale.grid","color","","borderColor"),e.route("scale.border","color","","borderColor"),e.route("scale.title","color","","color"),e.describe("scale",{_fallback:!1,_scriptable:e=>!e.startsWith("before")&&!e.startsWith("after")&&"callback"!==e&&"parser"!==e,_indexable:e=>"borderDash"!==e&&"tickBorderDash"!==e&&"dash"!==e}),e.describe("scales",{_fallback:"scale"}),e.describe("scale.ticks",{_scriptable:e=>"backdropPadding"!==e&&"callback"!==e,_indexable:e=>"backdropPadding"!==e})}]);function Vs(e,t,n,a,s){let r=t[s];return r||(r=t[s]=e.measureText(s).width,n.push(s)),r>a&&(a=r),a}function Us(e,t,n,a){let s=(a=a||{}).data=a.data||{},r=a.garbageCollect=a.garbageCollect||[];a.font!==t&&(s=a.data={},r=a.garbageCollect=[],a.font=t),e.save(),e.font=t;let i=0;const o=n.length;let c,l,u,h,d;for(c=0;c<o;c++)if(h=n[c],void 0===h||null===h||va(h)){if(va(h))for(l=0,u=h.length;l<u;l++)d=h[l],void 0===d||null===d||va(d)||(i=Vs(e,s,r,i,d))}else i=Vs(e,s,r,i,h);e.restore();const p=r.length/2;if(p>n.length){for(c=0;c<p;c++)delete s[r[c]];r.splice(0,p)}return i}function Hs(e,t,n){const a=e.currentDevicePixelRatio,s=0!==n?Math.max(n/2,.5):0;return Math.round((t-s)*a)/a+s}function Gs(e,t){(t||e)&&((t=t||e.getContext("2d")).save(),t.resetTransform(),t.clearRect(0,0,e.width,e.height),t.restore())}function qs(e,t,n,a){Ks(e,t,n,a,null)}function Ks(e,t,n,a,s){let r,i,o,c,l,u,h,d;const p=t.pointStyle,f=t.rotation,m=t.radius;let g=(f||0)*Ga;if(p&&"object"===typeof p&&(r=p.toString(),"[object HTMLImageElement]"===r||"[object HTMLCanvasElement]"===r))return e.save(),e.translate(n,a),e.rotate(g),e.drawImage(p,-p.width/2,-p.height/2,p.width,p.height),void e.restore();if(!(isNaN(m)||m<=0)){switch(e.beginPath(),p){default:s?e.ellipse(n,a,s/2,m,0,0,Va):e.arc(n,a,m,0,Va),e.closePath();break;case"triangle":u=s?s/2:m,e.moveTo(n+Math.sin(g)*u,a-Math.cos(g)*m),g+=Xa,e.lineTo(n+Math.sin(g)*u,a-Math.cos(g)*m),g+=Xa,e.lineTo(n+Math.sin(g)*u,a-Math.cos(g)*m),e.closePath();break;case"rectRounded":l=.516*m,c=m-l,i=Math.cos(g+Ka)*c,h=Math.cos(g+Ka)*(s?s/2-l:c),o=Math.sin(g+Ka)*c,d=Math.sin(g+Ka)*(s?s/2-l:c),e.arc(n-h,a-o,l,g-Wa,g-qa),e.arc(n+d,a-i,l,g-qa,g),e.arc(n+h,a+o,l,g,g+qa),e.arc(n-d,a+i,l,g+qa,g+Wa),e.closePath();break;case"rect":if(!f){c=Math.SQRT1_2*m,u=s?s/2:c,e.rect(n-u,a-c,2*u,2*c);break}g+=Ka;case"rectRot":h=Math.cos(g)*(s?s/2:m),i=Math.cos(g)*m,o=Math.sin(g)*m,d=Math.sin(g)*(s?s/2:m),e.moveTo(n-h,a-o),e.lineTo(n+d,a-i),e.lineTo(n+h,a+o),e.lineTo(n-d,a+i),e.closePath();break;case"crossRot":g+=Ka;case"cross":h=Math.cos(g)*(s?s/2:m),i=Math.cos(g)*m,o=Math.sin(g)*m,d=Math.sin(g)*(s?s/2:m),e.moveTo(n-h,a-o),e.lineTo(n+h,a+o),e.moveTo(n+d,a-i),e.lineTo(n-d,a+i);break;case"star":h=Math.cos(g)*(s?s/2:m),i=Math.cos(g)*m,o=Math.sin(g)*m,d=Math.sin(g)*(s?s/2:m),e.moveTo(n-h,a-o),e.lineTo(n+h,a+o),e.moveTo(n+d,a-i),e.lineTo(n-d,a+i),g+=Ka,h=Math.cos(g)*(s?s/2:m),i=Math.cos(g)*m,o=Math.sin(g)*m,d=Math.sin(g)*(s?s/2:m),e.moveTo(n-h,a-o),e.lineTo(n+h,a+o),e.moveTo(n+d,a-i),e.lineTo(n-d,a+i);break;case"line":i=s?s/2:Math.cos(g)*m,o=Math.sin(g)*m,e.moveTo(n-i,a-o),e.lineTo(n+i,a+o);break;case"dash":e.moveTo(n,a),e.lineTo(n+Math.cos(g)*(s?s/2:m),a+Math.sin(g)*m);break;case!1:e.closePath()}e.fill(),t.borderWidth>0&&e.stroke()}}function Xs(e,t,n){return n=n||.5,!t||e&&e.x>t.left-n&&e.x<t.right+n&&e.y>t.top-n&&e.y<t.bottom+n}function Ys(e,t){e.save(),e.beginPath(),e.rect(t.left,t.top,t.right-t.left,t.bottom-t.top),e.clip()}function Qs(e){e.restore()}function Zs(e,t,n,a,s){if(!t)return e.lineTo(n.x,n.y);if("middle"===s){const a=(t.x+n.x)/2;e.lineTo(a,t.y),e.lineTo(a,n.y)}else"after"===s!==!!a?e.lineTo(t.x,n.y):e.lineTo(n.x,t.y);e.lineTo(n.x,n.y)}function Js(e,t,n,a){if(!t)return e.lineTo(n.x,n.y);e.bezierCurveTo(a?t.cp1x:t.cp2x,a?t.cp1y:t.cp2y,a?n.cp2x:n.cp1x,a?n.cp2y:n.cp1y,n.x,n.y)}function $s(e,t,n,a,s){if(s.strikethrough||s.underline){const r=e.measureText(a),i=t-r.actualBoundingBoxLeft,o=t+r.actualBoundingBoxRight,c=n-r.actualBoundingBoxAscent,l=n+r.actualBoundingBoxDescent,u=s.strikethrough?(c+l)/2:l;e.strokeStyle=e.fillStyle,e.beginPath(),e.lineWidth=s.decorationWidth||2,e.moveTo(i,u),e.lineTo(o,u),e.stroke()}}function er(e,t){const n=e.fillStyle;e.fillStyle=t.color,e.fillRect(t.left,t.top,t.width,t.height),e.fillStyle=n}function tr(e,t,n,a,s){let r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:{};const i=va(t)?t:[t],o=r.strokeWidth>0&&""!==r.strokeColor;let c,l;for(e.save(),e.font=s.string,function(e,t){t.translation&&e.translate(t.translation[0],t.translation[1]),xa(t.rotation)||e.rotate(t.rotation),t.color&&(e.fillStyle=t.color),t.textAlign&&(e.textAlign=t.textAlign),t.textBaseline&&(e.textBaseline=t.textBaseline)}(e,r),c=0;c<i.length;++c)l=i[c],r.backdrop&&er(e,r.backdrop),o&&(r.strokeColor&&(e.strokeStyle=r.strokeColor),xa(r.strokeWidth)||(e.lineWidth=r.strokeWidth),e.strokeText(l,n,a,r.maxWidth)),e.fillText(l,n,a,r.maxWidth),$s(e,n,a,l,r),a+=Number(s.lineHeight);e.restore()}function nr(e,t){const{x:n,y:a,w:s,h:r,radius:i}=t;e.arc(n+i.topLeft,a+i.topLeft,i.topLeft,1.5*Wa,Wa,!0),e.lineTo(n,a+r-i.bottomLeft),e.arc(n+i.bottomLeft,a+r-i.bottomLeft,i.bottomLeft,Wa,qa,!0),e.lineTo(n+s-i.bottomRight,a+r),e.arc(n+s-i.bottomRight,a+r-i.bottomRight,i.bottomRight,qa,0,!0),e.lineTo(n+s,a+i.topRight),e.arc(n+s-i.topRight,a+i.topRight,i.topRight,0,-qa,!0),e.lineTo(n+i.topLeft,a)}const ar=/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/,sr=/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;function rr(e,t){const n=(""+e).match(ar);if(!n||"normal"===n[1])return 1.2*t;switch(e=+n[2],n[3]){case"px":return e;case"%":e/=100}return t*e}const ir=e=>+e||0;function or(e,t){const n={},a=wa(t),s=a?Object.keys(t):t,r=wa(e)?a?n=>Ca(e[n],e[t[n]]):t=>e[t]:()=>e;for(const i of s)n[i]=ir(r(i));return n}function cr(e){return or(e,{top:"y",right:"x",bottom:"y",left:"x"})}function lr(e){return or(e,["topLeft","topRight","bottomLeft","bottomRight"])}function ur(e){const t=cr(e);return t.width=t.left+t.right,t.height=t.top+t.bottom,t}function hr(e,t){e=e||{},t=t||Ws.font;let n=Ca(e.size,t.size);"string"===typeof n&&(n=parseInt(n,10));let a=Ca(e.style,t.style);a&&!(""+a).match(sr)&&(console.warn('Invalid font style specified: "'+a+'"'),a=void 0);const s={family:Ca(e.family,t.family),lineHeight:rr(Ca(e.lineHeight,t.lineHeight),n),size:n,style:a,weight:Ca(e.weight,t.weight),string:""};return s.string=function(e){return!e||xa(e.size)||xa(e.family)?null:(e.style?e.style+" ":"")+(e.weight?e.weight+" ":"")+e.size+"px "+e.family}(s),s}function dr(e,t,n,a){let s,r,i,o=!0;for(s=0,r=e.length;s<r;++s)if(i=e[s],void 0!==i&&(void 0!==t&&"function"===typeof i&&(i=i(t),o=!1),void 0!==n&&va(i)&&(i=i[n%i.length],o=!1),void 0!==i))return a&&!o&&(a.cacheable=!1),i}function pr(e,t){return Object.assign(Object.create(e),t)}function fr(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[""],n=arguments.length>3?arguments[3]:void 0,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:()=>e[0];const s=(arguments.length>2?arguments[2]:void 0)||e;"undefined"===typeof n&&(n=Ir("_fallback",e));const r={[Symbol.toStringTag]:"Object",_cacheable:!0,_scopes:e,_rootScopes:s,_fallback:n,_getTarget:a,override:a=>fr([a,...e],t,s,n)};return new Proxy(r,{deleteProperty:(t,n)=>(delete t[n],delete t._keys,delete e[0][n],!0),get:(n,a)=>xr(n,a,()=>function(e,t,n,a){let s;for(const r of t)if(s=Ir(yr(r,e),n),"undefined"!==typeof s)return br(e,s)?Sr(n,a,e,s):s}(a,t,e,n)),getOwnPropertyDescriptor:(e,t)=>Reflect.getOwnPropertyDescriptor(e._scopes[0],t),getPrototypeOf:()=>Reflect.getPrototypeOf(e[0]),has:(e,t)=>Nr(e).includes(t),ownKeys:e=>Nr(e),set(e,t,n){const s=e._storage||(e._storage=a());return e[t]=s[t]=n,delete e._keys,!0}})}function mr(e,t,n,a){const s={_cacheable:!1,_proxy:e,_context:t,_subProxy:n,_stack:new Set,_descriptors:gr(e,a),setContext:t=>mr(e,t,n,a),override:s=>mr(e.override(s),t,n,a)};return new Proxy(s,{deleteProperty:(t,n)=>(delete t[n],delete e[n],!0),get:(e,t,n)=>xr(e,t,()=>function(e,t,n){const{_proxy:a,_context:s,_subProxy:r,_descriptors:i}=e;let o=a[t];Ba(o)&&i.isScriptable(t)&&(o=function(e,t,n,a){const{_proxy:s,_context:r,_subProxy:i,_stack:o}=n;if(o.has(e))throw new Error("Recursion detected: "+Array.from(o).join("->")+"->"+e);o.add(e);let c=t(r,i||a);o.delete(e),br(e,c)&&(c=Sr(s._scopes,s,e,c));return c}(t,o,e,n));va(o)&&o.length&&(o=function(e,t,n,a){const{_proxy:s,_context:r,_subProxy:i,_descriptors:o}=n;if("undefined"!==typeof r.index&&a(e))return t[r.index%t.length];if(wa(t[0])){const n=t,a=s._scopes.filter(e=>e!==n);t=[];for(const c of n){const n=Sr(a,s,e,c);t.push(mr(n,r,i&&i[e],o))}}return t}(t,o,e,i.isIndexable));br(t,o)&&(o=mr(o,s,r&&r[t],i));return o}(e,t,n)),getOwnPropertyDescriptor:(t,n)=>t._descriptors.allKeys?Reflect.has(e,n)?{enumerable:!0,configurable:!0}:void 0:Reflect.getOwnPropertyDescriptor(e,n),getPrototypeOf:()=>Reflect.getPrototypeOf(e),has:(t,n)=>Reflect.has(e,n),ownKeys:()=>Reflect.ownKeys(e),set:(t,n,a)=>(e[n]=a,delete t[n],!0)})}function gr(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{scriptable:!0,indexable:!0};const{_scriptable:n=t.scriptable,_indexable:a=t.indexable,_allKeys:s=t.allKeys}=e;return{allKeys:s,scriptable:n,indexable:a,isScriptable:Ba(n)?n:()=>n,isIndexable:Ba(a)?a:()=>a}}const yr=(e,t)=>e?e+La(t):t,br=(e,t)=>wa(t)&&"adapters"!==e&&(null===Object.getPrototypeOf(t)||t.constructor===Object);function xr(e,t,n){if(Object.prototype.hasOwnProperty.call(e,t)||"constructor"===t)return e[t];const a=n();return e[t]=a,a}function vr(e,t,n){return Ba(e)?e(t,n):e}const wr=(e,t)=>!0===e?t:"string"===typeof e?Fa(t,e):void 0;function kr(e,t,n,a,s){for(const r of t){const t=wr(n,r);if(t){e.add(t);const r=vr(t._fallback,n,s);if("undefined"!==typeof r&&r!==n&&r!==a)return r}else if(!1===t&&"undefined"!==typeof a&&n!==a)return null}return!1}function Sr(e,t,n,a){const s=t._rootScopes,r=vr(t._fallback,n,a),i=[...e,...s],o=new Set;o.add(a);let c=Cr(o,i,n,r||n,a);return null!==c&&(("undefined"===typeof r||r===n||(c=Cr(o,i,r,c,a),null!==c))&&fr(Array.from(o),[""],s,r,()=>function(e,t,n){const a=e._getTarget();t in a||(a[t]={});const s=a[t];if(va(s)&&wa(n))return n;return s||{}}(t,n,a)))}function Cr(e,t,n,a,s){for(;n;)n=kr(e,t,n,a,s);return n}function Ir(e,t){for(const n of t){if(!n)continue;const t=n[e];if("undefined"!==typeof t)return t}}function Nr(e){let t=e._keys;return t||(t=e._keys=function(e){const t=new Set;for(const n of e)for(const e of Object.keys(n).filter(e=>!e.startsWith("_")))t.add(e);return Array.from(t)}(e._scopes)),t}function Tr(e,t,n,a){const{iScale:s}=e,{key:r="r"}=this._parsing,i=new Array(a);let o,c,l,u;for(o=0,c=a;o<c;++o)l=o+n,u=t[l],i[o]={r:s.parse(Fa(u,r),l)};return i}const Er=Number.EPSILON||1e-14,Rr=(e,t)=>t<e.length&&!e[t].skip&&e[t],_r=e=>"x"===e?"y":"x";function Ar(e,t,n,a){const s=e.skip?t:e,r=t,i=n.skip?t:n,o=rs(r,s),c=rs(i,r);let l=o/(o+c),u=c/(o+c);l=isNaN(l)?0:l,u=isNaN(u)?0:u;const h=a*l,d=a*u;return{previous:{x:r.x-h*(i.x-s.x),y:r.y-h*(i.y-s.y)},next:{x:r.x+d*(i.x-s.x),y:r.y+d*(i.y-s.y)}}}function Mr(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"x";const n=_r(t),a=e.length,s=Array(a).fill(0),r=Array(a);let i,o,c,l=Rr(e,0);for(i=0;i<a;++i)if(o=c,c=l,l=Rr(e,i+1),c){if(l){const e=l[t]-c[t];s[i]=0!==e?(l[n]-c[n])/e:0}r[i]=o?l?Qa(s[i-1])!==Qa(s[i])?0:(s[i-1]+s[i])/2:s[i-1]:s[i]}!function(e,t,n){const a=e.length;let s,r,i,o,c,l=Rr(e,0);for(let u=0;u<a-1;++u)c=l,l=Rr(e,u+1),c&&l&&(Za(t[u],0,Er)?n[u]=n[u+1]=0:(s=n[u]/t[u],r=n[u+1]/t[u],o=Math.pow(s,2)+Math.pow(r,2),o<=9||(i=3/Math.sqrt(o),n[u]=s*i*t[u],n[u+1]=r*i*t[u])))}(e,s,r),function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"x";const a=_r(n),s=e.length;let r,i,o,c=Rr(e,0);for(let l=0;l<s;++l){if(i=o,o=c,c=Rr(e,l+1),!o)continue;const s=o[n],u=o[a];i&&(r=(s-i[n])/3,o["cp1".concat(n)]=s-r,o["cp1".concat(a)]=u-r*t[l]),c&&(r=(c[n]-s)/3,o["cp2".concat(n)]=s+r,o["cp2".concat(a)]=u+r*t[l])}}(e,r,t)}function Pr(e,t,n){return Math.max(Math.min(e,n),t)}function Dr(e,t,n,a,s){let r,i,o,c;if(t.spanGaps&&(e=e.filter(e=>!e.skip)),"monotone"===t.cubicInterpolationMode)Mr(e,s);else{let n=a?e[e.length-1]:e[0];for(r=0,i=e.length;r<i;++r)o=e[r],c=Ar(n,o,e[Math.min(r+1,i-(a?0:1))%i],t.tension),o.cp1x=c.previous.x,o.cp1y=c.previous.y,o.cp2x=c.next.x,o.cp2y=c.next.y,n=o}t.capBezierPoints&&function(e,t){let n,a,s,r,i,o=Xs(e[0],t);for(n=0,a=e.length;n<a;++n)i=r,r=o,o=n<a-1&&Xs(e[n+1],t),r&&(s=e[n],i&&(s.cp1x=Pr(s.cp1x,t.left,t.right),s.cp1y=Pr(s.cp1y,t.top,t.bottom)),o&&(s.cp2x=Pr(s.cp2x,t.left,t.right),s.cp2y=Pr(s.cp2y,t.top,t.bottom)))}(e,n)}function Or(){return"undefined"!==typeof window&&"undefined"!==typeof document}function Fr(e){let t=e.parentNode;return t&&"[object ShadowRoot]"===t.toString()&&(t=t.host),t}function Lr(e,t,n){let a;return"string"===typeof e?(a=parseInt(e,10),-1!==e.indexOf("%")&&(a=a/100*t.parentNode[n])):a=e,a}const zr=e=>e.ownerDocument.defaultView.getComputedStyle(e,null);const Br=["top","right","bottom","left"];function jr(e,t,n){const a={};n=n?"-"+n:"";for(let s=0;s<4;s++){const r=Br[s];a[r]=parseFloat(e[t+"-"+r+n])||0}return a.width=a.left+a.right,a.height=a.top+a.bottom,a}function Wr(e,t){if("native"in e)return e;const{canvas:n,currentDevicePixelRatio:a}=t,s=zr(n),r="border-box"===s.boxSizing,i=jr(s,"padding"),o=jr(s,"border","width"),{x:c,y:l,box:u}=function(e,t){const n=e.touches,a=n&&n.length?n[0]:e,{offsetX:s,offsetY:r}=a;let i,o,c=!1;if(((e,t,n)=>(e>0||t>0)&&(!n||!n.shadowRoot))(s,r,e.target))i=s,o=r;else{const e=t.getBoundingClientRect();i=a.clientX-e.left,o=a.clientY-e.top,c=!0}return{x:i,y:o,box:c}}(e,n),h=i.left+(u&&o.left),d=i.top+(u&&o.top);let{width:p,height:f}=t;return r&&(p-=i.width+o.width,f-=i.height+o.height),{x:Math.round((c-h)/p*n.width/a),y:Math.round((l-d)/f*n.height/a)}}const Vr=e=>Math.round(10*e)/10;function Ur(e,t,n,a){const s=zr(e),r=jr(s,"margin"),i=Lr(s.maxWidth,e,"clientWidth")||Ha,o=Lr(s.maxHeight,e,"clientHeight")||Ha,c=function(e,t,n){let a,s;if(void 0===t||void 0===n){const r=e&&Fr(e);if(r){const e=r.getBoundingClientRect(),i=zr(r),o=jr(i,"border","width"),c=jr(i,"padding");t=e.width-c.width-o.width,n=e.height-c.height-o.height,a=Lr(i.maxWidth,r,"clientWidth"),s=Lr(i.maxHeight,r,"clientHeight")}else t=e.clientWidth,n=e.clientHeight}return{width:t,height:n,maxWidth:a||Ha,maxHeight:s||Ha}}(e,t,n);let{width:l,height:u}=c;if("content-box"===s.boxSizing){const e=jr(s,"border","width"),t=jr(s,"padding");l-=t.width+e.width,u-=t.height+e.height}l=Math.max(0,l-r.width),u=Math.max(0,a?l/a:u-r.height),l=Vr(Math.min(l,i,c.maxWidth)),u=Vr(Math.min(u,o,c.maxHeight)),l&&!u&&(u=Vr(l/2));return(void 0!==t||void 0!==n)&&a&&c.height&&u>c.height&&(u=c.height,l=Vr(Math.floor(u*a))),{width:l,height:u}}function Hr(e,t,n){const a=t||1,s=Vr(e.height*a),r=Vr(e.width*a);e.height=Vr(e.height),e.width=Vr(e.width);const i=e.canvas;return i.style&&(n||!i.style.height&&!i.style.width)&&(i.style.height="".concat(e.height,"px"),i.style.width="".concat(e.width,"px")),(e.currentDevicePixelRatio!==a||i.height!==s||i.width!==r)&&(e.currentDevicePixelRatio=a,i.height=s,i.width=r,e.ctx.setTransform(a,0,0,a,0,0),!0)}const Gr=function(){let e=!1;try{const t={get passive(){return e=!0,!1}};Or()&&(window.addEventListener("test",null,t),window.removeEventListener("test",null,t))}catch(G5){}return e}();function qr(e,t){const n=function(e,t){return zr(e).getPropertyValue(t)}(e,t),a=n&&n.match(/^(\d+)(\.\d+)?px$/);return a?+a[1]:void 0}function Kr(e,t,n,a){return{x:e.x+n*(t.x-e.x),y:e.y+n*(t.y-e.y)}}function Xr(e,t,n,a){return{x:e.x+n*(t.x-e.x),y:"middle"===a?n<.5?e.y:t.y:"after"===a?n<1?e.y:t.y:n>0?t.y:e.y}}function Yr(e,t,n,a){const s={x:e.cp2x,y:e.cp2y},r={x:t.cp1x,y:t.cp1y},i=Kr(e,s,n),o=Kr(s,r,n),c=Kr(r,t,n),l=Kr(i,o,n),u=Kr(o,c,n);return Kr(l,u,n)}function Qr(e,t,n){return e?function(e,t){return{x:n=>e+e+t-n,setWidth(e){t=e},textAlign:e=>"center"===e?e:"right"===e?"left":"right",xPlus:(e,t)=>e-t,leftForLtr:(e,t)=>e-t}}(t,n):{x:e=>e,setWidth(e){},textAlign:e=>e,xPlus:(e,t)=>e+t,leftForLtr:(e,t)=>e}}function Zr(e,t){let n,a;"ltr"!==t&&"rtl"!==t||(n=e.canvas.style,a=[n.getPropertyValue("direction"),n.getPropertyPriority("direction")],n.setProperty("direction",t,"important"),e.prevTextDirection=a)}function Jr(e,t){void 0!==t&&(delete e.prevTextDirection,e.canvas.style.setProperty("direction",t[0],t[1]))}function $r(e){return"angle"===e?{between:cs,compare:is,normalize:os}:{between:us,compare:(e,t)=>e-t,normalize:e=>e}}function ei(e){let{start:t,end:n,count:a,loop:s,style:r}=e;return{start:t%a,end:n%a,loop:s&&(n-t+1)%a===0,style:r}}function ti(e,t,n){if(!n)return[e];const{property:a,start:s,end:r}=n,i=t.length,{compare:o,between:c,normalize:l}=$r(a),{start:u,end:h,loop:d,style:p}=function(e,t,n){const{property:a,start:s,end:r}=n,{between:i,normalize:o}=$r(a),c=t.length;let l,u,{start:h,end:d,loop:p}=e;if(p){for(h+=c,d+=c,l=0,u=c;l<u&&i(o(t[h%c][a]),s,r);++l)h--,d--;h%=c,d%=c}return d<h&&(d+=c),{start:h,end:d,loop:p,style:e.style}}(e,t,n),f=[];let m,g,y,b=!1,x=null;const v=()=>b||c(s,y,m)&&0!==o(s,y),w=()=>!b||0===o(r,m)||c(r,y,m);for(let k=u,S=u;k<=h;++k)g=t[k%i],g.skip||(m=l(g[a]),m!==y&&(b=c(m,s,r),null===x&&v()&&(x=0===o(m,s)?k:S),null!==x&&w()&&(f.push(ei({start:x,end:k,loop:d,count:i,style:p})),x=null),S=k,y=m));return null!==x&&f.push(ei({start:x,end:h,loop:d,count:i,style:p})),f}function ni(e,t){const n=[],a=e.segments;for(let s=0;s<a.length;s++){const r=ti(a[s],e.points,t);r.length&&n.push(...r)}return n}function ai(e,t,n,a){return a&&a.setContext&&n?function(e,t,n,a){const s=e._chart.getContext(),r=si(e.options),{_datasetIndex:i,options:{spanGaps:o}}=e,c=n.length,l=[];let u=r,h=t[0].start,d=h;function p(e,t,a,s){const r=o?-1:1;if(e!==t){for(e+=c;n[e%c].skip;)e-=r;for(;n[t%c].skip;)t+=r;e%c!==t%c&&(l.push({start:e%c,end:t%c,loop:a,style:s}),u=s,h=t%c)}}for(const f of t){h=o?h:f.start;let e,t=n[h%c];for(d=h+1;d<=f.end;d++){const r=n[d%c];e=si(a.setContext(pr(s,{type:"segment",p0:t,p1:r,p0DataIndex:(d-1)%c,p1DataIndex:d%c,datasetIndex:i}))),ri(e,u)&&p(h,d-1,f.loop,u),t=r,u=e}h<d-1&&p(h,d-1,f.loop,u)}return l}(e,t,n,a):t}function si(e){return{backgroundColor:e.backgroundColor,borderCapStyle:e.borderCapStyle,borderDash:e.borderDash,borderDashOffset:e.borderDashOffset,borderJoinStyle:e.borderJoinStyle,borderWidth:e.borderWidth,borderColor:e.borderColor}}function ri(e,t){if(!t)return!1;const n=[],a=function(e,t){return Ts(t)?(n.includes(t)||n.push(t),n.indexOf(t)):t};return JSON.stringify(e,a)!==JSON.stringify(t,a)}function ii(e,t,n){return e.options.clip?e[n]:t[n]}function oi(e,t){const n=t._clip;if(n.disabled)return!1;const a=function(e,t){const{xScale:n,yScale:a}=e;return n&&a?{left:ii(n,t,"left"),right:ii(n,t,"right"),top:ii(a,t,"top"),bottom:ii(a,t,"bottom")}:t}(t,e.chartArea);return{left:!1===n.left?0:a.left-(!0===n.left?0:n.left),right:!1===n.right?e.width:a.right+(!0===n.right?0:n.right),top:!1===n.top?0:a.top-(!0===n.top?0:n.top),bottom:!1===n.bottom?e.height:a.bottom+(!0===n.bottom?0:n.bottom)}}class ci{constructor(){this._request=null,this._charts=new Map,this._running=!1,this._lastDate=void 0}_notify(e,t,n,a){const s=t.listeners[a],r=t.duration;s.forEach(a=>a({chart:e,initial:t.initial,numSteps:r,currentStep:Math.min(n-t.start,r)}))}_refresh(){this._request||(this._running=!0,this._request=ys.call(window,()=>{this._update(),this._request=null,this._running&&this._refresh()}))}_update(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Date.now(),t=0;this._charts.forEach((n,a)=>{if(!n.running||!n.items.length)return;const s=n.items;let r,i=s.length-1,o=!1;for(;i>=0;--i)r=s[i],r._active?(r._total>n.duration&&(n.duration=r._total),r.tick(e),o=!0):(s[i]=s[s.length-1],s.pop());o&&(a.draw(),this._notify(a,n,e,"progress")),s.length||(n.running=!1,this._notify(a,n,e,"complete"),n.initial=!1),t+=s.length}),this._lastDate=e,0===t&&(this._running=!1)}_getAnims(e){const t=this._charts;let n=t.get(e);return n||(n={running:!1,initial:!0,items:[],listeners:{complete:[],progress:[]}},t.set(e,n)),n}listen(e,t,n){this._getAnims(e).listeners[t].push(n)}add(e,t){t&&t.length&&this._getAnims(e).items.push(...t)}has(e){return this._getAnims(e).items.length>0}start(e){const t=this._charts.get(e);t&&(t.running=!0,t.start=Date.now(),t.duration=t.items.reduce((e,t)=>Math.max(e,t._duration),0),this._refresh())}running(e){if(!this._running)return!1;const t=this._charts.get(e);return!!(t&&t.running&&t.items.length)}stop(e){const t=this._charts.get(e);if(!t||!t.items.length)return;const n=t.items;let a=n.length-1;for(;a>=0;--a)n[a].cancel();t.items=[],this._notify(e,t,Date.now(),"complete")}remove(e){return this._charts.delete(e)}}var li=new ci;const ui="transparent",hi={boolean:(e,t,n)=>n>.5?t:e,color(e,t,n){const a=Es(e||ui),s=a.valid&&Es(t||ui);return s&&s.valid?s.mix(a,n).hexString():t},number:(e,t,n)=>e+(t-e)*n};class di{constructor(e,t,n,a){const s=t[n];a=dr([e.to,a,s,e.from]);const r=dr([e.from,s,a]);this._active=!0,this._fn=e.fn||hi[e.type||typeof r],this._easing=Ns[e.easing]||Ns.linear,this._start=Math.floor(Date.now()+(e.delay||0)),this._duration=this._total=Math.floor(e.duration),this._loop=!!e.loop,this._target=t,this._prop=n,this._from=r,this._to=a,this._promises=void 0}active(){return this._active}update(e,t,n){if(this._active){this._notify(!1);const a=this._target[this._prop],s=n-this._start,r=this._duration-s;this._start=n,this._duration=Math.floor(Math.max(r,e.duration)),this._total+=s,this._loop=!!e.loop,this._to=dr([e.to,t,a,e.from]),this._from=dr([e.from,a,t])}}cancel(){this._active&&(this.tick(Date.now()),this._active=!1,this._notify(!1))}tick(e){const t=e-this._start,n=this._duration,a=this._prop,s=this._from,r=this._loop,i=this._to;let o;if(this._active=s!==i&&(r||t<n),!this._active)return this._target[a]=i,void this._notify(!0);t<0?this._target[a]=s:(o=t/n%2,o=r&&o>1?2-o:o,o=this._easing(Math.min(1,Math.max(0,o))),this._target[a]=this._fn(s,i,o))}wait(){const e=this._promises||(this._promises=[]);return new Promise((t,n)=>{e.push({res:t,rej:n})})}_notify(e){const t=e?"res":"rej",n=this._promises||[];for(let a=0;a<n.length;a++)n[a][t]()}}class pi{constructor(e,t){this._chart=e,this._properties=new Map,this.configure(t)}configure(e){if(!wa(e))return;const t=Object.keys(Ws.animation),n=this._properties;Object.getOwnPropertyNames(e).forEach(a=>{const s=e[a];if(!wa(s))return;const r={};for(const e of t)r[e]=s[e];(va(s.properties)&&s.properties||[a]).forEach(e=>{e!==a&&n.has(e)||n.set(e,r)})})}_animateOptions(e,t){const n=t.options,a=function(e,t){if(!t)return;let n=e.options;if(!n)return void(e.options=t);n.$shared&&(e.options=n=Object.assign({},n,{$shared:!1,$animations:{}}));return n}(e,n);if(!a)return[];const s=this._createAnimations(a,n);return n.$shared&&function(e,t){const n=[],a=Object.keys(t);for(let s=0;s<a.length;s++){const t=e[a[s]];t&&t.active()&&n.push(t.wait())}return Promise.all(n)}(e.options.$animations,n).then(()=>{e.options=n},()=>{}),s}_createAnimations(e,t){const n=this._properties,a=[],s=e.$animations||(e.$animations={}),r=Object.keys(t),i=Date.now();let o;for(o=r.length-1;o>=0;--o){const c=r[o];if("$"===c.charAt(0))continue;if("options"===c){a.push(...this._animateOptions(e,t));continue}const l=t[c];let u=s[c];const h=n.get(c);if(u){if(h&&u.active()){u.update(h,l,i);continue}u.cancel()}h&&h.duration?(s[c]=u=new di(h,e,c,l),a.push(u)):e[c]=l}return a}update(e,t){if(0===this._properties.size)return void Object.assign(e,t);const n=this._createAnimations(e,t);return n.length?(li.add(this._chart,n),!0):void 0}}function fi(e,t){const n=e&&e.options||{},a=n.reverse,s=void 0===n.min?t:0,r=void 0===n.max?t:0;return{start:a?r:s,end:a?s:r}}function mi(e,t){const n=[],a=e._getSortedDatasetMetas(t);let s,r;for(s=0,r=a.length;s<r;++s)n.push(a[s].index);return n}function gi(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};const s=e.keys,r="single"===a.mode;let i,o,c,l;if(null===t)return;let u=!1;for(i=0,o=s.length;i<o;++i){if(c=+s[i],c===n){if(u=!0,a.all)continue;break}l=e.values[c],ka(l)&&(r||0===t||Qa(t)===Qa(l))&&(t+=l)}return u||a.all?t:0}function yi(e,t){const n=e&&e.options.stacked;return n||void 0===n&&void 0!==t.stack}function bi(e,t,n){const a=e[t]||(e[t]={});return a[n]||(a[n]={})}function xi(e,t,n,a){for(const s of t.getMatchingVisibleMetas(a).reverse()){const t=e[s.index];if(n&&t>0||!n&&t<0)return s.index}return null}function vi(e,t){const{chart:n,_cachedMeta:a}=e,s=n._stacks||(n._stacks={}),{iScale:r,vScale:i,index:o}=a,c=r.axis,l=i.axis,u=function(e,t,n){return"".concat(e.id,".").concat(t.id,".").concat(n.stack||n.type)}(r,i,a),h=t.length;let d;for(let p=0;p<h;++p){const e=t[p],{[c]:n,[l]:r}=e;d=(e._stacks||(e._stacks={}))[l]=bi(s,u,n),d[o]=r,d._top=xi(d,i,!0,a.type),d._bottom=xi(d,i,!1,a.type);(d._visualValues||(d._visualValues={}))[o]=r}}function wi(e,t){const n=e.scales;return Object.keys(n).filter(e=>n[e].axis===t).shift()}function ki(e,t){const n=e.controller.index,a=e.vScale&&e.vScale.axis;if(a){t=t||e._parsed;for(const e of t){const t=e._stacks;if(!t||void 0===t[a]||void 0===t[a][n])return;delete t[a][n],void 0!==t[a]._visualValues&&void 0!==t[a]._visualValues[n]&&delete t[a]._visualValues[n]}}}const Si=e=>"reset"===e||"none"===e,Ci=(e,t)=>t?e:Object.assign({},e);class Ii{constructor(e,t){this.chart=e,this._ctx=e.ctx,this.index=t,this._cachedDataOpts={},this._cachedMeta=this.getMeta(),this._type=this._cachedMeta.type,this.options=void 0,this._parsing=!1,this._data=void 0,this._objectData=void 0,this._sharedOptions=void 0,this._drawStart=void 0,this._drawCount=void 0,this.enableOptionSharing=!1,this.supportsDecimation=!1,this.$context=void 0,this._syncList=[],this.datasetElementType=new.target.datasetElementType,this.dataElementType=new.target.dataElementType,this.initialize()}initialize(){const e=this._cachedMeta;this.configure(),this.linkScales(),e._stacked=yi(e.vScale,e),this.addElements(),this.options.fill&&!this.chart.isPluginEnabled("filler")&&console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options")}updateIndex(e){this.index!==e&&ki(this._cachedMeta),this.index=e}linkScales(){const e=this.chart,t=this._cachedMeta,n=this.getDataset(),a=(e,t,n,a)=>"x"===e?t:"r"===e?a:n,s=t.xAxisID=Ca(n.xAxisID,wi(e,"x")),r=t.yAxisID=Ca(n.yAxisID,wi(e,"y")),i=t.rAxisID=Ca(n.rAxisID,wi(e,"r")),o=t.indexAxis,c=t.iAxisID=a(o,s,r,i),l=t.vAxisID=a(o,r,s,i);t.xScale=this.getScaleForId(s),t.yScale=this.getScaleForId(r),t.rScale=this.getScaleForId(i),t.iScale=this.getScaleForId(c),t.vScale=this.getScaleForId(l)}getDataset(){return this.chart.data.datasets[this.index]}getMeta(){return this.chart.getDatasetMeta(this.index)}getScaleForId(e){return this.chart.scales[e]}_getOtherScale(e){const t=this._cachedMeta;return e===t.iScale?t.vScale:t.iScale}reset(){this._update("reset")}_destroy(){const e=this._cachedMeta;this._data&&ms(this._data,this),e._stacked&&ki(e)}_dataCheck(){const e=this.getDataset(),t=e.data||(e.data=[]),n=this._data;if(wa(t)){const e=this._cachedMeta;this._data=function(e,t){const{iScale:n,vScale:a}=t,s="x"===n.axis?"x":"y",r="x"===a.axis?"x":"y",i=Object.keys(e),o=new Array(i.length);let c,l,u;for(c=0,l=i.length;c<l;++c)u=i[c],o[c]={[s]:u,[r]:e[u]};return o}(t,e)}else if(n!==t){if(n){ms(n,this);const e=this._cachedMeta;ki(e),e._parsed=[]}t&&Object.isExtensible(t)&&function(e,t){e._chartjs?e._chartjs.listeners.push(t):(Object.defineProperty(e,"_chartjs",{configurable:!0,enumerable:!1,value:{listeners:[t]}}),fs.forEach(t=>{const n="_onData"+La(t),a=e[t];Object.defineProperty(e,t,{configurable:!0,enumerable:!1,value(){for(var t=arguments.length,s=new Array(t),r=0;r<t;r++)s[r]=arguments[r];const i=a.apply(this,s);return e._chartjs.listeners.forEach(e=>{"function"===typeof e[n]&&e[n](...s)}),i}})}))}(t,this),this._syncList=[],this._data=t}}addElements(){const e=this._cachedMeta;this._dataCheck(),this.datasetElementType&&(e.dataset=new this.datasetElementType)}buildOrUpdateElements(e){const t=this._cachedMeta,n=this.getDataset();let a=!1;this._dataCheck();const s=t._stacked;t._stacked=yi(t.vScale,t),t.stack!==n.stack&&(a=!0,ki(t),t.stack=n.stack),this._resyncElements(e),(a||s!==t._stacked)&&(vi(this,t._parsed),t._stacked=yi(t.vScale,t))}configure(){const e=this.chart.config,t=e.datasetScopeKeys(this._type),n=e.getOptionScopes(this.getDataset(),t,!0);this.options=e.createResolver(n,this.getContext()),this._parsing=this.options.parsing,this._cachedDataOpts={}}parse(e,t){const{_cachedMeta:n,_data:a}=this,{iScale:s,_stacked:r}=n,i=s.axis;let o,c,l,u=0===e&&t===a.length||n._sorted,h=e>0&&n._parsed[e-1];if(!1===this._parsing)n._parsed=a,n._sorted=!0,l=a;else{l=va(a[e])?this.parseArrayData(n,a,e,t):wa(a[e])?this.parseObjectData(n,a,e,t):this.parsePrimitiveData(n,a,e,t);const s=()=>null===c[i]||h&&c[i]<h[i];for(o=0;o<t;++o)n._parsed[o+e]=c=l[o],u&&(s()&&(u=!1),h=c);n._sorted=u}r&&vi(this,l)}parsePrimitiveData(e,t,n,a){const{iScale:s,vScale:r}=e,i=s.axis,o=r.axis,c=s.getLabels(),l=s===r,u=new Array(a);let h,d,p;for(h=0,d=a;h<d;++h)p=h+n,u[h]={[i]:l||s.parse(c[p],p),[o]:r.parse(t[p],p)};return u}parseArrayData(e,t,n,a){const{xScale:s,yScale:r}=e,i=new Array(a);let o,c,l,u;for(o=0,c=a;o<c;++o)l=o+n,u=t[l],i[o]={x:s.parse(u[0],l),y:r.parse(u[1],l)};return i}parseObjectData(e,t,n,a){const{xScale:s,yScale:r}=e,{xAxisKey:i="x",yAxisKey:o="y"}=this._parsing,c=new Array(a);let l,u,h,d;for(l=0,u=a;l<u;++l)h=l+n,d=t[h],c[l]={x:s.parse(Fa(d,i),h),y:r.parse(Fa(d,o),h)};return c}getParsed(e){return this._cachedMeta._parsed[e]}getDataElement(e){return this._cachedMeta.data[e]}applyStack(e,t,n){const a=this.chart,s=this._cachedMeta,r=t[e.axis];return gi({keys:mi(a,!0),values:t._stacks[e.axis]._visualValues},r,s.index,{mode:n})}updateRangeFromParsed(e,t,n,a){const s=n[t.axis];let r=null===s?NaN:s;const i=a&&n._stacks[t.axis];a&&i&&(a.values=i,r=gi(a,s,this._cachedMeta.index)),e.min=Math.min(e.min,r),e.max=Math.max(e.max,r)}getMinMax(e,t){const n=this._cachedMeta,a=n._parsed,s=n._sorted&&e===n.iScale,r=a.length,i=this._getOtherScale(e),o=((e,t,n)=>e&&!t.hidden&&t._stacked&&{keys:mi(n,!0),values:null})(t,n,this.chart),c={min:Number.POSITIVE_INFINITY,max:Number.NEGATIVE_INFINITY},{min:l,max:u}=function(e){const{min:t,max:n,minDefined:a,maxDefined:s}=e.getUserBounds();return{min:a?t:Number.NEGATIVE_INFINITY,max:s?n:Number.POSITIVE_INFINITY}}(i);let h,d;function p(){d=a[h];const t=d[i.axis];return!ka(d[e.axis])||l>t||u<t}for(h=0;h<r&&(p()||(this.updateRangeFromParsed(c,e,d,o),!s));++h);if(s)for(h=r-1;h>=0;--h)if(!p()){this.updateRangeFromParsed(c,e,d,o);break}return c}getAllParsedValues(e){const t=this._cachedMeta._parsed,n=[];let a,s,r;for(a=0,s=t.length;a<s;++a)r=t[a][e.axis],ka(r)&&n.push(r);return n}getMaxOverflow(){return!1}getLabelAndValue(e){const t=this._cachedMeta,n=t.iScale,a=t.vScale,s=this.getParsed(e);return{label:n?""+n.getLabelForValue(s[n.axis]):"",value:a?""+a.getLabelForValue(s[a.axis]):""}}_update(e){const t=this._cachedMeta;this.update(e||"default"),t._clip=function(e){let t,n,a,s;return wa(e)?(t=e.top,n=e.right,a=e.bottom,s=e.left):t=n=a=s=e,{top:t,right:n,bottom:a,left:s,disabled:!1===e}}(Ca(this.options.clip,function(e,t,n){if(!1===n)return!1;const a=fi(e,n),s=fi(t,n);return{top:s.end,right:a.end,bottom:s.start,left:a.start}}(t.xScale,t.yScale,this.getMaxOverflow())))}update(e){}draw(){const e=this._ctx,t=this.chart,n=this._cachedMeta,a=n.data||[],s=t.chartArea,r=[],i=this._drawStart||0,o=this._drawCount||a.length-i,c=this.options.drawActiveElementsOnTop;let l;for(n.dataset&&n.dataset.draw(e,s,i,o),l=i;l<i+o;++l){const t=a[l];t.hidden||(t.active&&c?r.push(t):t.draw(e,s))}for(l=0;l<r.length;++l)r[l].draw(e,s)}getStyle(e,t){const n=t?"active":"default";return void 0===e&&this._cachedMeta.dataset?this.resolveDatasetElementOptions(n):this.resolveDataElementOptions(e||0,n)}getContext(e,t,n){const a=this.getDataset();let s;if(e>=0&&e<this._cachedMeta.data.length){const t=this._cachedMeta.data[e];s=t.$context||(t.$context=function(e,t,n){return pr(e,{active:!1,dataIndex:t,parsed:void 0,raw:void 0,element:n,index:t,mode:"default",type:"data"})}(this.getContext(),e,t)),s.parsed=this.getParsed(e),s.raw=a.data[e],s.index=s.dataIndex=e}else s=this.$context||(this.$context=function(e,t){return pr(e,{active:!1,dataset:void 0,datasetIndex:t,index:t,mode:"default",type:"dataset"})}(this.chart.getContext(),this.index)),s.dataset=a,s.index=s.datasetIndex=this.index;return s.active=!!t,s.mode=n,s}resolveDatasetElementOptions(e){return this._resolveElementOptions(this.datasetElementType.id,e)}resolveDataElementOptions(e,t){return this._resolveElementOptions(this.dataElementType.id,t,e)}_resolveElementOptions(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"default",n=arguments.length>2?arguments[2]:void 0;const a="active"===t,s=this._cachedDataOpts,r=e+"-"+t,i=s[r],o=this.enableOptionSharing&&za(n);if(i)return Ci(i,o);const c=this.chart.config,l=c.datasetElementScopeKeys(this._type,e),u=a?["".concat(e,"Hover"),"hover",e,""]:[e,""],h=c.getOptionScopes(this.getDataset(),l),d=Object.keys(Ws.elements[e]),p=c.resolveNamedOptions(h,d,()=>this.getContext(n,a,t),u);return p.$shared&&(p.$shared=o,s[r]=Object.freeze(Ci(p,o))),p}_resolveAnimations(e,t,n){const a=this.chart,s=this._cachedDataOpts,r="animation-".concat(t),i=s[r];if(i)return i;let o;if(!1!==a.options.animation){const a=this.chart.config,s=a.datasetAnimationScopeKeys(this._type,t),r=a.getOptionScopes(this.getDataset(),s);o=a.createResolver(r,this.getContext(e,n,t))}const c=new pi(a,o&&o.animations);return o&&o._cacheable&&(s[r]=Object.freeze(c)),c}getSharedOptions(e){if(e.$shared)return this._sharedOptions||(this._sharedOptions=Object.assign({},e))}includeOptions(e,t){return!t||Si(e)||this.chart._animationsDisabled}_getSharedOptions(e,t){const n=this.resolveDataElementOptions(e,t),a=this._sharedOptions,s=this.getSharedOptions(n),r=this.includeOptions(t,s)||s!==a;return this.updateSharedOptions(s,t,n),{sharedOptions:s,includeOptions:r}}updateElement(e,t,n,a){Si(a)?Object.assign(e,n):this._resolveAnimations(t,a).update(e,n)}updateSharedOptions(e,t,n){e&&!Si(t)&&this._resolveAnimations(void 0,t).update(e,n)}_setStyle(e,t,n,a){e.active=a;const s=this.getStyle(t,a);this._resolveAnimations(t,n,a).update(e,{options:!a&&this.getSharedOptions(s)||s})}removeHoverStyle(e,t,n){this._setStyle(e,n,"active",!1)}setHoverStyle(e,t,n){this._setStyle(e,n,"active",!0)}_removeDatasetHoverStyle(){const e=this._cachedMeta.dataset;e&&this._setStyle(e,void 0,"active",!1)}_setDatasetHoverStyle(){const e=this._cachedMeta.dataset;e&&this._setStyle(e,void 0,"active",!0)}_resyncElements(e){const t=this._data,n=this._cachedMeta.data;for(const[i,o,c]of this._syncList)this[i](o,c);this._syncList=[];const a=n.length,s=t.length,r=Math.min(s,a);r&&this.parse(0,r),s>a?this._insertElements(a,s-a,e):s<a&&this._removeElements(s,a-s)}_insertElements(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];const a=this._cachedMeta,s=a.data,r=e+t;let i;const o=e=>{for(e.length+=t,i=e.length-1;i>=r;i--)e[i]=e[i-t]};for(o(s),i=e;i<r;++i)s[i]=new this.dataElementType;this._parsing&&o(a._parsed),this.parse(e,t),n&&this.updateElements(s,e,t,"reset")}updateElements(e,t,n,a){}_removeElements(e,t){const n=this._cachedMeta;if(this._parsing){const a=n._parsed.splice(e,t);n._stacked&&ki(n,a)}n.data.splice(e,t)}_sync(e){if(this._parsing)this._syncList.push(e);else{const[t,n,a]=e;this[t](n,a)}this.chart._dataChanges.push([this.index,...e])}_onDataPush(){const e=arguments.length;this._sync(["_insertElements",this.getDataset().data.length-e,e])}_onDataPop(){this._sync(["_removeElements",this._cachedMeta.data.length-1,1])}_onDataShift(){this._sync(["_removeElements",0,1])}_onDataSplice(e,t){t&&this._sync(["_removeElements",e,t]);const n=arguments.length-2;n&&this._sync(["_insertElements",e,n])}_onDataUnshift(){this._sync(["_insertElements",0,arguments.length])}}function Ni(e){const t=e.iScale,n=function(e,t){if(!e._cache.$bar){const n=e.getMatchingVisibleMetas(t);let a=[];for(let t=0,s=n.length;t<s;t++)a=a.concat(n[t].controller.getAllParsedValues(e));e._cache.$bar=gs(a.sort((e,t)=>e-t))}return e._cache.$bar}(t,e.type);let a,s,r,i,o=t._length;const c=()=>{32767!==r&&-32768!==r&&(za(i)&&(o=Math.min(o,Math.abs(r-i)||o)),i=r)};for(a=0,s=n.length;a<s;++a)r=t.getPixelForValue(n[a]),c();for(i=void 0,a=0,s=t.ticks.length;a<s;++a)r=t.getPixelForTick(a),c();return o}function Ti(e,t,n,a){return va(e)?function(e,t,n,a){const s=n.parse(e[0],a),r=n.parse(e[1],a),i=Math.min(s,r),o=Math.max(s,r);let c=i,l=o;Math.abs(i)>Math.abs(o)&&(c=o,l=i),t[n.axis]=l,t._custom={barStart:c,barEnd:l,start:s,end:r,min:i,max:o}}(e,t,n,a):t[n.axis]=n.parse(e,a),t}function Ei(e,t,n,a){const s=e.iScale,r=e.vScale,i=s.getLabels(),o=s===r,c=[];let l,u,h,d;for(l=n,u=n+a;l<u;++l)d=t[l],h={},h[s.axis]=o||s.parse(i[l],l),c.push(Ti(d,h,r,l));return c}function Ri(e){return e&&void 0!==e.barStart&&void 0!==e.barEnd}function _i(e,t,n,a){let s=t.borderSkipped;const r={};if(!s)return void(e.borderSkipped=r);if(!0===s)return void(e.borderSkipped={top:!0,right:!0,bottom:!0,left:!0});const{start:i,end:o,reverse:c,top:l,bottom:u}=function(e){let t,n,a,s,r;return e.horizontal?(t=e.base>e.x,n="left",a="right"):(t=e.base<e.y,n="bottom",a="top"),t?(s="end",r="start"):(s="start",r="end"),{start:n,end:a,reverse:t,top:s,bottom:r}}(e);"middle"===s&&n&&(e.enableBorderRadius=!0,(n._top||0)===a?s=l:(n._bottom||0)===a?s=u:(r[Ai(u,i,o,c)]=!0,s=l)),r[Ai(s,i,o,c)]=!0,e.borderSkipped=r}function Ai(e,t,n,a){var s,r,i;return a?(i=n,e=Mi(e=(s=e)===(r=t)?i:s===i?r:s,n,t)):e=Mi(e,t,n),e}function Mi(e,t,n){return"start"===e?t:"end"===e?n:e}function Pi(e,t,n){let{inflateAmount:a}=t;e.inflateAmount="auto"===a?1===n?.33:0:a}On(Ii,"defaults",{}),On(Ii,"datasetElementType",null),On(Ii,"dataElementType",null);class Di extends Ii{parsePrimitiveData(e,t,n,a){return Ei(e,t,n,a)}parseArrayData(e,t,n,a){return Ei(e,t,n,a)}parseObjectData(e,t,n,a){const{iScale:s,vScale:r}=e,{xAxisKey:i="x",yAxisKey:o="y"}=this._parsing,c="x"===s.axis?i:o,l="x"===r.axis?i:o,u=[];let h,d,p,f;for(h=n,d=n+a;h<d;++h)f=t[h],p={},p[s.axis]=s.parse(Fa(f,c),h),u.push(Ti(Fa(f,l),p,r,h));return u}updateRangeFromParsed(e,t,n,a){super.updateRangeFromParsed(e,t,n,a);const s=n._custom;s&&t===this._cachedMeta.vScale&&(e.min=Math.min(e.min,s.min),e.max=Math.max(e.max,s.max))}getMaxOverflow(){return 0}getLabelAndValue(e){const t=this._cachedMeta,{iScale:n,vScale:a}=t,s=this.getParsed(e),r=s._custom,i=Ri(r)?"["+r.start+", "+r.end+"]":""+a.getLabelForValue(s[a.axis]);return{label:""+n.getLabelForValue(s[n.axis]),value:i}}initialize(){this.enableOptionSharing=!0,super.initialize();this._cachedMeta.stack=this.getDataset().stack}update(e){const t=this._cachedMeta;this.updateElements(t.data,0,t.data.length,e)}updateElements(e,t,n,a){const s="reset"===a,{index:r,_cachedMeta:{vScale:i}}=this,o=i.getBasePixel(),c=i.isHorizontal(),l=this._getRuler(),{sharedOptions:u,includeOptions:h}=this._getSharedOptions(t,a);for(let d=t;d<t+n;d++){const t=this.getParsed(d),n=s||xa(t[i.axis])?{base:o,head:o}:this._calculateBarValuePixels(d),p=this._calculateBarIndexPixels(d,l),f=(t._stacks||{})[i.axis],m={horizontal:c,base:n.base,enableBorderRadius:!f||Ri(t._custom)||r===f._top||r===f._bottom,x:c?n.head:p.center,y:c?p.center:n.head,height:c?p.size:Math.abs(n.size),width:c?Math.abs(n.size):p.size};h&&(m.options=u||this.resolveDataElementOptions(d,e[d].active?"active":a));const g=m.options||e[d].options;_i(m,g,f,r),Pi(m,g,l.ratio),this.updateElement(e[d],d,m,a)}}_getStacks(e,t){const{iScale:n}=this._cachedMeta,a=n.getMatchingVisibleMetas(this._type).filter(e=>e.controller.options.grouped),s=n.options.stacked,r=[],i=this._cachedMeta.controller.getParsed(t),o=i&&i[n.axis],c=e=>{const t=e._parsed.find(e=>e[n.axis]===o),a=t&&t[e.vScale.axis];if(xa(a)||isNaN(a))return!0};for(const l of a)if((void 0===t||!c(l))&&((!1===s||-1===r.indexOf(l.stack)||void 0===s&&void 0===l.stack)&&r.push(l.stack),l.index===e))break;return r.length||r.push(void 0),r}_getStackCount(e){return this._getStacks(void 0,e).length}_getAxisCount(){return this._getAxis().length}getFirstScaleIdForIndexAxis(){const e=this.chart.scales,t=this.chart.options.indexAxis;return Object.keys(e).filter(n=>e[n].axis===t).shift()}_getAxis(){const e={},t=this.getFirstScaleIdForIndexAxis();for(const n of this.chart.data.datasets)e[Ca("x"===this.chart.options.indexAxis?n.xAxisID:n.yAxisID,t)]=!0;return Object.keys(e)}_getStackIndex(e,t,n){const a=this._getStacks(e,n),s=void 0!==t?a.indexOf(t):-1;return-1===s?a.length-1:s}_getRuler(){const e=this.options,t=this._cachedMeta,n=t.iScale,a=[];let s,r;for(s=0,r=t.data.length;s<r;++s)a.push(n.getPixelForValue(this.getParsed(s)[n.axis],s));const i=e.barThickness;return{min:i||Ni(t),pixels:a,start:n._startPixel,end:n._endPixel,stackCount:this._getStackCount(),scale:n,grouped:e.grouped,ratio:i?1:e.categoryPercentage*e.barPercentage}}_calculateBarValuePixels(e){const{_cachedMeta:{vScale:t,_stacked:n,index:a},options:{base:s,minBarLength:r}}=this,i=s||0,o=this.getParsed(e),c=o._custom,l=Ri(c);let u,h,d=o[t.axis],p=0,f=n?this.applyStack(t,o,n):d;f!==d&&(p=f-d,f=d),l&&(d=c.barStart,f=c.barEnd-c.barStart,0!==d&&Qa(d)!==Qa(c.barEnd)&&(p=0),p+=d);const m=xa(s)||l?p:s;let g=t.getPixelForValue(m);if(u=this.chart.getDataVisibility(e)?t.getPixelForValue(p+f):g,h=u-g,Math.abs(h)<r){h=function(e,t,n){return 0!==e?Qa(e):(t.isHorizontal()?1:-1)*(t.min>=n?1:-1)}(h,t,i)*r,d===i&&(g-=h/2);const e=t.getPixelForDecimal(0),s=t.getPixelForDecimal(1),c=Math.min(e,s),p=Math.max(e,s);g=Math.max(Math.min(g,p),c),u=g+h,n&&!l&&(o._stacks[t.axis]._visualValues[a]=t.getValueForPixel(u)-t.getValueForPixel(g))}if(g===t.getPixelForValue(i)){const e=Qa(h)*t.getLineWidthForValue(i)/2;g+=e,h-=e}return{size:h,base:g,head:u,center:u+h/2}}_calculateBarIndexPixels(e,t){const n=t.scale,a=this.options,s=a.skipNull,r=Ca(a.maxBarThickness,1/0);let i,o;const c=this._getAxisCount();if(t.grouped){const n=s?this._getStackCount(e):t.stackCount,l="flex"===a.barThickness?function(e,t,n,a){const s=t.pixels,r=s[e];let i=e>0?s[e-1]:null,o=e<s.length-1?s[e+1]:null;const c=n.categoryPercentage;null===i&&(i=r-(null===o?t.end-t.start:o-r)),null===o&&(o=r+r-i);const l=r-(r-Math.min(i,o))/2*c;return{chunk:Math.abs(o-i)/2*c/a,ratio:n.barPercentage,start:l}}(e,t,a,n*c):function(e,t,n,a){const s=n.barThickness;let r,i;return xa(s)?(r=t.min*n.categoryPercentage,i=n.barPercentage):(r=s*a,i=1),{chunk:r/a,ratio:i,start:t.pixels[e]-r/2}}(e,t,a,n*c),u="x"===this.chart.options.indexAxis?this.getDataset().xAxisID:this.getDataset().yAxisID,h=this._getAxis().indexOf(Ca(u,this.getFirstScaleIdForIndexAxis())),d=this._getStackIndex(this.index,this._cachedMeta.stack,s?e:void 0)+h;i=l.start+l.chunk*d+l.chunk/2,o=Math.min(r,l.chunk*l.ratio)}else i=n.getPixelForValue(this.getParsed(e)[n.axis],e),o=Math.min(r,t.min*t.ratio);return{base:i-o/2,head:i+o/2,center:i,size:o}}draw(){const e=this._cachedMeta,t=e.vScale,n=e.data,a=n.length;let s=0;for(;s<a;++s)null===this.getParsed(s)[t.axis]||n[s].hidden||n[s].draw(this._ctx)}}On(Di,"id","bar"),On(Di,"defaults",{datasetElementType:!1,dataElementType:"bar",categoryPercentage:.8,barPercentage:.9,grouped:!0,animations:{numbers:{type:"number",properties:["x","y","base","width","height"]}}}),On(Di,"overrides",{scales:{_index_:{type:"category",offset:!0,grid:{offset:!0}},_value_:{type:"linear",beginAtZero:!0}}});class Oi extends Ii{initialize(){this.enableOptionSharing=!0,super.initialize()}parsePrimitiveData(e,t,n,a){const s=super.parsePrimitiveData(e,t,n,a);for(let r=0;r<s.length;r++)s[r]._custom=this.resolveDataElementOptions(r+n).radius;return s}parseArrayData(e,t,n,a){const s=super.parseArrayData(e,t,n,a);for(let r=0;r<s.length;r++){const e=t[n+r];s[r]._custom=Ca(e[2],this.resolveDataElementOptions(r+n).radius)}return s}parseObjectData(e,t,n,a){const s=super.parseObjectData(e,t,n,a);for(let r=0;r<s.length;r++){const e=t[n+r];s[r]._custom=Ca(e&&e.r&&+e.r,this.resolveDataElementOptions(r+n).radius)}return s}getMaxOverflow(){const e=this._cachedMeta.data;let t=0;for(let n=e.length-1;n>=0;--n)t=Math.max(t,e[n].size(this.resolveDataElementOptions(n))/2);return t>0&&t}getLabelAndValue(e){const t=this._cachedMeta,n=this.chart.data.labels||[],{xScale:a,yScale:s}=t,r=this.getParsed(e),i=a.getLabelForValue(r.x),o=s.getLabelForValue(r.y),c=r._custom;return{label:n[e]||"",value:"("+i+", "+o+(c?", "+c:"")+")"}}update(e){const t=this._cachedMeta.data;this.updateElements(t,0,t.length,e)}updateElements(e,t,n,a){const s="reset"===a,{iScale:r,vScale:i}=this._cachedMeta,{sharedOptions:o,includeOptions:c}=this._getSharedOptions(t,a),l=r.axis,u=i.axis;for(let h=t;h<t+n;h++){const t=e[h],n=!s&&this.getParsed(h),d={},p=d[l]=s?r.getPixelForDecimal(.5):r.getPixelForValue(n[l]),f=d[u]=s?i.getBasePixel():i.getPixelForValue(n[u]);d.skip=isNaN(p)||isNaN(f),c&&(d.options=o||this.resolveDataElementOptions(h,t.active?"active":a),s&&(d.options.radius=0)),this.updateElement(t,h,d,a)}}resolveDataElementOptions(e,t){const n=this.getParsed(e);let a=super.resolveDataElementOptions(e,t);a.$shared&&(a=Object.assign({},a,{$shared:!1}));const s=a.radius;return"active"!==t&&(a.radius=0),a.radius+=Ca(n&&n._custom,s),a}}On(Oi,"id","bubble"),On(Oi,"defaults",{datasetElementType:!1,dataElementType:"point",animations:{numbers:{type:"number",properties:["x","y","borderWidth","radius"]}}}),On(Oi,"overrides",{scales:{x:{type:"linear"},y:{type:"linear"}}});class Fi extends Ii{constructor(e,t){super(e,t),this.enableOptionSharing=!0,this.innerRadius=void 0,this.outerRadius=void 0,this.offsetX=void 0,this.offsetY=void 0}linkScales(){}parse(e,t){const n=this.getDataset().data,a=this._cachedMeta;if(!1===this._parsing)a._parsed=n;else{let s,r,i=e=>+n[e];if(wa(n[e])){const{key:e="value"}=this._parsing;i=t=>+Fa(n[t],e)}for(s=e,r=e+t;s<r;++s)a._parsed[s]=i(s)}}_getRotation(){return ts(this.options.rotation-90)}_getCircumference(){return ts(this.options.circumference)}_getRotationExtents(){let e=Va,t=-Va;for(let n=0;n<this.chart.data.datasets.length;++n)if(this.chart.isDatasetVisible(n)&&this.chart.getDatasetMeta(n).type===this._type){const a=this.chart.getDatasetMeta(n).controller,s=a._getRotation(),r=a._getCircumference();e=Math.min(e,s),t=Math.max(t,s+r)}return{rotation:e,circumference:t-e}}update(e){const t=this.chart,{chartArea:n}=t,a=this._cachedMeta,s=a.data,r=this.getMaxBorderWidth()+this.getMaxOffset(s)+this.options.spacing,i=Math.max((Math.min(n.width,n.height)-r)/2,0),o=Math.min((c=this.options.cutout,l=i,"string"===typeof c&&c.endsWith("%")?parseFloat(c)/100:+c/l),1);var c,l;const u=this._getRingWeight(this.index),{circumference:h,rotation:d}=this._getRotationExtents(),{ratioX:p,ratioY:f,offsetX:m,offsetY:g}=function(e,t,n){let a=1,s=1,r=0,i=0;if(t<Va){const o=e,c=o+t,l=Math.cos(o),u=Math.sin(o),h=Math.cos(c),d=Math.sin(c),p=(e,t,a)=>cs(e,o,c,!0)?1:Math.max(t,t*n,a,a*n),f=(e,t,a)=>cs(e,o,c,!0)?-1:Math.min(t,t*n,a,a*n),m=p(0,l,h),g=p(qa,u,d),y=f(Wa,l,h),b=f(Wa+qa,u,d);a=(m-y)/2,s=(g-b)/2,r=-(m+y)/2,i=-(g+b)/2}return{ratioX:a,ratioY:s,offsetX:r,offsetY:i}}(d,h,o),y=(n.width-r)/p,b=(n.height-r)/f,x=Math.max(Math.min(y,b)/2,0),v=Ia(this.options.radius,x),w=(v-Math.max(v*o,0))/this._getVisibleDatasetWeightTotal();this.offsetX=m*v,this.offsetY=g*v,a.total=this.calculateTotal(),this.outerRadius=v-w*this._getRingWeightOffset(this.index),this.innerRadius=Math.max(this.outerRadius-w*u,0),this.updateElements(s,0,s.length,e)}_circumference(e,t){const n=this.options,a=this._cachedMeta,s=this._getCircumference();return t&&n.animation.animateRotate||!this.chart.getDataVisibility(e)||null===a._parsed[e]||a.data[e].hidden?0:this.calculateCircumference(a._parsed[e]*s/Va)}updateElements(e,t,n,a){const s="reset"===a,r=this.chart,i=r.chartArea,o=r.options.animation,c=(i.left+i.right)/2,l=(i.top+i.bottom)/2,u=s&&o.animateScale,h=u?0:this.innerRadius,d=u?0:this.outerRadius,{sharedOptions:p,includeOptions:f}=this._getSharedOptions(t,a);let m,g=this._getRotation();for(m=0;m<t;++m)g+=this._circumference(m,s);for(m=t;m<t+n;++m){const t=this._circumference(m,s),n=e[m],r={x:c+this.offsetX,y:l+this.offsetY,startAngle:g,endAngle:g+t,circumference:t,outerRadius:d,innerRadius:h};f&&(r.options=p||this.resolveDataElementOptions(m,n.active?"active":a)),g+=t,this.updateElement(n,m,r,a)}}calculateTotal(){const e=this._cachedMeta,t=e.data;let n,a=0;for(n=0;n<t.length;n++){const s=e._parsed[n];null===s||isNaN(s)||!this.chart.getDataVisibility(n)||t[n].hidden||(a+=Math.abs(s))}return a}calculateCircumference(e){const t=this._cachedMeta.total;return t>0&&!isNaN(e)?Va*(Math.abs(e)/t):0}getLabelAndValue(e){const t=this._cachedMeta,n=this.chart,a=n.data.labels||[],s=Ps(t._parsed[e],n.options.locale);return{label:a[e]||"",value:s}}getMaxBorderWidth(e){let t=0;const n=this.chart;let a,s,r,i,o;if(!e)for(a=0,s=n.data.datasets.length;a<s;++a)if(n.isDatasetVisible(a)){r=n.getDatasetMeta(a),e=r.data,i=r.controller;break}if(!e)return 0;for(a=0,s=e.length;a<s;++a)o=i.resolveDataElementOptions(a),"inner"!==o.borderAlign&&(t=Math.max(t,o.borderWidth||0,o.hoverBorderWidth||0));return t}getMaxOffset(e){let t=0;for(let n=0,a=e.length;n<a;++n){const e=this.resolveDataElementOptions(n);t=Math.max(t,e.offset||0,e.hoverOffset||0)}return t}_getRingWeightOffset(e){let t=0;for(let n=0;n<e;++n)this.chart.isDatasetVisible(n)&&(t+=this._getRingWeight(n));return t}_getRingWeight(e){return Math.max(Ca(this.chart.data.datasets[e].weight,1),0)}_getVisibleDatasetWeightTotal(){return this._getRingWeightOffset(this.chart.data.datasets.length)||1}}On(Fi,"id","doughnut"),On(Fi,"defaults",{datasetElementType:!1,dataElementType:"arc",animation:{animateRotate:!0,animateScale:!1},animations:{numbers:{type:"number",properties:["circumference","endAngle","innerRadius","outerRadius","startAngle","x","y","offset","borderWidth","spacing"]}},cutout:"50%",rotation:0,circumference:360,radius:"100%",spacing:0,indexAxis:"r"}),On(Fi,"descriptors",{_scriptable:e=>"spacing"!==e,_indexable:e=>"spacing"!==e&&!e.startsWith("borderDash")&&!e.startsWith("hoverBorderDash")}),On(Fi,"overrides",{aspectRatio:1,plugins:{legend:{labels:{generateLabels(e){const t=e.data,{labels:{pointStyle:n,textAlign:a,color:s,useBorderRadius:r,borderRadius:i}}=e.legend.options;return t.labels.length&&t.datasets.length?t.labels.map((t,o)=>{const c=e.getDatasetMeta(0).controller.getStyle(o);return{text:t,fillStyle:c.backgroundColor,fontColor:s,hidden:!e.getDataVisibility(o),lineDash:c.borderDash,lineDashOffset:c.borderDashOffset,lineJoin:c.borderJoinStyle,lineWidth:c.borderWidth,strokeStyle:c.borderColor,textAlign:a,pointStyle:n,borderRadius:r&&(i||c.borderRadius),index:o}}):[]}},onClick(e,t,n){n.chart.toggleDataVisibility(t.index),n.chart.update()}}}});class Li extends Ii{initialize(){this.enableOptionSharing=!0,this.supportsDecimation=!0,super.initialize()}update(e){const t=this._cachedMeta,{dataset:n,data:a=[],_dataset:s}=t,r=this.chart._animationsDisabled;let{start:i,count:o}=ws(t,a,r);this._drawStart=i,this._drawCount=o,ks(t)&&(i=0,o=a.length),n._chart=this.chart,n._datasetIndex=this.index,n._decimated=!!s._decimated,n.points=a;const c=this.resolveDatasetElementOptions(e);this.options.showLine||(c.borderWidth=0),c.segment=this.options.segment,this.updateElement(n,void 0,{animated:!r,options:c},e),this.updateElements(a,i,o,e)}updateElements(e,t,n,a){const s="reset"===a,{iScale:r,vScale:i,_stacked:o,_dataset:c}=this._cachedMeta,{sharedOptions:l,includeOptions:u}=this._getSharedOptions(t,a),h=r.axis,d=i.axis,{spanGaps:p,segment:f}=this.options,m=$a(p)?p:Number.POSITIVE_INFINITY,g=this.chart._animationsDisabled||s||"none"===a,y=t+n,b=e.length;let x=t>0&&this.getParsed(t-1);for(let v=0;v<b;++v){const n=e[v],p=g?n:{};if(v<t||v>=y){p.skip=!0;continue}const b=this.getParsed(v),w=xa(b[d]),k=p[h]=r.getPixelForValue(b[h],v),S=p[d]=s||w?i.getBasePixel():i.getPixelForValue(o?this.applyStack(i,b,o):b[d],v);p.skip=isNaN(k)||isNaN(S)||w,p.stop=v>0&&Math.abs(b[h]-x[h])>m,f&&(p.parsed=b,p.raw=c.data[v]),u&&(p.options=l||this.resolveDataElementOptions(v,n.active?"active":a)),g||this.updateElement(n,v,p,a),x=b}}getMaxOverflow(){const e=this._cachedMeta,t=e.dataset,n=t.options&&t.options.borderWidth||0,a=e.data||[];if(!a.length)return n;const s=a[0].size(this.resolveDataElementOptions(0)),r=a[a.length-1].size(this.resolveDataElementOptions(a.length-1));return Math.max(n,s,r)/2}draw(){const e=this._cachedMeta;e.dataset.updateControlPoints(this.chart.chartArea,e.iScale.axis),super.draw()}}On(Li,"id","line"),On(Li,"defaults",{datasetElementType:"line",dataElementType:"point",showLine:!0,spanGaps:!1}),On(Li,"overrides",{scales:{_index_:{type:"category"},_value_:{type:"linear"}}});class zi extends Ii{constructor(e,t){super(e,t),this.innerRadius=void 0,this.outerRadius=void 0}getLabelAndValue(e){const t=this._cachedMeta,n=this.chart,a=n.data.labels||[],s=Ps(t._parsed[e].r,n.options.locale);return{label:a[e]||"",value:s}}parseObjectData(e,t,n,a){return Tr.bind(this)(e,t,n,a)}update(e){const t=this._cachedMeta.data;this._updateRadius(),this.updateElements(t,0,t.length,e)}getMinMax(){const e=this._cachedMeta,t={min:Number.POSITIVE_INFINITY,max:Number.NEGATIVE_INFINITY};return e.data.forEach((e,n)=>{const a=this.getParsed(n).r;!isNaN(a)&&this.chart.getDataVisibility(n)&&(a<t.min&&(t.min=a),a>t.max&&(t.max=a))}),t}_updateRadius(){const e=this.chart,t=e.chartArea,n=e.options,a=Math.min(t.right-t.left,t.bottom-t.top),s=Math.max(a/2,0),r=(s-Math.max(n.cutoutPercentage?s/100*n.cutoutPercentage:1,0))/e.getVisibleDatasetCount();this.outerRadius=s-r*this.index,this.innerRadius=this.outerRadius-r}updateElements(e,t,n,a){const s="reset"===a,r=this.chart,i=r.options.animation,o=this._cachedMeta.rScale,c=o.xCenter,l=o.yCenter,u=o.getIndexAngle(0)-.5*Wa;let h,d=u;const p=360/this.countVisibleElements();for(h=0;h<t;++h)d+=this._computeAngle(h,a,p);for(h=t;h<t+n;h++){const t=e[h];let n=d,f=d+this._computeAngle(h,a,p),m=r.getDataVisibility(h)?o.getDistanceFromCenterForValue(this.getParsed(h).r):0;d=f,s&&(i.animateScale&&(m=0),i.animateRotate&&(n=f=u));const g={x:c,y:l,innerRadius:0,outerRadius:m,startAngle:n,endAngle:f,options:this.resolveDataElementOptions(h,t.active?"active":a)};this.updateElement(t,h,g,a)}}countVisibleElements(){const e=this._cachedMeta;let t=0;return e.data.forEach((e,n)=>{!isNaN(this.getParsed(n).r)&&this.chart.getDataVisibility(n)&&t++}),t}_computeAngle(e,t,n){return this.chart.getDataVisibility(e)?ts(this.resolveDataElementOptions(e,t).angle||n):0}}On(zi,"id","polarArea"),On(zi,"defaults",{dataElementType:"arc",animation:{animateRotate:!0,animateScale:!0},animations:{numbers:{type:"number",properties:["x","y","startAngle","endAngle","innerRadius","outerRadius"]}},indexAxis:"r",startAngle:0}),On(zi,"overrides",{aspectRatio:1,plugins:{legend:{labels:{generateLabels(e){const t=e.data;if(t.labels.length&&t.datasets.length){const{labels:{pointStyle:n,color:a}}=e.legend.options;return t.labels.map((t,s)=>{const r=e.getDatasetMeta(0).controller.getStyle(s);return{text:t,fillStyle:r.backgroundColor,strokeStyle:r.borderColor,fontColor:a,lineWidth:r.borderWidth,pointStyle:n,hidden:!e.getDataVisibility(s),index:s}})}return[]}},onClick(e,t,n){n.chart.toggleDataVisibility(t.index),n.chart.update()}}},scales:{r:{type:"radialLinear",angleLines:{display:!1},beginAtZero:!0,grid:{circular:!0},pointLabels:{display:!1},startAngle:0}}});class Bi extends Fi{}On(Bi,"id","pie"),On(Bi,"defaults",{cutout:0,rotation:0,circumference:360,radius:"100%"});class ji extends Ii{getLabelAndValue(e){const t=this._cachedMeta.vScale,n=this.getParsed(e);return{label:t.getLabels()[e],value:""+t.getLabelForValue(n[t.axis])}}parseObjectData(e,t,n,a){return Tr.bind(this)(e,t,n,a)}update(e){const t=this._cachedMeta,n=t.dataset,a=t.data||[],s=t.iScale.getLabels();if(n.points=a,"resize"!==e){const t=this.resolveDatasetElementOptions(e);this.options.showLine||(t.borderWidth=0);const r={_loop:!0,_fullLoop:s.length===a.length,options:t};this.updateElement(n,void 0,r,e)}this.updateElements(a,0,a.length,e)}updateElements(e,t,n,a){const s=this._cachedMeta.rScale,r="reset"===a;for(let i=t;i<t+n;i++){const t=e[i],n=this.resolveDataElementOptions(i,t.active?"active":a),o=s.getPointPositionForValue(i,this.getParsed(i).r),c=r?s.xCenter:o.x,l=r?s.yCenter:o.y,u={x:c,y:l,angle:o.angle,skip:isNaN(c)||isNaN(l),options:n};this.updateElement(t,i,u,a)}}}On(ji,"id","radar"),On(ji,"defaults",{datasetElementType:"line",dataElementType:"point",indexAxis:"r",showLine:!0,elements:{line:{fill:"start"}}}),On(ji,"overrides",{aspectRatio:1,scales:{r:{type:"radialLinear"}}});class Wi extends Ii{getLabelAndValue(e){const t=this._cachedMeta,n=this.chart.data.labels||[],{xScale:a,yScale:s}=t,r=this.getParsed(e),i=a.getLabelForValue(r.x),o=s.getLabelForValue(r.y);return{label:n[e]||"",value:"("+i+", "+o+")"}}update(e){const t=this._cachedMeta,{data:n=[]}=t,a=this.chart._animationsDisabled;let{start:s,count:r}=ws(t,n,a);if(this._drawStart=s,this._drawCount=r,ks(t)&&(s=0,r=n.length),this.options.showLine){this.datasetElementType||this.addElements();const{dataset:s,_dataset:r}=t;s._chart=this.chart,s._datasetIndex=this.index,s._decimated=!!r._decimated,s.points=n;const i=this.resolveDatasetElementOptions(e);i.segment=this.options.segment,this.updateElement(s,void 0,{animated:!a,options:i},e)}else this.datasetElementType&&(delete t.dataset,this.datasetElementType=!1);this.updateElements(n,s,r,e)}addElements(){const{showLine:e}=this.options;!this.datasetElementType&&e&&(this.datasetElementType=this.chart.registry.getElement("line")),super.addElements()}updateElements(e,t,n,a){const s="reset"===a,{iScale:r,vScale:i,_stacked:o,_dataset:c}=this._cachedMeta,l=this.resolveDataElementOptions(t,a),u=this.getSharedOptions(l),h=this.includeOptions(a,u),d=r.axis,p=i.axis,{spanGaps:f,segment:m}=this.options,g=$a(f)?f:Number.POSITIVE_INFINITY,y=this.chart._animationsDisabled||s||"none"===a;let b=t>0&&this.getParsed(t-1);for(let x=t;x<t+n;++x){const t=e[x],n=this.getParsed(x),l=y?t:{},f=xa(n[p]),v=l[d]=r.getPixelForValue(n[d],x),w=l[p]=s||f?i.getBasePixel():i.getPixelForValue(o?this.applyStack(i,n,o):n[p],x);l.skip=isNaN(v)||isNaN(w)||f,l.stop=x>0&&Math.abs(n[d]-b[d])>g,m&&(l.parsed=n,l.raw=c.data[x]),h&&(l.options=u||this.resolveDataElementOptions(x,t.active?"active":a)),y||this.updateElement(t,x,l,a),b=n}this.updateSharedOptions(u,a,l)}getMaxOverflow(){const e=this._cachedMeta,t=e.data||[];if(!this.options.showLine){let e=0;for(let n=t.length-1;n>=0;--n)e=Math.max(e,t[n].size(this.resolveDataElementOptions(n))/2);return e>0&&e}const n=e.dataset,a=n.options&&n.options.borderWidth||0;if(!t.length)return a;const s=t[0].size(this.resolveDataElementOptions(0)),r=t[t.length-1].size(this.resolveDataElementOptions(t.length-1));return Math.max(a,s,r)/2}}On(Wi,"id","scatter"),On(Wi,"defaults",{datasetElementType:!1,dataElementType:"point",showLine:!1,fill:!1}),On(Wi,"overrides",{interaction:{mode:"point"},scales:{x:{type:"linear"},y:{type:"linear"}}});function Vi(){throw new Error("This method is not implemented: Check that a complete date adapter is provided.")}class Ui{static override(e){Object.assign(Ui.prototype,e)}constructor(e){On(this,"options",void 0),this.options=e||{}}init(){}formats(){return Vi()}parse(){return Vi()}format(){return Vi()}add(){return Vi()}diff(){return Vi()}startOf(){return Vi()}endOf(){return Vi()}}var Hi=Ui;function Gi(e,t,n,a){const{controller:s,data:r,_sorted:i}=e,o=s._cachedMeta.iScale,c=e.dataset&&e.dataset.options?e.dataset.options.spanGaps:null;if(o&&t===o.axis&&"r"!==t&&i&&r.length){const i=o._reversePixels?ps:ds;if(!a){const a=i(r,t,n);if(c){const{vScale:t}=s._cachedMeta,{_parsed:n}=e,r=n.slice(0,a.lo+1).reverse().findIndex(e=>!xa(e[t.axis]));a.lo-=Math.max(0,r);const i=n.slice(a.hi).findIndex(e=>!xa(e[t.axis]));a.hi+=Math.max(0,i)}return a}if(s._sharedOptions){const e=r[0],a="function"===typeof e.getRange&&e.getRange(t);if(a){const e=i(r,t,n-a),s=i(r,t,n+a);return{lo:e.lo,hi:s.hi}}}}return{lo:0,hi:r.length-1}}function qi(e,t,n,a,s){const r=e.getSortedVisibleDatasetMetas(),i=n[t];for(let o=0,c=r.length;o<c;++o){const{index:e,data:n}=r[o],{lo:c,hi:l}=Gi(r[o],t,i,s);for(let t=c;t<=l;++t){const s=n[t];s.skip||a(s,e,t)}}}function Ki(e,t,n,a,s){const r=[];if(!s&&!e.isPointInArea(t))return r;return qi(e,n,t,function(n,i,o){(s||Xs(n,e.chartArea,0))&&n.inRange(t.x,t.y,a)&&r.push({element:n,datasetIndex:i,index:o})},!0),r}function Xi(e,t,n,a,s,r){let i=[];const o=function(e){const t=-1!==e.indexOf("x"),n=-1!==e.indexOf("y");return function(e,a){const s=t?Math.abs(e.x-a.x):0,r=n?Math.abs(e.y-a.y):0;return Math.sqrt(Math.pow(s,2)+Math.pow(r,2))}}(n);let c=Number.POSITIVE_INFINITY;return qi(e,n,t,function(n,l,u){const h=n.inRange(t.x,t.y,s);if(a&&!h)return;const d=n.getCenterPoint(s);if(!(!!r||e.isPointInArea(d))&&!h)return;const p=o(t,d);p<c?(i=[{element:n,datasetIndex:l,index:u}],c=p):p===c&&i.push({element:n,datasetIndex:l,index:u})}),i}function Yi(e,t,n,a,s,r){return r||e.isPointInArea(t)?"r"!==n||a?Xi(e,t,n,a,s,r):function(e,t,n,a){let s=[];return qi(e,n,t,function(e,n,r){const{startAngle:i,endAngle:o}=e.getProps(["startAngle","endAngle"],a),{angle:c}=ss(e,{x:t.x,y:t.y});cs(c,i,o)&&s.push({element:e,datasetIndex:n,index:r})}),s}(e,t,n,s):[]}function Qi(e,t,n,a,s){const r=[],i="x"===n?"inXRange":"inYRange";let o=!1;return qi(e,n,t,(e,a,c)=>{e[i]&&e[i](t[n],s)&&(r.push({element:e,datasetIndex:a,index:c}),o=o||e.inRange(t.x,t.y,s))}),a&&!o?[]:r}var Zi={evaluateInteractionItems:qi,modes:{index(e,t,n,a){const s=Wr(t,e),r=n.axis||"x",i=n.includeInvisible||!1,o=n.intersect?Ki(e,s,r,a,i):Yi(e,s,r,!1,a,i),c=[];return o.length?(e.getSortedVisibleDatasetMetas().forEach(e=>{const t=o[0].index,n=e.data[t];n&&!n.skip&&c.push({element:n,datasetIndex:e.index,index:t})}),c):[]},dataset(e,t,n,a){const s=Wr(t,e),r=n.axis||"xy",i=n.includeInvisible||!1;let o=n.intersect?Ki(e,s,r,a,i):Yi(e,s,r,!1,a,i);if(o.length>0){const t=o[0].datasetIndex,n=e.getDatasetMeta(t).data;o=[];for(let e=0;e<n.length;++e)o.push({element:n[e],datasetIndex:t,index:e})}return o},point:(e,t,n,a)=>Ki(e,Wr(t,e),n.axis||"xy",a,n.includeInvisible||!1),nearest(e,t,n,a){const s=Wr(t,e),r=n.axis||"xy",i=n.includeInvisible||!1;return Yi(e,s,r,n.intersect,a,i)},x:(e,t,n,a)=>Qi(e,Wr(t,e),"x",n.intersect,a),y:(e,t,n,a)=>Qi(e,Wr(t,e),"y",n.intersect,a)}};const Ji=["left","top","right","bottom"];function $i(e,t){return e.filter(e=>e.pos===t)}function eo(e,t){return e.filter(e=>-1===Ji.indexOf(e.pos)&&e.box.axis===t)}function to(e,t){return e.sort((e,n)=>{const a=t?n:e,s=t?e:n;return a.weight===s.weight?a.index-s.index:a.weight-s.weight})}function no(e,t){const n=function(e){const t={};for(const n of e){const{stack:e,pos:a,stackWeight:s}=n;if(!e||!Ji.includes(a))continue;const r=t[e]||(t[e]={count:0,placed:0,weight:0,size:0});r.count++,r.weight+=s}return t}(e),{vBoxMaxWidth:a,hBoxMaxHeight:s}=t;let r,i,o;for(r=0,i=e.length;r<i;++r){o=e[r];const{fullSize:i}=o.box,c=n[o.stack],l=c&&o.stackWeight/c.weight;o.horizontal?(o.width=l?l*a:i&&t.availableWidth,o.height=s):(o.width=a,o.height=l?l*s:i&&t.availableHeight)}return n}function ao(e,t,n,a){return Math.max(e[n],t[n])+Math.max(e[a],t[a])}function so(e,t){e.top=Math.max(e.top,t.top),e.left=Math.max(e.left,t.left),e.bottom=Math.max(e.bottom,t.bottom),e.right=Math.max(e.right,t.right)}function ro(e,t,n,a){const{pos:s,box:r}=n,i=e.maxPadding;if(!wa(s)){n.size&&(e[s]-=n.size);const t=a[n.stack]||{size:0,count:1};t.size=Math.max(t.size,n.horizontal?r.height:r.width),n.size=t.size/t.count,e[s]+=n.size}r.getPadding&&so(i,r.getPadding());const o=Math.max(0,t.outerWidth-ao(i,e,"left","right")),c=Math.max(0,t.outerHeight-ao(i,e,"top","bottom")),l=o!==e.w,u=c!==e.h;return e.w=o,e.h=c,n.horizontal?{same:l,other:u}:{same:u,other:l}}function io(e,t){const n=t.maxPadding;function a(e){const a={left:0,top:0,right:0,bottom:0};return e.forEach(e=>{a[e]=Math.max(t[e],n[e])}),a}return a(e?["left","right"]:["top","bottom"])}function oo(e,t,n,a){const s=[];let r,i,o,c,l,u;for(r=0,i=e.length,l=0;r<i;++r){o=e[r],c=o.box,c.update(o.width||t.w,o.height||t.h,io(o.horizontal,t));const{same:i,other:h}=ro(t,n,o,a);l|=i&&s.length,u=u||h,c.fullSize||s.push(o)}return l&&oo(s,t,n,a)||u}function co(e,t,n,a,s){e.top=n,e.left=t,e.right=t+a,e.bottom=n+s,e.width=a,e.height=s}function lo(e,t,n,a){const s=n.padding;let{x:r,y:i}=t;for(const o of e){const e=o.box,c=a[o.stack]||{count:1,placed:0,weight:1},l=o.stackWeight/c.weight||1;if(o.horizontal){const a=t.w*l,r=c.size||e.height;za(c.start)&&(i=c.start),e.fullSize?co(e,s.left,i,n.outerWidth-s.right-s.left,r):co(e,t.left+c.placed,i,a,r),c.start=i,c.placed+=a,i=e.bottom}else{const a=t.h*l,i=c.size||e.width;za(c.start)&&(r=c.start),e.fullSize?co(e,r,s.top,i,n.outerHeight-s.bottom-s.top):co(e,r,t.top+c.placed,i,a),c.start=r,c.placed+=a,r=e.right}}t.x=r,t.y=i}var uo={addBox(e,t){e.boxes||(e.boxes=[]),t.fullSize=t.fullSize||!1,t.position=t.position||"top",t.weight=t.weight||0,t._layers=t._layers||function(){return[{z:0,draw(e){t.draw(e)}}]},e.boxes.push(t)},removeBox(e,t){const n=e.boxes?e.boxes.indexOf(t):-1;-1!==n&&e.boxes.splice(n,1)},configure(e,t,n){t.fullSize=n.fullSize,t.position=n.position,t.weight=n.weight},update(e,t,n,a){if(!e)return;const s=ur(e.options.layout.padding),r=Math.max(t-s.width,0),i=Math.max(n-s.height,0),o=function(e){const t=function(e){const t=[];let n,a,s,r,i,o;for(n=0,a=(e||[]).length;n<a;++n)s=e[n],({position:r,options:{stack:i,stackWeight:o=1}}=s),t.push({index:n,box:s,pos:r,horizontal:s.isHorizontal(),weight:s.weight,stack:i&&r+i,stackWeight:o});return t}(e),n=to(t.filter(e=>e.box.fullSize),!0),a=to($i(t,"left"),!0),s=to($i(t,"right")),r=to($i(t,"top"),!0),i=to($i(t,"bottom")),o=eo(t,"x"),c=eo(t,"y");return{fullSize:n,leftAndTop:a.concat(r),rightAndBottom:s.concat(c).concat(i).concat(o),chartArea:$i(t,"chartArea"),vertical:a.concat(s).concat(c),horizontal:r.concat(i).concat(o)}}(e.boxes),c=o.vertical,l=o.horizontal;Ta(e.boxes,e=>{"function"===typeof e.beforeLayout&&e.beforeLayout()});const u=c.reduce((e,t)=>t.box.options&&!1===t.box.options.display?e:e+1,0)||1,h=Object.freeze({outerWidth:t,outerHeight:n,padding:s,availableWidth:r,availableHeight:i,vBoxMaxWidth:r/2/u,hBoxMaxHeight:i/2}),d=Object.assign({},s);so(d,ur(a));const p=Object.assign({maxPadding:d,w:r,h:i,x:s.left,y:s.top},s),f=no(c.concat(l),h);oo(o.fullSize,p,h,f),oo(c,p,h,f),oo(l,p,h,f)&&oo(c,p,h,f),function(e){const t=e.maxPadding;function n(n){const a=Math.max(t[n]-e[n],0);return e[n]+=a,a}e.y+=n("top"),e.x+=n("left"),n("right"),n("bottom")}(p),lo(o.leftAndTop,p,h,f),p.x+=p.w,p.y+=p.h,lo(o.rightAndBottom,p,h,f),e.chartArea={left:p.left,top:p.top,right:p.left+p.w,bottom:p.top+p.h,height:p.h,width:p.w},Ta(o.chartArea,t=>{const n=t.box;Object.assign(n,e.chartArea),n.update(p.w,p.h,{left:0,top:0,right:0,bottom:0})})}};class ho{acquireContext(e,t){}releaseContext(e){return!1}addEventListener(e,t,n){}removeEventListener(e,t,n){}getDevicePixelRatio(){return 1}getMaximumSize(e,t,n,a){return t=Math.max(0,t||e.width),n=n||e.height,{width:t,height:Math.max(0,a?Math.floor(t/a):n)}}isAttached(e){return!0}updateConfig(e){}}class po extends ho{acquireContext(e){return e&&e.getContext&&e.getContext("2d")||null}updateConfig(e){e.options.animation=!1}}const fo="$chartjs",mo={touchstart:"mousedown",touchmove:"mousemove",touchend:"mouseup",pointerenter:"mouseenter",pointerdown:"mousedown",pointermove:"mousemove",pointerup:"mouseup",pointerleave:"mouseout",pointerout:"mouseout"},go=e=>null===e||""===e;const yo=!!Gr&&{passive:!0};function bo(e,t,n){e&&e.canvas&&e.canvas.removeEventListener(t,n,yo)}function xo(e,t){for(const n of e)if(n===t||n.contains(t))return!0}function vo(e,t,n){const a=e.canvas,s=new MutationObserver(e=>{let t=!1;for(const n of e)t=t||xo(n.addedNodes,a),t=t&&!xo(n.removedNodes,a);t&&n()});return s.observe(document,{childList:!0,subtree:!0}),s}function wo(e,t,n){const a=e.canvas,s=new MutationObserver(e=>{let t=!1;for(const n of e)t=t||xo(n.removedNodes,a),t=t&&!xo(n.addedNodes,a);t&&n()});return s.observe(document,{childList:!0,subtree:!0}),s}const ko=new Map;let So=0;function Co(){const e=window.devicePixelRatio;e!==So&&(So=e,ko.forEach((t,n)=>{n.currentDevicePixelRatio!==e&&t()}))}function Io(e,t,n){const a=e.canvas,s=a&&Fr(a);if(!s)return;const r=bs((e,t)=>{const a=s.clientWidth;n(e,t),a<s.clientWidth&&n()},window),i=new ResizeObserver(e=>{const t=e[0],n=t.contentRect.width,a=t.contentRect.height;0===n&&0===a||r(n,a)});return i.observe(s),function(e,t){ko.size||window.addEventListener("resize",Co),ko.set(e,t)}(e,r),i}function No(e,t,n){n&&n.disconnect(),"resize"===t&&function(e){ko.delete(e),ko.size||window.removeEventListener("resize",Co)}(e)}function To(e,t,n){const a=e.canvas,s=bs(t=>{null!==e.ctx&&n(function(e,t){const n=mo[e.type]||e.type,{x:a,y:s}=Wr(e,t);return{type:n,chart:t,native:e,x:void 0!==a?a:null,y:void 0!==s?s:null}}(t,e))},e);return function(e,t,n){e&&e.addEventListener(t,n,yo)}(a,t,s),s}class Eo extends ho{acquireContext(e,t){const n=e&&e.getContext&&e.getContext("2d");return n&&n.canvas===e?(function(e,t){const n=e.style,a=e.getAttribute("height"),s=e.getAttribute("width");if(e[fo]={initial:{height:a,width:s,style:{display:n.display,height:n.height,width:n.width}}},n.display=n.display||"block",n.boxSizing=n.boxSizing||"border-box",go(s)){const t=qr(e,"width");void 0!==t&&(e.width=t)}if(go(a))if(""===e.style.height)e.height=e.width/(t||2);else{const t=qr(e,"height");void 0!==t&&(e.height=t)}}(e,t),n):null}releaseContext(e){const t=e.canvas;if(!t[fo])return!1;const n=t[fo].initial;["height","width"].forEach(e=>{const a=n[e];xa(a)?t.removeAttribute(e):t.setAttribute(e,a)});const a=n.style||{};return Object.keys(a).forEach(e=>{t.style[e]=a[e]}),t.width=t.width,delete t[fo],!0}addEventListener(e,t,n){this.removeEventListener(e,t);const a=e.$proxies||(e.$proxies={}),s={attach:vo,detach:wo,resize:Io}[t]||To;a[t]=s(e,t,n)}removeEventListener(e,t){const n=e.$proxies||(e.$proxies={}),a=n[t];if(!a)return;({attach:No,detach:No,resize:No}[t]||bo)(e,t,a),n[t]=void 0}getDevicePixelRatio(){return window.devicePixelRatio}getMaximumSize(e,t,n,a){return Ur(e,t,n,a)}isAttached(e){const t=e&&Fr(e);return!(!t||!t.isConnected)}}class Ro{constructor(){On(this,"x",void 0),On(this,"y",void 0),On(this,"active",!1),On(this,"options",void 0),On(this,"$animations",void 0)}tooltipPosition(e){const{x:t,y:n}=this.getProps(["x","y"],e);return{x:t,y:n}}hasValue(){return $a(this.x)&&$a(this.y)}getProps(e,t){const n=this.$animations;if(!t||!n)return this;const a={};return e.forEach(e=>{a[e]=n[e]&&n[e].active()?n[e]._to:this[e]}),a}}function _o(e,t){const n=e.options.ticks,a=function(e){const t=e.options.offset,n=e._tickSize(),a=e._length/n+(t?0:1),s=e._maxLength/n;return Math.floor(Math.min(a,s))}(e),s=Math.min(n.maxTicksLimit||a,a),r=n.major.enabled?function(e){const t=[];let n,a;for(n=0,a=e.length;n<a;n++)e[n].major&&t.push(n);return t}(t):[],i=r.length,o=r[0],c=r[i-1],l=[];if(i>s)return function(e,t,n,a){let s,r=0,i=n[0];for(a=Math.ceil(a),s=0;s<e.length;s++)s===i&&(t.push(e[s]),r++,i=n[r*a])}(t,l,r,i/s),l;const u=function(e,t,n){const a=function(e){const t=e.length;let n,a;if(t<2)return!1;for(a=e[0],n=1;n<t;++n)if(e[n]-e[n-1]!==a)return!1;return a}(e),s=t.length/n;if(!a)return Math.max(s,1);const r=function(e){const t=[],n=Math.sqrt(e);let a;for(a=1;a<n;a++)e%a===0&&(t.push(a),t.push(e/a));return n===(0|n)&&t.push(n),t.sort((e,t)=>e-t).pop(),t}(a);for(let i=0,o=r.length-1;i<o;i++){const e=r[i];if(e>s)return e}return Math.max(s,1)}(r,t,s);if(i>0){let e,n;const a=i>1?Math.round((c-o)/(i-1)):null;for(Ao(t,l,u,xa(a)?0:o-a,o),e=0,n=i-1;e<n;e++)Ao(t,l,u,r[e],r[e+1]);return Ao(t,l,u,c,xa(a)?t.length:c+a),l}return Ao(t,l,u),l}function Ao(e,t,n,a,s){const r=Ca(a,0),i=Math.min(Ca(s,e.length),e.length);let o,c,l,u=0;for(n=Math.ceil(n),s&&(o=s-a,n=o/Math.floor(o/n)),l=r;l<0;)u++,l=Math.round(r+u*n);for(c=Math.max(r,0);c<i;c++)c===l&&(t.push(e[c]),u++,l=Math.round(r+u*n))}On(Ro,"defaults",{}),On(Ro,"defaultRoutes",void 0);const Mo=(e,t,n)=>"top"===t||"left"===t?e[t]+n:e[t]-n,Po=(e,t)=>Math.min(t||e,e);function Do(e,t){const n=[],a=e.length/t,s=e.length;let r=0;for(;r<s;r+=a)n.push(e[Math.floor(r)]);return n}function Oo(e,t,n){const a=e.ticks.length,s=Math.min(t,a-1),r=e._startPixel,i=e._endPixel,o=1e-6;let c,l=e.getPixelForTick(s);if(!(n&&(c=1===a?Math.max(l-r,i-l):0===t?(e.getPixelForTick(1)-l)/2:(l-e.getPixelForTick(s-1))/2,l+=s<t?c:-c,l<r-o||l>i+o)))return l}function Fo(e){return e.drawTicks?e.tickLength:0}function Lo(e,t){if(!e.display)return 0;const n=hr(e.font,t),a=ur(e.padding);return(va(e.text)?e.text.length:1)*n.lineHeight+a.height}function zo(e,t,n){let a=xs(e);return(n&&"right"!==t||!n&&"right"===t)&&(a=(e=>"left"===e?"right":"right"===e?"left":e)(a)),a}class Bo extends Ro{constructor(e){super(),this.id=e.id,this.type=e.type,this.options=void 0,this.ctx=e.ctx,this.chart=e.chart,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.width=void 0,this.height=void 0,this._margins={left:0,right:0,top:0,bottom:0},this.maxWidth=void 0,this.maxHeight=void 0,this.paddingTop=void 0,this.paddingBottom=void 0,this.paddingLeft=void 0,this.paddingRight=void 0,this.axis=void 0,this.labelRotation=void 0,this.min=void 0,this.max=void 0,this._range=void 0,this.ticks=[],this._gridLineItems=null,this._labelItems=null,this._labelSizes=null,this._length=0,this._maxLength=0,this._longestTextCache={},this._startPixel=void 0,this._endPixel=void 0,this._reversePixels=!1,this._userMax=void 0,this._userMin=void 0,this._suggestedMax=void 0,this._suggestedMin=void 0,this._ticksLength=0,this._borderValue=0,this._cache={},this._dataLimitsCached=!1,this.$context=void 0}init(e){this.options=e.setContext(this.getContext()),this.axis=e.axis,this._userMin=this.parse(e.min),this._userMax=this.parse(e.max),this._suggestedMin=this.parse(e.suggestedMin),this._suggestedMax=this.parse(e.suggestedMax)}parse(e,t){return e}getUserBounds(){let{_userMin:e,_userMax:t,_suggestedMin:n,_suggestedMax:a}=this;return e=Sa(e,Number.POSITIVE_INFINITY),t=Sa(t,Number.NEGATIVE_INFINITY),n=Sa(n,Number.POSITIVE_INFINITY),a=Sa(a,Number.NEGATIVE_INFINITY),{min:Sa(e,n),max:Sa(t,a),minDefined:ka(e),maxDefined:ka(t)}}getMinMax(e){let t,{min:n,max:a,minDefined:s,maxDefined:r}=this.getUserBounds();if(s&&r)return{min:n,max:a};const i=this.getMatchingVisibleMetas();for(let o=0,c=i.length;o<c;++o)t=i[o].controller.getMinMax(this,e),s||(n=Math.min(n,t.min)),r||(a=Math.max(a,t.max));return n=r&&n>a?a:n,a=s&&n>a?n:a,{min:Sa(n,Sa(a,n)),max:Sa(a,Sa(n,a))}}getPadding(){return{left:this.paddingLeft||0,top:this.paddingTop||0,right:this.paddingRight||0,bottom:this.paddingBottom||0}}getTicks(){return this.ticks}getLabels(){const e=this.chart.data;return this.options.labels||(this.isHorizontal()?e.xLabels:e.yLabels)||e.labels||[]}getLabelItems(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.chart.chartArea;return this._labelItems||(this._labelItems=this._computeLabelItems(e))}beforeLayout(){this._cache={},this._dataLimitsCached=!1}beforeUpdate(){Na(this.options.beforeUpdate,[this])}update(e,t,n){const{beginAtZero:a,grace:s,ticks:r}=this.options,i=r.sampleSize;this.beforeUpdate(),this.maxWidth=e,this.maxHeight=t,this._margins=n=Object.assign({left:0,right:0,top:0,bottom:0},n),this.ticks=null,this._labelSizes=null,this._gridLineItems=null,this._labelItems=null,this.beforeSetDimensions(),this.setDimensions(),this.afterSetDimensions(),this._maxLength=this.isHorizontal()?this.width+n.left+n.right:this.height+n.top+n.bottom,this._dataLimitsCached||(this.beforeDataLimits(),this.determineDataLimits(),this.afterDataLimits(),this._range=function(e,t,n){const{min:a,max:s}=e,r=Ia(t,(s-a)/2),i=(e,t)=>n&&0===e?0:e+t;return{min:i(a,-Math.abs(r)),max:i(s,r)}}(this,s,a),this._dataLimitsCached=!0),this.beforeBuildTicks(),this.ticks=this.buildTicks()||[],this.afterBuildTicks();const o=i<this.ticks.length;this._convertTicksToLabels(o?Do(this.ticks,i):this.ticks),this.configure(),this.beforeCalculateLabelRotation(),this.calculateLabelRotation(),this.afterCalculateLabelRotation(),r.display&&(r.autoSkip||"auto"===r.source)&&(this.ticks=_o(this,this.ticks),this._labelSizes=null,this.afterAutoSkip()),o&&this._convertTicksToLabels(this.ticks),this.beforeFit(),this.fit(),this.afterFit(),this.afterUpdate()}configure(){let e,t,n=this.options.reverse;this.isHorizontal()?(e=this.left,t=this.right):(e=this.top,t=this.bottom,n=!n),this._startPixel=e,this._endPixel=t,this._reversePixels=n,this._length=t-e,this._alignToPixels=this.options.alignToPixels}afterUpdate(){Na(this.options.afterUpdate,[this])}beforeSetDimensions(){Na(this.options.beforeSetDimensions,[this])}setDimensions(){this.isHorizontal()?(this.width=this.maxWidth,this.left=0,this.right=this.width):(this.height=this.maxHeight,this.top=0,this.bottom=this.height),this.paddingLeft=0,this.paddingTop=0,this.paddingRight=0,this.paddingBottom=0}afterSetDimensions(){Na(this.options.afterSetDimensions,[this])}_callHooks(e){this.chart.notifyPlugins(e,this.getContext()),Na(this.options[e],[this])}beforeDataLimits(){this._callHooks("beforeDataLimits")}determineDataLimits(){}afterDataLimits(){this._callHooks("afterDataLimits")}beforeBuildTicks(){this._callHooks("beforeBuildTicks")}buildTicks(){return[]}afterBuildTicks(){this._callHooks("afterBuildTicks")}beforeTickToLabelConversion(){Na(this.options.beforeTickToLabelConversion,[this])}generateTickLabels(e){const t=this.options.ticks;let n,a,s;for(n=0,a=e.length;n<a;n++)s=e[n],s.label=Na(t.callback,[s.value,n,e],this)}afterTickToLabelConversion(){Na(this.options.afterTickToLabelConversion,[this])}beforeCalculateLabelRotation(){Na(this.options.beforeCalculateLabelRotation,[this])}calculateLabelRotation(){const e=this.options,t=e.ticks,n=Po(this.ticks.length,e.ticks.maxTicksLimit),a=t.minRotation||0,s=t.maxRotation;let r,i,o,c=a;if(!this._isVisible()||!t.display||a>=s||n<=1||!this.isHorizontal())return void(this.labelRotation=a);const l=this._getLabelSizes(),u=l.widest.width,h=l.highest.height,d=ls(this.chart.width-u,0,this.maxWidth);r=e.offset?this.maxWidth/n:d/(n-1),u+6>r&&(r=d/(n-(e.offset?.5:1)),i=this.maxHeight-Fo(e.grid)-t.padding-Lo(e.title,this.chart.options.font),o=Math.sqrt(u*u+h*h),c=ns(Math.min(Math.asin(ls((l.highest.height+6)/r,-1,1)),Math.asin(ls(i/o,-1,1))-Math.asin(ls(h/o,-1,1)))),c=Math.max(a,Math.min(s,c))),this.labelRotation=c}afterCalculateLabelRotation(){Na(this.options.afterCalculateLabelRotation,[this])}afterAutoSkip(){}beforeFit(){Na(this.options.beforeFit,[this])}fit(){const e={width:0,height:0},{chart:t,options:{ticks:n,title:a,grid:s}}=this,r=this._isVisible(),i=this.isHorizontal();if(r){const r=Lo(a,t.options.font);if(i?(e.width=this.maxWidth,e.height=Fo(s)+r):(e.height=this.maxHeight,e.width=Fo(s)+r),n.display&&this.ticks.length){const{first:t,last:a,widest:s,highest:r}=this._getLabelSizes(),o=2*n.padding,c=ts(this.labelRotation),l=Math.cos(c),u=Math.sin(c);if(i){const t=n.mirror?0:u*s.width+l*r.height;e.height=Math.min(this.maxHeight,e.height+t+o)}else{const t=n.mirror?0:l*s.width+u*r.height;e.width=Math.min(this.maxWidth,e.width+t+o)}this._calculatePadding(t,a,u,l)}}this._handleMargins(),i?(this.width=this._length=t.width-this._margins.left-this._margins.right,this.height=e.height):(this.width=e.width,this.height=this._length=t.height-this._margins.top-this._margins.bottom)}_calculatePadding(e,t,n,a){const{ticks:{align:s,padding:r},position:i}=this.options,o=0!==this.labelRotation,c="top"!==i&&"x"===this.axis;if(this.isHorizontal()){const i=this.getPixelForTick(0)-this.left,l=this.right-this.getPixelForTick(this.ticks.length-1);let u=0,h=0;o?c?(u=a*e.width,h=n*t.height):(u=n*e.height,h=a*t.width):"start"===s?h=t.width:"end"===s?u=e.width:"inner"!==s&&(u=e.width/2,h=t.width/2),this.paddingLeft=Math.max((u-i+r)*this.width/(this.width-i),0),this.paddingRight=Math.max((h-l+r)*this.width/(this.width-l),0)}else{let n=t.height/2,a=e.height/2;"start"===s?(n=0,a=e.height):"end"===s&&(n=t.height,a=0),this.paddingTop=n+r,this.paddingBottom=a+r}}_handleMargins(){this._margins&&(this._margins.left=Math.max(this.paddingLeft,this._margins.left),this._margins.top=Math.max(this.paddingTop,this._margins.top),this._margins.right=Math.max(this.paddingRight,this._margins.right),this._margins.bottom=Math.max(this.paddingBottom,this._margins.bottom))}afterFit(){Na(this.options.afterFit,[this])}isHorizontal(){const{axis:e,position:t}=this.options;return"top"===t||"bottom"===t||"x"===e}isFullSize(){return this.options.fullSize}_convertTicksToLabels(e){let t,n;for(this.beforeTickToLabelConversion(),this.generateTickLabels(e),t=0,n=e.length;t<n;t++)xa(e[t].label)&&(e.splice(t,1),n--,t--);this.afterTickToLabelConversion()}_getLabelSizes(){let e=this._labelSizes;if(!e){const t=this.options.ticks.sampleSize;let n=this.ticks;t<n.length&&(n=Do(n,t)),this._labelSizes=e=this._computeLabelSizes(n,n.length,this.options.ticks.maxTicksLimit)}return e}_computeLabelSizes(e,t,n){const{ctx:a,_longestTextCache:s}=this,r=[],i=[],o=Math.floor(t/Po(t,n));let c,l,u,h,d,p,f,m,g,y,b,x=0,v=0;for(c=0;c<t;c+=o){if(h=e[c].label,d=this._resolveTickFontOptions(c),a.font=p=d.string,f=s[p]=s[p]||{data:{},gc:[]},m=d.lineHeight,g=y=0,xa(h)||va(h)){if(va(h))for(l=0,u=h.length;l<u;++l)b=h[l],xa(b)||va(b)||(g=Vs(a,f.data,f.gc,g,b),y+=m)}else g=Vs(a,f.data,f.gc,g,h),y=m;r.push(g),i.push(y),x=Math.max(g,x),v=Math.max(y,v)}!function(e,t){Ta(e,e=>{const n=e.gc,a=n.length/2;let s;if(a>t){for(s=0;s<a;++s)delete e.data[n[s]];n.splice(0,a)}})}(s,t);const w=r.indexOf(x),k=i.indexOf(v),S=e=>({width:r[e]||0,height:i[e]||0});return{first:S(0),last:S(t-1),widest:S(w),highest:S(k),widths:r,heights:i}}getLabelForValue(e){return e}getPixelForValue(e,t){return NaN}getValueForPixel(e){}getPixelForTick(e){const t=this.ticks;return e<0||e>t.length-1?null:this.getPixelForValue(t[e].value)}getPixelForDecimal(e){this._reversePixels&&(e=1-e);const t=this._startPixel+e*this._length;return ls(this._alignToPixels?Hs(this.chart,t,0):t,-32768,32767)}getDecimalForPixel(e){const t=(e-this._startPixel)/this._length;return this._reversePixels?1-t:t}getBasePixel(){return this.getPixelForValue(this.getBaseValue())}getBaseValue(){const{min:e,max:t}=this;return e<0&&t<0?t:e>0&&t>0?e:0}getContext(e){const t=this.ticks||[];if(e>=0&&e<t.length){const n=t[e];return n.$context||(n.$context=function(e,t,n){return pr(e,{tick:n,index:t,type:"tick"})}(this.getContext(),e,n))}return this.$context||(this.$context=function(e,t){return pr(e,{scale:t,type:"scale"})}(this.chart.getContext(),this))}_tickSize(){const e=this.options.ticks,t=ts(this.labelRotation),n=Math.abs(Math.cos(t)),a=Math.abs(Math.sin(t)),s=this._getLabelSizes(),r=e.autoSkipPadding||0,i=s?s.widest.width+r:0,o=s?s.highest.height+r:0;return this.isHorizontal()?o*n>i*a?i/n:o/a:o*a<i*n?o/n:i/a}_isVisible(){const e=this.options.display;return"auto"!==e?!!e:this.getMatchingVisibleMetas().length>0}_computeGridLineItems(e){const t=this.axis,n=this.chart,a=this.options,{grid:s,position:r,border:i}=a,o=s.offset,c=this.isHorizontal(),l=this.ticks.length+(o?1:0),u=Fo(s),h=[],d=i.setContext(this.getContext()),p=d.display?d.width:0,f=p/2,m=function(e){return Hs(n,e,p)};let g,y,b,x,v,w,k,S,C,I,N,T;if("top"===r)g=m(this.bottom),w=this.bottom-u,S=g-f,I=m(e.top)+f,T=e.bottom;else if("bottom"===r)g=m(this.top),I=e.top,T=m(e.bottom)-f,w=g+f,S=this.top+u;else if("left"===r)g=m(this.right),v=this.right-u,k=g-f,C=m(e.left)+f,N=e.right;else if("right"===r)g=m(this.left),C=e.left,N=m(e.right)-f,v=g+f,k=this.left+u;else if("x"===t){if("center"===r)g=m((e.top+e.bottom)/2+.5);else if(wa(r)){const e=Object.keys(r)[0],t=r[e];g=m(this.chart.scales[e].getPixelForValue(t))}I=e.top,T=e.bottom,w=g+f,S=w+u}else if("y"===t){if("center"===r)g=m((e.left+e.right)/2);else if(wa(r)){const e=Object.keys(r)[0],t=r[e];g=m(this.chart.scales[e].getPixelForValue(t))}v=g-f,k=v-u,C=e.left,N=e.right}const E=Ca(a.ticks.maxTicksLimit,l),R=Math.max(1,Math.ceil(l/E));for(y=0;y<l;y+=R){const e=this.getContext(y),t=s.setContext(e),a=i.setContext(e),r=t.lineWidth,l=t.color,u=a.dash||[],d=a.dashOffset,p=t.tickWidth,f=t.tickColor,m=t.tickBorderDash||[],g=t.tickBorderDashOffset;b=Oo(this,y,o),void 0!==b&&(x=Hs(n,b,r),c?v=k=C=N=x:w=S=I=T=x,h.push({tx1:v,ty1:w,tx2:k,ty2:S,x1:C,y1:I,x2:N,y2:T,width:r,color:l,borderDash:u,borderDashOffset:d,tickWidth:p,tickColor:f,tickBorderDash:m,tickBorderDashOffset:g}))}return this._ticksLength=l,this._borderValue=g,h}_computeLabelItems(e){const t=this.axis,n=this.options,{position:a,ticks:s}=n,r=this.isHorizontal(),i=this.ticks,{align:o,crossAlign:c,padding:l,mirror:u}=s,h=Fo(n.grid),d=h+l,p=u?-l:d,f=-ts(this.labelRotation),m=[];let g,y,b,x,v,w,k,S,C,I,N,T,E="middle";if("top"===a)w=this.bottom-p,k=this._getXAxisLabelAlignment();else if("bottom"===a)w=this.top+p,k=this._getXAxisLabelAlignment();else if("left"===a){const e=this._getYAxisLabelAlignment(h);k=e.textAlign,v=e.x}else if("right"===a){const e=this._getYAxisLabelAlignment(h);k=e.textAlign,v=e.x}else if("x"===t){if("center"===a)w=(e.top+e.bottom)/2+d;else if(wa(a)){const e=Object.keys(a)[0],t=a[e];w=this.chart.scales[e].getPixelForValue(t)+d}k=this._getXAxisLabelAlignment()}else if("y"===t){if("center"===a)v=(e.left+e.right)/2-d;else if(wa(a)){const e=Object.keys(a)[0],t=a[e];v=this.chart.scales[e].getPixelForValue(t)}k=this._getYAxisLabelAlignment(h).textAlign}"y"===t&&("start"===o?E="top":"end"===o&&(E="bottom"));const R=this._getLabelSizes();for(g=0,y=i.length;g<y;++g){b=i[g],x=b.label;const e=s.setContext(this.getContext(g));S=this.getPixelForTick(g)+s.labelOffset,C=this._resolveTickFontOptions(g),I=C.lineHeight,N=va(x)?x.length:1;const t=N/2,n=e.color,o=e.textStrokeColor,l=e.textStrokeWidth;let h,d=k;if(r?(v=S,"inner"===k&&(d=g===y-1?this.options.reverse?"left":"right":0===g?this.options.reverse?"right":"left":"center"),T="top"===a?"near"===c||0!==f?-N*I+I/2:"center"===c?-R.highest.height/2-t*I+I:-R.highest.height+I/2:"near"===c||0!==f?I/2:"center"===c?R.highest.height/2-t*I:R.highest.height-N*I,u&&(T*=-1),0===f||e.showLabelBackdrop||(v+=I/2*Math.sin(f))):(w=S,T=(1-N)*I/2),e.showLabelBackdrop){const t=ur(e.backdropPadding),n=R.heights[g],a=R.widths[g];let s=T-t.top,r=0-t.left;switch(E){case"middle":s-=n/2;break;case"bottom":s-=n}switch(k){case"center":r-=a/2;break;case"right":r-=a;break;case"inner":g===y-1?r-=a:g>0&&(r-=a/2)}h={left:r,top:s,width:a+t.width,height:n+t.height,color:e.backdropColor}}m.push({label:x,font:C,textOffset:T,options:{rotation:f,color:n,strokeColor:o,strokeWidth:l,textAlign:d,textBaseline:E,translation:[v,w],backdrop:h}})}return m}_getXAxisLabelAlignment(){const{position:e,ticks:t}=this.options;if(-ts(this.labelRotation))return"top"===e?"left":"right";let n="center";return"start"===t.align?n="left":"end"===t.align?n="right":"inner"===t.align&&(n="inner"),n}_getYAxisLabelAlignment(e){const{position:t,ticks:{crossAlign:n,mirror:a,padding:s}}=this.options,r=e+s,i=this._getLabelSizes().widest.width;let o,c;return"left"===t?a?(c=this.right+s,"near"===n?o="left":"center"===n?(o="center",c+=i/2):(o="right",c+=i)):(c=this.right-r,"near"===n?o="right":"center"===n?(o="center",c-=i/2):(o="left",c=this.left)):"right"===t?a?(c=this.left+s,"near"===n?o="right":"center"===n?(o="center",c-=i/2):(o="left",c-=i)):(c=this.left+r,"near"===n?o="left":"center"===n?(o="center",c+=i/2):(o="right",c=this.right)):o="right",{textAlign:o,x:c}}_computeLabelArea(){if(this.options.ticks.mirror)return;const e=this.chart,t=this.options.position;return"left"===t||"right"===t?{top:0,left:this.left,bottom:e.height,right:this.right}:"top"===t||"bottom"===t?{top:this.top,left:0,bottom:this.bottom,right:e.width}:void 0}drawBackground(){const{ctx:e,options:{backgroundColor:t},left:n,top:a,width:s,height:r}=this;t&&(e.save(),e.fillStyle=t,e.fillRect(n,a,s,r),e.restore())}getLineWidthForValue(e){const t=this.options.grid;if(!this._isVisible()||!t.display)return 0;const n=this.ticks.findIndex(t=>t.value===e);if(n>=0){return t.setContext(this.getContext(n)).lineWidth}return 0}drawGrid(e){const t=this.options.grid,n=this.ctx,a=this._gridLineItems||(this._gridLineItems=this._computeGridLineItems(e));let s,r;const i=(e,t,a)=>{a.width&&a.color&&(n.save(),n.lineWidth=a.width,n.strokeStyle=a.color,n.setLineDash(a.borderDash||[]),n.lineDashOffset=a.borderDashOffset,n.beginPath(),n.moveTo(e.x,e.y),n.lineTo(t.x,t.y),n.stroke(),n.restore())};if(t.display)for(s=0,r=a.length;s<r;++s){const e=a[s];t.drawOnChartArea&&i({x:e.x1,y:e.y1},{x:e.x2,y:e.y2},e),t.drawTicks&&i({x:e.tx1,y:e.ty1},{x:e.tx2,y:e.ty2},{color:e.tickColor,width:e.tickWidth,borderDash:e.tickBorderDash,borderDashOffset:e.tickBorderDashOffset})}}drawBorder(){const{chart:e,ctx:t,options:{border:n,grid:a}}=this,s=n.setContext(this.getContext()),r=n.display?s.width:0;if(!r)return;const i=a.setContext(this.getContext(0)).lineWidth,o=this._borderValue;let c,l,u,h;this.isHorizontal()?(c=Hs(e,this.left,r)-r/2,l=Hs(e,this.right,i)+i/2,u=h=o):(u=Hs(e,this.top,r)-r/2,h=Hs(e,this.bottom,i)+i/2,c=l=o),t.save(),t.lineWidth=s.width,t.strokeStyle=s.color,t.beginPath(),t.moveTo(c,u),t.lineTo(l,h),t.stroke(),t.restore()}drawLabels(e){if(!this.options.ticks.display)return;const t=this.ctx,n=this._computeLabelArea();n&&Ys(t,n);const a=this.getLabelItems(e);for(const s of a){const e=s.options,n=s.font;tr(t,s.label,0,s.textOffset,n,e)}n&&Qs(t)}drawTitle(){const{ctx:e,options:{position:t,title:n,reverse:a}}=this;if(!n.display)return;const s=hr(n.font),r=ur(n.padding),i=n.align;let o=s.lineHeight/2;"bottom"===t||"center"===t||wa(t)?(o+=r.bottom,va(n.text)&&(o+=s.lineHeight*(n.text.length-1))):o+=r.top;const{titleX:c,titleY:l,maxWidth:u,rotation:h}=function(e,t,n,a){const{top:s,left:r,bottom:i,right:o,chart:c}=e,{chartArea:l,scales:u}=c;let h,d,p,f=0;const m=i-s,g=o-r;if(e.isHorizontal()){if(d=vs(a,r,o),wa(n)){const e=Object.keys(n)[0],a=n[e];p=u[e].getPixelForValue(a)+m-t}else p="center"===n?(l.bottom+l.top)/2+m-t:Mo(e,n,t);h=o-r}else{if(wa(n)){const e=Object.keys(n)[0],a=n[e];d=u[e].getPixelForValue(a)-g+t}else d="center"===n?(l.left+l.right)/2-g+t:Mo(e,n,t);p=vs(a,i,s),f="left"===n?-qa:qa}return{titleX:d,titleY:p,maxWidth:h,rotation:f}}(this,o,t,i);tr(e,n.text,0,0,s,{color:n.color,maxWidth:u,rotation:h,textAlign:zo(i,t,a),textBaseline:"middle",translation:[c,l]})}draw(e){this._isVisible()&&(this.drawBackground(),this.drawGrid(e),this.drawBorder(),this.drawTitle(),this.drawLabels(e))}_layers(){const e=this.options,t=e.ticks&&e.ticks.z||0,n=Ca(e.grid&&e.grid.z,-1),a=Ca(e.border&&e.border.z,0);return this._isVisible()&&this.draw===Bo.prototype.draw?[{z:n,draw:e=>{this.drawBackground(),this.drawGrid(e),this.drawTitle()}},{z:a,draw:()=>{this.drawBorder()}},{z:t,draw:e=>{this.drawLabels(e)}}]:[{z:t,draw:e=>{this.draw(e)}}]}getMatchingVisibleMetas(e){const t=this.chart.getSortedVisibleDatasetMetas(),n=this.axis+"AxisID",a=[];let s,r;for(s=0,r=t.length;s<r;++s){const r=t[s];r[n]!==this.id||e&&r.type!==e||a.push(r)}return a}_resolveTickFontOptions(e){return hr(this.options.ticks.setContext(this.getContext(e)).font)}_maxDigits(){const e=this._resolveTickFontOptions(0).lineHeight;return(this.isHorizontal()?this.width:this.height)/e}}class jo{constructor(e,t,n){this.type=e,this.scope=t,this.override=n,this.items=Object.create(null)}isForType(e){return Object.prototype.isPrototypeOf.call(this.type.prototype,e.prototype)}register(e){const t=Object.getPrototypeOf(e);let n;(function(e){return"id"in e&&"defaults"in e})(t)&&(n=this.register(t));const a=this.items,s=e.id,r=this.scope+"."+s;if(!s)throw new Error("class does not have id: "+e);return s in a||(a[s]=e,function(e,t,n){const a=Ma(Object.create(null),[n?Ws.get(n):{},Ws.get(t),e.defaults]);Ws.set(t,a),e.defaultRoutes&&function(e,t){Object.keys(t).forEach(n=>{const a=n.split("."),s=a.pop(),r=[e].concat(a).join("."),i=t[n].split("."),o=i.pop(),c=i.join(".");Ws.route(r,s,c,o)})}(t,e.defaultRoutes);e.descriptors&&Ws.describe(t,e.descriptors)}(e,r,n),this.override&&Ws.override(e.id,e.overrides)),r}get(e){return this.items[e]}unregister(e){const t=this.items,n=e.id,a=this.scope;n in t&&delete t[n],a&&n in Ws[a]&&(delete Ws[a][n],this.override&&delete Fs[n])}}class Wo{constructor(){this.controllers=new jo(Ii,"datasets",!0),this.elements=new jo(Ro,"elements"),this.plugins=new jo(Object,"plugins"),this.scales=new jo(Bo,"scales"),this._typedRegistries=[this.controllers,this.scales,this.elements]}add(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];this._each("register",t)}remove(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];this._each("unregister",t)}addControllers(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];this._each("register",t,this.controllers)}addElements(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];this._each("register",t,this.elements)}addPlugins(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];this._each("register",t,this.plugins)}addScales(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];this._each("register",t,this.scales)}getController(e){return this._get(e,this.controllers,"controller")}getElement(e){return this._get(e,this.elements,"element")}getPlugin(e){return this._get(e,this.plugins,"plugin")}getScale(e){return this._get(e,this.scales,"scale")}removeControllers(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];this._each("unregister",t,this.controllers)}removeElements(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];this._each("unregister",t,this.elements)}removePlugins(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];this._each("unregister",t,this.plugins)}removeScales(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];this._each("unregister",t,this.scales)}_each(e,t,n){[...t].forEach(t=>{const a=n||this._getRegistryForType(t);n||a.isForType(t)||a===this.plugins&&t.id?this._exec(e,a,t):Ta(t,t=>{const a=n||this._getRegistryForType(t);this._exec(e,a,t)})})}_exec(e,t,n){const a=La(e);Na(n["before"+a],[],n),t[e](n),Na(n["after"+a],[],n)}_getRegistryForType(e){for(let t=0;t<this._typedRegistries.length;t++){const n=this._typedRegistries[t];if(n.isForType(e))return n}return this.plugins}_get(e,t,n){const a=t.get(e);if(void 0===a)throw new Error('"'+e+'" is not a registered '+n+".");return a}}var Vo=new Wo;class Uo{constructor(){this._init=void 0}notify(e,t,n,a){if("beforeInit"===t&&(this._init=this._createDescriptors(e,!0),this._notify(this._init,e,"install")),void 0===this._init)return;const s=a?this._descriptors(e).filter(a):this._descriptors(e),r=this._notify(s,e,t,n);return"afterDestroy"===t&&(this._notify(s,e,"stop"),this._notify(this._init,e,"uninstall"),this._init=void 0),r}_notify(e,t,n,a){a=a||{};for(const s of e){const e=s.plugin;if(!1===Na(e[n],[t,a,s.options],e)&&a.cancelable)return!1}return!0}invalidate(){xa(this._cache)||(this._oldCache=this._cache,this._cache=void 0)}_descriptors(e){if(this._cache)return this._cache;const t=this._cache=this._createDescriptors(e);return this._notifyStateChanges(e),t}_createDescriptors(e,t){const n=e&&e.config,a=Ca(n.options&&n.options.plugins,{}),s=function(e){const t={},n=[],a=Object.keys(Vo.plugins.items);for(let r=0;r<a.length;r++)n.push(Vo.getPlugin(a[r]));const s=e.plugins||[];for(let r=0;r<s.length;r++){const e=s[r];-1===n.indexOf(e)&&(n.push(e),t[e.id]=!0)}return{plugins:n,localIds:t}}(n);return!1!==a||t?function(e,t,n,a){let{plugins:s,localIds:r}=t;const i=[],o=e.getContext();for(const c of s){const t=c.id,s=Ho(n[t],a);null!==s&&i.push({plugin:c,options:Go(e.config,{plugin:c,local:r[t]},s,o)})}return i}(e,s,a,t):[]}_notifyStateChanges(e){const t=this._oldCache||[],n=this._cache,a=(e,t)=>e.filter(e=>!t.some(t=>e.plugin.id===t.plugin.id));this._notify(a(t,n),e,"stop"),this._notify(a(n,t),e,"start")}}function Ho(e,t){return t||!1!==e?!0===e?{}:e:null}function Go(e,t,n,a){let{plugin:s,local:r}=t;const i=e.pluginScopeKeys(s),o=e.getOptionScopes(n,i);return r&&s.defaults&&o.push(s.defaults),e.createResolver(o,a,[""],{scriptable:!1,indexable:!1,allKeys:!0})}function qo(e,t){const n=Ws.datasets[e]||{};return((t.datasets||{})[e]||{}).indexAxis||t.indexAxis||n.indexAxis||"x"}function Ko(e){if("x"===e||"y"===e||"r"===e)return e}function Xo(e){return"top"===e||"bottom"===e?"x":"left"===e||"right"===e?"y":void 0}function Yo(e){if(Ko(e))return e;for(var t=arguments.length,n=new Array(t>1?t-1:0),a=1;a<t;a++)n[a-1]=arguments[a];for(const s of n){const t=s.axis||Xo(s.position)||e.length>1&&Ko(e[0].toLowerCase());if(t)return t}throw new Error("Cannot determine type of '".concat(e,"' axis. Please provide 'axis' or 'position' option."))}function Qo(e,t,n){if(n[t+"AxisID"]===e)return{axis:t}}function Zo(e,t){const n=Fs[e.type]||{scales:{}},a=t.scales||{},s=qo(e.type,t),r=Object.create(null);return Object.keys(a).forEach(t=>{const i=a[t];if(!wa(i))return console.error("Invalid scale configuration for scale: ".concat(t));if(i._proxy)return console.warn("Ignoring resolver passed as options for scale: ".concat(t));const o=Yo(t,i,function(e,t){if(t.data&&t.data.datasets){const n=t.data.datasets.filter(t=>t.xAxisID===e||t.yAxisID===e);if(n.length)return Qo(e,"x",n[0])||Qo(e,"y",n[0])}return{}}(t,e),Ws.scales[i.type]),c=function(e,t){return e===t?"_index_":"_value_"}(o,s),l=n.scales||{};r[t]=Pa(Object.create(null),[{axis:o},i,l[o],l[c]])}),e.data.datasets.forEach(n=>{const s=n.type||e.type,i=n.indexAxis||qo(s,t),o=(Fs[s]||{}).scales||{};Object.keys(o).forEach(e=>{const t=function(e,t){let n=e;return"_index_"===e?n=t:"_value_"===e&&(n="x"===t?"y":"x"),n}(e,i),s=n[t+"AxisID"]||t;r[s]=r[s]||Object.create(null),Pa(r[s],[{axis:t},a[s],o[e]])})}),Object.keys(r).forEach(e=>{const t=r[e];Pa(t,[Ws.scales[t.type],Ws.scale])}),r}function Jo(e){const t=e.options||(e.options={});t.plugins=Ca(t.plugins,{}),t.scales=Zo(e,t)}function $o(e){return(e=e||{}).datasets=e.datasets||[],e.labels=e.labels||[],e}const ec=new Map,tc=new Set;function nc(e,t){let n=ec.get(e);return n||(n=t(),ec.set(e,n),tc.add(n)),n}const ac=(e,t,n)=>{const a=Fa(t,n);void 0!==a&&e.add(a)};class sc{constructor(e){this._config=function(e){return(e=e||{}).data=$o(e.data),Jo(e),e}(e),this._scopeCache=new Map,this._resolverCache=new Map}get platform(){return this._config.platform}get type(){return this._config.type}set type(e){this._config.type=e}get data(){return this._config.data}set data(e){this._config.data=$o(e)}get options(){return this._config.options}set options(e){this._config.options=e}get plugins(){return this._config.plugins}update(){const e=this._config;this.clearCache(),Jo(e)}clearCache(){this._scopeCache.clear(),this._resolverCache.clear()}datasetScopeKeys(e){return nc(e,()=>[["datasets.".concat(e),""]])}datasetAnimationScopeKeys(e,t){return nc("".concat(e,".transition.").concat(t),()=>[["datasets.".concat(e,".transitions.").concat(t),"transitions.".concat(t)],["datasets.".concat(e),""]])}datasetElementScopeKeys(e,t){return nc("".concat(e,"-").concat(t),()=>[["datasets.".concat(e,".elements.").concat(t),"datasets.".concat(e),"elements.".concat(t),""]])}pluginScopeKeys(e){const t=e.id,n=this.type;return nc("".concat(n,"-plugin-").concat(t),()=>[["plugins.".concat(t),...e.additionalOptionScopes||[]]])}_cachedScopes(e,t){const n=this._scopeCache;let a=n.get(e);return a&&!t||(a=new Map,n.set(e,a)),a}getOptionScopes(e,t,n){const{options:a,type:s}=this,r=this._cachedScopes(e,n),i=r.get(t);if(i)return i;const o=new Set;t.forEach(t=>{e&&(o.add(e),t.forEach(t=>ac(o,e,t))),t.forEach(e=>ac(o,a,e)),t.forEach(e=>ac(o,Fs[s]||{},e)),t.forEach(e=>ac(o,Ws,e)),t.forEach(e=>ac(o,Ls,e))});const c=Array.from(o);return 0===c.length&&c.push(Object.create(null)),tc.has(t)&&r.set(t,c),c}chartOptionScopes(){const{options:e,type:t}=this;return[e,Fs[t]||{},Ws.datasets[t]||{},{type:t},Ws,Ls]}resolveNamedOptions(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[""];const s={$shared:!0},{resolver:r,subPrefixes:i}=rc(this._resolverCache,e,a);let o=r;if(function(e,t){const{isScriptable:n,isIndexable:a}=gr(e);for(const s of t){const t=n(s),r=a(s),i=(r||t)&&e[s];if(t&&(Ba(i)||ic(i))||r&&va(i))return!0}return!1}(r,t)){s.$shared=!1;o=mr(r,n=Ba(n)?n():n,this.createResolver(e,n,i))}for(const c of t)s[c]=o[c];return s}createResolver(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[""],a=arguments.length>3?arguments[3]:void 0;const{resolver:s}=rc(this._resolverCache,e,n);return wa(t)?mr(s,t,void 0,a):s}}function rc(e,t,n){let a=e.get(t);a||(a=new Map,e.set(t,a));const s=n.join();let r=a.get(s);if(!r){r={resolver:fr(t,n),subPrefixes:n.filter(e=>!e.toLowerCase().includes("hover"))},a.set(s,r)}return r}const ic=e=>wa(e)&&Object.getOwnPropertyNames(e).some(t=>Ba(e[t]));const oc=["top","bottom","left","right","chartArea"];function cc(e,t){return"top"===e||"bottom"===e||-1===oc.indexOf(e)&&"x"===t}function lc(e,t){return function(n,a){return n[e]===a[e]?n[t]-a[t]:n[e]-a[e]}}function uc(e){const t=e.chart,n=t.options.animation;t.notifyPlugins("afterRender"),Na(n&&n.onComplete,[e],t)}function hc(e){const t=e.chart,n=t.options.animation;Na(n&&n.onProgress,[e],t)}function dc(e){return Or()&&"string"===typeof e?e=document.getElementById(e):e&&e.length&&(e=e[0]),e&&e.canvas&&(e=e.canvas),e}const pc={},fc=e=>{const t=dc(e);return Object.values(pc).filter(e=>e.canvas===t).pop()};function mc(e,t,n){const a=Object.keys(e);for(const s of a){const a=+s;if(a>=t){const r=e[s];delete e[s],(n>0||a>t)&&(e[a+n]=r)}}}class gc{static register(){Vo.add(...arguments),yc()}static unregister(){Vo.remove(...arguments),yc()}constructor(e,t){const n=this.config=new sc(t),a=dc(e),s=fc(a);if(s)throw new Error("Canvas is already in use. Chart with ID '"+s.id+"' must be destroyed before the canvas with ID '"+s.canvas.id+"' can be reused.");const r=n.createResolver(n.chartOptionScopes(),this.getContext());this.platform=new(n.platform||function(e){return!Or()||"undefined"!==typeof OffscreenCanvas&&e instanceof OffscreenCanvas?po:Eo}(a)),this.platform.updateConfig(n);const i=this.platform.acquireContext(a,r.aspectRatio),o=i&&i.canvas,c=o&&o.height,l=o&&o.width;this.id=ba(),this.ctx=i,this.canvas=o,this.width=l,this.height=c,this._options=r,this._aspectRatio=this.aspectRatio,this._layers=[],this._metasets=[],this._stacks=void 0,this.boxes=[],this.currentDevicePixelRatio=void 0,this.chartArea=void 0,this._active=[],this._lastEvent=void 0,this._listeners={},this._responsiveListeners=void 0,this._sortedMetasets=[],this.scales={},this._plugins=new Uo,this.$proxies={},this._hiddenIndices={},this.attached=!1,this._animationsDisabled=void 0,this.$context=void 0,this._doResize=function(e,t){let n;return function(){for(var a=arguments.length,s=new Array(a),r=0;r<a;r++)s[r]=arguments[r];return t?(clearTimeout(n),n=setTimeout(e,t,s)):e.apply(this,s),t}}(e=>this.update(e),r.resizeDelay||0),this._dataChanges=[],pc[this.id]=this,i&&o?(li.listen(this,"complete",uc),li.listen(this,"progress",hc),this._initialize(),this.attached&&this.update()):console.error("Failed to create chart: can't acquire context from the given item")}get aspectRatio(){const{options:{aspectRatio:e,maintainAspectRatio:t},width:n,height:a,_aspectRatio:s}=this;return xa(e)?t&&s?s:a?n/a:null:e}get data(){return this.config.data}set data(e){this.config.data=e}get options(){return this._options}set options(e){this.config.options=e}get registry(){return Vo}_initialize(){return this.notifyPlugins("beforeInit"),this.options.responsive?this.resize():Hr(this,this.options.devicePixelRatio),this.bindEvents(),this.notifyPlugins("afterInit"),this}clear(){return Gs(this.canvas,this.ctx),this}stop(){return li.stop(this),this}resize(e,t){li.running(this)?this._resizeBeforeDraw={width:e,height:t}:this._resize(e,t)}_resize(e,t){const n=this.options,a=this.canvas,s=n.maintainAspectRatio&&this.aspectRatio,r=this.platform.getMaximumSize(a,e,t,s),i=n.devicePixelRatio||this.platform.getDevicePixelRatio(),o=this.width?"resize":"attach";this.width=r.width,this.height=r.height,this._aspectRatio=this.aspectRatio,Hr(this,i,!0)&&(this.notifyPlugins("resize",{size:r}),Na(n.onResize,[this,r],this),this.attached&&this._doResize(o)&&this.render())}ensureScalesHaveIDs(){Ta(this.options.scales||{},(e,t)=>{e.id=t})}buildOrUpdateScales(){const e=this.options,t=e.scales,n=this.scales,a=Object.keys(n).reduce((e,t)=>(e[t]=!1,e),{});let s=[];t&&(s=s.concat(Object.keys(t).map(e=>{const n=t[e],a=Yo(e,n),s="r"===a,r="x"===a;return{options:n,dposition:s?"chartArea":r?"bottom":"left",dtype:s?"radialLinear":r?"category":"linear"}}))),Ta(s,t=>{const s=t.options,r=s.id,i=Yo(r,s),o=Ca(s.type,t.dtype);void 0!==s.position&&cc(s.position,i)===cc(t.dposition)||(s.position=t.dposition),a[r]=!0;let c=null;if(r in n&&n[r].type===o)c=n[r];else{c=new(Vo.getScale(o))({id:r,type:o,ctx:this.ctx,chart:this}),n[c.id]=c}c.init(s,e)}),Ta(a,(e,t)=>{e||delete n[t]}),Ta(n,e=>{uo.configure(this,e,e.options),uo.addBox(this,e)})}_updateMetasets(){const e=this._metasets,t=this.data.datasets.length,n=e.length;if(e.sort((e,t)=>e.index-t.index),n>t){for(let e=t;e<n;++e)this._destroyDatasetMeta(e);e.splice(t,n-t)}this._sortedMetasets=e.slice(0).sort(lc("order","index"))}_removeUnreferencedMetasets(){const{_metasets:e,data:{datasets:t}}=this;e.length>t.length&&delete this._stacks,e.forEach((e,n)=>{0===t.filter(t=>t===e._dataset).length&&this._destroyDatasetMeta(n)})}buildOrUpdateControllers(){const e=[],t=this.data.datasets;let n,a;for(this._removeUnreferencedMetasets(),n=0,a=t.length;n<a;n++){const a=t[n];let s=this.getDatasetMeta(n);const r=a.type||this.config.type;if(s.type&&s.type!==r&&(this._destroyDatasetMeta(n),s=this.getDatasetMeta(n)),s.type=r,s.indexAxis=a.indexAxis||qo(r,this.options),s.order=a.order||0,s.index=n,s.label=""+a.label,s.visible=this.isDatasetVisible(n),s.controller)s.controller.updateIndex(n),s.controller.linkScales();else{const t=Vo.getController(r),{datasetElementType:a,dataElementType:i}=Ws.datasets[r];Object.assign(t,{dataElementType:Vo.getElement(i),datasetElementType:a&&Vo.getElement(a)}),s.controller=new t(this,n),e.push(s.controller)}}return this._updateMetasets(),e}_resetElements(){Ta(this.data.datasets,(e,t)=>{this.getDatasetMeta(t).controller.reset()},this)}reset(){this._resetElements(),this.notifyPlugins("reset")}update(e){const t=this.config;t.update();const n=this._options=t.createResolver(t.chartOptionScopes(),this.getContext()),a=this._animationsDisabled=!n.animation;if(this._updateScales(),this._checkEventBindings(),this._updateHiddenIndices(),this._plugins.invalidate(),!1===this.notifyPlugins("beforeUpdate",{mode:e,cancelable:!0}))return;const s=this.buildOrUpdateControllers();this.notifyPlugins("beforeElementsUpdate");let r=0;for(let c=0,l=this.data.datasets.length;c<l;c++){const{controller:e}=this.getDatasetMeta(c),t=!a&&-1===s.indexOf(e);e.buildOrUpdateElements(t),r=Math.max(+e.getMaxOverflow(),r)}r=this._minPadding=n.layout.autoPadding?r:0,this._updateLayout(r),a||Ta(s,e=>{e.reset()}),this._updateDatasets(e),this.notifyPlugins("afterUpdate",{mode:e}),this._layers.sort(lc("z","_idx"));const{_active:i,_lastEvent:o}=this;o?this._eventHandler(o,!0):i.length&&this._updateHoverStyles(i,i,!0),this.render()}_updateScales(){Ta(this.scales,e=>{uo.removeBox(this,e)}),this.ensureScalesHaveIDs(),this.buildOrUpdateScales()}_checkEventBindings(){const e=this.options,t=new Set(Object.keys(this._listeners)),n=new Set(e.events);ja(t,n)&&!!this._responsiveListeners===e.responsive||(this.unbindEvents(),this.bindEvents())}_updateHiddenIndices(){const{_hiddenIndices:e}=this,t=this._getUniformDataChanges()||[];for(const{method:n,start:a,count:s}of t){mc(e,a,"_removeElements"===n?-s:s)}}_getUniformDataChanges(){const e=this._dataChanges;if(!e||!e.length)return;this._dataChanges=[];const t=this.data.datasets.length,n=t=>new Set(e.filter(e=>e[0]===t).map((e,t)=>t+","+e.splice(1).join(","))),a=n(0);for(let s=1;s<t;s++)if(!ja(a,n(s)))return;return Array.from(a).map(e=>e.split(",")).map(e=>({method:e[1],start:+e[2],count:+e[3]}))}_updateLayout(e){if(!1===this.notifyPlugins("beforeLayout",{cancelable:!0}))return;uo.update(this,this.width,this.height,e);const t=this.chartArea,n=t.width<=0||t.height<=0;this._layers=[],Ta(this.boxes,e=>{n&&"chartArea"===e.position||(e.configure&&e.configure(),this._layers.push(...e._layers()))},this),this._layers.forEach((e,t)=>{e._idx=t}),this.notifyPlugins("afterLayout")}_updateDatasets(e){if(!1!==this.notifyPlugins("beforeDatasetsUpdate",{mode:e,cancelable:!0})){for(let e=0,t=this.data.datasets.length;e<t;++e)this.getDatasetMeta(e).controller.configure();for(let t=0,n=this.data.datasets.length;t<n;++t)this._updateDataset(t,Ba(e)?e({datasetIndex:t}):e);this.notifyPlugins("afterDatasetsUpdate",{mode:e})}}_updateDataset(e,t){const n=this.getDatasetMeta(e),a={meta:n,index:e,mode:t,cancelable:!0};!1!==this.notifyPlugins("beforeDatasetUpdate",a)&&(n.controller._update(t),a.cancelable=!1,this.notifyPlugins("afterDatasetUpdate",a))}render(){!1!==this.notifyPlugins("beforeRender",{cancelable:!0})&&(li.has(this)?this.attached&&!li.running(this)&&li.start(this):(this.draw(),uc({chart:this})))}draw(){let e;if(this._resizeBeforeDraw){const{width:e,height:t}=this._resizeBeforeDraw;this._resizeBeforeDraw=null,this._resize(e,t)}if(this.clear(),this.width<=0||this.height<=0)return;if(!1===this.notifyPlugins("beforeDraw",{cancelable:!0}))return;const t=this._layers;for(e=0;e<t.length&&t[e].z<=0;++e)t[e].draw(this.chartArea);for(this._drawDatasets();e<t.length;++e)t[e].draw(this.chartArea);this.notifyPlugins("afterDraw")}_getSortedDatasetMetas(e){const t=this._sortedMetasets,n=[];let a,s;for(a=0,s=t.length;a<s;++a){const s=t[a];e&&!s.visible||n.push(s)}return n}getSortedVisibleDatasetMetas(){return this._getSortedDatasetMetas(!0)}_drawDatasets(){if(!1===this.notifyPlugins("beforeDatasetsDraw",{cancelable:!0}))return;const e=this.getSortedVisibleDatasetMetas();for(let t=e.length-1;t>=0;--t)this._drawDataset(e[t]);this.notifyPlugins("afterDatasetsDraw")}_drawDataset(e){const t=this.ctx,n={meta:e,index:e.index,cancelable:!0},a=oi(this,e);!1!==this.notifyPlugins("beforeDatasetDraw",n)&&(a&&Ys(t,a),e.controller.draw(),a&&Qs(t),n.cancelable=!1,this.notifyPlugins("afterDatasetDraw",n))}isPointInArea(e){return Xs(e,this.chartArea,this._minPadding)}getElementsAtEventForMode(e,t,n,a){const s=Zi.modes[t];return"function"===typeof s?s(this,e,n,a):[]}getDatasetMeta(e){const t=this.data.datasets[e],n=this._metasets;let a=n.filter(e=>e&&e._dataset===t).pop();return a||(a={type:null,data:[],dataset:null,controller:null,hidden:null,xAxisID:null,yAxisID:null,order:t&&t.order||0,index:e,_dataset:t,_parsed:[],_sorted:!1},n.push(a)),a}getContext(){return this.$context||(this.$context=pr(null,{chart:this,type:"chart"}))}getVisibleDatasetCount(){return this.getSortedVisibleDatasetMetas().length}isDatasetVisible(e){const t=this.data.datasets[e];if(!t)return!1;const n=this.getDatasetMeta(e);return"boolean"===typeof n.hidden?!n.hidden:!t.hidden}setDatasetVisibility(e,t){this.getDatasetMeta(e).hidden=!t}toggleDataVisibility(e){this._hiddenIndices[e]=!this._hiddenIndices[e]}getDataVisibility(e){return!this._hiddenIndices[e]}_updateVisibility(e,t,n){const a=n?"show":"hide",s=this.getDatasetMeta(e),r=s.controller._resolveAnimations(void 0,a);za(t)?(s.data[t].hidden=!n,this.update()):(this.setDatasetVisibility(e,n),r.update(s,{visible:n}),this.update(t=>t.datasetIndex===e?a:void 0))}hide(e,t){this._updateVisibility(e,t,!1)}show(e,t){this._updateVisibility(e,t,!0)}_destroyDatasetMeta(e){const t=this._metasets[e];t&&t.controller&&t.controller._destroy(),delete this._metasets[e]}_stop(){let e,t;for(this.stop(),li.remove(this),e=0,t=this.data.datasets.length;e<t;++e)this._destroyDatasetMeta(e)}destroy(){this.notifyPlugins("beforeDestroy");const{canvas:e,ctx:t}=this;this._stop(),this.config.clearCache(),e&&(this.unbindEvents(),Gs(e,t),this.platform.releaseContext(t),this.canvas=null,this.ctx=null),delete pc[this.id],this.notifyPlugins("afterDestroy")}toBase64Image(){return this.canvas.toDataURL(...arguments)}bindEvents(){this.bindUserEvents(),this.options.responsive?this.bindResponsiveEvents():this.attached=!0}bindUserEvents(){const e=this._listeners,t=this.platform,n=(n,a)=>{t.addEventListener(this,n,a),e[n]=a},a=(e,t,n)=>{e.offsetX=t,e.offsetY=n,this._eventHandler(e)};Ta(this.options.events,e=>n(e,a))}bindResponsiveEvents(){this._responsiveListeners||(this._responsiveListeners={});const e=this._responsiveListeners,t=this.platform,n=(n,a)=>{t.addEventListener(this,n,a),e[n]=a},a=(n,a)=>{e[n]&&(t.removeEventListener(this,n,a),delete e[n])},s=(e,t)=>{this.canvas&&this.resize(e,t)};let r;const i=()=>{a("attach",i),this.attached=!0,this.resize(),n("resize",s),n("detach",r)};r=()=>{this.attached=!1,a("resize",s),this._stop(),this._resize(0,0),n("attach",i)},t.isAttached(this.canvas)?i():r()}unbindEvents(){Ta(this._listeners,(e,t)=>{this.platform.removeEventListener(this,t,e)}),this._listeners={},Ta(this._responsiveListeners,(e,t)=>{this.platform.removeEventListener(this,t,e)}),this._responsiveListeners=void 0}updateHoverStyle(e,t,n){const a=n?"set":"remove";let s,r,i,o;for("dataset"===t&&(s=this.getDatasetMeta(e[0].datasetIndex),s.controller["_"+a+"DatasetHoverStyle"]()),i=0,o=e.length;i<o;++i){r=e[i];const t=r&&this.getDatasetMeta(r.datasetIndex).controller;t&&t[a+"HoverStyle"](r.element,r.datasetIndex,r.index)}}getActiveElements(){return this._active||[]}setActiveElements(e){const t=this._active||[],n=e.map(e=>{let{datasetIndex:t,index:n}=e;const a=this.getDatasetMeta(t);if(!a)throw new Error("No dataset found at index "+t);return{datasetIndex:t,element:a.data[n],index:n}});!Ea(n,t)&&(this._active=n,this._lastEvent=null,this._updateHoverStyles(n,t))}notifyPlugins(e,t,n){return this._plugins.notify(this,e,t,n)}isPluginEnabled(e){return 1===this._plugins._cache.filter(t=>t.plugin.id===e).length}_updateHoverStyles(e,t,n){const a=this.options.hover,s=(e,t)=>e.filter(e=>!t.some(t=>e.datasetIndex===t.datasetIndex&&e.index===t.index)),r=s(t,e),i=n?e:s(e,t);r.length&&this.updateHoverStyle(r,a.mode,!1),i.length&&a.mode&&this.updateHoverStyle(i,a.mode,!0)}_eventHandler(e,t){const n={event:e,replay:t,cancelable:!0,inChartArea:this.isPointInArea(e)},a=t=>(t.options.events||this.options.events).includes(e.native.type);if(!1===this.notifyPlugins("beforeEvent",n,a))return;const s=this._handleEvent(e,t,n.inChartArea);return n.cancelable=!1,this.notifyPlugins("afterEvent",n,a),(s||n.changed)&&this.render(),this}_handleEvent(e,t,n){const{_active:a=[],options:s}=this,r=t,i=this._getActiveElements(e,a,n,r),o=function(e){return"mouseup"===e.type||"click"===e.type||"contextmenu"===e.type}(e),c=function(e,t,n,a){return n&&"mouseout"!==e.type?a?t:e:null}(e,this._lastEvent,n,o);n&&(this._lastEvent=null,Na(s.onHover,[e,i,this],this),o&&Na(s.onClick,[e,i,this],this));const l=!Ea(i,a);return(l||t)&&(this._active=i,this._updateHoverStyles(i,a,t)),this._lastEvent=c,l}_getActiveElements(e,t,n,a){if("mouseout"===e.type)return[];if(!n)return t;const s=this.options.hover;return this.getElementsAtEventForMode(e,s.mode,s,a)}}function yc(){return Ta(gc.instances,e=>e._plugins.invalidate())}function bc(e,t,n,a){const s=or(e.options.borderRadius,["outerStart","outerEnd","innerStart","innerEnd"]);const r=(n-t)/2,i=Math.min(r,a*t/2),o=e=>{const t=(n-Math.min(r,e))*a/2;return ls(e,0,Math.min(r,t))};return{outerStart:o(s.outerStart),outerEnd:o(s.outerEnd),innerStart:ls(s.innerStart,0,i),innerEnd:ls(s.innerEnd,0,i)}}function xc(e,t,n,a){return{x:n+e*Math.cos(t),y:a+e*Math.sin(t)}}function vc(e,t,n,a,s,r){const{x:i,y:o,startAngle:c,pixelMargin:l,innerRadius:u}=t,h=Math.max(t.outerRadius+a+n-l,0),d=u>0?u+a+n+l:0;let p=0;const f=s-c;if(a){const e=((u>0?u-a:0)+(h>0?h-a:0))/2;p=(f-(0!==e?f*e/(e+a):f))/2}const m=(f-Math.max(.001,f*h-n/Wa)/h)/2,g=c+m+p,y=s-m-p,{outerStart:b,outerEnd:x,innerStart:v,innerEnd:w}=bc(t,d,h,y-g),k=h-b,S=h-x,C=g+b/k,I=y-x/S,N=d+v,T=d+w,E=g+v/N,R=y-w/T;if(e.beginPath(),r){const t=(C+I)/2;if(e.arc(i,o,h,C,t),e.arc(i,o,h,t,I),x>0){const t=xc(S,I,i,o);e.arc(t.x,t.y,x,I,y+qa)}const n=xc(T,y,i,o);if(e.lineTo(n.x,n.y),w>0){const t=xc(T,R,i,o);e.arc(t.x,t.y,w,y+qa,R+Math.PI)}const a=(y-w/d+(g+v/d))/2;if(e.arc(i,o,d,y-w/d,a,!0),e.arc(i,o,d,a,g+v/d,!0),v>0){const t=xc(N,E,i,o);e.arc(t.x,t.y,v,E+Math.PI,g-qa)}const s=xc(k,g,i,o);if(e.lineTo(s.x,s.y),b>0){const t=xc(k,C,i,o);e.arc(t.x,t.y,b,g-qa,C)}}else{e.moveTo(i,o);const t=Math.cos(C)*h+i,n=Math.sin(C)*h+o;e.lineTo(t,n);const a=Math.cos(I)*h+i,s=Math.sin(I)*h+o;e.lineTo(a,s)}e.closePath()}function wc(e,t,n,a,s){const{fullCircles:r,startAngle:i,circumference:o,options:c}=t,{borderWidth:l,borderJoinStyle:u,borderDash:h,borderDashOffset:d,borderRadius:p}=c,f="inner"===c.borderAlign;if(!l)return;e.setLineDash(h||[]),e.lineDashOffset=d,f?(e.lineWidth=2*l,e.lineJoin=u||"round"):(e.lineWidth=l,e.lineJoin=u||"bevel");let m=t.endAngle;if(r){vc(e,t,n,a,m,s);for(let t=0;t<r;++t)e.stroke();isNaN(o)||(m=i+(o%Va||Va))}f&&function(e,t,n){const{startAngle:a,pixelMargin:s,x:r,y:i,outerRadius:o,innerRadius:c}=t;let l=s/o;e.beginPath(),e.arc(r,i,o,a-l,n+l),c>s?(l=s/c,e.arc(r,i,c,n+l,a-l,!0)):e.arc(r,i,s,n+qa,a-qa),e.closePath(),e.clip()}(e,t,m),c.selfJoin&&m-i>=Wa&&0===p&&"miter"!==u&&function(e,t,n){const{startAngle:a,x:s,y:r,outerRadius:i,innerRadius:o,options:c}=t,{borderWidth:l,borderJoinStyle:u}=c,h=Math.min(l/i,os(a-n));if(e.beginPath(),e.arc(s,r,i-l/2,a+h/2,n-h/2),o>0){const t=Math.min(l/o,os(a-n));e.arc(s,r,o+l/2,n-t/2,a+t/2,!0)}else{const t=Math.min(l/2,i*os(a-n));if("round"===u)e.arc(s,r,t,n-Wa/2,a+Wa/2,!0);else if("bevel"===u){const i=2*t*t,o=-i*Math.cos(n+Wa/2)+s,c=-i*Math.sin(n+Wa/2)+r,l=i*Math.cos(a+Wa/2)+s,u=i*Math.sin(a+Wa/2)+r;e.lineTo(o,c),e.lineTo(l,u)}}e.closePath(),e.moveTo(0,0),e.rect(0,0,e.canvas.width,e.canvas.height),e.clip("evenodd")}(e,t,m),r||(vc(e,t,n,a,m,s),e.stroke())}On(gc,"defaults",Ws),On(gc,"instances",pc),On(gc,"overrides",Fs),On(gc,"registry",Vo),On(gc,"version","4.5.1"),On(gc,"getChart",fc);class kc extends Ro{constructor(e){super(),On(this,"circumference",void 0),On(this,"endAngle",void 0),On(this,"fullCircles",void 0),On(this,"innerRadius",void 0),On(this,"outerRadius",void 0),On(this,"pixelMargin",void 0),On(this,"startAngle",void 0),this.options=void 0,this.circumference=void 0,this.startAngle=void 0,this.endAngle=void 0,this.innerRadius=void 0,this.outerRadius=void 0,this.pixelMargin=0,this.fullCircles=0,e&&Object.assign(this,e)}inRange(e,t,n){const a=this.getProps(["x","y"],n),{angle:s,distance:r}=ss(a,{x:e,y:t}),{startAngle:i,endAngle:o,innerRadius:c,outerRadius:l,circumference:u}=this.getProps(["startAngle","endAngle","innerRadius","outerRadius","circumference"],n),h=(this.options.spacing+this.options.borderWidth)/2,d=Ca(u,o-i),p=cs(s,i,o)&&i!==o,f=d>=Va||p,m=us(r,c+h,l+h);return f&&m}getCenterPoint(e){const{x:t,y:n,startAngle:a,endAngle:s,innerRadius:r,outerRadius:i}=this.getProps(["x","y","startAngle","endAngle","innerRadius","outerRadius"],e),{offset:o,spacing:c}=this.options,l=(a+s)/2,u=(r+i+c+o)/2;return{x:t+Math.cos(l)*u,y:n+Math.sin(l)*u}}tooltipPosition(e){return this.getCenterPoint(e)}draw(e){const{options:t,circumference:n}=this,a=(t.offset||0)/4,s=(t.spacing||0)/2,r=t.circular;if(this.pixelMargin="inner"===t.borderAlign?.33:0,this.fullCircles=n>Va?Math.floor(n/Va):0,0===n||this.innerRadius<0||this.outerRadius<0)return;e.save();const i=(this.startAngle+this.endAngle)/2;e.translate(Math.cos(i)*a,Math.sin(i)*a);const o=a*(1-Math.sin(Math.min(Wa,n||0)));e.fillStyle=t.backgroundColor,e.strokeStyle=t.borderColor,function(e,t,n,a,s){const{fullCircles:r,startAngle:i,circumference:o}=t;let c=t.endAngle;if(r){vc(e,t,n,a,c,s);for(let t=0;t<r;++t)e.fill();isNaN(o)||(c=i+(o%Va||Va))}vc(e,t,n,a,c,s),e.fill()}(e,this,o,s,r),wc(e,this,o,s,r),e.restore()}}function Sc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:t;e.lineCap=Ca(n.borderCapStyle,t.borderCapStyle),e.setLineDash(Ca(n.borderDash,t.borderDash)),e.lineDashOffset=Ca(n.borderDashOffset,t.borderDashOffset),e.lineJoin=Ca(n.borderJoinStyle,t.borderJoinStyle),e.lineWidth=Ca(n.borderWidth,t.borderWidth),e.strokeStyle=Ca(n.borderColor,t.borderColor)}function Cc(e,t,n){e.lineTo(n.x,n.y)}function Ic(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const a=e.length,{start:s=0,end:r=a-1}=n,{start:i,end:o}=t,c=Math.max(s,i),l=Math.min(r,o),u=s<i&&r<i||s>o&&r>o;return{count:a,start:c,loop:t.loop,ilen:l<c&&!u?a+l-c:l-c}}function Nc(e,t,n,a){const{points:s,options:r}=t,{count:i,start:o,loop:c,ilen:l}=Ic(s,n,a),u=function(e){return e.stepped?Zs:e.tension||"monotone"===e.cubicInterpolationMode?Js:Cc}(r);let h,d,p,{move:f=!0,reverse:m}=a||{};for(h=0;h<=l;++h)d=s[(o+(m?l-h:h))%i],d.skip||(f?(e.moveTo(d.x,d.y),f=!1):u(e,p,d,m,r.stepped),p=d);return c&&(d=s[(o+(m?l:0))%i],u(e,p,d,m,r.stepped)),!!c}function Tc(e,t,n,a){const s=t.points,{count:r,start:i,ilen:o}=Ic(s,n,a),{move:c=!0,reverse:l}=a||{};let u,h,d,p,f,m,g=0,y=0;const b=e=>(i+(l?o-e:e))%r,x=()=>{p!==f&&(e.lineTo(g,f),e.lineTo(g,p),e.lineTo(g,m))};for(c&&(h=s[b(0)],e.moveTo(h.x,h.y)),u=0;u<=o;++u){if(h=s[b(u)],h.skip)continue;const t=h.x,n=h.y,a=0|t;a===d?(n<p?p=n:n>f&&(f=n),g=(y*g+t)/++y):(x(),e.lineTo(t,n),d=a,y=0,p=f=n),m=n}x()}function Ec(e){const t=e.options,n=t.borderDash&&t.borderDash.length;return!e._decimated&&!e._loop&&!t.tension&&"monotone"!==t.cubicInterpolationMode&&!t.stepped&&!n?Tc:Nc}On(kc,"id","arc"),On(kc,"defaults",{borderAlign:"center",borderColor:"#fff",borderDash:[],borderDashOffset:0,borderJoinStyle:void 0,borderRadius:0,borderWidth:2,offset:0,spacing:0,angle:void 0,circular:!0,selfJoin:!1}),On(kc,"defaultRoutes",{backgroundColor:"backgroundColor"}),On(kc,"descriptors",{_scriptable:!0,_indexable:e=>"borderDash"!==e});const Rc="function"===typeof Path2D;function _c(e,t,n,a){Rc&&!t.options.segment?function(e,t,n,a){let s=t._path;s||(s=t._path=new Path2D,t.path(s,n,a)&&s.closePath()),Sc(e,t.options),e.stroke(s)}(e,t,n,a):function(e,t,n,a){const{segments:s,options:r}=t,i=Ec(t);for(const o of s)Sc(e,r,o.style),e.beginPath(),i(e,t,o,{start:n,end:n+a-1})&&e.closePath(),e.stroke()}(e,t,n,a)}class Ac extends Ro{constructor(e){super(),this.animated=!0,this.options=void 0,this._chart=void 0,this._loop=void 0,this._fullLoop=void 0,this._path=void 0,this._points=void 0,this._segments=void 0,this._decimated=!1,this._pointsUpdated=!1,this._datasetIndex=void 0,e&&Object.assign(this,e)}updateControlPoints(e,t){const n=this.options;if((n.tension||"monotone"===n.cubicInterpolationMode)&&!n.stepped&&!this._pointsUpdated){const a=n.spanGaps?this._loop:this._fullLoop;Dr(this._points,n,e,a,t),this._pointsUpdated=!0}}set points(e){this._points=e,delete this._segments,delete this._path,this._pointsUpdated=!1}get points(){return this._points}get segments(){return this._segments||(this._segments=function(e,t){const n=e.points,a=e.options.spanGaps,s=n.length;if(!s)return[];const r=!!e._loop,{start:i,end:o}=function(e,t,n,a){let s=0,r=t-1;if(n&&!a)for(;s<t&&!e[s].skip;)s++;for(;s<t&&e[s].skip;)s++;for(s%=t,n&&(r+=s);r>s&&e[r%t].skip;)r--;return r%=t,{start:s,end:r}}(n,s,r,a);return ai(e,!0===a?[{start:i,end:o,loop:r}]:function(e,t,n,a){const s=e.length,r=[];let i,o=t,c=e[t];for(i=t+1;i<=n;++i){const n=e[i%s];n.skip||n.stop?c.skip||(a=!1,r.push({start:t%s,end:(i-1)%s,loop:a}),t=o=n.stop?i:null):(o=i,c.skip&&(t=i)),c=n}return null!==o&&r.push({start:t%s,end:o%s,loop:a}),r}(n,i,o<i?o+s:o,!!e._fullLoop&&0===i&&o===s-1),n,t)}(this,this.options.segment))}first(){const e=this.segments,t=this.points;return e.length&&t[e[0].start]}last(){const e=this.segments,t=this.points,n=e.length;return n&&t[e[n-1].end]}interpolate(e,t){const n=this.options,a=e[t],s=this.points,r=ni(this,{property:t,start:a,end:a});if(!r.length)return;const i=[],o=function(e){return e.stepped?Xr:e.tension||"monotone"===e.cubicInterpolationMode?Yr:Kr}(n);let c,l;for(c=0,l=r.length;c<l;++c){const{start:l,end:u}=r[c],h=s[l],d=s[u];if(h===d){i.push(h);continue}const p=o(h,d,Math.abs((a-h[t])/(d[t]-h[t])),n.stepped);p[t]=e[t],i.push(p)}return 1===i.length?i[0]:i}pathSegment(e,t,n){return Ec(this)(e,this,t,n)}path(e,t,n){const a=this.segments,s=Ec(this);let r=this._loop;t=t||0,n=n||this.points.length-t;for(const i of a)r&=s(e,this,i,{start:t,end:t+n-1});return!!r}draw(e,t,n,a){const s=this.options||{};(this.points||[]).length&&s.borderWidth&&(e.save(),_c(e,this,n,a),e.restore()),this.animated&&(this._pointsUpdated=!1,this._path=void 0)}}function Mc(e,t,n,a){const s=e.options,{[n]:r}=e.getProps([n],a);return Math.abs(t-r)<s.radius+s.hitRadius}On(Ac,"id","line"),On(Ac,"defaults",{borderCapStyle:"butt",borderDash:[],borderDashOffset:0,borderJoinStyle:"miter",borderWidth:3,capBezierPoints:!0,cubicInterpolationMode:"default",fill:!1,spanGaps:!1,stepped:!1,tension:0}),On(Ac,"defaultRoutes",{backgroundColor:"backgroundColor",borderColor:"borderColor"}),On(Ac,"descriptors",{_scriptable:!0,_indexable:e=>"borderDash"!==e&&"fill"!==e});class Pc extends Ro{constructor(e){super(),On(this,"parsed",void 0),On(this,"skip",void 0),On(this,"stop",void 0),this.options=void 0,this.parsed=void 0,this.skip=void 0,this.stop=void 0,e&&Object.assign(this,e)}inRange(e,t,n){const a=this.options,{x:s,y:r}=this.getProps(["x","y"],n);return Math.pow(e-s,2)+Math.pow(t-r,2)<Math.pow(a.hitRadius+a.radius,2)}inXRange(e,t){return Mc(this,e,"x",t)}inYRange(e,t){return Mc(this,e,"y",t)}getCenterPoint(e){const{x:t,y:n}=this.getProps(["x","y"],e);return{x:t,y:n}}size(e){let t=(e=e||this.options||{}).radius||0;t=Math.max(t,t&&e.hoverRadius||0);return 2*(t+(t&&e.borderWidth||0))}draw(e,t){const n=this.options;this.skip||n.radius<.1||!Xs(this,t,this.size(n)/2)||(e.strokeStyle=n.borderColor,e.lineWidth=n.borderWidth,e.fillStyle=n.backgroundColor,qs(e,n,this.x,this.y))}getRange(){const e=this.options||{};return e.radius+e.hitRadius}}function Dc(e,t){const{x:n,y:a,base:s,width:r,height:i}=e.getProps(["x","y","base","width","height"],t);let o,c,l,u,h;return e.horizontal?(h=i/2,o=Math.min(n,s),c=Math.max(n,s),l=a-h,u=a+h):(h=r/2,o=n-h,c=n+h,l=Math.min(a,s),u=Math.max(a,s)),{left:o,top:l,right:c,bottom:u}}function Oc(e,t,n,a){return e?0:ls(t,n,a)}function Fc(e){const t=Dc(e),n=t.right-t.left,a=t.bottom-t.top,s=function(e,t,n){const a=e.options.borderWidth,s=e.borderSkipped,r=cr(a);return{t:Oc(s.top,r.top,0,n),r:Oc(s.right,r.right,0,t),b:Oc(s.bottom,r.bottom,0,n),l:Oc(s.left,r.left,0,t)}}(e,n/2,a/2),r=function(e,t,n){const{enableBorderRadius:a}=e.getProps(["enableBorderRadius"]),s=e.options.borderRadius,r=lr(s),i=Math.min(t,n),o=e.borderSkipped,c=a||wa(s);return{topLeft:Oc(!c||o.top||o.left,r.topLeft,0,i),topRight:Oc(!c||o.top||o.right,r.topRight,0,i),bottomLeft:Oc(!c||o.bottom||o.left,r.bottomLeft,0,i),bottomRight:Oc(!c||o.bottom||o.right,r.bottomRight,0,i)}}(e,n/2,a/2);return{outer:{x:t.left,y:t.top,w:n,h:a,radius:r},inner:{x:t.left+s.l,y:t.top+s.t,w:n-s.l-s.r,h:a-s.t-s.b,radius:{topLeft:Math.max(0,r.topLeft-Math.max(s.t,s.l)),topRight:Math.max(0,r.topRight-Math.max(s.t,s.r)),bottomLeft:Math.max(0,r.bottomLeft-Math.max(s.b,s.l)),bottomRight:Math.max(0,r.bottomRight-Math.max(s.b,s.r))}}}}function Lc(e,t,n,a){const s=null===t,r=null===n,i=e&&!(s&&r)&&Dc(e,a);return i&&(s||us(t,i.left,i.right))&&(r||us(n,i.top,i.bottom))}function zc(e,t){e.rect(t.x,t.y,t.w,t.h)}function Bc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const a=e.x!==n.x?-t:0,s=e.y!==n.y?-t:0,r=(e.x+e.w!==n.x+n.w?t:0)-a,i=(e.y+e.h!==n.y+n.h?t:0)-s;return{x:e.x+a,y:e.y+s,w:e.w+r,h:e.h+i,radius:e.radius}}On(Pc,"id","point"),On(Pc,"defaults",{borderWidth:1,hitRadius:1,hoverBorderWidth:1,hoverRadius:4,pointStyle:"circle",radius:3,rotation:0}),On(Pc,"defaultRoutes",{backgroundColor:"backgroundColor",borderColor:"borderColor"});class jc extends Ro{constructor(e){super(),this.options=void 0,this.horizontal=void 0,this.base=void 0,this.width=void 0,this.height=void 0,this.inflateAmount=void 0,e&&Object.assign(this,e)}draw(e){const{inflateAmount:t,options:{borderColor:n,backgroundColor:a}}=this,{inner:s,outer:r}=Fc(this),i=(o=r.radius).topLeft||o.topRight||o.bottomLeft||o.bottomRight?nr:zc;var o;e.save(),r.w===s.w&&r.h===s.h||(e.beginPath(),i(e,Bc(r,t,s)),e.clip(),i(e,Bc(s,-t,r)),e.fillStyle=n,e.fill("evenodd")),e.beginPath(),i(e,Bc(s,t)),e.fillStyle=a,e.fill(),e.restore()}inRange(e,t,n){return Lc(this,e,t,n)}inXRange(e,t){return Lc(this,e,null,t)}inYRange(e,t){return Lc(this,null,e,t)}getCenterPoint(e){const{x:t,y:n,base:a,horizontal:s}=this.getProps(["x","y","base","horizontal"],e);return{x:s?(t+a)/2:t,y:s?n:(n+a)/2}}getRange(e){return"x"===e?this.width/2:this.height/2}}On(jc,"id","bar"),On(jc,"defaults",{borderSkipped:"start",borderWidth:0,borderRadius:0,inflateAmount:"auto",pointStyle:void 0}),On(jc,"defaultRoutes",{backgroundColor:"backgroundColor",borderColor:"borderColor"});const Wc=(e,t)=>{let{boxHeight:n=t,boxWidth:a=t}=e;return e.usePointStyle&&(n=Math.min(n,t),a=e.pointStyleWidth||Math.min(a,t)),{boxWidth:a,boxHeight:n,itemHeight:Math.max(t,n)}};class Vc extends Ro{constructor(e){super(),this._added=!1,this.legendHitBoxes=[],this._hoveredItem=null,this.doughnutMode=!1,this.chart=e.chart,this.options=e.options,this.ctx=e.ctx,this.legendItems=void 0,this.columnSizes=void 0,this.lineWidths=void 0,this.maxHeight=void 0,this.maxWidth=void 0,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.height=void 0,this.width=void 0,this._margins=void 0,this.position=void 0,this.weight=void 0,this.fullSize=void 0}update(e,t,n){this.maxWidth=e,this.maxHeight=t,this._margins=n,this.setDimensions(),this.buildLabels(),this.fit()}setDimensions(){this.isHorizontal()?(this.width=this.maxWidth,this.left=this._margins.left,this.right=this.width):(this.height=this.maxHeight,this.top=this._margins.top,this.bottom=this.height)}buildLabels(){const e=this.options.labels||{};let t=Na(e.generateLabels,[this.chart],this)||[];e.filter&&(t=t.filter(t=>e.filter(t,this.chart.data))),e.sort&&(t=t.sort((t,n)=>e.sort(t,n,this.chart.data))),this.options.reverse&&t.reverse(),this.legendItems=t}fit(){const{options:e,ctx:t}=this;if(!e.display)return void(this.width=this.height=0);const n=e.labels,a=hr(n.font),s=a.size,r=this._computeTitleHeight(),{boxWidth:i,itemHeight:o}=Wc(n,s);let c,l;t.font=a.string,this.isHorizontal()?(c=this.maxWidth,l=this._fitRows(r,s,i,o)+10):(l=this.maxHeight,c=this._fitCols(r,a,i,o)+10),this.width=Math.min(c,e.maxWidth||this.maxWidth),this.height=Math.min(l,e.maxHeight||this.maxHeight)}_fitRows(e,t,n,a){const{ctx:s,maxWidth:r,options:{labels:{padding:i}}}=this,o=this.legendHitBoxes=[],c=this.lineWidths=[0],l=a+i;let u=e;s.textAlign="left",s.textBaseline="middle";let h=-1,d=-l;return this.legendItems.forEach((e,p)=>{const f=n+t/2+s.measureText(e.text).width;(0===p||c[c.length-1]+f+2*i>r)&&(u+=l,c[c.length-(p>0?0:1)]=0,d+=l,h++),o[p]={left:0,top:d,row:h,width:f,height:a},c[c.length-1]+=f+i}),u}_fitCols(e,t,n,a){const{ctx:s,maxHeight:r,options:{labels:{padding:i}}}=this,o=this.legendHitBoxes=[],c=this.columnSizes=[],l=r-e;let u=i,h=0,d=0,p=0,f=0;return this.legendItems.forEach((e,r)=>{const{itemWidth:m,itemHeight:g}=function(e,t,n,a,s){const r=function(e,t,n,a){let s=e.text;s&&"string"!==typeof s&&(s=s.reduce((e,t)=>e.length>t.length?e:t));return t+n.size/2+a.measureText(s).width}(a,e,t,n),i=function(e,t,n){let a=e;"string"!==typeof t.text&&(a=Uc(t,n));return a}(s,a,t.lineHeight);return{itemWidth:r,itemHeight:i}}(n,t,s,e,a);r>0&&d+g+2*i>l&&(u+=h+i,c.push({width:h,height:d}),p+=h+i,f++,h=d=0),o[r]={left:p,top:d,col:f,width:m,height:g},h=Math.max(h,m),d+=g+i}),u+=h,c.push({width:h,height:d}),u}adjustHitBoxes(){if(!this.options.display)return;const e=this._computeTitleHeight(),{legendHitBoxes:t,options:{align:n,labels:{padding:a},rtl:s}}=this,r=Qr(s,this.left,this.width);if(this.isHorizontal()){let s=0,i=vs(n,this.left+a,this.right-this.lineWidths[s]);for(const o of t)s!==o.row&&(s=o.row,i=vs(n,this.left+a,this.right-this.lineWidths[s])),o.top+=this.top+e+a,o.left=r.leftForLtr(r.x(i),o.width),i+=o.width+a}else{let s=0,i=vs(n,this.top+e+a,this.bottom-this.columnSizes[s].height);for(const o of t)o.col!==s&&(s=o.col,i=vs(n,this.top+e+a,this.bottom-this.columnSizes[s].height)),o.top=i,o.left+=this.left+a,o.left=r.leftForLtr(r.x(o.left),o.width),i+=o.height+a}}isHorizontal(){return"top"===this.options.position||"bottom"===this.options.position}draw(){if(this.options.display){const e=this.ctx;Ys(e,this),this._draw(),Qs(e)}}_draw(){const{options:e,columnSizes:t,lineWidths:n,ctx:a}=this,{align:s,labels:r}=e,i=Ws.color,o=Qr(e.rtl,this.left,this.width),c=hr(r.font),{padding:l}=r,u=c.size,h=u/2;let d;this.drawTitle(),a.textAlign=o.textAlign("left"),a.textBaseline="middle",a.lineWidth=.5,a.font=c.string;const{boxWidth:p,boxHeight:f,itemHeight:m}=Wc(r,u),g=this.isHorizontal(),y=this._computeTitleHeight();d=g?{x:vs(s,this.left+l,this.right-n[0]),y:this.top+l+y,line:0}:{x:this.left+l,y:vs(s,this.top+y+l,this.bottom-t[0].height),line:0},Zr(this.ctx,e.textDirection);const b=m+l;this.legendItems.forEach((x,v)=>{a.strokeStyle=x.fontColor,a.fillStyle=x.fontColor;const w=a.measureText(x.text).width,k=o.textAlign(x.textAlign||(x.textAlign=r.textAlign)),S=p+h+w;let C=d.x,I=d.y;o.setWidth(this.width),g?v>0&&C+S+l>this.right&&(I=d.y+=b,d.line++,C=d.x=vs(s,this.left+l,this.right-n[d.line])):v>0&&I+b>this.bottom&&(C=d.x=C+t[d.line].width+l,d.line++,I=d.y=vs(s,this.top+y+l,this.bottom-t[d.line].height));if(function(e,t,n){if(isNaN(p)||p<=0||isNaN(f)||f<0)return;a.save();const s=Ca(n.lineWidth,1);if(a.fillStyle=Ca(n.fillStyle,i),a.lineCap=Ca(n.lineCap,"butt"),a.lineDashOffset=Ca(n.lineDashOffset,0),a.lineJoin=Ca(n.lineJoin,"miter"),a.lineWidth=s,a.strokeStyle=Ca(n.strokeStyle,i),a.setLineDash(Ca(n.lineDash,[])),r.usePointStyle){const i={radius:f*Math.SQRT2/2,pointStyle:n.pointStyle,rotation:n.rotation,borderWidth:s},c=o.xPlus(e,p/2);Ks(a,i,c,t+h,r.pointStyleWidth&&p)}else{const r=t+Math.max((u-f)/2,0),i=o.leftForLtr(e,p),c=lr(n.borderRadius);a.beginPath(),Object.values(c).some(e=>0!==e)?nr(a,{x:i,y:r,w:p,h:f,radius:c}):a.rect(i,r,p,f),a.fill(),0!==s&&a.stroke()}a.restore()}(o.x(C),I,x),C=((e,t,n,a)=>e===(a?"left":"right")?n:"center"===e?(t+n)/2:t)(k,C+p+h,g?C+S:this.right,e.rtl),function(e,t,n){tr(a,n.text,e,t+m/2,c,{strikethrough:n.hidden,textAlign:o.textAlign(n.textAlign)})}(o.x(C),I,x),g)d.x+=S+l;else if("string"!==typeof x.text){const e=c.lineHeight;d.y+=Uc(x,e)+l}else d.y+=b}),Jr(this.ctx,e.textDirection)}drawTitle(){const e=this.options,t=e.title,n=hr(t.font),a=ur(t.padding);if(!t.display)return;const s=Qr(e.rtl,this.left,this.width),r=this.ctx,i=t.position,o=n.size/2,c=a.top+o;let l,u=this.left,h=this.width;if(this.isHorizontal())h=Math.max(...this.lineWidths),l=this.top+c,u=vs(e.align,u,this.right-h);else{const t=this.columnSizes.reduce((e,t)=>Math.max(e,t.height),0);l=c+vs(e.align,this.top,this.bottom-t-e.labels.padding-this._computeTitleHeight())}const d=vs(i,u,u+h);r.textAlign=s.textAlign(xs(i)),r.textBaseline="middle",r.strokeStyle=t.color,r.fillStyle=t.color,r.font=n.string,tr(r,t.text,d,l,n)}_computeTitleHeight(){const e=this.options.title,t=hr(e.font),n=ur(e.padding);return e.display?t.lineHeight+n.height:0}_getLegendItemAt(e,t){let n,a,s;if(us(e,this.left,this.right)&&us(t,this.top,this.bottom))for(s=this.legendHitBoxes,n=0;n<s.length;++n)if(a=s[n],us(e,a.left,a.left+a.width)&&us(t,a.top,a.top+a.height))return this.legendItems[n];return null}handleEvent(e){const t=this.options;if(!function(e,t){if(("mousemove"===e||"mouseout"===e)&&(t.onHover||t.onLeave))return!0;if(t.onClick&&("click"===e||"mouseup"===e))return!0;return!1}(e.type,t))return;const n=this._getLegendItemAt(e.x,e.y);if("mousemove"===e.type||"mouseout"===e.type){const r=this._hoveredItem,i=(s=n,null!==(a=r)&&null!==s&&a.datasetIndex===s.datasetIndex&&a.index===s.index);r&&!i&&Na(t.onLeave,[e,r,this],this),this._hoveredItem=n,n&&!i&&Na(t.onHover,[e,n,this],this)}else n&&Na(t.onClick,[e,n,this],this);var a,s}}function Uc(e,t){return t*(e.text?e.text.length:0)}var Hc={id:"legend",_element:Vc,start(e,t,n){const a=e.legend=new Vc({ctx:e.ctx,options:n,chart:e});uo.configure(e,a,n),uo.addBox(e,a)},stop(e){uo.removeBox(e,e.legend),delete e.legend},beforeUpdate(e,t,n){const a=e.legend;uo.configure(e,a,n),a.options=n},afterUpdate(e){const t=e.legend;t.buildLabels(),t.adjustHitBoxes()},afterEvent(e,t){t.replay||e.legend.handleEvent(t.event)},defaults:{display:!0,position:"top",align:"center",fullSize:!0,reverse:!1,weight:1e3,onClick(e,t,n){const a=t.datasetIndex,s=n.chart;s.isDatasetVisible(a)?(s.hide(a),t.hidden=!0):(s.show(a),t.hidden=!1)},onHover:null,onLeave:null,labels:{color:e=>e.chart.options.color,boxWidth:40,padding:10,generateLabels(e){const t=e.data.datasets,{labels:{usePointStyle:n,pointStyle:a,textAlign:s,color:r,useBorderRadius:i,borderRadius:o}}=e.legend.options;return e._getSortedDatasetMetas().map(e=>{const c=e.controller.getStyle(n?0:void 0),l=ur(c.borderWidth);return{text:t[e.index].label,fillStyle:c.backgroundColor,fontColor:r,hidden:!e.visible,lineCap:c.borderCapStyle,lineDash:c.borderDash,lineDashOffset:c.borderDashOffset,lineJoin:c.borderJoinStyle,lineWidth:(l.width+l.height)/4,strokeStyle:c.borderColor,pointStyle:a||c.pointStyle,rotation:c.rotation,textAlign:s||c.textAlign,borderRadius:i&&(o||c.borderRadius),datasetIndex:e.index}},this)}},title:{color:e=>e.chart.options.color,display:!1,position:"center",text:""}},descriptors:{_scriptable:e=>!e.startsWith("on"),labels:{_scriptable:e=>!["generateLabels","filter","sort"].includes(e)}}};class Gc extends Ro{constructor(e){super(),this.chart=e.chart,this.options=e.options,this.ctx=e.ctx,this._padding=void 0,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.width=void 0,this.height=void 0,this.position=void 0,this.weight=void 0,this.fullSize=void 0}update(e,t){const n=this.options;if(this.left=0,this.top=0,!n.display)return void(this.width=this.height=this.right=this.bottom=0);this.width=this.right=e,this.height=this.bottom=t;const a=va(n.text)?n.text.length:1;this._padding=ur(n.padding);const s=a*hr(n.font).lineHeight+this._padding.height;this.isHorizontal()?this.height=s:this.width=s}isHorizontal(){const e=this.options.position;return"top"===e||"bottom"===e}_drawArgs(e){const{top:t,left:n,bottom:a,right:s,options:r}=this,i=r.align;let o,c,l,u=0;return this.isHorizontal()?(c=vs(i,n,s),l=t+e,o=s-n):("left"===r.position?(c=n+e,l=vs(i,a,t),u=-.5*Wa):(c=s-e,l=vs(i,t,a),u=.5*Wa),o=a-t),{titleX:c,titleY:l,maxWidth:o,rotation:u}}draw(){const e=this.ctx,t=this.options;if(!t.display)return;const n=hr(t.font),a=n.lineHeight/2+this._padding.top,{titleX:s,titleY:r,maxWidth:i,rotation:o}=this._drawArgs(a);tr(e,t.text,0,0,n,{color:t.color,maxWidth:i,rotation:o,textAlign:xs(t.align),textBaseline:"middle",translation:[s,r]})}}var qc={id:"title",_element:Gc,start(e,t,n){!function(e,t){const n=new Gc({ctx:e.ctx,options:t,chart:e});uo.configure(e,n,t),uo.addBox(e,n),e.titleBlock=n}(e,n)},stop(e){const t=e.titleBlock;uo.removeBox(e,t),delete e.titleBlock},beforeUpdate(e,t,n){const a=e.titleBlock;uo.configure(e,a,n),a.options=n},defaults:{align:"center",display:!1,font:{weight:"bold"},fullSize:!0,padding:10,position:"top",text:"",weight:2e3},defaultRoutes:{color:"color"},descriptors:{_scriptable:!0,_indexable:!1}};new WeakMap;const Kc={average(e){if(!e.length)return!1;let t,n,a=new Set,s=0,r=0;for(t=0,n=e.length;t<n;++t){const n=e[t].element;if(n&&n.hasValue()){const e=n.tooltipPosition();a.add(e.x),s+=e.y,++r}}if(0===r||0===a.size)return!1;return{x:[...a].reduce((e,t)=>e+t)/a.size,y:s/r}},nearest(e,t){if(!e.length)return!1;let n,a,s,r=t.x,i=t.y,o=Number.POSITIVE_INFINITY;for(n=0,a=e.length;n<a;++n){const a=e[n].element;if(a&&a.hasValue()){const e=rs(t,a.getCenterPoint());e<o&&(o=e,s=a)}}if(s){const e=s.tooltipPosition();r=e.x,i=e.y}return{x:r,y:i}}};function Xc(e,t){return t&&(va(t)?Array.prototype.push.apply(e,t):e.push(t)),e}function Yc(e){return("string"===typeof e||e instanceof String)&&e.indexOf("\n")>-1?e.split("\n"):e}function Qc(e,t){const{element:n,datasetIndex:a,index:s}=t,r=e.getDatasetMeta(a).controller,{label:i,value:o}=r.getLabelAndValue(s);return{chart:e,label:i,parsed:r.getParsed(s),raw:e.data.datasets[a].data[s],formattedValue:o,dataset:r.getDataset(),dataIndex:s,datasetIndex:a,element:n}}function Zc(e,t){const n=e.chart.ctx,{body:a,footer:s,title:r}=e,{boxWidth:i,boxHeight:o}=t,c=hr(t.bodyFont),l=hr(t.titleFont),u=hr(t.footerFont),h=r.length,d=s.length,p=a.length,f=ur(t.padding);let m=f.height,g=0,y=a.reduce((e,t)=>e+t.before.length+t.lines.length+t.after.length,0);if(y+=e.beforeBody.length+e.afterBody.length,h&&(m+=h*l.lineHeight+(h-1)*t.titleSpacing+t.titleMarginBottom),y){m+=p*(t.displayColors?Math.max(o,c.lineHeight):c.lineHeight)+(y-p)*c.lineHeight+(y-1)*t.bodySpacing}d&&(m+=t.footerMarginTop+d*u.lineHeight+(d-1)*t.footerSpacing);let b=0;const x=function(e){g=Math.max(g,n.measureText(e).width+b)};return n.save(),n.font=l.string,Ta(e.title,x),n.font=c.string,Ta(e.beforeBody.concat(e.afterBody),x),b=t.displayColors?i+2+t.boxPadding:0,Ta(a,e=>{Ta(e.before,x),Ta(e.lines,x),Ta(e.after,x)}),b=0,n.font=u.string,Ta(e.footer,x),n.restore(),g+=f.width,{width:g,height:m}}function Jc(e,t,n,a){const{x:s,width:r}=n,{width:i,chartArea:{left:o,right:c}}=e;let l="center";return"center"===a?l=s<=(o+c)/2?"left":"right":s<=r/2?l="left":s>=i-r/2&&(l="right"),function(e,t,n,a){const{x:s,width:r}=a,i=n.caretSize+n.caretPadding;return"left"===e&&s+r+i>t.width||"right"===e&&s-r-i<0||void 0}(l,e,t,n)&&(l="center"),l}function $c(e,t,n){const a=n.yAlign||t.yAlign||function(e,t){const{y:n,height:a}=t;return n<a/2?"top":n>e.height-a/2?"bottom":"center"}(e,n);return{xAlign:n.xAlign||t.xAlign||Jc(e,t,n,a),yAlign:a}}function el(e,t,n,a){const{caretSize:s,caretPadding:r,cornerRadius:i}=e,{xAlign:o,yAlign:c}=n,l=s+r,{topLeft:u,topRight:h,bottomLeft:d,bottomRight:p}=lr(i);let f=function(e,t){let{x:n,width:a}=e;return"right"===t?n-=a:"center"===t&&(n-=a/2),n}(t,o);const m=function(e,t,n){let{y:a,height:s}=e;return"top"===t?a+=n:a-="bottom"===t?s+n:s/2,a}(t,c,l);return"center"===c?"left"===o?f+=l:"right"===o&&(f-=l):"left"===o?f-=Math.max(u,d)+s:"right"===o&&(f+=Math.max(h,p)+s),{x:ls(f,0,a.width-t.width),y:ls(m,0,a.height-t.height)}}function tl(e,t,n){const a=ur(n.padding);return"center"===t?e.x+e.width/2:"right"===t?e.x+e.width-a.right:e.x+a.left}function nl(e){return Xc([],Yc(e))}function al(e,t){const n=t&&t.dataset&&t.dataset.tooltip&&t.dataset.tooltip.callbacks;return n?e.override(n):e}const sl={beforeTitle:ya,title(e){if(e.length>0){const t=e[0],n=t.chart.data.labels,a=n?n.length:0;if(this&&this.options&&"dataset"===this.options.mode)return t.dataset.label||"";if(t.label)return t.label;if(a>0&&t.dataIndex<a)return n[t.dataIndex]}return""},afterTitle:ya,beforeBody:ya,beforeLabel:ya,label(e){if(this&&this.options&&"dataset"===this.options.mode)return e.label+": "+e.formattedValue||e.formattedValue;let t=e.dataset.label||"";t&&(t+=": ");const n=e.formattedValue;return xa(n)||(t+=n),t},labelColor(e){const t=e.chart.getDatasetMeta(e.datasetIndex).controller.getStyle(e.dataIndex);return{borderColor:t.borderColor,backgroundColor:t.backgroundColor,borderWidth:t.borderWidth,borderDash:t.borderDash,borderDashOffset:t.borderDashOffset,borderRadius:0}},labelTextColor(){return this.options.bodyColor},labelPointStyle(e){const t=e.chart.getDatasetMeta(e.datasetIndex).controller.getStyle(e.dataIndex);return{pointStyle:t.pointStyle,rotation:t.rotation}},afterLabel:ya,afterBody:ya,beforeFooter:ya,footer:ya,afterFooter:ya};function rl(e,t,n,a){const s=e[t].call(n,a);return"undefined"===typeof s?sl[t].call(n,a):s}class il extends Ro{constructor(e){super(),this.opacity=0,this._active=[],this._eventPosition=void 0,this._size=void 0,this._cachedAnimations=void 0,this._tooltipItems=[],this.$animations=void 0,this.$context=void 0,this.chart=e.chart,this.options=e.options,this.dataPoints=void 0,this.title=void 0,this.beforeBody=void 0,this.body=void 0,this.afterBody=void 0,this.footer=void 0,this.xAlign=void 0,this.yAlign=void 0,this.x=void 0,this.y=void 0,this.height=void 0,this.width=void 0,this.caretX=void 0,this.caretY=void 0,this.labelColors=void 0,this.labelPointStyles=void 0,this.labelTextColors=void 0}initialize(e){this.options=e,this._cachedAnimations=void 0,this.$context=void 0}_resolveAnimations(){const e=this._cachedAnimations;if(e)return e;const t=this.chart,n=this.options.setContext(this.getContext()),a=n.enabled&&t.options.animation&&n.animations,s=new pi(this.chart,a);return a._cacheable&&(this._cachedAnimations=Object.freeze(s)),s}getContext(){return this.$context||(this.$context=(e=this.chart.getContext(),t=this,n=this._tooltipItems,pr(e,{tooltip:t,tooltipItems:n,type:"tooltip"})));var e,t,n}getTitle(e,t){const{callbacks:n}=t,a=rl(n,"beforeTitle",this,e),s=rl(n,"title",this,e),r=rl(n,"afterTitle",this,e);let i=[];return i=Xc(i,Yc(a)),i=Xc(i,Yc(s)),i=Xc(i,Yc(r)),i}getBeforeBody(e,t){return nl(rl(t.callbacks,"beforeBody",this,e))}getBody(e,t){const{callbacks:n}=t,a=[];return Ta(e,e=>{const t={before:[],lines:[],after:[]},s=al(n,e);Xc(t.before,Yc(rl(s,"beforeLabel",this,e))),Xc(t.lines,rl(s,"label",this,e)),Xc(t.after,Yc(rl(s,"afterLabel",this,e))),a.push(t)}),a}getAfterBody(e,t){return nl(rl(t.callbacks,"afterBody",this,e))}getFooter(e,t){const{callbacks:n}=t,a=rl(n,"beforeFooter",this,e),s=rl(n,"footer",this,e),r=rl(n,"afterFooter",this,e);let i=[];return i=Xc(i,Yc(a)),i=Xc(i,Yc(s)),i=Xc(i,Yc(r)),i}_createItems(e){const t=this._active,n=this.chart.data,a=[],s=[],r=[];let i,o,c=[];for(i=0,o=t.length;i<o;++i)c.push(Qc(this.chart,t[i]));return e.filter&&(c=c.filter((t,a,s)=>e.filter(t,a,s,n))),e.itemSort&&(c=c.sort((t,a)=>e.itemSort(t,a,n))),Ta(c,t=>{const n=al(e.callbacks,t);a.push(rl(n,"labelColor",this,t)),s.push(rl(n,"labelPointStyle",this,t)),r.push(rl(n,"labelTextColor",this,t))}),this.labelColors=a,this.labelPointStyles=s,this.labelTextColors=r,this.dataPoints=c,c}update(e,t){const n=this.options.setContext(this.getContext()),a=this._active;let s,r=[];if(a.length){const e=Kc[n.position].call(this,a,this._eventPosition);r=this._createItems(n),this.title=this.getTitle(r,n),this.beforeBody=this.getBeforeBody(r,n),this.body=this.getBody(r,n),this.afterBody=this.getAfterBody(r,n),this.footer=this.getFooter(r,n);const t=this._size=Zc(this,n),i=Object.assign({},e,t),o=$c(this.chart,n,i),c=el(n,i,o,this.chart);this.xAlign=o.xAlign,this.yAlign=o.yAlign,s={opacity:1,x:c.x,y:c.y,width:t.width,height:t.height,caretX:e.x,caretY:e.y}}else 0!==this.opacity&&(s={opacity:0});this._tooltipItems=r,this.$context=void 0,s&&this._resolveAnimations().update(this,s),e&&n.external&&n.external.call(this,{chart:this.chart,tooltip:this,replay:t})}drawCaret(e,t,n,a){const s=this.getCaretPosition(e,n,a);t.lineTo(s.x1,s.y1),t.lineTo(s.x2,s.y2),t.lineTo(s.x3,s.y3)}getCaretPosition(e,t,n){const{xAlign:a,yAlign:s}=this,{caretSize:r,cornerRadius:i}=n,{topLeft:o,topRight:c,bottomLeft:l,bottomRight:u}=lr(i),{x:h,y:d}=e,{width:p,height:f}=t;let m,g,y,b,x,v;return"center"===s?(x=d+f/2,"left"===a?(m=h,g=m-r,b=x+r,v=x-r):(m=h+p,g=m+r,b=x-r,v=x+r),y=m):(g="left"===a?h+Math.max(o,l)+r:"right"===a?h+p-Math.max(c,u)-r:this.caretX,"top"===s?(b=d,x=b-r,m=g-r,y=g+r):(b=d+f,x=b+r,m=g+r,y=g-r),v=b),{x1:m,x2:g,x3:y,y1:b,y2:x,y3:v}}drawTitle(e,t,n){const a=this.title,s=a.length;let r,i,o;if(s){const c=Qr(n.rtl,this.x,this.width);for(e.x=tl(this,n.titleAlign,n),t.textAlign=c.textAlign(n.titleAlign),t.textBaseline="middle",r=hr(n.titleFont),i=n.titleSpacing,t.fillStyle=n.titleColor,t.font=r.string,o=0;o<s;++o)t.fillText(a[o],c.x(e.x),e.y+r.lineHeight/2),e.y+=r.lineHeight+i,o+1===s&&(e.y+=n.titleMarginBottom-i)}}_drawColorBox(e,t,n,a,s){const r=this.labelColors[n],i=this.labelPointStyles[n],{boxHeight:o,boxWidth:c}=s,l=hr(s.bodyFont),u=tl(this,"left",s),h=a.x(u),d=o<l.lineHeight?(l.lineHeight-o)/2:0,p=t.y+d;if(s.usePointStyle){const t={radius:Math.min(c,o)/2,pointStyle:i.pointStyle,rotation:i.rotation,borderWidth:1},n=a.leftForLtr(h,c)+c/2,l=p+o/2;e.strokeStyle=s.multiKeyBackground,e.fillStyle=s.multiKeyBackground,qs(e,t,n,l),e.strokeStyle=r.borderColor,e.fillStyle=r.backgroundColor,qs(e,t,n,l)}else{e.lineWidth=wa(r.borderWidth)?Math.max(...Object.values(r.borderWidth)):r.borderWidth||1,e.strokeStyle=r.borderColor,e.setLineDash(r.borderDash||[]),e.lineDashOffset=r.borderDashOffset||0;const t=a.leftForLtr(h,c),n=a.leftForLtr(a.xPlus(h,1),c-2),i=lr(r.borderRadius);Object.values(i).some(e=>0!==e)?(e.beginPath(),e.fillStyle=s.multiKeyBackground,nr(e,{x:t,y:p,w:c,h:o,radius:i}),e.fill(),e.stroke(),e.fillStyle=r.backgroundColor,e.beginPath(),nr(e,{x:n,y:p+1,w:c-2,h:o-2,radius:i}),e.fill()):(e.fillStyle=s.multiKeyBackground,e.fillRect(t,p,c,o),e.strokeRect(t,p,c,o),e.fillStyle=r.backgroundColor,e.fillRect(n,p+1,c-2,o-2))}e.fillStyle=this.labelTextColors[n]}drawBody(e,t,n){const{body:a}=this,{bodySpacing:s,bodyAlign:r,displayColors:i,boxHeight:o,boxWidth:c,boxPadding:l}=n,u=hr(n.bodyFont);let h=u.lineHeight,d=0;const p=Qr(n.rtl,this.x,this.width),f=function(n){t.fillText(n,p.x(e.x+d),e.y+h/2),e.y+=h+s},m=p.textAlign(r);let g,y,b,x,v,w,k;for(t.textAlign=r,t.textBaseline="middle",t.font=u.string,e.x=tl(this,m,n),t.fillStyle=n.bodyColor,Ta(this.beforeBody,f),d=i&&"right"!==m?"center"===r?c/2+l:c+2+l:0,x=0,w=a.length;x<w;++x){for(g=a[x],y=this.labelTextColors[x],t.fillStyle=y,Ta(g.before,f),b=g.lines,i&&b.length&&(this._drawColorBox(t,e,x,p,n),h=Math.max(u.lineHeight,o)),v=0,k=b.length;v<k;++v)f(b[v]),h=u.lineHeight;Ta(g.after,f)}d=0,h=u.lineHeight,Ta(this.afterBody,f),e.y-=s}drawFooter(e,t,n){const a=this.footer,s=a.length;let r,i;if(s){const o=Qr(n.rtl,this.x,this.width);for(e.x=tl(this,n.footerAlign,n),e.y+=n.footerMarginTop,t.textAlign=o.textAlign(n.footerAlign),t.textBaseline="middle",r=hr(n.footerFont),t.fillStyle=n.footerColor,t.font=r.string,i=0;i<s;++i)t.fillText(a[i],o.x(e.x),e.y+r.lineHeight/2),e.y+=r.lineHeight+n.footerSpacing}}drawBackground(e,t,n,a){const{xAlign:s,yAlign:r}=this,{x:i,y:o}=e,{width:c,height:l}=n,{topLeft:u,topRight:h,bottomLeft:d,bottomRight:p}=lr(a.cornerRadius);t.fillStyle=a.backgroundColor,t.strokeStyle=a.borderColor,t.lineWidth=a.borderWidth,t.beginPath(),t.moveTo(i+u,o),"top"===r&&this.drawCaret(e,t,n,a),t.lineTo(i+c-h,o),t.quadraticCurveTo(i+c,o,i+c,o+h),"center"===r&&"right"===s&&this.drawCaret(e,t,n,a),t.lineTo(i+c,o+l-p),t.quadraticCurveTo(i+c,o+l,i+c-p,o+l),"bottom"===r&&this.drawCaret(e,t,n,a),t.lineTo(i+d,o+l),t.quadraticCurveTo(i,o+l,i,o+l-d),"center"===r&&"left"===s&&this.drawCaret(e,t,n,a),t.lineTo(i,o+u),t.quadraticCurveTo(i,o,i+u,o),t.closePath(),t.fill(),a.borderWidth>0&&t.stroke()}_updateAnimationTarget(e){const t=this.chart,n=this.$animations,a=n&&n.x,s=n&&n.y;if(a||s){const n=Kc[e.position].call(this,this._active,this._eventPosition);if(!n)return;const r=this._size=Zc(this,e),i=Object.assign({},n,this._size),o=$c(t,e,i),c=el(e,i,o,t);a._to===c.x&&s._to===c.y||(this.xAlign=o.xAlign,this.yAlign=o.yAlign,this.width=r.width,this.height=r.height,this.caretX=n.x,this.caretY=n.y,this._resolveAnimations().update(this,c))}}_willRender(){return!!this.opacity}draw(e){const t=this.options.setContext(this.getContext());let n=this.opacity;if(!n)return;this._updateAnimationTarget(t);const a={width:this.width,height:this.height},s={x:this.x,y:this.y};n=Math.abs(n)<.001?0:n;const r=ur(t.padding),i=this.title.length||this.beforeBody.length||this.body.length||this.afterBody.length||this.footer.length;t.enabled&&i&&(e.save(),e.globalAlpha=n,this.drawBackground(s,e,a,t),Zr(e,t.textDirection),s.y+=r.top,this.drawTitle(s,e,t),this.drawBody(s,e,t),this.drawFooter(s,e,t),Jr(e,t.textDirection),e.restore())}getActiveElements(){return this._active||[]}setActiveElements(e,t){const n=this._active,a=e.map(e=>{let{datasetIndex:t,index:n}=e;const a=this.chart.getDatasetMeta(t);if(!a)throw new Error("Cannot find a dataset at index "+t);return{datasetIndex:t,element:a.data[n],index:n}}),s=!Ea(n,a),r=this._positionChanged(a,t);(s||r)&&(this._active=a,this._eventPosition=t,this._ignoreReplayEvents=!0,this.update(!0))}handleEvent(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(t&&this._ignoreReplayEvents)return!1;this._ignoreReplayEvents=!1;const a=this.options,s=this._active||[],r=this._getActiveElements(e,s,t,n),i=this._positionChanged(r,e),o=t||!Ea(r,s)||i;return o&&(this._active=r,(a.enabled||a.external)&&(this._eventPosition={x:e.x,y:e.y},this.update(!0,t))),o}_getActiveElements(e,t,n,a){const s=this.options;if("mouseout"===e.type)return[];if(!a)return t.filter(e=>this.chart.data.datasets[e.datasetIndex]&&void 0!==this.chart.getDatasetMeta(e.datasetIndex).controller.getParsed(e.index));const r=this.chart.getElementsAtEventForMode(e,s.mode,s,n);return s.reverse&&r.reverse(),r}_positionChanged(e,t){const{caretX:n,caretY:a,options:s}=this,r=Kc[s.position].call(this,e,t);return!1!==r&&(n!==r.x||a!==r.y)}}On(il,"positioners",Kc);var ol={id:"tooltip",_element:il,positioners:Kc,afterInit(e,t,n){n&&(e.tooltip=new il({chart:e,options:n}))},beforeUpdate(e,t,n){e.tooltip&&e.tooltip.initialize(n)},reset(e,t,n){e.tooltip&&e.tooltip.initialize(n)},afterDraw(e){const t=e.tooltip;if(t&&t._willRender()){const n={tooltip:t};if(!1===e.notifyPlugins("beforeTooltipDraw",Ln(Ln({},n),{},{cancelable:!0})))return;t.draw(e.ctx),e.notifyPlugins("afterTooltipDraw",n)}},afterEvent(e,t){if(e.tooltip){const n=t.replay;e.tooltip.handleEvent(t.event,n,t.inChartArea)&&(t.changed=!0)}},defaults:{enabled:!0,external:null,position:"average",backgroundColor:"rgba(0,0,0,0.8)",titleColor:"#fff",titleFont:{weight:"bold"},titleSpacing:2,titleMarginBottom:6,titleAlign:"left",bodyColor:"#fff",bodySpacing:2,bodyFont:{},bodyAlign:"left",footerColor:"#fff",footerSpacing:2,footerMarginTop:6,footerFont:{weight:"bold"},footerAlign:"left",padding:6,caretPadding:2,caretSize:5,cornerRadius:6,boxHeight:(e,t)=>t.bodyFont.size,boxWidth:(e,t)=>t.bodyFont.size,multiKeyBackground:"#fff",displayColors:!0,boxPadding:0,borderColor:"rgba(0,0,0,0)",borderWidth:0,animation:{duration:400,easing:"easeOutQuart"},animations:{numbers:{type:"number",properties:["x","y","width","height","caretX","caretY"]},opacity:{easing:"linear",duration:200}},callbacks:sl},defaultRoutes:{bodyFont:"font",footerFont:"font",titleFont:"font"},descriptors:{_scriptable:e=>"filter"!==e&&"itemSort"!==e&&"external"!==e,_indexable:!1,callbacks:{_scriptable:!1,_indexable:!1},animation:{_fallback:!1},animations:{_fallback:"animation"}},additionalOptionScopes:["interaction"]};function cl(e,t,n,a){const s=e.indexOf(t);if(-1===s)return((e,t,n,a)=>("string"===typeof t?(n=e.push(t)-1,a.unshift({index:n,label:t})):isNaN(t)&&(n=null),n))(e,t,n,a);return s!==e.lastIndexOf(t)?n:s}function ll(e){const t=this.getLabels();return e>=0&&e<t.length?t[e]:e}class ul extends Bo{constructor(e){super(e),this._startValue=void 0,this._valueRange=0,this._addedLabels=[]}init(e){const t=this._addedLabels;if(t.length){const e=this.getLabels();for(const{index:n,label:a}of t)e[n]===a&&e.splice(n,1);this._addedLabels=[]}super.init(e)}parse(e,t){if(xa(e))return null;const n=this.getLabels();return((e,t)=>null===e?null:ls(Math.round(e),0,t))(t=isFinite(t)&&n[t]===e?t:cl(n,e,Ca(t,e),this._addedLabels),n.length-1)}determineDataLimits(){const{minDefined:e,maxDefined:t}=this.getUserBounds();let{min:n,max:a}=this.getMinMax(!0);"ticks"===this.options.bounds&&(e||(n=0),t||(a=this.getLabels().length-1)),this.min=n,this.max=a}buildTicks(){const e=this.min,t=this.max,n=this.options.offset,a=[];let s=this.getLabels();s=0===e&&t===s.length-1?s:s.slice(e,t+1),this._valueRange=Math.max(s.length-(n?0:1),1),this._startValue=this.min-(n?.5:0);for(let r=e;r<=t;r++)a.push({value:r});return a}getLabelForValue(e){return ll.call(this,e)}configure(){super.configure(),this.isHorizontal()||(this._reversePixels=!this._reversePixels)}getPixelForValue(e){return"number"!==typeof e&&(e=this.parse(e)),null===e?NaN:this.getPixelForDecimal((e-this._startValue)/this._valueRange)}getPixelForTick(e){const t=this.ticks;return e<0||e>t.length-1?null:this.getPixelForValue(t[e].value)}getValueForPixel(e){return Math.round(this._startValue+this.getDecimalForPixel(e)*this._valueRange)}getBasePixel(){return this.bottom}}function hl(e,t){const n=[],{bounds:a,step:s,min:r,max:i,precision:o,count:c,maxTicks:l,maxDigits:u,includeBounds:h}=e,d=s||1,p=l-1,{min:f,max:m}=t,g=!xa(r),y=!xa(i),b=!xa(c),x=(m-f)/(u+1);let v,w,k,S,C=Ja((m-f)/p/d)*d;if(C<1e-14&&!g&&!y)return[{value:f},{value:m}];S=Math.ceil(m/C)-Math.floor(f/C),S>p&&(C=Ja(S*C/p/d)*d),xa(o)||(v=Math.pow(10,o),C=Math.ceil(C*v)/v),"ticks"===a?(w=Math.floor(f/C)*C,k=Math.ceil(m/C)*C):(w=f,k=m),g&&y&&s&&function(e,t){const n=Math.round(e);return n-t<=e&&n+t>=e}((i-r)/s,C/1e3)?(S=Math.round(Math.min((i-r)/C,l)),C=(i-r)/S,w=r,k=i):b?(w=g?r:w,k=y?i:k,S=c-1,C=(k-w)/S):(S=(k-w)/C,S=Za(S,Math.round(S),C/1e3)?Math.round(S):Math.ceil(S));const I=Math.max(as(C),as(w));v=Math.pow(10,xa(o)?I:o),w=Math.round(w*v)/v,k=Math.round(k*v)/v;let N=0;for(g&&(h&&w!==r?(n.push({value:r}),w<r&&N++,Za(Math.round((w+N*C)*v)/v,r,dl(r,x,e))&&N++):w<r&&N++);N<S;++N){const e=Math.round((w+N*C)*v)/v;if(y&&e>i)break;n.push({value:e})}return y&&h&&k!==i?n.length&&Za(n[n.length-1].value,i,dl(i,x,e))?n[n.length-1].value=i:n.push({value:i}):y&&k!==i||n.push({value:k}),n}function dl(e,t,n){let{horizontal:a,minRotation:s}=n;const r=ts(s),i=(a?Math.sin(r):Math.cos(r))||.001,o=.75*t*(""+e).length;return Math.min(t/i,o)}On(ul,"id","category"),On(ul,"defaults",{ticks:{callback:ll}});class pl extends Bo{constructor(e){super(e),this.start=void 0,this.end=void 0,this._startValue=void 0,this._endValue=void 0,this._valueRange=0}parse(e,t){return xa(e)||("number"===typeof e||e instanceof Number)&&!isFinite(+e)?null:+e}handleTickRangeOptions(){const{beginAtZero:e}=this.options,{minDefined:t,maxDefined:n}=this.getUserBounds();let{min:a,max:s}=this;const r=e=>a=t?a:e,i=e=>s=n?s:e;if(e){const e=Qa(a),t=Qa(s);e<0&&t<0?i(0):e>0&&t>0&&r(0)}if(a===s){let t=0===s?1:Math.abs(.05*s);i(s+t),e||r(a-t)}this.min=a,this.max=s}getTickLimit(){const e=this.options.ticks;let t,{maxTicksLimit:n,stepSize:a}=e;return a?(t=Math.ceil(this.max/a)-Math.floor(this.min/a)+1,t>1e3&&(console.warn("scales.".concat(this.id,".ticks.stepSize: ").concat(a," would result generating up to ").concat(t," ticks. Limiting to 1000.")),t=1e3)):(t=this.computeTickLimit(),n=n||11),n&&(t=Math.min(n,t)),t}computeTickLimit(){return Number.POSITIVE_INFINITY}buildTicks(){const e=this.options,t=e.ticks;let n=this.getTickLimit();n=Math.max(2,n);const a=hl({maxTicks:n,bounds:e.bounds,min:e.min,max:e.max,precision:t.precision,step:t.stepSize,count:t.count,maxDigits:this._maxDigits(),horizontal:this.isHorizontal(),minRotation:t.minRotation||0,includeBounds:!1!==t.includeBounds},this._range||this);return"ticks"===e.bounds&&es(a,this,"value"),e.reverse?(a.reverse(),this.start=this.max,this.end=this.min):(this.start=this.min,this.end=this.max),a}configure(){const e=this.ticks;let t=this.min,n=this.max;if(super.configure(),this.options.offset&&e.length){const a=(n-t)/Math.max(e.length-1,1)/2;t-=a,n+=a}this._startValue=t,this._endValue=n,this._valueRange=n-t}getLabelForValue(e){return Ps(e,this.chart.options.locale,this.options.ticks.format)}}class fl extends pl{determineDataLimits(){const{min:e,max:t}=this.getMinMax(!0);this.min=ka(e)?e:0,this.max=ka(t)?t:1,this.handleTickRangeOptions()}computeTickLimit(){const e=this.isHorizontal(),t=e?this.width:this.height,n=ts(this.options.ticks.minRotation),a=(e?Math.sin(n):Math.cos(n))||.001,s=this._resolveTickFontOptions(0);return Math.ceil(t/Math.min(40,s.lineHeight/a))}getPixelForValue(e){return null===e?NaN:this.getPixelForDecimal((e-this._startValue)/this._valueRange)}getValueForPixel(e){return this._startValue+this.getDecimalForPixel(e)*this._valueRange}}On(fl,"id","linear"),On(fl,"defaults",{ticks:{callback:Os.formatters.numeric}});const ml=e=>Math.floor(Ya(e)),gl=(e,t)=>Math.pow(10,ml(e)+t);function yl(e){return 1===e/Math.pow(10,ml(e))}function bl(e,t,n){const a=Math.pow(10,n),s=Math.floor(e/a);return Math.ceil(t/a)-s}function xl(e,t){let{min:n,max:a}=t;n=Sa(e.min,n);const s=[],r=ml(n);let i=function(e,t){let n=ml(t-e);for(;bl(e,t,n)>10;)n++;for(;bl(e,t,n)<10;)n--;return Math.min(n,ml(e))}(n,a),o=i<0?Math.pow(10,Math.abs(i)):1;const c=Math.pow(10,i),l=r>i?Math.pow(10,r):0,u=Math.round((n-l)*o)/o,h=Math.floor((n-l)/c/10)*c*10;let d=Math.floor((u-h)/Math.pow(10,i)),p=Sa(e.min,Math.round((l+h+d*Math.pow(10,i))*o)/o);for(;p<a;)s.push({value:p,major:yl(p),significand:d}),d>=10?d=d<15?15:20:d++,d>=20&&(i++,d=2,o=i>=0?1:o),p=Math.round((l+h+d*Math.pow(10,i))*o)/o;const f=Sa(e.max,p);return s.push({value:f,major:yl(f),significand:d}),s}class vl extends Bo{constructor(e){super(e),this.start=void 0,this.end=void 0,this._startValue=void 0,this._valueRange=0}parse(e,t){const n=pl.prototype.parse.apply(this,[e,t]);if(0!==n)return ka(n)&&n>0?n:null;this._zero=!0}determineDataLimits(){const{min:e,max:t}=this.getMinMax(!0);this.min=ka(e)?Math.max(0,e):null,this.max=ka(t)?Math.max(0,t):null,this.options.beginAtZero&&(this._zero=!0),this._zero&&this.min!==this._suggestedMin&&!ka(this._userMin)&&(this.min=e===gl(this.min,0)?gl(this.min,-1):gl(this.min,0)),this.handleTickRangeOptions()}handleTickRangeOptions(){const{minDefined:e,maxDefined:t}=this.getUserBounds();let n=this.min,a=this.max;const s=t=>n=e?n:t,r=e=>a=t?a:e;n===a&&(n<=0?(s(1),r(10)):(s(gl(n,-1)),r(gl(a,1)))),n<=0&&s(gl(a,-1)),a<=0&&r(gl(n,1)),this.min=n,this.max=a}buildTicks(){const e=this.options,t=xl({min:this._userMin,max:this._userMax},this);return"ticks"===e.bounds&&es(t,this,"value"),e.reverse?(t.reverse(),this.start=this.max,this.end=this.min):(this.start=this.min,this.end=this.max),t}getLabelForValue(e){return void 0===e?"0":Ps(e,this.chart.options.locale,this.options.ticks.format)}configure(){const e=this.min;super.configure(),this._startValue=Ya(e),this._valueRange=Ya(this.max)-Ya(e)}getPixelForValue(e){return void 0!==e&&0!==e||(e=this.min),null===e||isNaN(e)?NaN:this.getPixelForDecimal(e===this.min?0:(Ya(e)-this._startValue)/this._valueRange)}getValueForPixel(e){const t=this.getDecimalForPixel(e);return Math.pow(10,this._startValue+t*this._valueRange)}}function wl(e){const t=e.ticks;if(t.display&&e.display){const e=ur(t.backdropPadding);return Ca(t.font&&t.font.size,Ws.font.size)+e.height}return 0}function kl(e,t,n){return n=va(n)?n:[n],{w:Us(e,t.string,n),h:n.length*t.lineHeight}}function Sl(e,t,n,a,s){return e===a||e===s?{start:t-n/2,end:t+n/2}:e<a||e>s?{start:t-n,end:t}:{start:t,end:t+n}}function Cl(e){const t={l:e.left+e._padding.left,r:e.right-e._padding.right,t:e.top+e._padding.top,b:e.bottom-e._padding.bottom},n=Object.assign({},t),a=[],s=[],r=e._pointLabels.length,i=e.options.pointLabels,o=i.centerPointLabels?Wa/r:0;for(let c=0;c<r;c++){const r=i.setContext(e.getPointLabelContext(c));s[c]=r.padding;const l=e.getPointPosition(c,e.drawingArea+s[c],o),u=hr(r.font),h=kl(e.ctx,u,e._pointLabels[c]);a[c]=h;const d=os(e.getIndexAngle(c)+o),p=Math.round(ns(d));Il(n,t,d,Sl(p,l.x,h.w,0,180),Sl(p,l.y,h.h,90,270))}e.setCenterPoint(t.l-n.l,n.r-t.r,t.t-n.t,n.b-t.b),e._pointLabelItems=function(e,t,n){const a=[],s=e._pointLabels.length,r=e.options,{centerPointLabels:i,display:o}=r.pointLabels,c={extra:wl(r)/2,additionalAngle:i?Wa/s:0};let l;for(let u=0;u<s;u++){c.padding=n[u],c.size=t[u];const s=Nl(e,u,c);a.push(s),"auto"===o&&(s.visible=Tl(s,l),s.visible&&(l=s))}return a}(e,a,s)}function Il(e,t,n,a,s){const r=Math.abs(Math.sin(n)),i=Math.abs(Math.cos(n));let o=0,c=0;a.start<t.l?(o=(t.l-a.start)/r,e.l=Math.min(e.l,t.l-o)):a.end>t.r&&(o=(a.end-t.r)/r,e.r=Math.max(e.r,t.r+o)),s.start<t.t?(c=(t.t-s.start)/i,e.t=Math.min(e.t,t.t-c)):s.end>t.b&&(c=(s.end-t.b)/i,e.b=Math.max(e.b,t.b+c))}function Nl(e,t,n){const a=e.drawingArea,{extra:s,additionalAngle:r,padding:i,size:o}=n,c=e.getPointPosition(t,a+s+i,r),l=Math.round(ns(os(c.angle+qa))),u=function(e,t,n){90===n||270===n?e-=t/2:(n>270||n<90)&&(e-=t);return e}(c.y,o.h,l),h=function(e){if(0===e||180===e)return"center";if(e<180)return"left";return"right"}(l),d=function(e,t,n){"right"===n?e-=t:"center"===n&&(e-=t/2);return e}(c.x,o.w,h);return{visible:!0,x:c.x,y:u,textAlign:h,left:d,top:u,right:d+o.w,bottom:u+o.h}}function Tl(e,t){if(!t)return!0;const{left:n,top:a,right:s,bottom:r}=e;return!(Xs({x:n,y:a},t)||Xs({x:n,y:r},t)||Xs({x:s,y:a},t)||Xs({x:s,y:r},t))}function El(e,t,n){const{left:a,top:s,right:r,bottom:i}=n,{backdropColor:o}=t;if(!xa(o)){const n=lr(t.borderRadius),c=ur(t.backdropPadding);e.fillStyle=o;const l=a-c.left,u=s-c.top,h=r-a+c.width,d=i-s+c.height;Object.values(n).some(e=>0!==e)?(e.beginPath(),nr(e,{x:l,y:u,w:h,h:d,radius:n}),e.fill()):e.fillRect(l,u,h,d)}}function Rl(e,t,n,a){const{ctx:s}=e;if(n)s.arc(e.xCenter,e.yCenter,t,0,Va);else{let n=e.getPointPosition(0,t);s.moveTo(n.x,n.y);for(let r=1;r<a;r++)n=e.getPointPosition(r,t),s.lineTo(n.x,n.y)}}On(vl,"id","logarithmic"),On(vl,"defaults",{ticks:{callback:Os.formatters.logarithmic,major:{enabled:!0}}});class _l extends pl{constructor(e){super(e),this.xCenter=void 0,this.yCenter=void 0,this.drawingArea=void 0,this._pointLabels=[],this._pointLabelItems=[]}setDimensions(){const e=this._padding=ur(wl(this.options)/2),t=this.width=this.maxWidth-e.width,n=this.height=this.maxHeight-e.height;this.xCenter=Math.floor(this.left+t/2+e.left),this.yCenter=Math.floor(this.top+n/2+e.top),this.drawingArea=Math.floor(Math.min(t,n)/2)}determineDataLimits(){const{min:e,max:t}=this.getMinMax(!1);this.min=ka(e)&&!isNaN(e)?e:0,this.max=ka(t)&&!isNaN(t)?t:0,this.handleTickRangeOptions()}computeTickLimit(){return Math.ceil(this.drawingArea/wl(this.options))}generateTickLabels(e){pl.prototype.generateTickLabels.call(this,e),this._pointLabels=this.getLabels().map((e,t)=>{const n=Na(this.options.pointLabels.callback,[e,t],this);return n||0===n?n:""}).filter((e,t)=>this.chart.getDataVisibility(t))}fit(){const e=this.options;e.display&&e.pointLabels.display?Cl(this):this.setCenterPoint(0,0,0,0)}setCenterPoint(e,t,n,a){this.xCenter+=Math.floor((e-t)/2),this.yCenter+=Math.floor((n-a)/2),this.drawingArea-=Math.min(this.drawingArea/2,Math.max(e,t,n,a))}getIndexAngle(e){return os(e*(Va/(this._pointLabels.length||1))+ts(this.options.startAngle||0))}getDistanceFromCenterForValue(e){if(xa(e))return NaN;const t=this.drawingArea/(this.max-this.min);return this.options.reverse?(this.max-e)*t:(e-this.min)*t}getValueForDistanceFromCenter(e){if(xa(e))return NaN;const t=e/(this.drawingArea/(this.max-this.min));return this.options.reverse?this.max-t:this.min+t}getPointLabelContext(e){const t=this._pointLabels||[];if(e>=0&&e<t.length){const n=t[e];return function(e,t,n){return pr(e,{label:n,index:t,type:"pointLabel"})}(this.getContext(),e,n)}}getPointPosition(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const a=this.getIndexAngle(e)-qa+n;return{x:Math.cos(a)*t+this.xCenter,y:Math.sin(a)*t+this.yCenter,angle:a}}getPointPositionForValue(e,t){return this.getPointPosition(e,this.getDistanceFromCenterForValue(t))}getBasePosition(e){return this.getPointPositionForValue(e||0,this.getBaseValue())}getPointLabelPosition(e){const{left:t,top:n,right:a,bottom:s}=this._pointLabelItems[e];return{left:t,top:n,right:a,bottom:s}}drawBackground(){const{backgroundColor:e,grid:{circular:t}}=this.options;if(e){const n=this.ctx;n.save(),n.beginPath(),Rl(this,this.getDistanceFromCenterForValue(this._endValue),t,this._pointLabels.length),n.closePath(),n.fillStyle=e,n.fill(),n.restore()}}drawGrid(){const e=this.ctx,t=this.options,{angleLines:n,grid:a,border:s}=t,r=this._pointLabels.length;let i,o,c;if(t.pointLabels.display&&function(e,t){const{ctx:n,options:{pointLabels:a}}=e;for(let s=t-1;s>=0;s--){const t=e._pointLabelItems[s];if(!t.visible)continue;const r=a.setContext(e.getPointLabelContext(s));El(n,r,t);const i=hr(r.font),{x:o,y:c,textAlign:l}=t;tr(n,e._pointLabels[s],o,c+i.lineHeight/2,i,{color:r.color,textAlign:l,textBaseline:"middle"})}}(this,r),a.display&&this.ticks.forEach((e,t)=>{if(0!==t||0===t&&this.min<0){o=this.getDistanceFromCenterForValue(e.value);const n=this.getContext(t),i=a.setContext(n),c=s.setContext(n);!function(e,t,n,a,s){const r=e.ctx,i=t.circular,{color:o,lineWidth:c}=t;!i&&!a||!o||!c||n<0||(r.save(),r.strokeStyle=o,r.lineWidth=c,r.setLineDash(s.dash||[]),r.lineDashOffset=s.dashOffset,r.beginPath(),Rl(e,n,i,a),r.closePath(),r.stroke(),r.restore())}(this,i,o,r,c)}}),n.display){for(e.save(),i=r-1;i>=0;i--){const a=n.setContext(this.getPointLabelContext(i)),{color:s,lineWidth:r}=a;r&&s&&(e.lineWidth=r,e.strokeStyle=s,e.setLineDash(a.borderDash),e.lineDashOffset=a.borderDashOffset,o=this.getDistanceFromCenterForValue(t.reverse?this.min:this.max),c=this.getPointPosition(i,o),e.beginPath(),e.moveTo(this.xCenter,this.yCenter),e.lineTo(c.x,c.y),e.stroke())}e.restore()}}drawBorder(){}drawLabels(){const e=this.ctx,t=this.options,n=t.ticks;if(!n.display)return;const a=this.getIndexAngle(0);let s,r;e.save(),e.translate(this.xCenter,this.yCenter),e.rotate(a),e.textAlign="center",e.textBaseline="middle",this.ticks.forEach((a,i)=>{if(0===i&&this.min>=0&&!t.reverse)return;const o=n.setContext(this.getContext(i)),c=hr(o.font);if(s=this.getDistanceFromCenterForValue(this.ticks[i].value),o.showLabelBackdrop){e.font=c.string,r=e.measureText(a.label).width,e.fillStyle=o.backdropColor;const t=ur(o.backdropPadding);e.fillRect(-r/2-t.left,-s-c.size/2-t.top,r+t.width,c.size+t.height)}tr(e,a.label,0,-s,c,{color:o.color,strokeColor:o.textStrokeColor,strokeWidth:o.textStrokeWidth})}),e.restore()}drawTitle(){}}On(_l,"id","radialLinear"),On(_l,"defaults",{display:!0,animate:!0,position:"chartArea",angleLines:{display:!0,lineWidth:1,borderDash:[],borderDashOffset:0},grid:{circular:!1},startAngle:0,ticks:{showLabelBackdrop:!0,callback:Os.formatters.numeric},pointLabels:{backdropColor:void 0,backdropPadding:2,display:!0,font:{size:10},callback:e=>e,padding:5,centerPointLabels:!1}}),On(_l,"defaultRoutes",{"angleLines.color":"borderColor","pointLabels.color":"color","ticks.color":"color"}),On(_l,"descriptors",{angleLines:{_fallback:"grid"}});const Al={millisecond:{common:!0,size:1,steps:1e3},second:{common:!0,size:1e3,steps:60},minute:{common:!0,size:6e4,steps:60},hour:{common:!0,size:36e5,steps:24},day:{common:!0,size:864e5,steps:30},week:{common:!1,size:6048e5,steps:4},month:{common:!0,size:2628e6,steps:12},quarter:{common:!1,size:7884e6,steps:4},year:{common:!0,size:3154e7}},Ml=Object.keys(Al);function Pl(e,t){return e-t}function Dl(e,t){if(xa(t))return null;const n=e._adapter,{parser:a,round:s,isoWeekday:r}=e._parseOpts;let i=t;return"function"===typeof a&&(i=a(i)),ka(i)||(i="string"===typeof a?n.parse(i,a):n.parse(i)),null===i?null:(s&&(i="week"!==s||!$a(r)&&!0!==r?n.startOf(i,s):n.startOf(i,"isoWeek",r)),+i)}function Ol(e,t,n,a){const s=Ml.length;for(let r=Ml.indexOf(e);r<s-1;++r){const e=Al[Ml[r]],s=e.steps?e.steps:Number.MAX_SAFE_INTEGER;if(e.common&&Math.ceil((n-t)/(s*e.size))<=a)return Ml[r]}return Ml[s-1]}function Fl(e,t,n){if(n){if(n.length){const{lo:a,hi:s}=hs(n,t);e[n[a]>=t?n[a]:n[s]]=!0}}else e[t]=!0}function Ll(e,t,n){const a=[],s={},r=t.length;let i,o;for(i=0;i<r;++i)o=t[i],s[o]=i,a.push({value:o,major:!1});return 0!==r&&n?function(e,t,n,a){const s=e._adapter,r=+s.startOf(t[0].value,a),i=t[t.length-1].value;let o,c;for(o=r;o<=i;o=+s.add(o,1,a))c=n[o],c>=0&&(t[c].major=!0);return t}(e,a,s,n):a}class zl extends Bo{constructor(e){super(e),this._cache={data:[],labels:[],all:[]},this._unit="day",this._majorUnit=void 0,this._offsets={},this._normalized=!1,this._parseOpts=void 0}init(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=e.time||(e.time={}),a=this._adapter=new Hi(e.adapters.date);a.init(t),Pa(n.displayFormats,a.formats()),this._parseOpts={parser:n.parser,round:n.round,isoWeekday:n.isoWeekday},super.init(e),this._normalized=t.normalized}parse(e,t){return void 0===e?null:Dl(this,e)}beforeLayout(){super.beforeLayout(),this._cache={data:[],labels:[],all:[]}}determineDataLimits(){const e=this.options,t=this._adapter,n=e.time.unit||"day";let{min:a,max:s,minDefined:r,maxDefined:i}=this.getUserBounds();function o(e){r||isNaN(e.min)||(a=Math.min(a,e.min)),i||isNaN(e.max)||(s=Math.max(s,e.max))}r&&i||(o(this._getLabelBounds()),"ticks"===e.bounds&&"labels"===e.ticks.source||o(this.getMinMax(!1))),a=ka(a)&&!isNaN(a)?a:+t.startOf(Date.now(),n),s=ka(s)&&!isNaN(s)?s:+t.endOf(Date.now(),n)+1,this.min=Math.min(a,s-1),this.max=Math.max(a+1,s)}_getLabelBounds(){const e=this.getLabelTimestamps();let t=Number.POSITIVE_INFINITY,n=Number.NEGATIVE_INFINITY;return e.length&&(t=e[0],n=e[e.length-1]),{min:t,max:n}}buildTicks(){const e=this.options,t=e.time,n=e.ticks,a="labels"===n.source?this.getLabelTimestamps():this._generate();"ticks"===e.bounds&&a.length&&(this.min=this._userMin||a[0],this.max=this._userMax||a[a.length-1]);const s=this.min,r=function(e,t,n){let a=0,s=e.length;for(;a<s&&e[a]<t;)a++;for(;s>a&&e[s-1]>n;)s--;return a>0||s<e.length?e.slice(a,s):e}(a,s,this.max);return this._unit=t.unit||(n.autoSkip?Ol(t.minUnit,this.min,this.max,this._getLabelCapacity(s)):function(e,t,n,a,s){for(let r=Ml.length-1;r>=Ml.indexOf(n);r--){const n=Ml[r];if(Al[n].common&&e._adapter.diff(s,a,n)>=t-1)return n}return Ml[n?Ml.indexOf(n):0]}(this,r.length,t.minUnit,this.min,this.max)),this._majorUnit=n.major.enabled&&"year"!==this._unit?function(e){for(let t=Ml.indexOf(e)+1,n=Ml.length;t<n;++t)if(Al[Ml[t]].common)return Ml[t]}(this._unit):void 0,this.initOffsets(a),e.reverse&&r.reverse(),Ll(this,r,this._majorUnit)}afterAutoSkip(){this.options.offsetAfterAutoskip&&this.initOffsets(this.ticks.map(e=>+e.value))}initOffsets(){let e,t,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],a=0,s=0;this.options.offset&&n.length&&(e=this.getDecimalForValue(n[0]),a=1===n.length?1-e:(this.getDecimalForValue(n[1])-e)/2,t=this.getDecimalForValue(n[n.length-1]),s=1===n.length?t:(t-this.getDecimalForValue(n[n.length-2]))/2);const r=n.length<3?.5:.25;a=ls(a,0,r),s=ls(s,0,r),this._offsets={start:a,end:s,factor:1/(a+1+s)}}_generate(){const e=this._adapter,t=this.min,n=this.max,a=this.options,s=a.time,r=s.unit||Ol(s.minUnit,t,n,this._getLabelCapacity(t)),i=Ca(a.ticks.stepSize,1),o="week"===r&&s.isoWeekday,c=$a(o)||!0===o,l={};let u,h,d=t;if(c&&(d=+e.startOf(d,"isoWeek",o)),d=+e.startOf(d,c?"day":r),e.diff(n,t,r)>1e5*i)throw new Error(t+" and "+n+" are too far apart with stepSize of "+i+" "+r);const p="data"===a.ticks.source&&this.getDataTimestamps();for(u=d,h=0;u<n;u=+e.add(u,i,r),h++)Fl(l,u,p);return u!==n&&"ticks"!==a.bounds&&1!==h||Fl(l,u,p),Object.keys(l).sort(Pl).map(e=>+e)}getLabelForValue(e){const t=this._adapter,n=this.options.time;return n.tooltipFormat?t.format(e,n.tooltipFormat):t.format(e,n.displayFormats.datetime)}format(e,t){const n=this.options.time.displayFormats,a=this._unit,s=t||n[a];return this._adapter.format(e,s)}_tickFormatFunction(e,t,n,a){const s=this.options,r=s.ticks.callback;if(r)return Na(r,[e,t,n],this);const i=s.time.displayFormats,o=this._unit,c=this._majorUnit,l=o&&i[o],u=c&&i[c],h=n[t],d=c&&u&&h&&h.major;return this._adapter.format(e,a||(d?u:l))}generateTickLabels(e){let t,n,a;for(t=0,n=e.length;t<n;++t)a=e[t],a.label=this._tickFormatFunction(a.value,t,e)}getDecimalForValue(e){return null===e?NaN:(e-this.min)/(this.max-this.min)}getPixelForValue(e){const t=this._offsets,n=this.getDecimalForValue(e);return this.getPixelForDecimal((t.start+n)*t.factor)}getValueForPixel(e){const t=this._offsets,n=this.getDecimalForPixel(e)/t.factor-t.end;return this.min+n*(this.max-this.min)}_getLabelSize(e){const t=this.options.ticks,n=this.ctx.measureText(e).width,a=ts(this.isHorizontal()?t.maxRotation:t.minRotation),s=Math.cos(a),r=Math.sin(a),i=this._resolveTickFontOptions(0).size;return{w:n*s+i*r,h:n*r+i*s}}_getLabelCapacity(e){const t=this.options.time,n=t.displayFormats,a=n[t.unit]||n.millisecond,s=this._tickFormatFunction(e,0,Ll(this,[e],this._majorUnit),a),r=this._getLabelSize(s),i=Math.floor(this.isHorizontal()?this.width/r.w:this.height/r.h)-1;return i>0?i:1}getDataTimestamps(){let e,t,n=this._cache.data||[];if(n.length)return n;const a=this.getMatchingVisibleMetas();if(this._normalized&&a.length)return this._cache.data=a[0].controller.getAllParsedValues(this);for(e=0,t=a.length;e<t;++e)n=n.concat(a[e].controller.getAllParsedValues(this));return this._cache.data=this.normalize(n)}getLabelTimestamps(){const e=this._cache.labels||[];let t,n;if(e.length)return e;const a=this.getLabels();for(t=0,n=a.length;t<n;++t)e.push(Dl(this,a[t]));return this._cache.labels=this._normalized?e:this.normalize(e)}normalize(e){return gs(e.sort(Pl))}}function Bl(e,t,n){let a,s,r,i,o=0,c=e.length-1;n?(t>=e[o].pos&&t<=e[c].pos&&({lo:o,hi:c}=ds(e,"pos",t)),({pos:a,time:r}=e[o]),({pos:s,time:i}=e[c])):(t>=e[o].time&&t<=e[c].time&&({lo:o,hi:c}=ds(e,"time",t)),({time:a,pos:r}=e[o]),({time:s,pos:i}=e[c]));const l=s-a;return l?r+(i-r)*(t-a)/l:r}On(zl,"id","time"),On(zl,"defaults",{bounds:"data",adapters:{},time:{parser:!1,unit:!1,round:!1,isoWeekday:!1,minUnit:"millisecond",displayFormats:{}},ticks:{source:"auto",callback:!1,major:{enabled:!1}}});class jl extends zl{constructor(e){super(e),this._table=[],this._minPos=void 0,this._tableRange=void 0}initOffsets(){const e=this._getTimestampsForTable(),t=this._table=this.buildLookupTable(e);this._minPos=Bl(t,this.min),this._tableRange=Bl(t,this.max)-this._minPos,super.initOffsets(e)}buildLookupTable(e){const{min:t,max:n}=this,a=[],s=[];let r,i,o,c,l;for(r=0,i=e.length;r<i;++r)c=e[r],c>=t&&c<=n&&a.push(c);if(a.length<2)return[{time:t,pos:0},{time:n,pos:1}];for(r=0,i=a.length;r<i;++r)l=a[r+1],o=a[r-1],c=a[r],Math.round((l+o)/2)!==c&&s.push({time:c,pos:r/(i-1)});return s}_generate(){const e=this.min,t=this.max;let n=super.getDataTimestamps();return n.includes(e)&&n.length||n.splice(0,0,e),n.includes(t)&&1!==n.length||n.push(t),n.sort((e,t)=>e-t)}_getTimestampsForTable(){let e=this._cache.all||[];if(e.length)return e;const t=this.getDataTimestamps(),n=this.getLabelTimestamps();return e=t.length&&n.length?this.normalize(t.concat(n)):t.length?t:n,e=this._cache.all=e,e}getDecimalForValue(e){return(Bl(this._table,e)-this._minPos)/this._tableRange}getValueForPixel(e){const t=this._offsets,n=this.getDecimalForPixel(e)/t.factor-t.end;return Bl(this._table,n*this._tableRange+this._minPos,!0)}}On(jl,"id","timeseries"),On(jl,"defaults",zl.defaults);const Wl=["height","width","redraw","datasetIdKey","type","data","options","plugins","fallbackContent","updateMode"],Vl="label";function Ul(e,t){"function"===typeof e?e(t):e&&(e.current=t)}function Hl(e,t){e.labels=t}function Gl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Vl;const a=[];e.datasets=t.map(t=>{const s=e.datasets.find(e=>e[n]===t[n]);return s&&t.data&&!a.includes(s)?(a.push(s),Object.assign(s,t),s):Ln({},t)})}function ql(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Vl;const n={labels:[],datasets:[]};return Hl(n,e.labels),Gl(n,e.datasets,t),n}function Kl(e,t){const{height:n=150,width:a=300,redraw:s=!1,datasetIdKey:r,type:i,data:o,options:c,plugins:l=[],fallbackContent:u,updateMode:h}=e,d=function(e,t){if(null==e)return{};var n,a,s=function(e,t){if(null==e)return{};var n={};for(var a in e)if({}.hasOwnProperty.call(e,a)){if(-1!==t.indexOf(a))continue;n[a]=e[a]}return n}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],-1===t.indexOf(n)&&{}.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}(e,Wl),p=(0,E.useRef)(null),f=(0,E.useRef)(null),m=()=>{p.current&&(f.current=new gc(p.current,{type:i,data:ql(o,r),options:c&&Ln({},c),plugins:l}),Ul(t,f.current))},g=()=>{Ul(t,null),f.current&&(f.current.destroy(),f.current=null)};return(0,E.useEffect)(()=>{!s&&f.current&&c&&function(e,t){const n=e.options;n&&t&&Object.assign(n,t)}(f.current,c)},[s,c]),(0,E.useEffect)(()=>{!s&&f.current&&Hl(f.current.config.data,o.labels)},[s,o.labels]),(0,E.useEffect)(()=>{!s&&f.current&&o.datasets&&Gl(f.current.config.data,o.datasets,r)},[s,o.datasets]),(0,E.useEffect)(()=>{f.current&&(s?(g(),setTimeout(m)):f.current.update(h))},[s,c,o.labels,o.datasets,h]),(0,E.useEffect)(()=>{f.current&&(g(),setTimeout(m))},[i]),(0,E.useEffect)(()=>(m(),()=>g()),[]),(0,vn.jsx)("canvas",Ln(Ln({ref:p,role:"img",height:n,width:a},d),{},{children:u}))}const Xl=(0,E.forwardRef)(Kl);function Yl(e,t){return gc.register(t),(0,E.forwardRef)((t,n)=>(0,vn.jsx)(Xl,Ln(Ln({},t),{},{ref:n,type:e})))}const Ql=Yl("line",Li),Zl=Yl("bar",Di),Jl=Yl("doughnut",Fi);gc.register(ul,fl,jc,Ac,Pc,kc,qc,ol,Hc);const $l=()=>{const e={responsive:!0,maintainAspectRatio:!1,plugins:{legend:{position:"bottom"}}},t=[{type:"success",icon:(0,vn.jsx)(Pt,{}),title:"High Detection Accuracy",description:"The system achieves 90%+ accuracy for most standard yoga poses when proper lighting and positioning are maintained."},{type:"success",icon:(0,vn.jsx)(Pt,{}),title:"Real-time Processing",description:"Pose detection runs at 30+ FPS, providing smooth real-time feedback without noticeable lag."},{type:"warning",icon:(0,vn.jsx)(Gt,{}),title:"Similar Pose Confusion",description:"Some poses with similar body positions may occasionally be confused, particularly intermediate poses."},{type:"success",icon:(0,vn.jsx)(Pt,{}),title:"Progressive Improvement",description:"Model accuracy improves with additional training data and user feedback integration."}];return(0,vn.jsxs)("div",{className:"results-page",children:[(0,vn.jsx)("section",{className:"page-hero",children:(0,vn.jsxs)("div",{className:"container",children:[(0,vn.jsx)("span",{className:"page-label",children:"Performance"}),(0,vn.jsx)("h1",{children:"Results & Analysis"}),(0,vn.jsx)("p",{children:"Detailed performance metrics and accuracy analysis of our AI-powered yoga pose detection system."})]})}),(0,vn.jsx)("section",{className:"section metrics-section",children:(0,vn.jsx)("div",{className:"container",children:(0,vn.jsx)("div",{className:"metrics-grid",children:[{label:"Overall Accuracy",value:"91.5%",color:"#a177b4"},{label:"Precision",value:"94%",color:"#9fc5a7"},{label:"Recall",value:"91%",color:"#f39c12"},{label:"F1-Score",value:"92.5%",color:"#3498db"}].map((e,t)=>(0,vn.jsxs)("div",{className:"metric-card",children:[(0,vn.jsx)("div",{className:"metric-value",style:{color:e.color},children:e.value}),(0,vn.jsx)("div",{className:"metric-label",children:e.label})]},t))})})}),(0,vn.jsx)("section",{className:"section charts-section gradient-bg-light",children:(0,vn.jsxs)("div",{className:"container",children:[(0,vn.jsxs)("div",{className:"section-title",children:[(0,vn.jsx)("span",{children:"Visual Analytics"}),(0,vn.jsx)("h2",{children:"Performance Charts"})]}),(0,vn.jsxs)("div",{className:"charts-grid",children:[(0,vn.jsxs)("div",{className:"chart-container",children:[(0,vn.jsx)("h3",{children:"Accuracy by Pose Type"}),(0,vn.jsx)("div",{className:"chart-wrapper",children:(0,vn.jsx)(Zl,{data:{labels:["Tadasana","Vrikshasana","Trikonasana","Bhujangasana","Vajrasana","Padmasana"],datasets:[{label:"Detection Accuracy (%)",data:[95,92,88,94,90,86],backgroundColor:"rgba(161, 119, 180, 0.6)",borderColor:"rgba(161, 119, 180, 1)",borderWidth:2,borderRadius:8}]},options:e})})]}),(0,vn.jsxs)("div",{className:"chart-container",children:[(0,vn.jsx)("h3",{children:"Model Performance Metrics"}),(0,vn.jsx)("div",{className:"chart-wrapper doughnut",children:(0,vn.jsx)(Jl,{data:{labels:["Precision","Recall","F1-Score"],datasets:[{data:[94,91,92.5],backgroundColor:["rgba(161, 119, 180, 0.8)","rgba(159, 197, 167, 0.8)","rgba(243, 156, 18, 0.8)"],borderWidth:0}]},options:e})})]})]}),(0,vn.jsxs)("div",{className:"chart-container full-width",children:[(0,vn.jsx)("h3",{children:"Accuracy Improvement Over Time"}),(0,vn.jsx)("div",{className:"chart-wrapper",children:(0,vn.jsx)(Ql,{data:{labels:["Week 1","Week 2","Week 3","Week 4","Week 5","Week 6"],datasets:[{label:"Average Accuracy",data:[75,80,85,88,91,93],borderColor:"rgba(161, 119, 180, 1)",backgroundColor:"rgba(161, 119, 180, 0.2)",tension:.4,fill:!0}]},options:e})})]})]})}),(0,vn.jsx)("section",{className:"section explanation-section",children:(0,vn.jsx)("div",{className:"container",children:(0,vn.jsxs)("div",{className:"explanation-grid",children:[(0,vn.jsxs)("div",{className:"explanation-card",children:[(0,vn.jsx)("h3",{children:"Precision"}),(0,vn.jsx)("p",{children:"Precision measures how many of the poses the system identified as correct were actually correct. Our 94% precision means that when the system says you're doing a pose correctly, it's right 94% of the time."}),(0,vn.jsx)("div",{className:"formula",children:"Precision = True Positives / (True Positives + False Positives)"})]}),(0,vn.jsxs)("div",{className:"explanation-card",children:[(0,vn.jsx)("h3",{children:"Recall"}),(0,vn.jsx)("p",{children:"Recall measures how many of the actual correct poses were successfully identified by the system. Our 91% recall means the system catches 91% of all correct pose attempts."}),(0,vn.jsx)("div",{className:"formula",children:"Recall = True Positives / (True Positives + False Negatives)"})]}),(0,vn.jsxs)("div",{className:"explanation-card",children:[(0,vn.jsx)("h3",{children:"F1-Score"}),(0,vn.jsx)("p",{children:"The F1-Score is the harmonic mean of precision and recall, providing a single metric that balances both. Our 92.5% F1-Score indicates excellent overall model performance."}),(0,vn.jsx)("div",{className:"formula",children:"F1 = 2 \xd7 (Precision \xd7 Recall) / (Precision + Recall)"})]})]})})}),(0,vn.jsx)("section",{className:"section observations-section",children:(0,vn.jsxs)("div",{className:"container",children:[(0,vn.jsxs)("div",{className:"section-title",children:[(0,vn.jsx)("span",{children:"Key Insights"}),(0,vn.jsx)("h2",{children:"Observations"})]}),(0,vn.jsx)("div",{className:"observations-grid",children:t.map((e,t)=>(0,vn.jsxs)("div",{className:"observation-card ".concat(e.type),children:[(0,vn.jsx)("div",{className:"observation-icon",children:e.icon}),(0,vn.jsxs)("div",{className:"observation-content",children:[(0,vn.jsx)("h4",{children:e.title}),(0,vn.jsx)("p",{children:e.description})]})]},t))})]})}),(0,vn.jsx)("section",{className:"section improvements-section gradient-bg-light",children:(0,vn.jsxs)("div",{className:"container",children:[(0,vn.jsxs)("div",{className:"section-title",children:[(0,vn.jsx)("span",{children:"Roadmap"}),(0,vn.jsx)("h2",{children:"Future Improvements"})]}),(0,vn.jsxs)("div",{className:"improvements-grid",children:[(0,vn.jsxs)("div",{className:"improvement-item",children:[(0,vn.jsx)(Mt,{}),(0,vn.jsx)("h4",{children:"More Poses"}),(0,vn.jsx)("p",{children:"Expanding the library to include 50+ yoga poses"})]}),(0,vn.jsxs)("div",{className:"improvement-item",children:[(0,vn.jsx)(Mt,{}),(0,vn.jsx)("h4",{children:"Better Accuracy"}),(0,vn.jsx)("p",{children:"Training on larger datasets for improved detection"})]}),(0,vn.jsxs)("div",{className:"improvement-item",children:[(0,vn.jsx)(Mt,{}),(0,vn.jsx)("h4",{children:"Voice Guidance"}),(0,vn.jsx)("p",{children:"Adding audio instructions and real-time voice feedback"})]}),(0,vn.jsxs)("div",{className:"improvement-item",children:[(0,vn.jsx)(Mt,{}),(0,vn.jsx)("h4",{children:"Progress Tracking"}),(0,vn.jsx)("p",{children:"Personal analytics and improvement tracking over time"})]})]})]})})]})},eu=()=>{const e="Your College Name",t="Department of Computer Science",n="College Address, City, State - PIN",a="2024-2025";return(0,vn.jsxs)("div",{className:"team-page",children:[(0,vn.jsx)("section",{className:"page-hero",children:(0,vn.jsxs)("div",{className:"container",children:[(0,vn.jsx)("span",{className:"page-label",children:"Meet Our"}),(0,vn.jsx)("h1",{children:"Development Team"}),(0,vn.jsx)("p",{children:"The talented individuals behind the YogaGuru AI-powered yoga pose detection platform."})]})}),(0,vn.jsx)("section",{className:"section team-section",children:(0,vn.jsxs)("div",{className:"container",children:[(0,vn.jsxs)("div",{className:"section-title",children:[(0,vn.jsx)("span",{children:"Students"}),(0,vn.jsx)("h2",{children:"Our Team"})]}),(0,vn.jsx)("div",{className:"team-grid",children:[{name:"Keraliya Kaushal",role:"Project Lead",department:"Computer Science",image:"/TeamImage/Kaushal.png",description:"Responsible for project management, system architecture, and frontend development.",links:{github:"https://github.com/Kaushal187-Patel",linkedin:"https://www.linkedin.com/in/keraliya-kaushal-2bb578273",email:"kaushal151131@email.com"}},{name:"Mankad Drashti",role:"ML Developer",department:"Computer Science",image:"/TeamImage/drashti.jpg",description:"Specialized in machine learning model development and pose estimation algorithms.",links:{github:"https://github.com",linkedin:"https://linkedin.com",email:"student2@email.com"}}].map((e,t)=>(0,vn.jsxs)("div",{className:"team-card",children:[(0,vn.jsx)("div",{className:"member-image",children:(0,vn.jsx)("img",{src:e.image,alt:e.name})}),(0,vn.jsxs)("div",{className:"member-info",children:[(0,vn.jsx)("h3",{children:e.name}),(0,vn.jsx)("span",{className:"role",children:e.role}),(0,vn.jsx)("span",{className:"department",children:e.department}),(0,vn.jsx)("p",{children:e.description}),(0,vn.jsxs)("div",{className:"member-links",children:[e.links.github&&(0,vn.jsx)("a",{href:e.links.github,target:"_blank",rel:"noopener noreferrer",children:(0,vn.jsx)(pt,{})}),e.links.linkedin&&(0,vn.jsx)("a",{href:e.links.linkedin,target:"_blank",rel:"noopener noreferrer",children:(0,vn.jsx)(bt,{})}),e.links.email&&(0,vn.jsx)("a",{href:"mailto:".concat(e.links.email),children:(0,vn.jsx)(Ht,{})})]})]})]},t))})]})}),(0,vn.jsx)("section",{className:"section college-section",children:(0,vn.jsx)("div",{className:"container",children:(0,vn.jsxs)("div",{className:"college-card",children:[(0,vn.jsx)("h2",{children:e}),(0,vn.jsx)("p",{className:"department",children:t}),(0,vn.jsx)("p",{className:"address",children:n}),(0,vn.jsxs)("p",{className:"year",children:["Academic Year: ",a]})]})})}),(0,vn.jsx)("section",{className:"section acknowledgments-section gradient-bg-light",children:(0,vn.jsxs)("div",{className:"container",children:[(0,vn.jsx)("div",{className:"section-title",children:(0,vn.jsx)("h2",{children:"Acknowledgments"})}),(0,vn.jsxs)("div",{className:"acknowledgment-content",children:[(0,vn.jsx)("p",{children:"We extend our sincere gratitude to our project guide for their invaluable guidance and support throughout the development of this project. We also thank our college and department for providing the necessary resources and infrastructure to bring this project to fruition."}),(0,vn.jsx)("p",{children:"Special thanks to the open-source community for their contributions to TensorFlow, MediaPipe, and other technologies that made this project possible."})]})]})})]})},tu=()=>{const[e,t]=(0,E.useState)({name:"",email:"",subject:"",message:""}),[n,a]=(0,E.useState)(!1),[s,r]=(0,E.useState)(!1),i=[{icon:(0,vn.jsx)(Ht,{}),title:"Email",details:"contact@yogaguru.com",link:"mailto:contact@yogaguru.com"},{icon:(0,vn.jsx)(rn,{}),title:"Phone",details:"+91 92653 00000",link:"tel:+919265300000"},{icon:(0,vn.jsx)(nn,{}),title:"Address",details:"Your College Name, City, State - PIN",link:null}],o=e=>{const{name:n,value:a}=e.target;t(e=>Ln(Ln({},e),{},{[n]:a}))};return(0,vn.jsxs)("div",{className:"contact-page",children:[(0,vn.jsx)("section",{className:"page-hero",children:(0,vn.jsxs)("div",{className:"container",children:[(0,vn.jsx)("span",{className:"page-label",children:"Get In Touch"}),(0,vn.jsx)("h1",{children:"Contact Us"}),(0,vn.jsx)("p",{children:"Have questions about YogaGuru? We'd love to hear from you. Send us a message and we'll respond as soon as possible."})]})}),(0,vn.jsx)("section",{className:"section contact-section",children:(0,vn.jsx)("div",{className:"container",children:(0,vn.jsxs)("div",{className:"contact-grid",children:[(0,vn.jsxs)("div",{className:"contact-form-wrapper",children:[(0,vn.jsx)("h2",{children:"Send us a Message"}),n?(0,vn.jsxs)("div",{className:"success-message",children:[(0,vn.jsx)(Pt,{}),(0,vn.jsx)("h3",{children:"Thank You!"}),(0,vn.jsx)("p",{children:"Your message has been sent successfully. We'll get back to you soon."})]}):(0,vn.jsxs)("form",{onSubmit:async e=>{e.preventDefault(),r(!0),await new Promise(e=>setTimeout(e,1500)),r(!1),a(!0),t({name:"",email:"",subject:"",message:""}),setTimeout(()=>a(!1),5e3)},className:"contact-form",children:[(0,vn.jsxs)("div",{className:"form-row",children:[(0,vn.jsxs)("div",{className:"form-group",children:[(0,vn.jsx)("label",{htmlFor:"name",children:"Your Name"}),(0,vn.jsx)("input",{type:"text",id:"name",name:"name",value:e.name,onChange:o,placeholder:"John Doe",required:!0})]}),(0,vn.jsxs)("div",{className:"form-group",children:[(0,vn.jsx)("label",{htmlFor:"email",children:"Email Address"}),(0,vn.jsx)("input",{type:"email",id:"email",name:"email",value:e.email,onChange:o,placeholder:"john@example.com",required:!0})]})]}),(0,vn.jsxs)("div",{className:"form-group",children:[(0,vn.jsx)("label",{htmlFor:"subject",children:"Subject"}),(0,vn.jsx)("input",{type:"text",id:"subject",name:"subject",value:e.subject,onChange:o,placeholder:"How can we help?",required:!0})]}),(0,vn.jsxs)("div",{className:"form-group",children:[(0,vn.jsx)("label",{htmlFor:"message",children:"Message"}),(0,vn.jsx)("textarea",{id:"message",name:"message",value:e.message,onChange:o,placeholder:"Tell us more about your inquiry...",rows:"5",required:!0})]}),(0,vn.jsx)("button",{type:"submit",className:"btn btn-primary submit-btn",disabled:s,children:s?"Sending...":(0,vn.jsxs)(vn.Fragment,{children:[(0,vn.jsx)(sn,{})," Send Message"]})})]})]}),(0,vn.jsxs)("div",{className:"contact-info-wrapper",children:[(0,vn.jsx)("h2",{children:"Contact Information"}),(0,vn.jsx)("p",{children:"Reach out to us through any of the following channels. We're here to help with any questions about our AI yoga pose detection platform."}),(0,vn.jsx)("div",{className:"contact-cards",children:i.map((e,t)=>(0,vn.jsxs)("div",{className:"contact-card",children:[(0,vn.jsx)("div",{className:"contact-icon",children:e.icon}),(0,vn.jsxs)("div",{className:"contact-details",children:[(0,vn.jsx)("h4",{children:e.title}),e.link?(0,vn.jsx)("a",{href:e.link,children:e.details}):(0,vn.jsx)("p",{children:e.details})]})]},t))}),(0,vn.jsx)("div",{className:"map-container",children:(0,vn.jsxs)("div",{className:"map-placeholder",children:[(0,vn.jsx)(nn,{}),(0,vn.jsx)("p",{children:"Map View"}),(0,vn.jsx)("span",{children:"Your College Location"})]})})]})]})})}),(0,vn.jsx)("section",{className:"section faq-cta gradient-bg-light",children:(0,vn.jsxs)("div",{className:"container text-center",children:[(0,vn.jsx)("h2",{children:"Frequently Asked Questions"}),(0,vn.jsx)("p",{children:"Check out our FAQ section for quick answers to common questions."}),(0,vn.jsx)("a",{href:"/#faq",className:"btn btn-primary",children:"View FAQs"})]})})]})},nu=e=>{let{isOpen:t,onClose:n,message:a,title:s="Success!"}=e;return t?(0,vn.jsx)("div",{className:"success-modal-overlay",onClick:n,children:(0,vn.jsxs)("div",{className:"success-modal-content",onClick:e=>e.stopPropagation(),children:[(0,vn.jsx)("button",{className:"success-modal-close",onClick:n,children:(0,vn.jsx)(mn,{})}),(0,vn.jsx)("div",{className:"success-modal-icon",children:(0,vn.jsx)(Pt,{})}),(0,vn.jsx)("h2",{className:"success-modal-title",children:s}),(0,vn.jsx)("p",{className:"success-modal-message",children:a})]})}):null},au={NODE_ENV:"production",PUBLIC_URL:"",WDS_SOCKET_HOST:void 0,WDS_SOCKET_PATH:void 0,WDS_SOCKET_PORT:void 0,FAST_REFRESH:!0}.REACT_APP_API_URL||"http://localhost:5000/api",su=()=>{const e=Re(),[t,n]=(0,E.useState)(!0),[a,s]=(0,E.useState)(!1),[r,i]=(0,E.useState)(!1),[o,c]=(0,E.useState)(""),[l,u]=(0,E.useState)(!1),[h,d]=(0,E.useState)(""),[p,f]=(0,E.useState)({name:"",email:"",password:"",confirmPassword:""}),[m,g]=(0,E.useState)({}),y=e=>{const{name:t,value:n}=e.target;f(e=>Ln(Ln({},e),{},{[t]:n})),m[t]&&g(e=>Ln(Ln({},e),{},{[t]:""}))},b=()=>{n(!t),f({name:"",email:"",password:"",confirmPassword:""}),g({})};return(0,vn.jsxs)("div",{className:"auth-page",children:[(0,vn.jsx)("div",{className:"auth-container",children:(0,vn.jsxs)("div",{className:"auth-card",children:[(0,vn.jsxs)("div",{className:"auth-header",children:[(0,vn.jsx)(tt,{to:"/",className:"auth-logo",children:"YogaGuru"}),(0,vn.jsx)("h1",{children:t?"Welcome Back":"Create Account"}),(0,vn.jsx)("p",{children:t?"Sign in to continue your yoga journey":"Start your AI-powered yoga practice today"})]}),(0,vn.jsxs)("div",{className:"auth-tabs",children:[(0,vn.jsx)("button",{className:"auth-tab ".concat(t?"active":""),onClick:()=>b(),children:"Login"}),(0,vn.jsx)("button",{className:"auth-tab ".concat(t?"":"active"),onClick:()=>b(),children:"Sign Up"})]}),(0,vn.jsxs)("form",{onSubmit:async n=>{if(n.preventDefault(),c(""),(()=>{const e={};return t||p.name.trim()||(e.name="Name is required"),p.email.trim()?/\S+@\S+\.\S+/.test(p.email)||(e.email="Invalid email format"):e.email="Email is required",p.password?p.password.length<6&&(e.password="Password must be at least 6 characters"):e.password="Password is required",t||p.password===p.confirmPassword||(e.confirmPassword="Passwords do not match"),g(e),0===Object.keys(e).length})()){i(!0);try{const n=t?"/auth/login":"/auth/register",a=t?{email:p.email,password:p.password}:{name:p.name,email:p.email,password:p.password},s=await fetch("".concat(au).concat(n),{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(a)}),r=await s.json();if(!s.ok)throw new Error(r.error||"Something went wrong");r.token&&(localStorage.setItem("token",r.token),localStorage.setItem("user",JSON.stringify(r.user))),f({name:"",email:"",password:"",confirmPassword:""}),g({}),t?(alert("Login successful! Welcome back!"),setTimeout(()=>{e("/"),window.location.reload()},500)):(d("Congratulations ".concat(r.user.name,"! Your account has been created successfully. You are now logged in.")),u(!0),setTimeout(()=>{u(!1),e("/profile"),window.location.reload()},3e3))}catch(a){console.error("Auth error:",a),c(a.message||"An error occurred. Please try again.")}finally{i(!1)}}},className:"auth-form",children:[!t&&(0,vn.jsxs)("div",{className:"form-group",children:[(0,vn.jsx)("label",{htmlFor:"name",children:"Full Name"}),(0,vn.jsxs)("div",{className:"input-wrapper",children:[(0,vn.jsx)(bn,{className:"input-icon"}),(0,vn.jsx)("input",{type:"text",id:"name",name:"name",value:p.name,onChange:y,placeholder:"John Doe",className:m.name?"error":""})]}),m.name&&(0,vn.jsx)("span",{className:"error-text",children:m.name})]}),(0,vn.jsxs)("div",{className:"form-group",children:[(0,vn.jsx)("label",{htmlFor:"email",children:"Email Address"}),(0,vn.jsxs)("div",{className:"input-wrapper",children:[(0,vn.jsx)(Ht,{className:"input-icon"}),(0,vn.jsx)("input",{type:"email",id:"email",name:"email",value:p.email,onChange:y,placeholder:"john@example.com",className:m.email?"error":""})]}),m.email&&(0,vn.jsx)("span",{className:"error-text",children:m.email})]}),(0,vn.jsxs)("div",{className:"form-group",children:[(0,vn.jsx)("label",{htmlFor:"password",children:"Password"}),(0,vn.jsxs)("div",{className:"input-wrapper",children:[(0,vn.jsx)(tn,{className:"input-icon"}),(0,vn.jsx)("input",{type:a?"text":"password",id:"password",name:"password",value:p.password,onChange:y,placeholder:"\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022",className:m.password?"error":""}),(0,vn.jsx)("button",{type:"button",className:"toggle-password",onClick:()=>s(!a),children:a?(0,vn.jsx)(Kt,{}):(0,vn.jsx)(Xt,{})})]}),m.password&&(0,vn.jsx)("span",{className:"error-text",children:m.password})]}),!t&&(0,vn.jsxs)("div",{className:"form-group",children:[(0,vn.jsx)("label",{htmlFor:"confirmPassword",children:"Confirm Password"}),(0,vn.jsxs)("div",{className:"input-wrapper",children:[(0,vn.jsx)(tn,{className:"input-icon"}),(0,vn.jsx)("input",{type:a?"text":"password",id:"confirmPassword",name:"confirmPassword",value:p.confirmPassword,onChange:y,placeholder:"\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022",className:m.confirmPassword?"error":""})]}),m.confirmPassword&&(0,vn.jsx)("span",{className:"error-text",children:m.confirmPassword})]}),t&&(0,vn.jsxs)("div",{className:"form-options",children:[(0,vn.jsxs)("label",{className:"remember-me",children:[(0,vn.jsx)("input",{type:"checkbox"}),(0,vn.jsx)("span",{children:"Remember me"})]}),(0,vn.jsx)("a",{href:"#forgot",className:"forgot-password",children:"Forgot Password?"})]}),o&&(0,vn.jsx)("div",{className:"server-error",style:{color:"#e74c3c",marginBottom:"1rem",padding:"0.75rem",backgroundColor:"#fee",borderRadius:"4px",fontSize:"0.9rem"},children:o}),(0,vn.jsx)("button",{type:"submit",className:"btn btn-primary submit-btn",disabled:r,children:r?t?"Signing In...":"Creating Account...":t?"Sign In":"Create Account"})]}),(0,vn.jsx)("div",{className:"auth-divider",children:(0,vn.jsx)("span",{children:"or continue with"})}),(0,vn.jsxs)("div",{className:"social-auth",children:[(0,vn.jsxs)("button",{className:"social-btn google",children:[(0,vn.jsx)(ft,{})," Google"]}),(0,vn.jsxs)("button",{className:"social-btn facebook",children:[(0,vn.jsx)(dt,{})," Facebook"]})]}),(0,vn.jsxs)("p",{className:"auth-footer",children:[t?"Don't have an account? ":"Already have an account? ",(0,vn.jsx)("button",{type:"button",onClick:b,className:"switch-mode",children:t?"Sign Up":"Sign In"})]})]})}),(0,vn.jsx)(nu,{isOpen:l,onClose:()=>{u(!1),e("/profile"),window.location.reload()},title:"\ud83c\udf89 Account Created Successfully!",message:h})]})},ru=()=>{const e=Re(),[t,n]=(0,E.useState)(null),[a,s]=(0,E.useState)(!1),[r,i]=(0,E.useState)(""),[o,c]=(0,E.useState)(!1),[l,u]=(0,E.useState)("");(0,E.useEffect)(()=>{const t=localStorage.getItem("user");if(localStorage.getItem("token")&&t)try{const e=JSON.parse(t);n(e),i(e.name)}catch(l){console.error("Error parsing user data:",l),e("/login")}else e("/login")},[e]);if(!t)return(0,vn.jsx)("div",{className:"profile-page",children:(0,vn.jsx)("div",{className:"profile-loading",children:"Loading..."})});return(0,vn.jsx)("div",{className:"profile-page",children:(0,vn.jsxs)("div",{className:"profile-container",children:[(0,vn.jsxs)("div",{className:"profile-header",children:[(0,vn.jsx)("div",{className:"profile-avatar",children:(0,vn.jsx)(bn,{})}),(0,vn.jsx)("h1",{children:"My Profile"})]}),(0,vn.jsxs)("div",{className:"profile-content",children:[(0,vn.jsxs)("div",{className:"profile-card",children:[(0,vn.jsxs)("div",{className:"profile-card-header",children:[(0,vn.jsx)("h2",{children:"Personal Information"}),a?(0,vn.jsxs)("div",{className:"edit-actions",children:[(0,vn.jsxs)("button",{className:"btn-save",onClick:async()=>{if(r.trim()){c(!0),u("");try{const e=localStorage.getItem("token"),a=await fetch("".concat(au,"/users/profile"),{method:"PUT",headers:{"Content-Type":"application/json",Authorization:"Bearer ".concat(e)},body:JSON.stringify({name:r})}),i=await a.json();if(!a.ok)throw new Error(i.error||"Failed to update profile");const o=Ln(Ln({},t),{},{name:r});localStorage.setItem("user",JSON.stringify(o)),n(o),s(!1),alert("Profile updated successfully!")}catch(l){console.error("Update error:",l),u(l.message||"Failed to update profile")}finally{c(!1)}}else u("Name cannot be empty")},disabled:o,children:[(0,vn.jsx)(un,{})," ",o?"Saving...":"Save"]}),(0,vn.jsxs)("button",{className:"btn-cancel",onClick:()=>{s(!1),i(t.name),u("")},children:[(0,vn.jsx)(mn,{})," Cancel"]})]}):(0,vn.jsxs)("button",{className:"btn-edit",onClick:()=>s(!0),children:[(0,vn.jsx)(Ut,{})," Edit"]})]}),l&&(0,vn.jsx)("div",{className:"profile-error",children:l}),(0,vn.jsxs)("div",{className:"profile-info",children:[(0,vn.jsxs)("div",{className:"info-item",children:[(0,vn.jsxs)("label",{children:[(0,vn.jsx)(bn,{})," Full Name"]}),a?(0,vn.jsx)("input",{type:"text",value:r,onChange:e=>i(e.target.value),className:"profile-input"}):(0,vn.jsx)("span",{children:t.name})]}),(0,vn.jsxs)("div",{className:"info-item",children:[(0,vn.jsxs)("label",{children:[(0,vn.jsx)(Ht,{})," Email Address"]}),(0,vn.jsx)("span",{children:t.email})]}),(0,vn.jsxs)("div",{className:"info-item",children:[(0,vn.jsxs)("label",{children:[(0,vn.jsx)(Rt,{})," Member Since"]}),(0,vn.jsx)("span",{children:(e=>{if(!e)return"N/A";return new Date(e).toLocaleDateString("en-US",{year:"numeric",month:"long",day:"numeric"})})(t.created_at||t.createdAt)})]})]})]}),(0,vn.jsx)("div",{className:"profile-actions",children:(0,vn.jsxs)("button",{className:"btn-logout",onClick:()=>{localStorage.removeItem("token"),localStorage.removeItem("user"),e("/"),window.location.reload()},children:[(0,vn.jsx)(dn,{})," Logout"]})})]})]})})},iu=()=>{const{categoryId:e}=function(){let{matches:e}=E.useContext(Ce),t=e[e.length-1];return t?t.params:{}}(),t=Te(),n=Re(),[a,s]=(0,E.useState)(null),[r,i]=(0,E.useState)(null),o=(e,t)=>{var n,a,s;const r="/pose-images/pose-".concat(e,".jpg"),i={Tadasana:"https://images.unsplash.com/photo-1545389336-cf090694435e?w=400&h=300&fit=crop&auto=format",Vrikshasana:"https://images.unsplash.com/photo-1758274525911-402f99afec14?w=600&h=400&fit=crop&auto=format&q=80",Trikonasana:"https://images.unsplash.com/photo-1767611090899-163209a4ead1?w=600&h=400&fit=crop&auto=format&q=80",Bhujangasana:"https://images.unsplash.com/photo-1717821552922-61e18814a44a?w=600&h=400&fit=crop&auto=format&q=80","Setu Bandhasana":"https://images.unsplash.com/photo-1767611086180-6b1176976371?w=600&h=400&fit=crop&auto=format&q=80",Virabhadrasana:r,Anjaneyasana:r,Paschimottanasana:r,"Ardha Matsyendrasana":r,Gomukhasana:r,Garudasana:r,"Supta Padangusthasana":r,Marjariasana:"https://images.unsplash.com/photo-1758599881262-7b79a56ac284?w=600&h=400&fit=crop&auto=format&q=80","Adho Mukha Svanasana":"https://images.unsplash.com/photo-1767611121194-3cb554c9a9ec?w=600&h=400&fit=crop&auto=format&q=80","Surya Namaskar":"https://images.unsplash.com/photo-1606663368493-131f4f97c095?w=600&h=400&fit=crop&auto=format&q=80",Balasana:"https://images.unsplash.com/photo-1767611118672-d3887038786c?w=600&h=400&fit=crop&auto=format&q=80",Padmasana:"https://images.unsplash.com/photo-1577344718665-3e7c0c1ecf6b?w=600&h=400&fit=crop&auto=format&q=80",Vajrasana:"https://images.unsplash.com/photo-1697274834392-04ff3b76ef20?w=600&h=400&fit=crop&auto=format&q=80",Pavanamuktasana:"https://images.unsplash.com/photo-1506126613408-eca07ce68773?w=400&h=300&fit=crop&auto=format",Uttanasana:"https://images.unsplash.com/photo-1506126613408-eca07ce68773?w=400&h=300&fit=crop&auto=format","Viparita Karani":"https://images.unsplash.com/photo-1506126613408-eca07ce68773?w=400&h=300&fit=crop&auto=format"};if(i[t])return i[t];const o=((null===(n=t.split("(")[1])||void 0===n||null===(a=n.split(")")[0])||void 0===a?void 0:a.trim())||(null===(s=t.split("-")[1])||void 0===s?void 0:s.trim())||"yoga pose").toLowerCase().replace(/\s+/g,"%20").replace(/[^a-z0-9%]/g,"");return"https://source.unsplash.com/400x300/?yoga%20".concat(o,"&sig=").concat(e)},c={"pain-relief":[{id:1,name:"\u0aad\u0ac1\u0a9c\u0a82\u0a97\u0abe\u0ab8\u0aa8 (Bhujangasana) - Cobra Pose",image:o(1,"Bhujangasana"),description:"A gentle backbend that strengthens the spine and opens the chest. This pose helps relieve back pain by stretching the front body and strengthening the back muscles.",advantages:["Relieves lower back pain","Strengthens the spine","Opens the chest and shoulders","Improves posture","Stretches abdominal muscles","Stimulates abdominal organs"],disadvantages:["Not suitable for severe back injuries","Avoid during pregnancy","May cause strain if done incorrectly","Can worsen carpal tunnel syndrome"],difficulty:"Beginner",duration:"30-60 seconds",subCategories:["Back Pain","Spine Health"]},{id:2,name:"\u0ab5\u0ac0\u0ab0\u0aad\u0aa6\u0acd\u0ab0\u0abe\u0ab8\u0aa8 II (Virabhadrasana II) - Warrior II",image:o(2,"Virabhadrasana"),description:"A powerful standing pose that strengthens the legs, opens the hips, and improves balance. Excellent for knee and hip joint health.",advantages:["Strengthens legs and ankles","Stretches hips and groin","Improves balance and stability","Opens the chest","Builds stamina","Relieves knee pain"],disadvantages:["Avoid with knee injuries","May strain hip flexors if overdone","Not recommended for high blood pressure","Can cause dizziness if held too long"],difficulty:"Intermediate",duration:"30-60 seconds",subCategories:["Knee Pain","Hip Pain"]},{id:3,name:"\u0aae\u0abe\u0ab0\u0acd\u0a9c\u0ab0\u0ac0\u0a86\u0ab8\u0aa8 (Marjariasana) - Cat-Cow Pose",image:o(3,"Marjariasana"),description:"A gentle flowing movement that warms up the spine and relieves tension in the back and neck. Perfect for office workers.",advantages:["Relieves neck and back tension","Improves spinal flexibility","Massages abdominal organs","Reduces stress and fatigue","Improves posture","Safe for beginners"],disadvantages:["Avoid with severe neck injuries","May cause discomfort with wrist issues","Not suitable during late pregnancy","Can cause dizziness if done too fast"],difficulty:"Beginner",duration:"1-2 minutes",subCategories:["Neck Pain","Back Pain"]},{id:4,name:"\u0ab8\u0ac7\u0aa4\u0ac1 \u0aac\u0a82\u0aa7\u0abe\u0ab8\u0aa8 (Setu Bandhasana) - Bridge Pose",image:o(4,"Setu Bandhasana"),description:"A gentle backbend that strengthens the back muscles and opens the chest. Excellent for relieving lower back pain and improving spinal flexibility.",advantages:["Relieves lower back pain","Strengthens glutes and hamstrings","Opens the chest and shoulders","Improves spinal flexibility","Stimulates thyroid gland","Reduces anxiety and fatigue"],disadvantages:["Avoid with neck injuries","Not suitable for severe back problems","May strain knees if misaligned","Avoid during late pregnancy"],difficulty:"Beginner",duration:"30-60 seconds",subCategories:["Back Pain","Spine Health"]},{id:5,name:"\u0a85\u0ab0\u0acd\u0aa7 \u0aae\u0aa4\u0acd\u0ab8\u0acd\u0aaf\u0ac7\u0aa8\u0acd\u0aa6\u0acd\u0ab0\u0abe\u0ab8\u0aa8 (Ardha Matsyendrasana) - Half Lord of the Fishes Pose",image:o(5,"Ardha Matsyendrasana"),description:"A seated twist that improves spinal mobility and relieves back stiffness. Helps with sciatica and lower back tension.",advantages:["Relieves back stiffness","Improves spinal mobility","Stretches shoulders and hips","Stimulates digestive organs","Helps with sciatica","Reduces fatigue"],disadvantages:["Avoid with severe back injuries","Not suitable during pregnancy","May cause discomfort with knee issues","Can strain spine if forced"],difficulty:"Intermediate",duration:"30-60 seconds each side",subCategories:["Back Pain","Sciatica"]},{id:6,name:"\u0ab8\u0ac1\u0aaa\u0acd\u0aa4 \u0aaa\u0aa6\u0abe\u0a82\u0a97\u0ac1\u0ab7\u0acd\u0aa0\u0abe\u0ab8\u0aa8 (Supta Padangusthasana) - Reclining Hand-to-Big-Toe Pose",image:o(6,"Supta Padangusthasana"),description:"A supine pose that stretches the hamstrings and relieves lower back pain. Excellent for sciatica relief.",advantages:["Stretches hamstrings and calves","Relieves lower back pain","Helps with sciatica","Improves flexibility","Strengthens legs","Safe for beginners"],disadvantages:["Avoid with severe hamstring injuries","Not suitable with knee problems","May cause strain if overstretched","Avoid with high blood pressure"],difficulty:"Beginner",duration:"30-60 seconds each leg",subCategories:["Back Pain","Sciatica","Joint Pain"]},{id:7,name:"\u0a97\u0acb\u0aae\u0ac1\u0a96\u0abe\u0ab8\u0aa8 (Gomukhasana) - Cow Face Pose",image:o(7,"Gomukhasana"),description:"A seated pose that stretches shoulders, hips, and thighs. Excellent for shoulder and hip pain relief.",advantages:["Stretches shoulders and chest","Opens hips and thighs","Improves posture","Relieves shoulder tension","Stretches triceps","Improves flexibility"],disadvantages:["Avoid with shoulder injuries","Not suitable with knee problems","May cause discomfort with tight hips","Can strain if forced"],difficulty:"Intermediate",duration:"30-60 seconds each side",subCategories:["Shoulder Pain","Hip Pain","Joint Pain"]},{id:8,name:"\u0a97\u0ab0\u0ac1\u0aa1\u0abe\u0ab8\u0aa8 (Garudasana) - Eagle Pose",image:o(8,"Garudasana"),description:"A balancing pose that strengthens legs and improves joint mobility. Helps with joint pain and improves circulation.",advantages:["Strengthens legs and ankles","Improves balance","Stretches shoulders and upper back","Improves joint mobility","Enhances concentration","Relieves joint stiffness"],disadvantages:["Avoid with knee or ankle injuries","Not suitable for balance issues","May cause dizziness","Can strain if held too long"],difficulty:"Intermediate",duration:"20-40 seconds each side",subCategories:["Joint Pain","Knee Pain","Arthritis"]},{id:9,name:"\u0aaa\u0ab6\u0acd\u0a9a\u0abf\u0aae\u0acb\u0aa4\u0acd\u0aa4\u0abe\u0aa8\u0abe\u0ab8\u0aa8 (Paschimottanasana) - Seated Forward Bend",image:o(9,"Paschimottanasana"),description:"A forward fold that stretches the entire back body and relieves back pain. Calms the nervous system.",advantages:["Stretches entire back body","Relieves back pain","Calms the nervous system","Stimulates abdominal organs","Improves digestion","Reduces stress"],disadvantages:["Avoid with severe back injuries","Not suitable with disc problems","May cause strain if forced","Avoid during pregnancy"],difficulty:"Beginner",duration:"1-3 minutes",subCategories:["Back Pain","Muscle Tension"]},{id:10,name:"\u0a85\u0a82\u0a9c\u0aa8\u0ac7\u0aaf\u0abe\u0ab8\u0aa8 (Anjaneyasana) - Low Lunge",image:o(10,"Anjaneyasana"),description:"A lunge pose that stretches hip flexors and relieves hip and knee pain. Strengthens legs and improves flexibility.",advantages:["Stretches hip flexors","Strengthens legs","Opens the chest","Relieves hip pain","Improves balance","Stretches psoas muscle"],disadvantages:["Avoid with knee injuries","Not suitable with hip problems","May strain if overstretched","Can cause discomfort with ankle issues"],difficulty:"Beginner",duration:"30-60 seconds each side",subCategories:["Hip Pain","Knee Pain","Muscle Tension"]},{id:11,name:"\u0a89\u0aa4\u0acd\u0aa4\u0abe\u0aa8\u0abe\u0ab8\u0aa8 (Uttanasana) - Standing Forward Bend",image:o(11,"Uttanasana"),description:"A standing forward fold that relieves back and neck tension. Calms the mind and stretches the entire back body.",advantages:["Relieves back and neck tension","Stretches hamstrings and calves","Calms the mind","Improves circulation","Reduces stress","Stimulates abdominal organs"],disadvantages:["Avoid with severe back injuries","Not suitable with high blood pressure","May cause dizziness","Avoid during late pregnancy"],difficulty:"Beginner",duration:"30-60 seconds",subCategories:["Back Pain","Neck Pain","Muscle Tension"]},{id:12,name:"\u0ab5\u0abf\u0aaa\u0ab0\u0ac0\u0aa4 \u0a95\u0ab0\u0aa3\u0ac0 (Viparita Karani) - Legs-Up-the-Wall Pose",image:o(12,"Viparita Karani"),description:"A restorative inversion that relieves back pain and reduces swelling. Excellent for sciatica and lower back relief.",advantages:["Relieves lower back pain","Reduces leg swelling","Calms the nervous system","Improves circulation","Reduces stress","Helps with sciatica"],disadvantages:["Avoid with eye pressure issues","Not suitable with severe back problems","May cause discomfort with neck issues","Avoid during menstruation"],difficulty:"Beginner",duration:"5-15 minutes",subCategories:["Back Pain","Sciatica","Muscle Tension"]},{id:13,name:"\u0aaa\u0ab5\u0aa8\u0aae\u0ac1\u0a95\u0acd\u0aa4\u0abe\u0ab8\u0aa8 (Pavanamuktasana) - Wind-Relieving Pose",image:o(13,"Pavanamuktasana"),description:"A supine pose that relieves lower back pain and improves digestion. Excellent for joint pain and arthritis.",advantages:["Relieves lower back pain","Improves digestion","Stretches lower back","Relieves gas and bloating","Strengthens core","Helps with joint pain"],disadvantages:["Avoid with severe back injuries","Not suitable during pregnancy","May cause discomfort with knee issues","Avoid with high blood pressure"],difficulty:"Beginner",duration:"30-60 seconds",subCategories:["Back Pain","Joint Pain","Arthritis"]},{id:14,name:"\u0aa4\u0acd\u0ab0\u0abf\u0a95\u0acb\u0aa3\u0abe\u0ab8\u0aa8 (Trikonasana) - Triangle Pose",image:o(14,"Trikonasana"),description:"A standing pose that strengthens legs and relieves back pain. Improves flexibility and balance.",advantages:["Strengthens legs","Stretches hamstrings and hips","Relieves back pain","Improves balance","Opens the chest","Stimulates abdominal organs"],disadvantages:["Avoid with low blood pressure","Not suitable with neck injuries","May cause dizziness","Can strain if overstretched"],difficulty:"Intermediate",duration:"30-60 seconds each side",subCategories:["Back Pain","Hip Pain","Muscle Tension"]},{id:15,name:"\u0a85\u0aa7\u0acb \u0aae\u0ac1\u0a96 \u0ab6\u0acd\u0ab5\u0abe\u0aa8\u0abe\u0ab8\u0aa8 (Adho Mukha Svanasana) - Downward-Facing Dog",image:o(15,"Adho Mukha Svanasana"),description:"An inversion that strengthens the entire body and relieves back pain. Excellent for shoulder and neck tension.",advantages:["Strengthens arms and legs","Stretches hamstrings and calves","Relieves back pain","Improves circulation","Calms the mind","Relieves shoulder tension"],disadvantages:["Avoid with wrist injuries","Not suitable with high blood pressure","May cause strain with shoulder issues","Avoid during late pregnancy"],difficulty:"Beginner",duration:"30-60 seconds",subCategories:["Back Pain","Shoulder Pain","Neck Pain"]}],"disease-specific":[{id:16,name:"\u0ab8\u0ac2\u0ab0\u0acd\u0aaf \u0aa8\u0aae\u0ab8\u0acd\u0a95\u0abe\u0ab0 (Surya Namaskar) - Sun Salutation",image:o(16,"Surya Namaskar"),description:"A complete sequence of 12 poses that provides a full-body workout. Excellent for diabetes management and cardiovascular health.",advantages:["Helps control blood sugar levels","Improves cardiovascular health","Boosts metabolism","Enhances flexibility","Reduces stress","Improves circulation"],disadvantages:["Avoid with severe heart conditions","Not recommended during pregnancy","May cause fatigue if overdone","Requires good physical condition"],difficulty:"Intermediate",duration:"5-10 minutes",subCategories:["Diabetes","Heart Health"]},{id:17,name:"\u0ab8\u0ab0\u0acd\u0ab5\u0abe\u0a82\u0a97\u0abe\u0ab8\u0aa8 (Sarvangasana) - Shoulder Stand",image:o(17,"Sarvangasana"),description:"An inverted pose that stimulates the thyroid gland and improves blood circulation. Beneficial for thyroid disorders.",advantages:["Stimulates thyroid gland","Improves blood circulation","Relieves stress and anxiety","Strengthens shoulders and arms","Improves digestion","Calms the nervous system"],disadvantages:["Avoid with neck injuries","Not suitable for high blood pressure","Avoid during menstruation","Not recommended for glaucoma","Requires proper technique"],difficulty:"Advanced",duration:"1-3 minutes",subCategories:["Thyroid","Blood Pressure"]},{id:18,name:"\u0ab9\u0ab2\u0abe\u0ab8\u0aa8 (Halasana) - Plow Pose",image:o(18,"Halasana"),description:"An inverted pose that stimulates the thyroid gland and improves digestion. Beneficial for diabetes and thyroid disorders.",advantages:["Stimulates thyroid gland","Improves digestion","Stretches the spine","Calms the nervous system","Helps with diabetes","Reduces stress"],disadvantages:["Avoid with neck injuries","Not suitable during menstruation","Avoid with high blood pressure","Requires flexibility","Not for beginners"],difficulty:"Advanced",duration:"1-3 minutes",subCategories:["Thyroid","Diabetes","Digestive Issues"]},{id:19,name:"\u0aa7\u0aa8\u0ac1\u0ab0\u0abe\u0ab8\u0aa8 (Dhanurasana) - Bow Pose",image:o(19,"Dhanurasana"),description:"A backbend that stimulates abdominal organs and improves digestion. Excellent for diabetes and digestive issues.",advantages:["Stimulates abdominal organs","Improves digestion","Strengthens back muscles","Opens the chest","Helps with diabetes","Reduces belly fat"],disadvantages:["Avoid with severe back injuries","Not suitable during pregnancy","Avoid with high blood pressure","May strain neck if done incorrectly"],difficulty:"Intermediate",duration:"20-30 seconds",subCategories:["Diabetes","Digestive Issues"]},{id:20,name:"\u0aad\u0ab8\u0acd\u0aa4\u0acd\u0ab0\u0abf\u0a95\u0abe \u0aaa\u0acd\u0ab0\u0abe\u0aa3\u0abe\u0aaf\u0abe\u0aae (Bhastrika Pranayama) - Bellows Breath",image:o(20,"Bhastrika Pranayama"),description:"A powerful breathing technique that improves lung capacity and helps with asthma. Boosts energy and metabolism.",advantages:["Improves lung capacity","Helps with asthma","Boosts metabolism","Increases energy","Improves circulation","Strengthens respiratory system"],disadvantages:["Avoid with high blood pressure","Not suitable with heart conditions","May cause dizziness","Avoid during pregnancy","Not for beginners"],difficulty:"Intermediate",duration:"2-5 minutes",subCategories:["Asthma","Heart Health","Immune System"]},{id:21,name:"\u0a95\u0aaa\u0abe\u0ab2\u0aad\u0abe\u0aa4\u0abf \u0aaa\u0acd\u0ab0\u0abe\u0aa3\u0abe\u0aaf\u0abe\u0aae (Kapalbhati Pranayama) - Skull Shining Breath",image:o(21,"Kapalbhati Pranayama"),description:"A cleansing breathing technique that helps control diabetes and improves digestion. Strengthens abdominal muscles.",advantages:["Helps control diabetes","Improves digestion","Strengthens abdominal muscles","Cleanses respiratory system","Boosts metabolism","Improves focus"],disadvantages:["Avoid with high blood pressure","Not suitable with heart problems","Avoid during pregnancy","May cause dizziness","Not for beginners"],difficulty:"Intermediate",duration:"2-5 minutes",subCategories:["Diabetes","Digestive Issues","Immune System"]},{id:22,name:"\u0aae\u0aa4\u0acd\u0ab8\u0acd\u0aaf\u0abe\u0ab8\u0aa8 (Matsyasana) - Fish Pose",image:o(22,"Matsyasana"),description:"A backbend that opens the chest and improves breathing. Beneficial for asthma and respiratory issues.",advantages:["Opens the chest","Improves breathing","Stretches hip flexors","Stimulates thyroid","Helps with asthma","Relieves neck tension"],disadvantages:["Avoid with neck injuries","Not suitable with high blood pressure","Avoid during late pregnancy","May strain lower back"],difficulty:"Beginner",duration:"30-60 seconds",subCategories:["Asthma","Thyroid","Heart Health"]},{id:23,name:"\u0ab5\u0a9c\u0acd\u0ab0\u0abe\u0ab8\u0aa8 (Vajrasana) - Thunderbolt Pose",image:o(23,"Vajrasana"),description:"A seated pose that improves digestion and helps control diabetes. Excellent for meditation and pranayama.",advantages:["Improves digestion","Helps with diabetes","Strengthens thigh muscles","Calms the mind","Improves posture","Aids in meditation"],disadvantages:["Avoid with knee injuries","Not suitable with ankle problems","May cause discomfort initially","Can strain knees if held too long"],difficulty:"Beginner",duration:"5-30 minutes",subCategories:["Diabetes","Digestive Issues"]},{id:24,name:"\u0aaa\u0ab6\u0acd\u0a9a\u0abf\u0aae\u0acb\u0aa4\u0acd\u0aa4\u0abe\u0aa8\u0abe\u0ab8\u0aa8 (Paschimottanasana) - Seated Forward Bend",image:o(24,"Paschimottanasana"),description:"A forward fold that stimulates abdominal organs and helps with diabetes. Calms the nervous system.",advantages:["Stimulates abdominal organs","Helps with diabetes","Calms nervous system","Improves digestion","Stretches entire back","Reduces stress"],disadvantages:["Avoid with severe back injuries","Not suitable with disc problems","Avoid during pregnancy","May cause strain if forced"],difficulty:"Beginner",duration:"1-3 minutes",subCategories:["Diabetes","Digestive Issues","Heart Health"]},{id:25,name:"\u0a89\u0ab7\u0acd\u0a9f\u0acd\u0ab0\u0abe\u0ab8\u0aa8 (Ustrasana) - Camel Pose",image:o(25,"Ustrasana"),description:"A deep backbend that opens the chest and improves breathing. Beneficial for asthma and respiratory health.",advantages:["Opens the chest","Improves breathing","Stretches hip flexors","Strengthens back","Helps with asthma","Stimulates thyroid"],disadvantages:["Avoid with neck injuries","Not suitable with high blood pressure","Avoid during pregnancy","May strain lower back"],difficulty:"Intermediate",duration:"30-60 seconds",subCategories:["Asthma","Thyroid","Heart Health"]},{id:26,name:"\u0aa8\u0abe\u0aa1\u0ac0 \u0ab6\u0acb\u0aa7\u0aa8 \u0aaa\u0acd\u0ab0\u0abe\u0aa3\u0abe\u0aaf\u0abe\u0aae (Nadi Shodhana Pranayama) - Alternate Nostril Breathing",image:o(26,"Nadi Shodhana Pranayama"),description:"A balancing breathing technique that regulates blood pressure and calms the mind. Excellent for heart health.",advantages:["Regulates blood pressure","Calms the mind","Balances nervous system","Improves focus","Reduces stress","Benefits heart health"],disadvantages:["Avoid with blocked nostrils","Not suitable during illness","May cause dizziness if done incorrectly","Requires proper technique"],difficulty:"Beginner",duration:"5-10 minutes",subCategories:["Blood Pressure (BP)","Heart Health","Immune System"]},{id:27,name:"\u0ab8\u0ac1\u0aaa\u0acd\u0aa4 \u0aac\u0aa6\u0acd\u0aa7 \u0a95\u0acb\u0aa8\u0abe\u0ab8\u0aa8 (Supta Baddha Konasana) - Reclining Bound Angle Pose",image:o(27,"Supta Baddha Konasana"),description:"A restorative pose that helps with PCOS and hormonal balance. Calms the nervous system and reduces stress.",advantages:["Helps with PCOS","Improves hormonal balance","Stretches inner thighs","Calms nervous system","Reduces stress","Improves circulation"],disadvantages:["Avoid with knee injuries","Not suitable with groin injuries","May cause discomfort with tight hips","Use props if needed"],difficulty:"Beginner",duration:"3-10 minutes",subCategories:["PCOS","Hormonal Balance","Immune System"]},{id:28,name:"\u0aac\u0aa6\u0acd\u0aa7 \u0a95\u0acb\u0aa8\u0abe\u0ab8\u0aa8 (Baddha Konasana) - Butterfly Pose",image:o(28,"Baddha Konasana"),description:"A seated pose that helps with PCOS and improves reproductive health. Stretches inner thighs and groin.",advantages:["Helps with PCOS","Improves reproductive health","Stretches inner thighs","Stimulates abdominal organs","Improves flexibility","Calms the mind"],disadvantages:["Avoid with knee injuries","Not suitable with groin problems","May cause discomfort initially","Use props for support"],difficulty:"Beginner",duration:"1-5 minutes",subCategories:["PCOS","Hormonal Balance"]},{id:29,name:"\u0ab6\u0ab5\u0abe\u0ab8\u0aa8 (Shavasana) - Corpse Pose",image:o(29,"Shavasana"),description:"A restorative pose that reduces blood pressure and calms the entire system. Essential for heart health.",advantages:["Reduces blood pressure","Calms entire system","Reduces stress","Improves heart health","Promotes relaxation","Enhances recovery"],disadvantages:["May cause sleepiness","Not suitable if feeling unwell","Keep warm during practice","Avoid if very tired"],difficulty:"Beginner",duration:"5-20 minutes",subCategories:["Blood Pressure (BP)","Heart Health","Immune System"]},{id:30,name:"\u0ab5\u0abf\u0aaa\u0ab0\u0ac0\u0aa4 \u0a95\u0ab0\u0aa3\u0ac0 (Viparita Karani) - Legs-Up-the-Wall Pose",image:o(30,"Viparita Karani"),description:"A gentle inversion that improves circulation and helps with blood pressure. Calms the nervous system.",advantages:["Improves circulation","Helps with blood pressure","Reduces leg swelling","Calms nervous system","Relieves stress","Benefits heart health"],disadvantages:["Avoid with eye pressure issues","Not suitable during menstruation","May cause discomfort with neck issues","Avoid if feeling dizzy"],difficulty:"Beginner",duration:"5-15 minutes",subCategories:["Blood Pressure (BP)","Heart Health","Immune System"]},{id:31,name:"\u0a85\u0ab0\u0acd\u0aa7 \u0a9a\u0a82\u0aa6\u0acd\u0ab0\u0abe\u0ab8\u0aa8 (Ardha Chandrasana) - Half Moon Pose",image:o(31,"Ardha Chandrasana"),description:"A balancing pose that improves circulation and strengthens the immune system. Enhances coordination and focus.",advantages:["Improves circulation","Strengthens immune system","Improves balance","Strengthens legs","Stretches hamstrings","Enhances focus"],disadvantages:["Avoid with low blood pressure","Not suitable with balance issues","May cause dizziness","Requires good flexibility"],difficulty:"Intermediate",duration:"30-60 seconds each side",subCategories:["Immune System","Heart Health"]},{id:32,name:"\u0a89\u0aa4\u0acd\u0a95\u0a9f\u0abe\u0ab8\u0aa8 (Utkatasana) - Chair Pose",image:o(32,"Utkatasana"),description:"A strengthening pose that improves metabolism and helps with diabetes. Builds endurance and strength.",advantages:["Improves metabolism","Helps with diabetes","Strengthens legs","Builds endurance","Tones muscles","Improves balance"],disadvantages:["Avoid with knee injuries","Not suitable with low blood pressure","May cause strain if held too long","Can be challenging for beginners"],difficulty:"Intermediate",duration:"30-60 seconds",subCategories:["Diabetes","Heart Health","Immune System"]}],"mental-health":[{id:33,name:"\u0aac\u0abe\u0ab2\u0abe\u0ab8\u0aa8 (Balasana) - Child's Pose",image:o(33,"Balasana"),description:"A restorative pose that calms the mind and relieves stress. Perfect for anxiety and stress management.",advantages:["Reduces stress and anxiety","Calms the mind","Stretches hips and thighs","Relieves back pain","Promotes relaxation","Improves sleep quality"],disadvantages:["Avoid with knee injuries","Not suitable during pregnancy","May cause discomfort with ankle issues","Can be difficult with tight hips"],difficulty:"Beginner",duration:"1-3 minutes",subCategories:["Stress Relief","Anxiety Management"]},{id:34,name:"\u0aaa\u0aa6\u0acd\u0aae\u0abe\u0ab8\u0aa8 (Padmasana) - Lotus Pose",image:o(34,"Padmasana"),description:"The classic meditation pose that promotes mental clarity and focus. Ideal for meditation and concentration practices.",advantages:["Improves focus and concentration","Calms the mind","Opens hips","Improves posture","Reduces anxiety","Enhances meditation practice"],disadvantages:["Requires flexible hips","Can strain knees if forced","Not suitable for knee injuries","May cause ankle discomfort","Difficult for beginners"],difficulty:"Intermediate",duration:"5-30 minutes",subCategories:["Focus & Concentration","Meditation"]},{id:35,name:"\u0ab6\u0ab5\u0abe\u0ab8\u0aa8 (Shavasana) - Corpse Pose",image:o(35,"Shavasana"),description:"The ultimate relaxation pose that calms the mind and reduces stress. Essential for mental health and sleep quality.",advantages:["Reduces stress and anxiety","Calms the mind","Improves sleep quality","Promotes deep relaxation","Reduces blood pressure","Enhances recovery"],disadvantages:["May cause sleepiness","Keep warm during practice","Not suitable if feeling unwell","Avoid if very tired"],difficulty:"Beginner",duration:"5-20 minutes",subCategories:["Stress Relief","Sleep Disorders","Emotional Balance"]},{id:36,name:"\u0ab5\u0abf\u0aaa\u0ab0\u0ac0\u0aa4 \u0a95\u0ab0\u0aa3\u0ac0 (Viparita Karani) - Legs-Up-the-Wall Pose",image:o(36,"Viparita Karani"),description:"A restorative inversion that calms the nervous system and reduces anxiety. Excellent for stress relief and sleep.",advantages:["Reduces anxiety","Calms nervous system","Improves sleep","Reduces stress","Relieves fatigue","Promotes relaxation"],disadvantages:["Avoid with eye pressure issues","Not suitable during menstruation","May cause discomfort with neck issues","Avoid if feeling dizzy"],difficulty:"Beginner",duration:"5-15 minutes",subCategories:["Stress Relief","Anxiety Management","Sleep Disorders"]},{id:37,name:"\u0a85\u0aa8\u0ac1\u0ab2\u0acb\u0aae \u0ab5\u0abf\u0ab2\u0acb\u0aae \u0aaa\u0acd\u0ab0\u0abe\u0aa3\u0abe\u0aaf\u0abe\u0aae (Anulom Vilom Pranayama) - Alternate Nostril Breathing",image:o(37,"Anulom Vilom Pranayama"),description:"A balancing breathing technique that calms the mind and reduces stress. Excellent for anxiety and emotional balance.",advantages:["Reduces stress and anxiety","Calms the mind","Balances emotions","Improves focus","Reduces depression symptoms","Enhances mental clarity"],disadvantages:["Avoid with blocked nostrils","Not suitable during illness","May cause dizziness if done incorrectly","Requires proper technique"],difficulty:"Beginner",duration:"5-10 minutes",subCategories:["Stress Relief","Anxiety Management","Depression Support","Emotional Balance"]},{id:38,name:"\u0aad\u0acd\u0ab0\u0aae\u0ab0\u0ac0 \u0aaa\u0acd\u0ab0\u0abe\u0aa3\u0abe\u0aaf\u0abe\u0aae (Bhramari Pranayama) - Bee Breath",image:o(38,"Bhramari Pranayama"),description:"A calming breathing technique that reduces anxiety and promotes sleep. Excellent for stress relief and emotional balance.",advantages:["Reduces anxiety","Promotes sleep","Calms the mind","Reduces stress","Improves focus","Balances emotions"],disadvantages:["Avoid with ear infections","Not suitable with severe sinus issues","May cause discomfort initially","Practice in quiet environment"],difficulty:"Beginner",duration:"5-10 minutes",subCategories:["Anxiety Management","Sleep Disorders","Stress Relief","Emotional Balance"]},{id:39,name:"\u0ab8\u0ac1\u0a96\u0abe\u0ab8\u0aa8 (Sukhasana) - Easy Pose",image:o(39,"Sukhasana"),description:"A comfortable seated pose for meditation that calms the mind and improves focus. Perfect for beginners.",advantages:["Calms the mind","Improves focus","Reduces stress","Improves posture","Easy for beginners","Enhances meditation"],disadvantages:["May cause discomfort with tight hips","Use props for support","Avoid with knee injuries","Keep spine straight"],difficulty:"Beginner",duration:"5-30 minutes",subCategories:["Focus & Concentration","Meditation","Stress Relief"]},{id:40,name:"\u0ab5\u0ac0\u0ab0\u0abe\u0ab8\u0aa8 (Virasana) - Hero Pose",image:o(40,"Virasana"),description:"A seated pose that calms the mind and improves focus. Excellent for meditation and concentration practices.",advantages:["Calms the mind","Improves focus","Stretches thighs","Improves digestion","Reduces stress","Enhances meditation"],disadvantages:["Avoid with knee injuries","Not suitable with ankle problems","May cause discomfort initially","Use props if needed"],difficulty:"Beginner",duration:"5-30 minutes",subCategories:["Focus & Concentration","Meditation","Stress Relief"]},{id:41,name:"\u0a89\u0a9c\u0acd\u0a9c\u0abe\u0aaf\u0ac0 \u0aaa\u0acd\u0ab0\u0abe\u0aa3\u0abe\u0aaf\u0abe\u0aae (Ujjayi Pranayama) - Victorious Breath",image:o(41,"Ujjayi Pranayama"),description:"A calming breathing technique that reduces stress and improves focus. Excellent for anxiety management.",advantages:["Reduces stress","Improves focus","Calms the mind","Reduces anxiety","Enhances concentration","Balances emotions"],disadvantages:["Avoid with high blood pressure","Not suitable with heart conditions","May cause dizziness","Requires proper technique"],difficulty:"Beginner",duration:"5-10 minutes",subCategories:["Stress Relief","Anxiety Management","Focus & Concentration"]},{id:42,name:"\u0ab8\u0ac1\u0aaa\u0acd\u0aa4 \u0aae\u0aa4\u0acd\u0ab8\u0acd\u0aaf\u0ac7\u0aa8\u0acd\u0aa6\u0acd\u0ab0\u0abe\u0ab8\u0aa8 (Supta Matsyendrasana) - Supine Spinal Twist",image:o(42,"Supta Matsyendrasana"),description:"A gentle twist that calms the nervous system and reduces stress. Excellent for sleep and relaxation.",advantages:["Calms nervous system","Reduces stress","Improves sleep","Stretches spine","Relieves tension","Promotes relaxation"],disadvantages:["Avoid with severe back injuries","Not suitable during pregnancy","May cause discomfort with knee issues","Keep shoulders on ground"],difficulty:"Beginner",duration:"30-60 seconds each side",subCategories:["Stress Relief","Sleep Disorders","Emotional Balance"]},{id:43,name:"\u0aae\u0aa4\u0acd\u0ab8\u0acd\u0aaf\u0abe\u0ab8\u0aa8 (Matsyasana) - Fish Pose",image:o(43,"Matsyasana"),description:"A backbend that opens the heart and reduces depression. Calms the mind and improves emotional balance.",advantages:["Reduces depression","Opens the heart","Calms the mind","Improves emotional balance","Stretches chest","Reduces stress"],disadvantages:["Avoid with neck injuries","Not suitable with high blood pressure","Avoid during late pregnancy","May strain lower back"],difficulty:"Beginner",duration:"30-60 seconds",subCategories:["Depression Support","Emotional Balance","Stress Relief"]},{id:44,name:"\u0ab8\u0ac7\u0aa4\u0ac1 \u0aac\u0a82\u0aa7\u0abe\u0ab8\u0aa8 (Setu Bandhasana) - Bridge Pose",image:o(44,"Setu Bandhasana"),description:"A gentle backbend that calms the mind and reduces anxiety. Excellent for stress relief and sleep.",advantages:["Reduces anxiety","Calms the mind","Improves sleep","Reduces stress","Opens the chest","Promotes relaxation"],disadvantages:["Avoid with neck injuries","Not suitable with severe back problems","Avoid during late pregnancy","May strain knees if misaligned"],difficulty:"Beginner",duration:"30-60 seconds",subCategories:["Anxiety Management","Sleep Disorders","Stress Relief"]},{id:45,name:"\u0aa8\u0abe\u0aa1\u0ac0 \u0ab6\u0acb\u0aa7\u0aa8 (Nadi Shodhana) - Alternate Nostril Breathing",image:o(45,"Nadi Shodhana"),description:"A balancing breathing technique that reduces stress and improves emotional balance. Excellent for depression support.",advantages:["Reduces stress","Improves emotional balance","Reduces depression symptoms","Calms the mind","Enhances focus","Balances nervous system"],disadvantages:["Avoid with blocked nostrils","Not suitable during illness","May cause dizziness if done incorrectly","Requires proper technique"],difficulty:"Beginner",duration:"5-10 minutes",subCategories:["Depression Support","Emotional Balance","Stress Relief"]},{id:46,name:"\u0ab6\u0ac0\u0aa4\u0ab2\u0ac0 \u0aaa\u0acd\u0ab0\u0abe\u0aa3\u0abe\u0aaf\u0abe\u0aae (Shitali Pranayama) - Cooling Breath",image:o(46,"Shitali Pranayama"),description:"A cooling breathing technique that calms the mind and reduces stress. Excellent for anxiety and emotional balance.",advantages:["Calms the mind","Reduces stress","Reduces anxiety","Cools the body","Improves focus","Balances emotions"],disadvantages:["Avoid in cold weather","Not suitable with respiratory issues","May cause discomfort initially","Practice in comfortable temperature"],difficulty:"Beginner",duration:"5-10 minutes",subCategories:["Anxiety Management","Stress Relief","Emotional Balance"]},{id:47,name:"\u0aaf\u0acb\u0a97 \u0aa8\u0abf\u0aa6\u0acd\u0ab0\u0abe (Yoga Nidra) - Yogic Sleep",image:o(47,"Yoga Nidra"),description:"A deep relaxation practice that reduces stress and improves sleep. Excellent for depression and anxiety management.",advantages:["Reduces stress","Improves sleep quality","Reduces anxiety","Helps with depression","Promotes deep relaxation","Enhances recovery"],disadvantages:["May cause deep sleep","Practice in quiet environment","Not suitable if very tired","Keep warm during practice"],difficulty:"Beginner",duration:"20-45 minutes",subCategories:["Sleep Disorders","Depression Support","Stress Relief","Anxiety Management"]}],"fitness-goals":[{id:48,name:"\u0a9a\u0aa4\u0ac1\u0ab0\u0a82\u0a97 \u0aa6\u0a82\u0aa1\u0abe\u0ab8\u0aa8 (Chaturanga Dandasana) - Four-Limbed Staff Pose",image:o(48,"Chaturanga Dandasana"),description:"A challenging arm balance that builds upper body strength and core stability. Excellent for weight loss and muscle toning.",advantages:["Builds upper body strength","Strengthens core muscles","Tones arms and shoulders","Improves balance","Burns calories","Builds endurance"],disadvantages:["Requires significant upper body strength","Can strain wrists","Not suitable for shoulder injuries","May cause lower back strain","Difficult for beginners"],difficulty:"Advanced",duration:"10-30 seconds",subCategories:["Strength Building","Weight Loss"]},{id:49,name:"\u0ab8\u0ac2\u0ab0\u0acd\u0aaf \u0aa8\u0aae\u0ab8\u0acd\u0a95\u0abe\u0ab0 (Surya Namaskar) - Sun Salutation",image:o(49,"Surya Namaskar"),description:"A complete sequence of 12 poses that provides a full-body workout. Excellent for weight loss and cardio fitness.",advantages:["Burns calories","Improves cardio fitness","Enhances flexibility","Strengthens entire body","Boosts metabolism","Improves circulation"],disadvantages:["Avoid with severe heart conditions","Not recommended during pregnancy","May cause fatigue if overdone","Requires good physical condition"],difficulty:"Intermediate",duration:"5-10 minutes",subCategories:["Weight Loss","Cardio Fitness","Body Sculpting"]},{id:50,name:"\u0a89\u0aa4\u0acd\u0a95\u0a9f\u0abe\u0ab8\u0aa8 (Utkatasana) - Chair Pose",image:o(50,"Utkatasana"),description:"A strengthening pose that builds leg and core strength. Excellent for weight loss and muscle toning.",advantages:["Burns calories","Strengthens legs","Tones muscles","Builds endurance","Improves balance","Strengthens core"],disadvantages:["Avoid with knee injuries","Not suitable with low blood pressure","May cause strain if held too long","Can be challenging for beginners"],difficulty:"Intermediate",duration:"30-60 seconds",subCategories:["Weight Loss","Strength Building","Muscle Tone"]},{id:51,name:"\u0aa8\u0abe\u0ab5\u0abe\u0ab8\u0aa8 (Navasana) - Boat Pose",image:o(51,"Navasana"),description:"A core strengthening pose that tones abdominal muscles. Excellent for weight loss and core strength.",advantages:["Strengthens core","Tones abdominal muscles","Burns calories","Improves balance","Strengthens hip flexors","Improves digestion"],disadvantages:["Avoid with lower back injuries","Not suitable during pregnancy","May cause strain if forced","Requires core strength"],difficulty:"Intermediate",duration:"20-40 seconds",subCategories:["Core Strength","Weight Loss","Body Sculpting"]},{id:52,name:"\u0aab\u0ab2\u0a95\u0abe\u0ab8\u0aa8 (Phalakasana) - Plank Pose",image:o(52,"Phalakasana"),description:"A full-body strengthening pose that builds core and upper body strength. Excellent for muscle toning.",advantages:["Strengthens entire body","Builds core strength","Tones arms and shoulders","Burns calories","Improves posture","Builds endurance"],disadvantages:["Avoid with wrist injuries","Not suitable with shoulder problems","May cause strain if held too long","Requires upper body strength"],difficulty:"Intermediate",duration:"20-60 seconds",subCategories:["Core Strength","Strength Building","Muscle Tone"]},{id:53,name:"\u0ab5\u0ac0\u0ab0\u0aad\u0aa6\u0acd\u0ab0\u0abe\u0ab8\u0aa8 I (Virabhadrasana I) - Warrior I",image:o(53,"Virabhadrasana I"),description:"A powerful standing pose that builds strength and stamina. Excellent for weight loss and muscle building.",advantages:["Strengthens legs","Builds stamina","Tones muscles","Burns calories","Improves balance","Opens hips"],disadvantages:["Avoid with knee injuries","Not suitable with high blood pressure","May cause strain if overdone","Can be challenging"],difficulty:"Intermediate",duration:"30-60 seconds each side",subCategories:["Strength Building","Weight Loss","Muscle Tone"]},{id:54,name:"\u0ab9\u0aa8\u0ac1\u0aae\u0abe\u0aa8\u0abe\u0ab8\u0aa8 (Hanumanasana) - Monkey Pose/Splits",image:o(54,"Hanumanasana"),description:"An advanced flexibility pose that stretches hamstrings and hip flexors. Excellent for flexibility training.",advantages:["Improves flexibility","Stretches hamstrings","Opens hip flexors","Strengthens legs","Improves balance","Enhances range of motion"],disadvantages:["Requires significant flexibility","Avoid with hamstring injuries","Not suitable with hip problems","Very challenging for beginners"],difficulty:"Advanced",duration:"30-60 seconds each side",subCategories:["Flexibility","Body Sculpting"]},{id:55,name:"\u0a8f\u0a95 \u0aaa\u0aa6 \u0ab0\u0abe\u0a9c\u0a95\u0aaa\u0acb\u0aa4\u0abe\u0ab8\u0aa8 (Eka Pada Rajakapotasana) - Pigeon Pose",image:o(55,"Eka Pada Rajakapotasana"),description:"A deep hip opener that improves flexibility. Excellent for flexibility and body sculpting.",advantages:["Opens hips","Improves flexibility","Stretches hip flexors","Relieves tension","Improves posture","Enhances range of motion"],disadvantages:["Avoid with knee injuries","Not suitable with hip problems","May cause discomfort initially","Use props for support"],difficulty:"Intermediate",duration:"1-3 minutes each side",subCategories:["Flexibility","Body Sculpting"]},{id:56,name:"\u0aa7\u0aa8\u0ac1\u0ab0\u0abe\u0ab8\u0aa8 (Dhanurasana) - Bow Pose",image:o(56,"Dhanurasana"),description:"A backbend that strengthens back muscles and improves flexibility. Excellent for strength and flexibility.",advantages:["Strengthens back","Improves flexibility","Tones muscles","Opens chest","Stimulates organs","Builds strength"],disadvantages:["Avoid with severe back injuries","Not suitable during pregnancy","Avoid with high blood pressure","May strain neck if done incorrectly"],difficulty:"Intermediate",duration:"20-30 seconds",subCategories:["Strength Building","Flexibility","Body Sculpting"]},{id:57,name:"\u0a85\u0aa7\u0acb \u0aae\u0ac1\u0a96 \u0ab5\u0ac3\u0a95\u0acd\u0ab7\u0abe\u0ab8\u0aa8 (Adho Mukha Vrksasana) - Handstand",image:o(57,"Adho Mukha Vrksasana"),description:"An advanced inversion that builds upper body and core strength. Excellent for strength building and body sculpting.",advantages:["Builds upper body strength","Strengthens core","Improves balance","Tones entire body","Builds confidence","Enhances coordination"],disadvantages:["Requires significant strength","Avoid with wrist injuries","Not suitable with high blood pressure","Very challenging","Requires proper technique"],difficulty:"Advanced",duration:"10-30 seconds",subCategories:["Strength Building","Body Sculpting"]},{id:58,name:"\u0aac\u0a95\u0abe\u0ab8\u0aa8 (Bakasana) - Crow Pose",image:o(58,"Bakasana"),description:"An arm balance that builds upper body and core strength. Excellent for strength building and muscle toning.",advantages:["Builds upper body strength","Strengthens core","Improves balance","Tones arms","Builds confidence","Enhances coordination"],disadvantages:["Requires upper body strength","Avoid with wrist injuries","Not suitable with shoulder problems","Challenging for beginners"],difficulty:"Intermediate",duration:"10-30 seconds",subCategories:["Strength Building","Muscle Tone","Core Strength"]},{id:59,name:"\u0a8a\u0ab0\u0acd\u0aa7\u0acd\u0ab5 \u0aa7\u0aa8\u0ac1\u0ab0\u0abe\u0ab8\u0aa8 (Urdhva Dhanurasana) - Wheel Pose",image:o(59,"Urdhva Dhanurasana"),description:"An advanced backbend that builds strength and flexibility. Excellent for body sculpting and flexibility.",advantages:["Builds strength","Improves flexibility","Opens chest","Strengthens arms and legs","Tones entire body","Enhances energy"],disadvantages:["Requires significant flexibility","Avoid with back injuries","Not suitable with high blood pressure","Very challenging","Requires proper technique"],difficulty:"Advanced",duration:"10-30 seconds",subCategories:["Flexibility","Strength Building","Body Sculpting"]},{id:60,name:"\u0aa4\u0acd\u0ab0\u0abf\u0a95\u0acb\u0aa3\u0abe\u0ab8\u0aa8 (Trikonasana) - Triangle Pose",image:o(60,"Trikonasana"),description:"A standing pose that improves flexibility and strengthens legs. Excellent for flexibility and muscle toning.",advantages:["Improves flexibility","Strengthens legs","Stretches hamstrings","Tones muscles","Improves balance","Opens hips"],disadvantages:["Avoid with low blood pressure","Not suitable with neck injuries","May cause dizziness","Can strain if overstretched"],difficulty:"Intermediate",duration:"30-60 seconds each side",subCategories:["Flexibility","Muscle Tone","Body Sculpting"]},{id:61,name:"\u0aaa\u0ab0\u0abf\u0ab5\u0ac3\u0aa4\u0acd\u0aa4 \u0aa4\u0acd\u0ab0\u0abf\u0a95\u0acb\u0aa3\u0abe\u0ab8\u0aa8 (Parivrtta Trikonasana) - Revolved Triangle Pose",image:o(61,"Parivrtta Trikonasana"),description:"A twisting pose that improves flexibility and strengthens core. Excellent for flexibility and core strength.",advantages:["Improves flexibility","Strengthens core","Stretches hamstrings","Tones muscles","Improves balance","Stimulates organs"],disadvantages:["Avoid with low blood pressure","Not suitable with back injuries","May cause dizziness","Requires good flexibility"],difficulty:"Intermediate",duration:"30-60 seconds each side",subCategories:["Flexibility","Core Strength","Body Sculpting"]},{id:62,name:"\u0ab5\u0ab8\u0abf\u0ab7\u0acd\u0aa0\u0abe\u0ab8\u0aa8 (Vasisthasana) - Side Plank Pose",image:o(62,"Vasisthasana"),description:"A side plank that builds core and arm strength. Excellent for core strength and muscle toning.",advantages:["Strengthens core","Builds arm strength","Tones muscles","Improves balance","Strengthens obliques","Burns calories"],disadvantages:["Avoid with wrist injuries","Not suitable with shoulder problems","May cause strain if held too long","Requires core strength"],difficulty:"Intermediate",duration:"20-40 seconds each side",subCategories:["Core Strength","Muscle Tone","Strength Building"]}],"age-groups":[{id:58,name:"\u0aa4\u0abe\u0aa1\u0abe\u0ab8\u0aa8 (Tadasana) - Mountain Pose",image:o(58,"Tadasana"),description:"A foundational standing pose perfect for all ages. Improves posture and balance. Safe for kids, teens, adults, and seniors.",advantages:["Improves posture","Strengthens thighs","Promotes balance","Safe for all ages","Easy to learn","Builds body awareness"],disadvantages:["May seem too simple","Requires focus","Keep feet grounded","Maintain alignment"],difficulty:"Beginner",duration:"30-60 seconds",subCategories:["Kids Yoga (5-12 years)","Teens Yoga (13-19 years)","Adults (20-50 years)","Seniors (50+ years)"]},{id:59,name:"\u0ab5\u0ac3\u0a95\u0acd\u0ab7\u0abe\u0ab8\u0aa8 (Vrikshasana) - Tree Pose",image:o(59,"Vrikshasana"),description:"A fun balancing pose perfect for kids and teens. Improves focus and balance. Can be modified for seniors.",advantages:["Improves balance","Strengthens legs","Enhances focus","Fun for kids","Builds confidence","Opens hips"],disadvantages:["Avoid with balance issues","Not suitable with knee injuries","May cause falls","Use wall support if needed"],difficulty:"Beginner",duration:"20-40 seconds each side",subCategories:["Kids Yoga (5-12 years)","Teens Yoga (13-19 years)","Adults (20-50 years)"]},{id:60,name:"\u0aac\u0abe\u0ab2\u0abe\u0ab8\u0aa8 (Balasana) - Child's Pose",image:o(60,"Balasana"),description:"A gentle resting pose suitable for all ages. Calms the mind and stretches the back. Perfect for kids and seniors.",advantages:["Calms the mind","Stretches back","Safe for all ages","Easy to do","Promotes relaxation","Reduces stress"],disadvantages:["Avoid with knee injuries","Not suitable during pregnancy","May cause discomfort with tight hips","Use props if needed"],difficulty:"Beginner",duration:"1-3 minutes",subCategories:["Kids Yoga (5-12 years)","Teens Yoga (13-19 years)","Adults (20-50 years)","Seniors (50+ years)"]},{id:61,name:"\u0aae\u0abe\u0ab0\u0acd\u0a9c\u0ab0\u0ac0\u0a86\u0ab8\u0aa8 (Marjariasana) - Cat-Cow Pose",image:o(61,"Marjariasana"),description:"A fun flowing movement perfect for kids. Warms up the spine and improves flexibility. Safe for all ages.",advantages:["Warms up spine","Improves flexibility","Fun for kids","Safe for all ages","Reduces stress","Easy to learn"],disadvantages:["Avoid with severe neck injuries","May cause discomfort with wrist issues","Not suitable during late pregnancy","Move slowly"],difficulty:"Beginner",duration:"1-2 minutes",subCategories:["Kids Yoga (5-12 years)","Teens Yoga (13-19 years)","Adults (20-50 years)","Seniors (50+ years)"]},{id:62,name:"\u0aad\u0ac1\u0a9c\u0a82\u0a97\u0abe\u0ab8\u0aa8 (Bhujangasana) - Cobra Pose",image:o(62,"Bhujangasana"),description:"A gentle backbend suitable for teens and adults. Strengthens the spine and opens the chest. Can be modified for seniors.",advantages:["Strengthens spine","Opens chest","Improves posture","Suitable for teens and adults","Stretches front body","Builds strength"],disadvantages:["Avoid with severe back injuries","Not suitable during pregnancy","May cause strain if done incorrectly","Keep it gentle for seniors"],difficulty:"Beginner",duration:"30-60 seconds",subCategories:["Teens Yoga (13-19 years)","Adults (20-50 years)","Seniors (50+ years)"]},{id:63,name:"\u0ab5\u0ac0\u0ab0\u0aad\u0aa6\u0acd\u0ab0\u0abe\u0ab8\u0aa8 II (Virabhadrasana II) - Warrior II",image:o(63,"Virabhadrasana II"),description:"A powerful standing pose perfect for teens and adults. Builds strength and stamina. Can be modified for seniors.",advantages:["Strengthens legs","Builds stamina","Improves balance","Suitable for teens and adults","Opens hips","Builds confidence"],disadvantages:["Avoid with knee injuries","Not suitable with high blood pressure","May cause strain if overdone","Use props for seniors"],difficulty:"Intermediate",duration:"30-60 seconds",subCategories:["Teens Yoga (13-19 years)","Adults (20-50 years)"]},{id:64,name:"\u0ab8\u0ac1\u0a96\u0abe\u0ab8\u0aa8 (Sukhasana) - Easy Pose",image:o(64,"Sukhasana"),description:"A comfortable seated pose perfect for all ages. Excellent for meditation and breathing exercises. Safe for kids and seniors.",advantages:["Comfortable for all ages","Easy to do","Improves posture","Calms the mind","Safe for kids and seniors","Enhances meditation"],disadvantages:["May cause discomfort with tight hips","Use props for support","Avoid with knee injuries","Keep spine straight"],difficulty:"Beginner",duration:"5-30 minutes",subCategories:["Kids Yoga (5-12 years)","Teens Yoga (13-19 years)","Adults (20-50 years)","Seniors (50+ years)"]},{id:65,name:"\u0a85\u0aa7\u0acb \u0aae\u0ac1\u0a96 \u0ab6\u0acd\u0ab5\u0abe\u0aa8\u0abe\u0ab8\u0aa8 (Adho Mukha Svanasana) - Downward-Facing Dog",image:o(65,"Adho Mukha Svanasana"),description:"An inversion suitable for teens and adults. Strengthens the entire body. Can be modified for seniors with props.",advantages:["Strengthens entire body","Stretches hamstrings","Suitable for teens and adults","Improves circulation","Calms the mind","Builds strength"],disadvantages:["Avoid with wrist injuries","Not suitable with high blood pressure","May cause strain with shoulder issues","Use props for seniors"],difficulty:"Beginner",duration:"30-60 seconds",subCategories:["Teens Yoga (13-19 years)","Adults (20-50 years)"]},{id:66,name:"\u0ab5\u0abf\u0aaa\u0ab0\u0ac0\u0aa4 \u0a95\u0ab0\u0aa3\u0ac0 (Viparita Karani) - Legs-Up-the-Wall Pose",image:o(66,"Viparita Karani"),description:"A gentle restorative pose perfect for seniors. Relieves fatigue and improves circulation. Safe and comfortable.",advantages:["Gentle and safe","Perfect for seniors","Relieves fatigue","Improves circulation","Reduces stress","No strain on joints"],disadvantages:["Avoid with eye pressure issues","Not suitable during menstruation","May cause discomfort with neck issues","Keep warm"],difficulty:"Beginner",duration:"5-15 minutes",subCategories:["Adults (20-50 years)","Seniors (50+ years)"]},{id:67,name:"\u0ab8\u0ac7\u0aa4\u0ac1 \u0aac\u0a82\u0aa7\u0abe\u0ab8\u0aa8 (Setu Bandhasana) - Bridge Pose",image:o(67,"Setu Bandhasana"),description:"A gentle backbend suitable for adults and seniors. Strengthens the back and opens the chest. Can be modified easily.",advantages:["Gentle backbend","Suitable for adults and seniors","Strengthens back","Opens chest","Improves flexibility","Can be modified"],disadvantages:["Avoid with neck injuries","Not suitable with severe back problems","Avoid during late pregnancy","Use props if needed"],difficulty:"Beginner",duration:"30-60 seconds",subCategories:["Adults (20-50 years)","Seniors (50+ years)"]},{id:68,name:"\u0aa4\u0acd\u0ab0\u0abf\u0a95\u0acb\u0aa3\u0abe\u0ab8\u0aa8 (Trikonasana) - Triangle Pose",image:o(68,"Trikonasana"),description:"A standing pose suitable for teens and adults. Improves flexibility and strength. Can be modified for seniors.",advantages:["Improves flexibility","Strengthens legs","Suitable for teens and adults","Opens hips","Improves balance","Can be modified"],disadvantages:["Avoid with low blood pressure","Not suitable with neck injuries","May cause dizziness","Use props for seniors"],difficulty:"Intermediate",duration:"30-60 seconds each side",subCategories:["Teens Yoga (13-19 years)","Adults (20-50 years)"]},{id:69,name:"\u0ab6\u0ab5\u0abe\u0ab8\u0aa8 (Shavasana) - Corpse Pose",image:o(69,"Shavasana"),description:"The ultimate relaxation pose perfect for all ages. Essential for recovery and relaxation. Safe for everyone.",advantages:["Perfect for all ages","Promotes relaxation","Reduces stress","Essential for recovery","Safe and comfortable","No physical strain"],disadvantages:["May cause sleepiness","Keep warm","Not suitable if feeling unwell","Practice in quiet environment"],difficulty:"Beginner",duration:"5-20 minutes",subCategories:["Kids Yoga (5-12 years)","Teens Yoga (13-19 years)","Adults (20-50 years)","Seniors (50+ years)"]},{id:70,name:"\u0ab8\u0ac2\u0ab0\u0acd\u0aaf \u0aa8\u0aae\u0ab8\u0acd\u0a95\u0abe\u0ab0 (Surya Namaskar) - Sun Salutation",image:o(70,"Surya Namaskar"),description:"A complete sequence perfect for teens and adults. Provides full-body workout. Can be simplified for seniors.",advantages:["Full-body workout","Suitable for teens and adults","Improves flexibility","Builds strength","Boosts energy","Can be modified"],disadvantages:["Avoid with severe heart conditions","Not recommended during pregnancy","May cause fatigue if overdone","Simplify for seniors"],difficulty:"Intermediate",duration:"5-10 minutes",subCategories:["Teens Yoga (13-19 years)","Adults (20-50 years)"]},{id:71,name:"\u0ab5\u0a9c\u0acd\u0ab0\u0abe\u0ab8\u0aa8 (Vajrasana) - Thunderbolt Pose",image:o(71,"Vajrasana"),description:"A seated pose suitable for all ages. Excellent for digestion and meditation. Safe and comfortable.",advantages:["Suitable for all ages","Improves digestion","Calms the mind","Safe and comfortable","Easy to maintain","Enhances meditation"],disadvantages:["Avoid with knee injuries","Not suitable with ankle problems","May cause discomfort initially","Use props if needed"],difficulty:"Beginner",duration:"5-30 minutes",subCategories:["Kids Yoga (5-12 years)","Teens Yoga (13-19 years)","Adults (20-50 years)","Seniors (50+ years)"]},{id:72,name:"\u0a85\u0a82\u0a9c\u0aa8\u0ac7\u0aaf\u0abe\u0ab8\u0aa8 (Anjaneyasana) - Low Lunge",image:o(72,"Anjaneyasana"),description:"A lunge pose suitable for teens and adults. Stretches hip flexors and strengthens legs. Can be modified for seniors.",advantages:["Stretches hip flexors","Strengthens legs","Suitable for teens and adults","Opens chest","Improves flexibility","Can be modified"],disadvantages:["Avoid with knee injuries","Not suitable with hip problems","May strain if overstretched","Use props for seniors"],difficulty:"Beginner",duration:"30-60 seconds each side",subCategories:["Teens Yoga (13-19 years)","Adults (20-50 years)"]}],women:[{id:73,name:"Baddha Konasana (Baddha Konasana) - Butterfly Pose",image:o(73,"Baddha Konasana"),description:"A seated pose that helps with PCOS and menstrual health. Stretches inner thighs and improves reproductive health.",advantages:["Helps with PCOS","Improves menstrual health","Stretches inner thighs","Stimulates reproductive organs","Improves flexibility","Calms the mind"],disadvantages:["Avoid with knee injuries","Not suitable with groin problems","May cause discomfort initially","Use props for support"],difficulty:"Beginner",duration:"1-5 minutes",subCategories:["PCOS","Menstrual Health","Hormonal Balance","Pelvic Health"]},{id:74,name:"Supta Baddha Konasana (Supta Baddha Konasana) - Reclining Bound Angle Pose",image:o(74,"Supta Baddha Konasana"),description:"A restorative pose that helps with PCOS and hormonal balance. Calms the nervous system and reduces stress.",advantages:["Helps with PCOS","Improves hormonal balance","Stretches inner thighs","Calms nervous system","Reduces stress","Improves circulation"],disadvantages:["Avoid with knee injuries","Not suitable with groin injuries","May cause discomfort with tight hips","Use props if needed"],difficulty:"Beginner",duration:"3-10 minutes",subCategories:["PCOS","Hormonal Balance","Menstrual Health","Pelvic Health"]},{id:75,name:"\u0ab5\u0abf\u0aaa\u0ab0\u0ac0\u0aa4 \u0a95\u0ab0\u0aa3\u0ac0 (Viparita Karani) - Legs-Up-the-Wall Pose",image:o(75,"Viparita Karani"),description:"A gentle inversion that helps with menstrual cramps and reduces stress. Excellent for pregnancy and postnatal recovery.",advantages:["Relieves menstrual cramps","Reduces stress","Gentle and safe","Improves circulation","Calms nervous system","Suitable for pregnancy (with modifications)"],disadvantages:["Avoid with eye pressure issues","Not suitable during active menstruation","May cause discomfort with neck issues","Avoid if feeling dizzy"],difficulty:"Beginner",duration:"5-15 minutes",subCategories:["Menstrual Health","Pregnancy Yoga","Postnatal Yoga","Hormonal Balance"]},{id:76,name:"\u0aae\u0abe\u0ab2\u0abe\u0ab8\u0aa8 (Malasana) - Garland Pose",image:o(76,"Malasana"),description:"A squatting pose that strengthens pelvic floor and helps with pregnancy. Excellent for pelvic health and hormonal balance.",advantages:["Strengthens pelvic floor","Helps with pregnancy","Opens hips","Improves pelvic health","Stretches groin","Aids in delivery preparation"],disadvantages:["Avoid with knee injuries","Not suitable with ankle problems","May cause discomfort with tight hips","Use props for support"],difficulty:"Beginner",duration:"30-60 seconds",subCategories:["Pregnancy Yoga","Pelvic Health","Hormonal Balance"]},{id:77,name:"Cat-Cow Pose (Cat-Cow Pose) - Marjariasana-Bitilasana",image:o(77,"Cat-Cow Pose"),description:"A gentle flowing movement safe for pregnancy. Relieves back pain and improves spinal flexibility. Perfect for all stages.",advantages:["Safe for pregnancy","Relieves back pain","Improves spinal flexibility","Gentle and safe","Reduces stress","Can be done throughout pregnancy"],disadvantages:["Avoid with severe neck injuries","May cause discomfort with wrist issues","Move slowly","Stop if any discomfort"],difficulty:"Beginner",duration:"1-2 minutes",subCategories:["Pregnancy Yoga","Postnatal Yoga","Menstrual Health"]},{id:78,name:"\u0aac\u0abe\u0ab2\u0abe\u0ab8\u0aa8 (Balasana) - Child's Pose",image:o(78,"Balasana"),description:"A restorative pose that helps with menstrual cramps and reduces stress. Can be modified for pregnancy.",advantages:["Relieves menstrual cramps","Reduces stress","Calms the mind","Stretches back","Promotes relaxation","Can be modified for pregnancy"],disadvantages:["Avoid with knee injuries","Not suitable during active menstruation","May cause discomfort with tight hips","Use props if needed"],difficulty:"Beginner",duration:"1-3 minutes",subCategories:["Menstrual Health","Pregnancy Yoga","Hormonal Balance"]},{id:79,name:"\u0ab8\u0ac7\u0aa4\u0ac1 \u0aac\u0a82\u0aa7\u0abe\u0ab8\u0aa8 (Setu Bandhasana) - Bridge Pose",image:o(79,"Setu Bandhasana"),description:"A gentle backbend that helps with hormonal balance and reduces stress. Excellent for menopause symptoms.",advantages:["Helps with hormonal balance","Reduces stress","Opens chest","Strengthens back","Helps with menopause","Improves mood"],disadvantages:["Avoid with neck injuries","Not suitable with severe back problems","Avoid during late pregnancy","Keep it gentle"],difficulty:"Beginner",duration:"30-60 seconds",subCategories:["Menopause","Hormonal Balance","Postnatal Yoga"]},{id:80,name:"Supta Matsyendrasana (Supta Matsyendrasana) - Supine Spinal Twist",image:o(80,"Supta Matsyendrasana"),description:"A gentle twist that helps with menstrual discomfort and improves digestion. Safe for most stages.",advantages:["Relieves menstrual discomfort","Improves digestion","Stretches spine","Calms nervous system","Reduces stress","Safe and gentle"],disadvantages:["Avoid with severe back injuries","Not suitable during active pregnancy","May cause discomfort with knee issues","Keep shoulders on ground"],difficulty:"Beginner",duration:"30-60 seconds each side",subCategories:["Menstrual Health","Hormonal Balance","Postnatal Yoga"]},{id:81,name:"\u0ab5\u0abf\u0aaa\u0ab0\u0ac0\u0aa4 \u0a95\u0ab0\u0aa3\u0ac0 (Viparita Karani) - Legs-Up-the-Wall Pose",image:o(81,"Viparita Karani"),description:"A restorative pose perfect for postnatal recovery. Reduces swelling and promotes healing. Excellent for new mothers.",advantages:["Perfect for postnatal recovery","Reduces swelling","Promotes healing","Gentle and safe","Reduces stress","Improves circulation"],disadvantages:["Avoid with eye pressure issues","Not suitable during active bleeding","May cause discomfort with neck issues","Keep warm"],difficulty:"Beginner",duration:"5-15 minutes",subCategories:["Postnatal Yoga","Hormonal Balance","Pelvic Health"]},{id:82,name:"\u0a85\u0aa7\u0acb \u0aae\u0ac1\u0a96 \u0ab6\u0acd\u0ab5\u0abe\u0aa8\u0abe\u0ab8\u0aa8 (Adho Mukha Svanasana) - Downward-Facing Dog",image:o(82,"Adho Mukha Svanasana"),description:"An inversion that helps with hormonal balance and reduces stress. Can be modified for pregnancy and postnatal.",advantages:["Helps with hormonal balance","Reduces stress","Strengthens body","Improves circulation","Can be modified","Calms the mind"],disadvantages:["Avoid with wrist injuries","Not suitable with high blood pressure","Modify for pregnancy","Use props if needed"],difficulty:"Beginner",duration:"30-60 seconds",subCategories:["Hormonal Balance","Pregnancy Yoga","Postnatal Yoga"]},{id:83,name:"\u0ab8\u0ac1\u0a96\u0abe\u0ab8\u0aa8 (Sukhasana) - Easy Pose",image:o(83,"Sukhasana"),description:"A comfortable seated pose for meditation and breathing. Excellent for hormonal balance and stress relief.",advantages:["Comfortable and safe","Improves hormonal balance","Calms the mind","Reduces stress","Easy to maintain","Enhances meditation"],disadvantages:["May cause discomfort with tight hips","Use props for support","Avoid with knee injuries","Keep spine straight"],difficulty:"Beginner",duration:"5-30 minutes",subCategories:["Hormonal Balance","Menstrual Health","Menopause"]},{id:84,name:"\u0ab6\u0ab5\u0abe\u0ab8\u0aa8 (Shavasana) - Corpse Pose",image:o(84,"Shavasana"),description:"The ultimate relaxation pose essential for women's health. Reduces stress and promotes hormonal balance.",advantages:["Reduces stress","Promotes hormonal balance","Essential for recovery","Reduces anxiety","Improves sleep","Calms entire system"],disadvantages:["May cause sleepiness","Keep warm","Not suitable if feeling unwell","Practice in quiet environment"],difficulty:"Beginner",duration:"5-20 minutes",subCategories:["Hormonal Balance","Menstrual Health","Menopause","Postnatal Yoga"]},{id:85,name:"Uttanasana (Uttanasana) - Standing Forward Bend",image:o(85,"Uttanasana"),description:"A forward fold that helps with menstrual cramps and reduces stress. Can be modified for pregnancy.",advantages:["Relieves menstrual cramps","Reduces stress","Stretches back","Calms the mind","Can be modified","Improves circulation"],disadvantages:["Avoid with severe back injuries","Not suitable with high blood pressure","Modify for pregnancy","May cause dizziness"],difficulty:"Beginner",duration:"30-60 seconds",subCategories:["Menstrual Health","Hormonal Balance","Pregnancy Yoga"]},{id:86,name:"\u0ab5\u0ac0\u0ab0\u0abe\u0ab8\u0aa8 (Virasana) - Hero Pose",image:o(86,"Virasana"),description:"A seated pose that helps with pelvic health and improves digestion. Excellent for hormonal balance.",advantages:["Improves pelvic health","Helps with hormonal balance","Improves digestion","Stretches thighs","Calms the mind","Enhances meditation"],disadvantages:["Avoid with knee injuries","Not suitable with ankle problems","May cause discomfort initially","Use props if needed"],difficulty:"Beginner",duration:"5-30 minutes",subCategories:["Pelvic Health","Hormonal Balance","Menstrual Health"]},{id:87,name:"Anulom Vilom Pranayama (Anulom Vilom Pranayama) - Alternate Nostril Breathing",image:o(87,"Anulom Vilom Pranayama"),description:"A balancing breathing technique that helps with hormonal balance and reduces stress. Excellent for menopause.",advantages:["Helps with hormonal balance","Reduces stress","Balances emotions","Helps with menopause","Calms the mind","Improves focus"],disadvantages:["Avoid with blocked nostrils","Not suitable during illness","May cause dizziness if done incorrectly","Requires proper technique"],difficulty:"Beginner",duration:"5-10 minutes",subCategories:["Hormonal Balance","Menopause","Menstrual Health"]}],lifestyle:[{id:88,name:"Desk Yoga - Seated Cat-Cow (Desk Yoga - Seated Cat-Cow) - Desk Yoga - Seated Cat-Cow",image:o(88,"Desk Yoga - Seated Cat-Cow"),description:"A seated version of cat-cow perfect for office workers. Relieves back and neck tension from desk work.",advantages:["Perfect for office workers","Relieves back tension","Relieves neck pain","Can be done at desk","Quick and easy","Improves posture"],disadvantages:["May look unusual at office","Requires some space","Move slowly","Stop if any discomfort"],difficulty:"Beginner",duration:"1-2 minutes",subCategories:["Office Workers","Desk Yoga","Daily Routine","Quick Sessions"]},{id:89,name:"Desk Yoga - Seated Spinal Twist (Desk Yoga - Seated Spinal Twist) - Desk Yoga - Seated Spinal Twist",image:o(89,"Desk Yoga - Seated Spinal Twist"),description:"A seated twist perfect for office breaks. Relieves back stiffness and improves spinal mobility.",advantages:["Perfect for office","Relieves back stiffness","Improves spinal mobility","Quick to do","Can be done at desk","Reduces fatigue"],disadvantages:["Avoid with severe back injuries","Move slowly","Keep spine straight","Stop if any pain"],difficulty:"Beginner",duration:"30 seconds each side",subCategories:["Office Workers","Desk Yoga","Daily Routine","Quick Sessions"]},{id:90,name:"\u0ab8\u0ac2\u0ab0\u0acd\u0aaf \u0aa8\u0aae\u0ab8\u0acd\u0a95\u0abe\u0ab0 (Surya Namaskar) - Sun Salutation",image:o(90,"Surya Namaskar"),description:"A complete sequence perfect for morning routine. Energizes the body and prepares for the day. Excellent for athletes.",advantages:["Perfect for morning","Energizes body","Full-body workout","Excellent for athletes","Boosts energy","Improves flexibility"],disadvantages:["Avoid with severe heart conditions","Not recommended during pregnancy","May cause fatigue if overdone","Requires some space"],difficulty:"Intermediate",duration:"5-10 minutes",subCategories:["Morning Yoga","Athletes","Daily Routine"]},{id:91,name:"\u0ab5\u0abf\u0aaa\u0ab0\u0ac0\u0aa4 \u0a95\u0ab0\u0aa3\u0ac0 (Viparita Karani) - Legs-Up-the-Wall Pose",image:o(91,"Viparita Karani"),description:"A restorative pose perfect for evening routine. Relieves fatigue and promotes relaxation. Excellent after work.",advantages:["Perfect for evening","Relieves fatigue","Promotes relaxation","Reduces stress","Improves sleep","No physical strain"],disadvantages:["Avoid with eye pressure issues","Not suitable during menstruation","May cause discomfort with neck issues","Keep warm"],difficulty:"Beginner",duration:"5-15 minutes",subCategories:["Evening Yoga","Daily Routine","Office Workers"]},{id:92,name:"\u0aa4\u0abe\u0aa1\u0abe\u0ab8\u0aa8 (Tadasana) - Mountain Pose",image:o(92,"Tadasana"),description:"A foundational pose perfect for daily routine. Improves posture and body awareness. Can be done anywhere.",advantages:["Can be done anywhere","Improves posture","Quick and easy","Perfect for daily routine","Builds body awareness","No space required"],disadvantages:["May seem too simple","Requires focus","Keep feet grounded","Maintain alignment"],difficulty:"Beginner",duration:"30-60 seconds",subCategories:["Daily Routine","Quick Sessions","Office Workers","Travel Yoga"]},{id:93,name:"\u0aac\u0abe\u0ab2\u0abe\u0ab8\u0aa8 (Balasana) - Child's Pose",image:o(93,"Balasana"),description:"A restorative pose perfect for quick breaks. Calms the mind and relieves stress. Excellent for travel.",advantages:["Perfect for quick breaks","Calms the mind","Relieves stress","Can be done anywhere","Quick and easy","Excellent for travel"],disadvantages:["Avoid with knee injuries","Not suitable during pregnancy","May cause discomfort with tight hips","Use props if needed"],difficulty:"Beginner",duration:"1-3 minutes",subCategories:["Quick Sessions","Travel Yoga","Daily Routine","Office Workers"]},{id:94,name:"\u0a85\u0aa7\u0acb \u0aae\u0ac1\u0a96 \u0ab6\u0acd\u0ab5\u0abe\u0aa8\u0abe\u0ab8\u0aa8 (Adho Mukha Svanasana) - Downward-Facing Dog",image:o(94,"Adho Mukha Svanasana"),description:"An inversion perfect for athletes. Strengthens the entire body and improves flexibility. Excellent for warm-up.",advantages:["Perfect for athletes","Strengthens entire body","Improves flexibility","Excellent warm-up","Energizes body","Improves circulation"],disadvantages:["Avoid with wrist injuries","Not suitable with high blood pressure","May cause strain with shoulder issues","Requires some space"],difficulty:"Beginner",duration:"30-60 seconds",subCategories:["Athletes","Morning Yoga","Daily Routine"]},{id:95,name:"\u0ab5\u0ac0\u0ab0\u0aad\u0aa6\u0acd\u0ab0\u0abe\u0ab8\u0aa8 II (Virabhadrasana II) - Warrior II",image:o(95,"Virabhadrasana II"),description:"A powerful standing pose excellent for athletes. Builds strength and stamina. Perfect for training.",advantages:["Excellent for athletes","Builds strength","Builds stamina","Improves balance","Strengthens legs","Perfect for training"],disadvantages:["Avoid with knee injuries","Not suitable with high blood pressure","May cause strain if overdone","Requires good physical condition"],difficulty:"Intermediate",duration:"30-60 seconds",subCategories:["Athletes","Daily Routine","Morning Yoga"]},{id:96,name:"\u0ab6\u0ab5\u0abe\u0ab8\u0aa8 (Shavasana) - Corpse Pose",image:o(96,"Shavasana"),description:"The ultimate relaxation pose perfect for evening routine. Essential for recovery and rest. Excellent after work.",advantages:["Perfect for evening","Promotes relaxation","Essential for recovery","Reduces stress","Improves sleep","No physical effort"],disadvantages:["May cause sleepiness","Keep warm","Not suitable if feeling unwell","Practice in quiet environment"],difficulty:"Beginner",duration:"5-20 minutes",subCategories:["Evening Yoga","Daily Routine","Office Workers"]},{id:97,name:"\u0aae\u0abe\u0ab0\u0acd\u0a9c\u0ab0\u0ac0\u0a86\u0ab8\u0aa8 (Marjariasana) - Cat-Cow Pose",image:o(97,"Marjariasana"),description:"A gentle flowing movement perfect for morning routine. Warms up the spine and energizes the body.",advantages:["Perfect for morning","Warms up spine","Energizes body","Quick and easy","Improves flexibility","Reduces stiffness"],disadvantages:["Avoid with severe neck injuries","May cause discomfort with wrist issues","Move slowly","Stop if any discomfort"],difficulty:"Beginner",duration:"1-2 minutes",subCategories:["Morning Yoga","Daily Routine","Quick Sessions","Office Workers"]},{id:98,name:"\u0ab8\u0ac1\u0a96\u0abe\u0ab8\u0aa8 (Sukhasana) - Easy Pose",image:o(98,"Sukhasana"),description:"A comfortable seated pose perfect for travel. Can be done anywhere. Excellent for meditation and breathing.",advantages:["Perfect for travel","Can be done anywhere","Comfortable","Easy to maintain","Enhances meditation","No space required"],disadvantages:["May cause discomfort with tight hips","Use props for support","Avoid with knee injuries","Keep spine straight"],difficulty:"Beginner",duration:"5-30 minutes",subCategories:["Travel Yoga","Daily Routine","Quick Sessions"]},{id:99,name:"Anulom Vilom Pranayama (Anulom Vilom Pranayama) - Alternate Nostril Breathing",image:o(99,"Anulom Vilom Pranayama"),description:"A breathing technique perfect for quick sessions. Calms the mind and reduces stress. Can be done anywhere.",advantages:["Perfect for quick sessions","Calms the mind","Reduces stress","Can be done anywhere","Quick and effective","No space required"],disadvantages:["Avoid with blocked nostrils","Not suitable during illness","May cause dizziness if done incorrectly","Requires proper technique"],difficulty:"Beginner",duration:"5-10 minutes",subCategories:["Quick Sessions","Daily Routine","Travel Yoga","Office Workers"]},{id:100,name:"Utkatasana (Utkatasana) - Chair Pose",image:o(100,"Utkatasana"),description:"A strengthening pose perfect for athletes. Builds leg strength and endurance. Excellent for training.",advantages:["Perfect for athletes","Builds leg strength","Builds endurance","Improves balance","Tones muscles","Excellent for training"],disadvantages:["Avoid with knee injuries","Not suitable with low blood pressure","May cause strain if held too long","Can be challenging"],difficulty:"Intermediate",duration:"30-60 seconds",subCategories:["Athletes","Daily Routine","Morning Yoga"]},{id:101,name:"\u0aa4\u0acd\u0ab0\u0abf\u0a95\u0acb\u0aa3\u0abe\u0ab8\u0aa8 (Trikonasana) - Triangle Pose",image:o(101,"Trikonasana"),description:"A standing pose perfect for daily routine. Improves flexibility and strength. Can be done in small spaces.",advantages:["Perfect for daily routine","Improves flexibility","Strengthens legs","Can be done in small spaces","Improves balance","Opens hips"],disadvantages:["Avoid with low blood pressure","Not suitable with neck injuries","May cause dizziness","Requires some space"],difficulty:"Intermediate",duration:"30-60 seconds each side",subCategories:["Daily Routine","Morning Yoga","Athletes"]},{id:102,name:"\u0ab5\u0abf\u0aaa\u0ab0\u0ac0\u0aa4 \u0a95\u0ab0\u0aa3\u0ac0 (Viparita Karani) - Legs-Up-the-Wall Pose",image:o(102,"Viparita Karani"),description:"A restorative pose perfect for evening routine. Relieves fatigue and promotes sleep. Excellent after long day.",advantages:["Perfect for evening","Relieves fatigue","Promotes sleep","Reduces stress","No physical strain","Excellent after work"],disadvantages:["Avoid with eye pressure issues","Not suitable during menstruation","May cause discomfort with neck issues","Keep warm"],difficulty:"Beginner",duration:"5-15 minutes",subCategories:["Evening Yoga","Daily Routine","Office Workers"]}],meditation:[{id:103,name:"Padmasana (Padmasana) - Lotus Pose",image:o(103,"Padmasana"),description:"The classic meditation pose that promotes mental clarity and focus. Ideal for deep meditation practice.",advantages:["Perfect for meditation","Improves focus","Calms the mind","Opens hips","Improves posture","Enhances concentration"],disadvantages:["Requires flexible hips","Can strain knees if forced","Not suitable for knee injuries","May cause ankle discomfort","Difficult for beginners"],difficulty:"Intermediate",duration:"5-30 minutes",subCategories:["Meditation","Mindfulness","Focus & Concentration","Chakra Balancing"]},{id:104,name:"\u0ab8\u0ac1\u0a96\u0abe\u0ab8\u0aa8 (Sukhasana) - Easy Pose",image:o(104,"Sukhasana"),description:"A comfortable seated pose perfect for beginners. Excellent for meditation and breathing exercises.",advantages:["Perfect for beginners","Comfortable","Easy to maintain","Enhances meditation","Calms the mind","Improves focus"],disadvantages:["May cause discomfort with tight hips","Use props for support","Avoid with knee injuries","Keep spine straight"],difficulty:"Beginner",duration:"5-30 minutes",subCategories:["Meditation","Mindfulness","Breathing Exercises","Relaxation Techniques"]},{id:105,name:"\u0ab5\u0ac0\u0ab0\u0abe\u0ab8\u0aa8 (Virasana) - Hero Pose",image:o(105,"Virasana"),description:"A seated pose that calms the mind and improves focus. Excellent for meditation and pranayama practice.",advantages:["Calms the mind","Improves focus","Enhances meditation","Stretches thighs","Improves digestion","Reduces stress"],disadvantages:["Avoid with knee injuries","Not suitable with ankle problems","May cause discomfort initially","Use props if needed"],difficulty:"Beginner",duration:"5-30 minutes",subCategories:["Meditation","Mindfulness","Breathing Exercises","Chakra Balancing"]},{id:106,name:"Anulom Vilom Pranayama (Anulom Vilom Pranayama) - Alternate Nostril Breathing",image:o(106,"Anulom Vilom Pranayama"),description:"A balancing breathing technique that calms the mind and enhances meditation. Excellent for chakra balancing.",advantages:["Calms the mind","Enhances meditation","Balances chakras","Improves focus","Reduces stress","Balances nervous system"],disadvantages:["Avoid with blocked nostrils","Not suitable during illness","May cause dizziness if done incorrectly","Requires proper technique"],difficulty:"Beginner",duration:"5-10 minutes",subCategories:["Breathing Exercises","Chakra Balancing","Meditation","Mindfulness"]},{id:107,name:"Bhramari Pranayama (Bhramari Pranayama) - Bee Breath",image:o(107,"Bhramari Pranayama"),description:"A calming breathing technique that promotes deep relaxation. Excellent for meditation and energy healing.",advantages:["Promotes deep relaxation","Calms the mind","Enhances meditation","Reduces stress","Improves focus","Energy healing"],disadvantages:["Avoid with ear infections","Not suitable with severe sinus issues","May cause discomfort initially","Practice in quiet environment"],difficulty:"Beginner",duration:"5-10 minutes",subCategories:["Breathing Exercises","Meditation","Relaxation Techniques","Energy Healing"]},{id:108,name:"Ujjayi Pranayama (Ujjayi Pranayama) - Victorious Breath",image:o(108,"Ujjayi Pranayama"),description:"A calming breathing technique that enhances focus and meditation. Excellent for mindfulness practice.",advantages:["Enhances focus","Improves meditation","Calms the mind","Reduces stress","Enhances concentration","Mindfulness practice"],disadvantages:["Avoid with high blood pressure","Not suitable with heart conditions","May cause dizziness","Requires proper technique"],difficulty:"Beginner",duration:"5-10 minutes",subCategories:["Breathing Exercises","Mindfulness","Meditation","Focus & Concentration"]},{id:109,name:"\u0ab6\u0ab5\u0abe\u0ab8\u0aa8 (Shavasana) - Corpse Pose",image:o(109,"Shavasana"),description:"The ultimate relaxation pose essential for meditation practice. Promotes deep relaxation and energy healing.",advantages:["Essential for meditation","Promotes deep relaxation","Energy healing","Reduces stress","Calms entire system","Enhances recovery"],disadvantages:["May cause sleepiness","Keep warm","Not suitable if feeling unwell","Practice in quiet environment"],difficulty:"Beginner",duration:"5-20 minutes",subCategories:["Meditation","Relaxation Techniques","Energy Healing","Chakra Balancing"]},{id:110,name:"\u0ab5\u0abf\u0aaa\u0ab0\u0ac0\u0aa4 \u0a95\u0ab0\u0aa3\u0ac0 (Viparita Karani) - Legs-Up-the-Wall Pose",image:o(110,"Viparita Karani"),description:"A restorative pose that calms the nervous system. Excellent for meditation preparation and relaxation.",advantages:["Calms nervous system","Prepares for meditation","Promotes relaxation","Reduces stress","Improves focus","Energy healing"],disadvantages:["Avoid with eye pressure issues","Not suitable during menstruation","May cause discomfort with neck issues","Keep warm"],difficulty:"Beginner",duration:"5-15 minutes",subCategories:["Meditation","Relaxation Techniques","Energy Healing","Chakra Balancing"]},{id:111,name:"Yoga Nidra (Yoga Nidra) - Yogic Sleep",image:o(111,"Yoga Nidra"),description:"A deep relaxation practice that promotes meditation and energy healing. Excellent for chakra balancing.",advantages:["Deep relaxation","Promotes meditation","Energy healing","Chakra balancing","Reduces stress","Enhances recovery"],disadvantages:["May cause deep sleep","Practice in quiet environment","Not suitable if very tired","Keep warm"],difficulty:"Beginner",duration:"20-45 minutes",subCategories:["Meditation","Relaxation Techniques","Energy Healing","Chakra Balancing"]},{id:112,name:"Kapalbhati Pranayama (Kapalbhati Pranayama) - Skull Shining Breath",image:o(112,"Kapalbhati Pranayama"),description:"A cleansing breathing technique that enhances focus and meditation. Excellent for chakra balancing.",advantages:["Enhances focus","Improves meditation","Chakra balancing","Cleanses system","Boosts energy","Improves concentration"],disadvantages:["Avoid with high blood pressure","Not suitable with heart problems","Avoid during pregnancy","May cause dizziness","Not for beginners"],difficulty:"Intermediate",duration:"2-5 minutes",subCategories:["Breathing Exercises","Chakra Balancing","Meditation","Energy Healing"]},{id:113,name:"Nadi Shodhana (Nadi Shodhana) - Alternate Nostril Breathing",image:o(113,"Nadi Shodhana"),description:"A balancing breathing technique perfect for meditation. Balances chakras and enhances energy healing.",advantages:["Perfect for meditation","Balances chakras","Energy healing","Calms the mind","Enhances focus","Balances nervous system"],disadvantages:["Avoid with blocked nostrils","Not suitable during illness","May cause dizziness if done incorrectly","Requires proper technique"],difficulty:"Beginner",duration:"5-10 minutes",subCategories:["Breathing Exercises","Chakra Balancing","Meditation","Energy Healing"]},{id:114,name:"Sitali Pranayama (Sitali Pranayama) - Cooling Breath",image:o(114,"Sitali Pranayama"),description:"A cooling breathing technique that calms the mind and enhances meditation. Excellent for relaxation.",advantages:["Calms the mind","Enhances meditation","Promotes relaxation","Cools the body","Reduces stress","Improves focus"],disadvantages:["Avoid in cold weather","Not suitable with respiratory issues","May cause discomfort initially","Practice in comfortable temperature"],difficulty:"Beginner",duration:"5-10 minutes",subCategories:["Breathing Exercises","Relaxation Techniques","Meditation","Mindfulness"]},{id:115,name:"Bhastrika Pranayama (Bhastrika Pranayama) - Bellows Breath",image:o(115,"Bhastrika Pranayama"),description:"A powerful breathing technique that enhances energy and meditation. Excellent for chakra balancing.",advantages:["Enhances energy","Improves meditation","Chakra balancing","Boosts energy","Improves focus","Energy healing"],disadvantages:["Avoid with high blood pressure","Not suitable with heart conditions","May cause dizziness","Avoid during pregnancy","Not for beginners"],difficulty:"Intermediate",duration:"2-5 minutes",subCategories:["Breathing Exercises","Chakra Balancing","Energy Healing","Meditation"]},{id:116,name:"\u0ab5\u0a9c\u0acd\u0ab0\u0abe\u0ab8\u0aa8 (Vajrasana) - Thunderbolt Pose",image:o(116,"Vajrasana"),description:"A seated pose perfect for meditation and pranayama. Calms the mind and enhances focus.",advantages:["Perfect for meditation","Calms the mind","Enhances focus","Improves digestion","Strengthens thighs","Aids in pranayama"],disadvantages:["Avoid with knee injuries","Not suitable with ankle problems","May cause discomfort initially","Use props if needed"],difficulty:"Beginner",duration:"5-30 minutes",subCategories:["Meditation","Breathing Exercises","Mindfulness","Chakra Balancing"]},{id:117,name:"Ardha Padmasana (Ardha Padmasana) - Half Lotus Pose",image:o(117,"Ardha Padmasana"),description:"A modified lotus pose perfect for meditation. Easier than full lotus but still effective for practice.",advantages:["Perfect for meditation","Easier than full lotus","Improves focus","Opens hips","Improves posture","Enhances concentration"],disadvantages:["Requires some hip flexibility","Can strain knees if forced","Not suitable for knee injuries","May cause discomfort initially"],difficulty:"Intermediate",duration:"5-30 minutes",subCategories:["Meditation","Mindfulness","Focus & Concentration","Chakra Balancing"]}],programs:[{id:118,name:"\u0aa4\u0abe\u0aa1\u0abe\u0ab8\u0aa8 (Tadasana) - Mountain Pose",image:o(118,"Tadasana"),description:"A foundational pose perfect for beginner courses. Improves posture and body awareness. Essential for all programs.",advantages:["Perfect for beginners","Improves posture","Builds foundation","Essential for all programs","Easy to learn","Builds body awareness"],disadvantages:["May seem too simple","Requires focus","Keep feet grounded","Maintain alignment"],difficulty:"Beginner",duration:"30-60 seconds",subCategories:["Beginner Course","Online Programs","Offline Classes","7-Day Challenge"]},{id:119,name:"\u0ab8\u0ac2\u0ab0\u0acd\u0aaf \u0aa8\u0aae\u0ab8\u0acd\u0a95\u0abe\u0ab0 (Surya Namaskar) - Sun Salutation",image:o(119,"Surya Namaskar"),description:"A complete sequence perfect for 7-day and 30-day challenges. Provides full-body workout and transformation.",advantages:["Perfect for challenges","Full-body workout","Transformation program","Improves flexibility","Builds strength","Boosts energy"],disadvantages:["Avoid with severe heart conditions","Not recommended during pregnancy","May cause fatigue if overdone","Requires good physical condition"],difficulty:"Intermediate",duration:"5-10 minutes",subCategories:["7-Day Challenge","30-Day Transformation","Online Programs","Offline Classes"]},{id:120,name:"Virabhadrasana Series (Virabhadrasana Series) - Warrior Poses",image:o(120,"Virabhadrasana Series"),description:"A series of warrior poses perfect for advanced training. Builds strength and stamina. Excellent for transformation programs.",advantages:["Perfect for advanced training","Builds strength","Builds stamina","Transformation program","Improves balance","Strengthens entire body"],disadvantages:["Avoid with knee injuries","Not suitable with high blood pressure","May cause strain if overdone","Requires good physical condition"],difficulty:"Intermediate",duration:"30-60 seconds each",subCategories:["Advanced Training","30-Day Transformation","Offline Classes"]},{id:121,name:"\u0aac\u0abe\u0ab2\u0abe\u0ab8\u0aa8 (Balasana) - Child's Pose",image:o(121,"Balasana"),description:"A restorative pose essential for all programs. Promotes recovery and relaxation. Perfect for beginner courses.",advantages:["Essential for all programs","Perfect for beginners","Promotes recovery","Promotes relaxation","Calms the mind","Reduces stress"],disadvantages:["Avoid with knee injuries","Not suitable during pregnancy","May cause discomfort with tight hips","Use props if needed"],difficulty:"Beginner",duration:"1-3 minutes",subCategories:["Beginner Course","Online Programs","Offline Classes","7-Day Challenge"]},{id:122,name:"\u0a85\u0aa7\u0acb \u0aae\u0ac1\u0a96 \u0ab6\u0acd\u0ab5\u0abe\u0aa8\u0abe\u0ab8\u0aa8 (Adho Mukha Svanasana) - Downward-Facing Dog",image:o(122,"Adho Mukha Svanasana"),description:"An inversion perfect for online and offline programs. Strengthens entire body and improves flexibility.",advantages:["Perfect for programs","Strengthens entire body","Improves flexibility","Energizes body","Improves circulation","Calms the mind"],disadvantages:["Avoid with wrist injuries","Not suitable with high blood pressure","May cause strain with shoulder issues","Requires some space"],difficulty:"Beginner",duration:"30-60 seconds",subCategories:["Online Programs","Offline Classes","7-Day Challenge","30-Day Transformation"]},{id:123,name:"\u0aad\u0ac1\u0a9c\u0a82\u0a97\u0abe\u0ab8\u0aa8 (Bhujangasana) - Cobra Pose",image:o(123,"Bhujangasana"),description:"A gentle backbend perfect for beginner courses. Strengthens spine and opens chest. Essential foundation pose.",advantages:["Perfect for beginners","Essential foundation","Strengthens spine","Opens chest","Improves posture","Easy to learn"],disadvantages:["Avoid with severe back injuries","Not suitable during pregnancy","May cause strain if done incorrectly","Keep it gentle"],difficulty:"Beginner",duration:"30-60 seconds",subCategories:["Beginner Course","Online Programs","Offline Classes","7-Day Challenge"]},{id:124,name:"\u0aa4\u0acd\u0ab0\u0abf\u0a95\u0acb\u0aa3\u0abe\u0ab8\u0aa8 (Trikonasana) - Triangle Pose",image:o(124,"Trikonasana"),description:"A standing pose perfect for transformation programs. Improves flexibility and strength. Excellent for challenges.",advantages:["Perfect for transformation","Improves flexibility","Strengthens legs","Excellent for challenges","Improves balance","Opens hips"],disadvantages:["Avoid with low blood pressure","Not suitable with neck injuries","May cause dizziness","Requires some flexibility"],difficulty:"Intermediate",duration:"30-60 seconds each side",subCategories:["30-Day Transformation","Advanced Training","Offline Classes"]},{id:125,name:"Navasana (Navasana) - Boat Pose",image:o(125,"Navasana"),description:"A core strengthening pose perfect for advanced training. Tones abdominal muscles and builds strength.",advantages:["Perfect for advanced training","Strengthens core","Tones muscles","Builds strength","Improves balance","Transformation program"],disadvantages:["Avoid with lower back injuries","Not suitable during pregnancy","May cause strain if forced","Requires core strength"],difficulty:"Intermediate",duration:"20-40 seconds",subCategories:["Advanced Training","30-Day Transformation","Offline Classes"]},{id:126,name:"\u0ab6\u0ab5\u0abe\u0ab8\u0aa8 (Shavasana) - Corpse Pose",image:o(126,"Shavasana"),description:"The ultimate relaxation pose essential for all programs. Promotes recovery and deep relaxation.",advantages:["Essential for all programs","Promotes recovery","Deep relaxation","Reduces stress","Calms entire system","Enhances transformation"],disadvantages:["May cause sleepiness","Keep warm","Not suitable if feeling unwell","Practice in quiet environment"],difficulty:"Beginner",duration:"5-20 minutes",subCategories:["Online Programs","Offline Classes","7-Day Challenge","30-Day Transformation","Beginner Course","Advanced Training"]},{id:127,name:"\u0ab5\u0ac3\u0a95\u0acd\u0ab7\u0abe\u0ab8\u0aa8 (Vrikshasana) - Tree Pose",image:o(127,"Vrikshasana"),description:"A balancing pose perfect for beginner courses. Improves focus and balance. Fun and engaging.",advantages:["Perfect for beginners","Fun and engaging","Improves balance","Enhances focus","Builds confidence","Easy to learn"],disadvantages:["Avoid with balance issues","Not suitable with knee injuries","May cause falls","Use wall support if needed"],difficulty:"Beginner",duration:"20-40 seconds each side",subCategories:["Beginner Course","Online Programs","Offline Classes","7-Day Challenge"]},{id:128,name:"Chaturanga Dandasana (Chaturanga Dandasana) - Four-Limbed Staff Pose",image:o(128,"Chaturanga Dandasana"),description:"A challenging pose perfect for advanced training. Builds upper body and core strength. Excellent for transformation.",advantages:["Perfect for advanced training","Builds strength","Transformation program","Tones entire body","Builds endurance","Challenging and rewarding"],disadvantages:["Requires significant strength","Avoid with wrist injuries","Not suitable with shoulder problems","Very challenging","Not for beginners"],difficulty:"Advanced",duration:"10-30 seconds",subCategories:["Advanced Training","30-Day Transformation","Offline Classes"]},{id:129,name:"Utkatasana (Utkatasana) - Chair Pose",image:o(129,"Utkatasana"),description:"A strengthening pose perfect for challenges and transformation programs. Builds leg strength and endurance.",advantages:["Perfect for challenges","Builds strength","Transformation program","Improves balance","Tones muscles","Builds endurance"],disadvantages:["Avoid with knee injuries","Not suitable with low blood pressure","May cause strain if held too long","Can be challenging"],difficulty:"Intermediate",duration:"30-60 seconds",subCategories:["7-Day Challenge","30-Day Transformation","Online Programs","Offline Classes"]},{id:130,name:"\u0ab8\u0ac7\u0aa4\u0ac1 \u0aac\u0a82\u0aa7\u0abe\u0ab8\u0aa8 (Setu Bandhasana) - Bridge Pose",image:o(130,"Setu Bandhasana"),description:"A gentle backbend perfect for beginner courses and online programs. Strengthens back and opens chest.",advantages:["Perfect for beginners","Online program friendly","Strengthens back","Opens chest","Improves flexibility","Easy to learn"],disadvantages:["Avoid with neck injuries","Not suitable with severe back problems","Avoid during late pregnancy","Keep it gentle"],difficulty:"Beginner",duration:"30-60 seconds",subCategories:["Beginner Course","Online Programs","Offline Classes","7-Day Challenge"]},{id:131,name:"\u0aae\u0abe\u0ab0\u0acd\u0a9c\u0ab0\u0ac0\u0a86\u0ab8\u0aa8 (Marjariasana) - Cat-Cow Pose",image:o(131,"Marjariasana"),description:"A gentle flowing movement perfect for all programs. Warms up the spine and improves flexibility.",advantages:["Perfect for all programs","Warms up spine","Improves flexibility","Easy to learn","Reduces stiffness","Safe for everyone"],disadvantages:["Avoid with severe neck injuries","May cause discomfort with wrist issues","Move slowly","Stop if any discomfort"],difficulty:"Beginner",duration:"1-2 minutes",subCategories:["Beginner Course","Online Programs","Offline Classes","7-Day Challenge","30-Day Transformation"]},{id:132,name:"\u0ab5\u0abf\u0aaa\u0ab0\u0ac0\u0aa4 \u0a95\u0ab0\u0aa3\u0ac0 (Viparita Karani) - Legs-Up-the-Wall Pose",image:o(132,"Viparita Karani"),description:"A restorative pose essential for all programs. Promotes recovery and relaxation. Perfect for online programs.",advantages:["Essential for all programs","Perfect for online","Promotes recovery","Promotes relaxation","Reduces stress","No physical strain"],disadvantages:["Avoid with eye pressure issues","Not suitable during menstruation","May cause discomfort with neck issues","Keep warm"],difficulty:"Beginner",duration:"5-15 minutes",subCategories:["Online Programs","Offline Classes","7-Day Challenge","30-Day Transformation","Beginner Course"]}],levels:[{id:133,name:"\u0aa4\u0abe\u0aa1\u0abe\u0ab8\u0aa8 (Tadasana) - Mountain Pose",image:o(133,"Tadasana"),description:"The foundational pose for all beginners. Improves posture and body awareness. Essential starting point.",advantages:["Perfect for beginners","Essential foundation","Improves posture","Builds body awareness","Easy to learn","Safe for everyone"],disadvantages:["May seem too simple","Requires focus","Keep feet grounded","Maintain alignment"],difficulty:"Beginner",duration:"30-60 seconds",subCategories:["Beginner","Gentle Yoga","Therapeutic"]},{id:134,name:"\u0aac\u0abe\u0ab2\u0abe\u0ab8\u0aa8 (Balasana) - Child's Pose",image:o(134,"Balasana"),description:"A restorative pose perfect for beginners and gentle yoga. Calms the mind and promotes relaxation.",advantages:["Perfect for beginners","Gentle yoga","Calms the mind","Promotes relaxation","Safe and comfortable","Therapeutic"],disadvantages:["Avoid with knee injuries","Not suitable during pregnancy","May cause discomfort with tight hips","Use props if needed"],difficulty:"Beginner",duration:"1-3 minutes",subCategories:["Beginner","Gentle Yoga","Restorative","Therapeutic"]},{id:135,name:"\u0aad\u0ac1\u0a9c\u0a82\u0a97\u0abe\u0ab8\u0aa8 (Bhujangasana) - Cobra Pose",image:o(135,"Bhujangasana"),description:"A gentle backbend perfect for beginners. Strengthens spine and opens chest. Can progress to intermediate.",advantages:["Perfect for beginners","Strengthens spine","Opens chest","Improves posture","Can progress","Therapeutic"],disadvantages:["Avoid with severe back injuries","Not suitable during pregnancy","May cause strain if done incorrectly","Keep it gentle"],difficulty:"Beginner",duration:"30-60 seconds",subCategories:["Beginner","Gentle Yoga","Therapeutic"]},{id:136,name:"\u0ab5\u0ac0\u0ab0\u0aad\u0aa6\u0acd\u0ab0\u0abe\u0ab8\u0aa8 II (Virabhadrasana II) - Warrior II",image:o(136,"Virabhadrasana II"),description:"A powerful standing pose perfect for intermediate level. Builds strength and stamina. Progress from beginner.",advantages:["Perfect for intermediate","Builds strength","Builds stamina","Improves balance","Opens hips","Progress from beginner"],disadvantages:["Avoid with knee injuries","Not suitable with high blood pressure","May cause strain if overdone","Requires foundation"],difficulty:"Intermediate",duration:"30-60 seconds",subCategories:["Intermediate","Power Yoga"]},{id:137,name:"\u0aa4\u0acd\u0ab0\u0abf\u0a95\u0acb\u0aa3\u0abe\u0ab8\u0aa8 (Trikonasana) - Triangle Pose",image:o(137,"Trikonasana"),description:"A standing pose perfect for intermediate level. Improves flexibility and strength. Progress from beginner poses.",advantages:["Perfect for intermediate","Improves flexibility","Strengthens legs","Progress from beginner","Improves balance","Opens hips"],disadvantages:["Avoid with low blood pressure","Not suitable with neck injuries","May cause dizziness","Requires some flexibility"],difficulty:"Intermediate",duration:"30-60 seconds each side",subCategories:["Intermediate","Power Yoga"]},{id:138,name:"Navasana (Navasana) - Boat Pose",image:o(138,"Navasana"),description:"A core strengthening pose perfect for intermediate level. Builds core strength and improves balance.",advantages:["Perfect for intermediate","Strengthens core","Improves balance","Tones muscles","Builds strength","Progress from beginner"],disadvantages:["Avoid with lower back injuries","Not suitable during pregnancy","May cause strain if forced","Requires core strength"],difficulty:"Intermediate",duration:"20-40 seconds",subCategories:["Intermediate","Power Yoga"]},{id:139,name:"Chaturanga Dandasana (Chaturanga Dandasana) - Four-Limbed Staff Pose",image:o(139,"Chaturanga Dandasana"),description:"A challenging pose perfect for advanced level. Builds upper body and core strength. Requires significant strength.",advantages:["Perfect for advanced","Builds strength","Tones entire body","Builds endurance","Challenging","Requires skill"],disadvantages:["Requires significant strength","Avoid with wrist injuries","Not suitable with shoulder problems","Very challenging","Not for beginners"],difficulty:"Advanced",duration:"10-30 seconds",subCategories:["Advanced","Expert","Power Yoga"]},{id:140,name:"Adho Mukha Vrksasana (Adho Mukha Vrksasana) - Handstand",image:o(140,"Adho Mukha Vrksasana"),description:"An advanced inversion perfect for expert level. Builds upper body strength and improves balance. Very challenging.",advantages:["Perfect for expert","Builds upper body strength","Improves balance","Tones entire body","Builds confidence","Very challenging"],disadvantages:["Requires significant strength","Avoid with wrist injuries","Not suitable with high blood pressure","Very challenging","Requires proper technique","Not for beginners"],difficulty:"Expert",duration:"10-30 seconds",subCategories:["Expert","Advanced","Power Yoga"]},{id:141,name:"Urdhva Dhanurasana (Urdhva Dhanurasana) - Wheel Pose",image:o(141,"Urdhva Dhanurasana"),description:"An advanced backbend perfect for expert level. Requires significant flexibility and strength. Very challenging.",advantages:["Perfect for expert","Builds strength","Improves flexibility","Opens chest","Tones entire body","Very challenging"],disadvantages:["Requires significant flexibility","Avoid with back injuries","Not suitable with high blood pressure","Very challenging","Requires proper technique","Not for beginners"],difficulty:"Expert",duration:"10-30 seconds",subCategories:["Expert","Advanced","Power Yoga"]},{id:142,name:"\u0ab5\u0abf\u0aaa\u0ab0\u0ac0\u0aa4 \u0a95\u0ab0\u0aa3\u0ac0 (Viparita Karani) - Legs-Up-the-Wall Pose",image:o(142,"Viparita Karani"),description:"A restorative pose perfect for gentle and therapeutic yoga. Promotes relaxation and recovery. Safe for all levels.",advantages:["Perfect for gentle yoga","Therapeutic","Restorative","Promotes relaxation","Safe for all levels","No physical strain"],disadvantages:["Avoid with eye pressure issues","Not suitable during menstruation","May cause discomfort with neck issues","Keep warm"],difficulty:"Beginner",duration:"5-15 minutes",subCategories:["Gentle Yoga","Restorative","Therapeutic","Beginner"]},{id:143,name:"\u0ab6\u0ab5\u0abe\u0ab8\u0aa8 (Shavasana) - Corpse Pose",image:o(143,"Shavasana"),description:"The ultimate relaxation pose essential for all levels. Promotes deep relaxation and recovery.",advantages:["Essential for all levels","Promotes deep relaxation","Promotes recovery","Reduces stress","Calms entire system","Therapeutic"],disadvantages:["May cause sleepiness","Keep warm","Not suitable if feeling unwell","Practice in quiet environment"],difficulty:"Beginner",duration:"5-20 minutes",subCategories:["Beginner","Intermediate","Advanced","Expert","Gentle Yoga","Restorative","Therapeutic","Power Yoga"]},{id:144,name:"\u0ab8\u0ac2\u0ab0\u0acd\u0aaf \u0aa8\u0aae\u0ab8\u0acd\u0a95\u0abe\u0ab0 (Surya Namaskar) - Sun Salutation",image:o(144,"Surya Namaskar"),description:"A complete sequence perfect for intermediate to advanced levels. Provides full-body workout and builds strength.",advantages:["Perfect for intermediate/advanced","Full-body workout","Builds strength","Improves flexibility","Boosts energy","Power yoga"],disadvantages:["Avoid with severe heart conditions","Not recommended during pregnancy","May cause fatigue if overdone","Requires good physical condition"],difficulty:"Intermediate",duration:"5-10 minutes",subCategories:["Intermediate","Advanced","Power Yoga"]},{id:145,name:"Bakasana (Bakasana) - Crow Pose",image:o(145,"Bakasana"),description:"An arm balance perfect for advanced level. Builds upper body and core strength. Requires significant strength.",advantages:["Perfect for advanced","Builds upper body strength","Strengthens core","Improves balance","Tones arms","Requires skill"],disadvantages:["Requires upper body strength","Avoid with wrist injuries","Not suitable with shoulder problems","Challenging","Not for beginners"],difficulty:"Advanced",duration:"10-30 seconds",subCategories:["Advanced","Expert","Power Yoga"]},{id:146,name:"\u0ab8\u0ac7\u0aa4\u0ac1 \u0aac\u0a82\u0aa7\u0abe\u0ab8\u0aa8 (Setu Bandhasana) - Bridge Pose",image:o(146,"Setu Bandhasana"),description:"A gentle backbend perfect for beginners and gentle yoga. Strengthens back and opens chest. Therapeutic.",advantages:["Perfect for beginners","Gentle yoga","Therapeutic","Strengthens back","Opens chest","Safe and gentle"],disadvantages:["Avoid with neck injuries","Not suitable with severe back problems","Avoid during late pregnancy","Keep it gentle"],difficulty:"Beginner",duration:"30-60 seconds",subCategories:["Beginner","Gentle Yoga","Restorative","Therapeutic"]},{id:147,name:"Padmasana (Padmasana) - Lotus Pose",image:o(147,"Padmasana"),description:"The classic meditation pose perfect for intermediate to advanced levels. Requires flexibility and practice.",advantages:["Perfect for intermediate/advanced","Classic meditation pose","Improves focus","Opens hips","Improves posture","Enhances concentration"],disadvantages:["Requires flexible hips","Can strain knees if forced","Not suitable for knee injuries","May cause ankle discomfort","Difficult for beginners"],difficulty:"Intermediate",duration:"5-30 minutes",subCategories:["Intermediate","Advanced","Expert"]}]};(0,E.useEffect)(()=>{var n;if(null!==(n=t.state)&&void 0!==n&&n.category)s(t.state.category),i(t.state.subCategory);else{const t={"pain-relief":{id:"pain-relief",name:"Pain Relief Yoga",icon:"\ud83e\ude79",subCategories:["Back Pain","Knee Pain","Neck Pain","Shoulder Pain","Sciatica","Joint Pain","Arthritis","Muscle Tension"]},"disease-specific":{id:"disease-specific",name:"Disease-Specific Yoga",icon:"\ud83c\udfe5",subCategories:["Diabetes","Blood Pressure (BP)","Thyroid","PCOS","Asthma","Heart Health","Digestive Issues","Immune System"]},"age-groups":{id:"age-groups",name:"Yoga for Age Groups",icon:"\ud83d\udc65",subCategories:["Kids Yoga (5-12 years)","Teens Yoga (13-19 years)","Adults (20-50 years)","Seniors (50+ years)"]},women:{id:"women",name:"Yoga for Women",icon:"\ud83d\udc69",subCategories:["Pregnancy Yoga","Postnatal Yoga","Menstrual Health","Menopause","Hormonal Balance","Pelvic Health"]},"mental-health":{id:"mental-health",name:"Yoga for Mental Health",icon:"\ud83e\uddd8",subCategories:["Stress Relief","Anxiety Management","Depression Support","Sleep Disorders","Focus & Concentration","Emotional Balance"]},"fitness-goals":{id:"fitness-goals",name:"Fitness & Body Goals",icon:"\ud83d\udcaa",subCategories:["Weight Loss","Weight Gain","Flexibility","Strength Building","Muscle Tone","Core Strength","Cardio Fitness","Body Sculpting"]},lifestyle:{id:"lifestyle",name:"Lifestyle Yoga",icon:"\ud83c\udf31",subCategories:["Office Workers","Athletes","Daily Routine","Morning Yoga","Evening Yoga","Desk Yoga","Travel Yoga","Quick Sessions"]},meditation:{id:"meditation",name:"Meditation & Pranayama",icon:"\ud83d\udd49\ufe0f",subCategories:["Breathing Exercises","Mindfulness","Guided Meditation","Chakra Balancing","Energy Healing","Relaxation Techniques"]},programs:{id:"programs",name:"Yoga Programs",icon:"\ud83d\udcda",subCategories:["Online Programs","Offline Classes","7-Day Challenge","30-Day Transformation","Beginner Course","Advanced Training"]},levels:{id:"levels",name:"Yoga Levels",icon:"\ud83d\udcca",subCategories:["Beginner","Intermediate","Advanced","Expert","Therapeutic","Restorative","Power Yoga","Gentle Yoga"]}};s(t[e]||t["pain-relief"])}},[e,t.state]);const l=()=>c[e]||c["pain-relief"],u=r?l().filter(e=>{var t;return null===(t=e.subCategories)||void 0===t?void 0:t.some(e=>e.toLowerCase().includes(r.toLowerCase()))}):l();return(0,vn.jsx)("div",{className:"category-detail-page",children:(0,vn.jsxs)("div",{className:"container",children:[(0,vn.jsxs)("button",{className:"back-button",onClick:()=>n("/pose-detection"),children:[(0,vn.jsx)(Ct,{})," Back to Categories"]}),a&&(0,vn.jsxs)(vn.Fragment,{children:[(0,vn.jsxs)("div",{className:"category-header-detail",children:[(0,vn.jsx)("div",{className:"category-icon-large",children:a.icon}),(0,vn.jsx)("h1",{children:a.name}),(0,vn.jsx)("p",{children:"Explore yoga poses tailored for your specific needs"})]}),a.subCategories&&a.subCategories.length>0&&(0,vn.jsxs)("div",{className:"subcategory-filter",children:[(0,vn.jsx)("button",{className:"subcategory-filter-btn ".concat(r?"":"active"),onClick:()=>i(null),children:"All"}),a.subCategories.map((e,t)=>(0,vn.jsx)("button",{className:"subcategory-filter-btn ".concat(r===e?"active":""),onClick:()=>i(e),children:e},t))]}),(0,vn.jsx)("div",{className:"poses-grid",children:u.map(e=>(0,vn.jsxs)("div",{className:"pose-card",onClick:()=>n("/pose/".concat(e.id),{state:{pose:e}}),style:{cursor:"pointer"},children:[(0,vn.jsxs)("div",{className:"pose-image-container",children:[(0,vn.jsx)("img",{src:e.image,alt:e.name,className:"pose-image",loading:"lazy",onError:t=>{const n="https://source.unsplash.com/400x300/?yoga&sig=".concat(e.id);let a=0;t.target.onerror=()=>{a++,a>=2?t.target.style.display="none":t.target.src=n},t.target.src=n}}),(0,vn.jsx)("span",{className:"pose-difficulty-badge ".concat(e.difficulty.toLowerCase()),children:e.difficulty})]}),(0,vn.jsxs)("div",{className:"pose-content",children:[(0,vn.jsx)("h3",{className:"pose-name",children:e.name}),(0,vn.jsx)("p",{className:"pose-description",children:e.description}),(0,vn.jsxs)("div",{className:"pose-duration",children:[(0,vn.jsx)("strong",{children:"Duration:"})," ",e.duration]}),(0,vn.jsxs)("div",{className:"pose-advantages",children:[(0,vn.jsxs)("h4",{children:[(0,vn.jsx)(Pt,{className:"icon-advantage"}),"Advantages"]}),(0,vn.jsx)("ul",{children:e.advantages.map((e,t)=>(0,vn.jsx)("li",{children:e},t))})]}),(0,vn.jsxs)("div",{className:"pose-disadvantages",children:[(0,vn.jsxs)("h4",{children:[(0,vn.jsx)(fn,{className:"icon-disadvantage"}),"Disadvantages & Precautions"]}),(0,vn.jsx)("ul",{children:e.disadvantages.map((e,t)=>(0,vn.jsx)("li",{children:e},t))})]})]})]},e.id))})]})]})})};var ou=n(29),cu=n.n(ou);class lu{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class uu{refCount(e){return hu("refCount")}incRef(e){return hu("incRef")}timerAvailable(){return!0}time(e){return hu("time")}read(e){return hu("read")}readSync(e){return hu("readSync")}readToGPU(e,t){return hu("readToGPU")}numDataIds(){return hu("numDataIds")}disposeData(e,t){return hu("disposeData")}write(e,t,n){return hu("write")}move(e,t,n,a,s){return hu("move")}createTensorFromGPUData(e,t,n){return hu("createTensorFromGPUData")}memory(){return hu("memory")}floatPrecision(){return hu("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return hu("dispose")}}function hu(e){throw new Error("'".concat(e,"' not yet implemented or not found in the registry. ")+"This kernel may not be supported by the tfjs backend you have chosen")}function du(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,mu(e,t,n)}function pu(e,t,n){return Math.max(e,Math.min(t,n))}function fu(e){return e%2===0?e:e+1}function mu(e,t,n){const a=e[t];e[t]=e[n],e[n]=a}function gu(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}function yu(e,t){if(!e)throw new Error("string"===typeof t?t:t())}function bu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";yu(ku(e,t),()=>n+" Shapes ".concat(e," and ").concat(t," must match"))}function xu(e){yu(null!=e,()=>"The input to the tensor constructor must be a non-null value.")}function vu(e){if(0===e.length)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function wu(e){return 0===e.length}function ku(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function Su(e){return e%1===0}function Cu(e){const t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function Iu(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function Nu(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e=>0,n=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0;return new Promise((s,r)=>{let i=0;const o=()=>{if(e())return void s();i++;const c=t(i);null!=n&&i>=n?r():null!=a?a(o,c):setTimeout(o,c)};o()})}function Tu(e,t){let n=1,a=-1;for(let r=0;r<e.length;++r)if(e[r]>=0)n*=e[r];else if(-1===e[r]){if(-1!==a)throw Error("Shapes can only have 1 implicit size. "+"Found -1 at dim ".concat(a," and dim ").concat(r));a=r}else if(e[r]<0)throw Error("Shapes can not be < 0. Found ".concat(e[r]," at dim ").concat(r));if(-1===a){if(t>0&&t!==n)throw Error("Size(".concat(t,") must match the product of shape ").concat(e));return e}if(0===n)throw Error("Cannot infer the missing size in [".concat(e,"] when ")+"there are 0 elements");if(t%n!==0)throw Error("The implicit shape can't be a fractional number. "+"Got ".concat(t," / ").concat(n));const s=e.slice();return s[a]=t/n,s}function Eu(e,t){const n=t.length;return yu((e=null==e?t.map((e,t)=>t):[].concat(e)).every(e=>e>=-n&&e<n),()=>"All values in axis param must be in range [-".concat(n,", ").concat(n,") but ")+"got axis ".concat(e)),yu(e.every(e=>Su(e)),()=>"All values in axis param must be integers but "+"got axis ".concat(e)),e.map(e=>e<0?n+e:e)}function Ru(e,t){const n=[],a=[],s=null!=t&&Array.isArray(t)&&0===t.length,r=null==t||s?null:Eu(t,e).sort();let i=0;for(let o=0;o<e.length;++o){if(null!=r){if(r[i]===o&&1!==e[o])throw new Error("Can't squeeze axis ".concat(o," since its dim '").concat(e[o],"' is not 1"));(null==r[i]||r[i]>o)&&1===e[o]&&(n.push(e[o]),a.push(o)),r[i]<=o&&i++}1!==e[o]&&(n.push(e[o]),a.push(o))}return{newShape:n,keptDims:a}}function _u(e,t){return Au(e,t)}function Au(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else if("bool"===e)n=new Uint8Array(t);else{if("string"!==e)throw new Error("Unknown data type ".concat(e));n=new Array(t)}return n}function Mu(e,t){return"complex64"!==t&&(("float32"!==t||"complex64"===e)&&(("int32"!==t||"float32"===e||"complex64"===e)&&("bool"!==t||"bool"!==e)))}function Pu(e){if("float32"===e||"int32"===e)return 4;if("complex64"===e)return 8;if("bool"===e)return 1;throw new Error("Unknown dtype ".concat(e))}function Du(e){return"string"===typeof e||e instanceof String}function Ou(e){return"number"===typeof e}function Fu(e){return Array.isArray(e)?Fu(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":Ou(e)?"float32":Du(e)?"string":"boolean"===typeof e?"bool":"float32"}function Lu(e){return!!(e&&e.constructor&&e.call&&e.apply)}function zu(e,t){for(let n=t;n<e;++n)if(e%n===0)return n;return e}function Bu(e){const t=e.length;if(t<2)return[];const n=new Array(t-1);n[t-2]=e[t-1];for(let a=t-3;a>=0;--a)n[a]=n[a+1]*e[a+1];return n}function ju(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s=new Array;if(1===t.length){const r=t[0]*(a?2:1);for(let t=0;t<r;t++)s[t]=n[e+t]}else{const r=t[0],i=t.slice(1),o=i.reduce((e,t)=>e*t)*(a?2:1);for(let t=0;t<r;t++)s[t]=ju(e+t*o,i,n,a)}return s}function Wu(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(0===e.length)return t[0];const a=e.reduce((e,t)=>e*t)*(n?2:1);if(0===a)return[];if(a!==t.length)throw new Error("[".concat(e,"] does not match the input size ").concat(t.length).concat(n?" for a complex tensor":"","."));return ju(0,e,t,n)}function Vu(e,t){if(Array.isArray(e))return e;if("float32"===t)return e instanceof Float32Array?e:new Float32Array(e);if("int32"===t)return e instanceof Int32Array?e:new Int32Array(e);if("bool"===t||"string"===t)return Uint8Array.from(new Int32Array(e));throw new Error("Unknown dtype ".concat(t))}function Uu(e,t){const n=Hu(e,t);for(let a=0;a<n.length;a++)n[a]=1;return n}function Hu(e,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t)return new Uint8Array(e);throw new Error("Unknown data type ".concat(t))}function Gu(e,t){const n=e.reduce((e,t)=>e*t,1);if(null==t||"float32"===t)return Wu(e,new Float32Array(n));if("int32"===t)return Wu(e,new Int32Array(n));if("bool"===t)return Wu(e,new Uint8Array(n));throw new Error("Unknown data type ".concat(t))}function qu(e){e.forEach(t=>{yu(Number.isInteger(t)&&t>=0,()=>"Tensor must have a shape comprised of positive integers but got "+"shape [".concat(e,"]."))})}function Ku(e,t,n){if(0===t)return 0;if(1===t)return e[0];let a=e[e.length-1];for(let s=0;s<e.length-1;++s)a+=n[s]*e[s];return a}function Xu(e,t,n){if(0===t)return[];if(1===t)return[e];const a=new Array(t);for(let s=0;s<a.length-1;++s)a[s]=Math.floor(e/n[s]),e-=a[s]*n[s];return a[a.length-1]=e,a}function Yu(e){return e&&e.then&&"function"===typeof e.then}const Qu="tfjsflags";class Zu{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=Ju,this.populateURLFlags()}setPlatform(e,t){null!=this.platform&&($u().getBool("IS_TEST")||$u().getBool("PROD")||console.warn("Platform ".concat(this.platformName," has already been set. ")+"Overwriting the platform with ".concat(e,"."))),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},null!=this.urlFlags[e]){const t=this.urlFlags[e];$u().getBool("IS_TEST")||$u().getBool("PROD")||console.warn("Setting feature override from URL ".concat(e,": ").concat(t,".")),this.set(e,t)}}async getAsync(e){return e in this.flags||(this.flags[e]=await this.evaluateFlag(e)),this.flags[e]}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(Yu(t))throw new Error("Flag ".concat(e," cannot be synchronously evaluated. ")+"Please use getAsync() instead.");return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(null==this.flagRegistry[e])throw new Error("Cannot set flag ".concat(e," as it has not been registered."));this.flags[e]=t,null!=this.flagRegistry[e].setHook&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(null==this.flagRegistry[e])throw new Error("Cannot evaluate flag '".concat(e,"': no evaluation function found."));return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if("undefined"===typeof this.global||"undefined"===typeof this.global.location||"undefined"===typeof this.global.location.search)return;const e=this.getQueryParams(this.global.location.search);if(Qu in e){e[Qu].split(",").forEach(e=>{const[t,n]=e.split(":");this.urlFlags[t]=function(e,t){const n=t.toLowerCase();return"true"===n||"false"===n?"true"===n:"".concat(+n)===n?+n:t}(0,n)})}}}function Ju(e){const t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,function(e){for(var n=arguments.length,a=new Array(n>1?n-1:0),s=1;s<n;s++)a[s-1]=arguments[s];return function(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}(t,a[0],a[1]),a.join("=")}),t}function $u(){return th}let eh,th=null;function nh(){if(null==eh){let e;if("undefined"!==typeof window)e=window;else if("undefined"!==typeof n.g)e=n.g;else if("undefined"!==typeof process)e=process;else{if("undefined"===typeof self)throw new Error("Could not find a global object");e=self}eh=e}return eh}function ah(e,t){const n=function(){const e=nh();return null==e._tfGlobals&&(e._tfGlobals=new Map),e._tfGlobals}();if(n.has(e))return n.get(e);{const a=t();return n.set(e,a),n.get(e)}}const sh="Abs",rh="Acos",ih="Acosh",oh="Add",ch="AddN",lh="All",uh="Any",hh="ArgMax",dh="ArgMin",ph="Asin",fh="Asinh",mh="Atan",gh="Atanh",yh="Atan2",bh="AvgPool",xh="AvgPoolGrad",vh="AvgPool3D",wh="AvgPool3DGrad",kh="BatchMatMul",Sh="BatchToSpaceND",Ch="Bincount",Ih="BitwiseAnd",Nh="BroadcastArgs",Th="Cast",Eh="Ceil",Rh="ClipByValue",_h="Complex",Ah="ComplexAbs",Mh="Concat",Ph="Conv2D",Dh="Conv2DBackpropFilter",Oh="Conv2DBackpropInput",Fh="Conv3D",Lh="Conv3DBackpropFilterV2",zh="Conv3DBackpropInputV2",Bh="Cos",jh="Cosh",Wh="Cumprod",Vh="Cumsum",Uh="CropAndResize",Hh="DenseBincount",Gh="DepthToSpace",qh="DepthwiseConv2dNative",Kh="DepthwiseConv2dNativeBackpropFilter",Xh="DepthwiseConv2dNativeBackpropInput",Yh="Diag",Qh="Dilation2D",Zh="Dilation2DBackpropInput",Jh="Dilation2DBackpropFilter",$h="Draw",ed="RealDiv",td="Einsum",nd="Elu",ad="EluGrad",sd="Erf",rd="Equal",id="Exp",od="ExpandDims",cd="Expm1",ld="FFT",ud="Fill",hd="FlipLeftRight",dd="Floor",pd="FloorDiv",fd="FusedBatchNorm",md="GatherV2",gd="GatherNd",yd="Greater",bd="GreaterEqual",xd="Identity",vd="IFFT",wd="Imag",kd="IsFinite",Sd="IsInf",Cd="IsNan",Id="LeakyRelu",Nd="Less",Td="LessEqual",Ed="LinSpace",Rd="Log",_d="Log1p",Ad="LogicalAnd",Md="LogicalNot",Pd="LogicalOr",Dd="LRN",Od="LRNGrad",Fd="Max",Ld="Maximum",zd="MaxPool",Bd="MaxPoolGrad",jd="MaxPool3D",Wd="MaxPool3DGrad",Vd="MaxPoolWithArgmax",Ud="Mean",Hd="Min",Gd="Minimum",qd="MirrorPad",Kd="Mod",Xd="Multinomial",Yd="Multiply",Qd="Neg",Zd="NotEqual",Jd="NonMaxSuppressionV3",$d="NonMaxSuppressionV4",ep="NonMaxSuppressionV5",tp="OnesLike",np="OneHot",ap="Pack",sp="PadV2",rp="Pow",ip="Prelu",op="Prod",cp="RaggedGather",lp="RaggedRange",up="RaggedTensorToTensor",hp="Range",dp="Real",pp="Reciprocal",fp="Relu",mp="Reshape",gp="ResizeNearestNeighbor",yp="ResizeNearestNeighborGrad",bp="ResizeBilinear",xp="ResizeBilinearGrad",vp="Relu6",wp="Reverse",kp="Round",Sp="Rsqrt",Cp="ScatterNd",Ip="TensorScatterUpdate",Np="SearchSorted",Tp="Select",Ep="Selu",Rp="Slice",_p="Sin",Ap="Sinh",Mp="Sign",Pp="Sigmoid",Dp="Softplus",Op="Sqrt",Fp="Sum",Lp="SpaceToBatchND",zp="SplitV",Bp="Softmax",jp="SparseFillEmptyRows",Wp="SparseReshape",Vp="SparseSegmentMean",Up="SparseSegmentSum",Hp="SparseToDense",Gp="SquaredDifference",qp="Square",Kp="StaticRegexReplace",Xp="StridedSlice",Yp="StringNGrams",Qp="StringSplit",Zp="StringToHashBucketFast",Jp="Sub",$p="Tan",ef="Tanh",tf="Tile",nf="TopK",af="Transform",sf="Transpose",rf="Unique",of="Unpack",cf="UnsortedSegmentSum",lf="ZerosLike",uf="Step",hf="FromPixels",df="RotateWithOffset",pf="_FusedMatMul",ff="FusedConv2D",mf="FusedDepthwiseConv2D";function gf(){$u().getBool("IS_TEST")||$u().getBool("PROD")||console.warn(...arguments)}function yf(){$u().getBool("IS_TEST")||$u().getBool("PROD")||console.log(...arguments)}const bf=ah("kernelRegistry",()=>new Map),xf=ah("gradRegistry",()=>new Map);function vf(e,t){const n=If(e,t);return bf.get(n)}function wf(e){return xf.get(e)}function kf(e){const t=bf.entries(),n=[];for(;;){const{done:a,value:s}=t.next();if(a)break;const[r,i]=s,[o]=r.split("_");o===e&&n.push(i)}return n}function Sf(e){const{kernelName:t,backendName:n}=e,a=If(t,n);bf.has(a)&&gf("The kernel '".concat(t,"' for backend ")+"'".concat(n,"' is already registered")),bf.set(a,e)}function Cf(e){const{kernelName:t}=e;xf.has(t)&&$u().getBool("DEBUG")&&gf("Overriding the gradient for '".concat(t,"'")),xf.set(t,e)}function If(e,t){return"".concat(t,"_").concat(e)}function Nf(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}var Tf=n(353);const Ef=n.n(Tf)()||Tf;function Rf(e){return Ef.fromString(e,!0,16)}const _f=Rf("c3a5c85c97cb3127"),Af=Rf("b492b66fbe98f273"),Mf=Rf("9ae16a3b2f90404f");function Pf(e){return e.xor(e.shru(47))}function Df(e,t,n){const a=e.slice(t,t+n);return Ef.fromBytes(Array.from(a),!0,!0)}function Of(e,t){return Df(e,t,8)}function Ff(e,t){return Df(e,t,4)}function Lf(e,t){return 0===t?e:e.shru(t).or(e.shl(64-t))}function zf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Rf("9ddfea08eb382d69"),a=e.xor(t).mul(n);a=a.xor(a.shru(47));let s=t.xor(a).mul(n);return s=s.xor(s.shru(47)),s=s.mul(n),s}function Bf(e,t,n,a){return function(e,t,n,a,s,r){s=s.add(e),r=Lf(r.add(s).add(a),21);const i=s;return s=(s=s.add(t)).add(n),r=r.add(Lf(s,44)),[s.add(a),r.add(i)]}(Of(e,t),Of(e,t+8),Of(e,t+16),Of(e,t+24),n,a)}function jf(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;const n=Ef.fromNumber(81,!0);if(t<=32)return t<=16?function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;if(t>=8){const n=Mf.add(2*t),a=Of(e,0).add(Mf),s=Of(e,t-8);return zf(Lf(s,37).mul(n).add(a),Lf(a,25).add(s).mul(n),n)}if(t>=4){const n=Mf.add(2*t);return zf(Ff(e,0).shl(3).add(t),Ff(e,t-4),n)}if(t>0){const n=e[0]+(e[t>>1]<<8),a=t+(e[t-1]<<2);return Pf(Mf.mul(n).xor(_f.mul(a))).mul(Mf)}return Mf}(e,t):function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;const n=Mf.add(2*t),a=Of(e,0).mul(Af),s=Of(e,8),r=Of(e,t-8).mul(n),i=Of(e,t-16).mul(Mf);return zf(Lf(a.add(s),43).add(Lf(r,30)).add(i),a.add(Lf(s.add(Mf),18)).add(r),n)}(e,t);if(t<=64)return function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;const n=Mf.add(2*t),a=Of(e,0).mul(Mf),s=Of(e,8),r=Of(e,t-8).mul(n),i=Of(e,t-16).mul(Mf),o=Lf(a.add(s),43).add(Lf(r,30)).add(i),c=zf(o,a.add(Lf(s.add(Mf),18)).add(r),n),l=Of(e,16).mul(n),u=Of(e,24),h=o.add(Of(e,t-32)).mul(n),d=c.add(Of(e,t-24)).mul(n);return zf(Lf(l.add(u),43).add(Lf(h,30)).add(d),l.add(Lf(u.add(a),18)).add(h),n)}(e,t);let a=n,s=n.mul(Af).add(113),r=Pf(s.mul(Mf).add(113)).mul(Mf),i=[Ef.UZERO,Ef.UZERO],o=[Ef.UZERO,Ef.UZERO];a=a.mul(Mf).add(Of(e,0));let c=0;const l=64*(t-1>>6),u=l+(t-1&63)-63;do{a=Lf(a.add(s).add(i[0]).add(Of(e,c+8)),37).mul(Af),s=Lf(s.add(i[1]).add(Of(e,c+48)),42).mul(Af),a=a.xor(o[1]),s=s.add(i[0]).add(Of(e,c+40)),r=Lf(r.add(o[0]),33).mul(Af),i=Bf(e,c,i[1].mul(Af),a.add(o[0])),o=Bf(e,c+32,r.add(o[1]),s.add(Of(e,c+16))),[r,a]=[a,r],c+=64}while(c!==l);const h=Af.add(r.and(255).shl(1));return c=u,o[0]=o[0].add(t-1&63),i[0]=i[0].add(o[0]),o[0]=o[0].add(i[0]),a=Lf(a.add(s).add(i[0]).add(Of(e,c+8)),37).mul(h),s=Lf(s.add(i[1]).add(Of(e,c+48)),42).mul(h),a=a.xor(o[1].mul(9)),s=s.add(i[0].mul(9).add(Of(e,c+40))),r=Lf(r.add(o[0]),33).mul(h),i=Bf(e,c,i[1].mul(h),a.add(o[0])),o=Bf(e,c+32,r.add(o[1]),s.add(Of(e,c+16))),[r,a]=[a,r],zf(zf(i[0],o[0],h).add(Pf(s).mul(_f)).add(r),zf(i[1],o[1],h).add(a),h)}function Wf(e,t){return"string"===t?Hf(e):Vf([e],t)}function Vf(e,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=Kf(e)),$u().getBool("DEBUG")&&function(e,t){for(let n=0;n<e.length;n++){const a=e[n];if(isNaN(a)||!isFinite(a))throw Error("A tensor of type ".concat(t," being uploaded contains ").concat(a,"."))}}(e,t),function(e,t){return e instanceof Float32Array&&"float32"===t||e instanceof Int32Array&&"int32"===t||e instanceof Uint8Array&&"bool"===t}(e,t))return e;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t){const t=new Uint8Array(e.length);for(let n=0;n<t.length;++n)0!==Math.round(e[n])&&(t[n]=1);return t}throw new Error("Unknown data type ".concat(t))}function Uf(){return $u().platform.now()}function Hf(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf-8";return t=t||"utf-8",$u().platform.encode(e,t)}function Gf(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf-8";return t=t||"utf-8",$u().platform.decode(e,t)}function qf(e){return null!=$u().platform.isTypedArray?$u().platform.isTypedArray(e):Nf(e)}function Kf(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(null==t&&(t=[]),"boolean"===typeof e||"number"===typeof e||"string"===typeof e||Yu(e)||null==e||qf(e)&&n)t.push(e);else if(Array.isArray(e)||qf(e))for(let a=0;a<e.length;++a)Kf(e[a],t,n);else{let a=-1;for(const t of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(t)&&(a=Math.max(a,Number(t)));for(let s=0;s<=a;s++)Kf(e[s],t,n)}return t}class Xf{constructor(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new Qf)}profileKernel(e,t,n){let a;const s=()=>{a=n()};let r;const i=Uf();if(this.backendTimer.timerAvailable())r=this.backendTimer.time(s);else{s();for(const e of a)e.dataSync();r=Promise.resolve({kernelMs:Uf()-i})}if($u().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let o=0;o<a.length;o++){const t=a[o];t.data().then(n=>{Yf(n,t.dtype,e)})}return{kernelName:e,outputs:a,inputs:t,timeMs:r.then(e=>e.kernelMs),extraInfo:r.then(e=>null!=e.getExtraProfileInfo?e.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:t,outputs:n,timeMs:a,inputs:s,extraInfo:r}=e;n.forEach(e=>{Promise.all([e.data(),a,r]).then(n=>{this.logger.logKernelProfile(t,e,n[0],n[1],s,n[2])})})}}function Yf(e,t,n){if("float32"!==t)return!1;for(let a=0;a<e.length;a++){const t=e[a];if(isNaN(t)||!isFinite(t))return console.warn("Found ".concat(t," in the result of '").concat(n,"'")),!0}return!1}class Qf{logKernelProfile(e,t,n,a,s,r){const i="number"===typeof a?Iu("".concat(a,"ms"),9):a.error,o=Iu(e,25),c=t.rank,l=t.size,u=Iu(t.shape.toString(),14);let h="";for(const d in s){const e=s[d];if(null!=e){const n=e.shape||t.shape,a=n.length;h+="".concat(d,": ").concat(a,"D ").concat(a>0?n:""," ")}}console.log("%c".concat(o,"\t%c").concat(i,"\t%c").concat(c,"D ").concat(u,"\t%c").concat(l,"\t%c").concat(h,"\t%c").concat(r),"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function Zf(e,t,n,a){const s=Bu(t),r=function(e,t,n,a){const s=vu(t),r=a[a.length-1],i=new Array(r).fill(0),o=t.length,c="complex64"===n?tm(e):e;if(o>1)for(let l=0;l<s/r;l++){const e=l*r;for(let t=0;t<r;t++)i[t]=Math.max(i[t],Jf(c[e+t],0,n).length)}return i}(e,t,n,s),i=t.length,o=em(e,t,n,s,r),c=["Tensor"];return a&&(c.push("  dtype: ".concat(n)),c.push("  rank: ".concat(i)),c.push("  shape: [".concat(t,"]")),c.push("  values:")),c.push(o.map(e=>"    "+e).join("\n")),c.join("\n")}function Jf(e,t,n){let a;return a=Array.isArray(e)?"".concat(parseFloat(e[0].toFixed(7))," + ")+"".concat(parseFloat(e[1].toFixed(7)),"j"):Du(e)?"'".concat(e,"'"):"bool"===n?$f(e):parseFloat(e.toFixed(7)).toString(),Iu(a,t)}function $f(e){return 0===e?"false":"true"}function em(e,t,n,a,s){let r=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const i="complex64"===n?2:1,o=t[0],c=t.length;if(0===c){if("complex64"===n){return[Jf(tm(e)[0],0,n)]}return"bool"===n?[$f(e[0])]:[e[0].toString()]}if(1===c){if(o>20){const t=3*i;let a=Array.from(e.slice(0,t)),r=Array.from(e.slice((o-3)*i,o*i));return"complex64"===n&&(a=tm(a),r=tm(r)),["["+a.map((e,t)=>Jf(e,s[t],n)).join(", ")+", ..., "+r.map((e,t)=>Jf(e,s[o-3+t],n)).join(", ")+"]"]}return["["+("complex64"===n?tm(e):Array.from(e)).map((e,t)=>Jf(e,s[t],n)).join(", ")+"]"]}const l=t.slice(1),u=a.slice(1),h=a[0]*i,d=[];if(o>20){for(let t=0;t<3;t++){const a=t*h,r=a+h;d.push(...em(e.slice(a,r),l,n,u,s,!1))}d.push("...");for(let t=o-3;t<o;t++){const a=t*h,r=a+h;d.push(...em(e.slice(a,r),l,n,u,s,t===o-1))}}else for(let m=0;m<o;m++){const t=m*h,a=t+h;d.push(...em(e.slice(t,a),l,n,u,s,m===o-1))}const p=2===c?",":"";d[0]="["+(o>0?d[0]+p:"");for(let m=1;m<d.length-1;m++)d[m]=" "+d[m]+p;let f=",\n";for(let m=2;m<c;m++)f+="\n";return d[d.length-1]=" "+d[d.length-1]+"]"+(r?"":f),d}function tm(e){const t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}class nm{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=vu(e),null!=n){const e=n.length;yu(e===this.size,()=>"Length of values '".concat(e,"' does not match the size ")+"inferred by the shape '".concat(this.size,"'."))}if("complex64"===t)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||Au(t,this.size),this.strides=Bu(e)}set(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),a=1;a<t;a++)n[a-1]=arguments[a];0===n.length&&(n=[0]),yu(n.length===this.rank,()=>"The number of provided coordinates (".concat(n.length,") must ")+"match the rank (".concat(this.rank,")"));const s=this.locToIndex(n);this.values[s]=e}get(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];0===t.length&&(t=[0]);let a=0;for(const r of t){if(r<0||r>=this.shape[a]){const e="Requested out of range element at ".concat(t,". ")+"  Buffer shape=".concat(this.shape);throw new Error(e)}a++}let s=t[t.length-1];for(let r=0;r<t.length-1;++r)s+=this.strides[r]*t[r];return this.values[s]}locToIndex(e){if(0===this.rank)return 0;if(1===this.rank)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(0===this.rank)return[];if(1===this.rank)return[e];const t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return am().makeTensor(this.values,this.shape,this.dtype)}}let am=null,sm=null,rm=null;class im{constructor(e,t,n,a){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=vu(e),this.strides=Bu(e),this.dataId=n,this.id=a,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return sm.buffer(this.shape,this.dtype,e)}bufferSync(){return sm.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return Wu(this.shape,e,"complex64"===this.dtype)}arraySync(){return Wu(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();const e=am().read(this.dataId);if("string"===this.dtype){const n=await e;try{return n.map(e=>Gf(e))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),am().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=am().readSync(this.dataId);if("string"===this.dtype)try{return e.map(e=>Gf(e))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await am().read(this.dataId);return"string"===this.dtype?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),am().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return sm.print(this,e)}clone(){return this.throwIfDisposed(),sm.clone(this)}toString(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return Zf(this.dataSync(),this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),sm.cast(this,e)}variable(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],t=arguments.length>1?arguments[1]:void 0,n=arguments.length>2?arguments[2]:void 0;return this.throwIfDisposed(),am().makeVariable(this,e,t,n)}}function om(){return ah("Tensor",()=>im)}Object.defineProperty(im,Symbol.hasInstance,{value:e=>!!e&&null!=e.data&&null!=e.dataSync&&null!=e.throwIfDisposed}),om();class cm extends im{constructor(e,t,n,a){super(e.shape,e.dtype,e.dataId,a),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error("dtype of the new value (".concat(e.dtype,") and ")+"previous value (".concat(this.dtype,") must match"));if(!ku(e.shape,this.shape))throw new Error("shape of the new value (".concat(e.shape,") and ")+"previous value (".concat(this.shape,") must match"));am().disposeTensor(this),this.dataId=e.dataId,am().incRef(this,null)}dispose(){am().disposeVariable(this),this.isDisposedInternal=!0}}var lm,um,hm,dm,pm;Object.defineProperty(cm,Symbol.hasInstance,{value:e=>e instanceof im&&null!=e.assign&&e.assign instanceof Function}),function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"}(lm||(lm={})),function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"}(um||(um={})),function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"}(hm||(hm={})),function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"}(dm||(dm={})),function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"}(pm||(pm={}));const fm={float32:dm,int32:um,bool:hm,complex64:pm};function mm(e,t){if("string"===e||"string"===t){if("string"===e&&"string"===t)return"string";throw new Error("Can not upcast ".concat(e," with ").concat(t))}return fm[e][t]}function gm(e){return mm(e,"int32")}function ym(e){return null!=e&&"object"===typeof e&&"texture"in e&&e.texture instanceof WebGLTexture}function bm(e){return"undefined"!==typeof GPUBuffer&&null!=e&&"object"===typeof e&&"buffer"in e&&e.buffer instanceof GPUBuffer}function xm(e,t){if(e.dtype===t.dtype)return[e,t];const n=mm(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function vm(e,t){return t.some(t=>t.id===e.id)}function wm(e){const t=[];return km(e,t,new Set),t}function km(e,t,n){if(null==e)return;if(e instanceof im)return void t.push(e);if(a=e,!Array.isArray(a)&&"object"!==typeof a)return;var a;const s=e;for(const r in s){const e=s[r];n.has(e)||(n.add(e),km(e,t,n))}}function Sm(e){return null!=e.kernelName}class Cm{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class Im{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new Cm}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then(()=>{});if(null!=this.backendInstance)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t];if(await this.initializeBackend(n).success)return void await this.setBackend(n)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error("Backend '".concat(this.backendName,"' has not yet been initialized. Make ")+"sure to await tf.ready() or await tf.setBackend() before calling other methods");if(null==this.backendInstance){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error("The highest priority backend '".concat(e,"' has not yet been ")+"initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{const{asyncInit:t}=this.initializeBackend(e);if(t)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return e in this.registryFactory?(gf("".concat(e," backend was already registered. ")+"Reusing existing backend factory."),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(null==this.registryFactory[e])throw new Error("Backend name '".concat(e,"' not found in registry"));if(this.backendName=e,null==this.registry[e]){this.backendInstance=null;const{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new Xf(this.backendInstance),!0}setupRegisteredKernels(){kf(this.backendName).forEach(e=>{null!=e.setupFunc&&e.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){kf(e).forEach(t=>{null!=t.disposeFunc&&t.disposeFunc(this.registry[e])})}initializeBackend(e){const t=this.registryFactory[e];if(null==t)throw new Error("Cannot initialize backend ".concat(e,", no registration found."));try{const n=t.factory();if(!n||n instanceof uu||"function"!==typeof n.then)return this.registry[e]=n,{success:!0,asyncInit:!1};{const t=++this.pendingBackendInitId,a=n.then(n=>!(t<this.pendingBackendInitId)&&(this.registry[e]=n,this.pendingBackendInit=null,!0)).catch(n=>(t<this.pendingBackendInitId||(this.pendingBackendInit=null,gf("Initialization of backend ".concat(e," failed")),gf(n.stack||n.message)),!1));return this.pendingBackendInit=a,{success:a,asyncInit:!0}}}catch(n){return gf("Initialization of backend ".concat(e," failed")),gf(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error("".concat(e," backend not found in registry"));this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t],{success:a,asyncInit:s}=this.initializeBackend(n);if(s||a)return{name:n,asyncInit:s}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const n=this.state.tensorInfo.get(t),a=n.backend,s=this.readSync(t),r=a.refCount(t);a.disposeData(t,!0),n.backend=e,e.move(t,s,n.shape,n.dtype,r),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n,a=null;if(null==t){if("function"!==typeof e)throw new Error("Please provide a function to tidy()");t=e}else{if("string"!==typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!==typeof t)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");a=e}return this.scopedRun(()=>this.startScope(a),()=>this.endScope(n),()=>(n=t(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n))}scopedRun(e,t,n){e();try{const e=n();return t(),e}catch(a){throw t(),a}}nextTensorId(){return Im.nextTensorId++}nextVariableId(){return Im.nextVariableId++}clone(e){const t=Tm.runKernel(xd,{x:e}),n={x:e};return this.addTapeNode(this.state.activeScope.name,n,[t],e=>({x:()=>{const t={x:e},n={dtype:"float32"};return Tm.runKernel(Th,t,n)}}),[],{}),t}runKernel(e,t,n){null==this.backendName&&this.backend;if(!(null!=vf(e,this.backendName)))throw new Error("Kernel '".concat(e,"' not registered for backend '").concat(this.backendName,"'"));return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){const a=this.backend.numDataIds();let s=0;n.forEach(e=>{s+="complex64"===e.dtype?3:1});const r=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],i=a-t-s-r;if(i>0)throw new Error("Backend '".concat(this.backendName,"' has an internal memory leak ")+"(".concat(i," data ids) after running '").concat(e,"'"))}runKernelFunc(e){let t,n=[];const a=this.isTapeOn(),s=this.state.numBytes,r=this.state.numTensors;let i,o;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;const c=Sm(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(Sm(e)){const{kernelName:t,inputs:s,attrs:r}=e;null==this.backendName&&this.backend;const c=vf(t,this.backendName);yu(null!=c,()=>"Cannot find registered kernel '".concat(t,"' for backend '").concat(this.backendName,"'")),i=()=>{const e=this.backend.numDataIds();o=c.kernelFunc({inputs:s,attrs:r,backend:this.backend});const i=Array.isArray(o)?o:[o];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(t,e,i);const l=i.map(e=>null!=e.rank?e:this.makeTensorFromTensorInfo(e));if(a){const e=this.getTensorsForGradient(t,s,l);n=this.saveTensorsForBackwardMode(e)}return l}}else{const{forwardFunc:t}=e,s=e=>{a&&(n=e.map(e=>this.keep(this.clone(e))))};i=()=>{const e=this.backend.numDataIds();o=this.tidy(()=>t(this.backend,s));const n=Array.isArray(o)?o:[o];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,e,n),n}}const{inputs:l,attrs:u}=e,h=Sm(e)?null:e.backwardsFunc;let d;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(d=this.profiler.profileKernel(c,l,()=>i()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(d),t=d.outputs):t=i()}),a&&this.addTapeNode(c,l,t,h,n,u),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-r,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(l).map(e=>null!=l[e]?l[e].shape:null),outputShapes:t.map(e=>e.shape),kernelTimeMs:d.timeMs,extraInfo:d.extraInfo}),Array.isArray(o)?t:t[0]}saveTensorsForBackwardMode(e){const t=e.map(e=>this.keep(this.clone(e)));return t}getTensorsForGradient(e,t,n){const a=wf(e);if(null!=a){const e=a.inputsToSave||[],s=a.outputsToSave||[];let r;a.saveAllInputs?(yu(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),r=Object.keys(t).map(e=>t[e])):r=e.map(e=>t[e]);const i=n.filter((e,t)=>s[t]);return r.concat(i)}return[]}makeTensor(e,t,n,a){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",a=a||this.backend;let s=e;"string"===n&&Du(e[0])&&(s=e.map(e=>Hf(e)));const r=a.write(s,t,n),i=new im(t,n,r,this.nextTensorId());if(this.trackTensor(i,a),"string"===n){const e=this.state.tensorInfo.get(r),t=function(e){if(null==e)return 0;let t=0;return e.forEach(e=>t+=e.length),t}(s);this.state.numBytes+=t-e.bytes,e.bytes=t}return i}makeTensorFromDataId(e,t,n,a){const s={dataId:e,shape:t,dtype:n=n||"float32"};return this.makeTensorFromTensorInfo(s,a)}makeTensorFromTensorInfo(e,t){const{dataId:n,shape:a,dtype:s}=e,r=new im(a,s,n,this.nextTensorId());return this.trackTensor(r,t),r}makeVariable(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0;n=n||this.nextVariableId().toString(),null!=a&&a!==e.dtype&&(e=e.cast(a));const s=new cm(e,t,n,this.nextTensorId());if(null!=this.state.registeredVariables[s.name])throw new Error("Variable with name ".concat(s.name," was already registered"));return this.state.registeredVariables[s.name]=s,this.incRef(s,this.backend),s}trackTensor(e,t){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(n=e.size*Pu(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof cm||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){const t=e.size*Pu(e.dtype);this.state.numBytes-=t}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(e=>e.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const a of this.state.activeProfile.kernels)a.kernelTimeMs=await a.kernelTimeMs,a.extraInfo=await a.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,t,n,a,s,r){const i={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:s},o=wf(e);null!=o&&(a=o.gradFunc),null!=a&&(i.gradient=e=>(e=e.map((e,t)=>{if(null==e){const e=n[t],a=Hu(e.size,e.dtype);return this.makeTensor(a,e.shape,e.dtype)}return e}),a(e.length>1?e:e[0],s,r))),this.state.activeTape.push(i)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=wm(e),n=new Set(t.map(e=>e.id));for(let s=0;s<this.state.activeScope.track.length;s++){const e=this.state.activeScope.track[s];e.kept||n.has(e.id)||e.dispose()}const a=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(e=>{e.kept||e.scopeId!==a.id||this.track(e)})}gradients(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(yu(t.length>0,()=>"gradients() received an empty list of xs."),null!=n&&"float32"!==n.dtype)throw new Error("dy must have 'float32' dtype, but has '".concat(n.dtype,"'"));const s=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));yu(s instanceof im,()=>"The result y returned by f() must be a tensor.");const r=function(e,t,n){const a={},s={};for(let c=0;c<t.length;c++)a[t[c].id]=!0;for(let c=0;c<e.length;c++){const n=e[c],r=n.inputs;for(const e in r){const i=r[e];let o=!1;for(let e=0;e<t.length;e++)if(a[i.id]){n.outputs.forEach(e=>a[e.id]=!0),o=!0,s[n.id]=!0;break}if(o)break}}const r={};r[n.id]=!0;const i={};for(let c=e.length-1;c>=0;c--){const t=e[c],n=t.inputs;for(let e=0;e<t.outputs.length;e++)if(r[t.outputs[e].id]){for(const e in n)r[n[e].id]=!0,i[t.id]=!0;break}}const o=[];for(let c=0;c<e.length;c++){const t=e[c];if(s[t.id]&&i[t.id]){const e={};for(const s in t.inputs){const n=t.inputs[s];a[n.id]&&(e[s]=n)}const n=Object.assign({},t);n.inputs=e,n.outputs=t.outputs,o.push(n)}}return o}(this.state.activeTape,t,s);if(!a&&0===r.length&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const e={};e[s.id]=null==n?function(e){const t=Uu(vu(e),"float32");return Tm.makeTensor(t,e,"float32")}(s.shape):n,function(e,t,n,a){for(let s=t.length-1;s>=0;s--){const r=t[s],i=[];if(r.outputs.forEach(t=>{const n=e[t.id];null!=n?i.push(n):i.push(null)}),null==r.gradient)throw new Error("Cannot compute gradient: gradient function not found "+"for ".concat(r.kernelName,"."));const o=r.gradient(i);for(const t in r.inputs){if(!(t in o))throw new Error("Cannot backprop through input ".concat(t,". ")+"Available gradients found: ".concat(Object.keys(o),"."));const s=n(()=>o[t]());if("float32"!==s.dtype)throw new Error("Error in gradient for op ".concat(r.kernelName,". The gradient of input ")+"".concat(t," must have 'float32' dtype, but has '").concat(s.dtype,"'"));const i=r.inputs[t];if(!ku(s.shape,i.shape))throw new Error("Error in gradient for op ".concat(r.kernelName,". The gradient of input ")+"'".concat(t,"' has shape '").concat(s.shape,"', which does not match ")+"the shape of the input '".concat(i.shape,"'"));if(null==e[i.id])e[i.id]=s;else{const t=e[i.id];e[i.id]=a(t,s),t.dispose()}}}}(e,r,e=>this.tidy(e),Em);const a=t.map(t=>e[t.id]);return 0===this.state.gradientDepth&&(this.state.activeTape.forEach(e=>{for(const t of e.saved)t.dispose()}),this.state.activeTape=null),{value:s,grads:a}})}customGrad(e){var t=this;return yu(Lu(e),()=>"The f passed in customGrad(f) must be a function."),function(){for(var n=arguments.length,a=new Array(n),s=0;s<n;s++)a[s]=arguments[s];let r;yu(a.every(e=>e instanceof im),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");const i={};a.forEach((e,t)=>{i[t]=e});return t.runKernelFunc({forwardFunc:(t,n)=>(r=e(...a,n),yu(r.value instanceof im,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),yu(Lu(r.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),r.value),backwardsFunc:(e,t)=>{const n=r.gradFunc(e,t),s=Array.isArray(n)?n:[n];yu(s.length===a.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),yu(s.every(e=>e instanceof im),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const i={};return s.forEach((e,t)=>{i[t]=()=>e}),i},inputs:i})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=Uf(),n=await this.backend.time(e);return n.wallMs=Uf()-t,n}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new Cm;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function Nm(){const e=nh();if(null==e._tfengine){const t=new Zu(e);e._tfengine=new Im(t)}var t;return t=e._tfengine.ENV,th=t,function(e){am=e}(()=>e._tfengine),e._tfengine}Im.nextTensorId=0,Im.nextVariableId=0;const Tm=Nm();function Em(e,t){const n={a:e,b:t};return Tm.runKernel(oh,n)}let Rm;function _m(e){if(void 0!==Rm)return Rm;if(e||"undefined"!==typeof navigator&&null!=navigator){if(e||(e=navigator),"ReactNative"===e.product)return!0;const t=e.userAgent||e.vendor||("undefined"!==typeof window?window.opera:"");if(!t){const t=e;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function Am(){return"undefined"!==typeof window&&null!=window.document||"undefined"!==typeof WorkerGlobalScope}const Mm=$u();function Pm(e,t){let n=e;if(qf(e))return"string"===t?[]:[e.length];if(ym(e)){const t=e.channels||"RGBA";return[e.height,e.width*t.length]}if(bm(e))return[e.buffer.size/(null==t?4:Pu(t))];if(!Array.isArray(e))return[];const a=[];for(;Array.isArray(n)||qf(n)&&"string"!==t;)a.push(n.length),n=n[0];return Array.isArray(e)&&$u().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&Dm(e,a,[]),a}function Dm(e,t,n){if(n=n||[],!Array.isArray(e)&&!qf(e))return void yu(0===t.length,()=>"Element arr[".concat(n.join("]["),"] is a primitive, ")+"but should be an array/TypedArray of ".concat(t[0]," elements"));yu(t.length>0,()=>"Element arr[".concat(n.join("]["),"] should be a primitive, ")+"but is an array of ".concat(e.length," elements")),yu(e.length===t[0],()=>"Element arr[".concat(n.join("]["),"] should have ").concat(t[0]," ")+"elements, but has ".concat(e.length," elements"));const a=t.slice(1);for(let s=0;s<e.length;++s)Dm(e[s],a,n.concat(s))}function Om(e,t,n,a){if("string_or_numeric"!==e){if(null==e)throw new Error("Expected dtype cannot be null.");if("numeric"!==e&&e!==t||"numeric"===e&&"string"===t)throw new Error("Argument '".concat(n,"' passed to '").concat(a,"' must ")+"be ".concat(e," tensor, but got ").concat(t," tensor"))}}function Fm(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"numeric";if(e instanceof om())return Om(a,e.dtype,t,n),e;let s=Fu(e);if("string"!==s&&["bool","int32","float32"].indexOf(a)>=0&&(s=a),Om(a,s,t,n),null==e||!qf(e)&&!Array.isArray(e)&&"number"!==typeof e&&"boolean"!==typeof e&&"string"!==typeof e){const a=null==e?"null":e.constructor.name;throw new Error("Argument '".concat(t,"' passed to '").concat(n,"' must be a ")+"Tensor or TensorLike, but got '".concat(a,"'"))}const r=Pm(e,s);qf(e)||Array.isArray(e)||(e=[e]);const i="string"!==s?Vf(e,s):Kf(e,[],!0);return Tm.makeTensor(i,r,s)}function Lm(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"numeric";if(!Array.isArray(e))throw new Error("Argument ".concat(t," passed to ").concat(n," must be a ")+"`Tensor[]` or `TensorLike[]`");return e.map((e,s)=>Fm(e,"".concat(t,"[").concat(s,"]"),n,a))}Mm.registerFlag("DEBUG",()=>!1,e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),Mm.registerFlag("IS_BROWSER",()=>Am()),Mm.registerFlag("IS_NODE",()=>"undefined"!==typeof process&&"undefined"!==typeof process.versions&&"undefined"!==typeof process.versions.node),Mm.registerFlag("IS_CHROME",()=>"undefined"!==typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),Mm.registerFlag("IS_SAFARI",()=>"undefined"!==typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor)),Mm.registerFlag("PROD",()=>!1),Mm.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Mm.getBool("DEBUG")),Mm.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),Mm.registerFlag("IS_TEST",()=>!1),Mm.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>Mm.getBool("DEBUG")),Mm.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1),Mm.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1),Mm.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);const zm="__op";function Bm(e){const t=Object.keys(e);if(1!==t.length)throw new Error("Please provide an object with a single key (operation name) mapping to a function. Got an object with "+"".concat(t.length," keys."));let n=t[0];const a=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+=zm;const s=function(){Tm.startScope(n);try{const e=a(...arguments);return Yu(e)&&console.error("Cannot return a Promise inside of tidy."),Tm.endScope(e),e}catch(e){throw Tm.endScope(null),e}};return Object.defineProperty(s,"name",{value:n,configurable:!0}),s}const jm=Bm({complex_:function(e,t){const n=Fm(e,"real","complex"),a=Fm(t,"imag","complex");bu(n.shape,a.shape,"real and imag shapes, ".concat(n.shape," and ").concat(a.shape,", ")+"must match in call to tf.complex().");const s={real:n,imag:a};return Tm.runKernel(_h,s)}});function Wm(e,t,n,a){if(null==a)a=Fu(e);else if("complex64"===a)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(bm(e)||ym(e)){if("float32"!==a&&"int32"!==a)throw new Error("Creating tensor from GPU data only supports "+"'float32'|'int32' dtype, while the dtype is ".concat(a,"."));return Tm.backend.createTensorFromGPUData(e,t||n,a)}if(!qf(e)&&!Array.isArray(e)&&"number"!==typeof e&&"boolean"!==typeof e&&"string"!==typeof e)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){qu(t);const e=vu(t),a=vu(n);yu(e===a,()=>"Based on the provided shape, [".concat(t,"], the tensor should have ")+"".concat(e," values but has ").concat(a));for(let s=0;s<n.length;++s){const e=n[s],a=s!==n.length-1||e!==vu(t.slice(s));yu(n[s]===t[s]||!a,()=>"Error creating a new Tensor. Inferred shape "+"(".concat(n,") does not match the provided ")+"shape (".concat(t,"). "))}}return qf(e)||Array.isArray(e)||(e=[e]),t=t||n,e="string"!==a?Vf(e,a):Kf(e,[],!0),Tm.makeTensor(e,t,a)}function Vm(e,t,n){return Wm(e,t,Pm(e,n),n)}const Um={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class Hm{static join(e){return new Hm(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,null==e)return;if(e instanceof Array||(e=[e]),0===(e=e.map(e=>qf(e)?e.buffer:e)).length)return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let n=0;n<e.length;n++){const a=e[n];n!==e.length-1&&a.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const s=t+a.byteLength;this.shards.push({buffer:a,start:t,end:s}),t=s}0===this.shards.length&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.byteLength;if(0===this.shards.length)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),t=Math.min(this.byteLength,t),t<=e)return new ArrayBuffer(0);const n=this.findShardForByte(e);if(-1===n)throw new Error("Could not find start shard for byte ".concat(e));const a=new ArrayBuffer(t-e),s=new Uint8Array(a);let r=0;for(let i=n;i<this.shards.length;i++){const n=this.shards[i],a=e+r-n.start,o=r,c=Math.min(t,n.end)-n.start,l=new Uint8Array(n.buffer,a,c-a);if(s.set(l,o),r+=l.length,t<n.end)break}return a}findShardForByte(e){if(0===this.shards.length||e<0||e>=this.byteLength)return-1;if(null!=this.bufferUniformSize)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(t){return e<t.start?-1:e>=t.end?1:0}if(0===t(this.shards[this.previousShardIndex]))return this.previousShardIndex;const n=function(e,t){let n=0,a=e.length;for(;n<=a;){const s=Math.floor((a-n)/2)+n,r=t(e[s]);if(0===r)return s;r<0?a=s:n=s+1}return-1}(this.shards,t);return-1===n?-1:(this.previousShardIndex=n,this.previousShardIndex)}}function Gm(){return Tm}function qm(){return Tm.memory()}function Km(e,t){return Tm.tidy(e,t)}function Xm(e){wm(e).forEach(e=>e.dispose())}function Ym(e){return Tm.keep(e)}function Qm(){return Tm.backendName}function Zm(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Tm.registerBackend(e,t,n)}function Jm(){return Tm.backend}!function(e){rm=e}(function(e){$u().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")});const $m=4;async function eg(e,t){const n=[],a=[],s=Array.isArray(e)?e.map(e=>e.name):Object.keys(e);for(let r=0;r<s.length;++r){const i=s[r],o=Array.isArray(e)?e[r].tensor:e[i];if("float32"!==o.dtype&&"int32"!==o.dtype&&"bool"!==o.dtype&&"string"!==o.dtype&&"complex64"!==o.dtype)throw new Error("Unsupported dtype in weight '".concat(i,"': ").concat(o.dtype));const c={name:i,shape:o.shape,dtype:o.dtype};if("string"===o.dtype){const e=new Promise(async e=>{const t=await o.bytes(),n=t.reduce((e,t)=>e+t.length,0)+$m*t.length,a=new Uint8Array(n);let s=0;for(let r=0;r<t.length;r++){const e=t[r],n=new Uint8Array(new Uint32Array([e.length]).buffer);a.set(n,s),s+=$m,a.set(e,s),s+=e.length}e(a)});a.push(e)}else a.push(o.data());null!=t&&(c.group=t),n.push(c)}return{data:og(await Promise.all(a)),specs:n}}function tg(e,t){const n=new Hm(e),a={};let s=0;for(const r of t){const e=ng(r,(e,t)=>n.slice(s+e,s+t));a[r.name]=sg(r,n.slice(s,s+e)),s+=e}return a}function ng(e,t){const n=vu(e.shape);let a;if("quantization"in e){const t=e.quantization;a=Um[t.dtype]}else{if("string"===e.dtype){let e=0;for(let a=0;a<n;a++)e+=$m+new Uint32Array(t(e,e+$m))[0];return e}a=Um[e.dtype]}return n*a}async function ag(e,t){const n=vu(e.shape);let a;if("quantization"in e){const t=e.quantization;a=Um[t.dtype]}else{if("string"===e.dtype){let e=0;for(let a=0;a<n;a++)e+=$m+new Uint32Array(await t(e,e+$m))[0];return e}a=Um[e.dtype]}return n*a}function sg(e,t){const n=e.name,a=e.dtype,s=e.shape,r=vu(s);let i,o=0;if("quantization"in e){const s=e.quantization;if("uint8"===s.dtype||"uint16"===s.dtype){if(!("min"in s)||!("scale"in s))throw new Error("Weight ".concat(e.name," with quantization ").concat(s.dtype," ")+"doesn't have corresponding metadata min and scale.")}else{if("float16"!==s.dtype)throw new Error("Weight ".concat(e.name," has unknown ")+"quantization dtype ".concat(s.dtype,". ")+"Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.");if("float32"!==a)throw new Error("Weight ".concat(e.name," is quantized with ").concat(s.dtype," ")+"which only supports weights of type float32 not ".concat(a,"."))}const c=Um[s.dtype],l="uint8"===s.dtype?new Uint8Array(t):new Uint16Array(t);if("float32"===a)if("uint8"===s.dtype||"uint16"===s.dtype){i=new Float32Array(l.length);for(let e=0;e<l.length;e++){const t=l[e];i[e]=t*s.scale+s.min}}else{if("float16"!==s.dtype)throw new Error("Unsupported quantization type ".concat(s.dtype," ")+"for weight type float32.");{const e=function(){const e=function(){const e=e=>{let t=e<<13,n=0;for(;0===(8388608&t);)n-=8388608,t<<=1;return t&=-8388609,n+=947912704,t|n},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let n=1024;n<2048;n++)t[n]=939524096+(n-1024<<13);return t}(),t=function(){const e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}(),n=function(){const e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}();return a=>{const s=new ArrayBuffer(4*a.length),r=new Uint32Array(s);for(let i=0;i<a.length;i++){const s=a[i],o=e[n[s>>10]+(1023&s)]+t[s>>10];r[i]=o}return new Float32Array(s)}}();i=e(l)}}else{if("int32"!==a)throw new Error("Unsupported dtype in weight '".concat(n,"': ").concat(a));if("uint8"!==s.dtype&&"uint16"!==s.dtype)throw new Error("Unsupported quantization type ".concat(s.dtype," ")+"for weight type int32.");i=new Int32Array(l.length);for(let e=0;e<l.length;e++){const t=l[e];i[e]=Math.round(t*s.scale+s.min)}}o+=r*c}else if("string"===a){const n=vu(e.shape);i=[];for(let e=0;e<n;e++){const e=new Uint32Array(t.slice(o,o+$m))[0];o+=$m;const n=new Uint8Array(t.slice(o,o+e));i.push(n),o+=e}}else{const e=Um[a];if("float32"===a)i=new Float32Array(t);else if("int32"===a)i=new Int32Array(t);else{if("bool"!==a){if("complex64"===a){i=new Float32Array(t);const e=new Float32Array(i.length/2),n=new Float32Array(i.length/2);for(let t=0;t<e.length;t++)e[t]=i[2*t],n[t]=i[2*t+1];const a=Vm(e,s,"float32"),r=Vm(n,s,"float32"),o=jm(a,r);return a.dispose(),r.dispose(),o}throw new Error("Unsupported dtype in weight '".concat(n,"': ").concat(a))}i=new Uint8Array(t)}o+=r*e}return Vm(i,s,a)}async function rg(e,t,n){let a=new Uint8Array(t);for(;a.byteLength<n;){const{done:t,value:s}=await e.read();if(t&&null==s){const e=n-a.byteLength;throw new Error("Reader is done but ".concat(e," bytes are still expected"))}const r=new Uint8Array(a.length+s.byteLength);r.set(a,0),r.set(new Uint8Array(s),a.length),a=r}return a.buffer}async function ig(e,t){const n={},a=e.getReader();let s=new ArrayBuffer(0);for(const r of t){const e=await ag(r,async(e,t)=>(s=await rg(a,s,t),s.slice(e,t)));s=await rg(a,s,e);const t=s.slice(0,e);s=s.slice(e);const i=sg(r,t);if(n[r.name]=i,"webgpu"===Qm()){const e=Jm();"uploadToGPU"in e&&vu(i.shape)>=$u().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&e.uploadToGPU(i.dataId)}}return n}function og(e){if(null===e)throw new Error("Invalid input value: ".concat(JSON.stringify(e)));let t=0;const n=[];e.forEach(e=>{if(t+=e.byteLength,n.push(e.byteLength===e.buffer.byteLength?e:new e.constructor(e)),!(e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array))throw new Error("Unsupported TypedArray subtype: ".concat(e.constructor.name))});const a=new Uint8Array(t);let s=0;return n.forEach(e=>{a.set(new Uint8Array(e.buffer),s),s+=e.byteLength}),a.buffer}const cg="undefined"!==typeof Buffer&&("undefined"===typeof Blob||"undefined"===typeof atob||"undefined"===typeof btoa);function lg(e){return cg?Buffer.byteLength(e,"utf8"):new Blob([e]).size}function ug(e){return Hm.join(e)}function hg(e){for(e=e.trim();e.endsWith("/");)e=e.slice(0,e.length-1);const t=e.split("/");return t[t.length-1]}function dg(e,t){const n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(n.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(n.trainingConfig=e.trainingConfig),n}function pg(e,t,n){const a={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(null!=e.trainingConfig&&(a.trainingConfig=e.trainingConfig),null!=e.weightsManifest){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");a.weightSpecs=t,a.weightData=n}return null!=e.signature&&(a.signature=e.signature),null!=e.userDefinedMetadata&&(a.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(a.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(a.initializerSignature=e.initializerSignature),a}async function fg(e,t){let n,a;return null!=e.weightsManifest&&([n,a]=await t(e.weightsManifest)),pg(e,n,a)}function mg(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==e.modelTopology?0:lg(JSON.stringify(e.modelTopology)),weightSpecsBytes:null==e.weightSpecs?0:lg(JSON.stringify(e.weightSpecs)),weightDataBytes:null==e.weightData?0:new Hm(e.weightData).byteLength}}function gg(e){const t=[];for(const n of e)t.push(...n.weights);return t}class yg{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==yg.instance&&(yg.instance=new yg),yg.instance}static registerSaveRouter(e){yg.getInstance().saveRouters.push(e)}static registerLoadRouter(e){yg.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return yg.getHandlers(e,"save")}static getLoadHandlers(e,t){return yg.getHandlers(e,"load",t)}static getHandlers(e,t,n){const a=[];return("load"===t?yg.getInstance().loadRouters:yg.getInstance().saveRouters).forEach(t=>{const s=t(e,n);null!==s&&a.push(s)}),a}}const bg=e=>yg.registerSaveRouter(e),xg=e=>yg.registerLoadRouter(e),vg=e=>yg.getSaveHandlers(e),wg=(e,t)=>yg.getLoadHandlers(e,t),kg="tensorflowjs",Sg="models_store",Cg="model_info_store";function Ig(){if(!$u().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const e="undefined"===typeof window?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function Ng(e){const t=e.result;t.createObjectStore(Sg,{keyPath:"modelPath"}),t.createObjectStore(Cg,{keyPath:"modelPath"})}class Tg{constructor(e){if(this.indexedDB=Ig(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((e,n)=>{const a=this.indexedDB.open(kg,1);a.onupgradeneeded=()=>Ng(a),a.onsuccess=()=>{const s=a.result;if(null==t){const t=s.transaction(Sg,"readonly"),a=t.objectStore(Sg).get(this.modelPath);a.onsuccess=()=>{if(null==a.result)return s.close(),n(new Error("Cannot find model with path '".concat(this.modelPath,"' ")+"in IndexedDB."));e(a.result.modelArtifacts)},a.onerror=e=>(s.close(),n(a.error)),t.oncomplete=()=>s.close()}else{t.weightData=Hm.join(t.weightData);const a=mg(t),i=s.transaction(Cg,"readwrite");let o,c,l=i.objectStore(Cg);try{o=l.put({modelPath:this.modelPath,modelArtifactsInfo:a})}catch(r){return n(r)}o.onsuccess=()=>{c=s.transaction(Sg,"readwrite");const o=c.objectStore(Sg);let u;try{u=o.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:a})}catch(r){return n(r)}u.onsuccess=()=>e({modelArtifactsInfo:a}),u.onerror=e=>{l=i.objectStore(Cg);const t=l.delete(this.modelPath);t.onsuccess=()=>(s.close(),n(u.error)),t.onerror=e=>(s.close(),n(u.error))}},o.onerror=e=>(s.close(),n(o.error)),i.oncomplete=()=>{null==c?s.close():c.oncomplete=()=>s.close()}}},a.onerror=e=>n(a.error)})}}Tg.URL_SCHEME="indexeddb://";const Eg=e=>{return $u().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Tg.URL_SCHEME)?(t=e.slice(Tg.URL_SCHEME.length),new Tg(t)):null;var t};yg.registerSaveRouter(Eg),yg.registerLoadRouter(Eg);class Rg{constructor(){this.indexedDB=Ig()}async listModels(){return new Promise((e,t)=>{const n=this.indexedDB.open(kg,1);n.onupgradeneeded=()=>Ng(n),n.onsuccess=()=>{const a=n.result,s=a.transaction(Cg,"readonly"),r=s.objectStore(Cg).getAll();r.onsuccess=()=>{const t={};for(const e of r.result)t[e.modelPath]=e.modelArtifactsInfo;e(t)},r.onerror=e=>(a.close(),t(r.error)),s.oncomplete=()=>a.close()},n.onerror=e=>t(n.error)})}async removeModel(e){var t;return e=(t=e).startsWith(Tg.URL_SCHEME)?t.slice(Tg.URL_SCHEME.length):t,new Promise((t,n)=>{const a=this.indexedDB.open(kg,1);a.onupgradeneeded=()=>Ng(a),a.onsuccess=()=>{const s=a.result,r=s.transaction(Cg,"readwrite"),i=r.objectStore(Cg),o=i.get(e);let c;o.onsuccess=()=>{if(null==o.result)return s.close(),n(new Error("Cannot find model with path '".concat(e,"' ")+"in IndexedDB."));{const a=i.delete(e),r=()=>{c=s.transaction(Sg,"readwrite");const a=c.objectStore(Sg).delete(e);a.onsuccess=()=>t(o.result.modelArtifactsInfo),a.onerror=e=>n(o.error)};a.onsuccess=r,a.onerror=e=>(r(),s.close(),n(o.error))}},o.onerror=e=>(s.close(),n(o.error)),r.oncomplete=()=>{null==c?s.close():c.oncomplete=()=>s.close()}},a.onerror=e=>n(a.error)})}}const _g="/",Ag="tensorflowjs_models",Mg="info",Pg="model_topology",Dg="weight_specs",Og="weight_data",Fg="model_metadata";function Lg(e){return{info:[Ag,e,Mg].join(_g),topology:[Ag,e,Pg].join(_g),weightSpecs:[Ag,e,Dg].join(_g),weightData:[Ag,e,Og].join(_g),modelMetadata:[Ag,e,Fg].join(_g)}}function zg(e){for(const t of Object.values(e))window.localStorage.removeItem(t)}function Bg(e){const t=e.split(_g);if(t.length<3)throw new Error("Invalid key format: ".concat(e));return t.slice(1,t.length-1).join(_g)}class jg{constructor(e){if(!$u().getBool("IS_BROWSER")||"undefined"===typeof window||"undefined"===typeof window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=Lg(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const n=JSON.stringify(e.modelTopology),a=JSON.stringify(e.weightSpecs),s=mg(e),r=Hm.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(s)),this.LS.setItem(this.keys.topology,n),this.LS.setItem(this.keys.weightSpecs,a),this.LS.setItem(this.keys.weightData,function(e){if(cg)return Buffer.from(e).toString("base64");const t=new Uint8Array(e);let n="";for(let a=0,s=t.length;a<s;a++)n+=String.fromCharCode(t[a]);return btoa(n)}(r));const t={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,initializerSignature:null!=e.initializerSignature?e.initializerSignature:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(t)),{modelArtifactsInfo:s}}catch(t){throw zg(this.keys),new Error("Failed to save model '".concat(this.modelPath,"' to local storage: ")+"size quota being exceeded is a possible cause of this failure: "+"modelTopologyBytes=".concat(s.modelTopologyBytes,", ")+"weightSpecsBytes=".concat(s.weightSpecsBytes,", ")+"weightDataBytes=".concat(s.weightDataBytes,"."))}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(null==e)throw new Error("In local storage, there is no model with name '".concat(this.modelPath,"'"));if("JSON"!==e.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error("In local storage, the topology of model '".concat(this.modelPath,"' ")+"is missing.");t.modelTopology=n;const a=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==a)throw new Error("In local storage, the weight specs of model '".concat(this.modelPath,"' ")+"are missing.");t.weightSpecs=a;const s=this.LS.getItem(this.keys.modelMetadata);if(null!=s){const e=JSON.parse(s);t.format=e.format,t.generatedBy=e.generatedBy,t.convertedBy=e.convertedBy,null!=e.signature&&(t.signature=e.signature),null!=e.userDefinedMetadata&&(t.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(t.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(t.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(t.trainingConfig=e.trainingConfig)}const r=this.LS.getItem(this.keys.weightData);if(null==r)throw new Error("In local storage, the binary weight values of model "+"'".concat(this.modelPath,"' are missing."));return t.weightData=function(e){if(cg){const t=Buffer.from(e,"base64");return t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)}const t=atob(e),n=new Uint8Array(t.length);for(let a=0;a<t.length;++a)n.set([t.charCodeAt(a)],a);return n.buffer}(r),t}}jg.URL_SCHEME="localstorage://";const Wg=e=>{return $u().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(jg.URL_SCHEME)?(t=e.slice(jg.URL_SCHEME.length),new jg(t)):null;var t};yg.registerSaveRouter(Wg),yg.registerLoadRouter(Wg);class Vg{constructor(){yu($u().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),yu("undefined"===typeof window||"undefined"!==typeof window.localStorage,()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},t=Ag+_g,n=_g+Mg;for(let a=0;a<this.LS.length;++a){const s=this.LS.key(a);if(s.startsWith(t)&&s.endsWith(n)){e[Bg(s)]=JSON.parse(this.LS.getItem(s))}}return e}async removeModel(e){var t;const n=Lg(e=(t=e).startsWith(jg.URL_SCHEME)?t.slice(jg.URL_SCHEME.length):t);if(null==this.LS.getItem(n.info))throw new Error("Cannot find model at path '".concat(e,"'"));const a=JSON.parse(this.LS.getItem(n.info));return zg(n),a}}const Ug="://";class Hg{constructor(){this.managers={}}static getInstance(){return null==Hg.instance&&(Hg.instance=new Hg),Hg.instance}static registerManager(e,t){yu(null!=e,()=>"scheme must not be undefined or null."),e.endsWith(Ug)&&(e=e.slice(0,e.indexOf(Ug))),yu(e.length>0,()=>"scheme must not be an empty string.");const n=Hg.getInstance();yu(null==n.managers[e],()=>"A model store manager is already registered for scheme '".concat(e,"'.")),n.managers[e]=t}static getManager(e){const t=Hg.getInstance().managers[e];if(null==t)throw new Error("Cannot find model manager for scheme '".concat(e,"'"));return t}static getSchemes(){return Object.keys(Hg.getInstance().managers)}}function Gg(e){if(-1===e.indexOf(Ug))throw new Error("The url string provided does not contain a scheme. Supported schemes are: "+"".concat(Hg.getSchemes().join(",")));return{scheme:e.split(Ug)[0],path:e.split(Ug)[1]}}async function qg(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];yu(e!==t,()=>"Old path and new path are the same: '".concat(e,"'"));const a=yg.getLoadHandlers(e);yu(a.length>0,()=>"Copying failed because no load handler is found for source URL ".concat(e,".")),yu(a.length<2,()=>"Copying failed because more than one (".concat(a.length,") ")+"load handlers for source URL ".concat(e,"."));const s=a[0],r=yg.getSaveHandlers(t);yu(r.length>0,()=>"Copying failed because no save handler is found for destination "+"URL ".concat(t,".")),yu(r.length<2,()=>"Copying failed because more than one (".concat(a.length,") ")+"save handlers for destination URL ".concat(t,"."));const i=r[0],o=Gg(e).scheme,c=Gg(e).path,l=o===Gg(e).scheme,u=await s.load();n&&l&&await Hg.getManager(o).removeModel(c);const h=await i.save(u);return n&&!l&&await Hg.getManager(o).removeModel(c),h.modelArtifactsInfo}async function Kg(){const e=Hg.getSchemes(),t={};for(const n of e){const e=await Hg.getManager(n).listModels();for(const a in e){t[n+Ug+a]=e[a]}}return t}async function Xg(e){const t=Gg(e);return Hg.getManager(t.scheme).removeModel(t.path)}async function Yg(e,t){return qg(e,t,!1)}async function Qg(e,t){return qg(e,t,!0)}class Zg{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error("Browser's encoder only supports utf-8, but got ".concat(t));return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){"undefined"!==typeof window&&$u().getBool("USE_SETTIMEOUTCUSTOM")?(this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",e=>{if(e.source===window&&e.data.name===this.messageName){e.stopPropagation();(0,this.functionRefs[e.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))):setTimeout(e,t)}isTypedArray(e){return Nf(e)}}if($u().get("IS_BROWSER")){$u().setPlatform("browser",new Zg);try{Hg.registerManager(jg.URL_SCHEME,new Vg)}catch(q5){}try{Hg.registerManager(Tg.URL_SCHEME,new Rg)}catch(q5){}}const Jg=()=>n(817);let $g;class ey{constructor(){this.util=n(590),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return null!=$u().global.fetch?$u().global.fetch(e,t):(null==$g&&($g=Jg()),$g(e,t))}now(){const e=process.hrtime();return 1e3*e[0]+e[1]/1e6}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error("Node built-in encoder only supports utf-8, but got ".concat(t));return this.textEncoder.encode(e)}decode(e,t){return 0===e.length?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}function ty(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32",n=arguments.length>2?arguments[2]:void 0;return t=t||"float32",qu(e),new nm(e,t,n)}$u().get("IS_NODE")&&!$u().get("IS_BROWSER")&&$u().setPlatform("node",new ey);const ny=Bm({cast_:function(e,t){const n=Fm(e,"x","cast");if(!function(e){return"bool"===e||"complex64"===e||"float32"===e||"int32"===e||"string"===e}(t))throw new Error("Failed to cast to unknown dtype ".concat(t));if("string"===t&&"string"!==n.dtype||"string"!==t&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");const a={x:n},s={dtype:t};return Tm.runKernel(Th,a,s)}});const ay=Bm({clone_:function(e){const t={x:Fm(e,"x","clone","string_or_numeric")};return Tm.runKernel(xd,t)}});function sy(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];console.log(e.toString(t))}Nm();sm={buffer:ty,cast:ny,clone:ay,print:sy};const ry=Bm({add_:function(e,t){let n=Fm(e,"a","add"),a=Fm(t,"b","add");[n,a]=xm(n,a);const s={a:n,b:a};return Tm.runKernel(oh,s)}});const iy=Bm({floorDiv_:function(e,t){let n=Fm(e,"a","floorDiv"),a=Fm(t,"b","floorDiv");[n,a]=xm(n,a);const s={a:n,b:a};return Tm.runKernel(pd,s)}});const oy=Bm({div_:function(e,t){let n=Fm(e,"a","div"),a=Fm(t,"b","div");if([n,a]=xm(n,a),"int32"===n.dtype&&"int32"===a.dtype)return iy(n,a);const s={a:n,b:a};return Tm.runKernel(ed,s,{})}});const cy=Bm({mul_:function(e,t){let n=Fm(e,"a","mul"),a=Fm(t,"b","mul");[n,a]=xm(n,a);const s={a:n,b:a};return Tm.runKernel(Yd,s)}});const ly=Bm({sqrt_:function(e){const t={x:Fm(e,"x","sqrt","float32")};return Tm.runKernel(Op,t)}});const uy=Bm({square_:function(e){const t=Fm(e,"x","square");return Tm.runKernel("Square",{x:t},{})}});const hy=Bm({zerosLike_:function(e){const t={x:Fm(e,"x","zerosLike")};return Tm.runKernel(lf,t)}});function dy(e){return Tm.customGrad(e)}function py(e,t){if((qf(e)&&"string"!==t||Array.isArray(e))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&qf(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Wm(e,[],[],t)}const fy=new Map,my=new Map;class gy{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class yy{constructor(){this.classNameMap={}}static getMap(){return null==yy.instance&&(yy.instance=new yy),yy.instance}static register(e){yy.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function by(e,t,n){yu(null!=e.className,()=>"Class being registered does not have the static className property defined."),yu("string"===typeof e.className,()=>"className is required to be a string, but got type "+typeof e.className),yu(e.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),"undefined"===typeof t&&(t="Custom"),"undefined"===typeof n&&(n=e.className);const a=t+">"+n;return yy.register(e),fy.set(a,e),my.set(e,a),e}class xy extends gy{minimize(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2?arguments[2]:void 0;const{value:a,grads:s}=this.computeGradients(e,n);if(null!=n){const e=n.map(e=>({name:e.name,tensor:s[e.name]}));this.applyGradients(e)}else this.applyGradients(s);return Xm(s),t?a:(a.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return function(e,t){yu(Lu(e),()=>"The f passed in variableGrads(f) must be a function"),yu(null==t||Array.isArray(t)&&t.every(e=>e instanceof cm),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const n=null!=t;if(!n){t=[];for(const e in Tm.registeredVariables)t.push(Tm.registeredVariables[e])}const a=n?t.filter(e=>!e.trainable):null,s=t.length;t=t.filter(e=>e.trainable),yu(t.length>0,()=>"variableGrads() expects at least one of the input variables to "+"be trainable, but none of the ".concat(s," variables is ")+"trainable.");const{value:r,grads:i}=Tm.gradients(e,t,null,!0);yu(i.some(e=>null!=e),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),yu(0===r.rank,()=>"The f passed in variableGrads(f) must return a scalar, but it "+"returned a rank-".concat(r.rank," tensor"));const o={};return t.forEach((e,t)=>{null!=i[t]&&(o[e.name]=i[t])}),null!=a&&a.forEach(e=>o[e.name]=null),{value:r,grads:o}}(e,t)}dispose(){null!=this.iterations_&&Xm(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:py(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for this optimizer class "+"".concat(this.getClassName()))}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(xy,Symbol.hasInstance,{value:e=>null!=e.minimize&&null!=e.computeGradients&&null!=e.applyGradients});class vy extends xy{static get className(){return"Adadelta"}constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=Tm.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,n)=>{const a=Tm.registeredVariables[t],s=!1;null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:"".concat(t,"/accum_grad"),variable:Km(()=>hy(a).variable(s))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:"".concat(t,"/accum_var"),variable:Km(()=>hy(a).variable(s))});const r=Array.isArray(e)?e[n].tensor:e[t];if(null==r)return;const i=this.accumulatedGrads[n].variable,o=this.accumulatedUpdates[n].variable;Km(()=>{const e=ry(cy(i,this.rho),cy(uy(r),1-this.rho)),t=cy(oy(ly(ry(o,this.epsilon)),ly(ry(i,this.epsilon))),r),n=ry(cy(o,this.rho),cy(uy(t),1-this.rho));i.assign(e),o.assign(n);const s=ry(cy(t,-this.learningRate),a);a.assign(s)})}),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(Xm(this.accumulatedGrads.map(e=>e.variable)),Xm(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){const t=(e=await this.extractIterations(e)).length/2,n=!1;this.accumulatedGrads=e.slice(0,t).map(e=>({originalName:e.name,variable:e.tensor.variable(n)})),this.accumulatedUpdates=e.slice(t,2*t).map(e=>({originalName:e.name,variable:e.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}function wy(e,t,n){qu(e);const a={shape:e,value:t,dtype:n=n||Fu(t)};return Tm.runKernel(ud,{},a)}class ky extends xy{static get className(){return"Adagrad"}constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.1;super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,n)=>{const a=Tm.registeredVariables[t];if(null==this.accumulatedGrads[n]){const e=!1;this.accumulatedGrads[n]={originalName:"".concat(t,"/accumulator"),variable:Km(()=>wy(a.shape,this.initialAccumulatorValue).variable(e))}}const s=Array.isArray(e)?e[n].tensor:e[t];if(null==s)return;const r=this.accumulatedGrads[n].variable;Km(()=>{const e=ry(r,uy(s));r.assign(e);const t=ry(cy(oy(s,ly(ry(e,Tm.backend.epsilon()))),-this.learningRate),a);a.assign(t)})}),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&Xm(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);this.accumulatedGrads=e.map(e=>({originalName:e.name,variable:e.tensor.variable(false)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}const Sy=Bm({pow_:function(e,t){let n=Fm(e,"base","pow"),a=Fm(t,"exp","pow");[n,a]=xm(n,a);const s={a:n,b:a};return Tm.runKernel(rp,s)}});const Cy=Bm({sub_:function(e,t){let n=Fm(e,"a","sub"),a=Fm(t,"b","sub");[n,a]=xm(n,a);const s={a:n,b:a};return Tm.runKernel(Jp,s)}});class Iy extends xy{static get className(){return"Adam"}constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=a,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],Km(()=>{this.accBeta1=py(t).variable(),this.accBeta2=py(n).variable()}),null==a&&(this.epsilon=Tm.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(e=>e.name):Object.keys(e);Km(()=>{const n=Cy(1,this.accBeta1),a=Cy(1,this.accBeta2);t.forEach((t,s)=>{const r=Tm.registeredVariables[t],i=!1;null==this.accumulatedFirstMoment[s]&&(this.accumulatedFirstMoment[s]={originalName:"".concat(t,"/m"),variable:Km(()=>hy(r).variable(i))}),null==this.accumulatedSecondMoment[s]&&(this.accumulatedSecondMoment[s]={originalName:"".concat(t,"/v"),variable:Km(()=>hy(r).variable(i))});const o=Array.isArray(e)?e[s].tensor:e[t];if(null==o)return;const c=this.accumulatedFirstMoment[s].variable,l=this.accumulatedSecondMoment[s].variable,u=ry(cy(c,this.beta1),cy(o,1-this.beta1)),h=ry(cy(l,this.beta2),cy(uy(o),1-this.beta2)),d=oy(u,n),p=oy(h,a);c.assign(u),l.assign(h);const f=ry(cy(oy(d,ry(ly(p),this.epsilon)),-this.learningRate),r);r.assign(f)}),this.accBeta1.assign(cy(this.accBeta1,this.beta1)),this.accBeta2.assign(cy(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&Xm(this.accumulatedFirstMoment.map(e=>e.variable)),null!=this.accumulatedSecondMoment&&Xm(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e),Km(()=>{this.accBeta1.assign(Sy(this.beta1,this.iterations_+1)),this.accBeta2.assign(Sy(this.beta2,this.iterations_+1))});const t=e.length/2,n=!1;this.accumulatedFirstMoment=e.slice(0,t).map(e=>({originalName:e.name,variable:e.tensor.variable(n)})),this.accumulatedSecondMoment=e.slice(t,2*t).map(e=>({originalName:e.name,variable:e.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}const Ny=Bm({abs_:function(e){const t=Fm(e,"x","abs");if("complex64"===t.dtype){const e={x:t};return Tm.runKernel(Ah,e)}{const e={x:t};return Tm.runKernel(sh,e)}}});function Ty(e,t){const n=e.length,a=[];for(let s=0;s<n;s++){const r=n-1-s,i=e[r]||1;(t[t.length-1-s]||1)>1&&1===i&&a.unshift(r)}return a}function Ey(e,t){const n=[];for(let a=0;a<t.length;a++){const s=e[e.length-a-1],r=t.length-a-1,i=t[r];(null==s||1===s&&i>1)&&n.unshift(r)}return n}function Ry(e,t){const n=Math.max(e.length,t.length),a=new Array(n);for(let s=0;s<n;s++){let r=e[e.length-s-1];null==r&&(r=1);let i=t[t.length-s-1];if(null==i&&(i=1),1===r)a[n-s-1]=i;else if(1===i)a[n-s-1]=r;else{if(r!==i){const n="Operands could not be broadcast together with shapes "+"".concat(e," and ").concat(t,".");throw Error(n)}a[n-s-1]=r}}return a}const _y=Bm({maximum_:function(e,t){let n=Fm(e,"a","maximum"),a=Fm(t,"b","maximum");[n,a]=xm(n,a),"bool"===n.dtype&&(n=ny(n,"int32"),a=ny(a,"int32")),Ry(n.shape,a.shape);const s={a:n,b:a};return Tm.runKernel(Ld,s)}});class Ay extends xy{static get className(){return"Adamax"}constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0;super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=a,this.decay=s,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],Km(()=>{this.iteration=py(0).variable(),this.accBeta1=py(t).variable()}),null==a&&(this.epsilon=Tm.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(e=>e.name):Object.keys(e);Km(()=>{const n=Cy(1,this.accBeta1),a=oy(-this.learningRate,ry(cy(this.iteration,this.decay),1));t.forEach((t,s)=>{const r=Tm.registeredVariables[t],i=!1;null==this.accumulatedFirstMoment[s]&&(this.accumulatedFirstMoment[s]={originalName:"".concat(t,"/m"),variable:hy(r).variable(i)}),null==this.accumulatedWeightedInfNorm[s]&&(this.accumulatedWeightedInfNorm[s]={originalName:"".concat(t,"/v"),variable:hy(r).variable(i)});const o=Array.isArray(e)?e[s].tensor:e[t];if(null==o)return;const c=this.accumulatedFirstMoment[s].variable,l=this.accumulatedWeightedInfNorm[s].variable,u=ry(cy(c,this.beta1),cy(o,1-this.beta1)),h=cy(l,this.beta2),d=Ny(o),p=_y(h,d);c.assign(u),l.assign(p);const f=ry(cy(oy(a,n),oy(u,ry(p,this.epsilon))),r);r.assign(f)}),this.iteration.assign(ry(this.iteration,1)),this.accBeta1.assign(cy(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&Xm(this.accumulatedFirstMoment.map(e=>e.variable)),null!=this.accumulatedWeightedInfNorm&&Xm(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}class My extends xy{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,n)=>{const a=Array.isArray(e)?e[n].tensor:e[t];if(null==a)return;const s=Tm.registeredVariables[t];Km(()=>{const e=ry(cy(this.c,a),s);s.assign(e)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,null!=this.c&&this.c.dispose(),this.c=Ym(py(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(0!==(e=await this.extractIterations(e)).length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}class Py extends My{static get className(){return"Momentum"}constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=py(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,n)=>{const a=Tm.registeredVariables[t];if(null==this.accumulations[n]){const e=!1;this.accumulations[n]={originalName:"".concat(t,"/momentum"),variable:Km(()=>hy(a).variable(e))}}const s=this.accumulations[n].variable,r=Array.isArray(e)?e[n].tensor:e[t];null!=r&&Km(()=>{let e;const t=ry(cy(this.m,s),r);e=this.useNesterov?ry(cy(this.c,ry(r,cy(t,this.m))),a):ry(cy(this.c,t),a),s.assign(t),a.assign(e)})}),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&Xm(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);this.accumulations=e.map(e=>({originalName:e.name,variable:e.tensor.variable(false)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}class Dy extends xy{static get className(){return"RMSProp"}constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,s=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=a,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=s,null==a&&(this.epsilon=Tm.backend.epsilon()),null==e)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,n)=>{const a=Tm.registeredVariables[t],s=!1;null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:"".concat(t,"/rms"),variable:Km(()=>hy(a).variable(s))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:"".concat(t,"/momentum"),variable:Km(()=>hy(a).variable(s))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:"".concat(t,"/mg"),variable:Km(()=>hy(a).variable(s))});const r=Array.isArray(e)?e[n].tensor:e[t];if(null==r)return;const i=this.accumulatedMeanSquares[n].variable,o=this.accumulatedMoments[n].variable;Km(()=>{const e=ry(cy(i,this.decay),cy(uy(r),1-this.decay));if(this.centered){const t=this.accumulatedMeanGrads[n].variable,s=ry(cy(t,this.decay),cy(r,1-this.decay)),c=oy(cy(r,this.learningRate),ly(Cy(e,ry(uy(s),this.epsilon)))),l=ry(cy(o,this.momentum),c);i.assign(e),t.assign(s),o.assign(l);const u=Cy(a,l);a.assign(u)}else{const e=ry(cy(i,this.decay),cy(uy(r),1-this.decay)),t=ry(cy(o,this.momentum),oy(cy(r,this.learningRate),ly(ry(e,this.epsilon))));i.assign(e),o.assign(t);const n=Cy(a,t);a.assign(n)}})}),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&Xm(this.accumulatedMeanSquares.map(e=>e.variable)),null!=this.accumulatedMeanGrads&&this.centered&&Xm(this.accumulatedMeanGrads.map(e=>e.variable)),null!=this.accumulatedMoments&&Xm(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map(e=>({originalName:e.name,variable:e.tensor.variable(n)})),this.accumulatedMoments=e.slice(t,2*t).map(e=>({originalName:e.name,variable:e.tensor.variable(n)})),this.centered&&(this.accumulatedMeanGrads=e.slice(2*t,3*t).map(e=>({originalName:e.name,variable:e.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}const Oy=[vy,ky,Iy,Ay,Py,Dy,My];function Fy(e){return new Promise(e=>setTimeout(e)).then(e)}class Ly{constructor(e){if(!$u().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(Ly.URL_SCHEME)&&(e=e.slice(Ly.URL_SCHEME.length)),null!=e&&0!==e.length||(e="model"),this.modelJsonFileName=e+".json",this.weightDataFileName=e+".weights.bin"}async save(e){if("undefined"===typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=Hm.join(e.weightData),n=window.URL.createObjectURL(new Blob([t],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const t=dg(e,[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}]),a=window.URL.createObjectURL(new Blob([JSON.stringify(t)],{type:"application/json"})),s=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(s.download=this.modelJsonFileName,s.href=a,await Fy(()=>s.dispatchEvent(new MouseEvent("click"))),null!=e.weightData){const e=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;e.download=this.weightDataFileName,e.href=n,await Fy(()=>e.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:mg(e)}}}}Ly.URL_SCHEME="downloads://";class zy{constructor(e){if(null==e||e.length<1)throw new Error("When calling browserFiles, at least 1 file is required, "+"but received ".concat(e));this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{const n=new FileReader;n.onload=n=>{const a=JSON.parse(n.target.result),s=a.modelTopology;if(null==s)return void t(new Error("modelTopology field is missing from file ".concat(this.jsonFile.name)));if(null==a.weightsManifest)return void t(new Error("weightManifest field is missing from file ".concat(this.jsonFile.name)));if(0===this.weightsFiles.length)return void e({modelTopology:s});const r=fg(a,e=>this.loadWeights(e));e(r)},n.onerror=e=>t("Failed to read model topology and weights manifest JSON "+"from file '".concat(this.jsonFile.name,"'. BrowserFiles supports loading ")+"Keras-style tf.Model artifacts only."),n.readAsText(this.jsonFile)})}loadWeights(e){const t=[],n=[];for(const r of e)t.push(...r.weights),n.push(...r.paths);const a=this.checkManifestAndWeightFiles(e),s=n.map(e=>this.loadWeightsFile(e,a[e]));return Promise.all(s).then(e=>[t,e])}loadWeightsFile(e,t){return new Promise((n,a)=>{const s=new FileReader;s.onload=e=>{const t=e.target.result;n(t)},s.onerror=t=>a("Failed to weights data from file of path '".concat(e,"'.")),s.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){const t=[],n=this.weightsFiles.map(e=>hg(e.name)),a={};for(const s of e)s.paths.forEach(e=>{const s=hg(e);if(-1!==t.indexOf(s))throw new Error("Duplicate file basename found in weights manifest: "+"'".concat(s,"'"));if(t.push(s),-1===n.indexOf(s))throw new Error("Weight file with basename '".concat(s,"' is not provided."));a[e]=this.weightsFiles[n.indexOf(s)]});if(t.length!==this.weightsFiles.length)throw new Error("Mismatch in the number of files in weights manifest "+"(".concat(t.length,") and the number of weight files provided ")+"(".concat(this.weightsFiles.length,")."));return a}}function By(e){return new zy(e)}function jy(e,t,n,a){!function(e){yu(null!=e&&Array.isArray(e)&&e.length>0,()=>"promises must be a none empty array")}(e),function(e,t){yu(e>=0&&e<=1,()=>"Progress fraction must be in range [0, 1], but "+"got startFraction ".concat(e)),yu(t>=0&&t<=1,()=>"Progress fraction must be in range [0, 1], but "+"got endFraction ".concat(t)),yu(t>=e,()=>"startFraction must be no more than endFraction, but "+"got startFraction ".concat(e," and endFraction ")+"".concat(t))}(n=null==n?0:n,a=null==a?1:a);let s=0;return Promise.all(e.map(r=>(r.then(r=>{const i=n+ ++s/e.length*(a-n);return t(i),r}),r)))}async function Wy(e,t){null==t&&(t={});const n=null==t.fetchFunc?$u().platform.fetch:t.fetchFunc,a=e.map(e=>n(e,t.requestInit,{isBinary:!0})),s=(null==t.onProgress?await Promise.all(a):await jy(a,t.onProgress,0,.5)).map(e=>e.arrayBuffer());return null==t.onProgress?await Promise.all(s):await jy(s,t.onProgress,.5,1)}async function Vy(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",n=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0;return Uy(e=>Wy(e,{requestInit:a}))(e,t,n)}function Uy(e){return async function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",a=arguments.length>2?arguments[2]:void 0;const s=t.map(()=>!1),r={},i=null!=a?a.map(()=>!1):[],o=[];if(t.forEach((e,t)=>{let n=0;e.weights.forEach(e=>{const c="quantization"in e?e.quantization.dtype:e.dtype,l=Um[c]*vu(e.shape),u=()=>{s[t]=!0,null==r[t]&&(r[t]=[]),r[t].push({manifestEntry:e,groupOffset:n,sizeBytes:l})};null!=a?a.forEach((t,n)=>{t===e.name&&(u(),i[n]=!0)}):u(),o.push(e.name),n+=l})}),!i.every(e=>e)){const e=a.filter((e,t)=>!i[t]);throw new Error("Could not find weights in manifest with names: "+"".concat(e.join(", "),". \n")+"Manifest JSON has weights with names: "+"".concat(o.join(", "),"."))}const c=s.reduce((e,t,n)=>(t&&e.push(n),e),[]),l=[];c.forEach(e=>{t[e].paths.forEach(e=>{const t=n+(n.endsWith("/")?"":"/")+e;l.push(t)})});const u=await e(l),h={};let d=0;return c.forEach(e=>{const n=t[e].paths.length,a=new Hm(u.slice(d,d+n));r[e].forEach(e=>{const t=tg(a.slice(e.groupOffset,e.groupOffset+e.sizeBytes),[e.manifestEntry]);for(const n in t)h[n]=t[n]}),d+=n}),h}}yg.registerSaveRouter(e=>$u().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Ly.URL_SCHEME)?function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"model";return new Ly(e)}(e.slice(Ly.URL_SCHEME.length)):null);class Hy{constructor(e,t){if(this.DEFAULT_METHOD="POST",null==t&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,null!=t.fetchFunc?(yu("function"===typeof t.fetchFunc,()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=$u().platform.fetch,yu(null!=e&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&yu(2===e.length,()=>"URL paths for http must have a length of 2, "+"(actual length is ".concat(e.length,").")),this.path=e,null!=t.requestInit&&null!=t.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const n=dg(e,[{paths:["./model.weights.bin"],weights:e.weightSpecs}]);if(t.body.append("model.json",new Blob([JSON.stringify(n)],{type:"application/json"}),"model.json"),null!=e.weightData){const n=Hm.join(e.weightData);t.body.append("model.weights.bin",new Blob([n],{type:"application/octet-stream"}),"model.weights.bin")}const a=await this.fetch(this.path,t);if(a.ok)return{modelArtifactsInfo:mg(e),responses:[a]};throw new Error("BrowserHTTPRequest.save() failed due to HTTP response status "+"".concat(a.status,"."))}async loadModelJSON(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error("Request to ".concat(this.path," failed with status code ")+"".concat(e.status,". Please verify this URL points to ")+"the model JSON of the model to load.");let t;try{t=await e.json()}catch(G5){let t="Failed to parse model JSON of response from ".concat(this.path,".");throw this.path.endsWith(".pb")?t+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":t+=" Please make sure the server is serving valid JSON for this request.",new Error(t)}const n=t.modelTopology,a=t.weightsManifest;if(null==n&&null==a)throw new Error("The JSON from HTTP path ".concat(this.path," contains neither model ")+"topology or manifest for weights.");return t}async load(){if(this.loadOptions.streamWeights)return this.loadStream();return fg(await this.loadModelJSON(),e=>this.loadWeights(e))}async loadStream(){const e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),n=gg(e.weightsManifest);return Object.assign(Object.assign({},e),{weightSpecs:n,getWeightStream:()=>function(e,t){var n;const a=null==t.fetchFunc?$u().platform.fetch:t.fetchFunc;let s,r=0;return null===(n=t.onProgress)||void 0===n||n.call(t,0),new ReadableStream({pull:async n=>{for(var i;r<e.length;){if(!s){const n=(await a(e[r],t.requestInit,{isBinary:!0})).body;s=n.getReader()}const{done:o,value:c}=await s.read();if(!o)return void n.enqueue(c);r++,s=void 0,null===(i=t.onProgress)||void 0===i||i.call(t,r/e.length)}n.close()}})}(t,this.loadOptions)})}async getWeightUrls(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[n,a]=function(e){const t=e.lastIndexOf("/"),n=e.lastIndexOf("?"),a=e.substring(0,t),s=n>t?e.substring(n):"";return[a+"/",s]}(t),s=this.weightPathPrefix||n,r=[],i=[];for(const o of e)for(const e of o.paths)null!=this.weightUrlConverter?i.push(this.weightUrlConverter(e)):r.push(s+e+a);return this.weightUrlConverter&&r.push(...await Promise.all(i)),r}async loadWeights(e){const t=await this.getWeightUrls(e);return[gg(e),await Wy(t,this.loadOptions)]}}function Gy(e){return null!=e.match(Hy.URL_SCHEME_REGEX)}Hy.URL_SCHEME_REGEX=/^https?:\/\//;const qy=(e,t)=>{if("undefined"===typeof fetch&&(null==t||null==t.fetchFunc))return null;{let n=!0;if(n=Array.isArray(e)?e.every(e=>Gy(e)):Gy(e),n)return Ky(e,t)}return null};function Ky(e,t){return new Hy(e,t)}function Xy(e,t){return Ky(e,t)}yg.registerSaveRouter(qy),yg.registerLoadRouter(qy);class Yy{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class Qy{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class Zy{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}}function Jy(e,t,n,a){return new Zy($y(...arguments))}function $y(e,t,n,a){if(1===arguments.length){return null!=e.modelTopology||null!=e.weightSpecs?new Yy(e):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Yy({modelTopology:e}))}return console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Yy({modelTopology:e,weightSpecs:t,weightData:n,trainingConfig:a})}function eb(e){return new Qy(e)}function tb(e){return new Qy(e)}function nb(e,t,n){if(xu(e),null!=t&&3!==t.length)throw new Error("tensor3d() requires shape to have three numbers");const a=Pm(e,n);if(3!==a.length&&1!==a.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===a.length&&null==t)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Wm(e,t,a,n)}let ab,sb=!1;function rb(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==e)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,a=!1,s=!1,r=!1,i=!1,o=!1;if(e.data instanceof Uint8Array)n=!0;else if("undefined"!==typeof ImageData&&e instanceof ImageData)a=!0;else if("undefined"!==typeof HTMLVideoElement&&e instanceof HTMLVideoElement)s=!0;else if("undefined"!==typeof HTMLImageElement&&e instanceof HTMLImageElement)r=!0;else if(null!=e.getContext)i=!0;else{if(!("undefined"!==typeof ImageBitmap&&e instanceof ImageBitmap))throw new Error("pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, "+"but was ".concat(e.constructor.name));o=!0}if(null!=vf(hf,Tm.backendName)){const n={pixels:e},a={numChannels:t};return Tm.runKernel(hf,n,a)}const[c,l]=s?[e.videoWidth,e.videoHeight]:[e.width,e.height];let u,h;if(i)u=e.getContext("2d").getImageData(0,0,c,l).data;else if(a||n)u=e.data;else if(r||s||o){if(null==ab)if("undefined"===typeof document){if("undefined"===typeof OffscreenCanvas||"undefined"===typeof OffscreenCanvasRenderingContext2D)throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");ab=new OffscreenCanvas(1,1).getContext("2d")}else ab=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});ab.canvas.width=c,ab.canvas.height=l,ab.drawImage(e,0,0,c,l),u=ab.getImageData(0,0,c,l).data}if(4===t)h=new Int32Array(u);else{const e=c*l;h=new Int32Array(e*t);for(let n=0;n<e;n++)for(let e=0;e<t;++e)h[n*t+e]=u[4*n+e]}return nb(h,[l,c,t],"int32")}function ib(e){if(2!==e.rank&&3!==e.rank)throw new Error("toPixels only supports rank 2 or 3 tensors, got rank ".concat(e.rank,"."));const t=2===e.rank?1:e.shape[2];if(t>4||2===t)throw new Error("toPixels only supports depth of size "+"1, 3 or 4 but got ".concat(t));if("float32"!==e.dtype&&"int32"!==e.dtype)throw new Error("Unsupported type for toPixels: ".concat(e.dtype,".")+" Please use float32 or int32 tensors.")}async function ob(e,t){let n=Fm(e,"img","toPixels");if(!(e instanceof im)){const e=n;n=ny(e,"int32"),e.dispose()}ib(n);const[a,s]=n.shape.slice(0,2),r=2===n.rank?1:n.shape[2],i=await n.data(),o="float32"===n.dtype?255:1,c=new Uint8ClampedArray(s*a*4);for(let l=0;l<a*s;++l){const e=[0,0,0,255];for(let a=0;a<r;a++){const t=i[l*r+a];if("float32"===n.dtype){if(t<0||t>1)throw new Error("Tensor values for a float32 Tensor must be in the "+"range [0 - 1] but encountered ".concat(t,"."))}else if("int32"===n.dtype&&(t<0||t>255))throw new Error("Tensor values for a int32 Tensor must be in the "+"range [0 - 255] but encountered ".concat(t,"."));1===r?(e[0]=t*o,e[1]=t*o,e[2]=t*o):e[a]=t*o}const t=4*l;c[t+0]=Math.round(e[0]),c[t+1]=Math.round(e[1]),c[t+2]=Math.round(e[2]),c[t+3]=Math.round(e[3])}if(null!=t){if(!sb){null!=vf($h,Tm.backendName)&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),sb=!0)}t.width=s,t.height=a;const e=t.getContext("2d"),n=new ImageData(c,s,a);e.putImageData(n,0,0)}return n!==e&&n.dispose(),c}const cb=Bm({fromPixels_:rb}),lb=-2,ub=-1;function hb(e,t,n){const a=e.shape.length;yu(a===t.length,()=>"Error in slice".concat(a,"D: Length of begin ").concat(t," must ")+"match the rank of the array (".concat(a,").")),yu(a===n.length,()=>"Error in slice".concat(a,"D: Length of size ").concat(n," must ")+"match the rank of the array (".concat(a,")."));for(let s=0;s<a;++s)yu(t[s]+n[s]<=e.shape[s],()=>"Error in slice".concat(a,"D: begin[").concat(s,"] + size[").concat(s,"] ")+"(".concat(t[s]+n[s],") would overflow input.shape[").concat(s,"] (").concat(e.shape[s],")"))}function db(e){const t=[];let n=0;for(;e>0;)1&e&&t.push(n),e/=2,n++;return t}function pb(e,t,n){const a=[];for(let s=0;s<e.length;s++)a[s]=Math.ceil((t[s]-e[s])/n[s]);return a}function fb(e,t,n,a){const s=[...e];for(let r=s.length;r<a.length;r++)s.push(1);for(let r=0;r<n;r++)0===r?s[t]=1:(s.splice(t,0,1),s.pop());return s}function mb(e,t,n){return n<=e?n:n-(t-1)}function gb(e,t){const n=[];for(let a=0;a<e;a++)n.push(t+a);return n}function yb(e,t,n,a,s,r,i,o,c){const l=e.length;let u=new Array(l),h=new Array(l),d=new Array(l);if(t.length&&n>0){const c=t[0],l=n+1;u=bb(i,c,l,a,e),h=xb(o,c,l,s,e),d=fb(r,c,l,e)}else for(let p=0;p<l;p++)u[p]=wb(i,a,r,e,p,c),h[p]=kb(o,s,r,e,p,c),d[p]=vb(r,p,c);return{begin:u,end:h,strides:d}}function bb(e,t,n,a,s){const r=[...s],i=gb(n,t);for(let o=0;o<r.length;o++)if(i.indexOf(o)>-1)r[o]=0;else{const s=mb(t,n,o);let i=a[s];e&1<<s&&(i=0),r[o]=i}return r}function xb(e,t,n,a,s){const r=[...s],i=gb(n,t);for(let o=0;o<r.length;o++)if(i.indexOf(o)>-1)r[o]=Number.MAX_SAFE_INTEGER;else{const s=mb(t,n,o);let i=a[s];e&1<<s&&(i=Number.MAX_SAFE_INTEGER),r[o]=i}for(let o=0;o<r.length;o++){const e=s[o];r[o]<0&&(r[o]+=e),r[o]=pu(0,r[o],s[o])}return r}function vb(e,t,n){let a=e[t];return(n&1<<t||null==a)&&(a=1),a}function wb(e,t,n,a,s,r){let i=t[s];const o=n[s]||1;(e&1<<s||r&1<<s||null==i)&&(i=o>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const c=a[s];return i<0&&(i+=c),i=pu(0,i,c-1),i}function kb(e,t,n,a,s,r){let i=t[s];const o=n[s]||1;(e&1<<s||r&1<<s||null==i)&&(i=o>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const c=a[s];return i<0&&(i+=c),i=o>0?pu(0,i,c):pu(-1,i,c-1),i}function Sb(e,t,n){let a=n.length;for(let s=0;s<n.length;s++)if(n[s]>1){a=s;break}for(let s=a+1;s<n.length;s++)if(t[s]>0||n[s]!==e[s])return!1;return!0}function Cb(e,t){let n=e.length>0?e[e.length-1]:1;for(let a=0;a<e.length-1;a++)n+=e[a]*t[a];return n}function Ib(e,t,n){let a;const s=e.shape.length;let r;return a="number"===typeof t?[t,...new Array(s-1).fill(0)]:t.length<s?t.concat(new Array(s-t.length).fill(0)):t.slice(),a.forEach(e=>{yu(-1!==e,()=>"slice() does not support negative begin indexing.")}),r=null==n?new Array(s).fill(-1):"number"===typeof n?[n,...new Array(s-1).fill(-1)]:n.length<s?n.concat(new Array(s-n.length).fill(-1)):n,r=r.map((t,n)=>t>=0?t:(yu(-1===t,()=>"Negative size values should be exactly -1 but got "+"".concat(t," for the slice() size at index ").concat(n,".")),e.shape[n]-a[n])),[a,r]}function Nb(e,t,n,a,s,r,i,o,c){let l;if(null==a?(l=new Array(t.length),l.fill(1)):l=a,null!=i&&0!==(i&i-1))throw new Error("Multiple ellipses in slice is not allowed.");let u=!1;const h={dims:l.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:l.slice(),beginMask:s,endMask:r,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:c};for(let b=0;b<h.dims;b++)u&&0!==(1<<b&o)&&h.numAddAxisAfterEllipsis++,1<<b&i&&(u=!0);u||(h.ellipsisMask|=1<<h.dims,h.dims++);const d={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=null!=e.begin,t.endValid=null!=e.end,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let a=0;a<e.dims;a++)if(1<<a&e.ellipsisMask){const s=Math.min(t.dims-(e.dims-a)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<s;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=a}else if(1<<a&e.newAxisMask)t.finalShapeGatherIndices.push(lb),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error("Index out of range using input dim ".concat(n,"; input ")+"has only ".concat(t.dims," dims, ").concat(t.begin.length,"."));null!=e.begin&&(t.begin[n]=e.begin[a]),null!=e.end&&(t.end[n]=e.end[a]),t.strides[n]=e.strides[a],e.beginMask&1<<a&&(t.beginMask|=1<<n),e.endMask&1<<a&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<a?(t.finalShapeGatherIndices.push(ub),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(a)),t.inputShapeGatherIndicesSparse[n]=a,n++}}(h,d);let p=!0,f=!0,m=!0;const g=[],y=[];for(let b=0;b<e.length;++b){if(0===d.strides[b])throw Error("strides[".concat(b,"] must be non-zero"));const t=!!(d.shrinkAxisMask&1<<b),n=e[b];if(-1===n){g.push(t?1:-1);continue}const a=[d.beginMask&1<<b,d.endMask&1<<b],s=[d.strides[b]>0?0:-1,d.strides[b]>0?n:n-1];if(t&&d.strides[b]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&1===d.strides[b];const r=!!(d.beginMask&1<<b&&d.endMask&1<<b);if(d.beginValid&&d.endValid){if(t){const e=d.begin[b]<0?n+d.begin[b]:d.begin[b];if(d.begin[b]=e,d.end[b]=d.begin[b]+1,e<0||e>=n)throw Error("slice index ".concat(d.begin[b]," of dimension ").concat(b," out of bounds."))}else d.begin[b]=Tb(d.begin[b],0,d.strides[b],n,a,s),d.end[b]=Tb(d.end[b],1,d.strides[b],n,a,s);const e=1===d.strides[b]&&0===d.begin[b]&&d.end[b]===n;p=p&&e,f=f&&(0===b&&1===d.strides[b]||e)}else p=p&&1===d.strides[b]&&r,f=f&&(0===b&&1===d.strides[b]||r);let i,o=!1;if(d.beginValid&&d.endValid?(i=d.end[b]-d.begin[b],o=!0):t?(i=1,o=!0):r&&n>=0&&(i=d.strides[b]<0?-n:n,o=!0),o){let e;e=0===i||i<0!==d.strides[b]<0?0:Math.trunc(i/d.strides[b])+(i%d.strides[b]!==0?1:0),g.push(e)}else g.push(-1)}for(let b=0;b<d.finalShapeGatherIndices.length;++b){const e=d.finalShapeGatherIndices[b];e>=0?y.push(g[e]):e===lb&&y.push(1)}return{finalShapeSparse:y.filter((e,t)=>d.finalShapeGatherIndices[t]!==lb),finalShape:y,isIdentity:p,sliceDim0:f,isSimpleSlice:m,begin:d.begin,end:d.end,strides:d.strides}}function Tb(e,t,n,a,s,r){if(s[t])return n>0?r[t]:r[t+1&1];{const t=e<0?a+e:e;return t<r[0]?r[0]:t>r[1]?r[1]:t}}const Eb=Bm({acos_:function(e){const t={x:Fm(e,"x","acos")};return Tm.runKernel(rh,t)}});const Rb=Bm({acosh_:function(e){const t={x:Fm(e,"x","acosh")};return Tm.runKernel(ih,t)}});const _b=Bm({addN_:function(e){yu(Array.isArray(e),()=>"The argument passed to tf.addN() must be a list of tensors"),yu(e.length>=1,()=>"Must pass at least one tensor to tf.addN(), but got "+"".concat(e.length));const t=e.map((e,t)=>Fm(e,"tensors".concat(t),"addN")),n=t[0];t.forEach(e=>{if(e.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),t.forEach(e=>{if(!ku(e.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const a=t;return Tm.runKernel(ch,a)}});const Ab=Bm({all_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const a={x:Fm(e,"x","all","bool")},s={axis:t,keepDims:n};return Tm.runKernel(lh,a,s)}});const Mb=Bm({any_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const a={x:Fm(e,"x","any","bool")},s={axis:t,keepDims:n};return Tm.runKernel(uh,a,s)}});const Pb=Bm({argMax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:Fm(e,"x","argMax")},a={axis:t};return Tm.runKernel(hh,n,a)}});const Db=Bm({argMin_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:Fm(e,"x","argMin")},a={axis:t};return Tm.runKernel(dh,n,a)}});const Ob=Bm({asin_:function(e){const t={x:Fm(e,"x","asin")};return Tm.runKernel(ph,t)}});const Fb=Bm({asinh_:function(e){const t={x:Fm(e,"x","asinh")};return Tm.runKernel(fh,t)}});const Lb=Bm({atan_:function(e){const t={x:Fm(e,"x","atan")};return Tm.runKernel(mh,t)}});const zb=Bm({atan2_:function(e,t){let n=Fm(e,"a","atan2"),a=Fm(t,"b","atan2");[n,a]=xm(n,a);const s={a:n,b:a};return Tm.runKernel(yh,s)}});const Bb=Bm({atanh_:function(e){const t={x:Fm(e,"x","atanh")};return Tm.runKernel(gh,t)}});function jb(e,t,n,a){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",r=arguments.length>5?arguments[5]:void 0;return Ub(e,[...t,e[3]],n,r,a,null,null,$b(s))}function Wb(e,t,n,a,s,r){let i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"channelsLast";const[o,c]=qb(t);let l;if("channelsLast"===i)l=[o,c,e[3],e[3]];else{if("channelsFirst"!==i)throw new Error("Unknown dataFormat ".concat(i));l=[o,c,e[1],e[1]]}return Ub(e,l,n,a,s,r,!1,i)}function Vb(e,t,n,a,s,r){let i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"NDHWC";const[o,c,l]=Kb(t);let u,h;if("NDHWC"===i)h="channelsLast",u=[o,c,l,e[4],e[4]];else{if("NCDHW"!==i)throw new Error("Unknown dataFormat ".concat(i));h="channelsFirst",u=[o,c,l,e[1],e[1]]}return Hb(e,u,n,a,s,!1,h,r)}function Ub(e,t,n,a,s,r){let i=arguments.length>6&&void 0!==arguments[6]&&arguments[6],o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:"channelsLast",[c,l,u,h]=[-1,-1,-1,-1];if("channelsLast"===o)[c,l,u,h]=e;else{if("channelsFirst"!==o)throw new Error("Unknown dataFormat ".concat(o));[c,h,l,u]=e}const[d,p,,f]=t,[m,g]=qb(n),[y,b]=qb(a),x=Xb(d,y),v=Xb(p,b),{padInfo:w,outHeight:k,outWidth:S}=function(e,t,n,a,s,r,i,o,c){let l,u,h;if("number"===typeof e){l={top:e,bottom:e,left:e,right:e,type:0===e?"VALID":"NUMBER"};const s=function(e,t,n,a,s){null==a&&(a=Gb(e,t,n));const r=e[0],i=e[1],o=Yb((r-t+2*a)/n+1,s),c=Yb((i-t+2*a)/n+1,s);return[o,c]}([t,n],r,a,e,o);u=s[0],h=s[1]}else if("same"===e){u=Math.ceil(t/a),h=Math.ceil(n/s);const e=Math.max(0,(u-1)*a+r-t),o=Math.max(0,(h-1)*s+i-n),c=Math.floor(e/2),d=e-c,p=Math.floor(o/2);l={top:c,bottom:d,left:p,right:o-p,type:"SAME"}}else if("valid"===e)l={top:0,bottom:0,left:0,right:0,type:"VALID"},u=Math.ceil((t-r+1)/a),h=Math.ceil((n-i+1)/s);else{if("object"!==typeof e)throw Error("Unknown padding parameter: ".concat(e));{const d="channelsLast"===c?e[1][0]:e[2][0],p="channelsLast"===c?e[1][1]:e[2][1],f="channelsLast"===c?e[2][0]:e[3][0],m="channelsLast"===c?e[2][1]:e[3][1];l={top:d,bottom:p,left:f,right:m,type:0===d&&0===p&&0===f&&0===m?"VALID":"EXPLICIT"},u=Yb((t-r+d+p)/a+1,o),h=Yb((n-i+f+m)/s+1,o)}}return{padInfo:l,outHeight:u,outWidth:h}}(s,l,u,m,g,x,v,r,o),C=i?f*h:f;let I;return"channelsFirst"===o?I=[c,C,k,S]:"channelsLast"===o&&(I=[c,k,S,C]),{batchSize:c,dataFormat:o,inHeight:l,inWidth:u,inChannels:h,outHeight:k,outWidth:S,outChannels:C,padInfo:w,strideHeight:m,strideWidth:g,filterHeight:d,filterWidth:p,effectiveFilterHeight:x,effectiveFilterWidth:v,dilationHeight:y,dilationWidth:b,inShape:e,outShape:I,filterShape:t}}function Hb(e,t,n,a,s){let r=arguments.length>5&&void 0!==arguments[5]&&arguments[5],i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"channelsLast",o=arguments.length>7?arguments[7]:void 0,[c,l,u,h,d]=[-1,-1,-1,-1,-1];if("channelsLast"===i)[c,l,u,h,d]=e;else{if("channelsFirst"!==i)throw new Error("Unknown dataFormat ".concat(i));[c,d,l,u,h]=e}const[p,f,m,,g]=t,[y,b,x]=Kb(n),[v,w,k]=Kb(a),S=Xb(p,v),C=Xb(f,w),I=Xb(m,k),{padInfo:N,outDepth:T,outHeight:E,outWidth:R}=function(e,t,n,a,s,r,i,o,c,l,u){let h,d,p,f;"valid"===e&&(e=0);if("number"===typeof e){h={top:e,bottom:e,left:e,right:e,front:e,back:e,type:0===e?"VALID":"NUMBER"};const m=function(e,t,n,a,s,r){null==s&&(s=Gb(e,t[0],a[0]));const i=[0,0,0,n];for(let o=0;o<3;o++)e[o]+2*s>=t[o]&&(i[o]=Yb((e[o]-t[o]+2*s)/a[o]+1,r));return i}([t,n,a,1],[o,c,l],1,[s,r,i],e,u);d=m[0],p=m[1],f=m[2]}else{if("same"!==e)throw Error("Unknown padding parameter: ".concat(e));{d=Math.ceil(t/s),p=Math.ceil(n/r),f=Math.ceil(a/i);const e=(d-1)*s+o-t,u=(p-1)*r+c-n,m=(f-1)*i+l-a,g=Math.floor(e/2),y=e-g,b=Math.floor(u/2),x=u-b,v=Math.floor(m/2);h={top:b,bottom:x,left:v,right:m-v,front:g,back:y,type:"SAME"}}}return{padInfo:h,outDepth:d,outHeight:p,outWidth:f}}(s,l,u,h,y,b,x,S,C,I,o),_=r?g*d:g;let A;return"channelsFirst"===i?A=[c,_,T,E,R]:"channelsLast"===i&&(A=[c,T,E,R,_]),{batchSize:c,dataFormat:i,inDepth:l,inHeight:u,inWidth:h,inChannels:d,outDepth:T,outHeight:E,outWidth:R,outChannels:_,padInfo:N,strideDepth:y,strideHeight:b,strideWidth:x,filterDepth:p,filterHeight:f,filterWidth:m,effectiveFilterDepth:S,effectiveFilterHeight:C,effectiveFilterWidth:I,dilationDepth:v,dilationHeight:w,dilationWidth:k,inShape:e,outShape:A,filterShape:t}}function Gb(e,t,n){const a=Xb(t,arguments.length>3&&void 0!==arguments[3]?arguments[3]:1);return Math.floor((e[0]*(n-1)-n+a)/2)}function qb(e){return"number"===typeof e?[e,e,e]:2===e.length?[e[0],e[1],1]:e}function Kb(e){return"number"===typeof e?[e,e,e]:e}function Xb(e,t){return t<=1?e:e+(e-1)*(t-1)}function Yb(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error("Unknown roundingMode ".concat(t))}}function Qb(e){const[t,n,a]=qb(e);return 1===t&&1===n&&1===a}function Zb(e,t){return Qb(e)||Qb(t)}function Jb(e){return qb(e).every(e=>e>0)}function $b(e){if("NHWC"===e)return"channelsLast";if("NCHW"===e)return"channelsFirst";throw new Error("Unknown dataFormat ".concat(e))}function ex(e,t,n){if(null!=n){if("string"===typeof t)throw Error("Error in ".concat(e,": pad must be an integer when using ")+"dimRoundingMode ".concat(n," but got pad ").concat(t,"."));if("number"===typeof t)yu(Su(t),()=>"Error in ".concat(e,": pad must be an integer when using ")+"dimRoundingMode ".concat(n," but got pad ").concat(t,"."));else{if("object"!==typeof t)throw Error("Error in ".concat(e,": Unknown padding parameter: ").concat(t));t.forEach(t=>{t.forEach(t=>{yu(Su(t),()=>"Error in ".concat(e,": pad must be an integer when using ")+"dimRoundingMode ".concat(n," but got pad ").concat(t,"."))})})}}}const tx=Bm({reshape_:function(e,t){const n={x:Fm(e,"x","reshape","string_or_numeric")},a={shape:t};return Tm.runKernel(mp,n,a)}});const nx=Bm({avgPool_:function(e,t,n,a,s){const r=Fm(e,"x","avgPool","float32");yu(Zb(n,1),()=>"Error in avgPool: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(1,"'"));let i=r,o=!1;3===r.rank&&(o=!0,i=tx(r,[1,r.shape[0],r.shape[1],r.shape[2]])),yu(4===i.rank,()=>"Error in avgPool: x must be rank 4 but got rank ".concat(i.rank,".")),ex("avgPool",a,s);const c={x:i},l={filterSize:t,strides:n,pad:a,dimRoundingMode:s};let u=Tm.runKernel(bh,c,l);return u=ny(u,r.dtype),o?tx(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});const ax=Bm({avgPool3d_:function(e,t,n,a,s){let r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NDHWC";const i=Fm(e,"x","avgPool3d","float32");let o=i,c=!1;4===i.rank&&(c=!0,o=tx(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),yu(5===o.rank,()=>"Error in avgPool3d: x must be rank 5 but got rank ".concat(o.rank,".")),yu("NDHWC"===r,()=>"Error in avgPool3d: Only NDHWC is currently supported, "+"but got dataFormat of ".concat(r)),yu("number"===typeof n&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,()=>"Error in avgPool3d: Stride must be > 0, but got '".concat(n,"'")),ex("avgPool3d",a,s);const l={x:o},u={filterSize:t,strides:n,pad:a,dimRoundingMode:s,dataFormat:r};let h=Tm.runKernel(vh,l,u);return h=ny(h,o.dtype),c?tx(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}});const sx=Bm({concat_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;yu(e.length>=1,()=>"Pass at least one tensor to concat");const n=Lm(e,"tensors","concat","string_or_numeric");if("complex64"===n[0].dtype&&n.forEach(e=>{if("complex64"!==e.dtype)throw new Error("Cannot concatenate complex64 tensors with a tensor\n          with dtype ".concat(e.dtype,". "))}),1===n.length)return ay(n[0]);const a=n,s={axis:t};return Tm.runKernel(Mh,a,s)}});const rx=Bm({matMul_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=Fm(e,"a","matMul"),r=Fm(t,"b","matMul");[s,r]=xm(s,r);const i={a:s,b:r},o={transposeA:n,transposeB:a};return Tm.runKernel(kh,i,o)}});const ix=Bm({sigmoid_:function(e){const t={x:Fm(e,"x","sigmoid","float32")};return Tm.runKernel(Pp,t)}});const ox=Bm({slice_:function(e,t,n){const a=Fm(e,"x","slice","string_or_numeric");if(0===a.rank)throw new Error("Slicing scalar is not possible");const s={x:a},r={begin:t,size:n};return Tm.runKernel(Rp,s,r)}});const cx=Bm({tanh_:function(e){const t={x:Fm(e,"x","tanh","float32")};return Tm.runKernel(ef,t)}});const lx=Bm({basicLSTMCell_:function(e,t,n,a,s,r){const i=Fm(e,"forgetBias","basicLSTMCell"),o=Fm(t,"lstmKernel","basicLSTMCell"),c=Fm(n,"lstmBias","basicLSTMCell"),l=Fm(a,"data","basicLSTMCell"),u=Fm(s,"c","basicLSTMCell"),h=Fm(r,"h","basicLSTMCell"),d=sx([l,h],1),p=rx(d,o),f=ry(p,c),m=f.shape[0],g=f.shape[1]/4,y=[m,g],b=ox(f,[0,0],y),x=ox(f,[0,g],y),v=ox(f,[0,2*g],y),w=ox(f,[0,3*g],y),k=ry(cy(ix(b),cx(x)),cy(u,ix(ry(i,v))));return[k,cy(cx(k),ix(w))]}});const ux=Bm({batchToSpaceND_:function(e,t,n){const a=Fm(e,"x","batchToSpaceND"),s=t.reduce((e,t)=>e*t);yu(a.rank>=1+t.length,()=>"input rank is ".concat(a.rank," but should be > than blockShape.length ").concat(t.length)),yu(n.length===t.length,()=>"crops.length is ".concat(n.length," but should be equal to blockShape.length  ").concat(t.length)),yu(a.shape[0]%s===0,()=>"input tensor batch is ".concat(a.shape[0]," but is not divisible by the product of ")+"the elements of blockShape ".concat(t.join(" * ")," === ").concat(s));const r={x:a},i={blockShape:t,crops:n};return Tm.runKernel(Sh,r,i)}});const hx=Bm({batchNorm_:function(e,t,n,a,s,r){null==r&&(r=.001);const i=Fm(e,"x","batchNorm"),o=Fm(t,"mean","batchNorm"),c=Fm(n,"variance","batchNorm");let l,u;null!=s&&(l=Fm(s,"scale","batchNorm")),null!=a&&(u=Fm(a,"offset","batchNorm")),yu(o.rank===c.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),yu(null==u||o.rank===u.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),yu(null==l||o.rank===l.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const h={x:function(e){let t;return t=0===e.rank||1===e.rank?tx(e,[1,1,1,e.size]):2===e.rank?tx(e,[1,1,e.shape[0],e.shape[1]]):3===e.rank?tx(e,[1,e.shape[0],e.shape[1],e.shape[2]]):e,t}(i),scale:l,offset:u,mean:o,variance:c},d={varianceEpsilon:r},p=Tm.runKernel(fd,h,d);return tx(p,i.shape)}});const dx=Bm({batchNorm2d_:function(e,t,n,a,s,r){const i=Fm(e,"x","batchNorm"),o=Fm(t,"mean","batchNorm"),c=Fm(n,"variance","batchNorm");let l,u;return null!=s&&(l=Fm(s,"scale","batchNorm")),null!=a&&(u=Fm(a,"offset","batchNorm")),yu(2===i.rank,()=>"Error in batchNorm2D: x must be rank 2 but got rank "+"".concat(i.rank,".")),yu(2===o.rank||1===o.rank,()=>"Error in batchNorm2D: mean must be rank 2 or rank 1 but "+"got rank ".concat(o.rank,".")),yu(2===c.rank||1===c.rank,()=>"Error in batchNorm2D: variance must be rank 2 or rank 1 "+"but got rank ".concat(c.rank,".")),null!=l&&yu(2===l.rank||1===l.rank,()=>"Error in batchNorm2D: scale must be rank 2 or rank 1 "+"but got rank ".concat(l.rank,".")),null!=u&&yu(2===u.rank||1===u.rank,()=>"Error in batchNorm2D: offset must be rank 2 or rank 1 "+"but got rank ".concat(u.rank,".")),hx(i,o,c,u,l,r)}});const px=Bm({batchNorm3d_:function(e,t,n,a,s,r){const i=Fm(e,"x","batchNorm"),o=Fm(t,"mean","batchNorm"),c=Fm(n,"variance","batchNorm");let l,u;return null!=s&&(l=Fm(s,"scale","batchNorm")),null!=a&&(u=Fm(a,"offset","batchNorm")),yu(3===i.rank,()=>"Error in batchNorm3D: x must be rank 3 but got rank "+"".concat(i.rank,".")),yu(3===o.rank||1===o.rank,()=>"Error in batchNorm3D: mean must be rank 3 or rank 1 but "+"got rank ".concat(o.rank,".")),yu(3===c.rank||1===c.rank,()=>"Error in batchNorm3D: variance must be rank 3 or rank 1 "+"but got rank ".concat(c.rank,".")),null!=l&&yu(3===l.rank||1===l.rank,()=>"Error in batchNorm3D: scale must be rank 3 or rank 1 "+"but got rank ".concat(l.rank,".")),null!=u&&yu(3===u.rank||1===u.rank,()=>"Error in batchNorm3D: offset must be rank 3 or rank 1 "+"but got rank ".concat(u.rank,".")),hx(i,o,c,u,l,r)}});const fx=Bm({batchNorm4d_:function(e,t,n,a,s,r){const i=Fm(e,"x","batchNorm"),o=Fm(t,"mean","batchNorm"),c=Fm(n,"variance","batchNorm");let l,u;return null!=s&&(l=Fm(s,"scale","batchNorm")),null!=a&&(u=Fm(a,"offset","batchNorm")),yu(4===i.rank,()=>"Error in batchNorm4D: x must be rank 4 but got rank "+"".concat(i.rank,".")),yu(4===o.rank||1===o.rank,()=>"Error in batchNorm4D: mean must be rank 4 or rank 1 but "+"got rank ".concat(o.rank,".")),yu(4===c.rank||1===c.rank,()=>"Error in batchNorm4D: variance must be rank 4 or rank 1 "+"but got rank ".concat(c.rank,".")),null!=l&&yu(4===l.rank||1===l.rank,()=>"Error in batchNorm4D: scale must be rank 4 or rank 1 "+"but got rank ".concat(l.rank,".")),null!=u&&yu(4===u.rank||1===u.rank,()=>"Error in batchNorm4D: offset must be rank 4 or rank 1 "+"but got rank ".concat(u.rank,".")),hx(i,o,c,u,l,r)}});const mx=Bm({bincount_:function(e,t,n){const a=Fm(e,"x","bincount"),s=Fm(t,"weights","bincount");yu("int32"===a.dtype,()=>"Error in bincount: input "+"dtype must be int32, but got ".concat(a.dtype)),yu(n>=0,()=>"size must be non-negative, but got ".concat(n,".")),yu(s.size===a.size||0===s.size,()=>"Error in bincount: weights must have the same size as input or"+"0-length, but got input shape: ".concat(a.shape,", weights shape: ")+"".concat(s.shape,"."));const r={x:a,weights:s},i={size:n};return Tm.runKernel(Ch,r,i)}});const gx=Bm({bitwiseAnd_:function(e,t){const n=Fm(e,"x","bitwiseAnd"),a=Fm(t,"y","bitwiseAnd");if(!ku(n.shape,a.shape))throw new Error("BitwiseAnd: Tensors must have the same shape. x: ".concat(n.shape,", y: ").concat(a.shape));if("int32"!==n.dtype||"int32"!==a.dtype)throw new Error("BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ".concat(n.dtype," and type of y: ").concat(a.dtype));const s={a:n,b:a};return Tm.runKernel(Ih,s)}});const yx=Bm({broadcastArgs_:function(e,t){const n=Fm(e,"s0","broadcastArgs","int32"),a=Fm(t,"s1","broadcastArgs","int32");if(1!==n.rank)throw new Error("broadcastArgs(): first input must be a vector (rank=1). "+"Has rank ".concat(n.rank));if(1!==a.rank)throw new Error("broadcastArgs(): second input must be a vector (rank=1). "+"Has rank ".concat(a.rank));const s={s0:n,s1:a};return Tm.runKernel(Nh,s)}});const bx=Bm({broadcastTo_:function(e,t){let n=Fm(e,"broadcastTo","x");const a=n.shape;if(qu(t),t.length<n.rank)throw new Error("broadcastTo(): shape.length=".concat(t.length," < input.rank=").concat(n.rank,"."));if(t.length>n.rank){const e=n.shape.slice();for(;e.length<t.length;)e.unshift(1);n=tx(n,e)}const s=n.shape,r=Array.from(t);for(let c=t.length-1;c>=0;c--)if(s[c]===t[c])r[c]=1;else if(1!==n.shape[c])throw new Error("broadcastTo(): [".concat(a,"] cannot be broadcast to [").concat(t,"]."));if(0===r.map((e,t)=>e>1?t:-1).filter(e=>e>=0).length)return ay(n);const i={x:n},o={reps:r};return Tm.runKernel(tf,i,o)}});const xx=Bm({ceil_:function(e){const t={x:Fm(e,"x","ceil","float32")};return Tm.runKernel(Eh,t)}});const vx=Bm({clipByValue_:function(e,t,n){const a=Fm(e,"x","clipByValue");if(yu(t<=n,()=>"Error in clip: min (".concat(t,") must be ")+"less than or equal to max (".concat(n,").")),t===n)return wy(a.shape,t,a.dtype);const s={x:a},r={clipValueMin:t,clipValueMax:n};return Tm.runKernel(Rh,s,r)}});const wx=Bm({concat1d_:function(e){return sx(e,0)}});const kx=Bm({concat2d_:function(e,t){return sx(e,t)}});const Sx=Bm({concat3d_:function(e,t){return sx(e,t)}});const Cx=Bm({concat4d_:function(e,t){return sx(e,t)}});const Ix=Bm({conv2d_:function(e,t,n,a){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6?arguments[6]:void 0;const o=Fm(e,"x","conv2d","float32"),c=Fm(t,"filter","conv2d","float32");let l=o,u=!1;3===o.rank&&(u=!0,l=tx(o,[1,o.shape[0],o.shape[1],o.shape[2]])),yu(4===l.rank,()=>"Error in conv2d: input must be rank 4, but got rank ".concat(l.rank,".")),yu(4===c.rank,()=>"Error in conv2d: filter must be rank 4, but got rank "+"".concat(c.rank,".")),ex("conv2d",a,i);const h="NHWC"===s?l.shape[3]:l.shape[1];yu(h===c.shape[2],()=>"Error in conv2d: depth of input (".concat(h,") must match ")+"input depth for filter ".concat(c.shape[2],".")),yu(Zb(n,r),()=>"Error in conv2D: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(r,"'")),yu(Jb(r),()=>"Error in conv2D: Dilated rates should be larger than 0."),yu(Jb(n),()=>"Error in conv2D: Strides should be larger than 0.");const d={x:l,filter:c},p={strides:n,pad:a,dataFormat:s,dilations:r,dimRoundingMode:i},f=Tm.runKernel(Ph,d,p);return u?tx(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const Nx=Bm({conv1d_:function(e,t,n,a){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NWC",r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,i=arguments.length>6?arguments[6]:void 0;const o=Fm(e,"x","conv1d"),c=Fm(t,"filter","conv1d");let l=o,u=!1;2===o.rank&&(u=!0,l=tx(o,[1,o.shape[0],o.shape[1]])),yu(3===l.rank,()=>"Error in conv1d: input must be rank 3, but got rank ".concat(l.rank,".")),yu(3===c.rank,()=>"Error in conv1d: filter must be rank 3, but got rank "+"".concat(c.rank,".")),ex("conv1d",a,i),yu(l.shape[2]===c.shape[1],()=>"Error in conv1d: depth of input (".concat(l.shape[2],") must match ")+"input depth for filter ".concat(c.shape[1],".")),yu(Zb(n,r),()=>"Error in conv1D: Either stride or dilation must be 1. "+"Got stride ".concat(n," and dilation '").concat(r,"'")),yu(Jb(r),()=>"Error in conv1D: Dilated rates should be larger than 0."),yu(Jb(n),()=>"Error in conv1D: Stride should be larger than 0."),yu("NWC"===s,()=>"Error in conv1d: got dataFormat of ".concat(s," but only NWC is currently supported."));const h=tx(c,[1,c.shape[0],c.shape[1],c.shape[2]]),d=tx(l,[l.shape[0],1,l.shape[1],l.shape[2]]),p=Ix(d,h,[1,n],a,"NHWC",[1,r],i);return tx(p,u?[p.shape[2],p.shape[3]]:[p.shape[0],p.shape[2],p.shape[3]])}});const Tx=Bm({conv2DBackpropInput_:function(e,t,n,a,s){let r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",i=arguments.length>6?arguments[6]:void 0;yu(e.length===t.rank,()=>"Length of inShape "+"(".concat(e.length,") and rank of dy (").concat(t.rank,") must match"));let o=e,c=t,l=!1;3===t.rank&&(l=!0,c=tx(t,[1,t.shape[0],t.shape[1],t.shape[2]]),o=[1,e[0],e[1],e[2]]),yu(4===o.length,()=>"Error in conv2dDerInput: inShape must be length 4, but got length "+"".concat(o.length,".")),yu(4===c.rank,()=>"Error in conv2dDerInput: dy must be rank 4, but got "+"rank ".concat(c.rank)),yu(4===n.rank,()=>"Error in conv2dDerInput: filter must be rank 4, but got "+"rank ".concat(n.rank));const u="NHWC"===r?o[3]:o[1],h="NHWC"===r?c.shape[3]:c.shape[1];yu(u===n.shape[2],()=>"Error in conv2dDerInput: depth of input (".concat(u,") must ")+"match input depth for filter ".concat(n.shape[2],".")),yu(h===n.shape[3],()=>"Error in conv2dDerInput: depth of output (".concat(h,") must ")+"match output depth for filter ".concat(n.shape[3],".")),ex("conv2dDerInput",s,i);const d={dy:c,filter:n},p={strides:a,pad:s,dataFormat:r,dimRoundingMode:i,inputShape:o},f=Tm.runKernel(Oh,d,p);return l?tx(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const Ex=Bm({conv2dTranspose_:function(e,t,n,a,s,r){const i=Fm(e,"x","conv2dTranspose"),o=Fm(t,"filter","conv2dTranspose");return Tx(n,i,o,a,s,"NHWC",r)}});const Rx=Bm({conv3d_:function(e,t,n,a){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NDHWC",r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1,1];const i=Fm(e,"x","conv3d"),o=Fm(t,"filter","conv3d");let c=i,l=!1;4===i.rank&&(l=!0,c=tx(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),yu(5===c.rank,()=>"Error in conv3d: input must be rank 5, but got rank ".concat(c.rank,".")),yu(5===o.rank,()=>"Error in conv3d: filter must be rank 5, but got rank "+"".concat(o.rank,".")),yu(c.shape[4]===o.shape[3],()=>"Error in conv3d: depth of input (".concat(c.shape[4],") must match ")+"input depth for filter ".concat(o.shape[3],".")),yu(Zb(n,r),()=>"Error in conv3D: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(r,"'")),yu("NDHWC"===s,()=>"Error in conv3d: got dataFormat of ".concat(s," but only NDHWC is currently supported.")),yu(Jb(r),()=>"Error in conv3D: Dilated rates should be larger than 0."),yu(Jb(n),()=>"Error in conv3D: Strides should be larger than 0.");const u={x:c,filter:o},h={strides:n,pad:a,dataFormat:s,dilations:r},d=Tm.runKernel(Fh,u,h);return l?tx(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});const _x=Bm({conv3DBackpropInput_:function(e,t,n,a,s){yu(e.length===t.rank,()=>"Length of inShape "+"(".concat(e.length,") and rank of dy (").concat(t.rank,") must match"));let r=e,i=t,o=!1;4===t.rank&&(o=!0,i=tx(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),r=[1,e[0],e[1],e[2],e[3]]);const c=r[4],l=i.shape[4];yu(5===r.length,()=>"Error in conv3dDerInput: inShape must be length 5, but got length "+"".concat(r.length,".")),yu(5===i.rank,()=>"Error in conv3dDerInput: dy must be rank 5, but got "+"rank ".concat(i.rank)),yu(5===n.rank,()=>"Error in conv3dDerInput: filter must be rank 5, but got "+"rank ".concat(n.rank)),yu(c===n.shape[3],()=>"Error in conv3dDerInput: depth of input (".concat(c,") must ")+"match input depth for filter ".concat(n.shape[3],".")),yu(l===n.shape[4],()=>"Error in conv3dDerInput: depth of output (".concat(l,") must ")+"match output depth for filter ".concat(n.shape[4],"."));const u={dy:i,filter:n},h={pad:s,strides:a,inputShape:r},d=Tm.runKernel(zh,u,h);return o?tx(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});const Ax=Bm({conv3dTranspose_:function(e,t,n,a,s){const r=Fm(e,"x","conv3dTranspose"),i=Fm(t,"filter","conv3dTranspose");return _x(n,r,i,a,s)}});const Mx=Bm({cos_:function(e){const t={x:Fm(e,"x","cos","float32")};return Tm.runKernel(Bh,t)}});const Px=Bm({cosh_:function(e){const t={x:Fm(e,"x","cosh","float32")};return Tm.runKernel(jh,t)}});const Dx=Bm({cumprod_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s={x:Fm(e,"x","cumprod")},r={axis:t,exclusive:n,reverse:a};return Tm.runKernel(Wh,s,r)}});const Ox=Bm({cumsum_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s={x:Fm(e,"x","cumsum")},r={axis:t,exclusive:n,reverse:a};return Tm.runKernel(Vh,s,r)}});const Fx=Bm({denseBincount_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s=Fm(e,"x","denseBincount"),r=Fm(t,"weights","denseBincount");yu("int32"===s.dtype,()=>"Error in denseBincount: input "+"dtype must be int32, but got ".concat(s.dtype)),yu(s.rank<=2,()=>"Error in denseBincount: input must be at most rank 2, but got "+"rank ".concat(s.rank,".")),yu(n>=0,()=>"size must be non-negative, but got ".concat(n,".")),yu(r.size===s.size||0===r.size,()=>"Error in denseBincount: weights must have the same shape as x or "+"0-length, but got x shape: ".concat(s.shape,", weights shape: ")+"".concat(r.shape,"."));const i={x:s,weights:r},o={size:n,binaryOutput:a};return Tm.runKernel(Hh,i,o)}});const Lx=Bm({depthToSpace_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"NHWC";const a=Fm(e,"x","depthToSpace","float32"),s="NHWC"===n?a.shape[1]:a.shape[2],r="NHWC"===n?a.shape[2]:a.shape[3],i="NHWC"===n?a.shape[3]:a.shape[1];yu(t>1,()=>"blockSize should be > 1 for depthToSpace, but was: ".concat(t)),yu(s*t>=0,()=>"Negative dimension size caused by overflow when multiplying\n    ".concat(s," and ").concat(t,"  for depthToSpace with input shape\n    ").concat(a.shape)),yu(r*t>=0,()=>"Negative dimension size caused by overflow when multiplying\n    ".concat(r," and ").concat(t," for depthToSpace with input shape\n        ").concat(a.shape)),yu(i%(t*t)===0,()=>"Dimension size must be evenly divisible by ".concat(t*t," but is ").concat(i," for depthToSpace with input shape ").concat(a.shape));const o={x:a},c={blockSize:t,dataFormat:n};return Tm.runKernel(Gh,o,c)}});const zx=Bm({depthwiseConv2d_:function(e,t,n,a){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6?arguments[6]:void 0;const o=Fm(e,"x","depthwiseConv2d","float32"),c=Fm(t,"filter","depthwiseConv2d","float32");let l=o,u=!1;3===o.rank&&(u=!0,l=tx(o,[1,o.shape[0],o.shape[1],o.shape[2]])),yu(4===l.rank,()=>"Error in depthwiseConv2d: input must be rank 4, but got "+"rank ".concat(l.rank,".")),yu(4===c.rank,()=>"Error in depthwiseConv2d: filter must be rank 4, but got rank "+"".concat(c.rank,"."));const h="NHWC"===s?l.shape[3]:l.shape[1];yu(h===c.shape[2],()=>"Error in depthwiseConv2d: number of input channels "+"(".concat(h,") must match the inChannels dimension in ")+"filter ".concat(c.shape[2],".")),ex("depthwiseConv2d",a,i);const d={x:l,filter:c},p={strides:n,pad:a,dataFormat:s,dilations:r,dimRoundingMode:i},f=Tm.runKernel(qh,d,p);return u?tx(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const Bx=Bm({diag_:function(e){const t={x:Fm(e,"x","diag")};return Tm.runKernel(Yh,t)}});const jx=Bm({dilation2d_:function(e,t,n,a){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:[1,1],r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC";const i=Fm(e,"x","dilation2d"),o=Fm(t,"filter","dilation2d");yu(3===i.rank||4===i.rank,()=>"Error in dilation2d: input must be rank 3 or 4, but got rank "+"".concat(i.rank,".")),yu(3===o.rank,()=>"Error in dilation2d: filter must be rank 3, but got rank "+"".concat(o.rank,".")),yu("NHWC"===r,()=>"Error in dilation2d: Only NHWC is currently supported, "+"but got dataFormat of ".concat(r));let c=i,l=!1;3===i.rank&&(c=tx(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=!0),yu(c.shape[3]===o.shape[2],()=>"Error in dilation2d:  input and filter must have the same depth: ".concat(c.shape[3]," vs ").concat(o.shape[2]));const u={x:c,filter:o},h={strides:n,pad:a,dilations:s},d=Tm.runKernel(Qh,u,h);return l?tx(d,[d.shape[1],d.shape[2],d.shape[3]]):d}});const Wx=Bm({equal_:function(e,t){let n=Fm(e,"a","equal","string_or_numeric"),a=Fm(t,"b","equal","string_or_numeric");[n,a]=xm(n,a),Ry(n.shape,a.shape);const s={a:n,b:a};return Tm.runKernel(rd,s)}});const Vx=Bm({where_:function(e,t,n){const a=Fm(t,"a","where"),s=Fm(n,"b","where"),r=Fm(e,"condition","where","bool"),i=Ry(Ry(r.shape,a.shape),s.shape),o={condition:bx(r,i),t:bx(a,i),e:bx(s,i)};return Tm.runKernel(Tp,o)}});const Ux=Bm({divNoNan_:function(e,t){let n=Fm(e,"a","div"),a=Fm(t,"b","div");[n,a]=xm(n,a);const s=oy(n,a),r=hy(s),i=Wx(a,r);return Vx(i,r,s)}});const Hx=Bm({dot_:function(e,t){const n=Fm(e,"t1","dot"),a=Fm(t,"t2","dot");yu((1===n.rank||2===n.rank)&&(1===a.rank||2===a.rank),()=>"Error in dot: inputs must all be rank 1 or 2, but got ranks "+"".concat(n.rank," and ").concat(a.rank,"."));const s=1===n.rank?n.size:n.shape[1],r=1===a.rank?a.size:a.shape[0];if(yu(s===r,()=>"Error in dot: inner dimensions of inputs must match, but got "+"".concat(s," and ").concat(r,".")),1===n.rank&&1===a.rank){const e=tx(n,[1,-1]),t=tx(a,[-1,1]),s=rx(e,t);return tx(s,[])}if(1===n.rank&&2===a.rank){const e=tx(n,[1,-1]),t=tx(a,[a.shape[0],a.shape[1]]),s=rx(e,t);return tx(s,[s.size])}if(2===n.rank&&1===a.rank){const e=tx(a,[-1,1]),t=rx(n,e);return tx(t,[t.size])}{const e=tx(a,[a.shape[0],a.shape[1]]);return rx(n,e)}}});const Gx=Bm({einsum_:function(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),a=1;a<t;a++)n[a-1]=arguments[a];const s=n.map((e,t)=>Fm(e,"tensors".concat(t),"einsum")),r={equation:e};return Tm.runKernel(td,s,r)}});const qx=Bm({elu_:function(e){const t={x:Fm(e,"x","elu","float32")};return Tm.runKernel(nd,t)}});const Kx=Bm({ensureShape_:function(e,t){const n=Fm(e,"x","ensureShape","string_or_numeric");if(!function(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(null!==e[n]&&null!==t[n]&&e[n]!==t[n])return!1;return!0}(n.shape,t))throw new Error("EnsureShape: Shape of tensor ".concat(n.shape," is not compatible with expected shape ").concat(t));return e}});const Xx=Bm({erf_:function(e){let t=Fm(e,"x","erf");yu("int32"===t.dtype||"float32"===t.dtype,()=>"Input dtype must be `int32` or `float32`."),"int32"===t.dtype&&(t=ny(t,"float32"));const n={x:t};return Tm.runKernel(sd,n)}});function Yx(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function Qx(e,t,n){const a=e.length+t.length,s=[];let r=0,i=0;for(let o=0;o<a;o++)-1===n.indexOf(o)?s.push(e[r++]):s.push(t[i++]);return s}function Zx(e,t){const n=[],a=e.length;for(let s=0;s<a;s++)-1===t.indexOf(s)&&n.push(e[s]);return[n,t.map(t=>e[t])]}function Jx(e,t){return Qx(e,t.map(e=>1),t)}function $x(e,t,n){yu(Yx(t,n),()=>"".concat(e," supports only inner-most axes for now. ")+"Got axes ".concat(t," and rank-").concat(n," input."))}function ev(e,t){if(Yx(e,t))return null;const n=[];for(let a=0;a<t;++a)-1===e.indexOf(a)&&n.push(a);return e.forEach(e=>n.push(e)),n}function tv(e){return e.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function nv(e,t){const n=[];for(let a=t-e;a<t;++a)n.push(a);return n}const av=Bm({max_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const a={x:Fm(e,"x","max")},s={reductionIndices:t,keepDims:n};return Tm.runKernel(Fd,a,s)}});const sv=Bm({min_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const a={x:Fm(e,"x","min")},s={axis:t,keepDims:n};return Tm.runKernel(Hd,a,s)}});const rv=Bm({sum_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=Fm(e,"x","sum");"bool"===a.dtype&&(a=ny(a,"int32"));const s={x:a},r={axis:t,keepDims:n};return Tm.runKernel(Fp,s,r)}});function iv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;if(0===e.rank)return Ny(e);if(1!==e.rank&&null===n)return iv(tx(e,[-1]),t,n);if(1===e.rank||"number"===typeof n||Array.isArray(n)&&1===n.length){if(1===t)return rv(Ny(e),n);if(t===1/0)return av(Ny(e),n);if(t===-1/0)return sv(Ny(e),n);if("euclidean"===t||2===t)return ly(rv(Sy(Ny(e),py(2,"int32")),n));throw new Error("Error in norm: invalid ord value: ".concat(t))}if(Array.isArray(n)&&2===n.length){if(1===t)return av(rv(Ny(e),n[0]),n[1]-1);if(t===1/0)return av(rv(Ny(e),n[1]),n[0]);if(t===-1/0)return sv(rv(Ny(e),n[1]),n[0]);if("fro"===t||"euclidean"===t)return ly(rv(uy(e),n));throw new Error("Error in norm: invalid ord value: ".concat(t))}throw new Error("Error in norm: invalid axis: ".concat(n))}const ov=Bm({norm_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"euclidean",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s=iv(e=Fm(e,"x","norm"),t,n);let r=s.shape;if(a){const t=Eu(n,e.shape);r=Jx(s.shape,t)}return tx(s,r)}});const cv=Bm({euclideanNorm_:function(e){return ov(e,"euclidean",arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,arguments.length>2&&void 0!==arguments[2]&&arguments[2])}});const lv=Bm({exp_:function(e){const t={x:Fm(e,"x","exp")};return Tm.runKernel(id,t)}});const uv=Bm({expandDims_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=Fm(e,"x","expandDims","string_or_numeric");yu(t<=n.rank,()=>"Axis must be <= rank of the tensor");const a={input:n},s={dim:t};return Tm.runKernel(od,a,s)}});const hv=Bm({expm1_:function(e){const t={x:Fm(e,"x","expm1")};return Tm.runKernel(cd,t)}});const dv=Bm({tile_:function(e,t){const n=Fm(e,"x","tile","string_or_numeric");yu(n.rank===t.length,()=>"Error in transpose: rank of input ".concat(n.rank," ")+"must match length of reps ".concat(t,"."));const a={x:n},s={reps:t};return Tm.runKernel(tf,a,s)}});const pv=Bm({eye_:function(e,t,n){null==t&&(t=e);const a=ty([e,t],arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32"),s=e<=t?e:t;for(let i=0;i<s;++i)a.set(1,i,i);const r=tx(a.toTensor(),[e,t]);if(null==n)return r;if(1===n.length)return dv(uv(r,0),[n[0],1,1]);if(2===n.length)return dv(uv(uv(r,0),0),[n[0],n[1],1,1]);if(3===n.length)return dv(uv(uv(uv(r,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error("eye() currently supports only 1D and 2D "+"batchShapes, but received ".concat(n.length,"D."))}});const fv=Bm({floor_:function(e){const t={x:Fm(e,"x","floor","float32")};return Tm.runKernel(dd,t)}});const mv=Bm({gather_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const s={x:Fm(e,"x","gather"),indices:Fm(t,"indices","gather","int32")},r={axis:n,batchDims:a};return Tm.runKernel(md,s,r)}});const gv=Bm({greater_:function(e,t){let n=Fm(e,"a","greater","string_or_numeric"),a=Fm(t,"b","greater","string_or_numeric");[n,a]=xm(n,a),Ry(n.shape,a.shape);const s={a:n,b:a};return Tm.runKernel(yd,s)}});const yv=Bm({greaterEqual_:function(e,t){let n=Fm(e,"a","greaterEqual","string_or_numeric"),a=Fm(t,"b","greaterEqual","string_or_numeric");[n,a]=xm(n,a),Ry(n.shape,a.shape);const s={a:n,b:a};return Tm.runKernel(bd,s)}});const bv=Bm({imag_:function(e){const t={input:Fm(e,"input","imag")};return Tm.runKernel(wd,t)}});const xv=Bm({isFinite_:function(e){const t={x:Fm(e,"x","isFinite")};return Tm.runKernel(kd,t)}});const vv=Bm({isInf_:function(e){const t={x:Fm(e,"x","isInf")};return Tm.runKernel(Sd,t)}});const wv=Bm({isNaN_:function(e){const t={x:Fm(e,"x","isNaN")};return Tm.runKernel(Cd,t)}});const kv=Bm({leakyRelu_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.2;const n={x:Fm(e,"x","leakyRelu")},a={alpha:t};return Tm.runKernel(Id,n,a)}});const Sv=Bm({less_:function(e,t){let n=Fm(e,"a","less","string_or_numeric"),a=Fm(t,"b","less","string_or_numeric");[n,a]=xm(n,a),Ry(n.shape,a.shape);const s={a:n,b:a};return Tm.runKernel(Nd,s)}});const Cv=Bm({lessEqual_:function(e,t){let n=Fm(e,"a","lessEqual","string_or_numeric"),a=Fm(t,"b","lessEqual","string_or_numeric");[n,a]=xm(n,a),Ry(n.shape,a.shape);const s={a:n,b:a};return Tm.runKernel(Td,s)}});function Iv(e,t,n){if(n<=0)throw new Error("The number of values should be positive.");const a={start:e,stop:t,num:n};return Tm.runKernel(Ed,{},a)}const Nv=Bm({localResponseNormalization_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:5,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5;const r=Fm(e,"x","localResponseNormalization");yu(4===r.rank||3===r.rank,()=>"Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ".concat(r.rank,".")),yu(Su(t),()=>"Error in localResponseNormalization: depthRadius must be an "+"integer but got depthRadius ".concat(t,"."));let i=r,o=!1;3===r.rank&&(o=!0,i=tx(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const c={x:i},l={depthRadius:t,bias:n,alpha:a,beta:s},u=Tm.runKernel(Dd,c,l);return o?tx(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});const Tv=Bm({log_:function(e){const t={x:Fm(e,"x","log","float32")};return Tm.runKernel(Rd,t)}});const Ev=Bm({log1p_:function(e){const t={x:Fm(e,"x","log1p")};return Tm.runKernel(_d,t)}});const Rv=Bm({neg_:function(e){const t={x:Fm(e,"x","neg")};return Tm.runKernel(Qd,t)}});const _v=Bm({softplus_:function(e){const t={x:Fm(e,"x","softplus")};return Tm.runKernel(Dp,t)}});const Av=Bm({logSigmoid_:function(e){const t=Fm(e,"x","logSigmoid");return dy(e=>({value:Rv(_v(Rv(e))),gradFunc:t=>cy(t,ix(Rv(e)))}))(t)}});const Mv=Bm({logSoftmax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=Fm(e,"logits","logSoftmax");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error("Log Softmax along a non-last dimension is not yet supported. "+"Logits was rank ".concat(n.rank," and axis was ").concat(t));const a=dy((e,n)=>{const a=av(e,t,!0),s=Cy(e,a),r=Cy(ny(s,"float32"),Tv(rv(lv(s),t,!0)));n([r]);return{value:r,gradFunc:(e,n)=>{const[a]=n,s=lv(a);return Cy(e,cy(rv(e,t,!0),s))}}});return a(n)}});const Pv=Bm({logSumExp_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const a=Fm(e,"x","logSumExp"),s=Eu(t,a.shape),r=av(a,s,!0),i=Cy(a,r),o=lv(i),c=rv(o,s),l=Tv(c),u=ry(tx(r,l.shape),l);if(n){const e=Jx(u.shape,s);return tx(u,e)}return u}});const Dv=Bm({logicalAnd_:function(e,t){const n=Fm(e,"a","logicalAnd","bool"),a=Fm(t,"b","logicalAnd","bool");Ry(n.shape,a.shape);const s={a:n,b:a};return Tm.runKernel(Ad,s)}});const Ov=Bm({logicalNot_:function(e){const t={x:Fm(e,"x","logicalNot","bool")};return Tm.runKernel(Md,t)}});const Fv=Bm({logicalOr_:function(e,t){const n=Fm(e,"a","logicalOr","bool"),a=Fm(t,"b","logicalOr","bool");Ry(n.shape,a.shape);const s={a:n,b:a};return Tm.runKernel(Pd,s)}});const Lv=Bm({logicalXor_:function(e,t){const n=Fm(e,"a","logicalXor","bool"),a=Fm(t,"b","logicalXor","bool");return Ry(n.shape,a.shape),Dv(Fv(e,t),Ov(Dv(e,t)))}}),zv=2147483648;const Bv=Bm({searchSorted_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"left";const a=Fm(e,"sortedSequence","searchSorted"),s=Fm(t,"values","searchSorted"),r=a.shape[a.shape.length-1],i=s.shape[s.shape.length-1],o=tx(a,[-1,r]),c=tx(s,[-1,i]);if(o.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(o.shape[0]!==c.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(vu(c.shape)>=zv)throw new Error("values tensor size must less than ".concat(zv));if(o.shape[1]>=zv)throw new Error("trailing dim_size must less than ".concat(zv," for int32 output type, was ").concat(o.shape[1]));const l={sortedSequence:o,values:c},u={side:n};return Tm.runKernel(Np,l,u)}});function jv(e,t){return Bv(e,t,"left")}const Wv=Bm({maxPool_:function(e,t,n,a,s){const r=Fm(e,"x","maxPool");let i=r,o=!1;3===r.rank&&(o=!0,i=tx(r,[1,r.shape[0],r.shape[1],r.shape[2]])),yu(4===i.rank,()=>"Error in maxPool: input must be rank 4 but got rank ".concat(i.rank,".")),yu(Zb(n,1),()=>"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(1,"'")),ex("maxPool",a,s);const c={x:i},l={filterSize:t,strides:n,pad:a,dimRoundingMode:s},u=Tm.runKernel(zd,c,l);return o?tx(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});const Vv=Bm({maxPool3d_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[1,1,1],n=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0,s=arguments.length>4?arguments[4]:void 0,r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NDHWC";const i=Fm(e,"x","maxPool3d");let o=i,c=!1;4===i.rank&&(c=!0,o=tx(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),yu(5===o.rank,()=>"Error in maxPool3d: x must be rank 5 but got rank ".concat(o.rank,".")),yu("NDHWC"===r,()=>"Error in maxPool3d: Only NDHWC is currently supported, "+"but got dataFormat of ".concat(r)),ex("maxPool3d",a,s);const l={x:o},u={filterSize:t,strides:n,pad:a,dimRoundingMode:s,dataFormat:r},h=Tm.runKernel(jd,l,u);return c?tx(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}});const Uv=Bm({maxPoolWithArgmax_:function(e,t,n,a){let s=arguments.length>4&&void 0!==arguments[4]&&arguments[4];const r={x:Fm(e,"x","maxPoolWithArgmax")},i={filterSize:t,strides:n,pad:a,includeBatchInIndex:s},o=Tm.runKernel(Vd,r,i);return{result:o[0],indexes:o[1]}}});const Hv=Bm({mean_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const a={x:Fm(e,"x","mean")},s={axis:t,keepDims:n};return Tm.runKernel(Ud,a,s)}});function Gv(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32";if(qu(e),"complex64"===t){const t=Gv(e,"float32"),n=Gv(e,"float32");return jm(t,n)}const n=Hu(vu(e),t);return Tm.makeTensor(n,e,t)}function qv(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32";if(qu(e),"complex64"===t){const t=qv(e,"float32"),n=Gv(e,"float32");return jm(t,n)}const n=Uu(vu(e),t);return Tm.makeTensor(n,e,t)}function Kv(e,t){let{indexing:n="xy"}=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if("xy"!==n&&"ij"!==n)throw new TypeError("".concat(n," is not a valid third argument to meshgrid"));if(void 0===e)return[];let a=Fm(e,"x","meshgrid",e instanceof im?e.dtype:"float32");if(void 0===t)return[a];let s=Fm(t,"y","meshgrid",t instanceof im?t.dtype:"float32");const r=vu(a.shape),i=vu(s.shape);return"xy"===n?(a=tx(a,[1,-1]),s=tx(s,[-1,1]),[rx(qv([i,1],a.dtype),a),rx(s,qv([1,r],s.dtype))]):(a=tx(a,[-1,1]),s=tx(s,[1,-1]),[rx(a,qv([1,i],a.dtype)),rx(qv([r,1],s.dtype),s)])}const Xv=Bm({minimum_:function(e,t){let n=Fm(e,"a","minimum"),a=Fm(t,"b","minimum");[n,a]=xm(n,a),"bool"===n.dtype&&(n=ny(n,"int32"),a=ny(a,"int32")),Ry(n.shape,a.shape);const s={a:n,b:a};return Tm.runKernel(Gd,s)}});const Yv=Bm({mirrorPad_:function(e,t,n){yu("reflect"===n||"symmetric"===n,()=>"Invalid mode. Mode must be either reflect or symmetric. "+"Got ".concat(n,"."));const a=Fm(e,"x","mirrorPad");if(0===a.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");yu(t.length===a.rank,()=>"Padding doesn't match input. Must be ".concat(a.rank,". ")+"Got ".concat(t.length,"."));const s="reflect"===n?1:0;for(let o=0;o<a.rank;o++)yu(2===t[o].length,()=>"Invalid number of paddings. Must be length of 2 each."),yu(t[o][0]>=0&&t[o][0]<=a.shape[o]-s&&t[o][1]>=0&&t[o][1]<=a.shape[o]-s,()=>"Padding in dimension ".concat(o," cannot be greater than or equal ")+"to ".concat(a.shape[o]-s," or less than 0 for input of ")+"shape ".concat(a.shape));const r={paddings:t,mode:n},i={x:a};return Tm.runKernel(qd,i,r)}});const Qv=Bm({mod_:function(e,t){let n=Fm(e,"a","mod"),a=Fm(t,"b","mod");[n,a]=xm(n,a);const s={a:n,b:a};return Tm.runKernel(Kd,s)}});const Zv=Bm({moments_:function(e){let t=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const n=Eu(arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,(e=Fm(e,"x","moments")).shape),a=Hv(e,n,t);let s=a.shape;t||(s=Jx(a.shape,n));const r=uy(Cy(ny(e,"float32"),tx(a,s)));return{mean:a,variance:Hv(r,n,t)}}});const Jv=Bm({multiRNNCell_:function(e,t,n,a){const s=Fm(t,"data","multiRNNCell"),r=Lm(n,"c","multiRNNCell"),i=Lm(a,"h","multiRNNCell");let o=s;const c=[];for(let h=0;h<e.length;h++){const t=e[h](o,r[h],i[h]);c.push(t[0]),c.push(t[1]),o=t[1]}const l=[],u=[];for(let h=0;h<c.length;h+=2)l.push(c[h]),u.push(c[h+1]);return[l,u]}});const $v=Bm({multinomial_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s=Fm(e,"logits","multinomial"),r=s.size,i=s.rank;if(r<2)throw new Error("Error in multinomial: you need at least 2 outcomes, but got "+"".concat(r,"."));if(i>2)throw new Error("Rank of probabilities must be 1 or 2, but is ".concat(i));n=n||Math.random();const o={logits:1===i?tx(s,[1,-1]):s},c={numSamples:t,seed:n,normalized:a},l=Tm.runKernel(Xd,o,c);return 1===i?tx(l,[l.size]):l}});const ew=Bm({notEqual_:function(e,t){let n=Fm(e,"a","notEqual","string_or_numeric"),a=Fm(t,"b","notEqual","string_or_numeric");[n,a]=xm(n,a),Ry(n.shape,a.shape);const s={a:n,b:a};return Tm.runKernel(Zd,s)}});const tw=Bm({oneHot_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"int32";if(t<2)throw new Error("Error in oneHot: depth must be >=2, but it is ".concat(t));const r={indices:Fm(e,"indices","oneHot","int32")},i={dtype:s,depth:t,onValue:n,offValue:a};return Tm.runKernel(np,r,i)}});const nw=Bm({onesLike_:function(e){const t={x:Fm(e,"x","onesLike")};return Tm.runKernel(tp,t)}});const aw=Bm({outerProduct_:function(e,t){const n=Fm(e,"v1","outerProduct"),a=Fm(t,"v2","outerProduct");yu(1===n.rank&&1===a.rank,()=>"Error in outerProduct: inputs must be rank 1, but got ranks "+"".concat(n.rank," and ").concat(a.rank,"."));const s=tx(n,[-1,1]),r=tx(a,[1,-1]);return rx(s,r)}});const sw=Bm({pad_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const a=Fm(e,"x","pad");if(0===a.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const s={paddings:t,constantValue:n},r={x:a};return Tm.runKernel(sp,r,s)}});const rw=Bm({pad1d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return yu(2===t.length,()=>"Invalid number of paddings. Must be length of 2."),sw(e,[t],n)}});const iw=Bm({pad2d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return yu(2===t.length&&2===t[0].length&&2===t[1].length,()=>"Invalid number of paddings. Must be length of 2 each."),sw(e,t,n)}});const ow=Bm({pad3d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return yu(3===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length,()=>"Invalid number of paddings. Must be length of 2 each."),sw(e,t,n)}});const cw=Bm({pad4d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return yu(4===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length&&2===t[3].length,()=>"Invalid number of paddings. Must be length of 2 each."),sw(e,t,n)}});const lw=Bm({spaceToBatchND_:function(e,t,n){const a=Fm(e,"x","spaceToBatchND");yu(a.rank>=1+t.length,()=>"input rank ".concat(a.rank," should be > than [blockShape] ").concat(t.length)),yu(n.length===t.length,()=>"paddings.shape[0] ".concat(n.length," must be equal to [blockShape] ").concat(t.length)),yu(a.shape.reduce((e,a,s)=>s>0&&s<=t.length?e&&(a+n[s-1][0]+n[s-1][1])%t[s-1]===0:e,!0),()=>"input spatial dimensions ".concat(a.shape.slice(1)," with paddings ").concat(n.toString()," must be divisible by blockShapes ").concat(t.toString()));const s={x:a},r={blockShape:t,paddings:n};return Tm.runKernel(Lp,s,r)}});const uw=Bm({pool_:function(e,t,n,a,s,r,i){null==s&&(s=[1,1]),null==r&&(r=1),0===a&&(a="valid");const o=Fm(e,"x","maxPool");let c=o,l=!1;3===o.rank&&(l=!0,c=tx(o,[1,o.shape[0],o.shape[1],o.shape[2]])),yu(Zb(r,s),()=>"Error in pool: Either strides or dilations must be 1. "+"Got strides ".concat(r," and dilations '").concat(s,"'"));const u=Wb(c.shape,t,r,s,a),h=[u.dilationHeight,u.dilationWidth];let d;d="same"===a?function(e,t){const n=e.map((e,n)=>e+(e-1)*(t[n]-1)),a=n.map(e=>e-1),s=a.map(e=>Math.floor(e/2)),r=a.map((e,t)=>e-s[t]);return a.map((e,t)=>[s[t],r[t]])}([u.filterHeight,u.filterWidth],h):[[0,0],[0,0]];const p=1===h[0]&&1===h[1],[f,m]=function(e,t,n){const a=n.map(e=>e[0]),s=n.map(e=>e[1]),r=e.concat(a,s),i=t.map((e,t)=>(e-r[t]%e)%e),o=s.map((e,t)=>e+i[t]),c=t.map((e,t)=>[a[t],o[t]]),l=t.map((e,t)=>[0,i[t]]);return[c,l]}([u.inHeight,u.inWidth],h,d),g=p?a:"valid",y=p?c:lw(c,h,f),b=("avg"===n?()=>nx(y,t,r,g,i):()=>Wv(y,t,r,g,i))(),x=p?b:ux(b,h,m);return l?tx(x,[x.shape[1],x.shape[2],x.shape[3]]):x}});const hw=Bm({prelu_:function(e,t){const n={x:Fm(e,"x","prelu"),alpha:Fm(t,"alpha","prelu")};return Tm.runKernel(ip,n)}});const dw=Bm({prod_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=Fm(e,"x","prod");"bool"===a.dtype&&(a=ny(a,"int32"));const s={x:a},r={axis:t,keepDims:n};return Tm.runKernel(op,s,r)}});const pw=Bm({raggedGather_:function(e,t,n,a){const s={paramsNestedSplits:e.map((e,t)=>Fm(e,"tensors".concat(t),"raggedGather","int32")),paramsDenseValues:Fm(t,"paramsDenseValues","raggedGather"),indices:Fm(n,"indices","raggedGather","int32")},r={outputRaggedRank:a},i=Tm.runKernel(cp,s,r);return{outputNestedSplits:i.slice(0,i.length-1),outputDenseValues:i[i.length-1]}}});const fw=Bm({raggedRange_:function(e,t,n){const a=Fm(e,"starts","raggedRange"),s={starts:a,limits:Fm(t,"limits","raggedRange",a.dtype),deltas:Fm(n,"deltas","raggedRange",a.dtype)},r=Tm.runKernel(lp,s);return{rtNestedSplits:r[0],rtDenseValues:r[1]}}});const mw=Bm({raggedTensorToTensor_:function(e,t,n,a,s){const r=Fm(e,"shape","raggedTensorToTensor","int32"),i=Fm(t,"values","raggedTensorToTensor"),o={shape:r,values:i,defaultValue:Fm(n,"defaultValue","raggedTensorToTensor",i.dtype),rowPartitionTensors:a.map((e,t)=>Fm(e,"tensors".concat(t),"raggedTensorToTensor","int32"))},c={rowPartitionTypes:s};return Tm.runKernel(up,o,c)}});const gw=Bm({rand_:function(e,t,n){qu(e);const a=vu(e);let s=null;if(null==n||"float32"===n)s=new Float32Array(a);else if("int32"===n)s=new Int32Array(a);else{if("bool"!==n)throw new Error("Unknown data type ".concat(n));s=new Uint8Array(a)}for(let r=0;r<a;r++)s[r]=t();return Tm.makeTensor(s,e,n)}});var yw=n(334);class bw{constructor(e,t,n,a,s){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=a,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const r=s||Math.random();this.random=yw.alea(r.toString())}nextValue(){if(!isNaN(this.nextVal)){const e=this.nextVal;return this.nextVal=NaN,e}let e,t,n=!1;for(;!n;){let a,s,r;do{a=2*this.random()-1,s=2*this.random()-1,r=a*a+s*s}while(r>=1||0===r);const i=Math.sqrt(-2*Math.log(r)/r);e=this.mean+this.stdDev*a*i,t=this.mean+this.stdDev*s*i,this.truncated&&!this.isValidTruncated(e)||(n=!0)}return this.truncated&&!this.isValidTruncated(t)||(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return null==this.dtype||"float32"===this.dtype?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class xw{constructor(e,t,n,a){this.alpha=e,this.beta=1/t,this.dtype=n;const s=a||Math.random();this.randu=yw.alea(s.toString()),this.randn=new bw(0,1,n,!1,this.randu()),this.d=e<1?e+2/3:e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,n,a,s,r;for(;;){do{a=this.randn.nextValue(),r=1+this.c*a}while(r<=0);if(r*=r*r,e=a*a,t=1-.331*e*e,n=.5*e+this.d*(1-r+Math.log(r)),s=this.randu(),s<t||Math.log(s)<n)break}return r=1/this.beta*this.d*r,this.alpha<1&&(r*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(r)}convertValue(e){return"float32"===this.dtype?e:Math.round(e)}}class vw{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0;if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=e,this.range=t-e,this.dtype=n,null==a&&(a=Math.random()),"number"===typeof a&&(a=a.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error("The difference between ".concat(e," - ").concat(t," <= 1 and dtype is not float"));this.random=yw.alea(a)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const ww=Bm({randomGamma_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32",s=arguments.length>4?arguments[4]:void 0;if(qu(e),null==n&&(n=1),null==a&&(a="float32"),"float32"!==a&&"int32"!==a)throw new Error("Unsupported data type ".concat(a));const r=new xw(t,n,a,s),i=ty(e,a);for(let o=0;o<i.values.length;o++)i.values[o]=r.nextValue();return i.toTensor()}});const kw=Bm({randomNormal_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3?arguments[3]:void 0,s=arguments.length>4?arguments[4]:void 0;if(qu(e),null!=a&&"bool"===a)throw new Error("Unsupported data type ".concat(a));const r=new bw(t,n,a,!1,s),i=ty(e,a);for(let o=0;o<i.values.length;o++)i.values[o]=r.nextValue();return i.toTensor()}});const Sw=Bm({randomStandardNormal_:function(e,t,n){if(null!=t&&"bool"===t)throw new Error("Unsupported data type ".concat(t));return kw(e,0,1,t,n)}});const Cw=Bm({randomUniform_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32",s=arguments.length>4?arguments[4]:void 0;qu(e);const r=ty(e,a),i=new vw(t,n,null,s);for(let o=0;o<r.values.length;o++)r.values[o]=i.nextValue();return r.toTensor()}});const Iw=Bm({randomUniformInt_:function(e,t,n,a){return Cw(e,t,n,"int32",a)}});function Nw(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32";if(0===n)throw new Error("Cannot have a step of zero");const s={start:e,stop:t,step:n,dtype:a};return Tm.runKernel(hp,{},s)}const Tw=Bm({real_:function(e){const t={input:Fm(e,"input","real")};return Tm.runKernel(dp,t)}});const Ew=Bm({reciprocal_:function(e){const t={x:Fm(e,"x","reciprocal")};return Tm.runKernel(pp,t)}});const Rw=Bm({relu_:function(e){const t={x:Fm(e,"x","relu")};return Tm.runKernel(fp,t)}});const _w=Bm({relu6_:function(e){const t={x:Fm(e,"x","relu6")};return Tm.runKernel(vp,t)}});const Aw=Bm({reverse_:function(e,t){const n={x:Fm(e,"x","reverse")},a={dims:t};return Tm.runKernel(wp,n,a)}});const Mw=Bm({reverse1d_:function(e){const t=Fm(e,"x","reverse");return yu(1===t.rank,()=>"Error in reverse1D: x must be rank 1 but got rank ".concat(t.rank,".")),Aw(t,0)}});const Pw=Bm({reverse2d_:function(e,t){const n=Fm(e,"x","reverse");return yu(2===n.rank,()=>"Error in reverse2D: x must be rank 2 but got rank ".concat(n.rank,".")),Aw(n,t)}});const Dw=Bm({reverse3d_:function(e,t){const n=Fm(e,"x","reverse");return yu(3===n.rank,()=>"Error in reverse3D: x must be rank 3 but got rank ".concat(n.rank,".")),Aw(n,t)}});const Ow=Bm({reverse4d_:function(e,t){const n=Fm(e,"x","reverse");return yu(4===n.rank,()=>"Error in reverse4D: x must be rank 4 but got rank ".concat(n.rank,".")),Aw(n,t)}});const Fw=Bm({round_:function(e){const t={x:Fm(e,"x","round")};return Tm.runKernel(kp,t)}});const Lw=Bm({rsqrt_:function(e){const t={x:Fm(e,"x","rsqrt","float32")};return Tm.runKernel(Sp,t)}});const zw=Bm({selu_:function(e){const t={x:Fm(e,"x","selu")};return Tm.runKernel(Ep,t)}});const Bw=Bm({separableConv2d_:function(e,t,n,a,s){let r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"NHWC";const o=Fm(e,"x","separableConv2d"),c=Fm(t,"depthwiseFilter","separableConv2d"),l=Fm(n,"pointwiseFilter","separableConv2d");let u=o,h=!1;if(3===o.rank&&(h=!0,u=tx(o,[1,o.shape[0],o.shape[1],o.shape[2]])),"NCHW"===i)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");yu(4===u.rank,()=>"Error in separableConv2d: input must be rank 4, but got "+"rank ".concat(u.rank,".")),yu(4===c.rank,()=>"Error in separableConv2d: depthwise filter must be rank 4, but "+"got rank ".concat(c.rank,".")),yu(4===l.rank,()=>"Error in separableConv2d: pointwise filter must be rank 4, but "+"got rank ".concat(c.rank,".")),yu(1===l.shape[0],()=>"Error in separableConv2d: the first dimension of pointwise filter "+" must be 1, but got ".concat(l.shape[0],".")),yu(1===l.shape[1],()=>"Error in separableConv2d: the second dimension of pointwise "+"filter must be 1, but got ".concat(l.shape[1],"."));const d=c.shape[2],p=c.shape[3];yu(l.shape[2]===d*p,()=>"Error in separableConv2d: the third dimension of pointwise filter "+"must be ".concat(d*p,", ")+"but got ".concat(l.shape[2],"."));const f=zx(u,c,a,s,i,r),m=Ix(f,l,1,"valid",i);return h?tx(m,[m.shape[1],m.shape[2],m.shape[3]]):m}});const jw=async function(e,t){const n=Fm(e,"x","setdiff1d"),a=Fm(t,"y","setdiff1d");yu(n.dtype===a.dtype,()=>"x and y should have the same dtype, but got x (".concat(n.dtype,") and y (").concat(a.dtype,").")),yu(1===n.rank,()=>"x should be 1D tensor, but got x (".concat(n.shape,").")),yu(1===a.rank,()=>"y should be 1D tensor, but got y (".concat(a.shape,")."));const s=await n.data(),r=await a.data(),i=new Set(r);let o=0;for(let u=0;u<s.length;u++)i.has(s[u])||o++;const c=new nm([o],n.dtype),l=new nm([o],"int32");for(let u=0,h=0;u<s.length;u++)i.has(s[u])||(c.values[h]=s[u],l.values[h]=u,h++);return[c.toTensor(),l.toTensor()]};const Ww=Bm({sign_:function(e){const t={x:Fm(e,"x","sign")};return Tm.runKernel(Mp,t)}});const Vw=Bm({sin_:function(e){const t={x:Fm(e,"x","sin","float32")};return Tm.runKernel(_p,t)}});const Uw=Bm({sinh_:function(e){const t={x:Fm(e,"x","sinh")};return Tm.runKernel(Ap,t)}});const Hw=Bm({slice1d_:function(e,t,n){const a=Fm(e,"x","slice1d");return yu(1===a.rank,()=>"slice1d expects a rank-1 tensor, but got a rank-".concat(a.rank," tensor")),ox(a,[t],[n])}});const Gw=Bm({slice2d_:function(e,t,n){const a=Fm(e,"x","slice2d");return yu(2===a.rank,()=>"slice2d expects a rank-2 tensor, but got a rank-".concat(a.rank," tensor")),ox(a,t,n)}});const qw=Bm({slice3d_:function(e,t,n){const a=Fm(e,"x","slice3d");return yu(3===a.rank,()=>"slice3d expects a rank-3 tensor, but got a rank-".concat(a.rank," tensor")),ox(a,t,n)}});const Kw=Bm({slice4d_:function(e,t,n){const a=Fm(e,"x","slice4d");return yu(4===a.rank,()=>"slice4d expects a rank-4 tensor, but got a rank-".concat(a.rank," tensor")),ox(a,t,n)}});const Xw=Bm({softmax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=Fm(e,"logits","softmax","float32");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error("Softmax along a non-last dimension is not yet supported. "+"Logits was rank ".concat(n.rank," and dim was ").concat(t));const a={logits:n},s={dim:t};return Tm.runKernel(Bp,a,s)}});const Yw=Bm({fft_:function(e){yu("complex64"===e.dtype,()=>"The dtype for tf.spectral.fft() must be complex64 "+"but got ".concat(e.dtype,"."));const t={input:e};return Tm.runKernel(ld,t)}});const Qw=Bm({ifft_:function(e){yu("complex64"===e.dtype,()=>"The dtype for tf.spectral.ifft() must be complex64 "+"but got ".concat(e.dtype,"."));const t={input:e};return Tm.runKernel(vd,t)}});const Zw=Bm({irfft_:function(e){const t=e.shape[e.shape.length-1],n=e.size/t;let a;if(t<=2){const s=tx(e,[n,t]);a=Qw(s)}else{const s=[n,2*(t-1)],r=tx(Tw(e),[n,t]),i=tx(bv(e),[n,t]),o=Aw(ox(r,[0,1],[n,t-2]),1),c=cy(Aw(ox(i,[0,1],[n,t-2]),1),py(-1)),l=sx([r,o],1),u=sx([i,c],1),h=tx(jm(l,u),[s[0],s[1]]);a=Qw(h)}if(a=Tw(a),3===e.rank&&0!==e.shape[0]){const t=a,n=e.shape[0];a=tx(a,[n,a.shape[0]/n,a.shape[1]]),t.dispose()}return a}});const Jw=Bm({split_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const a={x:Fm(e,"x","split")},s={numOrSizeSplits:t,axis:n};return Tm.runKernel(zp,a,s)}});const $w=Bm({rfft_:function(e,t){yu("float32"===e.dtype,()=>"The dtype for rfft() must be real value but got ".concat(e.dtype));let n=e.shape[e.shape.length-1];const a=e.size/n;let s;if(null!=t&&t<n){const a=e.shape.map(e=>0),r=e.shape.map(e=>e);r[e.shape.length-1]=t,s=ox(e,a,r),n=t}else if(null!=t&&t>n){const a=e.shape.map(e=>e);a[e.shape.length-1]=t-n,s=sx([e,Gv(a)],e.shape.length-1),n=t}else s=e;const r=hy(s),i=tx(jm(s,r),[a,n]),o=Yw(i),c=Math.floor(n/2)+1,l=Tw(o),u=bv(o),h=Jw(l,[c,n-c],l.shape.length-1),d=Jw(u,[c,n-c],u.shape.length-1),p=s.shape.slice();return p[s.shape.length-1]=c,tx(jm(h[0],d[0]),p)}});const ek=Bm({squaredDifference_:function(e,t){let n=Fm(e,"a","squaredDifference"),a=Fm(t,"b","squaredDifference");[n,a]=xm(n,a),Ry(n.shape,a.shape);const s={a:n,b:a};return Tm.runKernel(Gp,s,{})}});const tk=Bm({squeeze_:function(e,t){const n=Fm(e,"x","squeeze","string_or_numeric");return tx(n,Ru(n.shape,t).newShape)}});const nk=Bm({stack_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=Lm(e,"tensors","stack","string_or_numeric");yu(n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&yu(t<=n[0].rank,()=>"Axis must be <= rank of the tensor");const a=n,s={axis:t};return Tm.runKernel(ap,a,s)}});const ak=Bm({step_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:Fm(e,"x","step")},a={alpha:t};return Tm.runKernel(uf,n,a)}});const sk=Bm({stridedSlice_:function(e,t,n,a){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0,o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,c=arguments.length>8&&void 0!==arguments[8]?arguments[8]:0;const l={x:Fm(e,"x","stridedSlice","string_or_numeric")},u={begin:t,end:n,strides:a,beginMask:s,endMask:r,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:c};return Tm.runKernel(Xp,l,u)}});const rk=Bm({tan_:function(e){const t={x:Fm(e,"x","tan","float32")};return Tm.runKernel($p,t)}});function ik(e,t){xu(e);const n=Pm(e,t);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Wm(e,null,n,t)}function ok(e,t,n){if(xu(e),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");const a=Pm(e,n);if(2!==a.length&&1!==a.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===a.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Wm(e,t,a,n)}function ck(e,t,n){if(xu(e),null!=t&&4!==t.length)throw new Error("tensor4d() requires shape to have four numbers");const a=Pm(e,n);if(4!==a.length&&1!==a.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===a.length&&null==t)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return Wm(e,t,a,n)}function lk(e,t,n){if(xu(e),null!=t&&5!==t.length)throw new Error("tensor5d() requires shape to have five numbers");const a=Pm(e,n);if(5!==a.length&&1!==a.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===a.length&&null==t)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return Wm(e,t,a,n)}function uk(e,t,n){if(xu(e),null!=t&&6!==t.length)throw new Error("tensor6d() requires shape to have six numbers");const a=Pm(e,n);if(6!==a.length&&1!==a.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===a.length&&null==t)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return Wm(e,t=t||a,a,n)}function hk(e,t,n){const a=t.rank>1?t.shape[t.rank-1]:1,s=t.rank>1?t.rank-1:1,r="Must have updates.shape = indices.shape[:batchDim] + "+"shape[sliceDim:], got updates.shape: ".concat(n.shape)+", indices.shape: ".concat(t.shape,", shape: ").concat(e)+", sliceDim: ".concat(a,", and batchDim: ").concat(s,".");if(n.rank<s)throw new Error(r+" update.rank < ".concat(s,". "));if(e.length<a+(n.rank-s))throw new Error(r+" Output shape length < ".concat(a+(n.rank-s)));if(n.rank!==s+e.length-a)throw new Error(r+" update.rank != ".concat(s+e.length-a));for(let i=0;i<s;++i)if(n.shape[i]!==t.shape[i])throw new Error(r+" updates.shape[".concat(i,"] (").concat(n.shape[i],") != indices.shape[").concat(i,"] (").concat(t.shape[i],")."));for(let i=0;i<n.rank-s;++i)if(n.shape[i+s]!==e[i+a])throw new Error(r+" updates.shape[".concat(i+s,"] (").concat(n.shape[i+s],") != shape[").concat(i+s,"] (").concat(e[i+s],")"))}function dk(e,t,n){if(t.rank<1)throw new Error("tf.scatterND() expects the indices to be rank 1 or higher,"+" but the rank was ".concat(t.rank,"."));if(e.rank<1)throw new Error("tf.scatterND() expects the updates to be rank 1 or higher,"+" but the rank was ".concat(e.rank,"."));if("int32"!==t.dtype)throw new Error("The dtype of 'indices' should be int32, but got dtype: ".concat(t.dtype));if(n.length<1)throw new Error("Output rank must be greater or equal to 1, but got shape: ".concat(n));if(0===n.length){if(0===t.size)throw new Error("Indices specified for empty output. indices shape: ".concat(t.shape));if(0===e.size)throw new Error("Updates specified for empty output. updates shape: ".concat(e.shape))}hk(n,t,e)}function pk(e,t,n){const a=t.shape.length,s=a>1?t.shape[a-1]:1,r=n.length;let i=1;for(let c=s;c<r;++c)i*=n[c];const o=s<1?1:s;return{sliceRank:s,numUpdates:vu(t.shape)/o,sliceSize:i,strides:[...Bu(n.slice(0,s)),1],outputSize:vu(n)}}const fk=Bm({tensorScatterUpdate_:function(e,t,n){const a=Fm(e,"tensor","tensorScatterupdate"),s=Fm(t,"indices","tensorScatterupdate","int32"),r=Fm(n,"updates","tensorScatterupdate");if(dk(r,s,a.shape),a.dtype!==r.dtype)throw new Error("tensor and updates must have the same dtype, instead they are ".concat(a.dtype," and ").concat(r.dtype,"."));const i={tensor:a,indices:s,updates:r};return Tm.runKernel(Ip,i,{})}});const mk=Bm({topk_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];const a=Fm(e,"x","topk");if(0===a.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const s=a.shape[a.shape.length-1];if(t<0)throw new Error("'k' passed to topk() must be >= 0 but got ".concat(t));if(t>s)throw new Error("'k' passed to topk() must be <= the last dimension (".concat(s,") ")+"but got ".concat(t));const r={x:a},i={k:t,sorted:n},[o,c]=Tm.runKernel(nf,r,i);return{values:o,indices:c}}});const gk=Bm({truncatedNormal_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3?arguments[3]:void 0,s=arguments.length>4?arguments[4]:void 0;if(qu(e),null!=a&&"bool"===a)throw new Error("Unsupported data type $ { dtype }");const r=new bw(t,n,a,!0,s),i=ty(e,a);for(let o=0;o<i.values.length;o++)i.values[o]=r.nextValue();return i.toTensor()}});const yk=Bm({unique_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=Fm(e,"x","unique","string_or_numeric");yu(n.rank>0,()=>"The input tensor must be at least 1D");const a={x:n},s={axis:t},[r,i]=Tm.runKernel(rf,a,s);return{values:r,indices:i}}});const bk=Bm({unsortedSegmentSum_:function(e,t,n){const a=Fm(e,"x","unsortedSegmentSum"),s=Fm(t,"segmentIds","unsortedSegmentSum","int32");yu(Su(n),()=>"numSegments must be of dtype int");const r={x:a,segmentIds:s},i={numSegments:n};return Tm.runKernel(cf,r,i)}});const xk=Bm({unstack_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=Fm(e,"x","unstack","string_or_numeric");yu(t>=-n.shape.length&&t<n.shape.length,()=>"Axis = ".concat(t," is not in [-").concat(n.shape.length,", ").concat(n.shape.length,")"));const a={value:n},s={axis:t};return Tm.runKernel(of,a,s)}});function vk(e,t){return Bv(e,t,"right")}function wk(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0;return Tm.makeVariable(e,t,n,a)}function kk(e,t){const n=[];for(let r=0;r<t.length;r++)t[r]&&n.push(r);const a=ty(e,"int32"),s=ty([n.length,e.length],"int32");for(let r=0;r<n.length;r++){const t=a.indexToLoc(n[r]),i=r*e.length;s.values.set(t,i)}return s.toTensor()}const Sk=async function(e){const t=Fm(e,"condition","whereAsync","bool"),n=await t.data(),a=kk(t.shape,n);return e!==t&&t.dispose(),a};const Ck=async function(e,t,n){const a=Fm(e,"tensor","boolMask"),s=Fm(t,"mask","boolMask","bool"),r=null==n?0:n,i=s.rank,o=a.shape;yu(i>0,()=>"mask cannot be scalar"),bu(o.slice(r,r+i),s.shape,"mask's shape must match the first K dimensions of tensor's shape,");let c=1;for(let m=r;m<r+i;m++)c*=o[m];const l=o.slice(0,r).concat([c],o.slice(r+i)),u=tx(a,l),h=tx(s,[-1]),d=await Sk(h),p=tk(d,[1]),f=mv(u,p,r);return e!==a&&a.dispose(),t!==s&&s.dispose(),p.dispose(),u.dispose(),h.dispose(),d.dispose(),f};const Ik=Bm({transpose_:function(e,t,n){const a=Fm(e,"x","transpose");if(null==t&&(t=a.shape.map((e,t)=>t).reverse()),yu(a.rank===t.length,()=>"Error in transpose: rank of input ".concat(a.rank," ")+"must match length of perm ".concat(t,".")),t.forEach(e=>{yu(e>=0&&e<a.rank,()=>"All entries in 'perm' must be between 0 and ".concat(a.rank-1)+" but got ".concat(t))}),a.rank<=1)return a.clone();const s={x:a},r={perm:t};return"complex64"===a.dtype?Km(()=>{let e=Tw(a),t=bv(a);return e=Tm.runKernel(sf,{x:e},r),t=Tm.runKernel(sf,{x:t},r),n&&(t=Rv(t)),jm(e,t)}):Tm.runKernel(sf,s,r)}});const Nk=Bm({movingAverage_:function(e,t,n,a){let s=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];const r=Fm(e,"v","movingAverage"),i=Fm(t,"x","movingAverage"),o=Fm(n,"decay","movingAverage");var c,l;l=i,yu((c=r).dtype===l.dtype,()=>"The dtypes of the first(".concat(c.dtype,") and")+" second(".concat(l.dtype,") input must match")),yu(ku(r.shape,i.shape),()=>"Shape mismatch in v and x");const u=py(1),h=Cy(u,o);let d=cy(Cy(i,r),h);if(s){yu(null!=a,()=>"When using zeroDebias: true, step is required.");const e=Fm(a,"step","movingAverage");d=oy(d,Cy(u,Sy(o,e)))}return ry(r,d)}});const Tk=Bm({scatterND_:function(e,t,n){qu(n);const a=Fm(e,"indices","scatterND","int32"),s=Fm(t,"updates","scatterND");dk(s,a,n);const r={indices:a,updates:s},i={shape:n};return Tm.runKernel(Cp,r,i)}});const Ek=Bm({sparseToDense_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;qu(n);const s=Fm(e,"sparseIndices","sparseToDense","int32"),r=Fm(t,"sparseValues","sparseToDense","string_or_numeric"),i=Fm(a,"defaultValue","sparseToDense",r.dtype);!function(e,t,n,a){if("int32"!==e.dtype)throw new Error("tf.sparseToDense() expects the indices to be int32 type,"+" but the dtype was ".concat(e.dtype,"."));if(e.rank>2)throw new Error("sparseIndices should be a scalar, vector, or matrix,"+" but got shape ".concat(e.shape,"."));const s=e.rank>0?e.shape[0]:1,r=e.rank>1?e.shape[1]:1;if(n.length!==r)throw new Error("outputShape has incorrect number of elements:,"+" ".concat(n.length,", should be: ").concat(r,"."));const i=t.size;if(0!==t.rank&&(1!==t.rank||i!==s))throw new Error("sparseValues has incorrect shape "+"".concat(t.shape,", should be [] or [").concat(s,"]"));if(t.dtype!==a.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(s,r,n,i);const o={sparseIndices:s,sparseValues:r,defaultValue:i},c={outputShape:n};return Tm.runKernel(Hp,o,c)}});const Rk=Bm({gatherND_:function(e,t){const n=Fm(t,"indices","gatherND","int32"),a={params:Fm(e,"x","gatherND","string_or_numeric"),indices:n};return Tm.runKernel(gd,a)}});const _k=Bm({dropout_:function(e,t,n,a){const s=Fm(e,"x","dropout");if(yu("float32"===s.dtype,()=>"x has to be a floating point tensor since it's going to be "+"scaled, but got a ".concat(s.dtype," tensor instead.")),yu(t>=0&&t<1,()=>"rate must be a float in the range [0, 1), but got ".concat(t,".")),0===t)return e instanceof im?s.clone():s;const r=function(e,t){if(null==t)return e.shape.slice();if(ku(e.shape,t))return t;if(e.shape.length===t.length){const n=[];for(let a=0;a<e.shape.length;a++)null==t[a]&&null!=e.shape[a]?n.push(e.shape[a]):n.push(t[a]);return n}return t}(s,n),i=1-t,o=oy(fv(ry(Cw(r,0,1,"float32",a),i)),i);return cy(s,o)}});function Ak(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function Mk(e,t,n){const a=1-e%2,s=new Float32Array(e);for(let r=0;r<e;++r){const i=2*Math.PI*r/(e+a-1);s[r]=t-n*Math.cos(i)}return ik(s,"float32")}const Pk=async function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;const a=Fm(e,"predictions","inTopK"),s=Fm(t,"targets","inTopK");yu(a.rank>1,()=>"inTopK() expects the predictions to be of rank 2 or higher, "+"but got ".concat(a.rank)),yu(a.rank-1===s.rank,()=>"predictions rank should be 1 larger than targets rank, but got predictions rank "+"".concat(a.rank," and targets rank ").concat(s.rank)),bu(a.shape.slice(0,a.shape.length-1),s.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const r=a.shape[a.shape.length-1];yu(n>0&&n<=r,()=>"'k' passed to inTopK() must be > 0 && <= the predictions last "+"dimension (".concat(r,"), but got ").concat(n));const i=await a.data(),o=await s.data(),[c,l]=[i.length/r,r],u=_u("bool",c);for(let h=0;h<c;h++){const e=h*l,t=i.subarray(e,e+l),a=[];for(let n=0;n<t.length;n++)a.push({value:t[n],index:n});a.sort((e,t)=>t.value-e.value),u[h]=0;for(let s=0;s<n;s++)if(a[s].index===o[h]){u[h]=1;break}}return e!==a&&a.dispose(),t!==s&&s.dispose(),Vm(u,s.shape,"bool")};const Dk=Bm({conv2DBackpropFilter_:function(e,t,n,a,s){let r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",i=arguments.length>6?arguments[6]:void 0,o=e;3===e.rank&&(o=tx(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let c=t;3===c.rank&&(c=tx(t,[1,t.shape[0],t.shape[1],t.shape[2]])),yu(4===o.rank,()=>"Error in conv2dDerFilter: input must be rank 4, but got shape "+"".concat(o.shape,".")),yu(4===c.rank,()=>"Error in conv2dDerFilter: dy must be rank 4, but got shape "+"".concat(c.shape,".")),yu(4===n.length,()=>"Error in conv2dDerFilter: filterShape must be length 4, but got "+"".concat(n,"."));const l="NHWC"===r?o.shape[3]:o.shape[1],u="NHWC"===r?c.shape[3]:c.shape[1];yu(l===n[2],()=>"Error in conv2dDerFilter: depth of input ".concat(l,") must ")+"match input depth in filter (".concat(n[2],".")),yu(u===n[3],()=>"Error in conv2dDerFilter: depth of dy (".concat(u,") must ")+"match output depth for filter (".concat(n[3],").")),ex("conv2dDerFilter",s,i);const h={x:o,dy:c},d={strides:a,pad:s,dataFormat:r,dimRoundingMode:i,filterShape:n};return Tm.runKernel(Dh,h,d)}});function Ok(e,t,n){if(null==n||"linear"===n)return e;if("relu"===n)return cy(e,ak(t));throw new Error("Cannot compute gradient for fused activation ".concat(n,"."))}function Fk(e,t){let n=t;const a=Ey(e.shape,t.shape);return a.length>0&&(n=rv(n,a)),tx(n,e.shape)}function Lk(e,t,n,a){if("linear"===t)return e;if("relu"===t)return Rw(e);if("elu"===t)return qx(e);if("relu6"===t)return _w(e);if("prelu"===t)return hw(e,n);if("leakyrelu"===t)return kv(e,a);if("sigmoid"===t)return ix(e);throw new Error("Unknown fused activation ".concat(t,"."))}const zk=(e,t)=>!(e>0)||"linear"===t;const Bk=Bm({fusedConv2d_:function(e){let{x:t,filter:n,strides:a,pad:s,dataFormat:r="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:c,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:h}=e;if(l=l||"linear",!1===zk(Tm.state.gradientDepth,l)){yu("NHWC"===r,()=>"Error in fused conv2d: got dataFormat of ".concat(r," but ")+"only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.");let e=Ix(t,n,a,s,r,i,o);return null!=c&&(e=ry(e,c)),Lk(e,l,u,h)}const d=Fm(t,"x","conv2d","float32"),p=Fm(n,"filter","conv2d","float32");let f=d,m=!1;3===d.rank&&(m=!0,f=tx(d,[1,d.shape[0],d.shape[1],d.shape[2]])),yu(4===f.rank,()=>"Error in fused conv2d: input must be rank 4, but got rank "+"".concat(f.rank,".")),yu(4===p.rank,()=>"Error in fused conv2d: filter must be rank 4, but got rank "+"".concat(p.rank,".")),ex("fused conv2d",s,o);const g="NHWC"===r?f.shape[3]:f.shape[1];yu(p.shape[2]===g,()=>"Error in conv2d: depth of input (".concat(g,") must match ")+"input depth for filter ".concat(p.shape[2],".")),yu(Zb(a,i),()=>"Error in conv2D: Either strides or dilations must be 1. "+"Got strides ".concat(a," and dilations '").concat(i,"'"));const y=Ub(f.shape,p.shape,a,i,s,o);let b,x;if(null!=c&&(b=Fm(c,"bias","fused conv2d"),[b]=xm(b,d),"NHWC"===r?Ry(y.outShape,b.shape):(yu(b.shape.length<=1,()=>"Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of "+"rank-".concat(b.shape.length,".")),yu(0===b.shape.length||b.shape[0]===y.outChannels||1===b.shape[0],()=>"Error in fused conv2d: bias shape (".concat(b.shape,") is not ")+"compatible with the number of output channels "+"(".concat(y.outChannels,")")))),null!=u){const e=u.shape;if(yu(e.length<=1||3===e.length,()=>"Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of "+"rank-".concat(e.length,".")),1===e.length)yu(1===e[0]||e[0]===y.outChannels,()=>"Error in fused conv2d: PReLU activation weights "+"(".concat(e,") is not compatible with the number of output ")+"channels (".concat(y.outChannels,")."));else if(3===e.length)try{Ry(e,y.outShape)}catch(G5){const n="Error in fused conv2d: PReLU activation weights (".concat(e,") ")+"is not compatible with the output shape of the conv2d "+"(".concat(y.outShape,").");throw Error(n)}x=Fm(u,"prelu weights","fused conv2d")}const v=(e,t)=>{yu("NHWC"===r,()=>"Error in gradient of fused conv2D: got dataFormat of ".concat(r," but only NHWC is currently supported."));const[n,o,c,u]=t,h=Ok(e,c,l);yu(Qb(i),()=>"Error in gradient of fused conv2D: dilation rates greater than 1 "+"are not yet supported in gradients. Got dilations '".concat(i,"'"));const d=[Tx(o.shape,h,n,a,s),Dk(o,h,n.shape,a,s)];if(null!=u){const e=Fk(u,h);d.push(e)}return d},w={x:f,filter:p,bias:b,preluActivationWeights:x},k={strides:a,pad:s,dataFormat:r,dilations:i,dimRoundingMode:o,activation:l,leakyreluAlpha:h};if(null==c){const e=dy((e,t,n)=>{let a=Tm.runKernel(ff,w,k);return n([t,e,a]),m&&(a=tx(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:v}});return e(f,p)}{const e=dy((e,t,n,a)=>{let s=Tm.runKernel(ff,w,k);return a([t,e,s,n]),m&&(s=tx(s,[s.shape[1],s.shape[2],s.shape[3]])),{value:s,gradFunc:v}});return e(f,p,b)}}});const jk=Bm({depthwiseConv2dNativeBackpropFilter_:function(e,t,n,a,s){let r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6?arguments[6]:void 0,o=e;3===e.rank&&(o=tx(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let c=t;3===c.rank&&(c=tx(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const l={x:o,dy:c},u={strides:a,pad:s,dimRoundingMode:i,dilations:r,filterShape:n};return Tm.runKernel(Kh,l,u)}});const Wk=Bm({depthwiseConv2dNativeBackpropInput_:function(e,t,n,a,s){let r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6?arguments[6]:void 0,o=t,c=!1;3===t.rank&&(c=!0,o=tx(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const l={dy:o,filter:n},u={strides:a,pad:s,dimRoundingMode:i,dilations:r,inputShape:e},h=Tm.runKernel(Xh,l,u);return c?tx(h,[h.shape[1],h.shape[2],h.shape[3]]):h}});const Vk=Bm({fusedDepthwiseConv2d_:function(e){let{x:t,filter:n,strides:a,pad:s,dataFormat:r="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:c,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:h}=e;if(!1===zk(Tm.state.gradientDepth,l)){let e=zx(t,n,a,s,r,i,o);return null!=c&&(e=ry(e,c)),Lk(e,l,u,h)}const d=Fm(t,"x","depthwiseConv2d","float32"),p=Fm(n,"filter","depthwiseConv2d","float32");let f=d,m=!1;3===d.rank&&(m=!0,f=tx(d,[1,d.shape[0],d.shape[1],d.shape[2]])),yu(4===f.rank,()=>"Error in fused depthwiseConv2d: input must be rank 4, but got "+"rank ".concat(f.rank,".")),yu(4===p.rank,()=>"Error in fused depthwiseConv2d: filter must be rank 4, "+"but got rank ".concat(p.rank,".")),yu(f.shape[3]===p.shape[2],()=>"Error in fused depthwiseConv2d: number of input channels "+"(".concat(f.shape[3],") must match the inChannels dimension in ")+"filter ".concat(p.shape[2],".")),null==i&&(i=[1,1]),yu(Zb(a,i),()=>"Error in fused depthwiseConv2d: Either strides or dilations must "+"be 1. Got strides ".concat(a," and dilations '").concat(i,"'")),ex("fused depthwiseConv2d",s,o);const g=Ub(f.shape,p.shape,a,i,s,o,!0);let y,b;null!=c&&(y=Fm(c,"bias","fused conv2d"),[y]=xm(y,d),Ry(g.outShape,y.shape)),null!=u&&(b=Fm(u,"prelu weights","fused depthwiseConv2d"));const x=(e,t)=>{yu(Qb(i),()=>"Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations "+"'".concat(i,"'"));const[n,r,c,u]=t,h=Ok(e,c,l),d=Wk(r.shape,h,n,a,s,i,o),p=jk(r,h,n.shape,a,s,i,o);if(null!=u){return[d,p,Fk(y,h)]}return[d,p]},v={x:f,filter:p,bias:y,preluActivationWeights:b},w={strides:a,pad:s,dataFormat:r,dilations:i,dimRoundingMode:o,activation:l,leakyreluAlpha:h};if(null==c){const e=dy((e,t,n)=>{let a=Tm.runKernel(mf,v,w);return n([t,e,a]),m&&(a=tx(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:x}});return e(f,p)}{const e=dy((e,t,n,a)=>{let s=Tm.runKernel(mf,v,w);return a([t,e,s,n]),m&&(s=tx(s,[s.shape[1],s.shape[2],s.shape[3]])),{value:s,gradFunc:x}});return e(f,p,y)}}});const Uk=Bm({fusedMatMul_:function(e){let{a:t,b:n,transposeA:a=!1,transposeB:s=!1,bias:r,activation:i="linear",preluActivationWeights:o,leakyreluAlpha:c=.2}=e;if(!1===zk(Tm.state.gradientDepth,i)){let e=rx(t,n,a,s);return null!=r&&(e=ry(e,r)),Lk(e,i,o,c)}let l=Fm(t,"a","fused matMul"),u=Fm(n,"b","fused matMul");[l,u]=xm(l,u);const h=a?l.shape[l.rank-2]:l.shape[l.rank-1],d=s?u.shape[u.rank-1]:u.shape[u.rank-2],p=a?l.shape[l.rank-1]:l.shape[l.rank-2],f=s?u.shape[u.rank-2]:u.shape[u.rank-1],m=l.shape.slice(0,-2),g=u.shape.slice(0,-2),y=vu(m),b=vu(g);yu(h===d,()=>"Error in fused matMul: inner shapes (".concat(h,") and (")+"".concat(d,") of Tensors with shapes ").concat(l.shape," and ")+"".concat(u.shape," and transposeA=").concat(a)+" and transposeB=".concat(s," must match."));const x=Ry(l.shape.slice(0,-2),u.shape.slice(0,-2)).concat([p,f]),v=tx(l,a?[y,h,p]:[y,p,h]),w=tx(u,s?[b,f,d]:[b,d,f]);let k,S;null!=r&&(k=Fm(r,"bias","fused matMul"),[k]=xm(k,l),Ry(x,k.shape)),null!=o&&(S=Fm(o,"prelu weights","fused matMul"));const C=(e,t)=>{const[n,o,c,l]=t,u=Ok(tx(e,c.shape),c,i);let h,d;if(a||s?!a&&s?(h=rx(u,o,!1,!1),d=rx(u,n,!0,!1)):a&&!s?(h=rx(o,u,!1,!0),d=rx(n,u,!1,!1)):(h=rx(o,u,!0,!0),d=rx(u,n,!0,!0)):(h=rx(u,o,!1,!0),d=rx(n,u,!0,!1)),null!=r){return[h,d,Fk(l,u)]}return[h,d]},I={a:v,b:w,bias:k,preluActivationWeights:S},N={transposeA:a,transposeB:s,activation:i,leakyreluAlpha:c};if(null==r){const e=dy((e,t,n)=>{const a=Tm.runKernel(pf,I,N);return n([e,t,a]),{value:tx(a,x),gradFunc:C}});return e(v,w)}{const e=dy((e,t,n,a)=>{const s=Tm.runKernel(pf,I,N);return a([e,t,s,n]),{value:tx(s,x),gradFunc:C}});return e(v,w,k)}}});const Hk=Bm({hammingWindow_:function(e){return Mk(e,.54,.46)}});const Gk=Bm({hannWindow_:function(e){return Mk(e,.5,.5)}});const qk=Bm({frame_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,r=0;const i=[];for(;r+t<=e.size;)i.push(ox(e,r,t)),r+=n;if(a)for(;r<e.size;){const a=r+t-e.size,o=sx([ox(e,r,t-a),wy([a],s)]);i.push(o),r+=n}return 0===i.length?ok([],[0,t]):tx(sx(i),[i.length,t])}});const Kk=Bm({stft_:function(e,t,n,a){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Gk;null==a&&(a=Ak(t));const r=qk(e,t,n),i=cy(r,s(t));return $w(i,a)}});const Xk=Bm({cropAndResize_:function(e,t,n,a){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"bilinear",r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const i=Fm(e,"image","cropAndResize"),o=Fm(t,"boxes","cropAndResize","float32"),c=Fm(n,"boxInd","cropAndResize","int32"),l=o.shape[0];yu(4===i.rank,()=>"Error in cropAndResize: image must be rank 4,"+"but got rank ".concat(i.rank,".")),yu(2===o.rank&&4===o.shape[1],()=>"Error in cropAndResize: boxes must be have size [".concat(l,",4] ")+"but had shape ".concat(o.shape,".")),yu(1===c.rank&&c.shape[0]===l,()=>"Error in cropAndResize: boxInd must be have size [".concat(l,"] ")+"but had shape ".concat(o.shape,".")),yu(2===a.length,()=>"Error in cropAndResize: cropSize must be of length 2, but got "+"length ".concat(a.length,".")),yu(a[0]>=1&&a[1]>=1,()=>"cropSize must be atleast [1,1], but was ".concat(a)),yu("bilinear"===s||"nearest"===s,()=>"method must be bilinear or nearest, but was ".concat(s));const u={image:i,boxes:o,boxInd:c},h={method:s,extrapolationValue:r,cropSize:a};return Tm.runKernel(Uh,u,h)}});const Yk=Bm({flipLeftRight_:function(e){const t=Fm(e,"image","flipLeftRight","float32");yu(4===t.rank,()=>"Error in flipLeftRight: image must be rank 4,"+"but got rank ".concat(t.rank,"."));const n={image:t};return Tm.runKernel(hd,n,{})}});const Qk=Bm({grayscaleToRGB_:function(e){const t=Fm(e,"image","grayscaleToRGB"),n=t.rank-1,a=t.shape[n];yu(t.rank>=2,()=>"Error in grayscaleToRGB: images must be at least rank 2, "+"but got rank ".concat(t.rank,".")),yu(1===a,()=>"Error in grayscaleToRGB: last dimension of a grayscale image "+"should be size 1, but got size ".concat(a,"."));const s=new Array(t.rank);return s.fill(1,0,n),s[n]=3,dv(t,s)}});const Zk=Bm({rgbToGrayscale_:function(e){const t=Fm(e,"image","RGBToGrayscale"),n=t.rank-1,a=t.shape[n];yu(t.rank>=2,()=>"Error in RGBToGrayscale: images must be at least rank 2, "+"but got rank ".concat(t.rank,".")),yu(3===a,()=>"Error in RGBToGrayscale: last dimension of an RGB image "+"should be size 3, but got size ".concat(a,"."));const s=t.dtype,r=ny(t,"float32"),i=ik([.2989,.587,.114]);let o;switch(t.rank){case 2:o=Gx("ij,j->i",r,i);break;case 3:o=Gx("ijk,k->ij",r,i);break;case 4:o=Gx("ijkl,l->ijk",r,i);break;case 5:o=Gx("ijklm,m->ijkl",r,i);break;case 6:o=Gx("ijklmn,n->ijklm",r,i);break;default:throw new Error("Not a valid tensor rank.")}return o=uv(o,-1),ny(o,s)}});const Jk=Bm({rotateWithOffset_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5;const s=Fm(e,"image","rotateWithOffset","float32");yu(4===s.rank,()=>"Error in rotateWithOffset: image must be rank 4,"+"but got rank ".concat(s.rank,"."));const r={image:s},i={radians:t,fillValue:n,center:a};return Tm.runKernel(df,r,i)}});function $k(e,t,n,a,s,r){null==a&&(a=.5),null==s&&(s=Number.NEGATIVE_INFINITY),null==r&&(r=0);const i=e.shape[0];return n=Math.min(n,i),yu(0<=a&&a<=1,()=>"iouThreshold must be in [0, 1], but was '".concat(a,"'")),yu(2===e.rank,()=>"boxes must be a 2D tensor, but was of rank '".concat(e.rank,"'")),yu(4===e.shape[1],()=>"boxes must have 4 columns, but 2nd dimension was ".concat(e.shape[1])),yu(1===t.rank,()=>"scores must be a 1D tensor"),yu(t.shape[0]===i,()=>"scores has incompatible shape with boxes. Expected ".concat(i,", ")+"but was ".concat(t.shape[0])),yu(0<=r&&r<=1,()=>"softNmsSigma must be in [0, 1], but was '".concat(r,"'")),{maxOutputSize:n,iouThreshold:a,scoreThreshold:s,softNmsSigma:r}}const eS=Bm({nonMaxSuppression_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY;const r=Fm(e,"boxes","nonMaxSuppression","float32"),i=Fm(t,"scores","nonMaxSuppression","float32"),o=$k(r,i,n,a,s);n=o.maxOutputSize,a=o.iouThreshold,s=o.scoreThreshold;const c={maxOutputSize:n,iouThreshold:a,scoreThreshold:s};return Tm.runKernel(Jd,{boxes:r,scores:i},c)}});function tS(e,t,n){const a=function(e,t,n){return function(e,t,n){let a=0,s=e.length,r=0,i=!1;for(;a<s;){r=a+(s-a>>>1);const o=n(t,e[r]);o>0?a=r+1:(s=r,i=!o)}return i?a:-a-1}(e,t,n||nS)}(e,t,n),s=a<0?-(a+1):a;e.splice(s,0,t)}function nS(e,t){return e>t?1:e<t?-1:0}function aS(e,t,n,a,s){return iS(e,t,n,a,s,0)}function sS(e,t,n,a,s,r){return iS(e,t,n,a,s,0,!1,r,!0)}function rS(e,t,n,a,s,r){return iS(e,t,n,a,s,r,!0)}function iS(e,t,n,a,s,r){let i=arguments.length>6&&void 0!==arguments[6]&&arguments[6],o=arguments.length>7&&void 0!==arguments[7]&&arguments[7],c=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const l=[];for(let g=0;g<t.length;g++)t[g]>s&&l.push({score:t[g],boxIndex:g,suppressBeginIndex:0});l.sort(lS);const u=r>0?-.5/r:0,h=[],d=[];for(;h.length<n&&l.length>0;){const t=l.pop(),{score:n,boxIndex:r,suppressBeginIndex:i}=t;if(n<s)break;let o=!1;for(let c=h.length-1;c>=i;--c){const n=oS(e,r,h[c]);if(n>=a){o=!0;break}if(t.score=t.score*cS(a,u,n),t.score<=s)break}t.suppressBeginIndex=h.length,o||(t.score===n?(h.push(r),d.push(t.score)):t.score>s&&tS(l,t,lS))}const p=h.length,f=n-p;o&&f>0&&(h.push(...new Array(f).fill(0)),d.push(...new Array(f).fill(0)));const m={selectedIndices:h};return i&&(m.selectedScores=d),c&&(m.validOutputs=p),m}function oS(e,t,n){const a=e.subarray(4*t,4*t+4),s=e.subarray(4*n,4*n+4),r=Math.min(a[0],a[2]),i=Math.min(a[1],a[3]),o=Math.max(a[0],a[2]),c=Math.max(a[1],a[3]),l=Math.min(s[0],s[2]),u=Math.min(s[1],s[3]),h=Math.max(s[0],s[2]),d=Math.max(s[1],s[3]),p=(o-r)*(c-i),f=(h-l)*(d-u);if(p<=0||f<=0)return 0;const m=Math.max(r,l),g=Math.max(i,u),y=Math.min(o,h),b=Math.min(c,d),x=Math.max(y-m,0)*Math.max(b-g,0);return x/(p+f-x)}function cS(e,t,n){const a=Math.exp(t*n*n);return n<=e?a:0}function lS(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}const uS=async function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY;const r=Fm(e,"boxes","nonMaxSuppressionAsync"),i=Fm(t,"scores","nonMaxSuppressionAsync"),o=$k(r,i,n,a,s);n=o.maxOutputSize,a=o.iouThreshold,s=o.scoreThreshold;const c=await Promise.all([r.data(),i.data()]),l=c[0],u=c[1],{selectedIndices:h}=aS(l,u,n,a,s);return r!==e&&r.dispose(),i!==t&&i.dispose(),ik(h,"int32")};const hS=Bm({nonMaxSuppressionWithScore_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const i=Fm(e,"boxes","nonMaxSuppression"),o=Fm(t,"scores","nonMaxSuppression"),c=$k(i,o,n,a,s,r);n=c.maxOutputSize,a=c.iouThreshold,s=c.scoreThreshold,r=c.softNmsSigma;const l={boxes:i,scores:o},u={maxOutputSize:n,iouThreshold:a,scoreThreshold:s,softNmsSigma:r},h=Tm.runKernel(ep,l,u);return{selectedIndices:h[0],selectedScores:h[1]}}});const dS=async function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const i=Fm(e,"boxes","nonMaxSuppressionAsync"),o=Fm(t,"scores","nonMaxSuppressionAsync"),c=$k(i,o,n,a,s,r);n=c.maxOutputSize,a=c.iouThreshold,s=c.scoreThreshold,r=c.softNmsSigma;const l=await Promise.all([i.data(),o.data()]),u=l[0],h=l[1],{selectedIndices:d,selectedScores:p}=rS(u,h,n,a,s,r);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:ik(d,"int32"),selectedScores:ik(p)}};const pS=Bm({nonMaxSuppressionPadded_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,r=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const i=Fm(e,"boxes","nonMaxSuppression"),o=Fm(t,"scores","nonMaxSuppression"),c=$k(i,o,n,a,s,null),l={boxes:i,scores:o},u={maxOutputSize:c.maxOutputSize,iouThreshold:c.iouThreshold,scoreThreshold:c.scoreThreshold,padToMaxOutputSize:r},h=Tm.runKernel($d,l,u);return{selectedIndices:h[0],validOutputs:h[1]}}});const fS=async function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,r=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const i=Fm(e,"boxes","nonMaxSuppressionAsync"),o=Fm(t,"scores","nonMaxSuppressionAsync"),c=$k(i,o,n,a,s,null),l=c.maxOutputSize,u=c.iouThreshold,h=c.scoreThreshold,[d,p]=await Promise.all([i.data(),o.data()]),{selectedIndices:f,validOutputs:m}=sS(d,p,l,u,h,r);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:ik(f,"int32"),validOutputs:py(m,"int32")}};const mS=Bm({resizeBilinear_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s=Fm(e,"images","resizeBilinear");yu(3===s.rank||4===s.rank,()=>"Error in resizeBilinear: x must be rank 3 or 4, but got "+"rank ".concat(s.rank,".")),yu(2===t.length,()=>"Error in resizeBilinear: new shape must 2D, but got shape "+"".concat(t,".")),yu(!1===a||!1===n,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let r=s,i=!1;3===s.rank&&(i=!0,r=tx(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const[]=t,o={images:r},c={alignCorners:n,halfPixelCenters:a,size:t},l=Tm.runKernel(bp,o,c);return i?tx(l,[l.shape[1],l.shape[2],l.shape[3]]):l}});const gS=Bm({resizeNearestNeighbor_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s=Fm(e,"images","resizeNearestNeighbor");yu(3===s.rank||4===s.rank,()=>"Error in resizeNearestNeighbor: x must be rank 3 or 4, but got "+"rank ".concat(s.rank,".")),yu(2===t.length,()=>"Error in resizeNearestNeighbor: new shape must 2D, but got shape "+"".concat(t,".")),yu("float32"===s.dtype||"int32"===s.dtype,()=>"`images` must have `int32` or `float32` as dtype"),yu(!1===a||!1===n,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let r=s,i=!1;3===s.rank&&(i=!0,r=tx(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const[]=t,o={images:r},c={alignCorners:n,halfPixelCenters:a,size:t},l=Tm.runKernel(gp,o,c);return i?tx(l,[l.shape[1],l.shape[2],l.shape[3]]):l}});const yS=Bm({threshold_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"binary",n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5;const s=Fm(e,"image","threshold"),r=s.shape[0]*s.shape[1];let i,o,c,l,u=cy(ik([a]),255);if(yu(3===s.rank,()=>"Error in threshold: image must be rank 3,"+"but got rank ".concat(s.rank,".")),yu(3===s.shape[2]||1===s.shape[2],()=>"Error in threshold: image color channel must be equal to 3 or 1"+"but got ".concat(s.shape[2],".")),yu("int32"===s.dtype||"float32"===s.dtype,()=>"Error in dtype: image dtype must be int32 or float32,"+"but got dtype ".concat(s.dtype,".")),yu("otsu"===t||"binary"===t,()=>"Method must be binary or otsu, but was ".concat(t)),3===s.shape[2]){[i,o,c]=Jw(s,[1,1,1],-1);const e=cy(i,.2989),t=cy(o,.587),n=cy(c,.114);l=ry(ry(e,t),n)}else l=e;if("otsu"===t){u=function(e,t){let n,a,s,r,i,o,c=ik([-1]),l=ik([0]),u=ik([0]);for(let h=0;h<e.size-1;h++){n=ox(e,0,h+1),a=ox(e,h+1),i=oy(rv(n),t),o=oy(rv(a),t);const d=rv(cy(n,Nw(0,n.size)));s=oy(d,rv(n));const p=wy(a.shape,n.size),f=ry(Nw(0,a.size),p),m=cy(a,f);r=oy(rv(m),rv(a));const g=Cy(s,r),y=Cy(s,r),b=cy(i,o);u=cy(cy(b,g),y);const x=gv(u,l);l=Vx(x,u,l),c=Vx(x,ik([h]),c)}return c}(mx(ny(Fw(l),"int32"),Vm([]),256),r)}const h=n?Cv(l,u):gv(l,u);return ny(cy(h,255),"int32")}});const bS=Bm({transform_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"nearest",a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"constant",s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,r=arguments.length>5?arguments[5]:void 0;const i=Fm(e,"image","transform","float32"),o=Fm(t,"transforms","transform","float32");yu(4===i.rank,()=>"Error in transform: image must be rank 4,"+"but got rank ".concat(i.rank,".")),yu(2===o.rank&&(o.shape[0]===i.shape[0]||1===o.shape[0])&&8===o.shape[1],()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),yu(null==r||2===r.length,()=>"Error in transform: outputShape must be [height, width] or null, "+"but got ".concat(r,"."));const c={image:i,transforms:o},l={interpolation:n,fillMode:a,fillValue:s,outputShape:r};return Tm.runKernel(af,c,l)}});const xS=Bm({bandPart_:function(e,t,n){const a=Fm(e,"a","bandPart");yu(a.rank>=2,()=>"bandPart(): Rank must be at least 2, got ".concat(a.rank,"."));const s=a.shape,[r,i]=a.shape.slice(-2);let o,c;"number"===typeof t?(yu(t%1===0,()=>"bandPart(): numLower must be an integer, got ".concat(t,".")),yu(t<=r,()=>"bandPart(): numLower (".concat(t,")")+" must not be greater than the number of rows (".concat(r,").")),o=Fm(t<0?r:t,"numLower","bandPart")):(yu("int32"===t.dtype,()=>"bandPart(): numLower's dtype must be an int32."),o=Vx(Sv(t,0),r,Xv(t,r))),"number"===typeof n?(yu(n%1===0,()=>"bandPart(): numUpper must be an integer, got ".concat(n,".")),yu(n<=i,()=>"bandPart(): numUpper (".concat(n,")")+" must not be greater than the number of columns (".concat(i,").")),c=Fm(n<0?i:n,"numUpper","bandPart")):(yu("int32"===n.dtype,()=>"bandPart(): numUpper's dtype must be an int32."),c=Vx(Sv(n,0),i,Xv(n,i)));const l=tx(Nw(0,r,1,"int32"),[-1,1]),u=Nw(0,i,1,"int32"),h=Cy(l,u),d=Dv(Cv(h,o),yv(h,Rv(c))),p=Gv([r,i],a.dtype);return tx(nk(xk(tx(a,[-1,r,i])).map(e=>Vx(d,e,p))),s)}});const vS=Bm({gramSchmidt_:function(e){let t;if(Array.isArray(e)){t=!1,yu(null!=e&&e.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const n=e[0].shape[0];for(let t=1;t<e.length;++t)yu(e[t].shape[0]===n,()=>"Gram-Schmidt: Non-unique lengths found in the input vectors: "+"(".concat(e[t].shape[0]," vs. ").concat(n,")"))}else t=!0,e=Jw(e,e.shape[0],0).map(e=>tk(e,[0]));yu(e.length<=e[0].shape[0],()=>"Gram-Schmidt: Number of vectors (".concat(e.length,") exceeds ")+"number of dimensions (".concat(e[0].shape[0],")."));const n=[],a=e;for(let s=0;s<e.length;++s)n.push(Tm.tidy(()=>{let e=a[s];if(s>0)for(let t=0;t<s;++t){const a=cy(rv(cy(n[t],e)),n[t]);e=Cy(e,a)}return oy(e,ov(e,"euclidean"))}));return t?nk(n,0):n}});function wS(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return Tm.tidy(()=>{yu(2===e.shape.length,()=>"qr2d() requires a 2D Tensor, but got a ".concat(e.shape.length,"D Tensor."));const n=e.shape[0],a=e.shape[1];let s=pv(n),r=ay(e);const i=ok([[1]],[1,1]);let o=ay(i);const c=n>=a?a:n;for(let e=0;e<c;++e){const t=r,c=o,l=s;[o,r,s]=Tm.tidy(()=>{const t=ox(r,[e,e],[n-e,1]),c=ov(t),l=ox(r,[e,e],[1,1]),u=Vx(gv(l,0),ok([[-1]]),ok([[1]])),h=Cy(l,cy(u,c)),d=oy(t,h);o=1===d.shape[0]?ay(i):sx([i,ox(d,[1,0],[d.shape[0]-1,d.shape[1]])],0);const p=Rv(oy(rx(u,h),c)),f=ox(r,[e,0],[n-e,a]),m=cy(p,o),g=Ik(o);if(0===e)r=Cy(f,rx(m,rx(g,f)));else{const t=Cy(f,rx(m,rx(g,f)));r=sx([ox(r,[0,0],[e,a]),t],0)}const y=Ik(m),b=ox(s,[0,e],[n,s.shape[1]-e]);if(0===e)s=Cy(b,rx(rx(b,o),y));else{const t=Cy(b,rx(rx(b,o),y));s=sx([ox(s,[0,0],[n,e]),t],1)}return[o,r,s]}),Xm([t,c,l])}return!t&&n>a&&(s=ox(s,[0,0],[n,a]),r=ox(r,[0,0],[a,a])),[s,r]})}const kS=Bm({qr_:function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(yu(e.rank>=2,()=>"qr() requires input tensor to have a rank >= 2, but got rank ".concat(e.rank)),2===e.rank)return wS(e,t);{const n=e.shape.slice(0,e.shape.length-2).reduce((e,t)=>e*t),a=xk(tx(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),s=[],r=[];a.forEach(e=>{const[n,a]=wS(e,t);s.push(n),r.push(a)});return[tx(nk(s,0),e.shape),tx(nk(r,0),e.shape)]}}});var SS;!function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(SS||(SS={}));const CS=Bm({computeWeightedLoss_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:SS.SUM_BY_NONZERO_WEIGHTS;const a=Fm(e,"losses","computeWeightedLoss");let s=null;null!=t&&(s=Fm(t,"weights","computeWeightedLoss"));const r=null==s?a:cy(a,s);if(n===SS.NONE)return r;if(n===SS.SUM)return rv(r);if(n===SS.MEAN){if(null==s)return Hv(r);{const e=a.size/s.size,t=oy(rv(r),rv(s));return e>1?oy(t,py(e)):t}}if(n===SS.SUM_BY_NONZERO_WEIGHTS){if(null==s)return oy(rv(r),py(a.size));{const e=cy(s,qv(a.shape)),t=ny(rv(ew(e,py(0))),"float32");return oy(rv(r),t)}}throw Error("Unknown reduction: ".concat(n))}});const IS=Bm({absoluteDifference_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:SS.SUM_BY_NONZERO_WEIGHTS;const s=Fm(e,"labels","absoluteDifference"),r=Fm(t,"predictions","absoluteDifference");let i=null;null!=n&&(i=Fm(n,"weights","absoluteDifference")),bu(s.shape,r.shape,"Error in absoluteDifference: ");const o=Ny(Cy(s,r));return CS(o,i,a)}});const NS=Bm({cosineDistance_:function(e,t,n,a){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:SS.SUM_BY_NONZERO_WEIGHTS;const r=Fm(e,"labels","cosineDistance"),i=Fm(t,"predictions","cosineDistance");let o=null;null!=a&&(o=Fm(a,"weights","cosineDistance")),bu(r.shape,i.shape,"Error in cosineDistance: ");const c=py(1),l=Cy(c,rv(cy(r,i),n,!0));return CS(l,o,s)}});const TS=Bm({hingeLoss_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:SS.SUM_BY_NONZERO_WEIGHTS,s=Fm(e,"labels","hingeLoss");const r=Fm(t,"predictions","hingeLoss");let i=null;null!=n&&(i=Fm(n,"weights","hingeLoss")),bu(s.shape,r.shape,"Error in hingeLoss: ");const o=py(1);s=Cy(cy(py(2),s),o);const c=Rw(Cy(o,cy(s,r)));return CS(c,i,a)}});const ES=Bm({huberLoss_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:SS.SUM_BY_NONZERO_WEIGHTS;const r=Fm(e,"labels","huberLoss"),i=Fm(t,"predictions","huberLoss");let o=null;null!=n&&(o=Fm(n,"weights","huberLoss")),bu(r.shape,i.shape,"Error in huberLoss: ");const c=py(a),l=Ny(Cy(i,r)),u=Xv(l,c),h=Cy(l,u),d=ry(cy(py(.5),uy(u)),cy(c,h));return CS(d,o,s)}});const RS=Bm({logLoss_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1e-7,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:SS.SUM_BY_NONZERO_WEIGHTS;const r=Fm(e,"labels","logLoss"),i=Fm(t,"predictions","logLoss");let o=null;null!=n&&(o=Fm(n,"weights","logLoss")),bu(r.shape,i.shape,"Error in logLoss: ");const c=py(1),l=py(a),u=Rv(cy(r,Tv(ry(i,l)))),h=cy(Cy(c,r),Tv(ry(Cy(c,i),l))),d=Cy(u,h);return CS(d,o,s)}});const _S=Bm({meanSquaredError_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:SS.SUM_BY_NONZERO_WEIGHTS;const s=Fm(e,"labels","meanSquaredError"),r=Fm(t,"predictions","meanSquaredError");let i=null;null!=n&&(i=Fm(n,"weights","meanSquaredError")),bu(s.shape,r.shape,"Error in meanSquaredError: ");const o=ek(s,r);return CS(o,i,a)}});const AS=Bm({sigmoidCrossEntropy_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:SS.SUM_BY_NONZERO_WEIGHTS,r=Fm(e,"multiClassLabels","sigmoidCrossEntropy");const i=Fm(t,"logits","sigmoidCrossEntropy");let o=null;if(null!=n&&(o=Fm(n,"weights","sigmoidCrossEntropy")),bu(r.shape,i.shape,"Error in sigmoidCrossEntropy: "),a>0){const e=py(a),t=py(1),n=py(.5);r=ry(cy(r,Cy(t,e)),cy(n,e))}const c=function(e,t){const n=Fm(e,"labels","sigmoidCrossEntropyWithLogits"),a=Fm(t,"logits","sigmoidCrossEntropyWithLogits");bu(n.shape,a.shape,"Error in sigmoidCrossEntropyWithLogits: ");const s=Rw(a),r=cy(a,n),i=Ev(lv(Rv(Ny(a))));return ry(Cy(s,r),i)}(r,i);return CS(c,o,s)}});const MS=Bm({softmaxCrossEntropy_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:SS.SUM_BY_NONZERO_WEIGHTS,r=Fm(e,"onehotLabels","softmaxCrossEntropy");const i=Fm(t,"logits","softmaxCrossEntropy");let o=null;if(null!=n&&(o=Fm(n,"weights","softmaxCrossEntropy")),bu(r.shape,i.shape,"Error in softmaxCrossEntropy: "),a>0){const e=py(a),t=py(1),n=py(r.shape[1]);r=ry(cy(r,Cy(t,e)),oy(e,n))}const c=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;if(-1===n&&(n=t.rank-1),n!==t.rank-1)throw Error("Softmax cross entropy along a non-last dimension is not yet "+"supported. Labels / logits was rank ".concat(t.rank," ")+"and dim was ".concat(n));const a=dy((e,t,a)=>{const s=Pv(t,[n],!0),r=Cy(ny(t,"float32"),s);a([e,r]);const i=Rv(cy(r,e));return{value:rv(i,[n]),gradFunc:(e,t)=>{const[a,s]=t,r=Jx(e.shape,[n]);return[cy(tx(e,r),Cy(ny(a,"float32"),lv(s))),cy(tx(e,r),Cy(lv(s),ny(a,"float32")))]}}});return a(e,t)}(r,i);return CS(c,o,s)}});const PS=Bm({sparseFillEmptyRows_:function(e,t,n,a){const s=Fm(e,"indices","sparseFillEmptyRows","int32"),r=Fm(t,"values","sparseFillEmptyRows"),i=Fm(n,"denseShape","sparseFillEmptyRows","int32"),o=Fm(a,"defaultValue","sparseFillEmptyRows",r.dtype);if(2!==s.rank)throw new Error("Indices should be Tensor2D but received shape\n        ".concat(s.shape));if(1!==r.rank)throw new Error("Values should be Tensor1D but received shape ".concat(r.shape));if(1!==i.rank)throw new Error("Dense shape should be Tensor1D but received shape ".concat(i.shape));if(0!==o.rank)throw new Error("Default value should be a scalar but received shape ".concat(o.shape));const c={indices:s,values:r,denseShape:i,defaultValue:o},l=Tm.runKernel(jp,c);return{outputIndices:l[0],outputValues:l[1],emptyRowIndicator:l[2],reverseIndexMap:l[3]}}});const DS=Bm({sparseReshape_:function(e,t,n){const a=Fm(e,"inputIndices","sparseReshape","int32"),s=Fm(t,"inputShape","sparseReshape","int32"),r=Fm(n,"newShape","sparseReshape","int32");if(2!==a.rank)throw new Error("Input indices should be Tensor2D but received shape\n        ".concat(a.shape));if(1!==s.rank)throw new Error("Input shape should be Tensor1D but received shape ".concat(s.shape));if(1!==r.rank)throw new Error("New shape should be Tensor1D but received shape ".concat(r.shape));const i={inputIndices:a,inputShape:s,newShape:r},o=Tm.runKernel(Wp,i);return{outputIndices:o[0],outputShape:o[1]}}});const OS=Bm({sparseSegmentMean_:function(e,t,n){const a=Fm(e,"data","sparseSegmentMean"),s=Fm(t,"indices","sparseSegmentMean","int32"),r=Fm(n,"segmentIds","sparseSegmentMean","int32");if(a.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.rank)throw new Error("Indices should be Tensor1D but received shape\n          ".concat(s.shape));if(1!==r.rank)throw new Error("Segment ids should be Tensor1D but received shape\n          ".concat(r.shape));const i={data:a,indices:s,segmentIds:r};return Tm.runKernel(Vp,i)}});const FS=Bm({sparseSegmentSum_:function(e,t,n){const a=Fm(e,"data","sparseSegmentSum"),s=Fm(t,"indices","sparseSegmentSum","int32"),r=Fm(n,"segmentIds","sparseSegmentSum","int32");if(a.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.rank)throw new Error("Indices should be Tensor1D but received shape\n         ".concat(s.shape));if(1!==r.rank)throw new Error("Segment ids should be Tensor1D but received shape\n         ".concat(r.shape));const i={data:a,indices:s,segmentIds:r};return Tm.runKernel(Up,i)}});const LS=Bm({stringNGrams_:function(e,t,n,a,s,r,i,o){const c=Fm(e,"data","stringNGrams","string");if("string"!==c.dtype)throw new Error("Data must be of datatype string");if(1!==c.shape.length)throw new Error("Data must be a vector, saw: ".concat(c.shape));const l=Fm(t,"dataSplits","stringNGrams");if("int32"!==l.dtype)throw new Error("Data splits must be of datatype int32");const u={separator:n,nGramWidths:a,leftPad:s,rightPad:r,padWidth:i,preserveShortSequences:o},h={data:c,dataSplits:l},d=Tm.runKernel(Yp,h,u);return{nGrams:d[0],nGramsSplits:d[1]}}});const zS=Bm({stringSplit_:function(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];const a=Fm(e,"input","stringSplit","string"),s=Fm(t,"delimiter","stringSplit","string");if(1!==a.rank)throw new Error("Input should be Tensor1D but received shape ".concat(a.shape));if(0!==s.rank)throw new Error("Delimiter should be a scalar but received shape ".concat(s.shape));const r={skipEmpty:n},i={input:a,delimiter:s},o=Tm.runKernel(Qp,i,r);return{indices:o[0],values:o[1],shape:o[2]}}});const BS=Bm({stringToHashBucketFast_:function(e,t){const n=Fm(e,"input","stringToHashBucketFast","string"),a={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");const s={input:n};return Tm.runKernel(Zp,s,a)}});const jS=Bm({staticRegexReplace_:function(e,t,n){let a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];const s=Fm(e,"input","staticRegexReplace","string"),r={pattern:t,rewrite:n,replaceGlobal:a};return Tm.runKernel(Kp,{x:s},r)}}),WS={fft:Yw,ifft:Qw,rfft:$w,irfft:Zw},VS={hammingWindow:Hk,hannWindow:Gk,frame:qk,stft:Kk},US={flipLeftRight:Yk,grayscaleToRGB:Qk,resizeNearestNeighbor:gS,resizeBilinear:mS,rgbToGrayscale:Zk,rotateWithOffset:Jk,cropAndResize:Xk,nonMaxSuppression:eS,nonMaxSuppressionAsync:uS,nonMaxSuppressionWithScore:hS,nonMaxSuppressionWithScoreAsync:dS,nonMaxSuppressionPadded:pS,nonMaxSuppressionPaddedAsync:fS,threshold:yS,transform:bS},HS={bandPart:xS,gramSchmidt:vS,qr:kS},GS={absoluteDifference:IS,computeWeightedLoss:CS,cosineDistance:NS,hingeLoss:TS,huberLoss:ES,logLoss:RS,meanSquaredError:_S,sigmoidCrossEntropy:AS,softmaxCrossEntropy:MS},qS={sparseFillEmptyRows:PS,sparseReshape:DS,sparseSegmentMean:OS,sparseSegmentSum:FS},KS={stringNGrams:LS,stringSplit:zS,stringToHashBucketFast:BS,staticRegexReplace:jS};const XS=class{static sgd(e){return new My(e)}static momentum(e,t){return new Py(e,t,arguments.length>2&&void 0!==arguments[2]&&arguments[2])}static rmsprop(e){return new Dy(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,arguments.length>4&&void 0!==arguments[4]&&arguments[4])}static adam(){return new Iy(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.001,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:.999,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null)}static adadelta(){return new vy(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.001,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.95,arguments.length>2&&void 0!==arguments[2]?arguments[2]:null)}static adamax(){return new Ay(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.002,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:.999,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,arguments.length>4&&void 0!==arguments[4]?arguments[4]:0)}static adagrad(e){return new ky(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.1)}},YS="undefined"!==typeof requestAnimationFrame?requestAnimationFrame:"undefined"!==typeof setImmediate?setImmediate:e=>e();function QS(){return new Promise(e=>YS(()=>e()))}function ZS(e,t){const n=e[0].length;e.forEach((e,t)=>{yu(e.length===n,()=>"Error in concat".concat(n,"D: rank of tensors[").concat(t,"] must be the same ")+"as the rank of the rest (".concat(n,")"))}),yu(t>=0&&t<n,()=>"Error in concat".concat(n,"D: axis must be between 0 and ").concat(n-1,"."));const a=e[0];e.forEach((e,s)=>{for(let r=0;r<n;r++)yu(r===t||e[r]===a[r],()=>"Error in concat".concat(n,"D: Shape of tensors[").concat(s,"] (").concat(e,") ")+"does not match the shape of the rest (".concat(a,") ")+"along the non-concatenated axis ".concat(s,"."))})}function JS(e,t){const n=e[0].slice();for(let a=1;a<e.length;a++)n[t]+=e[a][t];return n}var $S;function eC(e,t,n){let a=new Array;if(null==n&&null==t)return a;if(null==t)for(;a.length<e+n.length;)a.push(-1);else a=t.slice();if(null==n)return a;if(e+n.length!==a.length)throw new Error("rt input.shape and shape=".concat(t," are incompatible: rt input.rank = ").concat(e+n.length,", but shape.rank = ").concat(a.length));for(let s=1;s<n.length;++s){const r=n[s],i=a[a.length-n.length+s],o=a[i];if(r>=0)if(o>=0){if(o!==r)throw new Error("rt input.shape and shape=".concat(t," are incompatible: rt input.shape[").concat(s+e,"] = ").concat(r," but shape[").concat(s+e,"] = ").concat(o))}else a[i]=r}return a}function tC(e){const t={FIRST_DIM_SIZE:$S.FIRST_DIM_SIZE,VALUE_ROWIDS:$S.VALUE_ROWIDS,ROW_LENGTHS:$S.ROW_LENGTHS,ROW_SPLITS:$S.ROW_SPLITS,ROW_LIMITS:$S.ROW_LIMITS,ROW_STARTS:$S.ROW_STARTS},n=[];for(const a of e){if(!(a in t))break;n.push(t[a])}return n}function nC(e){return 0===e.length?0:e[0]===$S.FIRST_DIM_SIZE?e.length-1:e.length}function aC(e,t){if(null==e||null==t)return;const n=e.length,a=t.length;if(n>=a)throw new Error("defaultValue.shape=".concat(e," and ragged tensor flatValues.shape=").concat(t,", are incompatible: defaultValue.rank = ").concat(n," must be less than ragged tensor input flatValues.rank = ").concat(a,")"));for(let s=0;s<Math.min(n,a-1);++s){const n=e[s],a=t[s+1];if(n>=0&&a>=0&&1!==n&&n!==a)throw new Error("defaultValue.shape=".concat(e,", and ragged tensor input flatValues.shape=").concat(t," are incompatible: defaultValue.shape[").concat(s-e.length,"] = ").concat(n," but ragged tensor input.flatValues.shape[").concat(s-e.length,"] = ").concat(a))}}!function(e){e[e.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",e[e.VALUE_ROWIDS=1]="VALUE_ROWIDS",e[e.ROW_LENGTHS=2]="ROW_LENGTHS",e[e.ROW_SPLITS=3]="ROW_SPLITS",e[e.ROW_LIMITS=4]="ROW_LIMITS",e[e.ROW_STARTS=5]="ROW_STARTS"}($S||($S={}));const sC=30;function rC(e){return e<=sC?e:zu(e,Math.floor(Math.sqrt(e)))}function iC(e,t,n){return[n*("number"===typeof e?e:e[0]),t*("number"===typeof e?e:e[1])]}function oC(e,t,n){let a=[];if(!(arguments.length>3&&void 0!==arguments[3])||arguments[3])a=a.concat(t.slice(0)),a.push(e[0]/n),a=a.concat(e.slice(1));else{a=a.concat(e[0]);const n=t.length;for(let s=0;s<n;++s)a=a.concat([e[s+1]/t[s],t[s]]);a=a.concat(e.slice(n+1))}return a}function cC(e,t){const n=[];if(!(arguments.length>2&&void 0!==arguments[2])||arguments[2]){n.push(t);for(let a=t+1;a<e;++a)a<=2*t?(n.push(a),n.push(a-(t+1))):n.push(a)}else{const a=[],s=[];for(let n=1;n<e;++n)n>=2*t+1||n%2===1?s.push(n):a.push(n);n.push(...a),n.push(0),n.push(...s)}return n}function lC(e,t,n){let a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];const s=[];a?s.push(e[0]/n):s.push(e[0]*n);for(let r=1;r<e.length;++r)r<=t.length?a?s.push(t[r-1]*e[r]):s.push(e[r]/t[r-1]):s.push(e[r]);return s}function uC(e,t){const n=[0];for(let a=0;a<t;++a)n.push(e[a][0]);return n}function hC(e,t,n){const a=e.slice(0,1);for(let s=0;s<n;++s)a.push(e[s+1]-t[s][0]-t[s][1]);return a}function dC(e,t){const n=e.shape.length,a=t.shape.length;if(n<1)throw new Error("tf.gatherND() expects the input to be rank 1 or higher,"+" but the rank was ".concat(n,"."));if(a<1)throw new Error("tf.gatherND() expects the indices to be rank 1 or higher,"+" but the rank was ".concat(a,"."));if("int32"!==t.dtype)throw new Error("tf.gatherND() expects the indices to be int32 type,"+" but the dtype was ".concat(t.dtype,"."));if(t.shape[a-1]>n)throw new Error("index innermost dimension length must be <= tensor rank; saw: "+"".concat(t.shape[a-1]," vs. ").concat(n));if(0===vu(e.shape))throw new Error("Requested more than 0 entries, but input is empty."+" Input shape: ".concat(e.shape,"."));const s=t.shape,r=s[s.length-1];let i=1;for(let h=0;h<s.length-1;++h)i*=s[h];const o=e.shape,c=s.slice();c.pop();let l=1;for(let h=r;h<n;++h)l*=o[h],c.push(o[h]);const u=[...Bu(e.shape).map(e=>e/l),1].slice(0,r);return[c,i,l,u]}const pC=1.7580993408473768,fC=1.0507009873554805,mC=.3275911,gC=.254829592,yC=-.284496736,bC=1.421413741,xC=-1.453152027,vC=1.061405429;function wC(e,t){if(e.length!==t.length)throw new Error("Cannot merge real and imag arrays of different lengths. real:"+"".concat(e.length,", imag: ").concat(t.length,"."));const n=new Float32Array(2*e.length);for(let a=0;a<n.length;a+=2)n[a]=e[a/2],n[a+1]=t[a/2];return n}function kC(e){const t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let a=0;a<e.length;a+=2)t[a/2]=e[a],n[a/2]=e[a+1];return{real:t,imag:n}}function SC(e){const t=Math.ceil(e.length/4),n=new Float32Array(t),a=new Float32Array(t);for(let s=0;s<e.length;s+=4)n[Math.floor(s/4)]=e[s],a[Math.floor(s/4)]=e[s+1];return{real:n,imag:a}}function CC(e){const t=Math.floor(e.length/4),n=new Float32Array(t),a=new Float32Array(t);for(let s=2;s<e.length;s+=4)n[Math.floor(s/4)]=e[s],a[Math.floor(s/4)]=e[s+1];return{real:n,imag:a}}function IC(e,t){return{real:e[2*t],imag:e[2*t+1]}}function NC(e,t,n,a){e[2*a]=t,e[2*a+1]=n}function TC(e,t){const n=new Float32Array(e/2),a=new Float32Array(e/2);for(let s=0;s<Math.ceil(e/2);s++){const r=(t?2:-2)*Math.PI*(s/e);n[s]=Math.cos(r),a[s]=Math.sin(r)}return{real:n,imag:a}}function EC(e,t,n){const a=(n?2:-2)*Math.PI*(e/t);return{real:Math.cos(a),imag:Math.sin(a)}}const RC="->",_C=/->/g,AC=",",MC="...";function PC(e,t){const n=((e=e.replace(/\s/g,"")).length-e.replace(_C,"").length)/RC.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error('Equation must contain exactly one arrow ("'.concat(RC,'").'));const[a,s]=e.split(RC);yu(-1===a.indexOf(MC),()=>'The ellipsis notation ("'.concat(MC,'") is not supported yet.'));const r=a.split(AC),i=r.length;if(t!==i)throw new Error("Expected ".concat(i," input tensors, received ").concat(t));if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const o=[];for(let h=0;h<s.length;++h){const e=s[h];if(!r.some(t=>-1!==t.indexOf(e)))throw new Error("Output subscripts contain the label ".concat(e," ")+"not present in the input subscripts.");-1===o.indexOf(e)&&o.push(e)}for(let h=0;h<a.length;++h){const e=a[h];-1===o.indexOf(e)&&e!==AC&&o.push(e)}const c=new Array(r.length);for(let h=0;h<i;++h){if(new Set(r[h].split("")).size!==r[h].length)throw new Error("Found duplicate axes in input component ".concat(r[h],". ")+"Support for duplicate axes in input is not implemented yet.");c[h]=[];for(let e=0;e<r[h].length;++e)c[h].push(o.indexOf(r[h][e]))}const l=o.length,u=[];for(let h=s.length;h<l;++h)u.push(h);return{allDims:o,summedDims:u,idDims:c}}function DC(e,t){let n=new Array(e);n.fill(-1);for(let s=0;s<t.length;++s)n[t[s]]=s;const a=[];for(let s=0;s<e;++s)-1===n[s]&&a.push(s);return n=n.filter(e=>-1!==e),{permutationIndices:n,expandDims:a}}function OC(e,t,n){const a=new Array(e);for(let s=0;s<n.length;++s){const e=n[s].shape;for(let n=0;n<t[s].length;++n)void 0===a[t[s][n]]?a[t[s][n]]=e[n]:yu(a[t[s][n]]===e[n],()=>"Expected dimension ".concat(a[t[s][n]]," at axis ").concat(n," ")+"of input shaped ".concat(JSON.stringify(e),", ")+"but got dimension ".concat(e[n]))}}function FC(e,t){const n=e,a=[];let s=0;0===e.length&&n.push(-1),s=e.length+1;for(let i=0;i<s;++i)a.push([]);const r=[];for(let i=0;i<n.length;++i){const e=zC(t,n[i]);for(const t of e)-1===r.indexOf(t)&&(a[i].push(t),r.push(t))}return{path:n,steps:a}}function LC(e){return e.every((e,t)=>e===t)}function zC(e,t){const n=[];for(let a=0;a<e.length;++a)0!==e[a].length&&-1===e[a].indexOf(t)&&-1!==t||n.push(a);return n}function BC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=[];if("number"===typeof t)yu(e.shape[n]%t===0,()=>"Number of splits must evenly divide the axis."),a=new Array(t).fill(e.shape[n]/t);else{const s=t.reduce((e,t)=>(-1===t&&(e+=1),e),0);yu(s<=1,()=>"There should be only one negative value in split array.");const r=t.indexOf(-1);if(-1!==r){const a=t.reduce((e,t)=>t>0?e+t:e);t[r]=e.shape[n]-a}yu(e.shape[n]===t.reduce((e,t)=>e+t),()=>"The sum of sizes must match the size of the axis dimension."),a=t}return a}function jC(e){return"Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ".concat(e)}function WC(e,t){return"indices(".concat(e,", 0) is invalid: ").concat(t," < 0")}function VC(e,t,n){return"indices(".concat(e,", 0) is invalid: ").concat(t," >= ").concat(n)}function UC(e,t){return"only one output dimension may be -1, not both ".concat(e," and ").concat(t)}function HC(e,t){return"size ".concat(e," must be non-negative, not ").concat(t)}function GC(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function qC(e,t){const n=vu(e),a=vu(t);return"Input to reshape is a SparseTensor with ".concat(n,"\n  dense values, but the requested shape requires a multiple of ").concat(a,". inputShape=").concat(e," outputShape= ").concat(t)}function KC(e,t){const n=vu(e),a=vu(t);return"Input to reshape is a tensor with ".concat(n," dense values, but the requested shape has ").concat(a,". inputShape=").concat(e," outputShape=").concat(t)}function XC(){return"segment ids must be >= 0"}function YC(){return"segment ids are not increasing"}function QC(e,t){return"Segment id ".concat(e," out of range [0, ").concat(t,"), possibly because segmentIds input is not sorted.")}function ZC(e,t,n){return"Bad: indices[".concat(e,"] == ").concat(t," out of range [0, ").concat(n,")")}function JC(e,t){let n,a=!1;for(e<=sC?(n=e,a=!0):n=zu(e,Math.floor(Math.sqrt(e)));!a;)n>t||n===e?a=!0:n=zu(e,n+1);return n}function $C(e,t,n){const a=[],s=e.length;for(let r=0;r<s;r++)r!==t?a.push(e[r]):a.push(n);return a}function eI(e,t,n,a){const s=t.shape.length,r=e.shape.length;if(0!==a&&(a<-s||a>s))throw new Error("Expect batchDims in the range of [-".concat(s,", ").concat(s,"], but got ").concat(a));if(a<0&&(a+=s),a>r)throw new Error("batchDims (".concat(a,") must be less than rank(x) (\n    ").concat(r,")."));if(n<a)throw new Error("batchDims (".concat(a,") must be less than or equal to axis (").concat(n,")."));for(let h=0;h<a;++h)if(e.shape[h]!==t.shape[h])throw new Error("x.shape[".concat(h,"]: ").concat(e.shape[h]," should be equal to indices.shape[").concat(h,"]: ").concat(t.shape[h],"."));const i=e.shape[n],o=[];let c=1,l=1,u=1;for(let h=0;h<a;++h)o.push(e.shape[h]),c*=e.shape[h];for(let h=a;h<n;h++)o.push(e.shape[h]),l*=e.shape[h];for(let h=a;h<s;h++)o.push(t.shape[h]);for(let h=n+1;h<r;h++)o.push(e.shape[h]),u*=e.shape[h];return{batchSize:c,sliceSize:u,outerSize:l,dimSize:i,outputShape:o}}function tI(e){try{return e.map(e=>Gf(e))}catch(q5){throw new Error("Failed to decode encoded string bytes into utf-8, error: ".concat(q5))}}function nI(e){return e.map(e=>Hf(e))}!function(){for(const e of Oy)by(e)}();const aI={kernelName:sh,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>cy(e,ak(ny(n,"float32"),-1))}}},sI={kernelName:rh,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=uy(ny(n,"float32")),a=ly(Cy(py(1),t));return Rv(oy(e,a))}}}},rI={kernelName:ih,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=ly(Cy(uy(ny(n,"float32")),1));return oy(e,t)}}}},iI={kernelName:oh,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,s=Ry(n.shape,a.shape);return{a:()=>{let t=e;const a=Ey(n.shape,s);return a.length>0&&(t=rv(t,a)),tx(t,n.shape)},b:()=>{let t=e;const n=Ey(a.shape,s);return n.length>0&&(t=rv(t,n)),tx(t,a.shape)}}}},oI={kernelName:ch,saveAllInputs:!0,gradFunc:(e,t)=>{const n={};return t.forEach((t,a)=>{n[a]=()=>e.clone()}),n}},cI={kernelName:hh,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>hy(n)}}},lI={kernelName:dh,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>hy(n)}}},uI={kernelName:ph,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>oy(e,ly(Cy(py(1),uy(ny(n,"float32")))))}}},hI={kernelName:fh,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=ly(ry(py(1),uy(ny(n,"float32"))));return oy(e,t)}}}},dI={kernelName:yh,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,s=Ry(n.shape,a.shape);return{a:()=>{const t=ry(uy(n),uy(a));let r=cy(e,oy(a,t));const i=Ey(n.shape,s);return i.length>0&&(r=rv(r,i)),tx(r,n.shape)},b:()=>{const t=ry(uy(n),uy(a));let r=Rv(cy(e,oy(n,t)));const i=Ey(a.shape,s);return i.length>0&&(r=rv(r,i)),tx(r,a.shape)}}}},pI={kernelName:mh,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>oy(e,ry(uy(ny(n,"float32")),1))}}},fI={kernelName:gh,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>oy(e,Cy(py(1),uy(ny(n,"float32"))))}}};const mI=Bm({avgPool3dGrad_:function(e,t,n,a,s,r){const i=Fm(e,"dy","avgPool3dGrad"),o=Fm(t,"input","avgPool3dGrad");let c=i,l=o,u=!1;4===o.rank&&(u=!0,c=tx(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),l=tx(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),yu(5===c.rank,()=>"Error in avgPool3dGrad: dy must be rank 5 but got rank "+"".concat(c.rank,".")),yu(5===l.rank,()=>"Error in avgPool3dGrad: input must be rank 5 but got rank "+"".concat(l.rank,".")),ex("avgPool3dGrad",s,r);const h={dy:c,input:l},d={filterSize:n,strides:a,pad:s,dimRoundingMode:r},p=Tm.runKernel(wh,h,d);return u?tx(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}}),gI={kernelName:vh,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{filterSize:s,strides:r,pad:i,dimRoundingMode:o}=n;return{x:()=>mI(e,a,s,r,i,o)}}};const yI=Bm({avgPoolGrad_:function(e,t,n,a,s){const r=Fm(e,"dy","avgPoolGrad"),i=Fm(t,"input","avgPoolGrad");yu(i.rank===r.rank,()=>"Rank of input (".concat(i.rank,") does not match rank of dy (").concat(r.rank,")"));let o=i,c=r,l=!1;3===i.rank&&(l=!0,o=tx(i,[1,i.shape[0],i.shape[1],i.shape[2]]),c=tx(r,[1,r.shape[0],r.shape[1],r.shape[2]])),yu(4===c.rank,()=>"Error in avgPoolGrad: dy must be rank 4 but got rank "+"".concat(c.rank,".")),yu(4===o.rank,()=>"Error in avgPoolGrad: input must be rank 4 but got rank "+"".concat(o.rank,"."));const u={dy:c,input:o},h={filterSize:n,strides:a,pad:s},d=Tm.runKernel(xh,u,h);return l?tx(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),bI={kernelName:bh,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{filterSize:s,strides:r,pad:i}=n;return{x:()=>yI(e,a,s,r,i)}}},xI={kernelName:kh,inputsToSave:["a","b"],gradFunc:(e,t,n)=>{const[a,s]=t,{transposeA:r,transposeB:i}=n;return r||i?!r&&i?{a:()=>rx(e,s,!1,!1),b:()=>rx(e,a,!0,!1)}:r&&!i?{a:()=>rx(s,e,!1,!0),b:()=>rx(a,e,!1,!1)}:{a:()=>rx(s,e,!0,!0),b:()=>rx(e,a,!0,!0)}:{a:()=>rx(e,s,!1,!0),b:()=>rx(a,e,!0,!1)}}},vI={kernelName:Sh,gradFunc:(e,t,n)=>{const{blockShape:a,crops:s}=n;return{x:()=>lw(e,a,s)}}},wI={kernelName:"BroadcastTo",gradFunc:(e,t,n)=>{const a=n,s=a.inputShape,r=a.shape,i=Array.from(r);for(let c=s.length-1;c>=0;c--)if(s[c]===r[c])i[c]=1;else if(1!==s[c])throw new Error("broadcastTo(): [".concat(s,"] cannot be broadcast to [").concat(r,"]."));const o=[];for(let c=0;c<i.length;c++)i[c]>1&&o.push(c);return{x:()=>rv(e,o,!0)}}},kI={kernelName:Th,gradFunc:e=>({x:()=>e.clone()})},SI={kernelName:Eh,gradFunc:e=>({x:()=>hy(e)})},CI={kernelName:Rh,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{clipValueMin:s,clipValueMax:r}=n;return{x:()=>Vx(Dv(yv(a,s),Cv(a,r)),e,hy(e))}}},II={kernelName:Ah,inputsToSave:["x"],gradFunc:aI.gradFunc},NI={kernelName:Mh,saveAllInputs:!0,gradFunc:(e,t,n)=>{const a=t.map(e=>e.shape),{axis:s}=n,r=Eu(s,t[0].shape)[0],i=a.map(e=>e[r]);return Jw(e,i,r).map(e=>()=>e)}},TI={kernelName:Ph,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[a,s]=t,{dilations:r,strides:i,pad:o,dataFormat:c}=n;return yu(Qb(r),()=>"Error in gradient of conv2D: dilation rates greater than 1 "+"are not yet supported in gradients. Got dilations '".concat(r,"'")),{x:()=>Tx(a.shape,e,s,i,o,c),filter:()=>Dk(a,e,s.shape,i,o,c)}}},EI={kernelName:Oh,inputsToSave:["dy","filter"],gradFunc:(e,t,n)=>{const[a,s]=t,{strides:r,pad:i,dataFormat:o,dimRoundingMode:c}=n;return{dy:()=>Ix(e,s,r,i,o,1,c),filter:()=>Dk(e,a,s.shape,r,i,o,c)}}};const RI=Bm({conv3DBackpropFilter_:function(e,t,n,a,s){let r=e;4===e.rank&&(r=tx(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let i=t;4===i.rank&&(i=tx(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),yu(5===r.rank,()=>"Error in conv3dDerFilter: input must be rank 5, but got shape "+"".concat(r.shape,".")),yu(5===i.rank,()=>"Error in conv3dDerFilter: dy must be rank 5, but got shape "+"".concat(i.shape,".")),yu(5===n.length,()=>"Error in conv3dDerFilter: filterShape must be length 5, but got "+"".concat(n,".")),yu(r.shape[4]===n[3],()=>"Error in conv3dDerFilter: depth of input ".concat(r.shape[4],") must ")+"match input depth in filter (".concat(n[3],".")),yu(i.shape[4]===n[4],()=>"Error in conv3dDerFilter: depth of dy (".concat(i.shape[4],") must ")+"match output depth for filter (".concat(n[4],")."));const o={x:r,dy:i},c={strides:a,pad:s,filterShape:n};return Tm.runKernel(Lh,o,c)}}),_I={kernelName:Fh,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:a,strides:s,pad:r}=n;yu(Qb(a),()=>"Error in gradient of conv3D: dilation rates greater than 1 are "+"not yet supported in gradients. Got dilations '".concat(a,"'"));const[i,o]=t;return{x:()=>_x(i.shape,e,o,s,r),filter:()=>RI(i,e,o.shape,s,r)}}},AI={kernelName:Bh,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>cy(Rv(Vw(ny(n,"float32"))),e)}}},MI={kernelName:jh,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>cy(Uw(ny(n,"float32")),e)}}},PI={kernelName:Vh,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{axis:s,exclusive:r,reverse:i}=n;return{x:()=>{const t=ev([s],a.rank);let n=Ox(e,s,r,!i);return null!=t&&(n=Ik(n,t)),n}}}},DI={kernelName:qh,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:a,strides:s,pad:r,dimRoundingMode:i}=n,o=null==a?[1,1]:a;yu(Qb(o),()=>"Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations "+"'".concat(o,"'"));const[c,l]=t;return yu(4===c.rank,()=>"Error in gradient of depthwiseConv2dNative: input must be "+"rank 4, but got rank ".concat(c.rank,".")),yu(4===l.rank,()=>"Error in gradient of depthwiseConv2dNative: filter must be "+"rank 4, but got rank ".concat(l.rank,".")),yu(c.shape[3]===l.shape[2],()=>"Error in gradient of depthwiseConv2d: number of input "+"channels (".concat(c.shape[3],") must match the inChannels dimension ")+"in filter ".concat(l.shape[2],".")),yu(Zb(s,o),()=>"Error in gradient of depthwiseConv2d: Either strides or "+"dilations must be  1. Got strides ".concat(s," and dilations ")+"'".concat(o,"'.")),ex("depthwiseConv2d",r,i),{x:()=>Wk(c.shape,e,l,s,r,o,i),filter:()=>jk(c,e,l.shape,s,r,o,i)}}},OI={kernelName:Qh,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[a,s]=t,r={x:a,filter:s,dy:e},i={x:a,filter:s,dy:e};return{x:()=>Tm.runKernel(Zh,r,n),filter:()=>Tm.runKernel(Jh,i,n)}}},FI={kernelName:nd,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t,a={dy:e,y:n};return{x:()=>Tm.runKernel(ad,a)}}},LI={kernelName:sd,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,a=cy(lv(Rv(uy(n))),2/Math.sqrt(Math.PI));return{x:()=>cy(e,a)}}},zI={kernelName:id,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>cy(e,n)}}},BI={kernelName:od,inputsToSave:["input"],gradFunc:(e,t)=>{const[n]=t;return{input:()=>tx(e,n.shape)}}},jI={kernelName:cd,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>cy(e,lv(n))}}},WI={kernelName:dd,gradFunc:e=>({x:()=>hy(e)})},VI={kernelName:pd,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,s=Ry(n.shape,a.shape);return{a:()=>{const t=oy(e,ny(a,"float32")),r=Ey(n.shape,s);return r.length>0?tx(rv(t,r),n.shape):t},b:()=>{let t=cy(e,ny(n,"float32"));const r=Ey(a.shape,s);r.length>0&&(t=tx(rv(t,r),a.shape));const i=uy(a);return Rv(oy(t,ny(i,"float32")))}}}},UI={kernelName:fd,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,n)=>{const{varianceEpsilon:a}=n,[s,r,i,o]=t,c=null==o?py(1):o,l=Ey(r.shape,s.shape),u=[];if(1===r.rank){for(let e=0;e<s.shape.length-1;++e)u.push(s.shape[e]);u.push(1)}const h=Cy(s,r),d=cy(e,c),p=Lw(ry(i,py(a))),f=cy(cy(cy(p,p),p),py(-.5));return{x:()=>1===r.rank?tx(cy(cy(e,dv(tx(p,[1,1,1,r.shape[0]]),u)),c),s.shape):tx(cy(cy(e,p),c),s.shape),mean:()=>{let e=cy(cy(p,py(-1)),d);return 1===r.rank&&(e=rv(e,l)),tx(e,r.shape)},variance:()=>{let e=cy(cy(f,h),d);return 1===r.rank&&(e=rv(e,l)),tx(e,r.shape)},scale:()=>{const t=cy(h,p);let n=cy(e,t);return 1===r.rank&&(n=rv(n,l)),tx(n,r.shape)},offset:()=>{let t=e;return 1===r.rank&&(t=rv(t,l)),tx(t,r.shape)}}}},HI={kernelName:md,inputsToSave:["x","indices"],gradFunc:(e,t,n)=>{const[a,s]=t,{axis:r,batchDims:i}=n,o=Eu(r,a.shape)[0],c=(e,t,n)=>()=>{const a=e.shape,s=t.size,i=a.slice(0,o),c=i.length,l=a.slice(r,a.length).slice(1),u=l.length,h=GI(0,c),d=GI(c+1,c+1+u),p=qI([i,[s],l]),f=tx(n,p),m=tx(t,[s]),g=qI([[c],h,d]),y=Ik(f,g);let b=bk(y,m,e.shape[o]);const x=tv(g);return b=Ik(b,x),b};if(1===i){const t=a.shape[0],n=a.split(t,0);return{x:()=>{const t=nk(n.map((t,n)=>c(t,s.slice(n,1),e.slice(n,1))()));return t.reshape(a.shape)},indices:()=>s}}return{x:c(a,s,e),indices:()=>s}}};function GI(e,t){const n=[];for(let a=e;a<t;++a)n.push(a);return n}function qI(e){const t=[];for(let n=0;n<e.length;++n)for(let a=0;a<e[n].length;++a)t.push(e[n][a]);return t}const KI={kernelName:bd,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t;return{a:()=>hy(n),b:()=>hy(a)}}},XI={kernelName:xd,gradFunc:e=>({x:()=>ny(e,"float32")})},YI={kernelName:kd,gradFunc:e=>({x:()=>hy(e)})},QI={kernelName:Sd,gradFunc:e=>({x:()=>hy(e)})},ZI={kernelName:Cd,gradFunc:e=>({x:()=>hy(e)})},JI={kernelName:Id,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{alpha:s}=n,r=gv(a,0);return{x:()=>Vx(r,e,cy(e,s))}}},$I={kernelName:_d,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>oy(e,ry(n,1))}}},eN={kernelName:Rd,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>oy(e,ny(n,"float32"))}}},tN={kernelName:"LogSoftmax",inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[a]=t,{axis:s}=n;return{logits:()=>{const t=lv(a);return Cy(e,cy(rv(e,s,!0),t))}}}};const nN=Bm({localResponseNormalizationBackprop_:function(e,t,n){const a={x:e,y:t,dy:n},s={depthRadius:arguments.length>3&&void 0!==arguments[3]?arguments[3]:5,bias:arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,alpha:arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,beta:arguments.length>6&&void 0!==arguments[6]?arguments[6]:.5};return Tm.runKernel(Od,a,s)}}),aN={kernelName:Dd,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[a,s]=t,{depthRadius:r,bias:i,alpha:o,beta:c}=n;return{x:()=>nN(a,s,e,r,i,o,c)}}};function sN(e,t,n,a){return t.rank<n.rank&&(t=tx(t,Jx(t.shape,a))),e.rank<n.rank&&(e=tx(e,Jx(e.shape,a))),{x:()=>cy(e,ny(Wx(n,t),e.dtype))}}const rN={kernelName:Fd,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const a=n,{reductionIndices:s}=a,r=t[0],i=sN(e,t[1],r,Eu(s,r.shape));return{x:()=>i.x()}}},iN={kernelName:Ld,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t;return{a:()=>cy(e,ny(yv(n,a),"float32")),b:()=>cy(e,ny(Sv(n,a),"float32"))}}};const oN=Bm({maxPool3dGrad_:function(e,t,n,a,s,r,i){const o=Fm(e,"dy","maxPool3dGrad"),c=Fm(t,"input","maxPool3dGrad"),l=Fm(n,"output","maxPool3dGrad");let u=o,h=c,d=l,p=!1;4===c.rank&&(p=!0,u=tx(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),h=tx(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]]),d=tx(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]])),yu(5===u.rank,()=>"Error in maxPool3dGrad: dy must be rank 5 but got rank "+"".concat(u.rank,".")),yu(5===h.rank,()=>"Error in maxPool3dGrad: input must be rank 5 but got rank "+"".concat(h.rank,".")),yu(5===d.rank,()=>"Error in maxPool3dGrad: output must be rank 5 but got rank "+"".concat(d.rank,".")),ex("maxPool3dGrad",r,i);const f={dy:u,input:h,output:d},m={filterSize:a,strides:s,pad:r,dimRoundingMode:i},g=Tm.runKernel(Wd,f,m);return p?tx(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}}),cN={kernelName:jd,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[a,s]=t,{filterSize:r,strides:i,pad:o,dimRoundingMode:c}=n;return{x:()=>oN(e,a,s,r,i,o,c)}}};const lN=Bm({maxPoolGrad_:function(e,t,n,a,s,r,i){const o=Fm(e,"dy","maxPoolGrad"),c=Fm(t,"input","maxPoolGrad"),l=Fm(n,"output","maxPoolGrad");yu(c.rank===o.rank,()=>"Rank of input (".concat(c.rank,") does not match rank of dy ")+"(".concat(o.rank,")")),yu(4===o.rank,()=>"Error in maxPoolGrad: dy must be rank 4 but got rank "+"".concat(o.rank,".")),yu(4===c.rank,()=>"Error in maxPoolGrad: input must be rank 4 but got rank "+"".concat(c.rank,".")),ex("maxPoolGrad",r,i);const u={dy:o,input:c,output:l},h={filterSize:a,strides:s,pad:r,dimRoundingMode:i};return Tm.runKernel(Bd,u,h)}}),uN={kernelName:zd,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[a,s]=t,{filterSize:r,strides:i,pad:o}=n;return{x:()=>lN(e,a,s,r,i,o)}}},hN={kernelName:qd,inputsToSave:["x"],gradFunc:(e,t,n)=>{const a=t[0],{paddings:s}=n,r=s.map(e=>e[0]);return{x:()=>ox(e,r,a.shape)}}},dN={kernelName:ap,saveAllInputs:!0,gradFunc:(e,t,n)=>{const{axis:a}=n;return xk(e,a).map(e=>()=>e)}},pN={kernelName:sp,inputsToSave:["x"],gradFunc:(e,t,n)=>{const a=t[0],{paddings:s}=n,r=s.map(e=>e[0]);return{x:()=>ox(e,r,a.shape)}}},fN={kernelName:rp,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{const[n,a,s]=t,r=n,i=a,o=Ry(r.shape,i.shape);return{a:()=>{const t=ny(i,"float32");let n=cy(e,cy(t,Sy(r,Cy(t,py(1)))));const a=Ey(r.shape,o);return a.length>0&&(n=rv(n,a)),tx(n,r.shape)},b:()=>{const t=gv(r,0),n=Vx(t,Tv(r),hy(r));let a=cy(e,cy(s,n));const c=Ey(i.shape,o);return c.length>0&&(a=rv(a,c)),tx(a,i.shape)}}}},mN={kernelName:ip,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{const[n,a]=t,s=gv(n,0);return{x:()=>Vx(s,e,cy(e,a)),alpha:()=>{let t=Vx(s,hy(e),cy(e,n));const r=Ey(a.shape,e.shape);return r.length>0&&(t=rv(t,r)),tx(t,a.shape)}}}};function gN(e,t,n){const a=e.shape.length,s=a-n.length,r=ev(n,a);let i=e;null!=r&&(i=Ik(e,r));const o=i.shape.slice(),c=o.splice(a-n.length,n.length).reduce((e,t)=>e*t,1);o.push(c);let l=function(e,t,n){const a=e.shape.slice();a[n]=1;const s=tx(t,a),r=Dx(e,n,!0,!1),i=Dx(e,n,!0,!0),o=cy(r,i);return cy(s,o)}(i.reshape(o),t,s);if(l=l.reshape(i.shape),null!=r){const e=tv(r);l=Ik(l,e)}return l}const yN={kernelName:Ep,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=gv(n,py(0)),a=py(pC),s=py(fC),r=cy(e,s),i=cy(cy(e,a),lv(ny(n,"float32")));return Vx(t,r,i)}}}},bN={kernelName:Lp,gradFunc:(e,t,n)=>{const{blockShape:a,paddings:s}=n;return{x:()=>ux(e,a,s)}}},xN={kernelName:zp,gradFunc:(e,t,n)=>{const{axis:a}=n;return{x:()=>sx(e,a)}}},vN={kernelName:tf,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{reps:s}=n;return{x:()=>{let t=hy(a);if(1===a.rank)for(let n=0;n<s[0];++n)t=ry(t,ox(e,[n*a.shape[0]],[a.shape[0]]));else if(2===a.rank)for(let n=0;n<s[0];++n)for(let r=0;r<s[1];++r)t=ry(t,ox(e,[n*a.shape[0],r*a.shape[1]],[a.shape[0],a.shape[1]]));else if(3===a.rank)for(let n=0;n<s[0];++n)for(let r=0;r<s[1];++r)for(let i=0;i<s[2];++i)t=ry(t,ox(e,[n*a.shape[0],r*a.shape[1],i*a.shape[2]],[a.shape[0],a.shape[1],a.shape[2]]));else{if(4!==a.rank)throw new Error("Gradient for tile operation is not implemented for rank-"+"".concat(a.rank," tensors yet."));for(let n=0;n<s[0];++n)for(let r=0;r<s[1];++r)for(let i=0;i<s[2];++i)for(let o=0;o<s[3];++o)t=ry(t,ox(e,[n*a.shape[0],r*a.shape[1],i*a.shape[2],o*a.shape[3]],[a.shape[0],a.shape[1],a.shape[2],a.shape[3]]))}return t}}}};const wN=[aI,sI,rI,iI,oI,cI,lI,uI,hI,dI,pI,fI,gI,bI,xI,vI,wI,kI,SI,CI,II,NI,EI,TI,_I,AI,MI,PI,DI,OI,{kernelName:ed,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,s=Ry(n.shape,a.shape);return{a:()=>{const t=oy(e,ny(a,"float32")),r=Ey(n.shape,s);return r.length>0?tx(rv(t,r),n.shape):t},b:()=>{let t=cy(e,ny(n,"float32"));const r=Ey(a.shape,s);r.length>0&&(t=tx(rv(t,r),a.shape));const i=uy(a);return Rv(oy(t,ny(i,"float32")))}}}},FI,LI,zI,BI,jI,VI,WI,UI,HI,KI,XI,YI,QI,ZI,JI,$I,eN,tN,aN,rN,rN,iN,cN,uN,{kernelName:Ud,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{axis:s}=n,r=Eu(s,a.shape),i=vu(Zx(a.shape,r)[1]);return{x:()=>{const t=a.shape.slice();r.forEach(e=>{t[e]=1});const n=tx(e,t);return oy(cy(n,qv(a.shape,"float32")),i)}}}},{kernelName:Hd,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const a=n,{axis:s}=a,[r,i]=t,o=sN(e,i,r,Eu(s,r.shape));return{x:()=>o.x()}}},{kernelName:Gd,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t;return{a:()=>cy(e,ny(Cv(n,a),"float32")),b:()=>cy(e,ny(gv(n,a),"float32"))}}},hN,{kernelName:Kd,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,s=Ry(n.shape,a.shape);return{a:()=>{const t=Ey(n.shape,s);return t.length>0?tx(rv(e,t),n.shape):e},b:()=>{const t=cy(e,Rv(fv(oy(n,a)))),r=Ey(a.shape,s);return r.length>0?tx(rv(t,r),a.shape):t}}}},{kernelName:Yd,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,s=Ry(n.shape,a.shape);return{a:()=>{const t=cy(e,ny(a,"float32")),r=Ey(n.shape,s);return r.length>0?tx(rv(t,r),n.shape):t},b:()=>{const t=cy(e,ny(n,"float32")),r=Ey(a.shape,s);return r.length>0?tx(rv(t,r),a.shape):t}}}},{kernelName:Qd,gradFunc:e=>({x:()=>Rv(e)})},{kernelName:np,inputsToSave:["indices"],gradFunc:(e,t)=>{const n=t[0];return{indices:()=>Gv(n.shape,"float32")}}},{kernelName:tp,gradFunc:e=>({x:()=>hy(e)})},dN,pN,pN,fN,mN,{kernelName:op,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{axis:s}=n;let r=[];return r=void 0===s||null===s?a.shape.map((e,t)=>t):"number"===typeof s?[s]:s,{x:()=>gN(a,e,r)}}},{kernelName:pp,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>oy(e,Rv(uy(n)))}}},{kernelName:vp,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,a=cy(Cv(n,6),ak(n));return{x:()=>cy(e,ny(a,"float32"))}}},{kernelName:fp,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>cy(e,ny(ak(n),"float32"))}}},{kernelName:mp,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>tx(e,n.shape)}}},{kernelName:bp,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[a]=t,s={dy:e,images:a};return{images:()=>Tm.runKernel(xp,s,n)}}},{kernelName:gp,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[a]=t,s={dy:e,images:a};return{images:()=>Tm.runKernel(yp,s,n)}}},{kernelName:wp,gradFunc:(e,t,n)=>{const{dims:a}=n,s=Eu(a,e.shape);return{x:()=>Aw(e,s)}}},{kernelName:kp,gradFunc:e=>({x:()=>hy(e)})},{kernelName:Sp,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Rv(oy(e,cy(Sy(n,1.5),2)))}}},{kernelName:Tp,inputsToSave:["condition"],gradFunc:(e,t)=>{const[n]=t;return{condition:()=>ny(hy(n),"float32"),t:()=>cy(e,ny(n,e.dtype)),e:()=>cy(e,ny(Ov(n),e.dtype))}}},yN,{kernelName:Pp,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>cy(e,cy(n,Cy(py(1),n)))}}},{kernelName:Mp,gradFunc:e=>({x:()=>hy(e)})},{kernelName:_p,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>cy(Mx(ny(n,"float32")),e)}}},{kernelName:Ap,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>cy(Px(ny(n,"float32")),e)}}},{kernelName:Rp,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{begin:s,size:r}=n,i=a.shape,[o,c]=Ib(a,s,r),l=[];for(let u=0;u<e.rank;u++)l.push([o[u],i[u]-o[u]-c[u]]);return{x:()=>sw(e,l)}}},{kernelName:Bp,outputsToSave:[!0],gradFunc:(e,t,n)=>{const[a]=t,{dim:s}=n,r=cy(e,a);return{logits:()=>Cy(r,cy(rv(r,[s],true),a))}}},{kernelName:Dp,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>cy(e,ix(n))}}},bN,bN,xN,xN,{kernelName:Op,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>oy(e,cy(ly(ny(n,"float32")),2))}}},{kernelName:Gp,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,s=py(2);return{a:()=>cy(e,cy(s,Cy(n,a))),b:()=>cy(e,cy(s,Cy(a,n)))}}},{kernelName:qp,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>cy(e,cy(ny(n,"float32"),2))}}},{kernelName:uf,gradFunc:e=>({x:()=>hy(e)})},{kernelName:Jp,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,s=Ry(n.shape,a.shape);return{a:()=>{let t=e;const a=Ey(n.shape,s);return a.length>0&&(t=rv(t,a)),tx(t,n.shape)},b:()=>{let t=e;const n=Ey(a.shape,s);return n.length>0&&(t=rv(t,n)),tx(Rv(t),a.shape)}}}},{kernelName:Fp,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,s=a.shape.slice(),{axis:r}=n;Eu(r,a.shape).forEach(e=>{s[e]=1});const i=tx(e,s),o=cy(i,qv(a.shape,"float32"));return{x:()=>o}}},{kernelName:$p,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>oy(e,uy(Mx(n)))}}},{kernelName:ef,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>cy(Cy(py(1),uy(n)),e)}}},vN,{kernelName:sf,gradFunc:(e,t,n)=>{const a=n,{perm:s}=a,r=tv(s);return{x:()=>Ik(e,r)}}},{kernelName:of,gradFunc:(e,t,n)=>{const a=n,{axis:s}=a;return{value:()=>nk(e,s)}}},{kernelName:cf,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>function(e,t){const n=_y(t,hy(t)),a=mv(e,n);let s=yv(t,py(0,"int32"));const r=a.rank-s.rank;for(let o=0;o<r;++o)s=uv(s,o+1);s=Dv(s,qv(a.shape,"bool"));const i=hy(a);return Vx(s,a,i)}(e,n)}}},{kernelName:lf,gradFunc:e=>({x:()=>hy(e)})}];for(const n of wN)Cf(n);om().prototype.abs=function(){return this.throwIfDisposed(),Ny(this)},om().prototype.acos=function(){return this.throwIfDisposed(),Eb(this)},om().prototype.acosh=function(){return this.throwIfDisposed(),Rb(this)},om().prototype.add=function(e){return this.throwIfDisposed(),ry(this,e)},om().prototype.all=function(e,t){return this.throwIfDisposed(),Ab(this,e,t)},om().prototype.any=function(e,t){return this.throwIfDisposed(),Mb(this,e,t)},om().prototype.argMax=function(e){return this.throwIfDisposed(),Pb(this,e)},om().prototype.argMin=function(e){return this.throwIfDisposed(),Db(this,e)},om().prototype.asScalar=function(){return this.throwIfDisposed(),yu(1===this.size,()=>"The array must have only 1 element."),tx(this,[])},om().prototype.asType=function(e){return this.throwIfDisposed(),ny(this,e)},om().prototype.as1D=function(){return this.throwIfDisposed(),tx(this,[this.size])},om().prototype.as2D=function(e,t){return this.throwIfDisposed(),tx(this,[e,t])},om().prototype.as3D=function(e,t,n){return this.throwIfDisposed(),tx(this,[e,t,n])},om().prototype.as4D=function(e,t,n,a){return this.throwIfDisposed(),tx(this,[e,t,n,a])},om().prototype.as5D=function(e,t,n,a,s){return this.throwIfDisposed(),tx(this,[e,t,n,a,s])},om().prototype.asin=function(){return this.throwIfDisposed(),Ob(this)},om().prototype.asinh=function(){return this.throwIfDisposed(),Fb(this)},om().prototype.atan=function(){return this.throwIfDisposed(),Lb(this)},om().prototype.atan2=function(e){return this.throwIfDisposed(),zb(this,e)},om().prototype.atanh=function(){return this.throwIfDisposed(),Bb(this)},om().prototype.avgPool=function(e,t,n,a){return this.throwIfDisposed(),nx(this,e,t,n,a)},om().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),ux(this,e,t)},om().prototype.batchNorm=function(e,t,n,a,s){return this.throwIfDisposed(),hx(this,e,t,n,a,s)},om().prototype.broadcastTo=function(e){return this.throwIfDisposed(),bx(this,e)},om().prototype.cast=function(e){return this.throwIfDisposed(),ny(this,e)},om().prototype.ceil=function(){return this.throwIfDisposed(),xx(this)},om().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),vx(this,e,t)},om().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof im&&(e=[e]),sx([this,...e],t)},om().prototype.conv1d=function(e,t,n,a,s,r){return this.throwIfDisposed(),Nx(this,e,t,n,a,s,r)},om().prototype.conv2dTranspose=function(e,t,n,a,s){return this.throwIfDisposed(),Ex(this,e,t,n,a,s)},om().prototype.conv2d=function(e,t,n,a,s,r){return this.throwIfDisposed(),Ix(this,e,t,n,a,s,r)},om().prototype.cos=function(){return this.throwIfDisposed(),Mx(this)},om().prototype.cosh=function(){return this.throwIfDisposed(),Px(this)},om().prototype.cumprod=function(e,t,n){return this.throwIfDisposed(),Dx(this,e,t,n)},om().prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),Ox(this,e,t,n)},om().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),Lx(this,e,t)},om().prototype.depthwiseConv2d=function(e,t,n,a,s,r){return this.throwIfDisposed(),zx(this,e,t,n,a,s,r)},om().prototype.dilation2d=function(e,t,n,a,s){return this.throwIfDisposed(),jx(this,e,t,n,a,s)},om().prototype.divNoNan=function(e){return this.throwIfDisposed(),Ux(this,e)},om().prototype.div=function(e){return this.throwIfDisposed(),oy(this,e)},om().prototype.dot=function(e){return this.throwIfDisposed(),Hx(this,e)},om().prototype.elu=function(){return this.throwIfDisposed(),qx(this)},om().prototype.equal=function(e){return this.throwIfDisposed(),Wx(this,e)},om().prototype.erf=function(){return this.throwIfDisposed(),Xx(this)},om().prototype.euclideanNorm=function(e,t){return this.throwIfDisposed(),cv(this,e,t)},om().prototype.exp=function(){return this.throwIfDisposed(),lv(this)},om().prototype.expandDims=function(e){return this.throwIfDisposed(),uv(this,e)},om().prototype.expm1=function(){return this.throwIfDisposed(),hv(this)},om().prototype.fft=function(){return this.throwIfDisposed(),Yw(this)},om().prototype.flatten=function(){return this.throwIfDisposed(),tx(this,[this.size])},om().prototype.floor=function(){return this.throwIfDisposed(),fv(this)},om().prototype.floorDiv=function(e){return this.throwIfDisposed(),iy(this,e)},om().prototype.gather=function(e,t,n){return this.throwIfDisposed(),mv(this,e,t,n)},om().prototype.greaterEqual=function(e){return this.throwIfDisposed(),yv(this,e)},om().prototype.greater=function(e){return this.throwIfDisposed(),gv(this,e)},om().prototype.ifft=function(){return this.throwIfDisposed(),Qw(this)},om().prototype.irfft=function(){return this.throwIfDisposed(),Zw(this)},om().prototype.isFinite=function(){return this.throwIfDisposed(),xv(this)},om().prototype.isInf=function(){return this.throwIfDisposed(),vv(this)},om().prototype.isNaN=function(){return this.throwIfDisposed(),wv(this)},om().prototype.leakyRelu=function(e){return this.throwIfDisposed(),kv(this,e)},om().prototype.lessEqual=function(e){return this.throwIfDisposed(),Cv(this,e)},om().prototype.less=function(e){return this.throwIfDisposed(),Sv(this,e)},om().prototype.localResponseNormalization=function(e,t,n,a){return this.throwIfDisposed(),Nv(this,e,t,n,a)},om().prototype.logSigmoid=function(){return this.throwIfDisposed(),Av(this)},om().prototype.logSoftmax=function(e){return this.throwIfDisposed(),Mv(this,e)},om().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),Pv(this,e,t)},om().prototype.log=function(){return this.throwIfDisposed(),Tv(this)},om().prototype.log1p=function(){return this.throwIfDisposed(),Ev(this)},om().prototype.logicalAnd=function(e){return this.throwIfDisposed(),Dv(this,e)},om().prototype.logicalNot=function(){return this.throwIfDisposed(),Ov(this)},om().prototype.logicalOr=function(e){return this.throwIfDisposed(),Fv(this,e)},om().prototype.logicalXor=function(e){return this.throwIfDisposed(),Lv(this,e)},om().prototype.matMul=function(e,t,n){return this.throwIfDisposed(),rx(this,e,t,n)},om().prototype.maxPool=function(e,t,n,a){return this.throwIfDisposed(),Wv(this,e,t,n,a)},om().prototype.max=function(e,t){return this.throwIfDisposed(),av(this,e,t)},om().prototype.maximum=function(e){return this.throwIfDisposed(),_y(this,e)},om().prototype.mean=function(e,t){return this.throwIfDisposed(),Hv(this,e,t)},om().prototype.min=function(e,t){return this.throwIfDisposed(),sv(this,e,t)},om().prototype.minimum=function(e){return this.throwIfDisposed(),Xv(this,e)},om().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),Yv(this,e,t)},om().prototype.mod=function(e){return this.throwIfDisposed(),Qv(this,e)},om().prototype.mul=function(e){return this.throwIfDisposed(),cy(this,e)},om().prototype.neg=function(){return this.throwIfDisposed(),Rv(this)},om().prototype.norm=function(e,t,n){return this.throwIfDisposed(),ov(this,e,t,n)},om().prototype.notEqual=function(e){return this.throwIfDisposed(),ew(this,e)},om().prototype.oneHot=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return this.throwIfDisposed(),tw(this,e,t,n)},om().prototype.onesLike=function(){return this.throwIfDisposed(),nw(this)},om().prototype.pad=function(e,t){return this.throwIfDisposed(),sw(this,e,t)},om().prototype.pool=function(e,t,n,a,s,r){return this.throwIfDisposed(),uw(this,e,t,n,a,s,r)},om().prototype.pow=function(e){return this.throwIfDisposed(),Sy(this,e)},om().prototype.prelu=function(e){return this.throwIfDisposed(),hw(this,e)},om().prototype.prod=function(e,t){return this.throwIfDisposed(),dw(this,e,t)},om().prototype.reciprocal=function(){return this.throwIfDisposed(),Ew(this)},om().prototype.relu=function(){return this.throwIfDisposed(),Rw(this)},om().prototype.relu6=function(){return this.throwIfDisposed(),_w(this)},om().prototype.reshapeAs=function(e){return this.throwIfDisposed(),tx(this,e.shape)},om().prototype.reshape=function(e){return this.throwIfDisposed(),tx(this,e)},om().prototype.resizeBilinear=function(e,t,n){return this.throwIfDisposed(),mS(this,e,t,n)},om().prototype.resizeNearestNeighbor=function(e,t,n){return this.throwIfDisposed(),gS(this,e,t,n)},om().prototype.reverse=function(e){return this.throwIfDisposed(),Aw(this,e)},om().prototype.rfft=function(){return this.throwIfDisposed(),$w(this)},om().prototype.round=function(){return this.throwIfDisposed(),Fw(this)},om().prototype.rsqrt=function(){return this.throwIfDisposed(),Lw(this)},om().prototype.selu=function(){return this.throwIfDisposed(),zw(this)},om().prototype.separableConv2d=function(e,t,n,a,s,r){return this.throwIfDisposed(),Bw(this,e,t,n,a,s,r)},om().prototype.sigmoid=function(){return this.throwIfDisposed(),ix(this)},om().prototype.sign=function(){return this.throwIfDisposed(),Ww(this)},om().prototype.sin=function(){return this.throwIfDisposed(),Vw(this)},om().prototype.sinh=function(){return this.throwIfDisposed(),Uw(this)},om().prototype.slice=function(e,t){return this.throwIfDisposed(),ox(this,e,t)},om().prototype.softmax=function(e){return this.throwIfDisposed(),Xw(this,e)},om().prototype.softplus=function(){return this.throwIfDisposed(),_v(this)},om().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),lw(this,e,t)},om().prototype.split=function(e,t){return this.throwIfDisposed(),Jw(this,e,t)},om().prototype.sqrt=function(){return this.throwIfDisposed(),ly(this)},om().prototype.square=function(){return this.throwIfDisposed(),uy(this)},om().prototype.squaredDifference=function(e){return this.throwIfDisposed(),ek(this,e)},om().prototype.squeeze=function(e){return this.throwIfDisposed(),tk(this,e)},om().prototype.stack=function(e,t){this.throwIfDisposed();const n=e instanceof im?[this,e]:[this,...e];return nk(n,t)},om().prototype.step=function(e){return this.throwIfDisposed(),ak(this,e)},om().prototype.stridedSlice=function(e,t,n,a,s,r,i,o){return this.throwIfDisposed(),sk(this,e,t,n,a,s,r,i,o)},om().prototype.sub=function(e){return this.throwIfDisposed(),Cy(this,e)},om().prototype.sum=function(e,t){return this.throwIfDisposed(),rv(this,e,t)},om().prototype.tan=function(){return this.throwIfDisposed(),rk(this)},om().prototype.tanh=function(){return this.throwIfDisposed(),cx(this)},om().prototype.tile=function(e){return this.throwIfDisposed(),dv(this,e)},om().prototype.toBool=function(){return this.throwIfDisposed(),ny(this,"bool")},om().prototype.toFloat=function(){return this.throwIfDisposed(),ny(this,"float32")},om().prototype.toInt=function(){return this.throwIfDisposed(),ny(this,"int32")},om().prototype.topk=function(e,t){return this.throwIfDisposed(),mk(this,e,t)},om().prototype.transpose=function(e){return this.throwIfDisposed(),Ik(this,e)},om().prototype.unique=function(e){return this.throwIfDisposed(),yk(this,e)},om().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),bk(this,e,t)},om().prototype.unstack=function(e){return this.throwIfDisposed(),xk(this,e)},om().prototype.where=function(e,t){return this.throwIfDisposed(),Vx(e,this,t)},om().prototype.zerosLike=function(){return this.throwIfDisposed(),hy(this)};class kN extends Error{constructor(e){super(e),Object.setPrototypeOf(this,kN.prototype)}}class SN extends Error{constructor(e){super(e),Object.setPrototypeOf(this,SN.prototype)}}class CN extends Error{constructor(e){super(e),Object.setPrototypeOf(this,CN.prototype)}}class IN extends Error{constructor(e){super(e),Object.setPrototypeOf(this,IN.prototype)}}class NN extends Error{constructor(e){super(e),Object.setPrototypeOf(this,NN.prototype)}}Error;class TN{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){const e=this.cache.keys().next().value;this.cache.delete(e)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error("The maxEntries of LRU caches must be at least 0, but got ".concat(e,"."));if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){const e=this.cache.keys().next().value;this.cache.delete(e)}this.maxEntries=e}}function EN(e,t){if(Array.isArray(e)){let n=[];for(let a=0;a<t;a++)n=n.concat(e);return n}{const n=new Array(t);return n.fill(e),n}}function RN(e,t){if(!e)throw new NN(t)}function _N(e,t){let n=0;for(const a of e)a===t&&n++;return n}function AN(e){return 1===e.length?e[0]:e}function MN(e){return Array.isArray(e)?e:[e]}function PN(e){const t=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==t[0]?t:"private"+t}function DN(e){return e.length<=1||-1===e.indexOf("_")?e:e.replace(/[_]+(\w|$)/g,(e,t)=>t.toUpperCase())}let ON={};function FN(e){if(null===e||void 0===e)return null;const t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function LN(e){if(null!=e&&"object"===typeof e)if(Array.isArray(e))e.forEach(e=>LN(e));else{const t=Object.keys(e);for(const n of t){const t=e[n];null!=t&&"object"===typeof t&&(Array.isArray(t)||"ndarray"!==t.type||"number"!==typeof t.value?LN(t):e[n]=t.value)}}}function zN(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"object",s=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if("string"===typeof e){const s=e;let r;if(s in n)r=n[s];else if(s in ON)r=ON[s];else if(r=t[s],null==r)throw new CN("Unknown ".concat(a,": ").concat(e,". ")+"This may be due to one of the following reasons:\n"+"1. The ".concat(a," is defined in Python, in which ")+"case it needs to be ported to TensorFlow.js or your JavaScript code.\n"+"2. The custom ".concat(a," is defined in JavaScript, ")+"but is not registered properly with tf.serialization.registerClass().");return r}{const r=e;if(null==r.className||null==r.config)throw new CN("".concat(a,": Improper config format: ")+"".concat(JSON.stringify(r),".\n")+"'className' and 'config' must set.");const i=r.className;let o,c;if(i in n?[o,c]=n[i]:i in ON?[o,c]=ON.className:i in t&&([o,c]=t[i]),null==o)throw new CN("Unknown ".concat(a,": ").concat(i,". ")+"This may be due to one of the following reasons:\n"+"1. The ".concat(a," is defined in Python, in which ")+"case it needs to be ported to TensorFlow.js or your JavaScript code.\n"+"2. The custom ".concat(a," is defined in JavaScript, ")+"but is not registered properly with tf.serialization.registerClass().");if(null!=c){const e={};for(const n of Object.keys(ON))e[n]=ON[n];for(const s of Object.keys(n))e[s]=n[s];r.config.customObjects=e;const t=Object.assign({},ON);for(const s of Object.keys(n))ON[s]=n[s];LN(r.config);const a=c(o,r.config,n,s);return ON=Object.assign({},t),a}{const e=Object.assign({},ON);for(const a of Object.keys(n))ON[a]=n[a];const t=new o(r.config);return ON=Object.assign({},e),t}}}function BN(e,t){return-1*function(e,t){return e<t?-1:e>t?1:0}(e,t)}function jN(e){if(null==e)return e;const t=[];for(const n of e)-1===t.indexOf(n)&&t.push(n);return t}function WN(e){if(null==e)throw new CN("Invalid value in obj: ".concat(JSON.stringify(e)));for(const t in e)if(e.hasOwnProperty(t))return!1;return!0}function VN(e,t,n){if(null!=n&&e.indexOf(n)<0)throw new CN("".concat(n," is not a valid ").concat(t,".  Valid values are ").concat(e," or null/undefined."))}function UN(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1/0;return RN(n>=0),RN(a>=n),Array.isArray(e)&&e.length>=n&&e.length<=a&&e.every(e=>typeof e===t)}function HN(e,t){Array.isArray(e)?(yu(e.length>0,()=>"".concat(t," is unexpectedly an empty array.")),e.forEach((e,n)=>HN(e,"element ".concat(n+1," of ").concat(t)))):yu(Number.isInteger(e)&&e>0,()=>"Expected ".concat(t," to be a positive integer, but got ")+"".concat(GN(e),"."))}function GN(e){return null===e?"null":Array.isArray(e)?"["+e.map(e=>GN(e)).join(",")+"]":"string"===typeof e?'"'.concat(e,'"'):"".concat(e)}function qN(e){return"relu"===e?"relu":"linear"===e?"linear":"elu"===e?"elu":null}let KN=0;function XN(){return KN++}const YN={};function QN(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return e in YN||(YN[e]=0),YN[e]+=1,e+YN[e].toString()}const ZN=["channelsFirst","channelsLast"],JN=["nearest","bilinear"],$N=["valid","same","causal"],eT=["max","avg"],tT=["sum","mul","concat","ave"],nT=new Map;function aT(e){VN(ZN,"DataFormat",e)}function sT(e){VN($N,"PaddingMode",e)}function rT(e){VN(eT,"PoolMode",e)}const iT=[];function oT(e,t){iT.push(e);try{const e=t();return iT.pop(),e}catch(G5){throw iT.pop(),G5}}function cT(e){if(!hT(e))throw new Error("Not a valid tensor name: '"+e+"'");return(0===iT.length?"":iT.join("/")+"/")+e}function lT(e){if(!hT(e))throw new Error("Not a valid tensor name: '"+e+"'");nT.has(e)||nT.set(e,0);const t=nT.get(e);if(nT.set(e,nT.get(e)+1),t>0){const n="".concat(e,"_").concat(t);return nT.set(n,1),n}return e}const uT=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function hT(e){return!!e.match(uT)}function dT(e){return e===parseInt(e.toString(),10)}function pT(e,t,n){null==t&&(t=0),null==n&&(n=e.length);let a=1;for(let s=t;s<n;++s)a*=e[s];return a}function fT(e){if(0===e.length)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let n=0;n<e.length;n++){const a=e[n];a<t&&(t=a)}return t}function mT(e){if(0===e.length)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let n=0;n<e.length;n++){const a=e[n];a>t&&(t=a)}return t}function gT(e,t){if(t<e)throw new CN("end (".concat(t,") < begin (").concat(e,") is forbidden."));const n=[];for(let a=e;a<t;++a)n.push(a);return n}let yT;function bT(){return null==yT&&(yT=Jm().epsilon()),yT}function xT(e,t){return ny(e,t)}function vT(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),tx(e,n)}function wT(e,t,n){return Km(()=>{switch(e.rank){case 1:return Hw(e,t,n);case 2:return Gw(e,[t,0],[n,e.shape[1]]);case 3:return qw(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return Kw(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return ox(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return ox(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new CN("sliceAlongFirstAxis() received an unsupported tensor rank: "+"".concat(e.rank))}})}function kT(e,t,n){return Km(()=>{switch(e.rank){case 1:return Hw(e,t,n);case 2:return Gw(e,[0,t],[e.shape[0],n]);case 3:return qw(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return Kw(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new CN("sliceAlongLastAxis() received an unsupported tensor rank: "+"".concat(e.rank))}})}function ST(e,t,n,a){return Km(()=>{switch(e.rank){case 1:return Hw(e,t,n);case 2:switch(a){case 1:return wT(e,t,n);case 2:return kT(e,t,n);default:throw new CN("The axis is not within the rank of the tensor "+"".concat(a))}case 3:switch(a){case 1:return wT(e,t,n);case 2:return qw(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return kT(e,t,n);default:throw new CN("The axis is not within the rank of the tensor "+"".concat(a))}case 4:switch(a){case 1:return wT(e,t,n);case 2:return Kw(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return Kw(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return kT(e,t,n);default:throw new CN("The axis is not within the rank of the tensor "+"".concat(a))}default:throw new CN("sliceAlongLastAxis() received an unsupported tensor rank: "+"".concat(e.rank))}})}function CT(e){let t,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;return n<0&&(t=e[0].rank,n=0!==t?t:0),n===e[0].rank&&(n=-1),sx(e,n)}function IT(e,t){switch(e.rank){case 1:return wx([e,t]);case 2:return kx([e,t],0);case 3:return Sx([e,t],0);case 4:return Cx([e,t],0);default:throw new CN("concatAlongFirstAxis() received an unsupported "+"tensor rank: ".concat(e.rank))}}function NT(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new CN("The length of input n (".concat(t.length,") does not match ")+"the number of dimensions in input x (".concat(e.rank,")"));return dv(e,t)}function TT(e){return kw(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,arguments.length>3?arguments[3]:void 0,arguments.length>4?arguments[4]:void 0)}function ET(e,t,n,a){if(e.rank<2||t.rank<2)throw new IN("dot requires both inputs to be rank >= 2"+" but got x shape = ".concat(e.shape," and y shape = ").concat(t.shape));if(t.rank>=3){if(e.shape.slice(-1)[0]!==t.shape.slice(-2)[0])throw new IN("If rank y >= 3, then the second last dim"+" of y must equal the last dim of x but got x shape = ".concat(e.shape," and ")+" y shape = ".concat(t.shape))}if(2===e.rank&&2===t.rank){return Uk({a:e,b:t,transposeA:!1,transposeB:!1,bias:a?AT(e.rank,a,"channelsLast"):null,activation:n})}{const s=e.shape.slice(),r=s.pop();e=tx(e,[-1,r]);const i=t.shape.slice(),o=i.pop(),c=i.pop(),l=[...i,o],u=Array.from({length:t.rank},(e,n)=>0===n?t.rank-2:n<=t.rank-2?n-1:n);t=tx(Ik(t,u),[c,-1]);const h=[...s,...l];return tx(Uk({a:e,b:t,transposeA:!1,transposeB:!1,bias:a?AT(e.rank,a,"channelsLast"):null,activation:n}),h)}}function RT(e,t,n){return Km(()=>(t=Array.isArray(t)?ik(t,"int32"):ny(t,"int32"),mv(e,t,n)))}function _T(e){return cy(e,e)}function AT(e,t,n){const a=t.shape;if(1!==t.rank&&t.rank!==e)throw new CN("Unexpected bias dimensions: ".concat(t.rank)+"; expected it to be 1 or ".concat(e));if(5===e){if("channelsFirst"===n)return 1===a.length?tx(t,[1,a[0],1,1,1]):tx(t,[1,a[3],a[0],a[1],a[2]]);if("channelsLast"===n)return 1===a.length?tx(t,[1,1,1,1,a[0]]):tx(t,[1].concat(a))}else if(4===e){if("channelsFirst"===n)return 1===a.length?tx(t,[1,a[0],1,1]):tx(t,[1,a[2],a[0],a[1]]);if("channelsLast"===n)return 1===a.length?tx(t,[1,1,1,a[0]]):tx(t,[1].concat(a))}else if(3===e){if("channelsFirst"===n)return 1===a.length?tx(t,[1,a[0],1]):tx(t,[1,a[1],a[0]]);if("channelsLast"===n)return 1===a.length?tx(t,[1,1,a[0]]):tx(t,[1].concat(a))}else if(e<3)return t;throw new CN("Unsupported input rank by biasAdd: ".concat(t.rank))}function MT(e,t,n){return Km(()=>(null==n&&(n="channelsLast"),aT(n),ry(e,AT(e.rank,t,n))))}function PT(e,t,n,a){return Km(()=>_k(e,t,n,a))}function DT(e,t){return arguments.length>2&&void 0!==arguments[2]&&arguments[2]?e():t()}const OT=["fanIn","fanOut","fanAvg"],FT=["normal","uniform","truncatedNormal"];class LT extends gy{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class zT extends LT{apply(e,t){return Gv(e,t)}}zT.className="Zeros",by(zT);class BT extends LT{apply(e,t){return qv(e,t)}}BT.className="Ones",by(BT);class jT extends LT{constructor(e){if(super(),"object"!==typeof e)throw new CN("Expected argument of type ConstantConfig but got ".concat(e));if(void 0===e.value)throw new CN("config must have value set but got ".concat(e));this.value=e.value}apply(e,t){return Km(()=>cy(py(this.value),qv(e,t)))}getConfig(){return{value:this.value}}}jT.className="Constant",by(jT);class WT extends LT{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return Cw(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}WT.className="RandomUniform",by(WT);class VT extends LT{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new IN("randomNormal does not support dType ".concat(t,"."));return TT(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}VT.className="RandomNormal",by(VT);class UT extends LT{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new IN("truncatedNormal does not support dType ".concat(t,"."));return gk(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}UT.className="TruncatedNormal",by(UT);class HT extends LT{constructor(e){super(),this.gain=null!=e.gain?e.gain:1}apply(e,t){return Km(()=>{if(2!==e.length||e[0]!==e[1])throw new CN("Identity matrix initializer can only be used for 2D square matrices.");return cy(this.gain,pv(e[0]))})}getConfig(){return{gain:this.gain}}}HT.className="Identity",by(HT);class GT extends LT{constructor(e){if(super(),e.scale<0)throw new CN("scale must be a positive float. Got: ".concat(e.scale));var t;this.scale=null==e.scale?1:e.scale,this.mode=null==e.mode?"fanIn":e.mode,t=this.mode,VN(OT,"FanMode",t),this.distribution=null==e.distribution?"normal":e.distribution,function(e){VN(FT,"Distribution",e)}(this.distribution),this.seed=e.seed}apply(e,t){const n=function(e){let t,n,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"channelsLast";if(aT(a),2===e.length)t=e[0],n=e[1];else if(-1!==[3,4,5].indexOf(e.length)){if("channelsFirst"===a){const a=pT(e,2);t=e[1]*a,n=e[0]*a}else if("channelsLast"===a){const a=pT(e,0,e.length-2);t=e[e.length-2]*a,n=e[e.length-1]*a}}else{const a=pT(e);t=Math.sqrt(a),n=Math.sqrt(a)}return[t,n]}(e),a=n[0],s=n[1];let r=this.scale;if("fanIn"===this.mode?r/=Math.max(1,a):"fanOut"===this.mode?r/=Math.max(1,s):r/=Math.max(1,(a+s)/2),"normal"===this.distribution){const n=Math.sqrt(r);if("float32"!==(t=t||"float32")&&"int32"!==t)throw new IN("".concat(this.getClassName()," does not support dType ").concat(t,"."));return gk(e,0,n,t,this.seed)}{const n=Math.sqrt(3*r);return Cw(e,-n,n,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}GT.className="VarianceScaling",by(GT);class qT extends GT{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return GT.className}}qT.className="GlorotUniform",by(qT);class KT extends GT{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return GT.className}}KT.className="GlorotNormal",by(KT);class XT extends GT{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return GT.className}}XT.className="HeNormal",by(XT);class YT extends GT{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return GT.className}}YT.className="HeUniform",by(YT);class QT extends GT{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return GT.className}}QT.className="LeCunNormal",by(QT);class ZT extends GT{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return GT.className}}ZT.className="LeCunUniform",by(ZT);class JT extends LT{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=null==e.gain?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return Km(()=>{if(e.length<2)throw new IN("Shape must be at least 2D.");if("int32"!==t&&"float32"!==t&&void 0!==t)throw new TypeError("Unsupported data type ".concat(t,"."));const n=vu(e.slice(0,-1)),a=e[e.length-1],s=n*a;s>this.ELEMENTS_WARN_SLOW&&console.warn("Orthogonal initializer is being called on a matrix with more "+"than ".concat(this.ELEMENTS_WARN_SLOW," (").concat(s,") elements: ")+"Slowness may result.");const r=TT([Math.max(a,n),Math.min(a,n)],0,1,t,this.seed),i=HS.qr(r,!1);let o=i[0];const c=i[1].flatten().stridedSlice([0],[Math.min(a,n)*Math.min(a,n)],[Math.min(a,n)+1]);return o=cy(o,c.sign()),n<a&&(o=o.transpose()),cy(py(this.gain),o.reshape(e))})}getConfig(){return{gain:this.gain,seed:this.seed}}}JT.className="Orthogonal",by(JT);const $T={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function eE(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return zN(e,yy.getMap().classNameMap,t,"initializer")}function tE(e){return FN(e)}function nE(e){if("string"===typeof e){const t=e in $T?$T[e]:e;if("GlorotNormal"===t)return new KT;if("GlorotUniform"===t)return new qT;if("HeNormal"===t)return new XT;if("HeUniform"===t)return new YT;if("LeCunNormal"===t)return new QT;if("LeCunUniform"===t)return new ZT;{const e={};return e.className=t,e.config={},eE(e)}}return e instanceof LT?e:eE(e)}function aE(e){return Array.isArray(e)&&Array.isArray(e[0])}function sE(e){return 0===e.length?[]:Array.isArray(e[0])?e:[e]}function rE(e){let t;if(Array.isArray(e)){if(1!==e.length)throw new CN("Expected Tensor length to be 1; got ".concat(e.length));t=e[0]}else t=e;return t}function iE(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(1===e.length)return e[0];throw new CN("Expected exactly 1 Shape; got ".concat(e.length))}return e}function oE(e){let t=0;for(const n of e)0===n.shape.length?t+=1:t+=n.shape.reduce((e,t)=>e*t);return t}const cE="Variable";class lE{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:cE,a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this.dtype=null==t?"float32":t,this.shape=e.shape,this.id=XN(),n=null==n?cE:n,this.originalName=cT(n),this.name=lT(this.originalName),this.trainable_=a,this.constraint=s,this.val=wk(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),function(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}(this.val,e),this.val.id!==e.id&&(this.val.assign(e),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error("LayersVariable ".concat(this.name," is already disposed."))}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function uE(e){return e.map(e=>e.read())}function hE(e){e.forEach(e=>{e[0].write(e[1])})}class dE{constructor(e){this.dtype=e.dtype,this.shape=e.shape,null!=e.shape?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}class pE{constructor(e,t,n,a,s,r,i){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=a,this.callArgs=s,this.outputTensorIndex=i,this.id=XN(),null!=r&&(this.originalName=cT(r),this.name=lT(this.originalName)),this.rank=t.length}}let fE=0;class mE{constructor(e,t){this.callArgs=t,this.id=fE++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const n of e.inboundLayers)null!=n&&n.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const t of this.inboundLayers)null!=t?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let gE=0;class yE extends gy{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=gE++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){const e=this.getClassName();t=PN(e)+"_"+QN(e)}if(this.name=t,this.trainable_=null==e.trainable||e.trainable,null!=e.inputShape||null!=e.batchInputShape){let t;if(null!=e.batchInputShape)t=e.batchInputShape;else if(null!=e.inputShape){let n=null;null!=e.batchSize&&(n=e.batchSize),t=[n].concat(e.inputShape)}this.batchInputShape=t;let n=e.dtype;null==n&&(n=e.inputDType),null==n&&(n="float32"),this.dtype=n}null!=e.weights?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(0===this.inboundNodes.length)throw new SN("The layer has never been called "+"and thus has no defined ".concat(t,"."));if(this.inboundNodes.length<=e)throw new CN("Asked to get ".concat(t," at node ").concat(e,", ")+"but the layer has only ".concat(this.inboundNodes.length," inbound nodes."));return this.inboundNodes[e]}getInputAt(e){return AN(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return AN(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new kN("Layer ".concat(this.name)+' has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use `getInputAt(nodeIndex)` instead.');if(0===this.inboundNodes.length)throw new kN("Layer ".concat(this.name)+" is not connected, no input to return.");return AN(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new kN("Layer ".concat(this.name)+" has no inbound nodes.");if(this.inboundNodes.length>1)throw new kN("Layer ".concat(this.name)+' has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use `getOutputAt(nodeIndex)` instead.');return AN(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(t=>t.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){const t=MN(e);if(null==this.inputSpec||0===this.inputSpec.length)return;const n=MN(this.inputSpec);if(t.length!==n.length)throw new CN("Layer ".concat(this.name," expects ").concat(n.length," inputs, ")+"but it received ".concat(t.length," input tensors. ")+"Input received: ".concat(e));for(let a=0;a<t.length;a++){const e=t[a],s=n[a];if(null==s)continue;const r=e.rank;if(null!=s.ndim&&r!==s.ndim)throw new CN("Input ".concat(a," is incompatible with layer ").concat(this.name,": ")+"expected ndim=".concat(s.ndim,", found ndim=").concat(r));if(null!=s.maxNDim&&r>s.maxNDim)throw new CN("Input ".concat(a," is incompatible with layer ").concat(this.name)+": expected max_ndim=".concat(s.maxNDim,", found ndim=").concat(r));if(null!=s.minNDim&&r<s.minNDim)throw new CN("Input ".concat(a," is incompatible with layer ").concat(this.name)+": expected min_ndim=".concat(s.minNDim,", found ndim=").concat(r,"."));if(null!=s.dtype&&e.dtype!==s.dtype)throw new CN("Input ".concat(a," is incompatible with layer ").concat(this.name," ")+": expected dtype=".concat(s.dtype,", found dtype=").concat(e.dtype,"."));if(s.axes){const t=e.shape;for(const e in s.axes){const n=Number(e),r=s.axes[e],i=n>=0?t[n]:t[t.length+n];if(null!=r&&-1===[r,null].indexOf(i))throw new CN("Input ".concat(a," is incompatible with layer ")+"".concat(this.name,": expected axis ").concat(n," of input shape to ")+"have value ".concat(r," but got shape ").concat(t,"."))}}if(null!=s.shape)for(let t=0;t<s.shape.length;++t){const n=s.shape[t],r=e.shape[t];if(null!=n&&null!=r&&n!==r)throw new CN("Input ".concat(a," is incompatible with layer ")+"".concat(this.name,": expected shape=").concat(s.shape,", ")+"found shape=".concat(e.shape,"."))}}}call(e,t){return e}invokeCallHook(e,t){null!=this._callHook&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();const n=MN(e),a=function(e){let t=!0;for(const n of MN(e))if(!(n instanceof pE)){t=!1;break}return t}(e),s=function(e){let t=!0;for(const n of MN(e))if(n instanceof pE){t=!1;break}return t}(e);if(a===s)throw new CN("Arguments to apply() must be all SymbolicTensors or all Tensors");return oT(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);const t=[];for(const n of MN(e))t.push(n.shape);this.build(AN(t)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&s&&(this._refCount=1)}if(this.assertInputCompatibility(e),s){let a=this.call(e,t);this.supportsMasking&&this.setMaskMetadata(e,a);const s=MN(a),r=[];for(let e of s)-1!==n.indexOf(e)&&(e=e.clone()),r.push(e);if(a=AN(r),null!=this.activityRegularizer)throw new IN("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return a}{const n=function(e){e=MN(e);const t=[];for(const n of e)t.push(n.shape);return AN(t)}(e),a=this.computeOutputShape(n);let s;const r="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(e)?n[0]:n),s=null!=a&&a.length>0&&Array.isArray(a[0])?a.map((n,a)=>new pE(r,n,this,MN(e),t,this.name,a)):new pE(r,a,this,MN(e),t,this.name),this.addInboundNode(e,s,null,null,n,a,t),this._refCount++,null!=this.activityRegularizer)throw new IN("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return s}})}warnOnIncompatibleInputShape(e){if(null!=this.batchInputShape)if(e.length!==this.batchInputShape.length)console.warn("The rank of the input tensor provided (shape: "+"".concat(JSON.stringify(e),") does not match that of the ")+"batchInputShape (".concat(JSON.stringify(this.batchInputShape),") ")+"of the layer ".concat(this.name));else{let t=!1;this.batchInputShape.forEach((n,a)=>{null!=n&&null!=e[a]&&e[a]!==n&&(t=!0)}),t&&console.warn("The shape of the input tensor "+"(".concat(JSON.stringify(e),") does not ")+"match the expectation of layer ".concat(this.name,": ")+"".concat(JSON.stringify(this.batchInputShape)))}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new kN("The layer ".concat(this.name," has never been called and thus has no ")+"defined output shape.");const e=[];for(const t of this.inboundNodes){const n=JSON.stringify(t.outputShapes);-1===e.indexOf(n)&&e.push(n)}if(1===e.length){const e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&1===e.length?e[0]:e}throw new kN("The layer ".concat(this.name," has multiple inbound nodes with different ")+'output shapes. Hence the notion of "output shape" is ill-defined for the layer.')}countParams(){if(!this.built)throw new SN("You tried to call countParams() on ".concat(this.name,", ")+"but the layer is not built yet. Build it first by calling build(batchInputShape).");return oE(this.weights)}build(e){this.built=!0}getWeights(){return uE(arguments.length>0&&void 0!==arguments[0]&&arguments[0]?this.trainableWeights:this.weights)}setWeights(e){Km(()=>{const t=this.weights;if(t.length!==e.length)throw new CN('You called setWeights(weights) on layer "'.concat(this.name,'" ')+"with a weight list of length ".concat(e.length,", ")+"but the layer was expecting ".concat(t.length," weights. ")+"Provided weights: ".concat(e,"..."));if(0===t.length)return;const n=[],a=uE(t);for(let s=0;s<a.length;++s){const r=a[s],i=t[s],o=e[s];if(!ku(r.shape,o.shape))throw new CN("Layer weight shape ".concat(r.shape," ")+"not compatible with provided weight shape ".concat(o.shape));n.push([i,o])}hE(n)})}addWeight(e,t,n,a,s,r,i,o){if(-1!==this._addedWeightNames.indexOf(e))throw new CN("Duplicate weight name ".concat(e," for layer ").concat(this.name));this._addedWeightNames.push(e),null==n&&(n="float32"),this.fastWeightInitDuringBuild&&(a=null!=o?o():nE("zeros"));const c=a.apply(t,n),l=new lE(c,n,e,r,i);return c.dispose(),null!=s&&this.addLoss(()=>s.apply(l.read())),null==r&&(r=!0),r?this._trainableWeights.push(l):this._nonTrainableWeights.push(l),l}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){null==e||Array.isArray(e)&&0===e.length||(e=MN(e),void 0!==this._losses&&null!==this._losses&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(null!=t){if(!Array.isArray(t))throw new TypeError("Layer ".concat(this.name," does not support masking, ")+"but was passed an inputMask.");t.forEach(e=>{if(null!=e)throw new TypeError("Layer ".concat(this.name," does not support masking, ")+"but was passed an inputMask.")})}return null}return t}setMaskMetadata(e,t,n){if(!this.supportsMasking)return;const a=this.computeMask(e,n),s=MN(t),r=MN(a);if(s.length!==r.length)throw new Error("".concat(this.name," outputs ").concat(s.length," tensors ")+"but ".concat(s.length," masks for those tensors"));for(let i=0;i<s.length;i++)s[i].kerasMask=r[i]}addInboundNode(e,t,n,a,s,r){let i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null;const o=MN(e);t=MN(t),n=MN(n),a=MN(a),s=sE(s),r=sE(r);const c=[],l=[],u=[];for(const h of o)c.push(h.sourceLayer),l.push(h.nodeIndex),u.push(h.tensorIndex);new mE({outboundLayer:this,inboundLayers:c,nodeIndices:l,tensorIndices:u,inputTensors:o,outputTensors:t,inputMasks:n,outputMasks:a,inputShapes:s,outputShapes:r},i);for(let h=0;h<t.length;h++)t[h].sourceLayer=this,t[h].nodeIndex=this.inboundNodes.length-1,t[h].tensorIndex=h}getConfig(){const e={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(e.batchInputShape=this.batchInputShape),null!=this.dtype&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error("Layer '".concat(this.name,"' is already disposed."))}dispose(){if(!this.built)throw new Error("Cannot dispose Layer ".concat(this.name," because it has not been ")+"built yet.");if(null===this._refCount)throw new Error("Cannot dispose Layer ".concat(this.name," because it has not been used ")+"yet.");this.assertNotDisposed();let e=0;return 0===--this._refCount&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}}function bE(e,t,n){if((null==t||null!=n&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),0===t.inboundNodes.length)return[e];{const e=t.inboundNodes[n];if(0===e.inboundLayers.length)return e.inputTensors;{const t=[];for(let n=0;n<e.inboundLayers.length;n++){const a=bE(e.inputTensors[n],e.inboundLayers[n],e.nodeIndices[n]);for(const e of a)-1===t.indexOf(e)&&t.push(e)}return t}}}class xE extends yE{constructor(e){if(super({dtype:e.dtype,name:null!=e.name?e.name:QN("input").toString()}),null==e.batchSize&&(e.batchSize=null),null==e.sparse&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,null!=e.inputShape&&null!=e.batchInputShape)throw new CN("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(null==t){if(null==e.inputShape)throw new CN("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(null!=e.batchSize)throw new CN("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const n=e.dtype||"float32";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];const a=new pE(this.dtype,this.batchInputShape,this,[],{},this.name);a.nodeIndex=0,a.tensorIndex=0,new mE({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[a],outputTensors:[a],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new CN("Cannot pass any input to an "+"InputLayer's apply() method. InputLayer name: ".concat(this.name))}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}xE.className="InputLayer",by(xE);class vE{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof vE)for(const t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(null==e)return;for(const t of e)this.add(t.key,t.value)}}add(e,t,n){if(null!=this.id2Value[e.id])throw new CN("Duplicate key: name=".concat(e.name,", id=").concat(e.id));return this.id2Value[e.id]=function(e,t){if(null==e.dtype||e.dtype===t.dtype)return t;try{return ny(t,e.dtype)}catch(q5){throw new CN("The dtype of the feed (".concat(t.dtype,") can not be cast to the dtype ")+"of the key '".concat(e.name,"' (").concat(e.dtype,")."))}}(e,t),this.name2Id[e.name]=e.id,null!=n&&(this.id2Mask[e.id]=n),this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return null!=this.id2Value[e.id]}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof pE){if(null==this.id2Value[e.id])throw new CN("Nonexistent key: ".concat(e.name));return this.id2Value[e.id]}{const t=this.name2Id[e];if(null==t)throw new CN("Feed dict has no SymbolicTensor name: ".concat(e));return this.id2Value[t]}}getMask(e){if(e instanceof pE){if(null==this.id2Value[e.id])throw new CN("Nonexistent key: ".concat(e.name));return this.id2Mask[e.id]}{const t=this.name2Id[e];if(null==t)throw new CN("Feed dict has no SymbolicTensor name: ".concat(e));return this.id2Mask[t]}}disposeMasks(){null!=this.id2Mask&&Xm(this.id2Mask)}}const wE=new TN,kE=new TN;function SE(e,t,n,a){const s=null!=n&&n.training,r=Array.isArray(e),i=r?e:[e],o=i.map(e=>e.name),c=[],l=t.names();for(const f of o)-1!==l.indexOf(f)?c.push(t.getValue(f)):c.push(null);null!=a&&(a.maxNumTensors=-1/0,a.minNumTensors=1/0);const u=o.join(",")+"|"+t.names().sort().join(",");let h,d=wE.get(u);if(null==d){const e=function(e,t){yu(null!=e&&e.length>0,()=>"Expected at least one fetch, got none");let n=[],a={};if(1===e.length){const s=IE(e[0],t);n=s.sorted,a=s.recipientMap}else{const s=new Set;for(const r of e){const{sorted:e,recipientMap:i}=IE(r,t);for(const t of e)s.has(t.name)||(n.push(t),s.add(t.name));for(const t in i)null==a[t]&&(a[t]=new Set),i[t].forEach(e=>a[t].add(e))}}return{sorted:n,recipientCounts:CE(a)}}(i,t);d=e.sorted,h=e.recipientCounts,wE.put(u,d),kE.put(u,h)}h={},s||Object.assign(h,kE.get(u));const p=new vE(t);for(let f=0;f<d.length;++f){if(null!=a){const e=qm().numTensors;e>a.maxNumTensors&&(a.maxNumTensors=e),e<a.minNumTensors&&(a.minNumTensors=e)}const e=d[f],r=e.sourceLayer;if(r instanceof xE)continue;const i=[],l=[],u=[];let m=!1;for(const n of e.inputs){const e=p.getValue(n),a=p.getMask(n);i.push(e),l.push(a),null!=a&&(m=!0),s||(h[n.name]--,0!==h[n.name]||t.hasKey(n)||-1!==o.indexOf(n.name)||e.isDisposed||!0===n.sourceLayer.stateful||u.push(e))}m&&((n=n||{}).mask=l[0]);const g=MN(r.apply(i,n));let y=null;r.supportsMasking&&(y=r.computeMask(i,l));const b=NE(e),x=Array.isArray(b)?b:[b];for(let t=0;t<x.length;++t){p.hasKey(x[t])||p.add(x[t],g[t],Array.isArray(y)?y[0]:y);const e=o.indexOf(x[t].name);-1!==e&&(c[e]=g[t])}s||Xm(u)}return p.disposeMasks(),r?c:c[0]}function CE(e){const t={};for(const n in e)t[n]=e[n].size;return t}function IE(e,t){const n=new Set,a=[],s={};for(const o of t.names())n.add(o);const r=[],i=[];for(r.push(e);r.length>0;){const e=r[r.length-1];if(n.has(e.name)){r.pop();continue}const t=i[i.length-1]===r.length-1;if(0===e.inputs.length||t)r.pop(),a.push(e),n.add(e.name),t&&i.pop();else{i.push(r.length-1);for(const t of e.inputs)null==s[t.name]&&(s[t.name]=new Set),s[t.name].add(e.name),n.has(t.name)||r.push(t)}}return{sorted:a,recipientMap:s}}function NE(e){let t;if(1===e.sourceLayer.inboundNodes.length)t=e.sourceLayer.output;else{let n=null;for(let t=0;t<e.sourceLayer.inboundNodes.length;++t)for(const a of e.sourceLayer.inboundNodes[t].outputTensors)if(a.id===e.id){n=t;break}t=e.sourceLayer.getOutputAt(n)}return t}function TE(e,t){return Km(()=>ly(rv(cy(e,e),t,!0)))}$u().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,function(e){null!=wE&&wE.setMaxEntries(e),null!=kE&&kE.setMaxEntries(e)});class EE extends gy{getConfig(){return{}}}class RE extends EE{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return Km(()=>{const t=TE(e,this.axis),n=vx(t,0,this.maxValue);return cy(e,oy(n,ry(bT(),t)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}RE.className="MaxNorm",by(RE);class _E extends EE{constructor(e){super(),this.defaultAxis=0,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return Km(()=>oy(e,ry(bT(),TE(e,this.axis))))}getConfig(){return{axis:this.axis}}}_E.className="UnitNorm",by(_E);class AE extends EE{apply(e){return Rw(e)}}AE.className="NonNeg",by(AE);class ME extends EE{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=e.minValue?e.minValue:this.defaultMinValue,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.rate=null!=e.rate?e.rate:this.defaultRate,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return Km(()=>{const t=TE(e,this.axis),n=ry(cy(this.rate,vx(t,this.minValue,this.maxValue)),cy(1-this.rate,t));return cy(e,oy(n,ry(bT(),t)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}ME.className="MinMaxNorm",by(ME);const PE={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function DE(e){return FN(e)}function OE(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return zN(e,yy.getMap().classNameMap,t,"constraint")}function FE(e){if(null==e)return null;if("string"===typeof e){return OE({className:e in PE?PE[e]:e,config:{}})}return e instanceof EE?e:OE(e)}async function LE(e){if(null==e)return;const t=[],n=[],a=[];for(const s in e){const r=e[s];if("number"!==typeof r){const e=r;t.push(e.data()),n.push(s),a.push(e)}}if(t.length>0){const s=await Promise.all(t);for(let t=0;t<s.length;++t)e[n[t]]=s[t][0];Xm(a)}}function zE(e){if(null!=e)for(const t in e){const n=e[t];"number"!==typeof n&&n.dispose()}}var BE;!function(e){e[e.SILENT=0]="SILENT",e[e.VERBOSE=1]="VERBOSE"}(BE||(BE={}));class jE{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}}class WE{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:10;null==e&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(const t of this.callbacks)t.setParams(e)}setModel(e){for(const t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onEpochBegin(e,t)}async onEpochEnd(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onEpochEnd(e,t)}async onBatchBegin(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onBatchBegin(e,t)}async onBatchEnd(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onBatchEnd(e,t)}async onTrainBegin(e){null==e&&(e={});for(const t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){null==e&&(e={});for(const t of this.callbacks)await t.onTrainEnd(e)}}class VE extends jE{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){null==t&&(t={});const n=null==t.size?0:t.size;this.seen+=n;for(const a in t){const e=t[a];if("number"===typeof e)this.totals.hasOwnProperty(a)||(this.totals[a]=0),this.totals[a]=this.totals[a]+e*n;else{let t;a in this.totals?t=this.totals[a]:this.totals[a]=0;const s=Km(()=>ry(this.totals[a],cy(e,n)));this.totals[a]=s,null!=t&&t.dispose()}}}async onEpochEnd(e,t){if(null!=t)for(const n of this.params.metrics)null!=this.totals[n]&&("number"===typeof this.totals[n]?t[n]=this.totals[n]/this.seen:Km(()=>{const e=cy(oy(1,this.seen),this.totals[n]);t[n]=e,this.totals[n].dispose(),Ym(t[n])}))}}class UE extends jE{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){null==t&&(t={}),this.epoch.push(e);for(const n in t)null==this.history[n]&&(this.history[n]=[]),this.history[n].push(t[n])}async syncData(){const e=[],t=[],n=[];for(const s in this.history){const a=this.history[s];for(let r=0;r<a.length;++r)if("number"!==typeof a[r]){const i=a[r];e.push(i.data()),t.push(s),n.push(r)}}const a=await Promise.all(e);for(let s=0;s<a.length;++s){this.history[t[s]][n[s]].dispose(),this.history[t[s]][n[s]]=a[s][0]}}}class HE extends jE{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||QS,this.yieldEvery=t||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=e.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");Ou(this.yieldEvery)&&(this.maybeWait=function(e,t,n){let a,s=null!=n?n():Uf();return function(){const r=null!=n?n():Uf();return r-s<t||(s=r,a=e(...arguments)),a}}(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,n){const a=[];null!=this.yield&&(await LE(n),a.push(this.yield(e,t,n))),a.push(this.nextFrameFunc()),await Promise.all(a)}async onEpochBegin(e,t){this.currentEpoch=e,null!=this.epochBegin&&(await LE(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){const n=[];null!=this.epochEnd&&(await LE(t),n.push(this.epochEnd(e,t))),"epoch"===this.yieldEvery&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(e,t){null!=this.batchBegin&&(await LE(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){const n=[];null!=this.batchEnd&&(await LE(t),n.push(this.batchEnd(e,t))),"batch"===this.yieldEvery?n.push(this.nextFrameFunc()):Ou(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(n)}async onTrainBegin(e){null!=this.trainBegin&&(await LE(e),await this.trainBegin(e))}async onTrainEnd(e){null!=this.trainEnd&&(await LE(e),await this.trainEnd(e))}}function GE(e,t){if(null==e&&(e={}),e instanceof jE)return[e];if(Array.isArray(e)&&e[0]instanceof jE)return e;return MN(e).map(e=>new HE(e,t))}class qE{constructor(){}static registerCallbackConstructor(e,t){yu(e>=0&&Number.isInteger(e),()=>"Verbosity level is expected to be an integer >= 0, "+"but got ".concat(e)),qE.checkForDuplicate(t),null==qE.constructors[e]&&(qE.constructors[e]=[]),qE.constructors[e].push(t)}static checkForDuplicate(e){for(const t in qE.constructors){qE.constructors[+t].forEach(t=>{if(t===e)throw new CN("Duplicate callback constructor.")})}}static clear(){qE.constructors={}}static createCallbacks(e){const t=[];for(const n in qE.constructors){const a=+n;e>=a&&t.push(...qE.constructors[a])}return t.map(e=>new e)}}function KE(e,t,n,a,s,r,i,o,c){const l=new UE,u=[new VE,...qE.createCallbacks(t)];null!=e&&u.push(...e),u.push(l);const h=new WE(u);return h.setParams({epochs:n,initialEpoch:a,samples:s,steps:r,batchSize:i,verbose:t,doValidation:o,metrics:c}),{callbackList:h,history:l}}function XE(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return zN(e,yy.getMap().classNameMap,t,"layer",n)}function YE(e,t){return Km(()=>{"float32"!==e.dtype&&(e=ny(e,"float32"));const n=rv(_T(e),t,!0),a=wy(n.shape,bT()),s=ly(_y(n,a));return oy(e,s)})}function QE(e,t){return Km(()=>Hv(_T(Cy(t,e)),-1))}function ZE(e,t){return Km(()=>Hv(Ny(Cy(t,e)),-1))}function JE(e,t){return Km(()=>{const n=Cy(e,t),a=vx(Ny(e),bT(),Number.MAX_VALUE),s=Ny(oy(n,a));return cy(100,Hv(s,-1))})}function $E(e,t){return Km(()=>{const n=vx(t,bT(),Number.MAX_VALUE),a=Tv(ry(1,n)),s=vx(e,bT(),Number.MAX_VALUE),r=Tv(ry(1,s));return Hv(_T(Cy(a,r)),-1)})}function eR(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return Km(()=>{if(n)t=Xw(t);else{const e=rv(t,t.shape.length-1,!0);t=oy(t,e)}return t=vx(t,bT(),1-bT()),Rv(rv(cy(ny(e,"float32"),Tv(t)),t.shape.length-1))})}function tR(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return Km(()=>{const a=ny(fv(function(e){const t=[pT(e.shape)];return tx(e,t)}(e)),"int32"),s=(t=vx(t,bT(),1-bT())).shape;return eR(tx(tw(a,s[s.length-1]),s),t,n)})}function nR(e,t){return Km(()=>{let n;return n=vx(t,bT(),1-bT()),n=Tv(oy(n,Cy(1,n))),Hv(function(e,t){if(!ku(e.shape,t.shape))throw new CN("logits and labels must have the same shape, but got shapes "+"".concat(JSON.stringify(e.shape)," and ").concat(JSON.stringify(t.shape)));return Km(()=>{const n=Rw(t),a=Rv(Ny(t));return ry(Cy(n,cy(t,e)),Ev(lv(a)))})}(e,n),-1)})}function aR(e,t){return Km(()=>{const n=vx(e,bT(),1),a=vx(t,bT(),1);return rv(cy(e,Tv(oy(n,a))),-1)})}function sR(e,t){return Km(()=>{const n=YE(e,-1),a=YE(t,-1),s=cy(n,a);return Rv(rv(s,-1))})}qE.constructors={};const rR={meanSquaredError:QE,meanAbsoluteError:ZE,meanAbsolutePercentageError:JE,meanSquaredLogarithmicError:$E,squaredHinge:function(e,t){return Km(()=>{const n=_y(0,Cy(1,cy(e,t)));return Hv(_T(n),-1)})},hinge:function(e,t){return Km(()=>{const n=_y(0,Cy(1,cy(e,t)));return Hv(n,-1)})},categoricalHinge:function(e,t){return Km(()=>{const n=rv(cy(e,t),-1),a=av(cy(Cy(1,e),t),-1);return _y(0,ry(1,Cy(a,n)))})},logcosh:function(e,t){return Km(()=>{const n=Math.log(2),a=Cy(t,e),s=Cy(ry(a,_v(cy(-2,a))),n);return Hv(s,-1)})},categoricalCrossentropy:eR,sparseCategoricalCrossentropy:tR,binaryCrossentropy:nR,kullbackLeiblerDivergence:aR,poisson:function(e,t){return Km(()=>{const n=Tv(ry(bT(),t));return Hv(Cy(t,cy(e,n)),-1)})},cosineProximity:sR};function iR(e){if("string"===typeof e){if(e in rR)return rR[e];let t="Unknown loss ".concat(e);throw e.toLowerCase().includes("softmaxcrossentropy")&&(t="Unknown loss ".concat(e,". ")+'Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy'),new CN(t)}return e}function oR(e,t){return Km(()=>{const n=cy(.5,nw(t)),a=xT(gv(t,n),e.dtype);return Hv(Wx(e,a),-1)})}function cR(e,t){return Km(()=>xT(Wx(Pb(e,-1),Pb(t,-1)),"float32"))}function lR(e,t){return Km(()=>ny(rv(Dv(Wx(e,1),Wx(t,1))),"float32"))}function uR(e,t){return nR(e,t)}function hR(e,t){return e.rank===t.rank&&(e=tk(e,[e.rank-1])),(t=Pb(t,-1)).dtype!==e.dtype&&(t=ny(t,e.dtype)),ny(Wx(e,t),"float32")}const dR=eR,pR=tR,fR={binaryAccuracy:oR,categoricalAccuracy:cR,precision:function(e,t){return Km(()=>{const n=lR(e,t),a=function(e,t){return Km(()=>ny(rv(Dv(Wx(e,0),Wx(t,1))),"float32"))}(e,t),s=ry(n,a);return ny(Vx(gv(s,0),oy(n,s),0),"float32")})},categoricalCrossentropy:dR,sparseCategoricalCrossentropy:pR,mse:QE,MSE:QE,mae:ZE,MAE:ZE,mape:JE,MAPE:JE,cosine:sR};function mR(e){if("string"===typeof e&&e in fR)return fR[e];if("string"!==typeof e&&null!=e)return e;throw new CN("Unknown metric ".concat(e))}function gR(e){if(RN(null!==e,"Unknown LossOrMetricFn ".concat(e)),"string"===typeof e)return e;{let t;for(const n of Object.keys(rR))if(rR[n]===e){t=n;break}if(void 0!==t)return t;for(const n of Object.keys(fR))if(fR[n]===e){t=n;break}return void 0!==t?t:e.name}}const yR=1048576;function bR(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(null==e||"object"!==typeof e||Object.getPrototypeOf(e)!==Object.prototype||!xR(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){const n=JSON.stringify(e);n.length>yR&&console.warn('User-defined metadata of model "'.concat(t,'" is too large in ')+"size (length=".concat(n.length," when serialized). It is not ")+"recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= "+"".concat(yR,"."))}}function xR(e){if(null===e)return!0;if("object"===typeof e){if(Object.getPrototypeOf(e)===Object.prototype){const t=Object.keys(e);for(const n of t){if("string"!==typeof n)return!1;if(!xR(e[n]))return!1}return!0}if(Array.isArray(e)){for(const t of e)if(!xR(t))return!1;return!0}return!1}{const t=typeof e;return"string"===t||"number"===t||"boolean"===t}}function vR(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:console.log;const s=function(e){let t=!0;const n=[],a=[];for(const s in e.nodesByDepth)n.push(e.nodesByDepth[s]);for(const s of n){if(s.length>1||1===s.length&&s[0].inboundLayers.length>1){t=!1;break}a.push(...s)}if(t)for(const s of e.layers){let e=!1;for(const n of s.inboundNodes)if(-1!==a.indexOf(n)){if(e){t=!1;break}e=!0}if(!t)break}return t}(e),r=["Layer (type)","Input Shape","Output shape","Param #"];let i;if(s?(t=t||90,n=n||[.32,.61,.89,1]):(t=t||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map(e=>Math.floor(t*e))),!s){r.push("Receives inputs"),i=[];for(const t in e.nodesByDepth)i.push(...e.nodesByDepth[t])}a("_".repeat(t)),wR(r,n,a),a("=".repeat(t));const o=e.layers;for(let u=0;u<o.length;++u)s?kR(o[u],n,a):SR(o[u],n,i,a),a((u===o.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();const c=function(e){let t;t=null!=e.collectedTrainableWeights?oE(e.collectedTrainableWeights):oE(e.trainableWeights);return t}(e),l=oE(e.nonTrainableWeights);a("Total params: ".concat(c+l)),a("Trainable params: ".concat(c)),a("Non-trainable params: ".concat(l)),a("_".repeat(t))}function wR(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log,a="";for(let s=0;s<e.length;++s)s>0&&(a=a.slice(0,a.length-1)+" "),a+=e[s],a=a.slice(0,t[s]),a+=" ".repeat(t[s]-a.length);n(a)}function kR(e,t,n){let a,s;try{s=e.inboundNodes.map(e=>JSON.stringify(e.inputShapes)).join(",")}catch(q5){s="multiple"}try{a=JSON.stringify(e.outputShape)}catch(q5){a="multiple"}const r=e.name,i=e.getClassName();wR(["".concat(r," (").concat(i,")"),s,a,e.countParams().toString()],t,n)}function SR(e,t,n,a){let s,r;try{r=e.inboundNodes.map(e=>JSON.stringify(e.inputShapes)).join(",")}catch(q5){r="multiple"}try{s=JSON.stringify(e.outputShape)}catch(q5){s="multiple"}const i=[];for(const u of e.inboundNodes)if(!(null!=n&&n.length>0&&-1===n.indexOf(u)))for(let e=0;e<u.inboundLayers.length;++e){const t=u.inboundLayers[e].name,n=u.nodeIndices[e],a=u.tensorIndices[e];i.push("".concat(t,"[").concat(n,"][").concat(a,"]"))}const o=e.name,c=e.getClassName(),l=0===i.length?"":i[0];wR(["".concat(o," (").concat(c,")"),r,s,e.countParams().toString(),l],t,a);for(let u=1;u<i.length;++u)wR(["","","","",i[u]],t,a)}function CR(e,t,n){return("inboundNodes"===e||"outputLayers"===e||"inputLayers"===e)&&0===t&&"string"===typeof n}function IR(e,t){if(null===e)return null;if("string"===typeof e)return DN(e);if("number"===typeof e||"boolean"===typeof e)return e;if(e instanceof Array){const n=[],a=e.length;for(let s=0;s<a;++s){const a=e[s];CR(t,s,a)?n.push(a):n.push(IR(a,t))}return n}{const t={};for(const n of Object.keys(e)){const a=e[n];if("name"===n&&"string"===typeof a)t[n]=a;else{const e=DN(n);t[e]=IR(a,e)}}return t}}function NR(e,t){if(null===e||void 0===e)return null;if("string"===typeof e)return PN(e);if("number"===typeof e||"boolean"===typeof e)return e;if(e instanceof Array){const n=[],a=e.length;for(let s=0;s<a;++s){const a=e[s];CR(t,s,a)?n.push(a):n.push(NR(a,t))}return n}{const t={};for(const n of Object.keys(e)){const a=e[n],s=PN(n);t[s]="name"!==n&&"className"!==n||"string"!==typeof a?NR(a,n):a}return t}}const TR="4.22.0";class ER extends yE{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,null==this.name){const e=this.getClassName().toLowerCase();this.name=QN(e)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],jN(this.inputs).length!==this.inputs.length)throw new CN("The list of inputs passed to the model is redundant. All inputs should only appear once. Found: "+"".concat(this.inputs.map(e=>e.name)));jN(this.outputs).length!==this.outputs.length&&console.warn("The list of outputs passed to the model is redundant. All outputs should only appear once. Found: "+"".concat(this.outputs.map(e=>e.name))),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const y of this.outputs){const e=y.sourceLayer,t=y.nodeIndex,n=y.tensorIndex;this.outputLayers.push(e),this.outputLayersNodeIndices.push(t),this.outputLayersTensorIndices.push(n)}for(const y of this.inputs){const e=y.sourceLayer,t=y.nodeIndex,n=y.tensorIndex;RN(0===t,"input layer has >1 nodes"),RN(0===n,"input layer has >1 tensors"),this.inputLayers.push(e),this.inputLayersNodeIndices.push(t),this.inputLayersTensorIndices.push(n)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let y=0;y<this.inputLayers.length;y++){const t=this.inputLayers[y];if(!(t instanceof xE))throw new TypeError("Input layers to a LayersModel must be InputLayer objects. "+"Received inputs: ".concat(e.inputs,". ")+"Input ".concat(y," (0-based) originates ")+"from layer type ".concat(t.getClassName(),"."));this.inputNames.push(t.name),this.feedInputShapes.push(t.batchInputShape),this.feedInputNames.push(t.name)}for(const y of this.outputLayers)this.outputNames.push(y.name);this.internalInputShapes=this.inputs.map(e=>e.shape),this.internalOutputShapes=this.outputs.map(e=>e.shape);const t={},n={},a={},s={},r={},i=[],o=(e,t,n,a,s,c)=>{null!=a&&null!=s&&null!=c||(a=e.sourceLayer,s=e.nodeIndex,c=e.tensorIndex);const l=a.inboundNodes[s];if(-1!==n.indexOf(l))throw new SN("The tensor ".concat(e.name,' at layer "').concat(a.name,'" ')+"is part of a cycle.");if(-1!==t.indexOf(l))return;this.containerNodes.add(ER.nodeKey(a,s)),a.id in r||(r[a.id]=Object.keys(r).length),-1===n.indexOf(l)&&n.push(l);const u=l.inboundLayers.length;for(let r=0;r<u;r++){const e=l.inputTensors[r],a=l.inboundLayers[r],s=l.nodeIndices[r],i=l.tensorIndices[r];o(e,t,n,a,s,i)}for(t.push(l);n.indexOf(l)>=0;)n.splice(n.indexOf(l),1);i.push(l)},c=[],l=[];for(const y of this.outputs)o(y,c,l);const u=i.slice().reverse();for(const y of u){n[y.id]=y,y.id in t||(t[y.id]=0);let e=t[y.id];const r=null==a[y.outboundLayer.id]?0:a[y.outboundLayer.id];e=Math.max(e,r),a[y.outboundLayer.id]=e,s[y.outboundLayer.id]=y.outboundLayer,t[y.id]=e;for(let a=0;a<y.inboundLayers.length;a++){const s=y.inboundLayers[a],r=y.nodeIndices[a],i=s.inboundNodes[r],o=null==t[i.id]?0:t[i.id];t[i.id]=Math.max(e+1,o),n[i.id]=i}}const h={};for(const y in t){const e=t[y];e in h||(h[e]=[]),h[e].push(n[y])}const d={};for(const y in a){const e=a[y];e in d||(d[e]=[]),d[e].push(s[y])}let p=Object.keys(d).map(e=>parseInt(e,10)).sort(BN);this.layers=[];for(const y of p){const e=d[y];e.sort((e,t)=>{const n=r[e.id],a=r[t.id];return n<a?-1:n>a?1:0});for(const t of e)t instanceof ER&&this.internalContainerRefs.push(t),this.layers.push(t)}this.layersByDepth=d,p=Object.keys(h).map(e=>parseInt(e,10)).sort(BN);const f=this.inputs.slice(),m=[];for(const y of p)for(const e of h[y]){const t=e.outboundLayer;if(null!=t){for(const n of e.inputTensors)if(-1===f.indexOf(n))throw new SN("Graph disconnected: cannot obtain value for tensor ".concat(n)+' at layer "'.concat(t.name,'". ')+"The following previous layers were accessed without "+"issue: ".concat(m));for(const t of e.outputTensors)f.push(t);m.push(t.name)}}this.nodesByDepth=h;const g=this.layers.map(e=>e.name);for(const y of g){const e=g.filter(e=>e===y).length;if(1!==e)throw new SN('The name "'.concat(y,'" is used ').concat(e," times ")+"in the model. All layer names should be unique. Layer names: "+JSON.stringify(g))}this.outboundNodes=[],this.inboundNodes=[],new mE({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(e=>null),outputMasks:this.outputs.map(e=>null),inputShapes:this.inputs.map(e=>e.shape),outputShapes:this.outputs.map(e=>e.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error("Container '".concat(this.name,"' is already disposed."))}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(0===--this._refCount){for(const t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(const t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach(t=>{t._trainableWeights.forEach(t=>t.trainable=e)}),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new CN("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const e of this.layers)t.push(...e.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n={};let a=0;const s=(e=>{const t=Object.keys(e);if(0===t.length)return!1;const n=t[0].split("/");return!isNaN(parseInt(n[n.length-1],10))})(e);s&&this.parseWeights(e);for(const i of this.layers)for(const[e,t]of i.weights.entries()){const r=s?"".concat(t.name.split("/").slice(0,-1).join("/")+"/").concat(e):t.originalName;if(null!=n[r])throw new CN("Duplicate weight name: ".concat(r));n[r]=t,a++}const r=[];for(const i in e){let a=i;if(null==n[i]){const e=i.split("/");a=e.slice(0,-2).concat([e[e.length-1]]).join("/")}if(null!=n[a])r.push([n[a],e[i]]);else if(t)throw new CN("Provided weight data has no target variable: ".concat(i));delete n[a]}if(t){const e=[];for(const t in n)e.push(t);if(e.length>0)throw new CN("".concat(e.length," of ").concat(a," weights are not set: ")+"".concat(e))}hE(r)}parseWeights(e){for(const t in Object.keys(e)){const n=t.split("/"),a=["vars","layer_checkpoint_dependencies"],s=n.map(e=>e.startsWith("_")?e.slice(1):e).filter(e=>!a.includes(e)).join("/");s!==t&&(e[s]=e[t],delete e[t])}}updatedConfig(){const e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion="tfjs-layers ".concat(TR),t.backend="TensorFlow.js",t}toJSON(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n=NR(this.updatedConfig());return t?JSON.stringify(n):n}call(e,t){return Km(()=>{e=MN(e);const n=new vE;for(let t=0;t<this.inputs.length;++t)n.add(this.inputs[t],e[t]);return SE(this.outputs,n,t)})}computeMask(e,t){return Km(()=>{let n;return e=MN(e),n=null==t?EN(null,e.length):MN(t),this.runInternalGraph(e,n)[1]})}computeOutputShape(e){const t=sE(e);if(t.length!==this.inputLayers.length)throw new CN("Invalid inputShape argument ".concat(e,": ")+"model has ".concat(this.inputLayers.length," tensor inputs."));const n={};for(let i=0;i<t.length;i++){const e=this.inputLayers[i],a=t[i];n[e.name+"_0_0"]=a}const a=Object.keys(this.nodesByDepth).map(e=>parseInt(e,10)).sort(BN);if(a.length>1)for(const i of a){const e=this.nodesByDepth[i];for(const t of e){const e=t.outboundLayer;if(-1!==this.inputLayers.map(e=>e.id).indexOf(e.id))continue;const a=[];for(let i=0;i<t.inboundLayers.length;i++){const e=t.inboundLayers[i],s=t.nodeIndices[i],r=t.tensorIndices[i],o=n["".concat(e.name,"_").concat(s,"_").concat(r)];a.push(o)}const s=sE(e.computeOutputShape(AN(a))),r=e.inboundNodes.indexOf(t);for(let t=0;t<s.length;t++){n["".concat(e.name,"_").concat(r,"_").concat(t)]=s[t]}}}const s=[],r=[];for(let i=0;i<this.outputLayers.length;i++){const e=this.outputLayers[i],t=this.outputLayersNodeIndices[i],n=this.outputLayersTensorIndices[i],a="".concat(e.name,"_").concat(t,"_").concat(n);r.push(a)}for(let i=0;i<r.length;i++){const e=r[i];RN(e in n),s.push(n[e])}return AN(s)}runInternalGraph(e,t){null==t&&(t=EN(null,e.length));const n={};for(let o=0;o<this.inputs.length;++o){const a=this.inputs[o],s=e[o],r=t[o];n[a.id]=[s,r]}const a=Object.keys(this.nodesByDepth).map(e=>parseInt(e,10)).sort(BN);for(const o of a){const e=this.nodesByDepth[o];for(const t of e){const e=t.outboundLayer,a=t.inputTensors,s=t.outputTensors,r=new Array;for(const t of a)t.id in n&&r.push(n[t.id]);if(r.length===a.length){let a,i,o,c,l={};if(null!=t.callArgs&&(l=t.callArgs),1===r.length){const[t,n]=r[0];null==l.mask&&(l.mask=n),o=MN(e.call(t,l)),c=MN(e.computeMask(t,n)),a=[t],i=[n]}else a=r.map(e=>e[0]),i=r.map(e=>e[1]),null==l.mask&&(l.mask=i),o=MN(e.call(a,l)),c=MN(e.computeMask(a,i));if(e.activityRegularizer)throw new IN("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let e=0;e<s.length;++e){const t=s[e],a=o[e],r=c[e];n[t.id]=[a,r]}}}}const s=[],r=[],i=[];for(const o of this.outputs){RN(o.id in n,"Could not compute output ".concat(o.name," : ").concat(o.id));const[e,t]=n[o.id];i.push(e.shape),s.push(e),r.push(t)}return[s,r,i]}buildNodeConversionMap(e){const t={};let n;for(const a of this.layers){n=a instanceof ER?1:0;for(let e=0;e<a.inboundNodes.length;e++){const s=ER.nodeKey(a,e);this.containerNodes.has(s)&&(t[s]=n,n+=1)}}return t}getLayer(e,t){if(null!=t)return this.findLayer(t);if(null==e)throw new CN("Provide either a layer name or layer index");if("number"===typeof e)return this.findLayer(e);for(const n of this.layers)if(n.name===e)return n;throw new CN("No such layer: ".concat(e))}findLayer(e){if(this.layers.length<=e)throw new CN("Was asked to retrieve layer at index ".concat(e,", but model only ")+"has ".concat(this.layers.length," layer(s)."));return this.layers[e]}calculateLosses(){return Km(()=>{const e=[];for(const t of this.layers)for(let n=0;n<t.inboundNodes.length;++n){const a=ER.nodeKey(t,n);this.containerNodes.has(a)&&e.push(...t.calculateLosses())}return e})}getConfig(){const e={name:this.name},t=this.buildNodeConversionMap(this.layers),n=[];for(const r of this.layers){const e=r.getClassName(),a=r.getConfig(),s=[];for(let n=0;n<r.inboundNodes.length;n++){const e=r.inboundNodes[n],a=ER.nodeKey(r,n);let i={};if(this.containerNodes.has(a)){if(e.callArgs)try{JSON.stringify(e.callArgs),i=e.callArgs}catch(q5){console.warn("Layer ".concat(r.name," was passed ")+"non-serializable keyword arguments: "+"".concat(e.callArgs,". They will not be included ")+"in the serialized model (and thus will be missing at deserialization time)."),i={}}if(e.inboundLayers.length>0){const n=[];for(let a=0;a<e.inboundLayers.length;a++){const s=e.inboundLayers[a],r=e.nodeIndices[a],o=e.tensorIndices[a];let c=t[ER.nodeKey(s,r)];null==c&&(c=0),n.push([s.name,c,o,i])}s.push(n)}}}const i={};i.name=r.name,i.className=e,i.config=a,i.inboundNodes=s,n.push(i)}e.layers=n;const a=[];for(let r=0;r<this.inputLayers.length;r++){const e=this.inputLayers[r],n=this.inputLayersNodeIndices[r],s=ER.nodeKey(e,n);if(!this.containerNodes.has(s))continue;let i=t[s];null!==i&&void 0!==i||(i=0);const o=this.inputLayersTensorIndices[r];a.push([e.name,i,o])}e.inputLayers=a;const s=[];for(let r=0;r<this.outputLayers.length;r++){const e=this.outputLayers[r],n=this.outputLayersNodeIndices[r],a=ER.nodeKey(e,n);if(!this.containerNodes.has(a))continue;let i=t[a];null!==i&&void 0!==i||(i=0);const o=this.outputLayersTensorIndices[r];s.push([e.name,i,o])}return e.outputLayers=s,e}static fromConfig(e,t){let n=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a={},s={};function r(e,t){e.name in s?s[e.name].push(t):s[e.name]=[t]}function i(e,t){const n=[];let s;for(const i of t){const o=i[0],c=i[1],l=i[2];if(s=null==i[3]?{}:i[3],!(o in a))return void r(e,t);const u=a[o];if(u.inboundNodes.length<=c)return void r(e,t);const h=u.inboundNodes[c];n.push(h.outputTensors[l])}n.length>0&&e.apply(AN(n),s)}function o(e){const s=e.name,i=XE(e,null!=t.customObjects?t.customObjects:{});i.setFastWeightInitDuringBuild(n),a[s]=i;e.inboundNodes.forEach(e=>{if(!(e instanceof Array))throw new CN("Corrupted configuration, expected array for nodeData: ".concat(e));r(i,e)})}const c=t.name,l=t.layers;for(const f of l)o(f);for(;!WN(s);)for(const e of l){const t=a[e.name];if(t.name in s){const e=s[t.name];delete s[t.name];for(const n of e)i(t,n)}}const u=[],h=[],d=t.inputLayers;for(const f of d){const e=f[0],t=f[1],n=f[2];RN(e in a);const s=a[e].inboundNodes[t].outputTensors;u.push(s[n])}const p=t.outputLayers;for(const f of p){const e=f[0],t=f[1],n=f[2];RN(e in a);const s=a[e].inboundNodes[t].outputTensors;h.push(s[n])}return new e({inputs:u,outputs:h,name:c})}get stateful(){if(this._stateful)throw new CN("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){Km(()=>{this.layers.forEach(e=>{e.stateful&&e.resetStates()})})}}function RR(e,t,n){const a=t.length;if(null==e||Array.isArray(e)&&0===e.length)return t.map(e=>null);if(1===a)return Array.isArray(e)&&1===e.length?e:"object"===typeof e&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==a)throw new Error("Provided ".concat(n," is an array of ").concat(e.length," ")+"element(s), but the model has ".concat(a," outputs. ")+"Make sure a set of weights is provided for each model output.");return e}if("object"===typeof e&&Object.keys(e).length>0&&"object"===typeof e[Object.keys(e)[0]]){const n=[];return t.forEach(t=>{t in e?n.push(e[t]):n.push(null)}),n}throw new Error("The model has multiple (".concat(a,") outputs, ")+"so ".concat(n," must be either an array with ")+"".concat(a," elements or an object with ").concat(t," keys. ")+"Provided ".concat(n," not understood: ").concat(JSON.stringify(e)))}function _R(e,t){return RR(e,t,"classWeight")}async function AR(e,t,n,a){if(null!=t||null!=a)throw new Error("Support sampleWeight is not implemented yet");if(null!=n){const t=Km(()=>{if(1===e.shape.length)return ay(e);if(2===e.shape.length){if(e.shape[1]>1){return Pb(e,1)}if(1===e.shape[1])return tx(e,[e.shape[0]]);throw new Error("Encountered unexpected last-dimension size (".concat(e.shape[1],") ")+"during handling of class weights. The size is expected to be >= 1.")}throw new Error("Unexpected rank of target (y) tensor (".concat(e.rank,") during ")+"handling of class weights. The rank is expected to be 1 or 2.")}),a=Array.from(await t.data());Xm(t);const s=[];return a.forEach(e=>{if(null==n[e])throw new Error("classWeight must contain all classes in the training data. "+"The class ".concat(e," exists in the data but not in ")+"classWeight");s.push(n[e])}),ik(s,"float32")}return null}function MR(e,t){return cy(e,t)}function PR(e,t){let n,a;const s=t;n=s.xs,a=s.ys,yu(null!=n&&null!=a,()=>"A Dataset iterator for fitDataset() is expected to generate objects of the form `{xs: xVal, ys: yVal}`, where the two values may be `tf.Tensor`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates "+"".concat(t));const r=DR("input",e.inputNames,n),i=DR("output",e.outputNames,a),o=r[0].shape[0];yu(r.length===e.inputs.length,()=>"LayersModel has ".concat(e.inputs.length," inputs, but the dataset ")+"provides ".concat(r.length," inputs.  (Expected input keys: ")+"".concat(JSON.stringify(e.inputNames),")")),yu(i.length===e.outputs.length,()=>"LayersModel has ".concat(e.outputs.length," outputs, but the dataset ")+"provides ".concat(i.length," outputs.  (Expected output keys: ")+"".concat(JSON.stringify(e.outputNames),")"));for(let c=0;c<r.length;c++)yu(r[c].shape[0]===o,()=>"Batch size mismatch: input "+"".concat(e.inputNames[c]," has ").concat(r[c].shape[0],"; ")+"expected  ".concat(o," based on input ").concat(e.inputNames[0],"."));for(let c=0;c<i.length;c++)yu(i[c].shape[0]===o,()=>"Batch size mismatch: output "+"".concat(e.outputNames[c]," has ").concat(i[c].shape[0],"; ")+"expected  ".concat(o," based on input ").concat(e.inputNames[0],"."));return{xs:r,ys:i}}function DR(e,t,n){if(n instanceof im)return[n];if(Array.isArray(n))return yu(n.length===t.length,()=>"Received an array of ".concat(n.length," Tensors, but expected ").concat(t.length," to match the ").concat(e," keys ").concat(t,".")),n;{const a=[];for(const s of t){if(null==n[s])throw new CN("The feature data generated by the dataset lacks the required "+"".concat(e," key '").concat(s,"'."));a.push(n[s])}return a}}async function OR(e,t,n){const a=null!=n.batchesPerEpoch;if(yu(null!=e.optimizer,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),yu(null!=n,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),yu(null!=n.epochs&&n.epochs>0&&Number.isInteger(n.epochs),()=>"For fitDataset(), config.epochs is expected to be a positive "+"integer, but got ".concat(n.epochs)),yu(!a||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),()=>"For fitDataset(), config.batchesPerEpoch is expected to be a "+"positive integer if specified, but got ".concat(n.batchesPerEpoch)),yu(null==n.validationSplit,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{const s=null!=n.validationData;let r,i;if(s)if(FR(n.validationData))yu(null==n.validationBatches||n.validationBatches>0&&Number.isInteger(n.validationBatches),()=>"For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, "+"but got ".concat(n.validationBatches));else{const e=function(e){if(3===e.length)throw new IN("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}(n.validationData);r=e.xs,i=e.ys}const o=e.makeTrainFunction(),c=e.getDedupedMetricsNames();let l;l=s?c.slice().concat(c.map(e=>"val_"+e)):c.slice();const u=GE(n.callbacks,n.yieldEvery),h=null==n.verbose?1:n.verbose,{callbackList:d,history:p}=KE(u,h,n.epochs,null,null,function(e,t){let n=null;null!=t.batchesPerEpoch?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size);return n}(t,n),null,s,l);d.setModel(e),e.history=p,await d.onTrainBegin(),e.stopTraining_=!1;let f=null==n.initialEpoch?0:n.initialEpoch,m=await t.iterator();for(;f<n.epochs;){const l={};await d.onEpochBegin(f);let u=0,h=0;for(a||(m=await t.iterator());!a||u<n.batchesPerEpoch;){const t=await m.next();if(a&&t.done){console.warn("You provided `batchesPerEpoch` as "+"".concat(n.batchesPerEpoch,", ")+"but your dataset iterator ran out of data after "+"".concat(u," batches; ")+"interrupting training. Make sure that your dataset can generate at least `batchesPerEpoch * epochs` batches (in this case, "+"".concat(n.batchesPerEpoch*n.epochs," batches). ")+"You may need to use the repeat() function when building your dataset.");break}if(null!=t.value){const{xs:a,ys:s}=PR(e,t.value),r={};r.batch=h,r.size=a[0].shape[0],await d.onBatchBegin(h,r);const i=[];if(null!=n.classWeight){const t=_R(n.classWeight,e.outputNames);for(let e=0;e<t.length;++e)i.push(await AR(s[e],null,t[e]))}const l=a.concat(s).concat(i),p=o(l);Xm(l);for(let e=0;e<c.length;++e){const t=c[e],n=p[e];r[t]=n,Ym(n)}await d.onBatchEnd(h,r),zE(r),h++,u++}if(a?u>=n.batchesPerEpoch:t.done){if(s){let t;t=FR(n.validationData)?MN(await e.evaluateDataset(n.validationData,{batches:n.validationBatches})):MN(e.evaluate(r,i,{batchSize:null==n.validationBatchSize?32:n.validationBatchSize,verbose:0}));for(let n=0;n<e.metricsNames.length;++n)l["val_".concat(e.metricsNames[n])]=t[n]}break}if(e.stopTraining_)break}if(await d.onEpochEnd(f,l),f++,e.stopTraining_)break}return await d.onTrainEnd(),await e.history.syncData(),e.history}finally{e.isTraining=!1}}function FR(e){return"function"===typeof e.iterator}function LR(e){yu(e>0&&Number.isInteger(e),()=>"batchSize is required to be a positive integer, but got ".concat(e))}function zR(e,t,n){return null==e?[null]:Array.isArray(e)?e.map(e=>wT(e,t,n-t)):wT(e,t,n-t)}function BR(e,t){return Km(()=>null==e?null:Array.isArray(e)?e.map(e=>BR(e,t)):RT(e,"int32"===t.dtype?t:ny(t,"int32")))}function jR(e,t){const n=[];let a=0,s=null;for(;a<e;)s=a+t,s>=e&&(s=e),n.push([a,s]),a=s;return n}function WR(e){const t=[];e instanceof im&&(e=[e]);for(let n=0;n<e.length;++n){const a=e[n];if(1===a.rank)t.push(vT(a,1));else{if(0===a.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(a)}}return t}function VR(e,t){if(null==e)return;const n=[];if(t instanceof im)n.push(t.id);else if(Array.isArray(t))t.forEach(e=>n.push(e.id));else if(null!=t)for(const s in t){const e=t[s];n.push(e.id)}const a=[];if(e instanceof im)-1===n.indexOf(e.id)&&a.push(e);else if(Array.isArray(e))e.forEach(e=>{-1===n.indexOf(e.id)&&a.push(e)});else if(null!=e)for(const s in e){const t=e[s];-1===n.indexOf(t.id)&&a.push(t)}a.forEach(e=>{e.isDisposed||e.dispose()})}function UR(e){return Array.isArray(e)}function HR(e){return!function(e){return e instanceof im}(e)&&!UR(e)}function GR(e,t,n){let a,s=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"";if(null==t||0===t.length){if(null!=e){let t=!1;if(UR(e)&&e.length>0)t=!0;else if(HR(e)){for(const n in e)if(e.hasOwnProperty(n)){t=!0;break}}else t=!0;if(t)throw new CN("Error when checking model ".concat(r," expected no data, ")+"but got ".concat(e))}return[]}if(null==e)return t.map(e=>null);if(HR(e)){a=[];for(const n of t){if(null==e[n])throw new CN('No data provided for "'.concat(n,'". Need data for each key in: ')+"".concat(t));a.push(e[n])}}else if(UR(e)){if(e.length!==t.length)throw new CN("Error when checking model ".concat(r,": the Array of ")+"Tensors that you are passing to your model is not the size the "+"model expected. Expected to see ".concat(t.length," Tensor(s), but ")+"instead got the following list of Tensor(s): ".concat(e));a=e}else{if(t.length>1)throw new CN("The model ".concat(r," expects ").concat(t.length," Tensor(s), ")+"but only received one Tensor. Found: Tensor with shape ".concat(e.shape));a=[e]}if(a=WR(a),null!=n)for(let i=0;i<t.length;++i){if(null==n[i])continue;const e=a[i];if(e.shape.length!==n[i].length)throw new CN("Error when checking ".concat(r,": expected ").concat(t[i]," ")+"to have ".concat(n[i].length," dimension(s). but got array with ")+"shape ".concat(e.shape));for(let t=0;t<n[i].length;++t){if(0===t&&!s)continue;const a=e.shape[t],o=n[i][t];if(null!=o&&o>=0&&a!==o)throw new CN("".concat(r," expected a batch of elements where each ")+"example has shape [".concat(n[i].slice(1,n[i].length),"] ")+"(i.e.,tensor shape [*,".concat(n[i].slice(1,n[i].length),"])")+" but the ".concat(r," received an input with ").concat(e.shape[0])+" examples, each with shape [".concat(e.shape.slice(1,e.shape.length),"]")+" (tensor shape [".concat(e.shape,"])"))}}return a}function qR(e,t,n){let a,s=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"";if(Array.isArray(e)){if(e.length!==t.length)throw new CN("Error when checking model ".concat(r,": the Array of ")+"Tensors that you are passing to your model is not the size the "+"the model expected. Expected to see ".concat(t.length," Tensor(s),")+" but instead got ".concat(e.length," Tensors(s)."));a=e}else{if(t.length>1)throw new CN("The model expects ".concat(t.length," ").concat(r," Tensors, ")+"but only received one Tensor. Found: array with shape "+"".concat(JSON.stringify(e.shape),"."));a=[e]}if(null!=n)for(let i=0;i<t.length;++i){if(null==n[i])continue;const e=a[i];if(e.shape.length!==n[i].length)throw new CN("Error when checking ".concat(r,": expected ").concat(t[i]," ")+"to have ".concat(n[i].length," dimension(s), but got array with ")+"shape ".concat(JSON.stringify(e.shape)));for(let a=0;a<n[i].length;++a){if(0===a&&!s)continue;const o=e.shape[a],c=n[i][a];if(null!=c&&c!==o)throw new CN("Error when checking ".concat(r,": expected ")+"".concat(t[i]," to have shape ").concat(JSON.stringify(n[i])," but ")+"got array with shape ".concat(JSON.stringify(e.shape),"."))}}}class KR extends ER{constructor(e){super(e),this.isTraining=!1}summary(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log;if(!this.built)throw new CN("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");vR(this,e,t,n)}compile(e){if(null==e.loss&&(e.loss=[]),this.loss=e.loss,"string"===typeof e.optimizer)this.optimizer_=function(e){const t={Adagrad:()=>XS.adagrad(.01),Adadelta:()=>XS.adadelta(1,.95,bT()),Adam:()=>XS.adam(.001,.9,.999,bT()),Adamax:()=>XS.adamax(.002,.9,.999,bT(),0),RMSProp:()=>XS.rmsprop(.001,.9,0,bT()),SGD:()=>XS.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new CN("Unknown Optimizer ".concat(e))}(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof xy))throw new CN("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(Array.isArray(e.loss)||"string"===typeof e.loss||"function"===typeof e.loss)if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new CN("When passing an Array as loss, it should have one entry per "+"model output. The model has ".concat(this.outputs.length," output(s), ")+"but you passed loss=".concat(e.loss,"."));const n=e.loss;t=n.map(e=>iR(e))}else{const n=iR(e.loss);this.outputs.forEach(e=>{t.push(n)})}else{e.loss=e.loss;for(const t in e.loss)if(-1===this.outputNames.indexOf(t))throw new CN('Unknown entry in loss dictionary: "'.concat(t,'". ')+"Only expected the following keys: ".concat(this.outputNames));for(const n of this.outputNames)null==e.loss[n]&&console.warn('Output "'.concat(n,'" is missing from loss dictionary. We assume ')+"this was done on purpose, and we will not be expecting data "+"to be passed to ".concat(n," during training")),t.push(iR(e.loss[n]))}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let r=0;r<this.outputs.length;++r){const e=this.internalOutputShapes[r],t=this.outputNames[r];this.feedOutputNames.push(t),this.feedOutputShapes.push(e),this.feedLossFns.push(this.lossFunctions[r])}const n=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],oT("loss",()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;const t=this.lossFunctions[e];this.outputs.length>1&&(this.metricsTensors.push([t,e]),this.metricsNames.push(this.outputNames[e]+"_loss"))}});const a=function(e,t){if(null==e||Array.isArray(e)&&0===e.length)return t.map(e=>[]);let n;if("string"===typeof e||"function"===typeof e)n=[e];else{if(!Array.isArray(e)&&"object"!==typeof e)throw new TypeError("Type of metrics argument not understood. Expected an string,"+"function, Array, or Object, found: ".concat(e));n=e}if(Array.isArray(n))return t.map(e=>n);{const e=[];for(const a of t){let t=n.hasOwnProperty(a)?n[a]:[];Array.isArray(t)||(t=[t]),e.push(t)}return e}}(e.metrics,this.outputNames),s=(e,t,n)=>{this.outputNames.length>1&&(t=this.outputNames[e]+"_"+t),this.metricsNames.push(t),this.metricsTensors.push([n,e])};oT("metric",()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;(t=>{let n,a,r;for(const i of t){if("string"===typeof i&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(i)){const t=this.internalOutputShapes[e];let s;1===t[t.length-1]||this.lossFunctions[e]===nR?-1!==["accuracy","acc"].indexOf(i)?a=oR:-1!==["crossentropy","ce"].indexOf(i)&&(a=uR):this.lossFunctions[e]===tR?-1!==["accuracy","acc"].indexOf(i)?a=hR:-1!==["crossentropy","ce"].indexOf(i)&&(a=pR):-1!==["accuracy","acc"].indexOf(i)?a=cR:-1!==["crossentropy","ce"].indexOf(i)&&(a=dR),-1!==["accuracy","acc"].indexOf(i)?s="acc":-1!==["crossentropy","ce"].indexOf(i)&&(s="ce"),r=a,n=""+s}else{const e=mR(i);r=e,n=""+gR(i)}let t;oT(n,()=>{t=r}),s(e,n,t)}})(a[e])}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const a=null==n.batchSize?32:n.batchSize;LR(a);const s=this.standardizeUserDataXY(e,t,!0,a);try{const e=s[0].concat(s[1]);this.makeTestFunction();const t=this.testFunction;return AN(this.testLoop(t,e,a,n.verbose,n.steps))}finally{VR(s[0],e),VR(s[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),async function(e,t,n){const a=null!=(n=n||{}).batches,s=e.testFunction;let r=[];if(n.verbose>0)throw new IN("Verbose mode is not implemented yet.");yu(!a||n.batches>0&&Number.isInteger(n.batches),()=>"Test loop expects `batches` to be a positive integer, but "+"received ".concat(JSON.stringify(n.batches)));const i="function"===typeof t.next?t:await t.iterator();let o=0,c=0;for(;!a||c<n.batches;){const t=await i.next();if(r=Km(()=>{if(t.value){const{xs:n,ys:a}=PR(e,t.value),i=n.concat(a),l=Km(()=>s(i));if(Xm(i),0===c)for(let e=0;e<l.length;++e)r.push(py(0));const u=i[0].shape[0];for(let e=0;e<l.length;++e){const t=l[e],n=r[e];r[e]=Km(()=>ry(r[e],cy(u,t))),c>0&&Xm(n)}Xm(l),o+=u,++c}return r}),t.done){a&&console.warn("Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least `batches` "+"batches (in this case, ".concat(n.batches," batches). ")+"You may need to use the repeat() function when building your dataset.");break}}for(let l=0;l<r.length;++l){const e=r[l];r[l]=oy(r[l],o),Xm(e)}return AN(r)}(this,e,t)}checkNumSamples(e,t,n){let a,s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"steps";if(null!=n){if(a=null,null!=t)throw new CN("If ".concat(s," is set, batchSize must be null or undefined.")+"Got batchSize = ".concat(t))}else{if(null==e)throw new CN("Either the input data should have a defined shape, or "+"".concat(s," shoud be specified."));a=Array.isArray(e)?e[0].shape[0]:e.shape[0]}return a}execute(e,t){if(Array.isArray(t)&&0===t.length)throw new CN("`outputs` is an empty Array, which is not allowed.");const n=Array.isArray(t),a=n?t:[t],s=this.retrieveSymbolicTensors(a),r=new vE;if(e instanceof im&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new CN("The number of inputs provided (".concat(e.length,") ")+"does not match the number of inputs of this model "+"(".concat(this.inputs.length,")."));for(let t=0;t<this.inputs.length;++t)r.add(this.inputs[t],e[t])}else for(const o of this.inputs){const t=e[o.name];if(null==t)throw new CN("No value is provided for the model's input ".concat(o.name));r.add(o,t)}const i=SE(s,r);return n?i:i[0]}retrieveSymbolicTensors(e){const t=EN(null,e.length);let n=e.length;for(const a of this.layers){const s=Array.isArray(a.output)?a.output:[a.output],r=s.map(e=>e.name);for(let a=0;a<e.length;++a){const i=r.indexOf(e[a]);if(-1!==i&&(t[a]=s[i],n--),0===n)break}if(0===n)break}if(n>0){const n=[];throw t.forEach((t,a)=>{null==t&&n.push(e[a])}),new CN("Cannot find SymbolicTensors for output name(s): "+"".concat(JSON.stringify(n)))}return t}predictLoop(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:32,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return Km(()=>{const a=this.checkNumSamples(e);if(n)throw new IN("Verbose predictLoop() is not implemented yet.");const s=jR(a,t),r=this.outputs.map(e=>[]);for(let t=0;t<s.length;++t){Km(()=>{const n=s[t][0],a=s[t][1],r=zR(e,n,a),i=[];if(Array.isArray(r))for(let e=0;e<r.length;++e)i.push({key:this.inputs[e],value:r[e]});else i.push({key:this.inputs[0],value:r});const o=new vE(i);return SE(this.outputs,o)}).forEach((e,t)=>r[t].push(e))}return AN(r.map(e=>sx(e,0)))})}predict(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=WR(e);qR(n,this.inputNames,this.feedInputShapes,!1);try{const e=null==t.batchSize?32:t.batchSize;return LR(e),this.predictLoop(n,e)}finally{VR(n,e)}}predictOnBatch(e){qR(e,this.inputNames,this.feedInputShapes,!0);const t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t){let n=arguments.length>3?arguments[3]:void 0;if(null==this.optimizer_)throw new SN("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const a=[];for(let s=0;s<this.feedOutputShapes.length;++s){const e=this.feedOutputShapes[s];this.feedLossFns[s]===tR?a.push(e.slice(0,e.length-1).concat([1])):a.push(e)}if(function(e,t){const n=jN(e.map(e=>e.shape[0]));n.sort();const a=jN(t.map(e=>e.shape[0]));if(a.sort(),n.length>1)throw new CN("All input Tensors (x) should have the same number of samples. Got array shapes: "+"".concat(JSON.stringify(e.map(e=>e.shape))));if(a.length>1)throw new CN("All target Tensors (y) should have the same number of samples. Got array shapes: "+"".concat(JSON.stringify(t.map(e=>e.shape))));if(n.length>0&&a.length>0&&!ku(n,a))throw new CN("Input Tensors should have the same number of samples as target "+"Tensors. Found ".concat(n[0]," input sample(s) and ").concat(a[0]," target ")+"sample(s).")}(e=GR(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=GR(t,this.feedOutputNames,a,!1,"target")),function(e,t,n){const a=[QE,nR,eR];for(let s=0;s<e.length;++s){const r=e[s],i=t[s],o=n[s];if(null!=i){if(i===eR&&1===r.shape[r.shape.length-1])throw new CN("You are passing a target array of shape ".concat(r.shape," while using ")+"a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].");if(-1!==a.indexOf(i)){const e=r.shape.slice(1),t=o.slice(1);for(let n=0;n<e.length;++n){const a=e[n],s=t[n];if(null!=s&&a!==s)throw new CN("A target Tensor with shape ".concat(r.shape," was passed for an ")+"output of shape ".concat(o,", while using a loss function that ")+"expects targets to have the same shape as the output.")}}}}}(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=n&&n>0&&e[0].shape[0]%n!==0)throw new CN("In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size "+"".concat(n,". Found: ").concat(e[0].shape[0]," sample(s)."));return[e,t]}async standardizeUserData(e,t,n,a){let s=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],r=arguments.length>5?arguments[5]:void 0;const[i,o]=this.standardizeUserDataXY(e,t,s,r);if(null!=n)throw new Error("sample weight is not supported yet.");let c=null;if(null!=a){const e=_R(a,this.outputNames);c=[];for(let t=0;t<e.length;++t)c.push(await AR(o[t],null,e[t]))}return[i,o,c]}testLoop(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,s=arguments.length>4?arguments[4]:void 0;return Km(()=>{const r=this.checkNumSamples(t,n,s,"steps"),i=[];if(a>0)throw new IN("Verbose mode is not implemented yet.");if(null!=s)throw new IN("steps mode in testLoop() is not implemented yet");{const a=jR(r,n),s=ik(gT(0,r));for(let n=0;n<a.length;++n){const r=a[n][0],o=a[n][1],c=wT(s,r,o-r),l=BR(t,c),u=e(l);if(0===n)for(let e=0;e<u.length;++e)i.push(py(0));for(let e=0;e<u.length;++e){const t=u[e];i[e]=ry(i[e],cy(o-r,t))}}for(let e=0;e<i.length;++e)i[e]=oy(i[e],r)}return i})}getDedupedMetricsNames(){const e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){const a=e[n];let s=a;if(_N(e,a)>1){const t=_N(e.slice(0,n),a);s+="_".concat(t)}t.push(s)}return t}makeTrainFunction(){return e=>{const t=[],n=e.slice(0,this.inputs.length),a=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),r=[],i=this.collectedTrainableWeights.map(e=>e.read());return[this.optimizer_.minimize(()=>{const e=[];for(let t=0;t<this.inputs.length;++t)e.push({key:this.inputs[t],value:n[t]});const i=new vE(e),o=SE(this.outputs,i,{training:!0});let c;for(let n=0;n<this.lossFunctions.length;++n){let e=(0,this.lossFunctions[n])(a[n],o[n]);null!=s[n]&&(e=MR(e,s[n]));const r=Hv(e);t.push(r),c=0===n?e:ry(c,e)}for(let n=0;n<this.metricsTensors.length;++n){let e;if(this.outputs.length>1&&n<this.outputs.length)e=t[n];else{const t=this.metricsTensors[n][0],s=this.metricsTensors[n][1];e=Hv(t(a[s],o[s]))}Ym(e),r.push(e)}return c=Hv(c),this.calculateLosses().forEach(e=>{c=ry(c,e)}),c},!0,i)].concat(r)}}makeTestFunction(){this.testFunction=e=>Km(()=>{const t=[];let n;const a=e.slice(0,this.inputs.length),s=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),r=[];for(let e=0;e<this.inputs.length;++e)r.push({key:this.inputs[e],value:a[e]});const i=new vE(r),o=SE(this.outputs,i);for(let e=0;e<this.lossFunctions.length;++e){const a=this.lossFunctions[e],r=Hv(a(s[e],o[e]));n=0===e?r:ry(n,r),t.push(n)}for(let e=0;e<this.metricsTensors.length;++e){const n=this.metricsTensors[e][0],a=this.metricsTensors[e][1],r=Hv(n(s[a],o[a]));t.push(r)}return t})}async fit(e,t){let n,a,s,r,i,o,c,l,u,h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;try{const d=null==h.batchSize?32:h.batchSize;LR(d);const p=!1,f=await this.standardizeUserData(e,t,h.sampleWeight,h.classWeight,p,d);n=f[0],a=f[1],u=f[2];let m,g=!1;if(null!=h.validationData&&h.validationData.length>0){if(g=!0,2!==h.validationData.length)throw 3===h.validationData.length?new IN("validationData including sample weights is not supported yet."):new CN("When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; "+"".concat(h.validationData," is invalid."));i=h.validationData[0],o=h.validationData[1];const e=!0,t=await this.standardizeUserData(i,o,null,null,e,d);c=t[0],l=t[1],m=c.concat(l)}else if(null!=h.validationSplit&&h.validationSplit>0&&h.validationSplit<1){g=!0;const e=Math.floor(n[0].shape[0]*(1-h.validationSplit)),t=n[0].shape[0];c=zR(n,e,t),s=n,n=zR(n,0,e),l=zR(a,e,t),r=a,a=zR(a,0,e),m=c.concat(l)}else null!=h.validationSteps&&(g=!0);const y=n.concat(a).concat(u);this.checkTrainableWeightsConsistency();const b=this.makeTrainFunction(),x=this.getDedupedMetricsNames();let v,w;g?(this.makeTestFunction(),v=this.testFunction,w=x.slice().concat(x.map(e=>"val_"+e))):(v=null,m=[],w=x.slice());const k=GE(h.callbacks,h.yieldEvery);return await this.fitLoop(b,y,x,d,h.epochs,h.verbose,k,v,m,h.shuffle,w,h.initialEpoch,null,null)}finally{this.isTraining=!1,VR(n,e),VR(a,t),VR(s,e),VR(r,t),VR(c,i),VR(l,o),null!=u&&Xm(u)}}async fitLoop(e,t,n,a,s,r,i,o,c,l,u,h,d,p){null==a&&(a=32),null==s&&(s=1),null==l&&(l=!0),null==h&&(h=0);let f=!1;if(null!=o&&null!=c&&(f=!0),null!=p&&(f=!0,null==d))throw new CN("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const m=this.checkNumSamples(t,a,d,"steps_per_epoch");let g;null!=m&&(g=gT(0,m)),null==r&&(r=1);const{callbackList:y,history:b}=KE(i,r,s,h,m,d,a,f,u);y.setModel(this),this.history=b,await y.onTrainBegin(),this.stopTraining_=!1;for(let x=h;x<s;++x){await y.onEpochBegin(x);const s={};if(null!=d)throw new IN("stepsPerEpoch mode is not implemented yet.");{if("batch"===l)throw new IN("batch shuffling is not implemneted yet");l&&du(g);const r=ik(g),i=jR(m,a);for(let l=0;l<i.length;++l){const u={};if(await y.onBatchBegin(l,u),Km(()=>{const h=i[l][0],d=i[l][1],p=wT(r,h,d-h);u.batch=l,u.size=d-h;const m=BR(t,p),g=e(m);for(let e=0;e<n.length;++e){const t=n[e],a=g[e];u[t]=a,Ym(a)}if(l===i.length-1&&f){const e=this.testLoop(o,c,a);for(let t=0;t<n.length;++t){const a=n[t],r=e[t];Ym(r),s["val_"+a]=r}}}),await y.onBatchEnd(l,u),zE(u),this.stopTraining_)break}r.dispose()}if(await y.onEpochEnd(x,s),this.stopTraining_)break}return await y.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return OR(this,e,t)}async trainOnBatch(e,t){const n=await this.standardizeUserData(e,t),a=n[0],s=n[1],r=this.makeTrainFunction()(a.concat(s)),i=[];for(const o of r){const e=await o.data();i.push(e[0])}return Xm(r),VR(n[0],e),VR(n[1],t),AN(i)}getNamedWeights(e){const t=[],n=null!=e&&e.trainableOnly,a=n?this.trainableWeights:this.weights,s=this.getWeights(n);for(let r=0;r<a.length;++r)n&&!a[r].trainable||t.push({name:a[r].originalName,tensor:s[r]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(0===e.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const t=qm().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-qm().numTensors}return e}getLossIdentifiers(){let e;if("string"===typeof this.loss)e=PN(this.loss);else if(Array.isArray(this.loss)){for(const e of this.loss)if("string"!==typeof e)throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(e=>PN(e))}else{const t=Object.keys(this.loss);e={};const n=this.loss;for(const a of t){if("string"!==typeof n[a])throw new Error("Serialization of non-string loss is not supported.");e[a]=PN(n[a])}}return e}getMetricIdentifiers(){if("string"===typeof this.metrics||"function"===typeof this.metrics)return[PN(gR(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>PN(gR(e)));{const e={};for(const t in this.metrics)e[t]=PN(gR(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(null!=e.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=e.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=e.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const t=XE(IR(e.optimizer_config));let n,a;if("string"===typeof e.loss)n=DN(e.loss);else if(Array.isArray(e.loss))n=e.loss.map(e=>DN(e));else if(null!=e.loss){n={};for(const t in e.loss)n[t]=DN(e.loss[t])}if(Array.isArray(e.metrics))a=e.metrics.map(e=>DN(e));else if(null!=e.metrics){a={};for(const t in e.metrics)a[t]=DN(e.metrics[t])}this.compile({loss:n,metrics:a,optimizer:t})}async save(e,t){if("string"===typeof e){const t=vg(e);if(0===t.length)throw new CN("Cannot find any save handlers for URL '".concat(e,"'"));if(t.length>1)throw new CN("Found more than one (".concat(t.length,") save handlers for ")+"URL '".concat(e,"'"));e=t[0]}if(null==e.save)throw new CN("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const n=await eg(this.getNamedWeights(t)),a={modelTopology:this.toJSON(null,!1),format:"layers-model",generatedBy:"TensorFlow.js tfjs-layers v".concat(TR),convertedBy:null};if(null!=t&&t.includeOptimizer&&null!=this.optimizer){a.trainingConfig=this.getTrainingConfig();const e="optimizer",{data:t,specs:s}=await eg(await this.optimizer.getWeights(),e);n.specs.push(...s),n.data=ug([n.data,t])}if(null!=this.userDefinedMetadata){const e=!0;bR(this.userDefinedMetadata,this.name,e),a.userDefinedMetadata=this.userDefinedMetadata}return a.weightData=n.data,a.weightSpecs=n.specs,e.save(a)}setUserDefinedMetadata(e){bR(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}KR.className="Model",by(KR);class XR extends KR{}XR.className="Functional",by(XR);class YR extends KR{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=null!=e.name?e.name:QN("sequential_"),null!=e.layers)for(const t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(e=>e<0))throw new CN("Negative dimension size caused by adding layer "+"".concat(e.name," with input shape [")+"".concat(e.inboundNodes[0].inputTensors[0].shape,"]"))}add(e){const t=e instanceof YR||e instanceof KR;let n;if(t){if(n=e,1!==n.outputs.length)throw new CN("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==n.inputs.length)throw new CN("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===e.inboundNodes.length){if(null==e.batchInputShape)throw new CN("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const t=function(e){if(null==e.batchShape&&null==e.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=e.batchShape&&null!=e.shape)throw new CN("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;null!=e.shape&&null==t&&(t=[null].concat(e.shape));let n=e.dtype;return null==n&&(n="float32"),new xE({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(t)}if(t)this.outputs=n.outputs,this.inputs=n.inputs;else{if(1!==e.inboundNodes.length)throw new CN("A layer added to a Sequential model must not already be "+"connected somewhere else. LayersModel received layer ".concat(e.name," ")+"which has ".concat(e.inboundNodes.length," pre-existing inbound ")+"connections.");if(1!==e.inboundNodes[0].outputTensors.length)throw new CN("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=bE(this.outputs[0])}this.inboundNodes=[],new mE({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:EN(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(e=>e.shape),outputShapes:this.outputs[0].shape})}else{const t=e.apply(this.outputs[0]);if(Array.isArray(t))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[t],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return null==this.model&&this.build(),this.model.call(e,t)}build(e){if(iE(e),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new KR({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log;this.built||this.build(),super.summary(e,t,n)}setWeights(e){null==this.model&&this.build(),this.model.setWeights(e)}evaluate(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this.built)throw new SN("The model needs to be compiled before being used.");return this.model.evaluate(e,t,n)}async evaluateDataset(e,t){if(!this.built)throw new SN("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return null==this.model&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this.built)throw new SN("The model needs to be compiled before being used.");return this.model.fit(e,t,n)}async fitDataset(e,t){if(!this.built)throw new SN("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t){let n,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s={};if(t instanceof Array){if(null==t[0].className||"Merge"===t[0].className)throw new CN("Legacy serialization format not supported yet.");n=t}else yu(null!=t.layers,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),n=t.layers,delete t.layers,s=t;const r=new e(s);if(!(r instanceof YR))throw new IN("Sequential.fromConfig called on non-Sequential input: ".concat(r));for(const i of n){const e=XE(i,void 0,a);a&&e.setFastWeightInitDuringBuild(!0),r.add(e)}return r}set stopTraining(e){if(null==this.model)throw new CN("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(null==this.model)throw new CN("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const t of this.layers){const n={};n.className=t.getClassName(),n.config=t.getConfig(),e.push(n)}return{name:this.name,layers:e}}}YR.className="Sequential",by(YR);class QR extends gy{getConfig(){return{}}}class ZR extends QR{apply(e){return function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(1!==t)throw new IN("Support for alpha values other than 1 (".concat(t,") is not implemented ")+"yet.");return qx(e)}(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:1)}}ZR.className="elu",by(ZR);class JR extends QR{apply(e){return zw(e)}}JR.className="selu",by(JR);class $R extends QR{apply(e){return Rw(e)}}$R.className="relu",by($R);class e_ extends QR{apply(e){return Km(()=>Xv(6,Rw(e)))}}e_.className="relu6",by(e_);class t_ extends QR{apply(e){return e}}t_.className="linear",by(t_);class n_ extends QR{apply(e){return ix(e)}}n_.className="sigmoid",by(n_);class a_ extends QR{apply(e){return function(e){return Km(()=>{const t=ry(.5,cy(.2,e));return vx(t,0,1)})}(e)}}a_.className="hardSigmoid",by(a_);class s_ extends QR{apply(e){return _v(e)}}s_.className="softplus",by(s_);class r_ extends QR{apply(e){return function(e){return Km(()=>oy(e,ry(Ny(e),1)))}(e)}}r_.className="softsign",by(r_);class i_ extends QR{apply(e){return cx(e)}}i_.className="tanh",by(i_);class o_ extends QR{apply(e){return Xw(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1)}}o_.className="softmax",by(o_);class c_ extends QR{apply(e){return Mv(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1)}}c_.className="logSoftmax",by(c_);class l_ extends QR{apply(e){return Km(()=>Km(()=>{const t=Math.sqrt(2),n=cy(.5,ry(1,Xx(oy(e,t))));return cy(e,n)}))}}l_.className="gelu",by(l_);class u_ extends QR{apply(e){return Km(()=>cy(.5,cy(e,ry(1,cx(cy(ly(oy(2,Math.PI)),ry(e,cy(.044715,Sy(e,3)))))))))}}u_.className="gelu_new",by(u_);class h_ extends QR{apply(e){return Km(()=>cy(e,cx(_v(e))))}}h_.className="mish",by(h_);class d_ extends QR{apply(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return Km(()=>cy(ix(cy(e,t)),e))}}function p_(e){return e.getClassName()}function f_(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return zN(e,yy.getMap().classNameMap,t,"activation")}function m_(e){if(null==e){const e={className:"linear",config:{}};return f_(e)}if("string"===typeof e){const t={};return t.className=e,t.config={},f_(t)}return e instanceof QR?e:f_(e)}function g_(e){if(null!=e&&"object"!==typeof e)throw new Error("Argument to L1L2 regularizer's constructor is expected to be an "+"object, but received: ".concat(e))}d_.className="swish",by(d_);class y_ extends gy{}class b_ extends y_{constructor(e){super(),g_(e),this.l1=null==e||null==e.l1?.01:e.l1,this.l2=null==e||null==e.l2?.01:e.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(e){return Km(()=>{let t=Gv([1]);return this.hasL1&&(t=ry(t,rv(cy(this.l1,Ny(e))))),this.hasL2&&(t=ry(t,rv(cy(this.l2,_T(e))))),tx(t,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}}b_.className="L1L2",by(b_);const x_={l1l2:"L1L2"};function v_(e){return FN(e)}function w_(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return zN(e,yy.getMap().classNameMap,t,"regularizer")}function k_(e){if(null==e)return null;if("string"===typeof e){return w_({className:e in x_?x_[e]:e,config:{}})}return e instanceof y_?e:w_(e)}class S_ extends yE{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,null!=e&&(this.maxValue=e.maxValue)}call(e,t){e=rE(e);let n=Rw(e);return null!=this.maxValue&&(n=vx(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}}S_.className="ReLU",by(S_);class C_ extends yE{constructor(e){super(null==e?{}:e),this.DEFAULT_ALPHA=.3,null==e&&(e={}),this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=rE(e);return kv(n,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}C_.className="LeakyReLU",by(C_);class I_ extends yE{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==e&&(e={}),this.supportsMasking=!0,this.alphaInitializer=nE(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=k_(e.alphaRegularizer),this.alphaConstraint=FE(e.alphaConstraint),null==e.sharedAxes)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else{if("number"!==typeof e.sharedAxes)throw new CN("Expected sharedAxes to be a number or an array of numbers, "+"but got ".concat(e.sharedAxes));this.sharedAxes=[e.sharedAxes]}}build(e){const t=(e=iE(e)).slice(1);if(null!=this.sharedAxes)for(const a of this.sharedAxes)t[a-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const n={};if(null!=this.sharedAxes)for(let a=1;a<e.length;++a)n[a]=e[a];this.inputSpec=[new dE({ndim:e.length,axes:n})],this.built=!0}call(e,t){return e=rE(e),hw(e,this.alpha.read())}getConfig(){const e={alphaInitializer:tE(this.alphaInitializer),alphaRegularizer:v_(this.alphaRegularizer),alphaConstraint:DE(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}}I_.className="PReLU",by(I_);class N_ extends yE{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA=1,null==e&&(e={}),null!=e.alpha&&e.alpha!==this.DEFAULT_ALPHA)throw new IN("Non-default alpha value (".concat(e.alpha,") is not supported by the ")+"ELU layer yet.");this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=rE(e);return qx(n)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}N_.className="ELU",by(N_);class T_ extends yE{constructor(e){super(null==e?{}:e),this.DEFAULT_THETA=1,null==e&&(e={}),this.theta=null==e.theta?this.DEFAULT_THETA:e.theta}call(e,t){const n=rE(e);return cy(n,ny(gv(n,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}}T_.className="ThresholdedReLU",by(T_);class E_ extends yE{constructor(e){super(null==e?{}:e),this.DEFAULT_AXIS=1,null==e&&(e={}),this.softmax=(new o_).apply,this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis}call(e,t){return Km(()=>{let n=rE(e);const a=t.mask;if(null!=a){const e=cy(Cy(qv(n.shape),ny(a,n.dtype)),py(-1e9));n=ry(n,e)}return this.axis instanceof Array?this.axis.length>1?lv(Cy(n,Pv(n,this.axis,!0))):this.softmax(n,this.axis[0]):this.softmax(n,this.axis)})}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}function R_(e,t,n){if("number"===typeof e)return EN(e,t);if(e.length!==t)throw new CN("The ".concat(n," argument must be an integer or tuple of ").concat(t," integers.")+" Received: ".concat(e.length," elements."));for(let a=0;a<t;++a){const s=e[a];if(!dT(s))throw new CN("The ".concat(n," argument must be an integer or tuple of ").concat(t)+" integers. Received: ".concat(JSON.stringify(e)," including a")+" non-integer number ".concat(s))}return e}function __(e,t,n,a){if(null==e)return e;let s;return s="same"===n?e:e-(t+(t-1)*((arguments.length>4&&void 0!==arguments[4]?arguments[4]:1)-1))+1,Math.floor((s+a-1)/a)}function A_(e,t,n,a){if(null==e)return null;if("valid"===a)e=e*t+mT([n-t,0]);else{if("same"!==a)throw new CN("Unsupport padding mode: ".concat(a,"."));e*=t}return e}function M_(e,t){return Km(()=>(aT(t),"channelsFirst"===t?Ik(e,[0,2,3,1]):e))}function P_(e,t){return Km(()=>(aT(t),"channelsFirst"===t?Ik(e,[0,2,3,4,1]):e))}function D_(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",r=arguments.length>5?arguments[5]:void 0,i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:1;return Km(()=>{if(null==r&&(r="channelsLast"),aT(r),3!==e.shape.length)throw new CN("The input of a conv1dWithBias operation should be 3, but is "+"".concat(e.shape.length," instead."));if(3!==t.shape.length)throw new CN("The kernel for a conv1dWithBias operation should be 3, but is "+"".concat(t.shape.length," instead"));if(null!=n&&1!==n.shape.length)throw new CN("The bias for a conv1dWithBias operation should be 1, but is "+"".concat(n.shape.length," instead"));if("channelsFirst"===r&&(e=Ik(e,[0,2,1])),"causal"===s)throw new IN("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=Nx(e,t,a,"same"===s?"same":"valid","NWC",i);return null!=n&&(o=MT(o,n)),o})}function O_(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[1,1],s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",r=arguments.length>5?arguments[5]:void 0,i=arguments.length>6?arguments[6]:void 0,o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null;return Km(()=>{if(null==r&&(r="channelsLast"),aT(r),3!==e.rank&&4!==e.rank)throw new CN("conv2dWithBiasActivation expects input to be of rank 3 or 4, "+"but received ".concat(e.rank,"."));if(3!==t.rank&&4!==t.rank)throw new CN("conv2dWithBiasActivation expects kernel to be of rank 3 or 4, "+"but received ".concat(e.rank,"."));let c=M_(e,r);if("causal"===s)throw new IN("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return c=Bk({x:c,filter:t,strides:a,pad:"same"===s?"same":"valid",dilations:i,dataFormat:"NHWC",bias:n,activation:o}),"channelsFirst"===r&&(c=Ik(c,[0,3,1,2])),c})}function F_(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[1,1,1],s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",r=arguments.length>5?arguments[5]:void 0,i=arguments.length>6?arguments[6]:void 0;return Km(()=>{if(null==r&&(r="channelsLast"),aT(r),4!==e.rank&&5!==e.rank)throw new CN("conv3dWithBias expects input to be of rank 4 or 5, but received "+"".concat(e.rank,"."));if(4!==t.rank&&5!==t.rank)throw new CN("conv3dWithBias expects kernel to be of rank 4 or 5, but received "+"".concat(e.rank,"."));let o=P_(e,r);if("causal"===s)throw new IN("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=Rx(o,t,a,"same"===s?"same":"valid","NDHWC",i),null!=n&&(o=MT(o,n)),"channelsFirst"===r&&(o=Ik(o,[0,4,1,2,3])),o})}E_.className="Softmax",by(E_);class L_ extends yE{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",L_.verifyArgs(t),this.rank=e,HN(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new IN("Convolution layer for rank other than 1, 2, or 3 (".concat(this.rank,") is ")+"not implemented yet.");if(this.kernelSize=R_(t.kernelSize,e,"kernelSize"),this.strides=R_(null==t.strides?1:t.strides,e,"strides"),this.padding=null==t.padding?"valid":t.padding,sT(this.padding),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,aT(this.dataFormat),this.activation=m_(t.activation),this.useBias=null==t.useBias||t.useBias,this.biasInitializer=nE(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=FE(t.biasConstraint),this.biasRegularizer=k_(t.biasRegularizer),this.activityRegularizer=k_(t.activityRegularizer),this.dilationRate=R_(null==t.dilationRate?1:t.dilationRate,e,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new CN("dilationRate must be a number or an array of a single number for 1D convolution, but received "+"".concat(JSON.stringify(this.dilationRate)));if(2===this.rank){if("number"===typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new CN("dilationRate must be a number or array of two numbers for 2D "+"convolution, but received ".concat(JSON.stringify(this.dilationRate)))}else if(3===this.rank)if("number"===typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new CN("dilationRate must be a number or array of three numbers for 3D "+"convolution, but received ".concat(JSON.stringify(this.dilationRate)))}static verifyArgs(e){if(RN("kernelSize"in e,"required key 'kernelSize' not in config"),"number"!==typeof e.kernelSize&&!UN(e.kernelSize,"number",1,3))throw new CN("BaseConv expects config.kernelSize to be number or number[] with "+"length 1, 2, or 3, but received ".concat(JSON.stringify(e.kernelSize),"."))}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:p_(this.activation),useBias:this.useBias,biasInitializer:tE(this.biasInitializer),biasRegularizer:v_(this.biasRegularizer),activityRegularizer:v_(this.activityRegularizer),biasConstraint:DE(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}class z_ extends L_{constructor(e,t){super(e,t),this.kernel=null,z_.verifyArgs(t),this.filters=t.filters,HN(this.filters,"filters"),this.kernelInitializer=nE(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=FE(t.kernelConstraint),this.kernelRegularizer=k_(t.kernelRegularizer)}build(e){e=iE(e);const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new CN("The channel dimension of the input should be defined. "+"Found ".concat(e[t]));const n=e[t],a=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:n}}],this.built=!0}call(e,t){return Km(()=>{let t;e=rE(e);const n=null==this.bias?null:this.bias.read(),a=qN(this.activation.getClassName());if(null!=a&&2===this.rank)t=O_(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate,a);else{if(1===this.rank)t=D_(e,this.kernel.read(),n,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)t=O_(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new IN("convolutions greater than 3D are not implemented yet.");t=F_(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(t=this.activation.apply(t))}return t})}computeOutputShape(e){e=iE(e);const t=[],n="channelsLast"===this.dataFormat?e.slice(1,e.length-1):e.slice(2);for(let s=0;s<n.length;++s){const e=__(n[s],this.kernelSize[s],this.padding,this.strides[s],"number"===typeof this.dilationRate?this.dilationRate:this.dilationRate[s]);t.push(e)}let a=[e[0]];return"channelsLast"===this.dataFormat?(a=a.concat(t),a.push(this.filters)):(a.push(this.filters),a=a.concat(t)),a}getConfig(){const e={filters:this.filters,kernelInitializer:tE(this.kernelInitializer),kernelRegularizer:v_(this.kernelRegularizer),kernelConstraint:DE(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||"number"!==typeof e.filters||e.filters<1)throw new CN("Convolution layer expected config.filters to be a 'number' > 0 "+"but got ".concat(JSON.stringify(e.filters)))}}class B_ extends z_{constructor(e){super(2,e),B_.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!==typeof e.kernelSize&&!UN(e.kernelSize,"number",1,2))throw new CN("Conv2D expects config.kernelSize to be number or number[] with "+"length 1 or 2, but received ".concat(JSON.stringify(e.kernelSize),"."))}}B_.className="Conv2D",by(B_);class j_ extends z_{constructor(e){super(3,e),j_.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!==typeof e.kernelSize&&(!Array.isArray(e.kernelSize)||1!==e.kernelSize.length&&3!==e.kernelSize.length))throw new CN("Conv3D expects config.kernelSize to be number or"+" [number, number, number], but received ".concat(JSON.stringify(e.kernelSize),"."))}}j_.className="Conv3D",by(j_);class W_ extends B_{constructor(e){if(super(e),this.inputSpec=[new dE({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new CN("Conv2DTranspose currently supports only padding modes 'same' "+"and 'valid', but received padding mode ".concat(this.padding))}build(e){if(4!==(e=iE(e)).length)throw new CN("Input should have rank 4; Received input shape: "+JSON.stringify(e));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new CN("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],a=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",a,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new dE({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return Km(()=>{let t=rE(e);if(4!==t.shape.length)throw new CN("Conv2DTranspose.call() expects input tensor to be rank-4, but "+"received a tensor of rank-".concat(t.shape.length));const n=t.shape,a=n[0];let s,r;"channelsFirst"===this.dataFormat?(s=2,r=3):(s=1,r=2);const i=n[s],o=n[r],c=this.kernelSize[0],l=this.kernelSize[1],u=this.strides[0],h=this.strides[1],d=[a,A_(i,u,c,this.padding),A_(o,h,l,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=Ik(t,[0,2,3,1]));let p=Ex(t,this.kernel.read(),d,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(p=Ik(p,[0,3,1,2])),null!=this.bias&&(p=MT(p,this.bias.read(),this.dataFormat)),null!=this.activation&&(p=this.activation.apply(p)),p})}computeOutputShape(e){const t=(e=iE(e)).slice();let n,a,s;"channelsFirst"===this.dataFormat?(n=1,a=2,s=3):(n=3,a=1,s=2);const r=this.kernelSize[0],i=this.kernelSize[1],o=this.strides[0],c=this.strides[1];return t[n]=this.filters,t[a]=A_(t[a],o,r,this.padding),t[s]=A_(t[s],c,i,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}W_.className="Conv2DTranspose",by(W_);class V_ extends j_{constructor(e){if(super(e),this.inputSpec=[new dE({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new CN("Conv3DTranspose currently supports only padding modes 'same' "+"and 'valid', but received padding mode ".concat(this.padding))}build(e){if(5!==(e=iE(e)).length)throw new CN("Input should have rank 5; Received input shape: "+JSON.stringify(e));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new CN("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],a=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",a,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new dE({ndim:5,axes:{[t]:n}})],this.built=!0}call(e,t){return Km(()=>{let t=rE(e);if(5!==t.shape.length)throw new CN("Conv3DTranspose.call() expects input tensor to be rank-4, but "+"received a tensor of rank-".concat(t.shape.length));const n=t.shape,a=n[0];let s,r,i;"channelsFirst"===this.dataFormat?(i=2,s=3,r=4):(i=1,s=2,r=3);const o=n[i],c=n[s],l=n[r],u=this.kernelSize[0],h=this.kernelSize[1],d=this.kernelSize[2],p=this.strides[0],f=this.strides[1],m=this.strides[2],g=[a,A_(o,p,u,this.padding),A_(c,f,h,this.padding),A_(l,m,d,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=Ik(t,[0,2,3,4,1]));let y=Ax(t,this.kernel.read(),g,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(y=Ik(y,[0,4,1,2,3])),null!==this.bias&&(y=MT(y,this.bias.read(),this.dataFormat)),null!==this.activation&&(y=this.activation.apply(y)),y})}computeOutputShape(e){const t=(e=iE(e)).slice();let n,a,s,r;"channelsFirst"===this.dataFormat?(n=1,a=2,s=3,r=4):(n=4,a=1,s=2,r=3);const i=this.kernelSize[0],o=this.kernelSize[1],c=this.kernelSize[2],l=this.strides[0],u=this.strides[1],h=this.strides[2];return t[n]=this.filters,t[a]=A_(t[a],l,i,this.padding),t[s]=A_(t[s],u,o,this.padding),t[r]=A_(t[r],h,c,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}V_.className="Conv3DTranspose",by(V_);class U_ extends z_{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==t.filters)throw new CN("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=t.kernelInitializer||null!=t.kernelRegularizer||null!=t.kernelConstraint)throw new CN("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=t.padding&&"same"!==t.padding&&"valid"!==t.padding)throw new CN("SeparableConv".concat(this.rank,"D supports only padding modes: ")+"'same' and 'valid', but received ".concat(JSON.stringify(t.padding)));this.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,this.depthwiseInitializer=nE(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=k_(t.depthwiseRegularizer),this.depthwiseConstraint=FE(t.depthwiseConstraint),this.pointwiseInitializer=nE(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=k_(t.pointwiseRegularizer),this.pointwiseConstraint=FE(t.pointwiseConstraint)}build(e){if((e=iE(e)).length<this.rank+2)throw new CN("Inputs to SeparableConv".concat(this.rank,"D should have rank ")+"".concat(this.rank+2,", but received input shape: ")+"".concat(JSON.stringify(e)));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t]||e[t]<0)throw new CN("The channel dimension of the inputs should be defined, "+"but found ".concat(JSON.stringify(e[t])));const n=e[t],a=this.kernelSize.concat([n,this.depthMultiplier]),s=[];for(let i=0;i<this.rank;++i)s.push(1);s.push(n*this.depthMultiplier,this.filters);const r=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",a,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,r,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",s,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,r,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,r,this.biasConstraint):this.bias=null,this.inputSpec=[new dE({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return Km(()=>{let t;if(e=rE(e),1===this.rank)throw new IN("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(e=Ik(e,[0,2,3,1])),t=Bw(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(t=MT(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),"channelsFirst"===this.dataFormat&&(t=Ik(t,[0,3,1,2])),t})}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=tE(this.depthwiseInitializer),e.pointwiseInitializer=tE(this.pointwiseInitializer),e.depthwiseRegularizer=v_(this.depthwiseRegularizer),e.pointwiseRegularizer=v_(this.pointwiseRegularizer),e.depthwiseConstraint=DE(this.depthwiseConstraint),e.pointwiseConstraint=DE(this.pointwiseConstraint),e}}U_.className="SeparableConv";class H_ extends U_{constructor(e){super(2,e)}}H_.className="SeparableConv2D",by(H_);class G_ extends z_{constructor(e){super(1,e),G_.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if("number"!==typeof e.kernelSize&&!UN(e.kernelSize,"number",1,1))throw new CN("Conv1D expects config.kernelSize to be number or number[] with "+"length 1, but received ".concat(JSON.stringify(e.kernelSize),"."))}}G_.className="Conv1D",by(G_);class q_ extends yE{constructor(e){super(e),"number"===typeof e.cropping?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:"number"===typeof e.cropping[0]?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=void 0===e.dataFormat?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return Km(()=>{if(e=rE(e),"channelsLast"===this.dataFormat){const t=ST(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return ST(t,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const t=ST(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return ST(t,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}q_.className="Cropping2D",by(q_);class K_ extends yE{constructor(e){var t;super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==e.size?this.DEFAULT_SIZE:e.size,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,aT(this.dataFormat),this.interpolation=null==e.interpolation?"nearest":e.interpolation,t=this.interpolation,VN(JN,"InterpolationFormat",t)}computeOutputShape(e){if("channelsFirst"===this.dataFormat){const t=null==e[2]?null:this.size[0]*e[2],n=null==e[3]?null:this.size[1]*e[3];return[e[0],e[1],t,n]}{const t=null==e[1]?null:this.size[0]*e[1],n=null==e[2]?null:this.size[1]*e[2];return[e[0],t,n,e[3]]}}call(e,t){return Km(()=>{let t=rE(e);const n=t.shape;if("channelsFirst"===this.dataFormat){t=Ik(t,[0,2,3,1]);const e=this.size[0]*n[2],a=this.size[1]*n[3],s="nearest"===this.interpolation?US.resizeNearestNeighbor(t,[e,a]):US.resizeBilinear(t,[e,a]);return Ik(s,[0,3,1,2])}{const e=this.size[0]*n[1],a=this.size[1]*n[2];return"nearest"===this.interpolation?US.resizeNearestNeighbor(t,[e,a]):US.resizeBilinear(t,[e,a])}})}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}}K_.className="UpSampling2D",by(K_);class X_ extends L_{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=nE(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=FE(e.depthwiseConstraint),this.depthwiseRegularizer=k_(e.depthwiseRegularizer)}build(e){if((e=iE(e)).length<4)throw new CN("Inputs to DepthwiseConv2D should have rank 4. "+"Received input shape: ".concat(JSON.stringify(e),"."));const t="channelsFirst"===this.dataFormat?1:3;if(null==e[t]||e[t]<0)throw new CN("The channel dimension of the inputs to DepthwiseConv2D should "+"be defined, but is not (".concat(e[t],")."));const n=e[t],a=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",a,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return Km(()=>{let t=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[1,1],a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"valid",s=arguments.length>4?arguments[4]:void 0,r=arguments.length>5?arguments[5]:void 0;return Km(()=>{null==s&&(s="channelsLast"),aT(s);let i=M_(e,s);if(4!==e.rank)throw new CN("Input for depthwiseConv2d is required to be 4-D, but is instead "+"".concat(e.rank,"-D"));if(4!==t.rank)throw new CN("depthwiseKernel is required to be 4-D, but is instead "+"".concat(t.rank,"-D"));return i=zx(i,t,n,"same"===a?"same":"valid","NHWC",r),"channelsFirst"===s&&(i=Ik(i,[0,3,1,2])),i})}(e=rE(e),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(t=MT(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),t})}computeOutputShape(e){e=iE(e);const t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],a="channelsFirst"===this.dataFormat?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,s=__(t,this.kernelSize[0],this.padding,this.strides[0]),r=__(n,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[e[0],a,s,r]:[e[0],s,r,a]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=tE(this.depthwiseInitializer),e.depthwiseRegularizer=v_(this.depthwiseRegularizer),e.depthwiseConstraint=DE(this.depthwiseRegularizer),e}}function Y_(e,t,n,a){if(Array.isArray(e)){if(null!=t||null!=n)throw new CN("When inputs is an array, neither initialState or constants should be provided");null!=a&&(n=e.slice(e.length-a,e.length),e=e.slice(0,e.length-a)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function s(e){return null==e||Array.isArray(e)?e:[e]}return{inputs:e,initialState:t=s(t),constants:n=s(n)}}function Q_(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=arguments.length>4?arguments[4]:void 0,r=arguments.length>5?arguments[5]:void 0,i=arguments.length>6&&void 0!==arguments[6]&&arguments[6],o=arguments.length>7&&void 0!==arguments[7]&&arguments[7];return Km(()=>{const c=t.shape.length;if(c<3)throw new CN("Input should be at least 3D, but is ".concat(c,"D."));const l=[1,0].concat(gT(2,c));if(t=Ik(t,l),null!=r)throw new IN("The rnn() functoin of the deeplearn.js backend does not support constants yet.");i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=s&&(s=ny(ny(s,"bool"),"float32"),s.rank===c-1&&(s=uv(s,-1)),s=Ik(s,l)),a&&(t=Aw(t,0),null!=s&&(s=Aw(s,0)));const u=[];let h,d=n;const p=t.shape[0],f=xk(t);let m,g;null!=s&&(m=xk(s));for(let t=0;t<p;++t){const n=f[t],a=Km(()=>e(n,d));if(null==s)h=a[0],d=a[1];else{const e=Km(()=>{const e=m[t],n=Cy(nw(e),e);return{output:ry(cy(a[0],e),cy(d[0],n)),newStates:d.map((t,s)=>ry(cy(a[1][s],e),cy(t,n)))}});h=e.output,d=e.newStates}o&&u.push(h)}if(o){g=nk(u,1)}return[h,g,d]})}X_.className="DepthwiseConv2D",by(X_);class Z_ extends yE{constructor(e){let t;if(super(e),null==e.cell)throw new CN("cell property is missing for the constructor of RNN.");if(t=Array.isArray(e.cell)?new rA({cells:e.cell}):e.cell,null==t.stateSize)throw new CN("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=null!=e.returnSequences&&e.returnSequences,this.returnState=null!=e.returnState&&e.returnState,this.goBackwards=null!=e.goBackwards&&e.goBackwards,this._stateful=null!=e.stateful&&e.stateful,this.unroll=null!=e.unroll&&e.unroll,this.supportsMasking=!0,this.inputSpec=[new dE({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(null==this.states_){return gT(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map(e=>null)}return this.states_}setStates(e){this.states_=e}computeOutputShape(e){aE(e)&&(e=e[0]);let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);const n=t[0];let a;if(a=this.returnSequences?[e[0],e[1],n]:[e[0],n],this.returnState){const n=[];for(const a of t)n.push([e[0],a]);return[a].concat(n)}return a}computeMask(e,t){return Km(()=>{Array.isArray(t)&&(t=t[0]);const e=this.returnSequences?t:null;if(this.returnState){const t=this.states.map(e=>null);return[e].concat(t)}return e})}get states(){if(null==this.states_){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let n=0;n<e;++n)t.push(null);return t}return this.states_}set states(e){this.states_=e}build(e){if(null!=this.numConstants)throw new IN("Constants support is not implemented in RNN yet.");aE(e)&&(e=e[0]);const t=this.stateful?e[0]:null,n=e.slice(2);this.inputSpec[0]=new dE({shape:[t,null,...n]});const a=[e[0]].concat(e.slice(2));let s;if(this.cell.build(a),s=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!ku(this.stateSpec.map(e=>e.shape[e.shape.length-1]),s))throw new CN("An initialState was passed that is not compatible with "+"cell.stateSize. Received stateSpec=".concat(this.stateSpec,"; ")+"However cell.stateSize is ".concat(this.cell.stateSize))}else this.stateSpec=s.map(e=>new dE({shape:[null,e]}));this.stateful&&this.resetStates()}resetStates(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];Km(()=>{if(!this.stateful)throw new kN("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape[0];if(null==n)throw new CN("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(e=>Gv([n,e])):this.states_=[Gv([n,this.cell.stateSize])];else if(null==e)Xm(this.states_),null!=this.keptStates&&(Xm(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(e=>Gv([n,e])):this.states_[0]=Gv([n,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new CN("Layer ".concat(this.name," expects ").concat(this.states_.length," state(s), ")+"but it received ".concat(e.length," state value(s). Input ")+"received: ".concat(e));!0===t?this.keptStates.push(this.states_.slice()):Xm(this.states_);for(let t=0;t<this.states_.length;++t){const a=e[t],s=Array.isArray(this.cell.stateSize)?this.cell.stateSize[t]:this.cell.stateSize,r=[n,s];if(!ku(a.shape,r))throw new CN("State ".concat(t," is incompatible with layer ").concat(this.name,": ")+"expected shape=".concat(r,", received shape=").concat(a.shape));this.states_[t]=a}}this.states_=this.states_.map(e=>Ym(e.clone()))})}apply(e,t){let n=null==t?null:t.initialState,a=null==t?null:t.constants;null==t&&(t={});const s=Y_(e,n,a,this.numConstants);e=s.inputs,n=s.initialState,a=s.constants;let r=[],i=[];if(null!=n){t.initialState=n,r=r.concat(n),this.stateSpec=[];for(const e of n)this.stateSpec.push(new dE({shape:e.shape}));i=i.concat(this.stateSpec)}null!=a&&(t.constants=a,r=r.concat(a),this.numConstants=a.length);if(r[0]instanceof pE){const n=[e].concat(r),a=this.inputSpec.concat(i),s=this.inputSpec;this.inputSpec=a;const o=super.apply(n,t);return this.inputSpec=s,o}return super.apply(e,t)}call(e,t){return Km(()=>{const n=null==t?null:t.mask,a=null==t?null:t.training;let s=null==t?null:t.initialState;e=rE(e),null==s&&(s=this.stateful?this.states_:this.getInitialState(e));const r=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(s.length!==r)throw new CN("RNN Layer has ".concat(r," state(s) but was passed ")+"".concat(s.length," initial state(s)."));this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const i={training:a},o=Q_((e,t)=>{const n=this.cell.call([e].concat(t),i);return[n[0],n.slice(1)]},e,s,this.goBackwards,n,null,this.unroll,this.returnSequences),c=o[0],l=o[1],u=o[2];this.stateful&&this.resetStates(u,a);const h=this.returnSequences?l:c;return this.returnState?[h].concat(u):h})}getInitialState(e){return Km(()=>{let t=Gv(e.shape);return t=rv(t,[1,2]),t=vT(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(e=>e>1?NT(t,[1,e]):t):this.cell.stateSize>1?[NT(t,[1,this.cell.stateSize])]:[t]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(t.numConstants=this.numConstants);const n=this.cell.getConfig();return this.getClassName()===Z_.className&&(t.cell={className:this.cell.getClassName(),config:n}),Object.assign(Object.assign(Object.assign({},n),e),t)}static fromConfig(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const a=XE(t.cell,n);return new e(Object.assign(t,{cell:a}))}}Z_.className="RNN",by(Z_);class J_ extends yE{}class $_ extends J_{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,HN(this.units,"units"),this.activation=m_(null==e.activation?this.DEFAULT_ACTIVATION:e.activation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=nE(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=nE(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=nE(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=k_(e.kernelRegularizer),this.recurrentRegularizer=k_(e.recurrentRegularizer),this.biasRegularizer=k_(e.biasRegularizer),this.kernelConstraint=FE(e.kernelConstraint),this.recurrentConstraint=FE(e.recurrentConstraint),this.biasConstraint=FE(e.biasConstraint),this.dropout=fT([1,mT([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=fT([1,mT([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=iE(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return Km(()=>{if(2!==e.length)throw new CN("SimpleRNNCell expects 2 input Tensors, got ".concat(e.length,"."));let n=e[1];e=e[0];const a=null!=t.training&&t.training;let s;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=iA({ones:()=>nw(e),rate:this.dropout,training:a,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=iA({ones:()=>nw(n),rate:this.recurrentDropout,training:a,dropoutFunc:this.dropoutFunc}));const r=this.dropoutMask,i=this.recurrentDropoutMask;s=ET(null!=r?cy(e,r):e,this.kernel.read()),null!=this.bias&&(s=MT(s,this.bias.read())),null!=i&&(n=cy(n,i));let o=ry(s,ET(n,this.recurrentKernel.read()));return null!=this.activation&&(o=this.activation.apply(o)),[o,o]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:p_(this.activation),useBias:this.useBias,kernelInitializer:tE(this.kernelInitializer),recurrentInitializer:tE(this.recurrentInitializer),biasInitializer:tE(this.biasInitializer),kernelRegularizer:v_(this.kernelRegularizer),recurrentRegularizer:v_(this.recurrentRegularizer),biasRegularizer:v_(this.biasRegularizer),activityRegularizer:v_(this.activityRegularizer),kernelConstraint:DE(this.kernelConstraint),recurrentConstraint:DE(this.recurrentConstraint),biasConstraint:DE(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}}$_.className="SimpleRNNCell",by($_);class eA extends Z_{constructor(e){e.cell=new $_(e),super(e)}call(e,t){return Km(()=>{null!=this.cell.dropoutMask&&(Xm(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Xm(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,a=null==t?null:t.training,s=null==t?null:t.initialState;return super.call(e,{mask:n,training:a,initialState:s})})}static fromConfig(e,t){return new e(t)}}eA.className="SimpleRNN",by(eA);class tA extends J_{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new CN("GRUCell does not support reset_after parameter set to true.");this.units=e.units,HN(this.units,"units"),this.activation=m_(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=m_(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=nE(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=nE(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=nE(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=k_(e.kernelRegularizer),this.recurrentRegularizer=k_(e.recurrentRegularizer),this.biasRegularizer=k_(e.biasRegularizer),this.kernelConstraint=FE(e.kernelConstraint),this.recurrentConstraint=FE(e.recurrentConstraint),this.biasConstraint=FE(e.biasConstraint),this.dropout=fT([1,mT([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=fT([1,mT([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){const t=(e=iE(e))[e.length-1];this.kernel=this.addWeight("kernel",[t,3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return Km(()=>{if(2!==e.length)throw new CN("GRUCell expects 2 input Tensors (inputs, h, c), got "+"".concat(e.length,"."));const n=null!=t.training&&t.training;let a=e[1];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=iA({ones:()=>nw(e),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=iA({ones:()=>nw(a),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));const s=this.dropoutMask,r=this.recurrentDropoutMask;let i,o,c;0<this.dropout&&this.dropout<1&&(e=cy(e,s[0]));let l=ET(e,this.kernel.read());this.useBias&&(l=MT(l,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(a=cy(a,r[0]));const u=this.recurrentKernel.read(),[h,d]=Jw(u,[2*this.units,this.units],u.rank-1),p=ET(a,h),[f,m,g]=Jw(l,3,l.rank-1),[y,b]=Jw(p,2,p.rank-1);i=this.recurrentActivation.apply(ry(f,y)),o=this.recurrentActivation.apply(ry(m,b));const x=ET(cy(o,a),d);c=this.activation.apply(ry(g,x));const v=ry(cy(i,a),cy(ry(1,Rv(i)),c));return[v,v]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:p_(this.activation),recurrentActivation:p_(this.recurrentActivation),useBias:this.useBias,kernelInitializer:tE(this.kernelInitializer),recurrentInitializer:tE(this.recurrentInitializer),biasInitializer:tE(this.biasInitializer),kernelRegularizer:v_(this.kernelRegularizer),recurrentRegularizer:v_(this.recurrentRegularizer),biasRegularizer:v_(this.biasRegularizer),activityRegularizer:v_(this.activityRegularizer),kernelConstraint:DE(this.kernelConstraint),recurrentConstraint:DE(this.recurrentConstraint),biasConstraint:DE(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}}tA.className="GRUCell",by(tA);class nA extends Z_{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new tA(e),super(e)}call(e,t){return Km(()=>{null!=this.cell.dropoutMask&&(Xm(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Xm(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,a=null==t?null:t.training,s=null==t?null:t.initialState;return super.call(e,{mask:n,training:a,initialState:s})})}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}}nA.className="GRU",by(nA);class aA extends J_{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,HN(this.units,"units"),this.activation=m_(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=m_(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=nE(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=nE(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=nE(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=k_(e.kernelRegularizer),this.recurrentRegularizer=k_(e.recurrentRegularizer),this.biasRegularizer=k_(e.biasRegularizer),this.kernelConstraint=FE(e.kernelConstraint),this.recurrentConstraint=FE(e.recurrentConstraint),this.biasConstraint=FE(e.biasConstraint),this.dropout=fT([1,mT([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=fT([1,mT([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;const n=(e=iE(e))[e.length-1];let a;if(this.kernel=this.addWeight("kernel",[n,4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const e=this.biasInitializer,n=this.units;a=new((t=class extends LT{apply(t,a){const s=e.apply([n]),r=(new BT).apply([n]),i=e.apply([2*n]);return IT(IT(s,r),i)}}).className="CustomInit",t)}else a=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,a,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return Km(()=>{const n=null!=t.training&&t.training;if(3!==e.length)throw new CN("LSTMCell expects 3 input Tensors (inputs, h, c), got "+"".concat(e.length,"."));let a=e[1];const s=e[2];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=iA({ones:()=>nw(e),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=iA({ones:()=>nw(a),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const r=this.dropoutMask,i=this.recurrentDropoutMask;let o,c,l,u;0<this.dropout&&this.dropout<1&&(e=cy(e,r[0]));let h=ET(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(a=cy(a,i[0])),h=ry(h,ET(a,this.recurrentKernel.read())),this.useBias&&(h=MT(h,this.bias.read()));const[d,p,f,m]=Jw(h,4,h.rank-1);o=this.recurrentActivation.apply(d),c=this.recurrentActivation.apply(p),l=ry(cy(c,s),cy(o,this.activation.apply(f))),u=this.recurrentActivation.apply(m);const g=cy(u,this.activation.apply(l));return[g,g,l]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:p_(this.activation),recurrentActivation:p_(this.recurrentActivation),useBias:this.useBias,kernelInitializer:tE(this.kernelInitializer),recurrentInitializer:tE(this.recurrentInitializer),biasInitializer:tE(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:v_(this.kernelRegularizer),recurrentRegularizer:v_(this.recurrentRegularizer),biasRegularizer:v_(this.biasRegularizer),activityRegularizer:v_(this.activityRegularizer),kernelConstraint:DE(this.kernelConstraint),recurrentConstraint:DE(this.recurrentConstraint),biasConstraint:DE(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}}aA.className="LSTMCell",by(aA);class sA extends Z_{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new aA(e),super(e)}call(e,t){return Km(()=>{null!=this.cell.dropoutMask&&(Xm(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Xm(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,a=null==t?null:t.training,s=null==t?null:t.initialState;return super.call(e,{mask:n,training:a,initialState:s})})}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}}sA.className="LSTM",by(sA);class rA extends J_{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return Km(()=>{let n=e.slice(1);const a=[];for(const e of this.cells.slice().reverse())Array.isArray(e.stateSize)?a.push(n.splice(0,e.stateSize.length)):a.push(n.splice(0,1));a.reverse();const s=[];let r;for(let i=0;i<this.cells.length;++i){const o=this.cells[i];n=a[i],r=0===i?[e[0]].concat(n):[r[0]].concat(n),r=o.call(r,t),s.push(r.slice(1))}n=[];for(const e of s.slice().reverse())n.push(...e);return[r[0]].concat(n)})}build(e){let t;aE(e)&&(e=e[0]),this.cells.forEach((n,a)=>{oT("RNNCell_".concat(a),()=>{n.build(e),t=Array.isArray(n.stateSize)?n.stateSize[0]:n.stateSize,e=[e[0],t]})}),this.built=!0}getConfig(){const e=super.getConfig(),t={cells:this.cells.map(e=>({className:e.getClassName(),config:e.getConfig()}))};return Object.assign(Object.assign({},e),t)}static fromConfig(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const a=[];for(const s of t.cells)a.push(XE(s,n));return new e({cells:a})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const e of this.cells)t.push(...e.trainableWeights);return t.concat(e)}return e}getWeights(){const e=[];for(const t of this.cells)e.push(...t.weights);return uE(e)}setWeights(e){const t=[];for(const n of this.cells){const a=n.weights.length,s=e.splice(a);for(let e=0;e<n.weights.length;++e)t.push([n.weights[e],s[e]])}hE(t)}}function iA(e){const{ones:t,rate:n,training:a=!1,count:s=1,dropoutFunc:r}=e,i=()=>null!=r?r(t(),n):PT(t(),n),o=()=>DT(i,t,a);if(!s||s<=1)return Ym(o().clone());return Array(s).fill(void 0).map(o).map(e=>Ym(e.clone()))}rA.className="StackedRNNCells",by(rA);var oA=function(e,t){var n={};for(var a in e)Object.prototype.hasOwnProperty.call(e,a)&&t.indexOf(a)<0&&(n[a]=e[a]);if(null!=e&&"function"===typeof Object.getOwnPropertySymbols){var s=0;for(a=Object.getOwnPropertySymbols(e);s<a.length;s++)t.indexOf(a[s])<0&&Object.prototype.propertyIsEnumerable.call(e,a[s])&&(n[a[s]]=e[a[s]])}return n};class cA extends Z_{constructor(e){if(e.unroll)throw new IN("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new IN("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new dE({ndim:5})]}call(e,t){return Km(()=>{if(null!=this.cell.dropoutMask&&(Xm(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Xm(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new CN("ConvRNN2D cell does not support constants");const n=null==t?null:t.mask,a=null==t?null:t.training,s=null==t?null:t.initialState;return super.call(e,{mask:n,training:a,initialState:s})})}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return Km(()=>{const{stateSize:t}=this.cell,n=e.shape,a=this.computeSingleOutputShape(n),s=Gv([a[0],...a.slice(2)]);return Array.isArray(t)?Array(t.length).fill(s):[s]})}resetStates(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];Km(()=>{if(!this.stateful)throw new kN("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape,a=this.computeSingleOutputShape(n),s=[a[0],...a.slice(2)];if(null==n[0])throw new CN("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Gv(s)):this.states_=[Gv(s)];else if(null==e)Xm(this.states_),null!=this.keptStates&&(Xm(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Gv(s)):this.states_[0]=Gv(s);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new CN("Layer ".concat(this.name," expects ").concat(this.states_.length," state(s), ")+"but it received ".concat(e.length," state value(s). Input ")+"received: ".concat(e));t?this.keptStates.push(this.states_.slice()):Xm(this.states_);for(let t=0;t<this.states_.length;++t){const n=e[t],a=s;if(!ku(n.shape,a))throw new CN("State ".concat(t," is incompatible with layer ").concat(this.name,": ")+"expected shape=".concat(a,", received shape=").concat(n.shape));this.states_[t]=n}}this.states_=this.states_.map(e=>Ym(e.clone()))})}computeSingleOutputShape(e){const{dataFormat:t,filters:n,kernelSize:a,padding:s,strides:r,dilationRate:i}=this.cell,o="channelsFirst"===t,c=e[o?3:2],l=e[o?4:3],u=__(c,a[0],s,r[0],i[0]),h=__(l,a[1],s,r[1],i[1]);return[...e.slice(0,2),...o?[n,u,h]:[u,h,n]]}}cA.className="ConvRNN2D";class lA extends aA{constructor(e){const{filters:t,kernelSize:n,strides:a,padding:s,dataFormat:r,dilationRate:i}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,HN(this.filters,"filters"),this.kernelSize=R_(n,2,"kernelSize"),this.kernelSize.forEach(e=>HN(e,"kernelSize")),this.strides=R_(a||1,2,"strides"),this.strides.forEach(e=>HN(e,"strides")),this.padding=s||"valid",sT(this.padding),this.dataFormat=r||"channelsLast",aT(this.dataFormat),this.dilationRate=R_(i||1,2,"dilationRate"),this.dilationRate.forEach(e=>HN(e,"dilationRate"))}build(e){var t;e=iE(e);const n="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[n])throw new CN("The channel dimension of the input should be defined. "+"Found ".concat(e[n]));const a=e[n],s=this.kernelSize.concat([a,4*this.filters]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const r=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",r,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let e;if(this.unitForgetBias){const n=this.biasInitializer,a=this.filters;e=new((t=class extends LT{apply(e,t){return CT([n.apply([a]),qv([a]),n.apply([2*a])])}}).className="CustomInit",t)}else e=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,e,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return Km(()=>{if(3!==e.length)throw new CN("ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got "+"".concat(e.length,"."));const n=t.training||!1,a=e[0],s=e[1],r=e[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=iA({ones:()=>nw(a),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const i=this.dropoutMask,o=(e,t,n)=>t&&t[n]?cy(t[n],e):e;let c=o(a,i,0),l=o(a,i,1),u=o(a,i,2),h=o(a,i,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=iA({ones:()=>nw(s),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const d=this.recurrentDropoutMask;let p=o(s,d,0),f=o(s,d,1),m=o(s,d,2),g=o(s,d,3);const[y,b,x,v]=Jw(this.kernel.read(),4,3),[w,k,S,C]=this.useBias?Jw(this.bias.read(),4):[null,null,null,null];c=this.inputConv(c,y,w,this.padding),l=this.inputConv(l,b,k,this.padding),u=this.inputConv(u,x,S,this.padding),h=this.inputConv(h,v,C,this.padding);const[I,N,T,E]=Jw(this.recurrentKernel.read(),4,3);p=this.recurrentConv(p,I),f=this.recurrentConv(f,N),m=this.recurrentConv(m,T),g=this.recurrentConv(g,E);const R=this.recurrentActivation.apply(ry(c,p)),_=this.recurrentActivation.apply(ry(l,f)),A=ry(cy(_,r),cy(R,this.activation.apply(ry(u,m)))),M=cy(this.recurrentActivation.apply(ry(h,g)),this.activation.apply(A));return[M,M,A]})}getConfig(){const e=super.getConfig(),{units:t}=e,n=oA(e,["units"]),a={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},n),a)}inputConv(e,t,n,a){const s=Ix(e,t,this.strides,a||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return n?MT(s,n,this.dataFormat):s}recurrentConv(e,t){return Ix(e,t,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}lA.className="ConvLSTM2DCell",by(lA);class uA extends cA{constructor(e){const t=new lA(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}}uA.className="ConvLSTM2D",by(uA);class hA extends yE{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(null==this.noiseShape)return this.noiseShape;const t=e.shape,n=[];for(let a=0;a<this.noiseShape.length;++a)n.push(null==this.noiseShape[a]?t[a]:this.noiseShape[a]);return n}call(e,t){return Km(()=>{this.invokeCallHook(e,t);const n=rE(e);if(0<this.rate&&this.rate<1){const e=null!=t.training&&t.training,a=this.getNoiseShape(n);return DT(()=>PT(n,this.rate,a,this.seed),()=>n,e)}return e})}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}}hA.className="Dropout",by(hA);class dA extends hA{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const t=e.shape;return[t[0],1,t[2]]}}dA.className="SpatialDropout1D",by(dA);class pA extends yE{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==e.batchInputShape&&null==e.inputShape&&null!=e.inputDim){let t=null;null!=e.batchSize&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,HN(this.units,"units"),this.activation=m_(e.activation),null!=e.useBias&&(this.useBias=e.useBias),this.kernelInitializer=nE(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=nE(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=FE(e.kernelConstraint),this.biasConstraint=FE(e.biasConstraint),this.kernelRegularizer=k_(e.kernelRegularizer),this.biasRegularizer=k_(e.biasRegularizer),this.activityRegularizer=k_(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){const t=(e=iE(e))[e.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){const t=(e=iE(e)).slice();return t[t.length-1]=this.units,t}call(e,t){return Km(()=>{this.invokeCallHook(e,t);const n=rE(e),a=qN(this.activation.getClassName());let s;return null!=a?s=ET(n,this.kernel.read(),a,this.bias?this.bias.read():null):(s=ET(n,this.kernel.read()),null!=this.bias&&(s=MT(s,this.bias.read())),null!=this.activation&&(s=this.activation.apply(s))),s})}getConfig(){const e={units:this.units,activation:p_(this.activation),useBias:this.useBias,kernelInitializer:tE(this.kernelInitializer),biasInitializer:tE(this.biasInitializer),kernelRegularizer:v_(this.kernelRegularizer),biasRegularizer:v_(this.biasRegularizer),activityRegularizer:v_(this.activityRegularizer),kernelConstraint:DE(this.kernelConstraint),biasConstraint:DE(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}pA.className="Dense",by(pA);class fA extends yE{constructor(e){super(e=e||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=iE(e);for(const t of e.slice(1))if(null==t)throw new CN('The shape of the input to "Flatten" is not fully defined '+"(got ".concat(e.slice(1),"). Make sure to pass a complete ")+'"input_shape" or "batch_input_shape" argument to the first layer in your model.');return[e[0],pT(e,1)]}call(e,t){return Km(()=>{this.invokeCallHook(e,t);let n=rE(e);if("channelsFirst"===this.dataFormat&&n.rank>1){const e=[0];for(let t=2;t<n.rank;++t)e.push(t);e.push(1),n=Ik(n,e)}return function(e){if(e.rank<=1)throw new CN("batchFlatten requires a minimum rank of 2. Got rank: ".concat(e.rank,"."));const t=[e.shape[0],pT(e.shape,1)];return tx(e,t)}(n)})}getConfig(){const e={};null!=this.dataFormat&&(e.dataFormat=this.dataFormat);const t=super.getConfig();return Object.assign(e,t),e}}fA.className="Flatten",by(fA);class mA extends yE{constructor(e){super(e),this.supportsMasking=!0,this.activation=m_(e.activation)}call(e,t){return Km(()=>{this.invokeCallHook(e,t);const n=rE(e);return this.activation.apply(n)})}getConfig(){const e={activation:p_(this.activation)},t=super.getConfig();return Object.assign(e,t),e}}mA.className="Activation",by(mA);class gA extends yE{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return Km(()=>{return e=rE(e),t=e,n=this.n,Km(()=>{if(2!==t.shape.length)throw new CN("repeat() expects a rank-2 tensor, but received a "+"rank-".concat(t.shape.length," tensor."));return NT(vT(t,1),[1,n,1])});var t,n})}getConfig(){const e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}}gA.className="RepeatVector",by(gA);class yA extends yE{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||null==e}fixUnknownDimension(e,t){const n="Total size of new array must be unchanged.",a=t.slice();let s=1,r=null;for(let o=0;o<a.length;++o){const e=a[o];if(this.isUnknown(e)){if(null!==r)throw new CN("Can only specifiy one unknown dimension.");r=o}else s*=e}const i=pT(e);if(null!==r){if(0===s||i%s!==0)throw new CN(n);a[r]=i/s}else if(i!==s)throw new CN(n);return a}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return Km(()=>{this.invokeCallHook(e,t);const n=rE(e),a=n.shape,s=a.slice(0,1).concat(this.fixUnknownDimension(a.slice(1),this.targetShape));return tx(n,s)})}getConfig(){const e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}}yA.className="Reshape",by(yA);class bA extends yE{constructor(e){if(super(e),null==e.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error("Permute constructor requires `dims` to be an Array, but received "+"".concat(e.dims," instead."));const t=gT(1,e.dims.length+1);if(!ku(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new dE({ndim:this.dims.length+1})]}computeOutputShape(e){const t=(e=iE(e)).slice();return this.dims.forEach((n,a)=>{t[a+1]=e[n]}),t}call(e,t){return Ik(rE(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}}bA.className="Permute",by(bA);class xA extends yE{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,this.maskValue=null!=e?null==e.maskValue?0:e.maskValue:0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){const n=rE(e);return Mb(ew(n,this.maskValue),-1)}call(e,t){return Km(()=>{this.invokeCallHook(e,t);const n=rE(e),a=Mb(ew(n,this.maskValue),-1,!0);return cy(n,ny(a,n.dtype))})}}xA.className="Masking",by(xA);class vA extends yE{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==e.batchInputShape&&null==e.inputShape){let t=null;null!=e.batchSize&&(t=e.batchSize),null==e.inputLength?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(MN(e.inputLength))}this.inputDim=e.inputDim,HN(this.inputDim,"inputDim"),this.outputDim=e.outputDim,HN(this.outputDim,"outputDim"),this.embeddingsInitializer=nE(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=k_(e.embeddingsRegularizer),this.activityRegularizer=k_(e.activityRegularizer),this.embeddingsConstraint=FE(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return Km(()=>this.maskZero?(e=rE(e),ew(e,hy(e))):null)}computeOutputShape(e){if(e=iE(e),null==this.inputLength)return[...e,this.outputDim];const t=MN(this.inputLength);if(t.length!==e.length-1)throw new CN('"inputLength" is '.concat(this.inputLength,", but received ")+"input shape has shape ".concat(e));{let n=0;for(let a=0;a<t.length;++a){const s=t[a],r=e[a+1];if(null!=s&&null!=r&&s!==r)throw new CN('"inputLength" is '.concat(this.inputLength,", but received ")+"input shape has shape ".concat(e));null==s&&(t[n]=r),n++}}return[e[0],...t,this.outputDim]}call(e,t){return Km(()=>{this.invokeCallHook(e,t);let n=rE(e);"int32"!==n.dtype&&(n=xT(n,"int32"));const a=RT(this.embeddings.read(),tx(n,[n.size]));return tx(a,iE(this.computeOutputShape(n.shape)))})}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:tE(this.embeddingsInitializer),embeddingsRegularizer:v_(this.embeddingsRegularizer),activityRegularizer:v_(this.activityRegularizer),embeddingsConstraint:DE(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}}vA.className="Embedding",by(vA);class wA extends yE{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new IN}computeElementwiseOpOutputShape(e,t){if(null==e||null==t)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(0===t.length)return e;const n=e.slice(0,e.length-t.length);for(let a=0;a<t.length;++a){const s=e[e.length-t.length+a],r=t[a];if(null==s||null==r||s<0||r<0)n.push(null);else if(1===s)n.push(r);else if(1===r)n.push(s);else{if(s!==r)throw new CN("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(s)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[iE(e)]),e.length<2)throw new CN("A merge layer should be called on an Array of at least 2 inputs."+" Got ".concat(e.length," input(s)."));let t=[];for(const s of e)null!=s&&null!==s[0]&&t.push(s[0]);if(t=jN(t),t.length>1)throw new CN("Can not merge tensors with different batch sizes. "+"Got tensors with shapes: ".concat(JSON.stringify(e),"."));let n=null==e[0]?null:e[0].slice(1);for(let s=1;s<e.length;++s){const t=null==e[s]?null:e[s].slice(1);n=this.computeElementwiseOpOutputShape(n,t)}const a=e.map(e=>e.length);-1===e.indexOf(null)&&1===jN(a).length?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return Km(()=>{if(this.reshapeRequired){const t=[],n=e.map(e=>e.rank);if(-1===n.indexOf(null)){const a=mT(n);for(let n of e){const e=n.rank;for(let t=0;t<a-e;++t)n=vT(n,1);t.push(n)}return this.mergeFunction(t)}{let n=!1;for(const r of e){const e=r.rank;if(null==e){const e=r.shape,a=e[0],s=e.slice(1).concat([a]);let i=tx(r,[a].concat(pT(e.slice(1))));i=Ik(i,[1,0]),i=tx(i,s),t.push(i),n=!0}else if(e>1){const a=gT(1,e).concat([0]);t.push(Ik(r,a)),n=!0}else t.push(r)}let a=this.mergeFunction(t);const s=a.rank;if(n)if(null==s){const e=a.shape,t=e[e.length-1],n=[t].concat(e.slice(0,e.length-1));a=tx(Ik(tx(a,[-1,t]),[1,0]),n)}else if(s>1){const e=[s-1].concat(gT(0,s-1));a=Ik(a,e)}return a}}return this.mergeFunction(e)})}computeOutputShape(e){let t;t=null==e[0]?null:e[0].slice(1);for(let a=1;a<e.length;++a){const n=null==e[a]?null:e[a].slice(1);t=this.computeElementwiseOpOutputShape(t,n)}let n=[];for(const a of e)null!=a&&null!==a[0]&&n.push(a[0]);return n=jN(n),t=1===n.length?n.concat(t):[null].concat(t),t}computeMask(e,t){return Km(()=>{if(null==t)return null;if(!Array.isArray(t))throw new CN("`mask` should be an Array");if(!Array.isArray(e))throw new CN("`inputs` should be an Array");if(t.length!==e.length)throw new CN("The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths "+"(".concat(e.length," vs ").concat(t.length,")"));if(t.every(e=>null==e))return null;let n=(t=t.map(e=>null==e?e:uv(e,0)))[0];for(let e=1;e<t.length-1;++e)n=Dv(n,t[e]);return n})}}class kA extends wA{constructor(e){super(e)}mergeFunction(e){return Km(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=ry(t,e[n]);return t})}}kA.className="Add",by(kA);class SA extends wA{constructor(e){super(e)}mergeFunction(e){return Km(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=cy(t,e[n]);return t})}}SA.className="Multiply",by(SA);class CA extends wA{constructor(e){super(e)}mergeFunction(e){return Km(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=ry(t,e[n]);return cy(1/e.length,t)})}}CA.className="Average",by(CA);class IA extends wA{constructor(e){super(e)}mergeFunction(e){return Km(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=_y(t,e[n]);return t})}}IA.className="Maximum",by(IA);class NA extends wA{constructor(e){super(e)}mergeFunction(e){return Km(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=Xv(t,e[n]);return t})}}NA.className="Minimum",by(NA);class TA extends wA{constructor(e){super(e),this.DEFAULT_AXIS=-1,null==e&&(e={}),this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!Array.isArray(e)||!Array.isArray(e[0])||1===e.length)throw new CN("A `Concatenate` layer should be called on a list of at least 2 inputs");let t=!0;for(const a of e)if(null!=a){t=!1;break}if(t)return;const n=[];for(let a=0;a<e.length;++a){const t=e[a].slice();t.splice(this.axis,1);let s=!1;for(const e of n)if(ku(e,t)){s=!0;break}s||n.push(t)}if(n.length>1)throw new CN("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return Km(()=>CT(e,this.axis))}computeOutputShape(e){if(!Array.isArray(e)||!Array.isArray(e[0]))throw new CN("A `Concatenate` layer should be called on a list of inputs.");const t=e,n=t[0].slice(),a=this.axis<0?n.length+this.axis:this.axis;for(const s of t.slice(1)){if(null==n[a]||null==s[a]){n[a]=null;break}n[a]+=s[a]}return n}computeMask(e,t){if(null==t)return null;if(!Array.isArray(t))throw new CN("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new CN("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new CN("Mismatch in the length of mask (".concat(t.length,") ")+"and the legnth of inputs (".concat(e.length,")"));return Km(()=>{let n=!0;if(t.forEach(e=>{null==e||(n=!1)}),n)return null;const a=[];for(let r=0;r<e.length;++r)null==t[r]?a.push(ny(nw(e[r]),"bool")):t[r].rank<e[r].rank?a.push(uv(t[r],-1)):a.push(t[r]);const s=sx(a,this.axis);return Ab(s,-1,!1)})}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}function EA(e,t){for(;e<0;)e+=t;return e}TA.className="Concatenate",by(TA);class RA extends wA{constructor(e){super(e),this.axes=e.axes,this.normalize=null!=e.normalize&&e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){yu(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0],n=e[1];if(t.length>3||n.length>3)throw new IN("Dot layer does not support tensors of 4D or higher rank yet.");const a=this.interpretAxes(t,n);if(t[a[0]]!==n[a[1]])throw new CN("Dimension incompatibility: "+"".concat(t[a[0]]," !== ").concat(n[a[1]]))}mergeFunction(e){if(2!==e.length)throw new CN("A `Dot` layer must be called on exactly 2 inputs, "+"but received ".concat(e.length," input(s)."));let t,n=e[0],a=e[1];return t=Array.isArray(this.axes)?this.axes.map((t,n)=>EA(t,e[n].shape.length)):[EA(this.axes,n.shape.length),EA(this.axes,a.shape.length)],this.normalize&&(n=YE(n,t[0]),a=YE(a,t[1])),function(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new IN("batchDot is not implemented for tensors of 4D or higher rank yet");if(yu(e.shape.length>=2,()=>"batchDot requires the rank of x to be >= 2, "+"but got ".concat(e.shape.length)),yu(e.shape.length>=2,()=>"batchDot requires the rank of y to be >= 2, "+"but got ".concat(t.shape.length)),"number"===typeof n&&(n=[n,n]),"complex64"===e.dtype||"complex64"===t.dtype)throw new IN("batchDot is not implemented for complex64-type Tensors yet.");const a=e.shape.length,s=t.shape.length;null==n&&(n=[a-1,s-2]);const r=n;return Km(()=>{let n,i;if(a>s){n=a-s;const e=[];for(let t=0;t<n;++t)e.push(1);t=tx(t,t.shape.concat(e))}else if(s>a){n=s-a;const t=[];for(let e=0;e<n;++e)t.push(1);e=tx(e,e.shape.concat(t))}else n=0;if(2===e.shape.length&&2===t.shape.length)i=r[0]===r[1]?rv(cy(e,t),r[0]):rv(cy(Ik(e,[1,0]),t),r[1]);else{const n=r[0]!==e.shape.length-1,a=r[1]===t.shape.length-1;i=rx(e,t,n,a)}if(n>0){let e;e=a>s?a+s-3:a-1;const t=[];for(let a=e;a<e+n;++a)t.push(a);i=tk(i,t)}return 1===i.shape.length&&(i=uv(i,1)),i})}(n,a,t)}interpretAxes(e,t){let n;return n=Array.isArray(this.axes)?this.axes:[EA(this.axes,e.length),EA(this.axes,t.length)],n}computeOutputShape(e){yu(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new IN("Dot layer does not support tensors of 4D or higher rank yet.");const a=this.interpretAxes(t,n);t.splice(a[0],1),n.splice(a[1],1),n.splice(0,1);const s=t.concat(n);return 1===s.length&&s.push(1),s}computeMask(e,t){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}}RA.className="Dot",by(RA);class _A extends yE{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return Km(()=>{this.invokeCallHook(e,t);const n=rE(e);return DT(()=>ry(TT(n.shape,0,this.stddev),n),()=>n,t.training||!1)})}}_A.className="GaussianNoise",by(_A);class AA extends yE{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return Km(()=>{this.invokeCallHook(e,t);const n=rE(e);if(this.rate>0&&this.rate<1){return DT(()=>{const e=Math.sqrt(this.rate/(1-this.rate));return cy(n,TT(n.shape,1,e))},()=>n,t.training||!1)}return n})}}AA.className="GaussianDropout",by(AA);class MA extends yE{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||rE(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return Km(()=>{if(this.rate<1&&this.rate>0){const n=this._getNoiseShape(e),a=()=>{const t=rE(e),a=-1.7580993408473766;let s=yv(Cw(n),this.rate);s=xT(s,"float32");const r=((1-this.rate)*(1+this.rate*a**2))**-.5,i=-r*a*this.rate,o=ry(cy(t,s),cy(ry(s,-1),a));return ry(cy(o,r),i)};return DT(a,()=>rE(e),t.training||!1)}return e})}}function PA(e,t,n,a,s){let r,i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:.001;if(2===e.rank)r=dx(e,t,n,a,s,i);else if(3===e.rank)r=px(e,t,n,a,s,i);else{if(4!==e.rank)throw new IN("batchNormalization is not implemented for array of rank ".concat(e.rank," ")+"yet");r=fx(e,t,n,a,s,i)}return r}function DA(e,t,n,a){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return ku(a.slice().sort(),gT(0,e.rank-1))?function(e,t,n,a){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return Km(()=>{const r=Zv(e,a),i=r.mean,o=r.variance;return[PA(e,i,o,n,t,s),i,o]})}(e,t,n,a,s):function(e,t,n,a){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return Km(()=>{const r=Zv(e,a),i=r.mean,o=r.variance,c=[];for(const t of gT(0,e.rank))-1!==a.indexOf(t)?c.push(1):c.push(e.shape[t]);const l=tx(i,c),u=tx(o,c),h=null==t?null:tx(t,c),d=null==n?null:tx(n,c);return[PA(e,l,u,d,h,s),i,o]})}(e,t,n,a,s)}MA.className="AlphaDropout",by(MA);class OA extends yE{constructor(e){null==e&&(e={}),super(e),this.supportsMasking=!0,this.axis=null==e.axis?-1:e.axis,this.momentum=null==e.momentum?.99:e.momentum,this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=nE(e.betaInitializer||"zeros"),this.gammaInitializer=nE(e.gammaInitializer||"ones"),this.movingMeanInitializer=nE(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=nE(e.movingVarianceInitializer||"ones"),this.betaConstraint=FE(e.betaConstraint),this.gammaConstraint=FE(e.gammaConstraint),this.betaRegularizer=k_(e.betaRegularizer),this.gammaRegularizer=k_(e.gammaRegularizer)}build(e){e=iE(e);const t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(null==n)throw new CN("Axis ".concat(t," of input tensor should have a defined dimension but ")+"the layer received an input with shape "+"".concat(JSON.stringify(e),"."));this.inputSpec=[new dE({ndim:e.length,axes:{[t]:n}})];const a=[n];this.scale&&(this.gamma=this.addWeight("gamma",a,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",a,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",a,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",a,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return Km(()=>{const n=null!=t.training&&t.training,a=rE(e),s=a.shape,r=s.length,i=gT(0,r),o=this.axis>=0?this.axis:this.axis+r;i.splice(o,1);const c=EN(1,r);c[o]=s[o];const l=i.slice();l.sort();const u=!ku(l,gT(0,r).slice(0,r-1));if(!n)return(()=>{if(u){const e=tx(this.movingMean.read(),c),t=tx(this.movingVariance.read(),c),n=this.center?tx(this.beta.read(),c):null,s=this.scale?tx(this.gamma.read(),c):null;return PA(a,e,t,n,s,this.epsilon)}return PA(a,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[h,d,p]=DA(a,this.gamma.read(),this.beta.read(),i,this.epsilon),f=(e,t,n)=>{Km(()=>{const a=1-n,s=e.read(),r=cy(Cy(s,t),a);e.write(Cy(s,r))})};return(()=>{f(this.movingMean,d,this.momentum),f(this.movingVariance,p,this.momentum)})(),h})}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:tE(this.betaInitializer),gammaInitializer:tE(this.gammaInitializer),movingMeanInitializer:tE(this.movingMeanInitializer),movingVarianceInitializer:tE(this.movingVarianceInitializer),betaRegularizer:v_(this.betaRegularizer),gammaRegularizer:v_(this.gammaRegularizer),betaConstraint:DE(this.betaConstraint),gammaConstraint:DE(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}}OA.className="BatchNormalization",by(OA);class FA extends yE{constructor(e){if(null==e&&(e={}),super(e),this.axis=null==e.axis?-1:e.axis,"number"===typeof this.axis){if(!Number.isInteger(this.axis))throw new Error("Expected axis to be an integer, but received ".concat(this.axis))}else{if(!Array.isArray(this.axis))throw new Error("Expected axis to be an integer or an array of integers, "+"but received ".concat(JSON.stringify(this.axis)));for(const e of this.axis)if(!Number.isInteger(e))throw new Error("Expected axis to be an array of integers, "+"but received ".concat(JSON.stringify(this.axis)))}this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=nE(e.betaInitializer||"zeros"),this.gammaInitializer=nE(e.gammaInitializer||"ones"),this.betaRegularizer=k_(e.betaRegularizer),this.gammaRegularizer=k_(e.gammaRegularizer),this.supportsMasking=!0}build(e){const t=(e=iE(e)).length;"number"===typeof this.axis&&(this.axis=[this.axis]);for(let s=0;s<this.axis.length;++s)this.axis[s]<0&&(this.axis[s]+=t);for(const s of this.axis)if(s<0||s>=t)throw new Error("Invalid axis: ".concat(s));if(this.axis.length!==jN(this.axis).length)throw new Error("Found duplicate axes in: ".concat(this.axis));const n=this.axis.map(t=>e[t]),a=!0;this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,a):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,a):this.beta=null,this.built=!0}call(e,t){const n=rE(e),a=n.shape,s=a.length;return Km(()=>{let{mean:e,variance:t}=Zv(n,this.axis,!0);const r=EN(1,s);for(const n of this.axis)r[n]=a[n];const i=e=>null!=e&&e.shape.length!==s?tx(e,r):e;let o=this.scale?i(this.gamma.read()):null,c=this.center?i(this.beta.read()):null;const l=[],u=[];for(let n=0;n<s;++n)-1!==this.axis.indexOf(n)?(l.push(a[n]),u.push(1)):(l.push(1),u.push(a[n]));return e=dv(e,l),t=dv(t,l),null!=o&&(o=dv(o,u)),null!=c&&(c=dv(c,u)),PA(n,e,t,c,o,this.epsilon)})}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:tE(this.betaInitializer),gammaInitializer:tE(this.gammaInitializer),betaRegularizer:v_(this.betaRegularizer),gammaRegularizer:v_(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}}FA.className="LayerNormalization",by(FA);class LA extends yE{constructor(e){if(null==e&&(e={}),super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,null==e.padding)this.padding=[[1,1],[1,1]];else if("number"===typeof e.padding)this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,2!==e.padding.length)throw new CN("ZeroPadding2D expects padding to be a length-2 array, but "+"received a length-".concat(e.padding.length," array."));let t,n;if("number"===typeof e.padding[0])t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,2!==e.padding[0].length)throw new CN("ZeroPadding2D expects height padding to be a length-2 array, "+"but received a length-".concat(e.padding[0].length," array."));if(t=e.padding[0],2!==e.padding[1].length)throw new CN("ZeroPadding2D expects width padding to be a length-2 array, "+"but received a length-".concat(e.padding[1].length," array."));n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new dE({ndim:4})]}computeOutputShape(e){let t,n;return e=iE(e),"channelsFirst"===this.dataFormat?(t=null!=e[2]&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[3]&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],t,n]):(t=null!=e[1]&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[2]&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],t,n,e[3]])}call(e,t){return Km(()=>{return t=rE(e),n=this.padding,a=this.dataFormat,Km(()=>{if(4!==t.rank)throw new CN("temporalPadding expects input tensor to be 4-D, but received a "+"".concat(t.rank,"-D tensor."));if(null==n&&(n=[[1,1],[1,1]]),2!==n.length||2!==n[0].length||2!==n[1].length)throw new CN("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==a&&(a="channelsLast"),"channelsLast"!==a&&"channelsFirst"!==a)throw new CN("Unknown data format: ".concat(a,". ")+"Supported data formats are 'channelsLast' and 'channelsFirst.");let e;return e="channelsFirst"===a?[[0,0],[0,0],n[0],n[1]]:[[0,0],n[0],n[1],[0,0]],sw(t,e)});var t,n,a})}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}function zA(e,t,n,a,s,r){return Km(()=>{let i;aT(s),rT(r),sT(a),null==n&&(n=[1,1]),null==a&&(a="valid"),null==s&&(s="channelsLast"),null==r&&(r="max"),e=M_(e,s);const o="same"===a?"same":"valid";return i="max"===r?Wv(e,t,n,o):nx(e,t,n,o),"channelsFirst"===s&&(i=Ik(i,[0,3,1,2])),i})}function BA(e,t,n,a,s,r){return Km(()=>{let i;aT(s),rT(r),sT(a),null==n&&(n=[1,1,1]),null==a&&(a="valid"),null==s&&(s="channelsLast"),null==r&&(r="max"),e=P_(e,s);const o="same"===a?"same":"valid";return i="max"===r?Vv(e,t,n,o):ax(e,t,n,o),"channelsFirst"===s&&(i=Ik(i,[0,4,1,2,3])),i})}LA.className="ZeroPadding2D",by(LA);class jA extends yE{constructor(e){if(null==e.poolSize&&(e.poolSize=2),super(e),"number"===typeof e.poolSize)this.poolSize=[e.poolSize];else{if(!Array.isArray(e.poolSize)||1!==e.poolSize.length||"number"!==typeof e.poolSize[0])throw new CN("poolSize for 1D convolutional layer must be a number or an Array of a single number, but received "+"".concat(JSON.stringify(e.poolSize)));this.poolSize=e.poolSize}if(HN(this.poolSize,"poolSize"),null==e.strides)this.strides=this.poolSize;else if("number"===typeof e.strides)this.strides=[e.strides];else{if(!Array.isArray(e.strides)||1!==e.strides.length||"number"!==typeof e.strides[0])throw new CN("strides for 1D convolutional layer must be a number or an Array of a single number, but received "+"".concat(JSON.stringify(e.strides)));this.strides=e.strides}HN(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,sT(this.padding),this.inputSpec=[new dE({ndim:3})]}computeOutputShape(e){const t=__((e=iE(e))[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return Km(()=>{this.invokeCallHook(e,t),e=vT(rE(e),2);const n=this.poolingFunction(rE(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return tk(n,[2])})}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}}class WA extends jA{constructor(e){super(e)}poolingFunction(e,t,n,a,s){return aT(s),sT(a),zA(e,t,n,a,s,"max")}}WA.className="MaxPooling1D",by(WA);class VA extends jA{constructor(e){super(e)}poolingFunction(e,t,n,a,s){return aT(s),sT(a),zA(e,t,n,a,s,"avg")}}VA.className="AveragePooling1D",by(VA);class UA extends yE{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(2!==e.strides.length)throw new CN("If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length "+"".concat(e.strides.length,"."));this.strides=e.strides}else this.strides=[e.strides,e.strides];HN(this.poolSize,"poolSize"),HN(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,aT(this.dataFormat),sT(this.padding),this.inputSpec=[new dE({ndim:4})]}computeOutputShape(e){e=iE(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2];return t=__(t,this.poolSize[0],this.padding,this.strides[0]),n=__(n,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return Km(()=>(this.invokeCallHook(e,t),this.poolingFunction(rE(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class HA extends UA{constructor(e){super(e)}poolingFunction(e,t,n,a,s){return aT(s),sT(a),zA(e,t,n,a,s,"max")}}HA.className="MaxPooling2D",by(HA);class GA extends UA{constructor(e){super(e)}poolingFunction(e,t,n,a,s){return aT(s),sT(a),zA(e,t,n,a,s,"avg")}}GA.className="AveragePooling2D",by(GA);class qA extends yE{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(3!==e.strides.length)throw new CN("If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length "+"".concat(e.strides.length,"."));this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];HN(this.poolSize,"poolSize"),HN(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,aT(this.dataFormat),sT(this.padding),this.inputSpec=[new dE({ndim:5})]}computeOutputShape(e){e=iE(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],a="channelsFirst"===this.dataFormat?e[4]:e[3];return t=__(t,this.poolSize[0],this.padding,this.strides[0]),n=__(n,this.poolSize[1],this.padding,this.strides[1]),a=__(a,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n,a]:[e[0],t,n,a,e[4]]}call(e,t){return Km(()=>(this.invokeCallHook(e,t),this.poolingFunction(rE(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class KA extends qA{constructor(e){super(e)}poolingFunction(e,t,n,a,s){return aT(s),sT(a),BA(e,t,n,a,s,"max")}}KA.className="MaxPooling3D",by(KA);class XA extends qA{constructor(e){super(e)}poolingFunction(e,t,n,a,s){return aT(s),sT(a),BA(e,t,n,a,s,"avg")}}XA.className="AveragePooling3D",by(XA);class YA extends yE{constructor(e){super(e),this.inputSpec=[new dE({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new IN}}class QA extends YA{constructor(e){super(e||{})}call(e,t){return Km(()=>{const t=rE(e);return Hv(t,1)})}}QA.className="GlobalAveragePooling1D",by(QA);class ZA extends YA{constructor(e){super(e||{})}call(e,t){return Km(()=>{const t=rE(e);return av(t,1)})}}ZA.className="GlobalMaxPooling1D",by(ZA);class JA extends yE{constructor(e){super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,aT(this.dataFormat),this.inputSpec=[new dE({ndim:4})]}computeOutputShape(e){return"channelsLast"===this.dataFormat?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new IN}getConfig(){const e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class $A extends JA{call(e,t){return Km(()=>{const t=rE(e);return"channelsLast"===this.dataFormat?Hv(t,[1,2]):Hv(t,[2,3])})}}$A.className="GlobalAveragePooling2D",by($A);class eM extends JA{call(e,t){return Km(()=>{const t=rE(e);return"channelsLast"===this.dataFormat?av(t,[1,2]):av(t,[2,3])})}}eM.className="GlobalMaxPooling2D",by(eM);class tM extends yE{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(e){null!=this.layer&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const a=XE(t.layer,n);delete t.layer;const s={layer:a};return Object.assign(s,t),new e(s)}}class nM extends tM{constructor(e){super(e),this.supportsMasking=!0}build(e){if((e=iE(e)).length<3)throw new CN("TimeDistributed layer expects an input shape >= 3D, but received "+"input shape ".concat(JSON.stringify(e)));this.inputSpec=[{shape:e}];const t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){const t=[(e=iE(e))[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t),a=e[1];return[n[0],a].concat(n.slice(1))}call(e,t){return Km(()=>Q_((e,n)=>[rE(this.layer.call(e,t)),[]],e=rE(e),[],!1,null,null,!1,!0)[1])}}nM.className="TimeDistributed",by(nM);class aM extends tM{constructor(e){super(e);const t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=XE(n),t.goBackwards=!0!==t.goBackwards;const a={};var s;if(a.className=e.layer.getClassName(),a.config=t,this.backwardLayer=XE(a),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===e.mergeMode?"concat":e.mergeMode,s=this.mergeMode,VN(tT,"BidirectionalMergeMode",s),e.weights)throw new IN("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const t=e.length,n=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))}computeOutputShape(e){let t,n,a,s=this.forwardLayer.computeOutputShape(e);return Array.isArray(s)&&Array.isArray(s[0])||(s=[s]),this.returnState?(a=s.slice(1),t=s[0]):t=s[0],"concat"===this.mergeMode?(t[t.length-1]*=2,n=[t]):n=null==this.mergeMode?[t,t.slice()]:[t],this.returnState?null==this.mergeMode?n.concat(a).concat(a.slice()):[t].concat(a).concat(a.slice()):AN(n)}apply(e,t){let n=null==t?null:t.initialState,a=null==t?null:t.constants;null==t&&(t={});const s=Y_(e,n,a,this.numConstants);if(e=s.inputs,n=s.initialState,a=s.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(null==n||0===n.length)&&null==a)return super.apply(e,t);const r=[],i=[];if(null!=n){const e=n.length;if(e%2>0)throw new CN("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=n,r.push(...n);const a=n.map(e=>new dE({shape:e.shape}));this.forwardLayer.stateSpec=a.slice(0,e/2),this.backwardLayer.stateSpec=a.slice(e/2),i.push(...a)}if(null!=a)throw new IN("Support for constants in Bidirectional layers is not implemented yet.");const o=r[0]instanceof pE;for(const c of r)if(c instanceof pE!==o)throw new CN("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(o){const n=[e].concat(r),a=this.inputSpec.concat(i),s=this.inputSpec;this.inputSpec=a;const o=super.apply(n,t);return this.inputSpec=s,o}return super.apply(e,t)}call(e,t){return Km(()=>{const n=t.initialState;let a,s,r,i;if(null==n)a=this.forwardLayer.call(e,t),s=this.backwardLayer.call(e,t);else{const r=n.slice(0,n.length/2),i=n.slice(n.length/2);a=this.forwardLayer.call(e,Object.assign(t,{initialState:r})),s=this.backwardLayer.call(e,Object.assign(t,{initialState:i}))}return this.returnState&&(Array.isArray(a)&&(r=a.slice(1).concat(s.slice(1))),a=a[0],s=s[0]),this.returnSequences&&(s=Aw(s,1)),"concat"===this.mergeMode?i=CT([a,s]):"sum"===this.mergeMode?i=ry(a,s):"ave"===this.mergeMode?i=cy(.5,ry(a,s)):"mul"===this.mergeMode?i=cy(a,s):null==this.mergeMode&&(i=[a,s]),this.returnState?null==this.mergeMode?i.concat(r):[i].concat(r):i})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){oT(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),oT(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,t){let n;if(Array.isArray(t)&&(t=t[0]),n=this.returnSequences?null==this.mergeMode?[t,t]:t:null==this.mergeMode?[null,null]:null,this.returnState){const e=this.forwardLayer.states.map(e=>null);return Array.isArray(n)?n.concat(e).concat(e):[n].concat(e).concat(e)}return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(e),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){const n=XE(t.layer);if(delete t.layer,null!=t.numConstants)throw new IN("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const a=t;return a.layer=n,new e(a)}}aM.className="Bidirectional",by(aM);class sM extends yE{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){const e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return Km(()=>("float32"!==(e=rE(e)).dtype&&(e=xT(e,"float32")),ry(cy(e,this.scale),this.offset)))}}sM.className="Rescaling",by(sM);const{resizeBilinear:rM,cropAndResize:iM}=US;class oM extends yE{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,n,a,s,r,i,o){return Km(()=>{let c,l=!1;const u=[t/r,n/i,(a+t)/r,(s+n)/i],h=[];3===e.rank?(l=!0,c=nk([e])):c=e;for(let e=0;e<c.shape[0];e++)h.push(u);const d=Vm(h,[h.length,4]),p=Nw(0,h.length,1,"int32"),f=iM(c,d,p,[a,s],"nearest");return xT(l?rE(xk(f)):f,o)})}upsize(e,t,n,a){return Km(()=>xT(rM(e,[t,n]),a))}call(e,t){return Km(()=>{const t=rE(e),n=t.dtype,a=t.shape,s=a[a.length-3],r=a[a.length-2];let i=0;s!==this.height&&(i=Math.floor((s-this.height)/2));let o=0;return r!==this.width&&(o=Math.floor((r-this.width)/2),0===o&&(o=1)),i>=0&&o>=0?this.centerCrop(t,i,o,this.height,this.width,s,r,n):this.upsize(e,this.height,this.width,n)})}getConfig(){const e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){const t=(e=iE(e)).length-3,n=e.length-2;return e[t]=this.height,e[n]=this.width,e}}oM.className="CenterCrop",by(oM);class cM extends yE{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return null==(e=iE(e))?[this.numTokens]:"oneHot"===this.outputMode&&1!==e[e.length-1]?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return Km(()=>{let n;if("int32"!==(e=rE(e)).dtype&&(e=xT(e,"int32")),"undefined"!==typeof t.countWeights){if("count"!==this.outputMode)throw new CN("countWeights is not used when outputMode !== count.\n              Received countWeights=".concat(t.countWeights));n=rE(t.countWeights)}const a=av(e),s=sv(e),r=gv(this.numTokens,a).bufferSync().get(0),i=yv(s,0).bufferSync().get(0);if(!r||!i)throw new CN("Input values must be between 0 < values <="+" numTokens with numTokens=".concat(this.numTokens));return function(e,t,n,a){let s=rE(e);if("int32"!==s.dtype&&(s=xT(s,"int32")),"int"===t)return s;const r=s.shape;if(0===s.rank&&(s=uv(s,-1)),"oneHot"===t&&1!==s.shape[s.shape.length-1]&&(s=uv(s,-1)),s.rank>2)throw new CN("When outputMode is not int, maximum output rank is 2"+" Received outputMode ".concat(t," and input shape ").concat(r)+" which would result in output rank ".concat(s.rank,"."));const i=["multiHot","oneHot"].includes(t),o=s;let c;if(c=Fx(o,"undefined"!==typeof a&&"count"===t?a:[],n,i),"tfIdf"!==t)return c;if(a)return cy(c,a);throw new CN("When outputMode is 'tfIdf', weights must be provided.")}(e,this.outputMode,this.numTokens,n)})}}cM.className="CategoryEncoding",by(cM);const lM=new Set(["bilinear","nearest"]);class uM extends yE{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation){if(!lM.has(e.interpolation))throw new CN("Invalid interpolation parameter: ".concat(e.interpolation," is not implemented"));this.interpolation=e.interpolation}else this.interpolation="bilinear";this.cropToAspectRatio=Boolean(e.cropToAspectRatio)}computeOutputShape(e){const t=(e=iE(e))[2];return[this.height,this.width,t]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return Km(()=>{const t=[this.height,this.width];if("bilinear"===this.interpolation)return US.resizeBilinear(e,t,!this.cropToAspectRatio);if("nearest"===this.interpolation)return US.resizeNearestNeighbor(e,t,!this.cropToAspectRatio);throw new Error("Interpolation is ".concat(this.interpolation," but only ").concat([...lM]," are supported"))})}}uM.className="Resizing",by(uM);class hM{constructor(e){this.seed=e}next(){if(void 0!==this.seed)return this.seed++}}hM.className="RandomSeed";class dM extends yE{constructor(e){super(e),this.randomGenerator=new hM(e.seed)}getConfig(){const e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}}dM.className="BaseRandomLayer";const pM=new Set(["bilinear","nearest"]);class fM extends dM{constructor(e){super(e);const{factor:t,interpolation:n="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&2===this.factor.length)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else{if(Array.isArray(this.factor)||!(this.factor>0))throw new CN("Invalid factor: ".concat(this.factor,". Must be positive number or tuple of 2 numbers"));this.widthLower=-this.factor,this.widthUpper=this.factor}if(this.widthLower<-1||this.widthUpper<-1)throw new CN("factor must have values larger than -1. Got: ".concat(this.factor));if(this.widthUpper<this.widthLower)throw new CN("factor cannot have upper bound less than lower bound.\n        Got upper bound: ".concat(this.widthUpper,".\n        Got lower bound: ").concat(this.widthLower,"\n      "));if(n){if(!pM.has(n))throw new CN("Invalid interpolation parameter: ".concat(n," is not implemented"));this.interpolation=n}}getConfig(){const e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){const t=(e=iE(e))[2];return[this.imgHeight,-1,t]}call(e,t){return Km(()=>{const t=rE(e);this.imgHeight=t.shape[t.shape.length-3];const n=t.shape[t.shape.length-2];this.widthFactor=Cw([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let a=this.widthFactor.dataSync()[0]*n;a=Math.round(a);const s=[this.imgHeight,a];switch(this.interpolation){case"bilinear":return US.resizeBilinear(e,s);case"nearest":return US.resizeNearestNeighbor(e,s);default:throw new Error("Interpolation is ".concat(this.interpolation,"\n          but only ").concat([...pM]," are supported"))}})}}fM.className="RandomWidth",by(fM);var mM,gM;$u().registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")}),function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF"}(mM||(mM={})),function(e){let t;!function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"}(t=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))}(gM||(gM={}));const yM={};function bM(e){return yM[e]}function xM(e,t,n,a,s){const r=t.inputParams[e];if(r&&void 0!==r.inputIndexStart){const e=r.inputIndexStart,i=0===r.inputIndexEnd?void 0:void 0===r.inputIndexEnd?e+1:r.inputIndexEnd,o=e<0?t.inputNames.length+e:e;if("tensor"===r.type)return vM(t.inputNames[o],n,a,s);if("tensors"===r.type){const r=t.inputs.slice(e,i),o=t.inputNames.slice(e,i).filter((e,t)=>{var n;return"NoOp"!==(null===(n=r[t])||void 0===n?void 0:n.op)});return o.map(e=>vM(e,n,a,s))}const c=vM(t.inputNames[o],n,a,s),l=c.dataSync();return"number"===r.type?l[0]:Wu(c.shape,l)}const i=t.attrParams[e];return i&&i.value}function vM(e,t,n,a){const[s,r]=CM(e,n);if(null!=a){const e=a.getHashTableHandleByName(s);if(null!=e)return e}const i=n.currentContextIds.find(e=>!!t[SM(s,e)]);return void 0!==i?t[SM(s,i)][r]:void 0}function wM(e,t,n){return t[SM(e,n.currentContextId)]}function kM(e,t){const[n,a,s]=CM(e,t);return[SM(n,t&&t.currentContextId),a,s]}function SM(e,t){return t?"".concat(e,"-").concat(t):e}function CM(e,t){if(""===e)return["",0,void 0];const n=null!=t&&null!=t.parseNodeNameCache;if(n){const n=t.parseNodeNameCache.get(e);if(null!=n)return n}const a=e.split(":");let s;if(1===a.length)s=[e,0,void 0];else{const e=a[0],t=3===a.length?a[1]:void 0;s=[e,Number(a[a.length-1]),t]}return n&&t.parseNodeNameCache.set(e,s),s}function IM(e,t,n){let a=xM("pad",e,t,n);if("explicit"===a){a=xM("explicitPaddings",e,t,n);const s=[[0,0],[0,0],[0,0],[0,0]];for(let e=0;e<4;e++)s[e][0]=a[2*e],s[e][1]=a[2*e+1];return s}return a}function NM(e){return e.kept?e:ay(e)}const TM=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],EM=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],RM=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],_M=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],AM=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],MM=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],PM=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],DM=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],OM=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],FM=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],LM=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],zM=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],BM=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],jM=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],WM=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],VM=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],UM=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],HM=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],GM=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];class qM{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[].concat(...[i,o,c,l,u,h,d,p,f,m,g,y,b,x,v,w,k,S,C].map(e=>e.json));this.opMappers=e.reduce((e,t)=>(e[t.tfOpName]=t,e),{})}transformGraph(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=e.node,a=[],s=[],r=[],i=n.reduce((e,t)=>(e[t.name]=this.mapNode(t),t.op.startsWith("Placeholder")?a.push(e[t.name]):"Const"===t.op?s.push(e[t.name]):null!=t.input&&0!==t.input.length||r.push(e[t.name]),e),{});let o=[];const c=[];let l={},u={};null!=t&&(l=this.mapSignatureEntries(t.inputs),u=this.mapSignatureEntries(t.outputs));const h=Object.keys(i);h.forEach(e=>{const t=i[e];t.inputNames.forEach((e,n)=>{const[a,,s]=kM(e),r=i[a];if(null!=r.outputs){const e=r.outputs.indexOf(s);if(-1!==e){const s="".concat(a,":").concat(e);t.inputNames[n]=s}}t.inputs.push(r),r.children.push(t)})}),0===Object.keys(u).length?h.forEach(e=>{const t=i[e];0===t.children.length&&c.push(t)}):Object.keys(u).forEach(e=>{const[t]=kM(e),n=i[t];null!=n&&(n.signatureKey=u[e],c.push(n))}),Object.keys(l).length>0?Object.keys(l).forEach(e=>{const[t]=kM(e),n=i[t];n&&(n.signatureKey=l[e],o.push(n))}):o=a;let d={};null!=e.library&&null!=e.library.function&&(d=e.library.function.reduce((e,t)=>(e[t.signature.name]=this.mapFunction(t),e),{}));const p={nodes:i,inputs:o,outputs:c,weights:s,placeholders:a,signature:t,functions:d};return r.length>0&&(p.initNodes=r),p}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,n)=>(t[e[n].name]=n,t),{})}mapNode(e){const t=bM(e.op)||this.opMappers[e.op]||{};null==e.attr&&(e.attr={});const n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(e=>e.startsWith("^")?e.slice(1):e),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return null!=t.inputs&&(n.inputParams=t.inputs.reduce((e,t)=>(e[t.name]={type:t.type,inputIndexStart:t.start,inputIndexEnd:t.end},e),{})),null!=t.attrs&&(n.attrParams=t.attrs.reduce((t,n)=>{const a=n.type;let s;switch(n.type){case"string":s=XM(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=XM(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"string[]":s=sP(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=sP(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number":s=QM(e.attr,n.tfName,n.defaultValue||0),void 0===s&&n.tfDeprecatedName&&(s=QM(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number[]":s=aP(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=aP(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool":s=YM(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=YM(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool[]":s=iP(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=iP(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape":s=nP(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=nP(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape[]":s=rP(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=rP(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype":s=$M(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=$M(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype[]":s=eP(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=eP(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"func":s=JM(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=JM(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error("Unsupported param type: ".concat(n.type," for op: ").concat(e.op))}return t[n.name]={value:s,type:a},t},{})),n}mapFunction(e){const t=e.nodeDef,n=[];let a={};null!=t&&(a=t.reduce((e,t)=>(e[t.name]=this.mapNode(t),"Const"===t.op&&n.push(e[t.name]),e),{}));const s=[],r=[];e.signature.inputArg.forEach(e=>{const[t]=kM(e.name),n={name:t,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:ZM(e.type),type:"dtype"}},children:[]};n.signatureKey=e.name,s.push(n),a[t]=n});Object.keys(a).forEach(e=>{const t=a[e];t.inputNames.forEach((e,n)=>{const[s,,r]=kM(e),i=a[s];if(null!=i.outputs){const e=i.outputs.indexOf(r);if(-1!==e){const a="".concat(s,":").concat(e);t.inputNames[n]=a}}t.inputs.push(i),i.children.push(t)})});const i=e.ret;e.signature.outputArg.forEach(e=>{const[t,n]=kM(i[e.name]),s=a[t];null!=s&&(s.defaultOutput=n,r.push(s))});const o=this.mapArgsToSignature(e);return{nodes:a,inputs:s,outputs:r,weights:n,placeholders:[],signature:o}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((e,t)=>(e[t.name]=this.mapArgToTensorInfo(t),e),{}),outputs:e.signature.outputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t),{})}}mapArgToTensorInfo(e,t){let n=e.name;return null!=t&&(n=t[n]),{name:n,dtype:e.type}}}function KM(e,t){const n=Array.isArray(e)?String.fromCharCode.apply(null,e):function(e){const t=$u().global;if("undefined"!==typeof t.atob)return t.atob(e);if("undefined"!==typeof Buffer)return new Buffer(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(e);return t?n:n.toLowerCase()}function XM(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s=e[t];return null!=s?KM(s.s,a):n}function YM(e,t,n){const a=e[t];return a?a.b:n}function QM(e,t,n){const a=e[t]||{},s=null!=a.i?a.i:null!=a.f?a.f:n;return"number"===typeof s?s:parseInt(s,10)}function ZM(e){switch("string"===typeof e&&(e=mM[e]),e){case mM.DT_FLOAT:case mM.DT_HALF:return"float32";case mM.DT_INT32:case mM.DT_INT64:case mM.DT_INT8:case mM.DT_UINT8:return"int32";case mM.DT_BOOL:return"bool";case mM.DT_DOUBLE:return"float32";case mM.DT_STRING:return"string";case mM.DT_COMPLEX64:case mM.DT_COMPLEX128:return"complex64";default:return null}}function JM(e,t,n){const a=e[t];return a&&a.func?a.func.name:n}function $M(e,t,n){const a=e[t];return a&&a.type?ZM(a.type):n}function eP(e,t,n){const a=e[t];return a&&a.list&&a.list.type?a.list.type.map(e=>ZM(e)):n}function tP(e){if(!e.unknownRank)return null!=e.dim?e.dim.map(e=>"number"===typeof e.size?e.size:parseInt(e.size,10)):[]}function nP(e,t,n){const a=e[t];return a&&a.shape?tP(a.shape):n}function aP(e,t,n){const a=e[t];return a?((a.list.f&&a.list.f.length?a.list.f:a.list.i)||[]).map(e=>"number"===typeof e?e:parseInt(e,10)):n}function sP(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s=e[t];return s&&s.list&&s.list.s?s.list.s.map(e=>KM(e,a)):n}function rP(e,t,n){const a=e[t];return a&&a.list&&a.list.shape?a.list.shape.map(e=>tP(e)):n}function iP(e,t,n){const a=e[t];return a&&a.list&&a.list.b?a.list.b:n}class oP{constructor(e,t,n){this.node=e,this.tensorMap=t,this.context=n,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(e=>this.getInput(e)),null!=e.rawAttrs&&(this.attrs=Object.keys(e.rawAttrs).reduce((e,t)=>(e[t]=this.getAttr(t),e),{}))}getInput(e){return vM(e,this.tensorMap,this.context)}getAttr(e,t){const n=this.node.rawAttrs[e];if(null!=n.tensor)return vM(e,this.tensorMap,this.context);if(null!=n.i||null!=n.f)return QM(this.node.rawAttrs,e,t);if(null!=n.s)return XM(this.node.rawAttrs,e,t);if(null!=n.b)return YM(this.node.rawAttrs,e,t);if(null!=n.shape)return nP(this.node.rawAttrs,e,t);if(null!=n.type)return $M(this.node.rawAttrs,e,t);if(null!=n.list){if(null!=n.list.i||null!=n.list.f)return aP(this.node.rawAttrs,e,t);if(null!=n.list.s)return sP(this.node.rawAttrs,e,t);if(null!=n.list.shape)return rP(this.node.rawAttrs,e,t);if(null!=n.list.b)return iP(this.node.rawAttrs,e,t);if(null!=n.list.type)return eP(this.node.rawAttrs,e,t)}return t}}function cP(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";if("number"!==typeof e&&"number"!==typeof t){yu(e.length===t.length,()=>n+" Shapes ".concat(e," and ").concat(t," must match"));for(let a=0;a<e.length;a++){const s=e[a],r=t[a];yu(s<0||r<0||s===r,()=>n+" Shapes ".concat(e," and ").concat(t," must match"))}}}function lP(e){return"number"!==typeof e&&!e.some(e=>e<0)}function uP(e,t,n){let a=hP(e,n);const s=!lP(a);if(s&&0===t.length)throw new Error("Tried to calculate elements of an empty list"+" with non-fully-defined elementShape: ".concat(a));if(s&&t.forEach(e=>{a=hP(e.shape,a)}),!lP(a))throw new Error("Non-fully-defined elementShape: ".concat(a));return a}function hP(e,t){if("number"===typeof e)return t;if("number"===typeof t)return e;if(e.length!==t.length)throw new Error("Incompatible ranks during merge: ".concat(e," vs. ").concat(t));const n=[];for(let a=0;a<e.length;++a){const s=e[a],r=t[a];if(s>=0&&r>=0&&s!==r)throw new Error("Incompatible shape during merge: ".concat(e," vs. ").concat(t));n[a]=s>=0?s:r}return n}class dP{constructor(e,t,n,a,s,r,i){this.name=e,this.dtype=t,this.maxSize=n,this.elementShape=a,this.identicalElementShapes=s,this.dynamicSize=r,this.clearAfterRead=i,this.tensors=[],this.closed_=!1,this.idTensor=py(0),Ym(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{null!=e&&e.has(t.tensor.id)||t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error("TensorArray ".concat(this.name," has already been closed."));if(e<0||e>=this.size())throw new Error("Tried to read from index ".concat(e,", but array size is: ").concat(this.size()));const t=this.tensors[e];if(t.cleared)throw new Error("TensorArray ".concat(this.name,": Could not read index ").concat(e," twice because it was cleared after a previous read ")+"(perhaps try setting clear_after_read = false?).");return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(e=>this.read(e))}write(e,t){if(this.closed_)throw new Error("TensorArray ".concat(this.name," has already been closed."));if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error("Tried to write to index ".concat(e,", but array is not resizeable and size is: ").concat(this.maxSize));const n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error("TensorArray ".concat(this.name,": Could not write to TensorArray index ").concat(e,",\n          because the value dtype is ").concat(t.dtype,", but TensorArray dtype is ").concat(this.dtype,"."));if(0!==this.size()||null!=this.elementShape&&0!==this.elementShape.length||(this.elementShape=t.shape),cP(this.elementShape,t.shape,"TensorArray ".concat(this.name,": Could not write to TensorArray index ").concat(e,".")),n.read)throw new Error("TensorArray ".concat(this.name,": Could not write to TensorArray index ").concat(e,", because it has already been read."));if(n.written)throw new Error("TensorArray ".concat(this.name,": Could not write to TensorArray index ").concat(e,", because it has already been written."));n.tensor=t,Ym(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error("TensorArray ".concat(this.name,": could not write multiple tensors,")+"because the index size: ".concat(e.length," is not the same as tensors size: ").concat(t.length,"."));e.forEach((e,n)=>this.write(e,t[n]))}gather(e,t){if(t&&t!==this.dtype)throw new Error("TensorArray dtype is ".concat(this.dtype," but gather requested dtype ").concat(t));if(e)e=e.slice(0,this.size());else{e=[];for(let t=0;t<this.size();t++)e.push(t)}if(0===e.length)return Vm([],[0].concat(this.elementShape));const n=this.readMany(e);return cP(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),nk(n,0)}concat(e){if(e&&e!==this.dtype)throw new Error("TensorArray dtype is ".concat(this.dtype," but concat requested dtype ").concat(e));if(0===this.size())return Vm([],[0].concat(this.elementShape));const t=[];for(let a=0;a<this.size();a++)t.push(a);const n=this.readMany(t);return cP(this.elementShape,n[0].shape,"TensorArray shape mismatch: tensor array shape (".concat(this.elementShape,") vs first tensor shape (").concat(n[0].shape,")")),sx(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error("TensorArray dtype is ".concat(this.dtype," but tensor has dtype ").concat(t.dtype));if(e.length!==t.shape[0])throw new Error("Expected len(indices) == tensor.shape[0], but saw: ".concat(e.length," vs. ").concat(t.shape[0]));const n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error("Max index must be < array size (".concat(n,"  vs. ").concat(this.maxSize,")"));this.writeMany(e,xk(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error("TensorArray dtype is ".concat(this.dtype," but tensor has dtype ").concat(t.dtype));let n=0;const a=e.map(e=>(n+=e,n));if(n!==t.shape[0])throw new Error("Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ".concat(n,", and tensor's shape is: ").concat(t.shape));if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error("TensorArray's size is not equal to the size of lengths (".concat(this.maxSize," vs. ").concat(e.length,"), ")+"and the TensorArray is not marked as dynamically resizeable");const s=0===n?0:t.size/n,r=[];Km(()=>{t=tx(t,[1,n,s]);for(let n=0;n<e.length;++n){const i=[0,0===n?0:a[n-1],0],o=[1,e[n],s];r[n]=tx(ox(t,i,o),this.elementShape)}return r});const i=[];for(let o=0;o<e.length;o++)i[o]=o;this.writeMany(i,r)}}class pP{get id(){return this.idTensor.id}constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:-1;this.tensors=e,this.elementShape=t,this.elementDtype=n,null!=e&&e.forEach(e=>{if(n!==e.dtype)throw new Error("Invalid data types; op elements ".concat(n,", but list elements ").concat(e.dtype));cP(t,e.shape,"TensorList shape mismatch: "),Ym(e)}),this.idTensor=py(0),this.maxNumElements=a,Ym(this.idTensor)}copy(){return new pP([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{null!=e&&e.has(t.id)||t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;if(t!==this.elementDtype)throw new Error("Invalid data types; op elements ".concat(t,", but list elements ").concat(this.elementDtype));if(-1!==n&&this.tensors.length!==n)throw new Error("Operation expected a list with ".concat(n," elements but got a list with ").concat(this.tensors.length," elements."));cP(e,this.elementShape,"TensorList shape mismatch: ");const a=uP(this.elementShape,this.tensors,e);return Km(()=>{const e=this.tensors.map(e=>tx(e,a));return nk(e,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error("Invalid data types; op elements ".concat(t,", but list elements ").concat(this.elementDtype));if(0===this.size())throw new Error("Trying to pop from an empty list.");const n=uP(this.elementShape,this.tensors,e),a=this.tensors.pop();return a.kept=!1,cP(a.shape,e,"TensorList shape mismatch: "),tx(a,n)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error("Invalid data types; op elements ".concat(e.dtype,", but list elements ").concat(this.elementDtype));if(cP(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");Ym(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error("TensorListResize expects size to be non-negative. Got: ".concat(e));if(-1!==this.maxNumElements&&e>this.maxNumElements)throw new Error("TensorListResize input size ".concat(e," is greater maxNumElement ").concat(this.maxNumElements,"."));const t=new pP([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let n=0;n<Math.min(this.tensors.length,e);++n)t.tensors[n]=this.tensors[n];return t}getItem(e,t,n){if(n!==this.elementDtype)throw new Error("Invalid data types; op elements ".concat(n,", but list elements ").concat(this.elementDtype));if(e<0||e>this.tensors.length)throw new Error("Trying to access element ".concat(e," in a list with ").concat(this.tensors.length," elements."));if(null==this.tensors[e])throw new Error("element at index ".concat(e," is null."));cP(this.tensors[e].shape,t,"TensorList shape mismatch: ");const a=uP(this.elementShape,this.tensors,t);return tx(this.tensors[e],a)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error("Invalid data types; op elements ".concat(t.dtype,", but list elements ").concat(this.elementDtype));if(e<0||-1!==this.maxNumElements&&e>=this.maxNumElements)throw new Error("Trying to set element ".concat(e," in a list with max ").concat(this.maxNumElements," elements."));cP(this.elementShape,t.shape,"TensorList shape mismatch: "),Ym(t),null!=this.tensors[e]&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,n){if(t!==this.elementDtype)throw new Error("Invalid data types; op elements ".concat(t,", but list elements ").concat(this.elementDtype));cP(this.elementShape,n,"TensorList shape mismatch: "),e=e.slice(0,this.size());const a=uP(this.elementShape,this.tensors,n);return 0===e.length?Vm([],[0].concat(a)):Km(()=>{const t=e.map(e=>tx(this.tensors[e],a));return nk(t,0)})}concat(e,t){if(e&&e!==this.elementDtype)throw new Error("TensorList dtype is ".concat(this.elementDtype," but concat requested dtype ").concat(e));cP(this.elementShape,t,"TensorList shape mismatch: ");const n=uP(this.elementShape,this.tensors,t);return 0===this.size()?Vm([],[0].concat(n)):Km(()=>{const e=this.tensors.map(e=>tx(e,n));return sx(e,0)})}}const fP=async(e,t,n)=>{switch(e.op){case"If":case"StatelessIf":{const a=xM("thenBranch",e,t,n),s=xM("elseBranch",e,t,n),r=xM("cond",e,t,n),i=xM("args",e,t,n);return(await r.data())[0]?n.functionMap[a].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap):n.functionMap[s].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{const a=xM("body",e,t,n),s=xM("cond",e,t,n),r=xM("args",e,t,n),i=await n.functionMap[s].executeFunctionAsync(r,n.tensorArrayMap,n.tensorListMap),o=r.map(e=>e.id);let c=await i[0].data();i.forEach(e=>{e.kept||-1!==o.indexOf(e.id)||e.dispose()});let l=r;for(;c[0];){const e=l;l=await n.functionMap[a].executeFunctionAsync(l,n.tensorArrayMap,n.tensorListMap);const t=l.map(e=>e.id);e.forEach(e=>{e.kept||-1!==o.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()});const r=await n.functionMap[s].executeFunctionAsync(l,n.tensorArrayMap,n.tensorListMap);c=await r[0].data(),r.forEach(e=>{e.kept||-1!==o.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()})}return l}case"LoopCond":return[NM(xM("pred",e,t,n))];case"Switch":{const a=xM("pred",e,t,n);let s=xM("data",e,t,n);return s.kept||(s=NM(s)),(await a.data())[0]?[void 0,s]:[s,void 0]}case"Merge":{const a=e.inputNames.find(e=>void 0!==vM(e,t,n));if(a){return[NM(vM(a,t,n))]}return}case"Enter":{const a=xM("frameName",e,t,n),s=xM("tensor",e,t,n);return n.enterFrame(a),[NM(s)]}case"Exit":{const a=xM("tensor",e,t,n);return n.exitFrame(),[NM(a)]}case"NextIteration":{const a=xM("tensor",e,t,n);return n.nextIteration(),[NM(a)]}case"TensorArrayV3":{const a=xM("size",e,t,n),s=xM("dtype",e,t,n),r=xM("elementShape",e,t,n),i=xM("dynamicSize",e,t,n),o=xM("clearAfterRead",e,t,n),c=xM("identicalElementShapes",e,t,n),l=xM("name",e,t,n),u=new dP(l,s,a,r,c,i,o);return n.addTensorArray(u),[u.idTensor,py(1)]}case"TensorArrayWriteV3":{const a=xM("tensorArrayId",e,t,n),s=xM("index",e,t,n),r=xM("tensor",e,t,n),i=n.getTensorArray(a.id);return i.write(s,r),[i.idTensor]}case"TensorArrayReadV3":{const a=xM("tensorArrayId",e,t,n),s=xM("index",e,t,n);return[n.getTensorArray(a.id).read(s)]}case"TensorArrayGatherV3":{const a=xM("tensorArrayId",e,t,n),s=xM("indices",e,t,n),r=xM("dtype",e,t,n);return[n.getTensorArray(a.id).gather(s,r)]}case"TensorArrayScatterV3":{const a=xM("tensorArrayId",e,t,n),s=xM("indices",e,t,n),r=xM("tensor",e,t,n),i=n.getTensorArray(a.id);return i.scatter(s,r),[i.idTensor]}case"TensorArrayConcatV3":{const a=xM("tensorArrayId",e,t,n),s=n.getTensorArray(a.id),r=xM("dtype",e,t,n);return[s.concat(r)]}case"TensorArraySplitV3":{const a=xM("tensorArrayId",e,t,n),s=xM("tensor",e,t,n),r=xM("lengths",e,t,n),i=n.getTensorArray(a.id);return i.split(r,s),[i.idTensor]}case"TensorArraySizeV3":{const a=xM("tensorArrayId",e,t,n);return[py(n.getTensorArray(a.id).size(),"int32")]}case"TensorArrayCloseV3":{const a=xM("tensorArrayId",e,t,n),s=n.getTensorArray(a.id);return s.clearAndClose(),[s.idTensor]}case"TensorListSetItem":{const a=xM("tensorListId",e,t,n),s=xM("index",e,t,n),r=xM("tensor",e,t,n),i=n.getTensorList(a.id);return i.setItem(s,r),[i.idTensor]}case"TensorListGetItem":{const a=xM("tensorListId",e,t,n),s=xM("index",e,t,n),r=xM("elementShape",e,t,n),i=xM("elementDType",e,t,n);return[n.getTensorList(a.id).getItem(s,r,i)]}case"TensorListScatterV2":case"TensorListScatter":{const a=xM("indices",e,t,n),s=function(e,t,n,a){if(t.length!==e.shape[0])throw new Error("Expected len(indices) == tensor.shape[0], but saw: ".concat(t.length," vs. ").concat(e.shape[0]));const s=Math.max(...t);if(null!=a&&-1!==a&&s>=a)throw new Error("Max index must be < array size (".concat(s,"  vs. ").concat(a,")"));const r=new pP([],n,e.dtype,a),i=xk(e,0);return t.forEach((e,t)=>{r.setItem(e,i[t])}),r}(xM("tensor",e,t,n),a,xM("elementShape",e,t,n),xM("numElements",e,t,n));return n.addTensorList(s),[s.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const a=xM("elementShape",e,t,n),s=xM("elementDType",e,t,n);let r;r="TensorListReserve"===e.op?"numElements":"maxNumElements";const i=xM(r,e,t,n),o=function(e,t,n,a){return new pP([],e,t,a)}(a,s,0,"TensorListReserve"===e.op?-1:i);return n.addTensorList(o),[o.idTensor]}case"TensorListGather":{const a=xM("tensorListId",e,t,n),s=xM("indices",e,t,n),r=xM("elementShape",e,t,n),i=xM("elementDType",e,t,n);return[n.getTensorList(a.id).gather(s,i,r)]}case"TensorListStack":{const a=xM("tensorListId",e,t,n),s=xM("elementShape",e,t,n),r=xM("elementDType",e,t,n),i=xM("numElements",e,t,n);return[n.getTensorList(a.id).stack(s,r,i)]}case"TensorListFromTensor":{const a=function(e,t,n){const a=e.dtype;if(e.shape.length<1)throw new Error("Tensor must be at least a vector, but saw shape: ".concat(e.shape));if(e.dtype!==n)throw new Error("Invalid data types; op elements ".concat(e.dtype,", but list elements ").concat(n));cP(e.shape.slice(1),t,"TensorList shape mismatch: ");const s=xk(e);return new pP(s,t,a)}(xM("tensor",e,t,n),xM("elementShape",e,t,n),xM("elementDType",e,t,n));return n.addTensorList(a),[a.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const a=xM("tensorListId",e,t,n),s=n.getTensorList(a.id),r=xM("dtype",e,t,n),i=xM("elementShape",e,t,n);return[s.concat(r,i)]}case"TensorListPushBack":{const a=xM("tensorListId",e,t,n),s=xM("tensor",e,t,n),r=n.getTensorList(a.id);return r.pushBack(s),[r.idTensor]}case"TensorListPopBack":{const a=xM("tensorListId",e,t,n),s=xM("elementShape",e,t,n),r=xM("elementDType",e,t,n);return[n.getTensorList(a.id).popBack(s,r)]}case"TensorListSplit":{const a=xM("tensor",e,t,n),s=xM("elementShape",e,t,n),r=function(e,t,n){let a=0;const s=t.map(e=>(a+=e,a));if(a!==e.shape[0])throw new Error("Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ".concat(a,", and tensor's shape is: ").concat(e.shape));const r=hP(e.shape.slice(1),n),i=0===a?0:e.size/a,o=Km(()=>{const n=[];e=tx(e,[1,a,i]);for(let a=0;a<t.length;++a){const o=[0,0===a?0:s[a-1],0],c=[1,t[a],i];n[a]=tx(ox(e,o,c),r)}return e.dispose(),n}),c=new pP([],n,e.dtype,t.length);for(let l=0;l<o.length;l++)c.setItem(l,o[l]);return c}(a,xM("lengths",e,t,n),s);return n.addTensorList(r),[r.idTensor]}case"TensorListLength":{const a=xM("tensorListId",e,t,n);return[py(n.getTensorList(a.id).size(),"int32")]}case"TensorListResize":{const a=xM("tensorListId",e,t,n),s=xM("size",e,t,n),r=n.getTensorList(a.id).resize(s);return n.addTensorList(r),[r.idTensor]}default:throw TypeError("Node type ".concat(e.op," is not implemented"))}};function mP(e,t,n){const[a,s]=xM("fusedOps",e,t,n),r="biasadd"===a,i=!r,o="prelu"===s,c="fusedbatchnorm"===a,l=xM("numArgs",e,t,n);if(r){if(o&&2!==l)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&r&&1!==l)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(c)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const u=xM("strides",e,t,n),h=IM(e,t,n),d=xM("dataFormat",e,t,n).toUpperCase(),p=xM("dilations",e,t,n);let[f,m]=xM("args",e,t,n);i&&(m=f,f=void 0);return{stride:u,pad:h,dataFormat:d,dilations:p,biasArg:f,preluArg:m,activationFunc:s,leakyreluAlpha:xM("leakyreluAlpha",e,t,n)}}function gP(e,t,n){return{boxes:xM("boxes",e,t,n),scores:xM("scores",e,t,n),maxOutputSize:xM("maxOutputSize",e,t,n),iouThreshold:xM("iouThreshold",e,t,n),scoreThreshold:xM("scoreThreshold",e,t,n),softNmsSigma:xM("softNmsSigma",e,t,n)}}class yP{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=py(0),this.tensorMap=new Map,Ym(this.handle)}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return py(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const n=await e.data();return this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),Km(()=>{const e=xk(t),a=n.length,s=e.length;yu(a===s,()=>"The number of elements doesn't match, keys has "+"".concat(a," elements, the values has ").concat(s," ")+"elements.");for(let t=0;t<a;t++){const a=n[t],s=e[t];Ym(s),this.tensorMap.set(a,s)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);const n=await e.data();return Km(()=>{const e=[];for(let a=0;a<n.length;a++){const s=n[a],r=this.findWithDefault(s,t);e.push(r)}return nk(e)})}findWithDefault(e,t){const n=this.tensorMap.get(e);return null!=n?n:t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error("Expect key dtype ".concat(this.keyDType,", but got ")+"".concat(e.dtype));if(t.dtype!==this.valueDType)throw new Error("Expect value dtype ".concat(this.valueDType,", but got ")+"".concat(t.dtype))}}function bP(e,t,n,a){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Km;const r=((e,t,n)=>{switch(e.category){case"arithmetic":return s(()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I;switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[a.add(xM("a",e,t,n),xM("b",e,t,n))];case"AddN":return[a.addN(xM("tensors",e,t,n))];case"FloorMod":case"Mod":return[a.mod(xM("a",e,t,n),xM("b",e,t,n))];case"Mul":return[a.mul(xM("a",e,t,n),xM("b",e,t,n))];case"RealDiv":case"Div":return[a.div(xM("a",e,t,n),xM("b",e,t,n))];case"DivNoNan":return[a.divNoNan(xM("a",e,t,n),xM("b",e,t,n))];case"FloorDiv":return[a.floorDiv(xM("a",e,t,n),xM("b",e,t,n))];case"Sub":return[a.sub(xM("a",e,t,n),xM("b",e,t,n))];case"Minimum":return[a.minimum(xM("a",e,t,n),xM("b",e,t,n))];case"Maximum":return[a.maximum(xM("a",e,t,n),xM("b",e,t,n))];case"Pow":return[a.pow(xM("a",e,t,n),xM("b",e,t,n))];case"SquaredDifference":return[a.squaredDifference(xM("a",e,t,n),xM("b",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n));case"basic_math":return s(()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I;switch(e.op){case"Abs":case"ComplexAbs":return[a.abs(xM("x",e,t,n))];case"Acos":return[a.acos(xM("x",e,t,n))];case"Acosh":return[a.acosh(xM("x",e,t,n))];case"Asin":return[a.asin(xM("x",e,t,n))];case"Asinh":return[a.asinh(xM("x",e,t,n))];case"Atan":return[a.atan(xM("x",e,t,n))];case"Atan2":return[a.atan2(xM("x",e,t,n),xM("y",e,t,n))];case"Atanh":return[a.atanh(xM("x",e,t,n))];case"Ceil":return[a.ceil(xM("x",e,t,n))];case"Complex":return[a.complex(xM("real",e,t,n),xM("imag",e,t,n))];case"Cos":return[a.cos(xM("x",e,t,n))];case"Cosh":return[a.cosh(xM("x",e,t,n))];case"Elu":return[a.elu(xM("x",e,t,n))];case"Erf":return[a.erf(xM("x",e,t,n))];case"Exp":return[a.exp(xM("x",e,t,n))];case"Expm1":return[a.expm1(xM("x",e,t,n))];case"Floor":return[a.floor(xM("x",e,t,n))];case"Log":return[a.log(xM("x",e,t,n))];case"Log1p":return[a.log1p(xM("x",e,t,n))];case"Imag":return[a.imag(xM("x",e,t,n))];case"Neg":return[a.neg(xM("x",e,t,n))];case"Reciprocal":return[a.reciprocal(xM("x",e,t,n))];case"Real":return[a.real(xM("x",e,t,n))];case"Relu":return[a.relu(xM("x",e,t,n))];case"Round":return[a.round(xM("x",e,t,n))];case"Selu":return[a.selu(xM("x",e,t,n))];case"Sigmoid":return[a.sigmoid(xM("x",e,t,n))];case"Sin":return[a.sin(xM("x",e,t,n))];case"Sign":return[a.sign(xM("x",e,t,n))];case"Sinh":return[a.sinh(xM("x",e,t,n))];case"Softplus":return[a.softplus(xM("x",e,t,n))];case"Sqrt":return[a.sqrt(xM("x",e,t,n))];case"Square":return[a.square(xM("x",e,t,n))];case"Tanh":return[a.tanh(xM("x",e,t,n))];case"Tan":return[a.tan(xM("x",e,t,n))];case"ClipByValue":return[a.clipByValue(xM("x",e,t,n),xM("clipValueMin",e,t,n),xM("clipValueMax",e,t,n))];case"Relu6":return[a.relu6(xM("x",e,t,n))];case"Rsqrt":return[a.rsqrt(vM(e.inputNames[0],t,n))];case"LeakyRelu":return[a.leakyRelu(xM("x",e,t,n),xM("alpha",e,t,n))];case"Prelu":return[a.prelu(xM("x",e,t,n),xM("alpha",e,t,n))];case"IsNan":return[a.isNaN(vM(e.inputNames[0],t,n))];case"IsInf":return[a.isInf(vM(e.inputNames[0],t,n))];case"IsFinite":return[a.isFinite(vM(e.inputNames[0],t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n));case"control":return fP(e,t,n);case"convolution":return s(()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I;switch(e.op){case"Conv1D":{const s=xM("stride",e,t,n),r=xM("pad",e,t,n),i=xM("dataFormat",e,t,n).toUpperCase(),o=xM("dilation",e,t,n);return[a.conv1d(xM("x",e,t,n),xM("filter",e,t,n),s,r,i,o)]}case"Conv2D":{const s=xM("strides",e,t,n),r=IM(e,t,n),i=xM("dataFormat",e,t,n).toUpperCase(),o=xM("dilations",e,t,n);return[a.conv2d(xM("x",e,t,n),xM("filter",e,t,n),[s[1],s[2]],r,i,[o[1],o[2]])]}case"_FusedConv2D":{const{stride:s,pad:r,dataFormat:i,dilations:o,biasArg:c,preluArg:l,activationFunc:u,leakyreluAlpha:h}=mP(e,t,n);return[a.fused.conv2d({x:xM("x",e,t,n),filter:xM("filter",e,t,n),strides:[s[1],s[2]],pad:r,dataFormat:i,dilations:[o[1],o[2]],bias:c,activation:u,preluActivationWeights:l,leakyreluAlpha:h})]}case"FusedDepthwiseConv2dNative":{const{stride:s,pad:r,dataFormat:i,dilations:o,biasArg:c,preluArg:l,activationFunc:u,leakyreluAlpha:h}=mP(e,t,n);return[a.fused.depthwiseConv2d({x:xM("x",e,t,n),filter:xM("filter",e,t,n),strides:[s[1],s[2]],pad:r,dataFormat:i,dilations:[o[1],o[2]],bias:c,activation:u,preluActivationWeights:l,leakyreluAlpha:h})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const s=xM("outputShape",e,t,n),r=xM("strides",e,t,n),i=IM(e,t,n);return[a.conv2dTranspose(xM("x",e,t,n),xM("filter",e,t,n),s,[r[1],r[2]],i)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const s=xM("strides",e,t,n),r=IM(e,t,n),i=xM("dilations",e,t,n),o=xM("dataFormat",e,t,n).toUpperCase();return[a.depthwiseConv2d(xM("input",e,t,n),xM("filter",e,t,n),[s[1],s[2]],r,o,[i[1],i[2]])]}case"Conv3D":{const s=xM("strides",e,t,n),r=xM("pad",e,t,n),i=xM("dataFormat",e,t,n).toUpperCase(),o=xM("dilations",e,t,n);return[a.conv3d(xM("x",e,t,n),xM("filter",e,t,n),[s[1],s[2],s[3]],r,i,[o[1],o[2],o[3]])]}case"AvgPool":{const s=xM("strides",e,t,n),r=xM("pad",e,t,n),i=xM("kernelSize",e,t,n);return[a.avgPool(xM("x",e,t,n),[i[1],i[2]],[s[1],s[2]],r)]}case"MaxPool":{const s=xM("strides",e,t,n),r=xM("pad",e,t,n),i=xM("kernelSize",e,t,n);return[a.maxPool(xM("x",e,t,n),[i[1],i[2]],[s[1],s[2]],r)]}case"MaxPoolWithArgmax":{const s=xM("strides",e,t,n),r=xM("pad",e,t,n),i=xM("kernelSize",e,t,n),o=xM("includeBatchInIndex",e,t,n),{result:c,indexes:l}=a.maxPoolWithArgmax(xM("x",e,t,n),[i[1],i[2]],[s[1],s[2]],r,o);return[c,l]}case"AvgPool3D":{const s=xM("strides",e,t,n),r=xM("pad",e,t,n),i=xM("kernelSize",e,t,n);return[a.avgPool3d(xM("x",e,t,n),[i[1],i[2],i[3]],[s[1],s[2],s[3]],r)]}case"MaxPool3D":{const s=xM("strides",e,t,n),r=xM("pad",e,t,n),i=xM("kernelSize",e,t,n);return[a.maxPool3d(xM("x",e,t,n),[i[1],i[2],i[3]],[s[1],s[2],s[3]],r)]}case"Dilation2D":{const s=xM("strides",e,t,n),r=xM("pad",e,t,n),i=xM("dilations",e,t,n),o=s[1],c=s[2],l=i[1],u=i[2];return[a.dilation2d(xM("x",e,t,n),xM("filter",e,t,n),[o,c],r,[l,u],"NHWC")]}default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n));case"creation":return s(()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I;switch(e.op){case"Fill":{const s=xM("shape",e,t,n),r=xM("dtype",e,t,n),i=xM("value",e,t,n);return[a.fill(s,i,r)]}case"LinSpace":{const s=xM("start",e,t,n),r=xM("stop",e,t,n),i=xM("num",e,t,n);return[a.linspace(s,r,i)]}case"Multinomial":{const s=xM("logits",e,t,n),r=xM("numSamples",e,t,n),i=xM("seed",e,t,n);return[a.multinomial(s,r,i)]}case"OneHot":{const s=xM("indices",e,t,n),r=xM("depth",e,t,n),i=xM("onValue",e,t,n),o=xM("offValue",e,t,n),c=xM("dtype",e,t,n);return[a.oneHot(s,r,i,o,c)]}case"Ones":return[a.ones(xM("shape",e,t,n),xM("dtype",e,t,n))];case"OnesLike":return[a.onesLike(xM("x",e,t,n))];case"RandomStandardNormal":return[a.randomStandardNormal(xM("shape",e,t,n),xM("dtype",e,t,n),xM("seed",e,t,n))];case"RandomUniform":return[a.randomUniform(xM("shape",e,t,n),xM("minval",e,t,n),xM("maxval",e,t,n),xM("dtype",e,t,n))];case"RandomUniformInt":return[a.randomUniformInt(xM("shape",e,t,n),xM("minval",e,t,n),xM("maxval",e,t,n),xM("seed",e,t,n))];case"Range":{const s=xM("start",e,t,n),r=xM("stop",e,t,n),i=xM("step",e,t,n);return[a.range(s,r,i,xM("dtype",e,t,n))]}case"TruncatedNormal":{const s=xM("shape",e,t,n),r=xM("mean",e,t,n),i=xM("stdDev",e,t,n),o=xM("seed",e,t,n);return[a.truncatedNormal(s,r,i,xM("dtype",e,t,n),o)]}case"Zeros":return[a.zeros(xM("shape",e,t,n),xM("dtype",e,t,n))];case"ZerosLike":return[a.zerosLike(xM("x",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n));case"dynamic":return async function(e,t,n,a){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:I;switch(e.op){case"NonMaxSuppressionV5":{const{boxes:a,scores:r,maxOutputSize:i,iouThreshold:o,scoreThreshold:c,softNmsSigma:l}=gP(e,t,n),u=await s.image.nonMaxSuppressionWithScoreAsync(a,r,i,o,c,l);return[u.selectedIndices,u.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:a,scores:r,maxOutputSize:i,iouThreshold:o,scoreThreshold:c}=gP(e,t,n),l=xM("padToMaxOutputSize",e,t,n),u=await s.image.nonMaxSuppressionPaddedAsync(a,r,i,o,c,l);return[u.selectedIndices,u.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:a,scores:r,maxOutputSize:i,iouThreshold:o,scoreThreshold:c}=gP(e,t,n);return[await s.image.nonMaxSuppressionAsync(a,r,i,o,c)]}case"Where":{const a=s.cast(xM("condition",e,t,n),"bool"),r=[await s.whereAsync(a)];return a.dispose(),r}case"ListDiff":return s.setdiff1dAsync(xM("x",e,t,n),xM("y",e,t,n));default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n);case"evaluation":return s(()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I;switch(e.op){case"LowerBound":{const s=xM("sortedSequence",e,t,n),r=xM("values",e,t,n);return[a.lowerBound(s,r)]}case"TopKV2":{const s=xM("x",e,t,n),r=xM("k",e,t,n),i=xM("sorted",e,t,n),o=a.topk(s,r,i);return[o.values,o.indices]}case"UpperBound":{const s=xM("sortedSequence",e,t,n),r=xM("values",e,t,n);return[a.upperBound(s,r)]}case"Unique":{const s=xM("x",e,t,n),r=a.unique(s);return[r.values,r.indices]}case"UniqueV2":{const s=xM("x",e,t,n),r=xM("axis",e,t,n),i=a.unique(s,r);return[i.values,i.indices]}default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n));case"image":return s(()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I;switch(e.op){case"ResizeBilinear":{const s=xM("images",e,t,n),r=xM("size",e,t,n),i=xM("alignCorners",e,t,n),o=xM("halfPixelCenters",e,t,n);return[a.image.resizeBilinear(s,[r[0],r[1]],i,o)]}case"ResizeNearestNeighbor":{const s=xM("images",e,t,n),r=xM("size",e,t,n),i=xM("alignCorners",e,t,n),o=xM("halfPixelCenters",e,t,n);return[a.image.resizeNearestNeighbor(s,[r[0],r[1]],i,o)]}case"CropAndResize":{const s=xM("image",e,t,n),r=xM("boxes",e,t,n),i=xM("boxInd",e,t,n),o=xM("cropSize",e,t,n),c=xM("method",e,t,n),l=xM("extrapolationValue",e,t,n);return[a.image.cropAndResize(s,r,i,o,c,l)]}case"ImageProjectiveTransformV3":{const s=xM("images",e,t,n),r=xM("transforms",e,t,n),i=xM("outputShape",e,t,n),o=xM("fillValue",e,t,n),c=xM("interpolation",e,t,n),l=xM("fillMode",e,t,n);return[a.image.transform(s,r,c.toLowerCase(),l.toLowerCase(),o,i)]}default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n));case"graph":return s(()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I;switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":const s=xM("default",e,t,n);return[vM(e.name,t,n)||s];case"Placeholder":return[vM(e.name,t,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":case"Snapshot":return[NM(xM("x",e,t,n))];case"IdentityN":return xM("x",e,t,n).map(e=>NM(e));case"Shape":return[a.tensor1d(xM("x",e,t,n).shape,"int32")];case"ShapeN":return xM("x",e,t,n).map(e=>a.tensor1d(e.shape));case"Size":return[a.scalar(xM("x",e,t,n).size,"int32")];case"Rank":return[a.scalar(xM("x",e,t,n).rank,"int32")];case"NoOp":return[a.scalar(1)];case"Print":const r=xM("x",e,t,n),i=xM("data",e,t,n),o=xM("message",e,t,n),c=xM("summarize",e,t,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(o);for(let e=0;e<i.length;e++)console.log(Array.prototype.slice.call(i[e].dataSync()).slice(0,c));return[r];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n));case"logical":return s(()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I;switch(e.op){case"Equal":return[a.equal(xM("a",e,t,n),xM("b",e,t,n))];case"NotEqual":return[a.notEqual(xM("a",e,t,n),xM("b",e,t,n))];case"Greater":return[a.greater(xM("a",e,t,n),xM("b",e,t,n))];case"GreaterEqual":return[a.greaterEqual(xM("a",e,t,n),xM("b",e,t,n))];case"Less":return[a.less(xM("a",e,t,n),xM("b",e,t,n))];case"LessEqual":return[a.lessEqual(xM("a",e,t,n),xM("b",e,t,n))];case"LogicalAnd":return[a.logicalAnd(xM("a",e,t,n),xM("b",e,t,n))];case"LogicalNot":return[a.logicalNot(xM("a",e,t,n))];case"LogicalOr":return[a.logicalOr(xM("a",e,t,n),xM("b",e,t,n))];case"Select":case"SelectV2":return[a.where(xM("condition",e,t,n),xM("a",e,t,n),xM("b",e,t,n))];case"BitwiseAnd":return[a.bitwiseAnd(xM("a",e,t,n),xM("b",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n));case"matrices":return s(()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I;switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[a.matMul(xM("a",e,t,n),xM("b",e,t,n),xM("transposeA",e,t,n),xM("transposeB",e,t,n))];case"Einsum":return[a.einsum(xM("equation",e,t,n),...xM("tensors",e,t,n))];case"Transpose":return[a.transpose(xM("x",e,t,n),xM("perm",e,t,n))];case"_FusedMatMul":const[s,r]=xM("fusedOps",e,t,n),i="biasadd"===s,o="prelu"===r,c=xM("numArgs",e,t,n),l=xM("leakyreluAlpha",e,t,n);if(i){if(o&&2!==c)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&1!==c)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[u,h]=xM("args",e,t,n);return[a.fused.matMul({a:xM("a",e,t,n),b:xM("b",e,t,n),transposeA:xM("transposeA",e,t,n),transposeB:xM("transposeB",e,t,n),bias:u,activation:r,preluActivationWeights:h,leakyreluAlpha:l})];case"MatrixBandPart":return[a.linalg.bandPart(xM("a",e,t,n),xM("numLower",e,t,n),xM("numUpper",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n));case"normalization":return s(()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I;switch(e.op){case"EuclideanNorm":return[a.euclideanNorm(xM("x",e,t,n),xM("axis",e,t,n),xM("keepDims",e,t,n))];case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[a.batchNorm(xM("x",e,t,n),xM("mean",e,t,n),xM("variance",e,t,n),xM("offset",e,t,n),xM("scale",e,t,n),xM("epsilon",e,t,n))];case"LRN":return[a.localResponseNormalization(xM("x",e,t,n),xM("radius",e,t,n),xM("bias",e,t,n),xM("alpha",e,t,n),xM("beta",e,t,n))];case"Softmax":return[a.softmax(xM("x",e,t,n))];case"LogSoftmax":return[a.logSoftmax(xM("x",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n));case"ragged":return s(()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I;switch(e.op){case"RaggedGather":{const{outputNestedSplits:s,outputDenseValues:r}=a.raggedGather(xM("paramsNestedSplits",e,t,n),xM("paramsDenseValues",e,t,n),xM("indices",e,t,n),xM("outputRaggedRank",e,t,n));return s.concat(r)}case"RaggedRange":{const{rtNestedSplits:s,rtDenseValues:r}=a.raggedRange(xM("starts",e,t,n),xM("limits",e,t,n),xM("splits",e,t,n));return[s,r]}case"RaggedTensorToTensor":return[a.raggedTensorToTensor(xM("shape",e,t,n),xM("values",e,t,n),xM("defaultValue",e,t,n),xM("rowPartitionTensors",e,t,n),xM("rowPartitionTypes",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n));case"reduction":return s(()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I;switch(e.op){case"Max":{const s=xM("axis",e,t,n),r=xM("keepDims",e,t,n);return[a.max(xM("x",e,t,n),s,r)]}case"Mean":{const s=xM("axis",e,t,n),r=xM("keepDims",e,t,n);return[a.mean(xM("x",e,t,n),s,r)]}case"Min":{const s=xM("axis",e,t,n),r=xM("keepDims",e,t,n);return[a.min(xM("x",e,t,n),s,r)]}case"Sum":{const s=xM("axis",e,t,n),r=xM("keepDims",e,t,n);return[a.sum(xM("x",e,t,n),s,r)]}case"All":{const s=xM("axis",e,t,n),r=xM("keepDims",e,t,n);return[a.all(xM("x",e,t,n),s,r)]}case"Any":{const s=xM("axis",e,t,n),r=xM("keepDims",e,t,n);return[a.any(xM("x",e,t,n),s,r)]}case"ArgMax":{const s=xM("axis",e,t,n);return[a.argMax(xM("x",e,t,n),s)]}case"ArgMin":{const s=xM("axis",e,t,n);return[a.argMin(xM("x",e,t,n),s)]}case"Prod":{const s=xM("axis",e,t,n),r=xM("keepDims",e,t,n);return[a.prod(xM("x",e,t,n),s,r)]}case"Cumprod":{const s=xM("axis",e,t,n),r=xM("exclusive",e,t,n),i=xM("reverse",e,t,n);return[a.cumprod(xM("x",e,t,n),s,r,i)]}case"Cumsum":{const s=xM("axis",e,t,n),r=xM("exclusive",e,t,n),i=xM("reverse",e,t,n);return[a.cumsum(xM("x",e,t,n),s,r,i)]}case"Bincount":const s=xM("x",e,t,n),r=xM("weights",e,t,n),i=xM("size",e,t,n);return[a.bincount(s,r,i)];case"DenseBincount":{const s=xM("x",e,t,n),r=xM("weights",e,t,n),i=xM("size",e,t,n),o=xM("binaryOutput",e,t,n);return[a.denseBincount(s,r,i,o)]}default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n));case"slice_join":return s(()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I;switch(e.op){case"ConcatV2":case"Concat":{const s=xM("n",e,t,n),r=xM("axis",e,t,n);let i=xM("tensors",e,t,n);return i=i.slice(0,s),[a.concat(i,r)]}case"Gather":{const s=xM("x",e,t,n),r=xM("indices",e,t,n);return[a.gather(s,a.cast(r,"int32"),0)]}case"GatherV2":{const s=xM("axis",e,t,n),r=xM("batchDims",e,t,n),i=xM("x",e,t,n),o=xM("indices",e,t,n);return[a.gather(i,a.cast(o,"int32"),s,r)]}case"Reverse":{const s=xM("dims",e,t,n),r=[];for(let e=0;e<s.length;e++)s[e]&&r.push(e);const i=xM("x",e,t,n);return[a.reverse(i,r)]}case"ReverseV2":{const s=xM("axis",e,t,n),r=xM("x",e,t,n);return[a.reverse(r,s)]}case"Slice":{const s=xM("begin",e,t,n),r=xM("size",e,t,n);return[a.slice(xM("x",e,t,n),s,r)]}case"StridedSlice":{const s=xM("begin",e,t,n),r=xM("end",e,t,n),i=xM("strides",e,t,n),o=xM("beginMask",e,t,n),c=xM("endMask",e,t,n),l=xM("ellipsisMask",e,t,n),u=xM("newAxisMask",e,t,n),h=xM("shrinkAxisMask",e,t,n),d=xM("x",e,t,n);return[a.stridedSlice(d,s,r,i,o,c,l,u,h)]}case"Pack":return Km(()=>{const s=xM("axis",e,t,n),r=xM("tensors",e,t,n),i=r[0].shape,o=a.squeeze(r[0]).shape,c=r.map(e=>{const t=ku(e.shape,i);if(!t&&!ku(a.squeeze(e).shape,o))throw new Error("the input tensors shape does not match");return t?e:a.reshape(e,i)});return[a.stack(c,s)]});case"Unpack":{const s=xM("axis",e,t,n),r=xM("tensor",e,t,n);return a.unstack(r,s)}case"Tile":{const s=xM("reps",e,t,n);return[a.tile(xM("x",e,t,n),s)]}case"Split":case"SplitV":{const s=xM("axis",e,t,n),r=xM("numOrSizeSplits",e,t,n),i=xM("x",e,t,n);return a.split(i,r,s)}case"ScatterNd":{const s=xM("indices",e,t,n),r=xM("values",e,t,n),i=xM("shape",e,t,n);return[a.scatterND(s,r,i)]}case"GatherNd":{const s=xM("x",e,t,n),r=xM("indices",e,t,n);return[a.gatherND(s,r)]}case"SparseToDense":{const s=xM("sparseIndices",e,t,n),r=xM("outputShape",e,t,n),i=xM("sparseValues",e,t,n),o=xM("defaultValue",e,t,n);return[a.sparseToDense(s,i,r,i.dtype===o.dtype?o:a.cast(o,i.dtype))]}case"TensorScatterUpdate":{const s=xM("indices",e,t,n),r=xM("values",e,t,n),i=xM("tensor",e,t,n);return[a.tensorScatterUpdate(i,s,r)]}default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n));case"sparse":return s(()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I;switch(e.op){case"SparseFillEmptyRows":{const{outputIndices:s,outputValues:r,emptyRowIndicator:i,reverseIndexMap:o}=a.sparse.sparseFillEmptyRows(xM("indices",e,t,n),xM("values",e,t,n),xM("denseShape",e,t,n),xM("defaultValue",e,t,n));return[s,r,i,o]}case"SparseReshape":{const{outputIndices:s,outputShape:r}=a.sparse.sparseReshape(xM("inputIndices",e,t,n),xM("inputShape",e,t,n),xM("newShape",e,t,n));return[s,r]}case"SparseSegmentMean":return[a.sparse.sparseSegmentMean(xM("data",e,t,n),xM("indices",e,t,n),xM("segmentIds",e,t,n))];case"SparseSegmentSum":return[a.sparse.sparseSegmentSum(xM("data",e,t,n),xM("indices",e,t,n),xM("segmentIds",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n));case"spectral":return s(()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I;switch(e.op){case"FFT":return[a.fft(xM("x",e,t,n))];case"IFFT":return[a.ifft(xM("x",e,t,n))];case"RFFT":return[a.rfft(xM("x",e,t,n))];case"IRFFT":return[a.irfft(xM("x",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n));case"string":return s(()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I;switch(e.op){case"StaticRegexReplace":return[a.string.staticRegexReplace(xM("input",e,t,n),xM("pattern",e,t,n),xM("rewrite",e,t,n),xM("replaceGlobal",e,t,n))];case"StringNGrams":{const{nGrams:s,nGramsSplits:r}=a.string.stringNGrams(xM("data",e,t,n),xM("dataSplits",e,t,n),xM("separator",e,t,n),xM("nGramWidths",e,t,n),xM("leftPad",e,t,n),xM("rightPad",e,t,n),xM("padWidth",e,t,n),xM("preserveShortSequences",e,t,n));return[s,r]}case"StringSplit":{const{indices:s,values:r,shape:i}=a.string.stringSplit(xM("input",e,t,n),xM("delimiter",e,t,n),xM("skipEmpty",e,t,n));return[s,r,i]}case"StringToHashBucketFast":return[a.string.stringToHashBucketFast(xM("input",e,t,n),xM("numBuckets",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n));case"transformation":return s(()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I;switch(e.op){case"Cast":return[a.cast(xM("x",e,t,n),xM("dtype",e,t,n))];case"ExpandDims":{const s=xM("axis",e,t,n);return[a.expandDims(xM("x",e,t,n),s)]}case"Squeeze":{const s=xM("axis",e,t,n);return[a.squeeze(xM("x",e,t,n),s)]}case"Reshape":return[a.reshape(xM("x",e,t,n),xM("shape",e,t,n))];case"EnsureShape":return[a.ensureShape(xM("x",e,t,n),xM("shape",e,t,n))];case"MirrorPad":return[a.mirrorPad(xM("x",e,t,n),xM("padding",e,t,n),xM("mode",e,t,n))];case"PadV2":case"Pad":return[a.pad(xM("x",e,t,n),xM("padding",e,t,n),xM("constantValue",e,t,n))];case"SpaceToBatchND":{const s=xM("blockShape",e,t,n),r=xM("paddings",e,t,n);return[a.spaceToBatchND(xM("x",e,t,n),s,r)]}case"BatchToSpaceND":{const s=xM("blockShape",e,t,n),r=xM("crops",e,t,n);return[a.batchToSpaceND(xM("x",e,t,n),s,r)]}case"DepthToSpace":{const s=xM("blockSize",e,t,n),r=xM("dataFormat",e,t,n).toUpperCase();return[a.depthToSpace(xM("x",e,t,n),s,r)]}case"BroadcastTo":return[a.broadcastTo(xM("x",e,t,n),xM("shape",e,t,n))];case"BroadcastArgs":return[a.broadcastArgs(xM("s0",e,t,n),xM("s1",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n));case"hash_table":return(async(e,t,n,a)=>{switch(e.op){case"HashTable":case"HashTableV2":{const s=a.getHashTableHandleByName(e.name);if(null!=s)return[s];{const s=xM("keyDType",e,t,n),r=xM("valueDType",e,t,n),i=new yP(s,r);return a.addHashTable(e.name,i),[i.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const s=xM("tableHandle",e,t,n,a),r=xM("keys",e,t,n),i=xM("values",e,t,n),o=a.getHashTableById(s.id);return[await o.import(r,i)]}case"LookupTableFind":case"LookupTableFindV2":{const s=xM("tableHandle",e,t,n,a),r=xM("keys",e,t,n),i=xM("defaultValue",e,t,n),o=a.getHashTableById(s.id);return[await o.find(r,i)]}case"LookupTableSize":case"LookupTableSizeV2":{const s=xM("tableHandle",e,t,n,a);return[a.getHashTableById(s.id).tensorSize()]}default:throw TypeError("Node type ".concat(e.op," is not implemented"))}})(e,t,n,a);case"custom":const r=bM(e.op);if(r&&r.customExecutor)return r.customExecutor(new oP(e,t,n));throw TypeError("Custom op ".concat(e.op," is not registered."));default:throw TypeError("Unknown op '".concat(e.op,"'. File an issue at ")+"https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()")}})(e,t,n);return Yu(r)?r.then(e=>[].concat(e)):[].concat(r)}class xP{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},s=arguments.length>4?arguments[4]:void 0;this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=n,this.functionMap=a,this.parseNodeNameCache=s,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(e=>0===e.id&&0===e.iterationId?"":"".concat(e.frameName,"-").concat(e.iterationId)).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}function vP(e,t,n,a){const s=new Set,r=[];let i=null,o=null;const c=new Set,l=new Set(Object.keys(e).map(e=>CM(e)[0]));a=a||[];const u=new Set(a.map(e=>CM(e.name)[0])),h=[...t];for(;h.length>0;){const e=h.pop();(NP(e)||TP(e)||EP(e))&&null==i&&(i=e,o=i.children.map(e=>e.name).filter(e=>s.has(e))),s.add(e.name),null==n[e.name]&&(l.has(e.name)||u.has(e.name)||(0!==e.inputs.length?e.inputs.forEach(e=>{c.has(e.name)||(c.add(e.name),h.push(e))}):r.push(e.name)))}return{inputs:e,outputs:t,usedNodes:s,missingInputs:r,dynamicNode:i,syncInputs:o}}function wP(e,t){const{usedNodes:n,inputs:a}=t,s=Object.keys(a).map(e=>CM(e)[0]).map(t=>e.nodes[t]),r=e.initNodes||[],i=e=>n.has("string"===typeof e?e:e.name);function o(e){return[...new Map(e.map(e=>[e.name,e])).values()]}const c=o([...s,...e.weights,...r]).filter(i),l=o([...c,...Object.values(e.nodes)]).filter(i),u=new Map(l.map(e=>[e.name,e])),h={};for(const m of l){h[m.name]=h[m.name]||0;for(const e of m.children)i(e)||(h[e.name]=Number.POSITIVE_INFINITY),h[e.name]=(h[e.name]||0)+1}const d=Object.entries(h).filter(e=>{let[,t]=e;return 0===t}).map(e=>{let[t]=e;return t}),p=[...d];for(;d.length>0;){const e=d.pop(),t=u.get(e);for(const n of t.children.filter(i))0===--h[n.name]&&(p.push(n.name),d.push(n.name))}const f=function(e,t){const n=new Map(e.map(e=>[e.name,e])),a=t.map(e=>e.name),s=new Set(a);for(;a.length>0;){const e=a.pop(),t=n.get(e);for(const r of t.children)n.has(r.name)&&!s.has(r.name)&&(s.add(r.name),a.push(r.name))}const r=e.filter(e=>s.has(e.name));return r}(p.map(e=>u.get(e)),c);return function(e,t){const n=new Map(e.map((e,t)=>[e.name,t])),a=new Set(t.map(e=>e.name)),s=e=>a.has("string"===typeof e?e:e.name),r=new Set(e.map(e=>e.name)),i=e=>r.has("string"===typeof e?e:e.name);for(const o of e){for(const e of o.children.filter(i)){if(!n.has(e.name))throw new kP("Child ".concat(e.name," of node ").concat(o.name," is unreachable."));if(n.get(o.name)>n.get(e.name))throw new kP("Node ".concat(o.name," is scheduled to run after its child ").concat(e.name,"."))}if(!s(o))for(const e of o.inputs){if(!n.has(e.name))throw new kP("Input ".concat(e.name," of node ").concat(o.name," is unreachable."));if(n.get(e.name)>n.get(o.name))throw new kP("Node ".concat(o.name," is scheduled to run before its input ").concat(e.name,"."))}}}(f,c),f}class kP extends Error{constructor(e){super("NodesExecutionOrderError: ".concat(e))}}const SP=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),CP=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),IP=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function NP(e){return SP.has(e.op)}function TP(e){return CP.has(e.op)}function EP(e){return IP.has(e.op)}class RP{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map(t=>e[t].map(e=>e.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const t=e.signatureKey||e.name;return e.defaultOutput?"".concat(t,":").concat(e.defaultOutput):t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,null!=e.functions&&Object.keys(e.functions).forEach(t=>{this._functionExecutorMap[t]=new RP(e.functions[t],this)})}getCompilationKey(e,t){const n=e.map(e=>e.name).sort(),a=t.map(e=>e.name).sort();return n.join(this.SEPARATOR)+"--"+a.join(this.SEPARATOR)}compile(e,t){const n=vP(e,t,this.weightMap,this._initNodes),{missingInputs:a,dynamicNode:s,syncInputs:r}=n;if(null!=s)throw new Error("This execution contains the node '".concat(s.name,"', which has ")+"the dynamic op '".concat(s.op,"'. Please use ")+"model.executeAsync() instead. Alternatively, to avoid the "+"dynamic ops, specify the inputs [".concat(r,"]"));if(a.length>0){const n=t.map(e=>e.name),s=Object.keys(e);throw new Error("Cannot compute the outputs [".concat(n,"] from the provided inputs ")+"[".concat(s,"]. Missing the following inputs: [").concat(a,"]"))}const i=wP(this.graph,n),o=function(e){const t=new Map(e.map((e,t)=>[e.name,t])),n=Number.MAX_SAFE_INTEGER,a=e.map((e,t)=>NP(e)?n:t),s=e=>{const n=a[t.get(e.name)];return null==n?-1:n},r=e.map((e,t)=>e.children.map(s).reduce((e,t)=>Math.max(e,t),a[t])),i=new Map;for(let o=0;o<e.length;++o){const t=r[o];if(t===n)continue;const a=e[o],s=e[t];i.has(s.name)||i.set(s.name,[]),i.get(s.name).push(a)}return i}(i);return{orderedNodes:i,nodeLiveUntilMap:o}}cloneAndKeepTensor(e){if(null==e)return null;const t=e.clone();return Ym(t),t}cloneTensorList(e){if(!e)return null;const t=e.map(e=>this.cloneAndKeepTensor(e));return t}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map(e=>{let[t,n]=e;return[t,this.cloneTensorList(n)]}))}execute(e,t){this.disposeIntermediateTensors(),e=this.mapInputs(e);const n=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const a=n.map(e=>this.graph.nodes[CM(e)[0]]),s=t.map(e=>CM(e)[0]),r=new Set(s);let i=s.map(e=>this.graph.nodes[e]);0===i.length&&(i=this._outputs);const o=this.getCompilationKey(a,i);let c=this.compiledMap.get(o);null==c&&(c=this.compile(e,i),this.compiledMap.set(o,c));try{this.keepIntermediateTensors=$u().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(G5){this.keepIntermediateTensors=!1,console.warn(G5.message)}const l={},u={};return Km(()=>{const n=new xP(this.weightMap,l,u,this.functionExecutorMap,this.parseNodeNameCache),a=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach(t=>{const[s,r]=CM(t,n),i=[];i[r]=e[t],a[s]=i,this.keepIntermediateTensors&&(this.clonedTensorsMap[s]=this.cloneTensorList(i))});const s=this.getFrozenTensorIds(a),{orderedNodes:i,nodeLiveUntilMap:o}=c;for(const e of i){if(a[e.name])continue;const t=bP(e,a,n,this._resourceManager);if(Yu(t))throw new Error("The execution of the op '".concat(e.op,"' returned a promise. ")+"Please use model.executeAsync() instead.");a[e.name]=t,this.keepIntermediateTensors&&(this.clonedTensorsMap[e.name]=this.cloneTensorList(t)),this.checkTensorForDisposalWithNodeLiveUntilInfo(e,a,n,s,r,o.get(e.name))}return null==this.parent&&n.dispose(s),t.map(e=>vM(e,a,n))})}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map(t=>e[t]).map(e=>e.map(e=>e.id)));return new Set(t)}checkTensorForDisposal(e,t,n,a,s,r,i){if(!NP(t)&&!r.has(e)){for(const a of n[e])null!=a&&(i[a.id]=(i[a.id]||0)+t.children.length);for(const e of t.inputs){if(NP(e))continue;const t=wM(e.name,n,a);if(null!=t)for(const e of t){if(!e||e.kept||s.has(e.id))continue;const t=i[e.id];1===t?(e.dispose(),delete i[e.id]):null!=t&&i[e.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,t,n,a,s,r){function i(e){return NP(e)||s.has(e.name)}if(!NP(e)&&null!=r)for(const o of r){if(i(o))continue;const e=wM(o.name,t,n);for(const t of e)!t||t.kept||a.has(t.id)||t.dispose()}}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(e=>{for(const t of e)t&&!t.isDisposed&&t.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{};this.disposeIntermediateTensors(),n||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepIntermediateTensors=$u().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(G5){this.keepIntermediateTensors=!1,console.warn(G5.message)}const r=new xP(this.weightMap,a,s,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const i=await this.executeWithControlFlow(e,r,t,n),o=t.map(e=>vM(e,i,r)),c=o.map(e=>e.id),l=Object.keys(e).map(t=>e[t].id),u=new Set([...c,...l,...this.weightIds]);return Object.values(i).forEach(e=>{e.forEach(e=>{!e||e.isDisposed||u.has(e.id)||e.dispose()})}),null==this.parent&&r.dispose(u),o}async executeFunctionAsync(e,t,n){const a=e.reduce((e,t,n)=>(e[this.inputs[n].name]=t,e),{});return this._executeAsync(a,this.outputNodes,!0,t,n)}async executeWithControlFlow(e,t,n,a){const s=Object.keys(e),r=s.map(e=>this.graph.nodes[CM(e)[0]]),i=n.map(e=>CM(e)[0]),o=new Set(i);let c=i.map(e=>this.graph.nodes[e]);0===c.length&&(c=this._outputs);const{usedNodes:l,missingInputs:u,dynamicNode:h,syncInputs:d}=vP(e,c,this.weightMap,this._initNodes),p=[...r,...this.graph.weights,...this._initNodes||[]].map(e=>({node:e,contexts:t.currentContext})),f=Object.assign({},this.weightMap);Object.keys(e).forEach(t=>{const[n,a]=CM(t),s=[];s[a]=e[t],f[n]=s});const m={},g=this.getFrozenTensorIds(f),y={};for(;p.length>0;){const e=this.processStack(r,p,t,f,y,g,o,m,l);await Promise.all(e)}null!=h||a||console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const b=c.filter(e=>!NP(e)&&!vM(e.name,f,t)).map(e=>e.name);if(b.length>0){let e="";throw null!=h&&(e="Alternatively, to avoid the dynamic ops, use model.execute() "+"and specify the inputs [".concat(d,"]")),new Error("Cannot compute the outputs [".concat(b,"] from the provided ")+"inputs [".concat(s,"]. Consider providing the following inputs: ")+"[".concat(u,"]. ").concat(e))}return f}processStack(e,t,n,a,s,r,i,o,c){const l=[];for(;t.length>0;){const e=t.pop();n.currentContext=e.contexts;let u="";if("Enter"===e.node.op&&xM("isConstant",e.node,a,n)&&([u]=kM(e.node.name,n)),null==a[e.node.name]){const h=bP(e.node,a,n,this._resourceManager);u||([u]=kM(e.node.name,n));const d=n.currentContext;Yu(h)?l.push(h.then(l=>(a[u]=l,this.keepIntermediateTensors&&(this.clonedTensorsMap[u]=this.cloneTensorList(l)),n.currentContext=d,this.checkTensorForDisposal(u,e.node,a,n,r,i,o),this.processChildNodes(e.node,t,n,a,s,c),l))):(a[u]=h,this.keepIntermediateTensors&&(this.clonedTensorsMap[u]=this.cloneTensorList(h)),this.checkTensorForDisposal(u,e.node,a,n,r,i,o),this.processChildNodes(e.node,t,n,a,s,c))}else this.processChildNodes(e.node,t,n,a,s,c)}return l}processChildNodes(e,t,n,a,s,r){e.children.forEach(e=>{const[i]=kM(e.name,n);!s[i]&&r.has(e.name)&&("Merge"===e.op?e.inputNames.some(e=>!!vM(e,a,n))&&(s[i]=!0,t.push({contexts:n.currentContext,node:e})):e.inputNames.every(e=>!!vM(e,a,n))&&(s[i]=!0,t.push({contexts:n.currentContext,node:e})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(e=>e.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{const n=e[t],[a]=CM(t),s=this.graph.nodes[a];if(s.attrParams.shape&&s.attrParams.shape.value){const e=s.attrParams.shape.value,t=e.length===n.shape.length&&n.shape.every((t,n)=>-1===e[n]||e[n]===t);yu(t,()=>"The shape of dict['".concat(s.name,"'] provided in ")+"model.execute(dict) must be [".concat(e,"], but was ")+"[".concat(n.shape,"]"))}s.attrParams.dtype&&s.attrParams.dtype.value&&yu(n.dtype===s.attrParams.dtype.value,()=>"The dtype of dict['".concat(s.name,"'] provided in ")+"model.execute(dict) must be "+"".concat(s.attrParams.dtype.value,", but was ").concat(n.dtype))})}mapInputs(e){var t,n;const a={};for(const s in e){const r=null===(n=null===(t=this._signature)||void 0===t?void 0:t.inputs)||void 0===n?void 0:n[s];null!=r?a[r.name]=e[s]:a[s]=e[s]}return a}checkInputs(e){const t=Object.keys(e).filter(e=>{const[t]=CM(e);return null==this.graph.nodes[t]});if(t.length>0)throw new Error("The dict provided in model.execute(dict) has "+"keys: [".concat(t,"] that are not part of graph"))}mapOutputs(e){return e.map(e=>{var t,n;const a=null===(n=null===(t=this._signature)||void 0===t?void 0:t.outputs)||void 0===n?void 0:n[e];return null!=a?a.name:e},{})}checkOutputs(e){e.forEach(e=>{const[t]=CM(e);if(!this.graph.nodes[t])throw new Error("The output '".concat(e,"' is not found in the graph"))})}}class _P{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}const AP="?tfjs-format=file",MP="model.json";class PP{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:e;this.modelUrl=t,this.loadOptions=n,this.version="n/a",this.io=a,null==n&&(this.loadOptions={}),this.resourceManager=new _P}findIOHandler(){const e=this.modelUrl;if(null!=e.load)this.handler=e;else if(null!=this.loadOptions.requestInit)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const t=this.io.getLoadHandlers(e,this.loadOptions);if(0===t.length)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error("Found more than one (".concat(t.length,") load handlers for ")+"URL '".concat([e],"'"));this.handler=t[0]}}load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return Yu(e)?e.then(e=>null==e.getWeightStream?this.loadSync(e):this.loadStreaming(e)):this.loadSync(e)}loadSync(e){const t=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,t)}async loadStreaming(e){if(null==e.getWeightStream)throw new Error("Model artifacts missing streamWeights function");const t=await ig(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,t)}loadWithWeightMap(e,t){this.artifacts=e;const n=this.artifacts.modelTopology;let a=this.artifacts.signature;if(null!=this.artifacts.userDefinedMetadata){const e=this.artifacts.userDefinedMetadata;null!=e.signature&&(a=e.signature),null!=e.structuredOutputKeys&&(this.structuredOutputKeys=e.structuredOutputKeys)}if(this.signature=a,this.version="".concat(n.versions.producer,".").concat(n.versions.minConsumer),this.executor=new RP(qM.Instance.transformGraph(n,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(t),this.executor.resourceManager=this.resourceManager,null!=e.modelInitializer&&null!=e.modelInitializer.node){const t=qM.Instance.transformGraph(e.modelInitializer);this.initializer=new RP(t),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if("string"===typeof e){const t=this.io.getSaveHandlers(e);if(0===t.length)throw new Error("Cannot find any save handlers for URL '".concat(e,"'"));if(t.length>1)throw new Error("Found more than one (".concat(t.length,") save handlers for ")+"URL '".concat(e,"'"));e=t[0]}if(null==e.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){const t={};return(e instanceof im?[e]:e).forEach((e,n)=>t[this.structuredOutputKeys[n]]=e),t}return e}predict(e,t){const n=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(n)}async predictAsync(e,t){const n=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(n)}normalizeInputs(e){var t;if(!(e instanceof im)&&!Array.isArray(e)){const n=null===(t=this.signature)||void 0===t?void 0:t.inputs;if(null!=n)for(const t in n){const a=n[t];null!=a.resourceId&&(e[t]=this.resourceIdToCapturedInput[a.resourceId])}return e}e=Array.isArray(e)?e:[e];const n=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+n!==this.inputNodes.length)throw new Error("Input tensor count mismatch, the graph model has ".concat(this.inputNodes.length-n," non-resource placeholders, while there are ").concat(e.length," input tensors provided."));let a=0;return this.inputNodes.reduce((t,n)=>{var s,r,i;const o=null===(i=null===(r=null===(s=this.signature)||void 0===s?void 0:s.inputs)||void 0===r?void 0:r[n])||void 0===i?void 0:i.resourceId;return t[n]=null!=o?this.resourceIdToCapturedInput[o]:e[a++],t},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return null==this.initializer?[]:null==this.initializerSignature?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return null==this.initializer?[]:null==this.initializerSignature?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){const t=this.initializerSignature.outputs,n=Object.keys(t);for(let a=0;a<n.length;a++){const s=t[n[a]];this.resourceIdToCapturedInput[s.resourceId]=e[a]}}}execute(e,t){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const n=this.executor.execute(e,t);return n.length>1?n:n[0]}async executeAsync(e,t){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const n=await this.executor.executeAsync(e,t);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,n)=>(t[n]=[e[n]],t),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&Xm(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function DP(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:e;if(null==t)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==n&&(n={}),n.fromTFHub&&"string"===typeof t&&(t=function(e){e.endsWith("/")||(e+="/");return"".concat(e).concat(MP).concat(AP)}(t));const s=new PP(t,n,a);return await s.load(),s}function OP(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Map,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new Set;if(null==e)return null;if("function"===typeof Blob&&e instanceof Blob)return e.slice();if(a.has(e))throw new Error("Circular references are not supported.");if(n.has(e))return n.get(e);const s=t(e);if(s.recurse&&null!==s.value)throw new Error("A deep map function may not return both a value and recurse=true.");if(s.recurse){if(BP(e)){const s=Array.isArray(e)?[]:{};a.add(e);for(const r in e){const i=OP(e[r],t,n,a);s[r]=i}return a.delete(e),e.__proto__&&(s.__proto__=e.__proto__),s}throw new Error("Can't recurse into non-iterable type: ".concat(e))}return n.set(e,s.value),s.value}function FP(e){return LP(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:zP)}function LP(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Set;const a=e[0];if(n.has(a))throw new Error("Circular references are not supported.");const s=t(e);if(s.recurse&&null!==s.value)throw new Error("A deep zip function may not return both a value and recurse=true.");if(s.recurse){if(BP(a)){const s=Array.isArray(a)?[]:{};n.add(a);for(const r in a){const a=LP(e.map(e=>e[r]),t,n);s[r]=a}return n.delete(a),s}throw new Error("Can't recurse into non-iterable type: ".concat(a))}return s.value}function zP(e){return null===e?null:BP(e[0])?{value:null,recurse:!0}:{value:e,recurse:!1}}function BP(e){let t=!1;if($u().get("IS_BROWSER"))t=e instanceof TextDecoder;else{const{StringDecoder:a}=n(551);t=e instanceof a}return null!=e&&!ArrayBuffer.isView(e)&&(Array.isArray(e)||"object"===typeof e&&!(e instanceof im)&&!(e instanceof Promise)&&!t)}function jP(e){return function(e,t){return OP(e,t)}(e,WP)}function WP(e){return e instanceof im?{value:e.clone(),recurse:!1}:BP(e)?{value:null,recurse:!0}:{value:e,recurse:!1}}class VP{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,null==e)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(const t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const t=this.wrap(this.begin+e),n=this.get(t);return this.set(t,this.pop()),n}}class UP extends VP{constructor(){super(UP.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){const e=2*this.capacity,t=new Array(e),n=this.length();for(let a=0;a<n;a++)t[a]=this.get(this.wrap(this.begin+a));this.data=t,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}}function HP(e){return new XP(e)}function GP(e,t){return new rD(e,t)}UP.INITIAL_CAPACITY=32;class qP{async toArray(){const e=[];let t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){const e=this.prefetch(100),t=[];let n=await e.next();for(;!n.done;)t.push(n.value),n=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),n=e(t.value);for(;!t.done&&n;)t=await this.next(),n=e(t.value)}handleErrors(e){return new tD(this,e)}filter(e){return new $P(this,e)}map(e){return new eD(this,e)}mapAsync(e){return new nD(this,e)}serialMapAsync(e){return new nD(this,e).serial()}flatmap(e){return new sD(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile(e=>!0===e)}rowMajorBatch(e){return new JP(this,e,!(arguments.length>1&&void 0!==arguments[1])||arguments[1])}columnMajorBatch(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:zP;return this.rowMajorBatch(e,t).map(e=>FP(e,n))}concatenate(e,t){return new rD(new KP([this,e]),t)}take(e){return e<0||null==e?this:new ZP(this,e)}skip(e){return e<0||null==e?this:new QP(this,e)}prefetch(e){return new oD(this,e)}shuffle(e,t){return new cD(this,e,t)}serial(){return new YP(this)}}class KP extends qP{constructor(e){super(),this.items=e,this.trav=0}summary(){return"Array of ".concat(this.items.length," items")}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};const e=this.items[this.trav];return this.trav++,{value:jP(e),done:!1}}}class XP extends qP{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(G5){throw G5.message="Error thrown while iterating through a dataset: ".concat(G5.message),G5}}}class YP extends qP{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> Serial")}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}}class QP extends qP{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> Skip")}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){const e=await this.upstream.next();if(e.done)return e;Xm(e.value)}return this.upstream.next()}}class ZP extends qP{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return"".concat(this.upstream.summary()," -> Take")}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}}class JP extends qP{constructor(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> RowMajorBatch")}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){const e=[];for(;e.length<this.batchSize;){const t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}}class $P extends qP{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> Filter")}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){const e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;Xm(e.value)}}}class eD extends qP{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return"".concat(this.upstream.summary()," -> Map")}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=wm(e.value),n=this.transform(e.value),a=wm(n);for(const s of t)vm(s,a)||s.dispose();return{value:n,done:!1}}}class tD extends qP{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> handleErrors")}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(G5){if(!this.handler(G5))return{value:null,done:!0}}}}class nD extends qP{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return"".concat(this.upstream.summary()," -> AsyncMap")}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=wm(e.value),n=await this.transform(e.value),a=wm(n);for(const s of t)vm(s,a)||s.dispose();return{value:n,done:!1}}}class aD extends qP{constructor(){super(),this.outputQueue=new UP,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;0===this.outputQueue.length();)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}}class sD extends aD{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return"".concat(this.upstream.summary()," -> Flatmap")}async pump(){const e=await this.upstream.next();if(e.done)return!1;const t=wm(e.value),n=this.transform(e.value),a=wm(n);this.outputQueue.pushAll(n);for(const s of t)vm(s,a)||s.dispose();return!0}}class rD extends qP{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"".concat("TODO: fill in upstream of chained summaries"," -> Chained")}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,null==this.iterator){const e=await this.moreIterators.next();if(e.done)return{value:null,done:!0};this.iterator=e.value,null!=this.baseErrorHandler&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}const t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}}var iD;!function(e){e[e.FAIL=0]="FAIL",e[e.SHORTEST=1]="SHORTEST",e[e.LONGEST=2]="LONGEST"}(iD||(iD={}));class oD extends qP{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new VP(t)}summary(){return"".concat(this.upstream.summary()," -> Prefetch")}refill(){for(;!this.buffer.isFull();){const e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}}class cD extends oD{constructor(e,t,n){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=yw.alea(n||Uf().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){const e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(!t.done)return this.refill(),t;this.upstreamExhausted=!0}return{value:null,done:!0}}}class lD{constructor(){this.size=null}batch(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n=this;let a;return yu(e>0,()=>"batchSize needs to be positive, but it is\n      ".concat(e)),a=this.size===1/0||null==this.size?this.size:t?Math.ceil(this.size/e):Math.floor(this.size/e),uD(async()=>(await n.iterator()).columnMajorBatch(e,t,hD),a)}concatenate(e){const t=this;let n;return n=this.size===1/0||e.size===1/0?1/0:null!=this.size&&null!=e.size?this.size+e.size:null,uD(async()=>(await t.iterator()).concatenate(await e.iterator()),n)}filter(e){const t=this;let n;return n=this.size===1/0?1/0:null,uD(async()=>(await t.iterator()).filter(t=>Km(()=>e(t))),n)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){const t=this;return uD(async()=>(await t.iterator()).map(t=>Km(()=>e(t))),this.size)}mapAsync(e){const t=this;return uD(async()=>(await t.iterator()).mapAsync(e),this.size)}prefetch(e){if(null==e)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const t=this;return uD(async()=>(await t.iterator()).prefetch(e),this.size)}repeat(e){const t=this;let n;return n=null!=this.size&&e>0?this.size*e:0===e?0:null!=this.size&&(void 0===e||e<0)?1/0:null,uD(async()=>GP(HP(async()=>({value:await t.iterator(),done:!1})).take(e)),n)}skip(e){const t=this;let n;return n=null!=this.size&&e>=0&&this.size>=e?this.size-e:null!=this.size&&(this.size<e||void 0===e||e<0)?0:null,uD(async()=>(await t.iterator()).skip(e),n)}shuffle(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(null==e||e<0)throw null==this.size?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError("`Dataset.shuffle()` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for `tf.Tensor`s), consider setting "+"bufferSize to the dataset size (".concat(this.size," elements)"));const a=this,s=yw.alea(t||Uf().toString());return uD(async()=>{let t=s.int32();return n&&(t+=s.int32()),(await a.iterator()).shuffle(e,t.toString())},this.size)}take(e){const t=this;let n;return n=null!=this.size&&this.size>e?e:null!=this.size&&this.size<=e?this.size:null,uD(async()=>(await t.iterator()).take(e),n)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}}function uD(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return new class extends lD{constructor(){super(...arguments),this.size=t}async iterator(){return e()}}}function hD(e){if(null===e)return null;if(function(e){return null==e||null===(t=e)||"object"!==typeof t&&"function"!==typeof t||Array.isArray(e)||"object"===typeof e&&e instanceof im||qf(e);var t}(e[0])){return{value:function(e){if(0===e.length)throw new Error("Can't make a batch of zero elements.");return e[0]instanceof im?nk(e):Vm(e)}(e),recurse:!1}}return{value:null,recurse:!0}}lD.MAX_BUFFER_SIZE=1e4;Symbol("out"),Symbol("field"),Symbol("quote"),Symbol("quoteafterquote"),Symbol("quoteinquote");function dD(e,t){Array.isArray(e)||(e=[e]),e.forEach(e=>{null!=e&&yu("complex64"!==e.dtype,()=>"".concat(t," does not support complex64 tensors in the CPU backend."))})}const pD=kk;class fD extends uu{nextDataId(){return fD.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new lu(this,Gm())}write(e,t,n){this.firstUse&&(this.firstUse=!1,$u().get("IS_NODE")&&gf("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));const a={id:this.nextDataId()};return this.data.set(a,{values:e,dtype:n,refCount:1}),a}makeTensorInfo(e,t,n){let a;if("string"===t&&null!=n&&n.length>0&&Du(n[0])){const s=n.map(e=>Hf(e));a=this.write(s,e,t)}else a=this.write(n,e,t);return{dataId:a,shape:e,dtype:t}}refCount(e){if(this.data.has(e)){return this.data.get(e).refCount}return 0}incRef(e){this.data.get(e).refCount++}decRef(e){if(this.data.has(e)){this.data.get(e).refCount--}}move(e,t,n,a,s){this.data.set(e,{values:t,dtype:a,refCount:s})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:t,complexTensorInfos:n}=this.data.get(e);if("complex64"===t){return wC(this.readSync(n.real.dataId),this.readSync(n.imag.dataId))}return Vu(this.data.get(e).values,t)}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map(e=>Gf(e));return ty(e.shape,e.dtype,n)}catch(n){throw new Error("Failed to decode encoded string bytes into utf-8")}return ty(e.shape,e.dtype,t)}makeOutput(e,t,n){return Gm().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,e),this)}disposeData(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:n}=this.data.get(e);null!=n&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const t=Uf();e();return{kernelMs:Uf()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){dD([e],"where");const t=this.readSync(e.dataId);return pD(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}fD.nextDataId=0;function mD(e){return(t,n,a)=>{const s=Au(n,t.length);for(let r=0;r<t.length;++r)s[r]=e(t[r],a);return s}}function gD(e,t,n){return yD(e,mD(t),n)}function yD(e,t,n){return a=>{let{inputs:s,attrs:r,backend:i}=a;const{x:o}=s;dD(o,e);const c=i,l=c.data.get(o.dataId).values;let u;if("string"===o.dtype){if(!Array.isArray(l))throw new Error("String tensor's value was not an instance of Array");u=tI(l)}else u=l;const h=n||o.dtype,d=t(u,h,r);return c.makeTensorInfo(o.shape,h,d)}}Zm("cpu",()=>new fD,1);const bD=gD(nd,e=>e>=0?e:Math.exp(e)-1),xD={kernelName:nd,backendName:"cpu",kernelFunc:bD};function vD(e){const{inputs:t,backend:n}=e,{x:a}=t;return n.incRef(a.dataId),{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}const wD={kernelName:xd,backendName:"cpu",kernelFunc:vD};function kD(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{alpha:r}=a;dD([s],"leakyRelu");const i=vu(s.shape),o=n.data.get(s.dataId).values,c=_u("float32",i);for(let l=0;l<o.length;l++)c[l]=o[l]<0?r*o[l]:o[l];return n.makeTensorInfo(s.shape,"float32",c)}const SD={kernelName:Id,backendName:"cpu",kernelFunc:kD};function CD(e){return(t,n,a,s,r)=>{const i=Ry(t,n),o=i.length,c=Bu(i),l=_u(r,vu(i)),u=t.length,h=n.length,d=Bu(t),p=Bu(n),f=Ty(t,i),m=Ty(n,i);if(f.length+m.length===0)for(let g=0;g<l.length;++g)l[g]=e(a[g%a.length],s[g%s.length]);else for(let g=0;g<l.length;++g){const t=Xu(g,o,c),n=t.slice(-u);f.forEach(e=>n[e]=0);const r=Ku(n,u,d),i=t.slice(-h);m.forEach(e=>i[e]=0);const y=Ku(i,h,p);l[g]=e(a[r],s[y])}return[l,i]}}const ID=CD((e,t)=>e<0?t*e:e);function ND(e){const{inputs:t,backend:n}=e,{x:a,alpha:s}=t;dD([a,s],"prelu");const r=n.data.get(a.dataId).values,i=n.data.get(s.dataId).values,[o,c]=ID(a.shape,s.shape,r,i,"float32");return n.makeTensorInfo(c,"float32",o)}const TD={kernelName:ip,backendName:"cpu",kernelFunc:ND},ED=gD(fp,e=>Math.max(0,e)),RD={kernelName:fp,backendName:"cpu",kernelFunc:ED},_D=gD(vp,e=>Math.min(Math.max(0,e),6)),AD={kernelName:vp,backendName:"cpu",kernelFunc:_D},MD=mD(e=>1/(1+Math.exp(-e))),PD=gD(Pp,e=>1/(1+Math.exp(-e))),DD={kernelName:Pp,backendName:"cpu",kernelFunc:PD};function OD(e,t,n,a,s){if("linear"===n)return vD({inputs:{x:t},backend:e});if("relu"===n)return ED({inputs:{x:t},backend:e});if("elu"===n)return bD({inputs:{x:t},backend:e});if("relu6"===n)return _D({inputs:{x:t},backend:e});if("prelu"===n)return ND({inputs:{x:t,alpha:a},backend:e});if("leakyrelu"===n)return kD({inputs:{x:t},backend:e,attrs:{alpha:s}});if("sigmoid"===n)return PD({inputs:{x:t},backend:e});throw new Error("Activation ".concat(n," has not been implemented for the CPU backend."))}function FD(e){const{inputs:t,backend:n}=e,{real:a,imag:s}=t,r=n.data.get(a.dataId).values,i=n.data.get(s.dataId).values,o=n.makeTensorInfo(a.shape,"complex64");return n.data.get(o.dataId).complexTensorInfos={real:n.makeTensorInfo(a.shape,"float32",r),imag:n.makeTensorInfo(s.shape,"float32",i)},o}const LD={kernelName:_h,backendName:"cpu",kernelFunc:FD};function zD(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"float32";if("complex64"===n){return FD({inputs:{real:zD(e,t,"float32"),imag:zD(e,t,"float32")},backend:e})}const a=Hu(vu(t),n);return e.makeTensorInfo(t,n,a)}function BD(e){const{inputs:t,backend:n}=e,{input:a}=t,s=n.data.get(a.dataId).complexTensorInfos.real,r=n.data.get(s.dataId).values;return n.makeTensorInfo(s.shape,s.dtype,r)}const jD={kernelName:dp,backendName:"cpu",kernelFunc:BD};function WD(e,t,n,a){if("int32"===a){return[t,"int32",Int32Array.from(e)]}if("bool"===a){const a=Vf([0],n),[s,r]=CD((e,t)=>e!==t?1:0)(t,[],e,a,"bool");return[r,"bool",s]}throw new Error("Error in Cast: failed to cast ".concat(n," to ").concat(a))}function VD(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{dtype:r}=a;if("complex64"===r){if("complex64"===s.dtype)return vD({inputs:{x:s},backend:n});const e=zD(n,s.shape,s.dtype),t=VD({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),a=FD({inputs:{real:t,imag:e},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),a}if("complex64"===s.dtype){const e=BD({inputs:{input:s},backend:n}),t=VD({inputs:{x:e},backend:n,attrs:{dtype:r}});return n.disposeIntermediateTensorInfo(e),t}if(!Mu(s.dtype,r)){const e=vD({inputs:{x:s},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:r}}const i=n.data.get(s.dataId).values,[o,c,l]=WD(i,s.shape,s.dtype,r);return n.makeTensorInfo(o,c,l)}const UD={kernelName:Th,backendName:"cpu",kernelFunc:VD};function HD(e,t,n,a){return null==n?n=>{let{inputs:s,backend:r}=n;const{a:i,b:o}=s,c=r;dD([i,o],e);const l=c.data.get(i.dataId).values,u=c.data.get(o.dataId).values,h="string"===i.dtype?tI(l):l,d="string"===i.dtype?tI(u):u,p=a||i.dtype,[f,m]=t(i.shape,o.shape,h,d,p);return c.makeTensorInfo(m,p,f)}:e=>{let{inputs:s,backend:r}=e;const{a:i,b:o}=s,c=r;if("complex64"===i.dtype||"complex64"===o.dtype){const e=VD({inputs:{x:i},backend:c,attrs:{dtype:"complex64"}}),t=c.data.get(e.dataId),a=t.complexTensorInfos.real,s=t.complexTensorInfos.imag,r=c.data.get(a.dataId).values,l=c.data.get(s.dataId).values,u=VD({inputs:{x:o},backend:c,attrs:{dtype:"complex64"}}),h=c.data.get(u.dataId),d=h.complexTensorInfos.real,p=h.complexTensorInfos.imag,f=c.data.get(d.dataId).values,m=c.data.get(p.dataId).values,[g,y,b]=n(i.shape,o.shape,r,l,f,m),x=c.makeTensorInfo(b,"float32",g),v=c.makeTensorInfo(b,"float32",y),w=FD({inputs:{real:x,imag:v},backend:c});return c.disposeIntermediateTensorInfo(e),c.disposeIntermediateTensorInfo(u),c.disposeIntermediateTensorInfo(x),c.disposeIntermediateTensorInfo(v),w}{const e=c.data.get(i.dataId).values,n=c.data.get(o.dataId).values,s=a||i.dtype,[r,l]=t(i.shape,o.shape,e,n,s);return c.makeTensorInfo(l,s,r)}}}function GD(e){return(t,n,a,s,r,i)=>{const o=Ry(t,n),c=vu(o),l=o.length,u=Bu(o),h=_u("float32",c),d=_u("float32",c),p=Ty(t,o),f=Ty(n,o),m=wC(a,s),g=wC(r,i),y=t.length,b=Bu(t),x=n.length,v=Bu(n);if(p.length+f.length===0)for(let w=0;w<h.length;w++){const t=w%m.length,n=w%g.length,a=e(m[2*t],m[2*t+1],g[2*n],g[2*n+1]);h[w]=a.real,d[w]=a.imag}else for(let w=0;w<h.length;w++){const t=Xu(w,l,u),n=t.slice(-y);p.forEach(e=>n[e]=0);const a=Ku(n,y,b),s=t.slice(-x);f.forEach(e=>s[e]=0);const r=Ku(s,x,v),i=e(m[2*a],m[2*a+1],g[2*r],g[2*r+1]);h[w]=i.real,d[w]=i.imag}return[h,d,o]}}const qD=CD((e,t)=>e+t),KD=GD((e,t,n,a)=>({real:e+n,imag:t+a})),XD=HD(oh,qD,KD),YD={kernelName:oh,backendName:"cpu",kernelFunc:XD};function QD(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{shape:r}=a,i=vu(s.shape),o=Tu(r,i),c=vu(o);yu(i===c,()=>"The new shape (".concat(o,") has ").concat(c," elements and the old ")+"shape (".concat(s.shape,") has ").concat(i," elements. The new shape and old ")+"shape must have the same number of elements."),n.incRef(s.dataId);const l=n.data.get(s.dataId);if(null!=l.complexTensorInfos){const e=l.complexTensorInfos.real,t=l.complexTensorInfos.imag;e.shape=o,t.shape=o}return{dataId:s.dataId,shape:o,dtype:s.dtype}}const ZD={kernelName:mp,backendName:"cpu",kernelFunc:QD};function JD(e){const{inputs:t,backend:n,attrs:a}=e,{a:s,b:r}=t,{transposeA:i,transposeB:o}=a;dD([s,r],"matMul");const c=s.shape.length,l=r.shape.length,u=i?s.shape[c-2]:s.shape[c-1],h=o?r.shape[l-1]:r.shape[l-2],d=i?s.shape[c-1]:s.shape[c-2],p=o?r.shape[l-2]:r.shape[l-1],f=s.shape.slice(0,-2),m=r.shape.slice(0,-2),g=vu(f),y=vu(m),b=Ry(s.shape.slice(0,-2),r.shape.slice(0,-2)).concat([d,p]);yu(u===h,()=>"Error in matMul: inner shapes (".concat(u,") and (")+"".concat(h,") of Tensors with shapes ").concat(s.shape," and ")+"".concat(r.shape," and transposeA=").concat(i)+" and transposeB=".concat(o," must match."));const x=o?[y,p,h]:[y,h,p],v=QD({inputs:{x:s},backend:n,attrs:{shape:i?[g,u,d]:[g,d,u]}}),w=QD({inputs:{x:r},backend:n,attrs:{shape:x}}),k=i?v.shape[1]:v.shape[2],S=i?v.shape[2]:v.shape[1],C=o?w.shape[1]:w.shape[2],I=Math.max(g,y),N=n.data.get(v.dataId).values,T=n.data.get(w.dataId).values,E=Bu(v.shape),R=Bu(w.shape),[_,A,M]=i?[E[0],1,E[1]]:[E[0],E[1],1],[P,D,O]=o?[1,R[1],R[0]]:[R[1],1,R[0]],F=S*C,L=ty([I,S,C],v.dtype),z=L.values,B=n.blockSize;for(let j=0;j<I;j++){const e=j%g,t=j%y;for(let n=0;n<S;n+=B){const a=Math.min(n+B,S);for(let s=0;s<C;s+=B){const r=Math.min(s+B,C);for(let i=0;i<k;i+=B){const o=Math.min(i+B,k);for(let c=n;c<a;c++)for(let n=s;n<r;n++){let a=0;for(let s=i;s<o;s++){a+=N[e*_+c*A+s*M]*T[s*P+n*D+t*O]}z[j*F+(c*C+n)]+=a}}}}}return n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(w),n.makeTensorInfo(b,L.dtype,L.values)}const $D={kernelName:kh,backendName:"cpu",kernelFunc:JD};const eO={kernelName:pf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{a:s,b:r,bias:i,preluActivationWeights:o}=t,{transposeA:c,transposeB:l,activation:u,leakyreluAlpha:h}=a;let d,p,f;const m=[];d=JD({inputs:{a:s,b:r},attrs:{transposeA:c,transposeB:l},backend:n}),i&&(p=XD({inputs:{a:d,b:i},backend:n}),m.push(d),d=p),u&&(f=OD(n,d,u,o,h),m.push(d),d=f);for(const g of m)n.disposeIntermediateTensorInfo(g);return d}};function tO(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}const nO={kernelName:sh,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend;dD(t,"abs");let a=new Float32Array(vu(t.shape));return a=tO(n.data.get(t.dataId).values),n.makeOutput(a,t.shape,t.dtype)}},aO=gD(rh,e=>Math.acos(e)),sO={kernelName:rh,backendName:"cpu",kernelFunc:aO},rO=gD(ih,e=>Math.acosh(e)),iO={kernelName:ih,backendName:"cpu",kernelFunc:rO};const oO={kernelName:ch,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,a=t;dD(t,"addN");const s=a.map(e=>n.data.get(e.dataId).values),r=ty(a[0].shape,a[0].dtype),i=r.values;for(let o=0;o<a.length;o++){const e=s[o];for(let t=0;t<i.length;t++)i[t]+=e[t]}return n.makeTensorInfo(r.shape,r.dtype,r.values)}};function cO(e,t,n,a,s){const r=t.length,i=vu(t),o=Bu(t),c=Bu(s),l=_u(n,vu(s));for(let u=0;u<i;++u){const t=Xu(u,r,o),n=new Array(t.length);for(let e=0;e<n.length;e++)n[e]=t[a[e]];l[Ku(n,r,c)]=e[u]}return l}function lO(e){const{inputs:t,attrs:n,backend:a}=e,{x:s}=t,{perm:r}=n;dD(s,"transpose");const i=s.shape.length,o=new Array(i);for(let l=0;l<o.length;l++)o[l]=s.shape[r[l]];const c=cO(a.data.get(s.dataId).values,s.shape,s.dtype,r,o);return{dataId:a.write(c,o,s.dtype),shape:o,dtype:s.dtype}}const uO={kernelName:sf,backendName:"cpu",kernelFunc:lO};const hO={kernelName:lh,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{axis:r,keepDims:i}=a;dD(s,"all");const o=Eu(r,s.shape);let c=o;const l=ev(c,s.shape.length);let u=s;null!=l&&(u=lO({inputs:{x:s},backend:n,attrs:{perm:l}}),c=nv(c.length,s.shape.length)),$x("all",c,u.shape.length);const[h,d]=Zx(u.shape,c),p=vu(d),f=Hu(vu(h),u.dtype),m=n.data.get(u.dataId).values;for(let y=0;y<f.length;++y){const e=y*p;let t=m[e];for(let n=0;n<p;++n){const a=m[e+n];t=t&&a}f[y]=t}null!=l&&n.disposeIntermediateTensorInfo(u);const g=n.makeTensorInfo(h,u.dtype,f);if(i){const e=QD({inputs:{x:g},backend:n,attrs:{shape:Jx(h,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}};const dO={kernelName:uh,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{axis:r,keepDims:i}=a;dD(s,"any");const o=Eu(r,s.shape);let c=o;const l=ev(c,s.shape.length);let u=s;null!=l&&(u=lO({inputs:{x:s},backend:n,attrs:{perm:l}}),c=nv(c.length,s.shape.length)),$x("any",c,u.shape.length);const[h,d]=Zx(u.shape,c),p=vu(d),f=Hu(vu(h),u.dtype),m=n.data.get(u.dataId).values;for(let y=0;y<f.length;++y){const e=y*p;let t=m[e];for(let n=0;n<p;++n){const a=m[e+n];t=t||a}f[y]=t}null!=l&&n.disposeIntermediateTensorInfo(u);const g=n.makeTensorInfo(h,u.dtype,f);if(i){const e=QD({inputs:{x:g},backend:n,attrs:{shape:Jx(h,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}};const pO={kernelName:hh,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{axis:r}=a;dD(s,"argMax");let i=Eu(r,s.shape);const o=ev(i,s.shape.length);let c=s;const l=[];null!=o&&(c=lO({inputs:{x:s},backend:n,attrs:{perm:o}}),l.push(c),i=nv(i.length,c.shape.length)),i=[i[0]],$x("argMax",i,c.shape.length);const[u,h]=Zx(c.shape,i),d=Hu(vu(u),"int32"),p=vu(h),f=n.data.get(c.dataId).values;for(let m=0;m<d.length;++m){const e=m*p;let t=f[e],n=0;for(let a=0;a<p;++a){const s=f[e+a];s>t&&(t=s,n=a)}d[m]=n}return l.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.makeTensorInfo(u,"int32",d)}};const fO={kernelName:dh,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{axis:r}=a;dD(s,"argMin");let i=Eu(r,s.shape);const o=ev(i,s.shape.length);let c=s;const l=[];null!=o&&(c=lO({inputs:{x:s},backend:n,attrs:{perm:o}}),l.push(c),i=nv(i.length,c.shape.length)),i=[i[0]],$x("argMin",i,c.shape.length);const[u,h]=Zx(c.shape,i),d=Hu(vu(u),"int32"),p=vu(h),f=n.data.get(c.dataId).values;for(let m=0;m<d.length;++m){const e=m*p;let t=f[e],n=0;for(let a=0;a<p;++a){const s=f[e+a];s<t&&(t=s,n=a)}d[m]=n}return l.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.makeTensorInfo(u,"int32",d)}},mO=gD(ph,e=>Math.asin(e)),gO={kernelName:ph,backendName:"cpu",kernelFunc:mO},yO=gD(fh,e=>Math.asinh(e)),bO={kernelName:fh,backendName:"cpu",kernelFunc:yO},xO=gD(mh,e=>Math.atan(e)),vO={kernelName:mh,backendName:"cpu",kernelFunc:xO},wO=CD((e,t)=>Math.atan2(e,t)),kO=HD(yh,wO),SO={kernelName:yh,backendName:"cpu",kernelFunc:kO},CO=gD(gh,e=>Math.atanh(e)),IO={kernelName:gh,backendName:"cpu",kernelFunc:CO};function NO(e,t,n,a,s,r){const i=s.strideHeight,o=s.strideWidth,c=s.dilationHeight,l=s.dilationWidth,u=s.effectiveFilterHeight,h=s.effectiveFilterWidth,d=s.padInfo.top,p=s.padInfo.left,f="max"===r?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=ty(s.outShape,n),g=m.values,y=s.outShape[1]*s.outShape[2]*s.outShape[3],b=s.outShape[2]*s.outShape[3],x=s.outShape[3];for(let v=0;v<s.batchSize;++v){const t=v*y,n=v*a[0];for(let m=0;m<s.inChannels;++m)for(let y=0;y<s.outHeight;++y){const v=y*i-d,w=Math.max(0,v),k=Math.min(s.inHeight,u+v),S=t+y*b;for(let t=0;t<s.outWidth;++t){const i=t*o-p,u=Math.max(0,i),d=Math.min(s.inWidth,h+i);let y=f,b=0,v=0;for(let t=w;t<k;t+=c){const s=n+t*a[1];for(let t=u;t<d;t+=l){const n=e[s+t*a[2]+m];"max"===r&&n>y?y=n:"avg"===r&&(b+=n,v++)}if(isNaN(y))break}g[S+t*x+m]="avg"===r?b/v:y}}}return m}function TO(e,t,n,a){let s=arguments.length>4&&void 0!==arguments[4]&&arguments[4],r=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const i=ty(a.outShape,"int32"),o=a.strideHeight,c=a.strideWidth,l=a.dilationHeight,u=a.dilationWidth,h=a.effectiveFilterHeight,d=a.effectiveFilterWidth,p=a.padInfo.top,f=a.padInfo.left,m=ty(t,n,e);for(let g=0;g<a.batchSize;++g)for(let e=0;e<a.inChannels;++e)for(let t=0;t<a.outHeight;++t){const n=t*o-p;let y=n;for(;y<0;)y+=l;const b=Math.min(a.inHeight,h+n);for(let o=0;o<a.outWidth;++o){const h=o*c-f;let p=h;for(;p<0;)p+=u;const x=Math.min(a.inWidth,d+h);let v=Number.NEGATIVE_INFINITY,w=-1;for(let t=y;t<b;t+=l){const i=t-n;for(let n=p;n<x;n+=u){const o=n-h,c=m.get(g,t,n,e);c>v&&(v=c,w=s?r?((g*a.inHeight+t)*a.inWidth+n)*a.inChannels+e:(t*a.inWidth+n)*a.inChannels+e:i*d+o)}}i.set(w,g,t,o,e)}}return i}function EO(e,t,n,a,s,r){const i=s.strideDepth,o=s.strideHeight,c=s.strideWidth,l=s.dilationDepth,u=s.dilationHeight,h=s.dilationWidth,d=s.effectiveFilterDepth,p=s.effectiveFilterHeight,f=s.effectiveFilterWidth,m=s.padInfo.front,g=s.padInfo.top,y=s.padInfo.left,b="max"===r?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,x=ty(s.outShape,n),v=x.values,w=s.outShape[1]*s.outShape[2]*s.outShape[3]*s.outShape[4],k=s.outShape[2]*s.outShape[3]*s.outShape[4],S=s.outShape[3]*s.outShape[4],C=s.outShape[4];for(let I=0;I<s.batchSize;++I){const t=I*w,n=I*a[0];for(let x=0;x<s.inChannels;++x)for(let w=0;w<s.outDepth;++w){const I=w*i-m;let N=I;for(;N<0;)N+=l;const T=Math.min(s.inDepth,d+I),E=t+w*k;for(let t=0;t<s.outHeight;++t){const i=t*o-g;let d=i;for(;d<0;)d+=u;const m=Math.min(s.inHeight,p+i),w=E+t*S;for(let t=0;t<s.outWidth;++t){const i=t*c-y;let o=i;for(;o<0;)o+=h;const p=Math.min(s.inWidth,f+i),g=w+t*C;let k=b,S=0,I=0;for(let t=N;t<T;t+=l){const s=n+t*a[1];for(let t=d;t<m;t+=u){const n=s+t*a[2];for(let t=o;t<p;t+=h){const s=e[n+t*a[3]+x];if("max"===r&&s>k?k=s:"avg"===r&&(S+=s,I++),isNaN(k))break}if(isNaN(k))break}if(isNaN(k))break}v[g+x]="avg"===r?S/Math.max(I,1):k}}}}return x}const RO={kernelName:bh,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t;dD(s,"avgPool");const{filterSize:r,strides:i,pad:o,dimRoundingMode:c}=a;yu(Zb(i,1),()=>"Error in avgPool: Either strides or dilations must be 1. "+"Got strides ".concat(i," and dilations '").concat(1,"'"));const l=Wb(s.shape,r,i,1,o,c);let u;if(1===l.filterWidth&&1===l.filterHeight&&ku(l.inShape,l.outShape))u=vD({inputs:{x:s},backend:n});else{const e=n.data.get(s.dataId).values,t=Bu(s.shape),a=NO(e,s.shape,s.dtype,t,l,"avg");u=n.makeTensorInfo(l.outShape,s.dtype,a.values)}return u}};const _O={kernelName:vh,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{filterSize:r,strides:i,pad:o,dimRoundingMode:c,dataFormat:l}=a;dD(s,"avgPool3d");const u=Vb(s.shape,r,i,1,o,c,l),h=EO(n.data.get(s.dataId).values,s.shape,s.dtype,Bu(s.shape),u,"avg");return n.makeTensorInfo(h.shape,"float32",h.values)}};const AO={kernelName:wh,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:s,input:r}=t,{filterSize:i,strides:o,pad:c,dimRoundingMode:l}=a;dD([s,r],"avgPool3DGrad");const u=Vb(r.shape,i,o,1,c,l),h=u.strideDepth,d=u.strideHeight,p=u.strideWidth,f=u.filterDepth,m=u.filterHeight,g=u.filterWidth,y=u.dilationDepth,b=u.dilationHeight,x=u.dilationWidth,v=u.effectiveFilterDepth,w=u.effectiveFilterHeight,k=u.effectiveFilterWidth,S=v-1-u.padInfo.front,C=k-1-u.padInfo.left,I=w-1-u.padInfo.top,N=ty(r.shape,"float32"),T=1/(f*m*g),E=n.bufferSync(s);for(let R=0;R<u.batchSize;++R)for(let e=0;e<u.inChannels;++e)for(let t=0;t<u.inDepth;++t)for(let n=0;n<u.inHeight;++n)for(let a=0;a<u.inWidth;++a){const s=t-S,r=n-I,i=a-C;let o=0;for(let t=0;t<v;t+=y){const n=(s+t)/h;if(!(n<0||n>=u.outDepth||Math.floor(n)!==n))for(let t=0;t<w;t+=b){const a=(r+t)/d;if(!(a<0||a>=u.outHeight||Math.floor(a)!==a))for(let t=0;t<k;t+=x){const s=(i+t)/p;if(s<0||s>=u.outWidth||Math.floor(s)!==s)continue;o+=E.get(R,n,a,s,e)}}}N.set(o*T,R,t,n,a,e)}return n.makeTensorInfo(N.shape,N.dtype,N.values)}};const MO={kernelName:xh,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:s,input:r}=t,i=r;dD([s,r],"avgPoolGrad");const{filterSize:o,strides:c,pad:l}=a,u=Wb(i.shape,o,c,1,l),h=u.strideHeight,d=u.strideWidth,p=u.filterHeight,f=u.filterWidth,m=u.dilationHeight,g=u.dilationWidth,y=u.effectiveFilterHeight,b=u.effectiveFilterWidth,x=b-1-u.padInfo.left,v=y-1-u.padInfo.top,w=ty(i.shape,"float32"),k=1/(p*f),S=n.data.get(s.dataId).values,C=ty(s.shape,"float32",S);for(let I=0;I<u.batchSize;++I)for(let e=0;e<u.inChannels;++e)for(let t=0;t<u.inHeight;++t)for(let n=0;n<u.inWidth;++n){const a=t-v,s=n-x;let r=0;for(let t=0;t<y;t+=m){const n=(a+t)/h;if(!(n<0||n>=u.outHeight||Math.floor(n)!==n))for(let t=0;t<b;t+=g){const a=(s+t)/d;if(a<0||a>=u.outWidth||Math.floor(a)!==a)continue;r+=C.get(I,n,a,e)}}w.set(r*k,I,t,n,e)}return n.makeTensorInfo(w.shape,w.dtype,w.values)}};const PO={kernelName:fd,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,scale:r,offset:i,mean:o,variance:c}=t;yu(o.shape.length===c.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),yu(null==i||o.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),yu(null==r||o.shape.length===r.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),dD([s,o,c,r,i],"batchNorm");let{varianceEpsilon:l}=a;null==l&&(l=.001);const u=n.data.get(s.dataId).values,h=n.data.get(o.dataId).values,d=n.data.get(c.dataId).values,p=r?n.data.get(r.dataId).values:new Float32Array([1]),f=i?n.data.get(i.dataId).values:new Float32Array([0]),m=new Float32Array(u.length),g=f.length,y=p.length,b=d.length,x=h.length;let v=0,w=0,k=0,S=0;for(let C=0;C<u.length;++C)m[C]=f[v++]+(u[C]-h[w++])*p[k++]/Math.sqrt(d[S++]+l),v>=g&&(v=0),w>=x&&(w=0),k>=y&&(k=0),S>=b&&(S=0);return n.makeTensorInfo(s.shape,s.dtype,m)}};function DO(e,t,n,a,s){const r=Sb(a,t,n),i=vu(n),o=Bu(a);if(r){const n=Cb(t,o);return"string"===s?e.slice(n,n+i):e.subarray(n,n+i)}const c=ty(a,s,"string"===s?tI(e):e),l=ty(n,s);for(let u=0;u<l.size;++u){const e=l.indexToLoc(u),n=e.map((e,n)=>e+t[n]);l.set(c.get(...n),...e)}return"string"===s?nI(l.values):l.values}function OO(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{begin:r,size:i}=a;dD(s,"slice");const[o,c]=Ib(s,r,i);hb(s,o,c);const l=DO(n.data.get(s.dataId).values,o,c,s.shape,s.dtype);return n.makeTensorInfo(c,s.dtype,l)}const FO={kernelName:Rp,backendName:"cpu",kernelFunc:OO};const LO={kernelName:Sh,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{blockShape:r,crops:i}=a;dD([s],"batchToSpaceND");const o=r.reduce((e,t)=>e*t),c=oC(s.shape,r,o),l=cC(c.length,r.length),u=lC(s.shape,r,o),h=uC(i,r.length),d=hC(u,i,r.length),p=QD({inputs:{x:s},backend:n,attrs:{shape:c}}),f=lO({inputs:{x:p},backend:n,attrs:{perm:l}}),m=QD({inputs:{x:f},backend:n,attrs:{shape:u}}),g=OO({inputs:{x:m},backend:n,attrs:{begin:h,size:d}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}};function zO(e,t,n,a,s){const r=vu(a),i=Hu(s,n);for(let o=0;o<e.length;o++){const n=e[o];if(n<0)throw new Error("Input x must be non-negative!");n>=s||(i[n]+=r>0?t[o]:1)}return i}function BO(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s=e.shape[0],r=e.shape[1],i=ty([s,n],t.dtype);for(let o=0;o<s;o++)for(let s=0;s<r;s++){const r=e.get(o,s);if(r<0)throw new Error("Input x must be non-negative!");r>=n||(a?i.set(1,o,r):t.size>0?i.set(i.get(o,r)+t.get(o,s),o,r):i.set(i.get(o,r)+1,o,r))}return i}const jO={kernelName:Ch,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,weights:r}=t,{size:i}=a,o=zO(n.data.get(s.dataId).values,n.data.get(r.dataId).values,r.dtype,r.shape,i);return n.makeTensorInfo([i],r.dtype,o)}},WO=CD((e,t)=>e&t),VO=HD(Ih,WO),UO={kernelName:Ih,backendName:"cpu",kernelFunc:VO};const HO={kernelName:Nh,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{s0:a,s1:s}=t,r=n.data.get(a.dataId).values,i=n.data.get(s.dataId).values,o=Ry(Array.from(r),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}},GO=mD(e=>Math.ceil(e)),qO=yD(Eh,GO),KO={kernelName:Eh,backendName:"cpu",kernelFunc:qO},XO=gD(Rh,(e,t)=>{const n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e}),YO={kernelName:Rh,backendName:"cpu",kernelFunc:XO},QO={kernelName:Ah,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend,a=new Float32Array(vu(t.shape)),s=n.data.get(t.dataId),r=s.complexTensorInfos.real,i=s.complexTensorInfos.imag,o=n.data.get(r.dataId).values,c=n.data.get(i.dataId).values;for(let l=0;l<o.length;l++){const e=o[l],t=c[l];a[l]=Math.hypot(e,t)}return n.makeOutput(a,t.shape,"float32")}};function ZO(e,t,n,a){const s=Au(n,vu(t));if(a&&"string"!==n){let t=0;e.forEach(e=>{const n=vu(e.shape);s.set(e.vals,t),t+=n})}else{let a=0;e.forEach(e=>{const r="string"===n?tI(e.vals):e.vals;let i=0;for(let n=0;n<e.shape[0];++n){const o=n*t[1]+a;for(let t=0;t<e.shape[1];++t)s[o+t]=r[i++]}a+=e.shape[1]})}return s}function JO(e){const{inputs:t,backend:n}=e,{input:a}=t,s=n.data.get(a.dataId).complexTensorInfos.imag,r=n.data.get(s.dataId).values;return n.makeTensorInfo(s.shape,s.dtype,r)}const $O={kernelName:wd,backendName:"cpu",kernelFunc:JO};function eF(e){const{inputs:t,backend:n,attrs:a}=e,{axis:s}=a,r=Eu(s,t[0].shape)[0];ZS(t.map(e=>e.shape),r);let i=JS(t.map(e=>e.shape),r);if(0===vu(i))return n.makeTensorInfo(i,t[0].dtype,[]);const o=t.filter(e=>vu(e.shape)>0);if(1===o.length)return vD({inputs:{x:o[0]},backend:n});if("complex64"===o[0].dtype){const e=o.map(e=>BD({inputs:{input:e},backend:n})),t=o.map(e=>JO({inputs:{input:e},backend:n})),a=eF({inputs:e,backend:n,attrs:{axis:r}}),s=eF({inputs:t,backend:n,attrs:{axis:r}}),i=FD({inputs:{real:a,imag:s},backend:n});return e.forEach(e=>n.disposeIntermediateTensorInfo(e)),t.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),i}const c=o.map(e=>{const t=vu(e.shape.slice(r));return QD({inputs:{x:e},backend:n,attrs:{shape:[-1,t]}})}),l=c.map(e=>({vals:n.data.get(e.dataId).values,shape:e.shape}));i=JS(c.map(e=>e.shape),1);const u=1===c[0].shape[0],h=ZO(l,i,t[0].dtype,u),d=JS(o.map(e=>e.shape),r),p=n.makeTensorInfo(d,t[0].dtype,h);return c.forEach(e=>n.disposeIntermediateTensorInfo(e)),p}const tF={kernelName:Mh,backendName:"cpu",kernelFunc:eF};function nF(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,filter:r}=t,{strides:i,pad:o,dataFormat:c,dilations:l,dimRoundingMode:u}=a;dD([s,r],"conv2d");const h=$b(c),d=Ub(s.shape,r.shape,i,l,o,u,!1,h),p=d.filterHeight,f=d.filterWidth,m=d.dilationHeight,g=d.dilationWidth,y=d.padInfo.left,b=d.padInfo.top,x="channelsLast"===d.dataFormat,v=new nm(d.outShape,s.dtype),w=Bu(s.shape),k=Bu(r.shape),S=w[0],C=x?w[1]:w[2],I=x?w[2]:1,N=x?1:w[1],T=v.strides[0],E=x?v.strides[1]:v.strides[2],R=x?v.strides[2]:1,_=x?1:v.strides[1],A=n.data.get(s.dataId).values,M=n.data.get(r.dataId).values,P=v.values;for(let D=0;D<d.batchSize;++D){const e=D*S,t=D*T;for(let n=0;n<d.outHeight;++n){const a=t+n*E,s=n*d.strideHeight-b;for(let t=0;t<p;++t){const n=s+t*m;if(n<0||n>=d.inHeight)continue;const r=t*k[0],i=e+n*C;for(let e=0;e<d.outWidth;++e){const t=a+e*R,n=e*d.strideWidth-y;for(let e=0;e<f;++e){const a=n+e*g;if(a<0||a>=d.inWidth)continue;const s=i+a*I;let o=r+e*k[1];for(let e=0;e<d.inChannels;++e){const n=A[s+e*N];for(let e=0;e<d.outChannels;++e)P[t+e*_]+=n*M[o+e];o+=d.outChannels}}}}}}return n.makeTensorInfo(v.shape,v.dtype,P)}const aF={kernelName:Ph,backendName:"cpu",kernelFunc:nF};const sF={kernelName:Dh,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,dy:r}=t,{strides:i,pad:o,dataFormat:c,dimRoundingMode:l,filterShape:u}=a;dD([s,r],"conv2dBackpropFilter");const h=$b(c),d=Ub(s.shape,u,i,1,o,l,!1,h),{strideHeight:p,strideWidth:f,filterHeight:m,filterWidth:g}=d,y="channelsLast"===d.dataFormat,b=new nm(d.filterShape,"float32"),x=d.padInfo.left,v=d.padInfo.top,w=n.data.get(s.dataId).values,k=n.data.get(r.dataId).values,S=new nm(s.shape,s.dtype,w),C=new nm(r.shape,r.dtype,k);for(let I=0;I<m;++I){const e=Math.max(0,Math.ceil((v-I)/p)),t=Math.min(d.outHeight,(d.inHeight+v-I)/p);for(let n=0;n<g;++n){const a=Math.max(0,Math.ceil((x-n)/f)),s=Math.min(d.outWidth,(d.inWidth+x-n)/f);for(let r=0;r<d.inChannels;++r)for(let i=0;i<d.outChannels;++i){let o=0;for(let c=0;c<d.batchSize;++c)for(let l=e;l<t;++l){const e=I+l*p-v;for(let t=a;t<s;++t){const a=n+t*f-x;o+=y?S.get(c,e,a,r)*C.get(c,l,t,i):S.get(c,r,e,a)*C.get(c,i,l,t)}}b.set(o,I,n,r,i)}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}};const rF={kernelName:Oh,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:s,filter:r}=t,{inputShape:i,strides:o,pad:c,dataFormat:l,dimRoundingMode:u}=a;dD([s,r],"conv2dBackpropInput");const h=Bu(r.shape),d=Bu(s.shape);let p=$b(l);const f=Ub(i,r.shape,o,1,c,u,!1,p),m=new nm(f.inShape,"float32"),g=m.values,y=n.data.get(s.dataId).values,b=n.data.get(r.dataId).values,[x,v,w]=h,{batchSize:k,filterHeight:S,filterWidth:C,inChannels:I,inHeight:N,inWidth:T,outChannels:E,outHeight:R,outWidth:_,strideHeight:A,strideWidth:M}=f;p=f.dataFormat;const P=S-1-f.padInfo.top,D=C-1-f.padInfo.left,O="channelsLast"===p,F=m.strides[0],L=O?m.strides[1]:m.strides[2],z=O?m.strides[2]:1,B=O?1:m.strides[1],j=d[0],W=O?d[1]:d[2],V=O?d[2]:1,U=O?1:d[1];for(let H=0;H<k;++H)for(let e=0;e<I;++e)for(let t=0;t<N;++t){const n=t-P,a=Math.max(0,Math.ceil(n/A)),s=Math.min(R,(S+n)/A);for(let r=0;r<T;++r){const i=r-D,o=Math.max(0,Math.ceil(i/M)),c=Math.min(_,(C+i)/M);let l=0;for(let t=a;t<s;++t){const a=t*A-n;for(let n=o;n<c;++n){const s=j*H+W*t+V*n,r=x*(S-1-a)+v*(C-1-(n*M-i))+w*e;for(let e=0;e<E;++e){l+=y[s+U*e]*b[r+e]}}}g[F*H+L*t+z*r+B*e]=l}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}};const iF={kernelName:Fh,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,filter:r}=t,{strides:i,pad:o,dilations:c}=a;dD([s,r],"conv3d");const l=Hb(s.shape,r.shape,i,c,o),{filterDepth:u,filterHeight:h,filterWidth:d,dilationDepth:p,dilationHeight:f,dilationWidth:m,padInfo:g}=l,y=g.front,b=g.left,x=g.top,v=new nm(l.outShape,s.dtype),w=n.data.get(s.dataId).values,k=n.data.get(r.dataId).values,S=v.values,C=Bu(s.shape),I=Bu(r.shape);for(let N=0;N<l.batchSize;++N){const e=N*C[0],t=N*v.strides[0];for(let n=0;n<l.outDepth;++n){const a=t+n*v.strides[1],s=n*l.strideDepth-y;for(let t=0;t<u;++t){const n=s+t*p;if(n<0||n>=l.inDepth)continue;const r=t*I[0],i=e+n*C[1];for(let e=0;e<l.outHeight;++e){const t=a+e*v.strides[2],n=e*l.strideHeight-x;for(let e=0;e<h;++e){const a=n+e*f;if(a<0||a>=l.inHeight)continue;const s=r+e*I[1],o=i+a*C[2];for(let e=0;e<l.outWidth;++e){const n=t+e*l.outChannels,a=e*l.strideWidth-b;for(let e=0;e<d;++e){const t=a+e*m;if(t<0||t>=l.inWidth)continue;const r=s+e*I[2],i=o+t*l.inChannels;let c=r;for(let e=0;e<l.inChannels;++e){const t=w[i+e];for(let e=0;e<l.outChannels;++e)S[n+e]+=t*k[c+e];c+=l.outChannels}}}}}}}}return n.makeTensorInfo(v.shape,v.dtype,v.values)}};const oF={kernelName:Lh,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,dy:r}=t,{strides:i,pad:o,filterShape:c}=a;dD([s,r],"conv3dBackpropFilterV2");const l=Bu(s.shape),u=Bu(r.shape),h=Hb(s.shape,c,i,1,o),d=h.strideDepth,p=h.strideHeight,f=h.strideWidth,m=h.filterDepth,g=h.filterHeight,y=h.filterWidth,b=new nm(h.filterShape,"float32"),x=b.values,[v,w,k,S]=b.strides,C=n.data.get(r.dataId).values,[I,N,T,E]=u,R=n.data.get(s.dataId).values,[_,A,M,P]=l,D=h.padInfo.front,O=h.padInfo.left,F=h.padInfo.top;for(let L=0;L<m;++L){const e=Math.max(0,Math.ceil((D-L)/d)),t=Math.min(h.outDepth,(h.inDepth+D-L)/d),n=L*v;for(let a=0;a<g;++a){const s=Math.max(0,Math.ceil((F-a)/p)),r=Math.min(h.outHeight,(h.inHeight+F-a)/p),i=a*w+n;for(let n=0;n<y;++n){const o=Math.max(0,Math.ceil((O-n)/f)),c=Math.min(h.outWidth,(h.inWidth+O-n)/f),l=n*k+i;for(let i=0;i<h.inChannels;++i){const u=i*S+l;for(let l=0;l<h.outChannels;++l){let m=0;for(let u=0;u<h.batchSize;++u){const h=u*_,g=u*I;for(let u=e;u<t;++u){const e=(L+u*d-D)*A+h,t=u*N+g;for(let u=s;u<r;++u){const s=(a+u*p-F)*M+e,r=u*T+t;for(let e=o;e<c;++e){const t=e*E+r;m+=R[(n+e*f-O)*P+s+i]*C[t+l]}}}}x[u+l]=m}}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}};const cF={kernelName:zh,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:s,filter:r}=t,{pad:i,strides:o,inputShape:c}=a;dD([s],"conv3dBackpropInputV2");const l=Bu(s.shape),u=Bu(r.shape),h=Hb(c,r.shape,o,1,i),d=new nm(h.inShape,"float32"),p=d.values,[f,m,g,y]=d.strides,b=n.data.get(s.dataId).values,[x,v,w,k]=l,S=n.data.get(r.dataId).values,[C,I,N,T]=u,{batchSize:E,filterDepth:R,filterHeight:_,filterWidth:A,inChannels:M,inDepth:P,inHeight:D,inWidth:O,outChannels:F,outDepth:L,outHeight:z,outWidth:B,strideDepth:j,strideHeight:W,strideWidth:V}=h,U=R-1-h.padInfo.front,H=_-1-h.padInfo.top,G=A-1-h.padInfo.left;for(let q=0;q<E;++q)for(let e=0;e<M;++e)for(let t=0;t<P;++t){const n=t-U,a=Math.max(0,Math.ceil(n/j)),s=Math.min(L,(R+n)/j);for(let r=0;r<D;++r){const i=r-H,o=Math.max(0,Math.ceil(i/W)),c=Math.min(z,(_+i)/W);for(let l=0;l<O;++l){const u=l-G,h=Math.max(0,Math.ceil(u/V)),d=Math.min(B,(A+u)/V);let E=0;for(let t=a;t<s;++t){const a=t*j-n;for(let n=o;n<c;++n){const s=n*W-i;for(let r=h;r<d;++r){const i=x*q+v*t+w*n+k*r,o=C*(R-1-a)+I*(_-1-s)+N*(A-1-(r*V-u))+T*e;for(let e=0;e<F;++e){E+=b[i+e]*S[o+e]}}}}p[f*q+m*t+g*r+y*l+e]=E}}}return n.makeTensorInfo(d.shape,d.dtype,d.values)}},lF=gD(Bh,e=>Math.cos(e)),uF={kernelName:Bh,backendName:"cpu",kernelFunc:lF},hF=gD(jh,e=>Math.cosh(e)),dF={kernelName:jh,backendName:"cpu",kernelFunc:hF};const pF={kernelName:Uh,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{image:s,boxes:r,boxInd:i}=t,{cropSize:o,method:c,extrapolationValue:l}=a,[u,h,d,p]=s.shape,f=r.shape[0],[m,g]=o,y=ty([f,m,g,p],"float32"),b=n.data.get(r.dataId).values,x=n.data.get(i.dataId).values,v=n.data.get(s.dataId).values,w=Bu(s.shape),k=Bu(y.shape);for(let S=0;S<f;S++){const e=4*S,t=b[e],n=b[e+1],a=b[e+2],s=b[e+3],r=x[S];if(r>=u)continue;const i=m>1?(a-t)*(h-1)/(m-1):0,o=g>1?(s-n)*(d-1)/(g-1):0;for(let u=0;u<m;u++){const e=m>1?t*(h-1)+u*i:.5*(t+a)*(h-1);if(e<0||e>h-1)for(let t=0;t<g;t++)for(let e=0;e<p;e++){const n=e+t*k[2]+u*k[1]+S*k[0];y.values[n]=l}else if("bilinear"===c){const t=Math.floor(e),a=Math.ceil(e),i=e-t;for(let e=0;e<g;e++){const c=g>1?n*(d-1)+e*o:.5*(n+s)*(d-1);if(c<0||c>d-1){for(let t=0;t<p;t++){const n=t+e*k[2]+u*k[1]+S*k[0];y.values[n]=l}continue}const h=Math.floor(c),f=Math.ceil(c),m=c-h;for(let n=0;n<p;n++){let s=n+h*w[2]+t*w[1]+r*w[0];const o=v[s];s=n+f*w[2]+t*w[1]+r*w[0];const c=v[s];s=n+h*w[2]+a*w[1]+r*w[0];const l=v[s];s=n+f*w[2]+a*w[1]+r*w[0];const d=o+(c-o)*m,p=l+(v[s]-l)*m;s=n+e*k[2]+u*k[1]+S*k[0],y.values[s]=d+(p-d)*i}}}else for(let t=0;t<g;++t){const a=g>1?n*(d-1)+t*o:.5*(n+s)*(d-1);if(a<0||a>d-1){for(let e=0;e<p;e++){const n=e+t*k[2]+u*k[1]+S*k[0];y.values[n]=l}continue}const i=Math.round(a),c=Math.round(e);for(let e=0;e<p;e++){const n=e+i*w[2]+c*w[1]+r*w[0],a=e+t*k[2]+u*k[1]+S*k[0];y.values[a]=v[n]}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}};const fF={kernelName:Wh,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{axis:r,exclusive:i,reverse:o}=a;dD(s,"cumprod");const c=ev([r],s.shape.length);let l=s;null!=c&&(l=lO({inputs:{x:s},backend:n,attrs:{perm:c}}));const u=nv(1,s.shape.length)[0];if(u!==l.shape.length-1)throw new Error("backend.cumprod in CPU expects an inner-most "+"axis=".concat(l.shape.length-1," but got axis=").concat(u));const h=mm(l.dtype,"int32"),d=Uu(vu(l.shape),h),p=n.data.get(l.dataId).values,f=l.shape[l.shape.length-1],m=o?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let y=0;y<p.length;y+=f)for(let e=0;e<f;e++){const t=m(y,e);if(0===e)d[t]=i?1:p[t];else{const n=m(y,e-1);d[t]=i?p[n]*d[n]:p[t]*d[n]}}const g=n.makeTensorInfo(l.shape,h,d);if(null!=c){const e=lO({inputs:{x:g},backend:n,attrs:{perm:tv(c)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(l),e}return g}};const mF={kernelName:Vh,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{axis:r,exclusive:i,reverse:o}=a;dD(s,"cumsum");const c=ev([r],s.shape.length);let l=s;null!=c&&(l=lO({inputs:{x:s},backend:n,attrs:{perm:c}}));const u=nv(1,s.shape.length)[0];if(u!==l.shape.length-1)throw new Error("backend.cumsum in CPU expects an inner-most "+"axis=".concat(l.shape.length-1," but got axis=").concat(u));const h=mm(l.dtype,"int32"),d=Hu(vu(l.shape),h),p=n.data.get(l.dataId).values,f=l.shape[l.shape.length-1],m=o?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let y=0;y<p.length;y+=f)for(let e=0;e<f;e++){const t=m(y,e);if(0===e)d[t]=i?0:p[t];else{const n=m(y,e-1);d[t]=i?p[n]+d[n]:p[t]+d[n]}}const g=n.makeTensorInfo(l.shape,h,d);if(null!=c){const e=lO({inputs:{x:g},backend:n,attrs:{perm:tv(c)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(l),e}return g}};const gF={kernelName:Hh,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,weights:r}=t,{size:i,binaryOutput:o}=a;if(1===s.shape.length){const e=zO(n.data.get(s.dataId).values,n.data.get(r.dataId).values,r.dtype,r.shape,i);return n.makeTensorInfo([i],r.dtype,e)}if(2===s.shape.length){const e=BO(n.bufferSync(s),n.bufferSync(r),i,o);return n.makeTensorInfo(e.shape,r.dtype,e.values)}throw new Error("Error in denseBincount: input must be at most rank 2, but got rank"+"".concat(s.shape.length,"."))}};const yF={kernelName:Gh,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{blockSize:r,dataFormat:i}=a;yu("NHWC"===i,()=>"Only NHWC dataFormat supported on CPU for depthToSpace. Got ".concat(i));const o=s.shape[0],c=s.shape[1],l=s.shape[2],u=s.shape[3],h=c*r,d=l*r,p=u/(r*r),f=n.data.get(s.dataId).values,m=new Float32Array(o*h*d*p);let g=0;for(let y=0;y<o;++y)for(let e=0;e<h;++e){const t=Math.floor(e/r),n=e%r;for(let e=0;e<d;++e){const a=Math.floor(e/r),s=(n*r+e%r)*p;for(let e=0;e<p;++e){const n=e+s+u*(a+l*(t+c*y));m[g++]=f[n]}}}return n.makeTensorInfo([o,h,d,p],s.dtype,m)}};function bF(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,filter:r}=t,{strides:i,pad:o,dilations:c,dimRoundingMode:l}=a;dD([s,r],"depthwiseConv2DNative");const u=Bu(s.shape),h=Bu(r.shape);let d=c;null==d&&(d=[1,1]),yu(Zb(i,d),()=>"Error in depthwiseConv2d: Either strides or dilations must be "+"1. Got strides ".concat(i," and dilations '").concat(d,"'"));const p=Ub(s.shape,r.shape,i,d,o,l,!0),{filterHeight:f,filterWidth:m,dilationHeight:g,dilationWidth:y,padInfo:b}=p,x=b.left,v=b.top,w=p.outChannels/p.inChannels,k=new nm(p.outShape,s.dtype),S=n.data.get(s.dataId).values,C=n.data.get(r.dataId).values,I=k.values;for(let N=0;N<p.batchSize;++N){const e=N*u[0],t=N*k.strides[0];for(let n=0;n<p.outHeight;++n){const a=t+n*k.strides[1],s=n*p.strideHeight-v;for(let t=0;t<f;++t){const n=s+t*g;if(n<0||n>=p.inHeight)continue;const r=t*h[0],i=e+n*u[1];for(let e=0;e<p.outWidth;++e){const t=a+e*k.strides[2],n=e*p.strideWidth-x;for(let e=0;e<m;++e){const a=n+e*y;if(a<0||a>=p.inWidth)continue;const s=r+e*h[1],o=i+a*p.inChannels;let c=t,l=s;for(let e=0;e<p.inChannels;++e){const t=S[o+e];for(let e=0;e<w;++e)I[c+e]+=t*C[l+e];c+=w,l+=w}}}}}}return n.makeTensorInfo(k.shape,k.dtype,k.values)}const xF={kernelName:qh,backendName:"cpu",kernelFunc:bF};const vF={kernelName:Kh,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,dy:r}=t,{strides:i,dilations:o,pad:c,dimRoundingMode:l,filterShape:u}=a;dD([s,r],"depthwiseConv2dNativeBackpropFilter");const h=Ub(s.shape,u,i,o,c,l,!0),{strideHeight:d,strideWidth:p,filterHeight:f,filterWidth:m}=h,g=new nm(h.filterShape,"float32"),y=h.padInfo.left,b=h.padInfo.top,x=h.outChannels/h.inChannels,v=n.data.get(s.dataId).values,w=new nm(s.shape,s.dtype,v),k=n.data.get(r.dataId).values,S=new nm(r.shape,r.dtype,k);for(let C=0;C<f;++C){const e=Math.max(0,Math.ceil((b-C)/d)),t=Math.min(h.outHeight,(h.inHeight+b-C)/d);for(let n=0;n<m;++n){const a=Math.max(0,Math.ceil((y-n)/p)),s=Math.min(h.outWidth,(h.inWidth+y-n)/p);for(let r=0;r<h.outChannels;++r){const i=Math.trunc(r/x),o=r%x;let c=0;for(let l=0;l<h.batchSize;++l)for(let o=e;o<t;++o){const e=C+o*d-b;for(let t=a;t<s;++t){const a=n+t*p-y;c+=w.get(l,e,a,i)*S.get(l,o,t,r)}}g.set(c,C,n,i,o)}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}};const wF={kernelName:Xh,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:s,filter:r}=t,{strides:i,dilations:o,pad:c,dimRoundingMode:l,inputShape:u}=a;dD([s,r],"depthwiseConv2DNativeBackpropInput");const h=Bu(s.shape),d=Bu(r.shape),p=Ub(u,r.shape,i,o,c,l,!0),f=new nm(p.inShape,"float32"),m=f.values,[g,y,b]=f.strides,x=n.data.get(s.dataId).values,[v,w,k]=h,S=n.data.get(r.dataId).values,[C,I,N]=d,{batchSize:T,filterHeight:E,filterWidth:R,inChannels:_,inHeight:A,inWidth:M,outChannels:P,outHeight:D,outWidth:O,strideHeight:F,strideWidth:L}=p,z=E-1-p.padInfo.top,B=R-1-p.padInfo.left,j=P/_;for(let W=0;W<T;++W)for(let e=0;e<_;++e)for(let t=0;t<A;++t){const n=t-z,a=Math.max(0,Math.ceil(n/F)),s=Math.min(D,(E+n)/F);for(let r=0;r<M;++r){const i=r-B,o=Math.max(0,Math.ceil(i/L)),c=Math.min(O,(R+i)/L);let l=0;for(let t=a;t<s;++t){const a=t*F-n;for(let n=o;n<c;++n){const s=v*W+w*t+k*n,r=C*(E-1-a)+I*(R-1-(n*L-i))+N*e;for(let t=0;t<j;++t){l+=x[s+(e*j+t)]*S[r+t]}}}m[g*W+y*t+b*r+e]=l}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}};const kF={kernelName:Yh,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t,s=vu(a.shape),r=n.data.get(a.dataId).values,i=ty([s,s],a.dtype),o=i.values;for(let l=0;l<r.length;l++)o[l*s+l]=r[l];const c=[...a.shape,...a.shape];return n.makeTensorInfo(c,i.dtype,i.values)}},SF={kernelName:Qh,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:a}=e;const{x:s,filter:r}=t,{strides:i,pad:o,dilations:c}=a,l=n,u=l.data.get(s.dataId).values,h=s.shape.length,d=l.data.get(r.dataId).values,p=r.shape.length,{batchSize:f,inHeight:m,inWidth:g,inChannels:y,outHeight:b,outWidth:x,padInfo:v,strideHeight:w,strideWidth:k,filterHeight:S,filterWidth:C,dilationHeight:I,dilationWidth:N,outShape:T}=jb(s.shape,r.shape,i,o,"NHWC",c),E=vu(T),R=T.length,_=Au(s.dtype,E);for(let A=0;A<f;++A)for(let e=0;e<b;++e){const t=e*w-v.top;for(let n=0;n<x;++n){const a=n*k-v.left;for(let i=0;i<y;++i){let o=Number.MIN_SAFE_INTEGER;for(let e=0;e<S;++e){const n=t+e*I;if(n>=0&&n<m)for(let t=0;t<C;++t){const c=a+t*N;if(c>=0&&c<g){const a=Ku([A,n,c,i],h,Bu(s.shape)),l=Ku([e,t,i],p,Bu(r.shape)),f=u[a]+d[l];f>o&&(o=f)}}}_[Ku([A,e,n,i],R,Bu(T))]=o}}}return{dataId:l.write(Vf(_,s.dtype),T,s.dtype),shape:T,dtype:s.dtype}}},CF={kernelName:Jh,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:a}=e;const{x:s,filter:r,dy:i}=t,{strides:o,pad:c,dilations:l}=a,u=n,h=Wu(s.shape,u.data.get(s.dataId).values),d=Wu(r.shape,u.data.get(r.dataId).values),{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:x,strideHeight:v,strideWidth:w,filterHeight:k,filterWidth:S,dilationHeight:C,dilationWidth:I,outShape:N}=jb(s.shape,r.shape,o,c,"NHWC",l);yu(i.rank===N.length,()=>"Error in ".concat(Jh,", dy ")+"must have the same rank as output ".concat(N.length,", but got ")+"".concat(i.rank));const T=Wu(N,u.data.get(i.dataId).values),E=Gu(r.shape,r.dtype);for(let R=0;R<p;++R)for(let e=0;e<y;++e){const t=e*v-x.top;for(let n=0;n<b;++n){const a=n*w-x.left;for(let s=0;s<g;++s){let r=Number.MIN_SAFE_INTEGER,i=0,o=0;for(let e=0;e<k;++e){const n=t+e*C;if(n>=0&&n<f)for(let t=0;t<S;++t){const c=a+t*I;if(c>=0&&c<m){const a=h[R][n][c][s]+d[e][t][s];a>r&&(r=a,i=e,o=t)}}}E[i][o][s]+=T[R][e][n][s]}}}return{dataId:u.write(Vf(E,s.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},IF={kernelName:Zh,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:a}=e;const{x:s,filter:r,dy:i}=t,{strides:o,pad:c,dilations:l}=a,u=n,h=Wu(s.shape,u.data.get(s.dataId).values),d=Wu(r.shape,u.data.get(r.dataId).values),{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:x,strideHeight:v,strideWidth:w,filterHeight:k,filterWidth:S,dilationHeight:C,dilationWidth:I,outShape:N}=jb(s.shape,r.shape,o,c,"NHWC",l);yu(i.rank===N.length,()=>"Error in ".concat(Zh,", dy ")+"must have the same rank as output ".concat(N.length,", but got ")+"".concat(i.rank));const T=Wu(N,u.data.get(i.dataId).values),E=Gu(s.shape,s.dtype);for(let R=0;R<p;++R)for(let e=0;e<y;++e){const t=e*v-x.top;for(let n=0;n<b;++n){const a=n*w-x.left;for(let s=0;s<g;++s){let r=Number.MIN_SAFE_INTEGER,i=t<0?0:t,o=a<0?0:a;for(let e=0;e<k;++e){const n=t+e*C;if(n>=0&&n<f)for(let t=0;t<S;++t){const c=a+t*I;if(c>=0&&c<m){const a=h[R][n][c][s]+d[e][t][s];a>r&&(r=a,i=n,o=c)}}}E[R][i][o][s]+=T[R][e][n][s]}}}return{dataId:u.write(Vf(E,s.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};const NF={kernelName:$h,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{image:s}=t,{canvas:r,options:i}=a,{contextOptions:o,imageOptions:c}=i||{},l=(null===c||void 0===c?void 0:c.alpha)||1,u=(null===o||void 0===o?void 0:o.contextType)||"2d";if("2d"!==u)throw new Error("Context type ".concat(o.contextType," is not supported by the CPU backend."));const h=r.getContext(u,(null===o||void 0===o?void 0:o.contextAttributes)||{});if(null==h)throw new Error("Could not get the context with ".concat(u," type."));const[d,p]=s.shape.slice(0,2),f=2===s.shape.length?1:s.shape[2],m=n.data.get(s.dataId).values,g="float32"===s.dtype?255:1,y=new Uint8ClampedArray(p*d*4);for(let x=0;x<d*p;++x){const e=[0,0,0,255*l];for(let n=0;n<f;n++){const t=m[x*f+n];if("float32"===s.dtype){if(t<0||t>1)throw new Error("Tensor values for a float32 Tensor must be in the "+"range [0 - 1] but encountered ".concat(t,"."))}else if("int32"===s.dtype&&(t<0||t>255))throw new Error("Tensor values for a int32 Tensor must be in the "+"range [0 - 255] but encountered ".concat(t,"."));1===f?(e[0]=t*g,e[1]=t*g,e[2]=t*g):e[n]=t*g}const t=4*x;y[t+0]=Math.round(e[0]),y[t+1]=Math.round(e[1]),y[t+2]=Math.round(e[2]),y[t+3]=Math.round(e[3])}r.width=p,r.height=d;const b=new ImageData(y,p,d);return h.putImageData(b,0,0),s}},TF=CD((e,t)=>e*t),EF=GD((e,t,n,a)=>({real:e*n-t*a,imag:e*a+t*n})),RF=HD(Yd,TF,EF),_F={kernelName:Yd,backendName:"cpu",kernelFunc:RF};function AF(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{axis:r,keepDims:i}=a;let o;dD(s,"sum"),o="bool"===s.dtype?VD({inputs:{x:s},backend:n,attrs:{dtype:"int32"}}):vD({inputs:{x:s},backend:n});const c=o.shape.length,l=Eu(r,o.shape),u=ev(l,c);let h=l,d=o;null!=u&&(d=lO({inputs:{x:o},backend:n,attrs:{perm:u}}),h=nv(h.length,c)),$x("sum",h,d.shape.length);const[p,f]=Zx(d.shape,h);let m=zD(n,p,mm(d.dtype,"int32"));const g=vu(f),y=n.data.get(m.dataId).values,b=n.data.get(d.dataId).values;for(let x=0;x<y.length;++x){const e=x*g;let t=0;for(let n=0;n<g;++n)t+=b[e+n];y[x]=t}if(i){const e=m;m=QD({inputs:{x:m},backend:n,attrs:{shape:Jx(m.shape,l)}}),n.disposeIntermediateTensorInfo(e)}return n.disposeIntermediateTensorInfo(o),null!=u&&n.disposeIntermediateTensorInfo(d),m}const MF={kernelName:Fp,backendName:"cpu",kernelFunc:AF};const PF={kernelName:td,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{equation:s}=a,r=t,{allDims:i,summedDims:o,idDims:c}=PC(s,r.length);OC(i.length,c,r);const{path:l,steps:u}=FC(o,c),h=u.length;let d=null,p=i.length;const f=[];for(let m=0;m<h;++m){for(const e of u[m]){const{permutationIndices:t,expandDims:a}=DC(p,c[e]);let s;LC(t)?s=r[e]:(s=lO({inputs:{x:r[e]},backend:n,attrs:{perm:t}}),f.push(s));const i=s.shape.slice();for(let e=0;e<a.length;++e)i.splice(a[e],0,1);ku(s.shape,i)||(s=QD({inputs:{x:s},backend:n,attrs:{shape:i}}),f.push(s)),null===d?d=s:(d=RF({inputs:{a:s,b:d},backend:n}),f.push(d))}m<h-1&&(l[m]>=0&&(d=AF({inputs:{x:d},backend:n,attrs:{axis:l[m]-(i.length-p),keepDims:!1}}),f.push(d)),p--)}for(const m of f)m!==d&&n.disposeIntermediateTensorInfo(m);return d}};const DF={kernelName:ad,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{dy:a,y:s}=t;dD([a,s],"eluGrad");const r=new Float32Array(vu(s.shape)),i=n.data.get(s.dataId).values,o=n.data.get(a.dataId).values;for(let c=0;c<i.length;++c){const e=i[c];r[c]=e>=0?o[c]:o[c]*(e+1)}return n.makeTensorInfo(s.shape,"float32",r)}},OF=CD((e,t)=>e===t?1:0),FF=HD(rd,OF,null,"bool"),LF={kernelName:rd,backendName:"cpu",kernelFunc:FF},zF=mC,BF=gC,jF=yC,WF=bC,VF=xC,UF=vC,HF=gD(sd,e=>{const t=Math.sign(e),n=Math.abs(e),a=1/(1+zF*n);return t*(1-((((UF*a+VF)*a+WF)*a+jF)*a+BF)*a*Math.exp(-n*n))}),GF={kernelName:sd,backendName:"cpu",kernelFunc:HF},qF=mD(e=>Math.exp(e)),KF=yD(id,qF,"float32"),XF={kernelName:id,backendName:"cpu",kernelFunc:KF};function YF(e){const{inputs:t,backend:n,attrs:a}=e,{input:s}=t,{dim:r}=a,i=s.shape.length,o=s.shape.slice();let c=r;return r<0&&(yu(-(i+1)<=r,()=>"Axis must be in the interval [".concat(-(i+1),", ").concat(i,"]")),c=i+r+1),o.splice(c,0,1),QD({inputs:{x:s},backend:n,attrs:{shape:o}})}const QF={kernelName:od,backendName:"cpu",kernelFunc:YF},ZF=mD(e=>Math.expm1(e)),JF=yD(cd,ZF),$F={kernelName:cd,backendName:"cpu",kernelFunc:JF},eL=CD((e,t)=>e/t),tL=HD(ed,eL),nL={kernelName:ed,backendName:"cpu",kernelFunc:tL},aL=CD((e,t)=>e-t),sL=GD((e,t,n,a)=>({real:e-n,imag:t-a})),rL=HD(Jp,aL,sL),iL={kernelName:Jp,backendName:"cpu",kernelFunc:rL};function oL(e,t,n){const a=e.shape,s=a[0],r=a[1],i=n.data.get(e.dataId),o=i.complexTensorInfos.real,c=i.complexTensorInfos.imag,l=[s,r],u=vu(l),h=_u("float32",u),d=_u("float32",u);for(let g=0;g<s;g++){const e=OO({inputs:{x:o},backend:n,attrs:{begin:[g,0],size:[1,r]}}),a=OO({inputs:{x:c},backend:n,attrs:{begin:[g,0],size:[1,r]}}),s=FD({inputs:{real:e,imag:a},backend:n}),{real:i,imag:l}=cL(s,t,n),u=wC(i,l);for(let t=0;t<r;t++){const e=IC(u,t);h[g*r+t]=e.real,d[g*r+t]=e.imag}n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s)}const p=n.makeTensorInfo(l,"float32",h),f=n.makeTensorInfo(l,"float32",d),m=FD({inputs:{real:p,imag:f},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}function cL(e,t,n){const a=vu(e.shape),s=n.data.get(e.dataId),r=n.data.get(s.complexTensorInfos.real.dataId).values,i=n.data.get(s.complexTensorInfos.imag.dataId).values;if(0===((o=a)&o-1)){const s=lL(r,i,a,t,n),o=[e.shape[0],e.shape[1]];if(t){const e=n.makeTensorInfo(o,"float32",s.real),t=n.makeTensorInfo(o,"float32",s.imag),r=n.makeTensorInfo([],"float32",Wf(a,"float32")),i=vD({inputs:{x:r},backend:n}),c=nL.kernelFunc({inputs:{a:e,b:r},backend:n}),l=nL.kernelFunc({inputs:{a:t,b:i},backend:n}),u=n.data.get(c.dataId).values,h=n.data.get(l.dataId).values;return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(l),{real:u,imag:h}}return s}{const e=function(e,t,n){const a=new Float32Array(2*t);for(let s=0;s<t;s++){let r=0,i=0;for(let a=0;a<t;a++){const o=EC(s*a,t,n),c=IC(e,a);r+=c.real*o.real-c.imag*o.imag,i+=c.real*o.imag+c.imag*o.real}n&&(r/=t,i/=t),NC(a,r,i,s)}return a}(wC(r,i),a,t);return kC(e)}var o}function lL(e,t,n,a,s){if(1===n)return{real:e,imag:t};const r=wC(e,t),i=n/2,o=SC(r),c=o.real,l=o.imag,u=[c.length],h=s.makeTensorInfo(u,"float32",c),d=s.makeTensorInfo(u,"float32",l),p=FD({inputs:{real:h,imag:d},backend:s}),f=CC(r),m=f.real,g=f.imag,y=[m.length],b=s.makeTensorInfo(y,"float32",m),x=s.makeTensorInfo(y,"float32",g),v=FD({inputs:{real:b,imag:x},backend:s}),w=lL(c,l,i,a,s),k=w.real,S=w.imag,C=[k.length],I=s.makeTensorInfo(C,"float32",k),N=s.makeTensorInfo(C,"float32",S),T=FD({inputs:{real:I,imag:N},backend:s}),E=lL(m,g,i,a,s),R=E.real,_=E.imag,A=[R.length],M=s.makeTensorInfo(A,"float32",R),P=s.makeTensorInfo(A,"float32",_),D=FD({inputs:{real:M,imag:P},backend:s}),O=TC(n,a),F=[O.real.length],L=s.makeTensorInfo(F,"float32",O.real),z=s.makeTensorInfo(F,"float32",O.imag),B=FD({inputs:{real:L,imag:z},backend:s}),j=RF({inputs:{a:B,b:D},backend:s}),W=XD({inputs:{a:T,b:j},backend:s}),V=rL({inputs:{a:T,b:j},backend:s}),U=BD({inputs:{input:W},backend:s}),H=BD({inputs:{input:V},backend:s}),G=JO({inputs:{input:W},backend:s}),q=JO({inputs:{input:V},backend:s}),K=eF({inputs:[U,H],backend:s,attrs:{axis:0}}),X=eF({inputs:[G,q],backend:s,attrs:{axis:0}}),Y=s.data.get(K.dataId).values,Q=s.data.get(X.dataId).values;return s.disposeIntermediateTensorInfo(h),s.disposeIntermediateTensorInfo(d),s.disposeIntermediateTensorInfo(p),s.disposeIntermediateTensorInfo(b),s.disposeIntermediateTensorInfo(x),s.disposeIntermediateTensorInfo(v),s.disposeIntermediateTensorInfo(I),s.disposeIntermediateTensorInfo(N),s.disposeIntermediateTensorInfo(T),s.disposeIntermediateTensorInfo(M),s.disposeIntermediateTensorInfo(P),s.disposeIntermediateTensorInfo(D),s.disposeIntermediateTensorInfo(L),s.disposeIntermediateTensorInfo(z),s.disposeIntermediateTensorInfo(B),s.disposeIntermediateTensorInfo(j),s.disposeIntermediateTensorInfo(W),s.disposeIntermediateTensorInfo(V),s.disposeIntermediateTensorInfo(U),s.disposeIntermediateTensorInfo(G),s.disposeIntermediateTensorInfo(H),s.disposeIntermediateTensorInfo(q),s.disposeIntermediateTensorInfo(K),s.disposeIntermediateTensorInfo(X),{real:Y,imag:Q}}const uL={kernelName:ld,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:a}=t,s=vu(a.shape),r=a.shape[a.shape.length-1],i=QD({inputs:{x:a},backend:n,attrs:{shape:[s/r,r]}}),o=oL(i,!1,n),c=QD({inputs:{x:o},backend:n,attrs:{shape:a.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),c}};function hL(e){const{backend:t,attrs:n}=e,{shape:a,value:s,dtype:r}=n,i=r||Fu(s),o=Au(i,vu(a));return function(e,t){e.fill(t)}(o,s),t.makeTensorInfo(a,i,o)}const dL={kernelName:ud,backendName:"cpu",kernelFunc:hL};const pL={kernelName:hd,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e;const{image:s}=t,r=a,i=_u(s.dtype,vu(s.shape)),[o,c,l,u]=s.shape,h=r.data.get(s.dataId).values;for(let d=0;d<o;d++){const e=d*l*c*u;for(let t=0;t<c;t++){const n=t*(l*u);for(let t=0;t<l;t++){const a=t*u;for(let s=0;s<u;s++){const r=Math.round(l-t-1),o=e+n+a+s;let c=h[o];if(r>=0&&r<l){c=h[e+n+r*u+s]}i[o]=c}}}}return{dataId:r.write(i,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},fL=mD(e=>Math.floor(e)),mL=yD(dd,fL),gL={kernelName:dd,backendName:"cpu",kernelFunc:mL},yL=CD((e,t)=>Math.floor(e/t)),bL=HD(pd,yL,null,"int32"),xL={kernelName:pd,backendName:"cpu",kernelFunc:bL};const vL={kernelName:ff,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,filter:r,bias:i,preluActivationWeights:o}=t,{strides:c,pad:l,dataFormat:u,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=a;let m=nF({inputs:{x:s,filter:r},backend:n,attrs:{strides:c,pad:l,dataFormat:u,dilations:h,dimRoundingMode:d}});if(i){const e=m;if("NCHW"===u&&1===i.shape.length&&1!==i.shape[0]){const e=QD({inputs:{x:i},backend:n,attrs:{shape:[i.shape[0],1,1]}});m=XD({inputs:{a:m,b:e},backend:n}),n.disposeIntermediateTensorInfo(e)}else m=XD({inputs:{a:m,b:i},backend:n});n.disposeIntermediateTensorInfo(e)}if(p){const e=m;if("NCHW"===u&&"prelu"===p&&1===o.shape.length&&1!==o.shape[0]){const e=QD({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});m=OD(n,m,p,e,f),n.disposeIntermediateTensorInfo(e)}else m=OD(n,m,p,o,f);n.disposeIntermediateTensorInfo(e)}return m}};const wL={kernelName:mf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,filter:r,bias:i,preluActivationWeights:o}=t,{strides:c,pad:l,dataFormat:u,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=a;let m=bF({inputs:{x:s,filter:r},backend:n,attrs:{strides:c,pad:l,dataFormat:u,dilations:h,dimRoundingMode:d}});if(i){const e=m;m=XD({inputs:{a:m,b:i},backend:n}),n.disposeIntermediateTensorInfo(e)}if(p){const e=m;m=OD(n,m,p,o,f),n.disposeIntermediateTensorInfo(e)}return m}};function kL(e,t,n,a,s,r,i,o,c){const l=ty([a,r],n);for(let u=0;u<a;u++){const n=[];let a=0;for(let t=0;t<s;t++){const r=e[u*s+t];a+=r*i[t],n.push(r)}if(a<0||a>=c/r)throw new Error("Invalid indices: ".concat(n," does not index into ").concat(o));for(let e=0;e<r;e++)l.values[u*r+e]=t.get(...t.indexToLoc(a*r+e))}return l}const SL={kernelName:gd,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:a,indices:s}=t,r=vu(a.shape),i=s.shape,o=i[i.length-1],[c,l,u,h]=dC(a,s);if(0===l)return n.makeTensorInfo(c,a.dtype,[]);const d=kL(n.data.get(s.dataId).values,n.bufferSync(a),a.dtype,l,o,u,h,a.shape,r);return n.makeTensorInfo(c,a.dtype,d.values)}};function CL(e,t,n){const a=ty(n,e.dtype);for(let s=0;s<a.size;++s){const n=a.indexToLoc(s).slice(),r=n[0],i=n[2],o=t.locToIndex([r,i]);n[2]=t.values[o];const c=e.locToIndex(n);0<=c&&c<e.values.length&&(a.values[s]=e.values[c])}return a}const IL={kernelName:md,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,indices:r}=t,{axis:i,batchDims:o}=a;dD([s,r],"gatherV2");const c=Eu(i,s.shape)[0],l=n.data.get(r.dataId).values,u=s.shape[c];for(let x=0;x<l.length;++x){const e=l[x];yu(e<=u-1&&e>=0,()=>"GatherV2: the index value ".concat(e," is not in [0, ").concat(u-1,"]"))}let h=o;null==o&&(h=0);const d=vu(r.shape),p=eI(s,r,c,h),f=QD({inputs:{x:s},backend:n,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),m=QD({inputs:{x:r},backend:n,attrs:{shape:[p.batchSize,d/p.batchSize]}}),g=[p.batchSize,p.outerSize,d/p.batchSize,p.sliceSize],y=n.bufferSync(m),b=CL(n.bufferSync(f),y,g);return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.makeTensorInfo(p.outputShape,b.dtype,b.values)}},NL=CD((e,t)=>e>t?1:0),TL=HD(yd,NL,null,"bool"),EL={kernelName:yd,backendName:"cpu",kernelFunc:TL},RL=CD((e,t)=>e>=t?1:0),_L=HD(bd,RL,null,"bool"),AL={kernelName:bd,backendName:"cpu",kernelFunc:_L};const ML={kernelName:vd,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:a}=t,s=vu(a.shape),r=a.shape[a.shape.length-1],i=QD({inputs:{x:a},backend:n,attrs:{shape:[s/r,r]}}),o=oL(i,!0,n),c=QD({inputs:{x:o},backend:n,attrs:{shape:a.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),c}},PL=gD(kd,e=>Number.isFinite(e)?1:0,"bool"),DL={kernelName:kd,backendName:"cpu",kernelFunc:PL},OL=gD(Sd,e=>Math.abs(e)===1/0?1:0,"bool"),FL={kernelName:Sd,backendName:"cpu",kernelFunc:OL},LL=gD(Cd,e=>Number.isNaN(e)?1:0,"bool"),zL={kernelName:Cd,backendName:"cpu",kernelFunc:LL},BL=CD((e,t)=>e<t?1:0),jL=HD(Nd,BL,null,"bool"),WL={kernelName:Nd,backendName:"cpu",kernelFunc:jL},VL=CD((e,t)=>e<=t?1:0),UL=HD(Td,VL,null,"bool"),HL={kernelName:Td,backendName:"cpu",kernelFunc:UL};function GL(e,t,n){const a=(t-e)/(n-1),s=Hu(n,"float32");s[0]=e;for(let r=1;r<s.length;r++)s[r]=s[r-1]+a;return s}const qL={kernelName:Ed,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:a,stop:s,num:r}=n,i=GL(a,s,r);return t.makeTensorInfo([i.length],"float32",i)}},KL=mD(e=>Math.log(e)),XL=yD(Rd,KL),YL={kernelName:Rd,backendName:"cpu",kernelFunc:XL},QL=gD(_d,e=>Math.log1p(e)),ZL={kernelName:_d,backendName:"cpu",kernelFunc:QL},JL=CD((e,t)=>e&&t),$L=HD(Ad,JL,null,"bool"),ez={kernelName:Ad,backendName:"cpu",kernelFunc:$L},tz=gD(Md,e=>e?0:1,"bool"),nz={kernelName:Md,backendName:"cpu",kernelFunc:tz},az=CD((e,t)=>e||t),sz=HD(Pd,az,null,"bool"),rz={kernelName:Pd,backendName:"cpu",kernelFunc:sz};const iz={kernelName:Dd,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{depthRadius:r,bias:i,alpha:o,beta:c}=a;dD(s,"LRN");const l=s.shape[3],u=l-1,h=n.data.get(s.dataId).values,d=vu(s.shape),p=new Float32Array(d);function f(e){const t=e%l;let n=e-t+Math.max(0,t-r);const a=e-t+Math.min(t+r,u);let s=0;for(;n<=a;n++){const e=h[n];s+=e*e}return s}for(let m=0;m<d;m++){const e=f(m),t=h[m]*Math.pow(i+o*e,-c);p[m]=t}return n.makeTensorInfo(s.shape,s.dtype,p)}};const oz={kernelName:Od,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,y:r,dy:i}=t,{depthRadius:o,bias:c,alpha:l,beta:u}=a;dD(i,"LRNGrad");const h=vu(i.shape),d=i.shape[3],p=n.data.get(i.dataId).values,f=n.data.get(s.dataId).values,m=n.data.get(r.dataId).values,g=new Float32Array(h),y=h;for(let b=0;b<y;b++){const e=b%d,t=b-e+Math.max(0,e-o),n=b-e+Math.min(d,e+o+1);let a=0;for(let s=t;s<n;s++)a+=Math.pow(f[s],2);a=l*a+c;for(let s=t;s<n;s++){let e=-2*l*u*f[s]*m[b]/a;b===s&&(e+=Math.pow(a,-u)),e*=p[b],g[s]+=e}}return n.makeTensorInfo(i.shape,s.dtype,g)}};function cz(e,t,n,a){const s=_u(a,vu(n));for(let r=0;r<s.length;++r){const n=r*t;let a=e[n];for(let s=0;s<t;++s){const t=e[n+s];(Number.isNaN(t)||t>a)&&(a=t)}s[r]=a}return s}function lz(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{reductionIndices:r,keepDims:i}=a,o=n;let c=s.shape;const l=c.length,u=Eu(r,c);let h=u;const d=ev(h,l);let p=o.data.get(s.dataId).values;if(null!=d){const e=new Array(l);for(let t=0;t<e.length;t++)e[t]=c[d[t]];p=cO(p,c,s.dtype,d,e),h=nv(h.length,l),c=e}dD(s,"max"),$x("max",h,l);const[f,m]=Zx(c,h),g=cz(p,vu(m),f,s.dtype),y=o.write(g,f,s.dtype);let b=f;if(i){b=Jx(f,u)}return{dataId:y,shape:b,dtype:s.dtype}}const uz={kernelName:Fd,backendName:"cpu",kernelFunc:lz},hz=CD((e,t)=>Math.max(e,t)),dz=HD(Ld,hz),pz={kernelName:Ld,backendName:"cpu",kernelFunc:dz};const fz={kernelName:zd,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t;dD(s,"maxPool");const{filterSize:r,strides:i,pad:o,dimRoundingMode:c}=a;yu(Zb(i,1),()=>"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(i," and dilations '").concat(1,"'"));const l=Wb(s.shape,r,i,1,o,c);let u;if(1===l.filterWidth&&1===l.filterHeight&&ku(l.inShape,l.outShape))u=vD({inputs:{x:s},backend:n});else{const e=n.data.get(s.dataId).values,t=Bu(s.shape),a=NO(e,s.shape,s.dtype,t,l,"max");u=n.makeTensorInfo(l.outShape,s.dtype,a.values)}return u}};const mz={kernelName:jd,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{filterSize:r,strides:i,pad:o,dimRoundingMode:c,dataFormat:l}=a;dD(s,"maxPool3d");const u=Vb(s.shape,r,i,1,o,c,l),h=EO(n.data.get(s.dataId).values,s.shape,s.dtype,Bu(s.shape),u,"max");return n.makeTensorInfo(h.shape,"float32",h.values)}};const gz={kernelName:Wd,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:s,input:r}=t,{filterSize:i,strides:o,pad:c,dimRoundingMode:l}=a;dD([s,r],"maxPool3DGrad");const u=Vb(r.shape,i,o,1,c,l),h=function(e,t){const n=ty(t.outShape,"int32"),a=t.strideDepth,s=t.strideHeight,r=t.strideWidth,i=t.dilationDepth,o=t.dilationHeight,c=t.dilationWidth,l=t.effectiveFilterDepth,u=t.effectiveFilterHeight,h=t.effectiveFilterWidth,d=t.padInfo.front,p=t.padInfo.top,f=t.padInfo.left;for(let m=0;m<t.batchSize;++m)for(let g=0;g<t.inChannels;++g)for(let y=0;y<t.outDepth;++y){const b=y*a-d;let x=b;for(;x<0;)x+=i;const v=Math.min(t.inDepth,l+b);for(let a=0;a<t.outHeight;++a){const l=a*s-p;let d=l;for(;d<0;)d+=o;const w=Math.min(t.inHeight,u+l);for(let s=0;s<t.outWidth;++s){const p=s*r-f;let k=p;for(;k<0;)k+=c;const S=Math.min(t.inWidth,h+p);let C=Number.NEGATIVE_INFINITY,I=-1;for(let t=x;t<v;t+=i){const n=t-b;for(let a=d;a<w;a+=o){const s=a-l;for(let r=k;r<S;r+=c){const i=r-p,o=e.get(m,t,a,r,g);o>=C&&(C=o,I=n*u*h+s*u+i)}}}n.set(I,m,y,a,s,g)}}}return n}(n.bufferSync(r),u),d=u.strideDepth,p=u.strideHeight,f=u.strideWidth,m=u.dilationDepth,g=u.dilationHeight,y=u.dilationWidth,b=u.effectiveFilterDepth,x=u.effectiveFilterHeight,v=u.effectiveFilterWidth,w=b-1-u.padInfo.front,k=v-1-u.padInfo.left,S=x-1-u.padInfo.top,C=ty(r.shape,"float32"),I=n.bufferSync(s);for(let N=0;N<u.batchSize;++N)for(let e=0;e<u.inChannels;++e)for(let t=0;t<u.inDepth;++t)for(let n=0;n<u.inHeight;++n)for(let a=0;a<u.inWidth;++a){const s=t-w,r=n-S,i=a-k;let o=0;for(let t=0;t<b;t+=m){const n=(s+t)/d;if(!(n<0||n>=u.outDepth||Math.floor(n)!==n))for(let a=0;a<x;a+=g){const s=(r+a)/p;if(!(s<0||s>=u.outHeight||Math.floor(s)!==s))for(let r=0;r<v;r+=y){const c=(i+r)/f;if(c<0||c>=u.outWidth||Math.floor(c)!==c)continue;const l=b*x*v-1-h.get(N,n,s,c,e)===t*x*v+a*v+r?1:0;if(0===l)continue;o+=I.get(N,n,s,c,e)*l}}}C.set(o,N,t,n,a,e)}return n.makeTensorInfo(C.shape,C.dtype,C.values)}};const yz={kernelName:Bd,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:s,input:r,output:i}=t,o=r;dD([r,i],"maxPoolGrad");const{filterSize:c,strides:l,pad:u,dimRoundingMode:h}=a,d=Wb(o.shape,c,l,1,u,h),p=n.data.get(o.dataId).values,f=ty(d.outShape,o.dtype,TO(p,o.shape,o.dtype,d).values),m=d.strideHeight,g=d.strideWidth,y=d.dilationHeight,b=d.dilationWidth,x=d.effectiveFilterHeight,v=d.effectiveFilterWidth,w=v-1-d.padInfo.left,k=x-1-d.padInfo.top,S=ty(o.shape,"float32"),C=n.data.get(s.dataId).values,I=ty(s.shape,"float32",C);for(let N=0;N<d.batchSize;++N)for(let e=0;e<d.inChannels;++e)for(let t=0;t<d.inHeight;++t)for(let n=0;n<d.inWidth;++n){const a=t-k,s=n-w;let r=0;for(let t=0;t<x;t+=y){const n=(a+t)/m;if(!(n<0||n>=d.outHeight||Math.floor(n)!==n))for(let a=0;a<v;a+=b){const i=(s+a)/g;if(i<0||i>=d.outWidth||Math.floor(i)!==i)continue;const o=x*v-1-f.get(N,n,i,e)===t*v+a?1:0;if(0===o)continue;r+=I.get(N,n,i,e)*o}}S.set(r,N,t,n,e)}return n.makeTensorInfo(S.shape,S.dtype,S.values)}};const bz={kernelName:Vd,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e;const{x:s}=t,{filterSize:r,strides:i,pad:o,includeBatchInIndex:c}=n,l=a;dD(s,"MaxPoolWithArgmax");const u=l.data.get(s.dataId).values,h=Wb(s.shape,r,i,[1,1],o),[d,p]=function(e,t,n,a,s){const r=NO(e,0,n,Bu(t),s,"max"),i=TO(e,t,n,s,!0,a);return[r.values,i.values]}(u,s.shape,s.dtype,c,h),f=l.write(d,h.outShape,s.dtype),m=l.write(p,h.outShape,s.dtype);return[{dataId:f,shape:h.outShape,dtype:s.dtype},{dataId:m,shape:h.outShape,dtype:"int32"}]}};const xz={kernelName:Ud,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{axis:r,keepDims:i}=a,o=Eu(r,s.shape),c=vu(Zx(s.shape,o)[1]),l=[],u=n.makeTensorInfo([],"float32",new Float32Array([c]));l.push(u);const h=VD({inputs:{x:s},backend:n,attrs:{dtype:"float32"}});l.push(h);const d=tL({inputs:{a:h,b:u},backend:n});l.push(d);const p=AF({inputs:{x:d},backend:n,attrs:{axis:r,keepDims:i}});return l.forEach(e=>n.disposeIntermediateTensorInfo(e)),p}};const vz={kernelName:Hd,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{axis:r,keepDims:i}=a;dD(s,"min");const o=Eu(r,s.shape);let c=o;const l=ev(c,s.shape.length);let u=s;null!=l&&(u=lO({inputs:{x:s},backend:n,attrs:{perm:l}}),c=nv(c.length,s.shape.length)),$x("min",c,u.shape.length);const[h,d]=Zx(u.shape,c),p=vu(d),f=Hu(vu(h),u.dtype),m=n.data.get(u.dataId).values;for(let y=0;y<f.length;++y){const e=y*p;let t=m[e];for(let n=0;n<p;++n){const a=m[e+n];(Number.isNaN(a)||a<t)&&(t=a)}f[y]=t}null!=l&&n.disposeIntermediateTensorInfo(u);const g=n.makeTensorInfo(h,u.dtype,f);if(i){const e=QD({inputs:{x:g},backend:n,attrs:{shape:Jx(h,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}},wz=CD((e,t)=>Math.min(e,t)),kz=HD(Gd,wz),Sz={kernelName:Gd,backendName:"cpu",kernelFunc:kz};const Cz={kernelName:qd,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{paddings:r,mode:i}=a;dD(s,"mirrorPad");const o=r.map((e,t)=>e[0]+s.shape[t]+e[1]),c=r.map(e=>e[0]),l=r.map((e,t)=>e[0]+s.shape[t]),u="reflect"===i?0:1,h=n.data.get(s.dataId).values,d=s.shape.length,p=Bu(s.shape),f=vu(o),m=o.length,g=Bu(o),y=_u(s.dtype,f);for(let b=0;b<f;b++){let e=Xu(b,m,g);for(let n=0;n<m;n++)e[n]<c[n]?e[n]=2*c[n]-e[n]-u:e[n]>=l[n]&&(e[n]=2*(l[n]-1)-e[n]+u);e=e.map((e,t)=>e-c[t]);const t=Ku(e,d,p);y[b]=h[t]}return{dataId:n.write(y,o,s.dtype),shape:o,dtype:s.dtype}}},Iz=CD((e,t)=>{const n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t}),Nz=HD(Kd,Iz),Tz={kernelName:Kd,backendName:"cpu",kernelFunc:Nz};function Ez(e){const{inputs:t,backend:n,attrs:a}=e,{logits:s}=t,{dim:r}=a,i=s.shape.length;let o=r;if(-1===o&&(o=i-1),o!==i-1)throw Error("Softmax along a non-last dimension is not yet supported. "+"Logits was rank ".concat(i," and dim was ").concat(o));const c=Eu([o],s.shape),l=lz({inputs:{x:s},backend:n,attrs:{reductionIndices:c,keepDims:!1}}),u=Jx(l.shape,c),h=QD({inputs:{x:l},backend:n,attrs:{shape:u}}),d=rL({inputs:{a:s,b:h},backend:n}),p=KF({inputs:{x:d},backend:n}),f=AF({inputs:{x:p},backend:n,attrs:{axis:c,keepDims:!1}}),m=QD({inputs:{x:f},backend:n,attrs:{shape:u}}),g=tL({inputs:{a:p,b:m},backend:n});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}const Rz={kernelName:Bp,backendName:"cpu",kernelFunc:Ez};const _z={kernelName:Xd,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{logits:s}=t,{numSamples:r,seed:i,normalized:o}=a;dD(s,"multinomial");const c=o?s:Ez({inputs:{logits:s},backend:n,attrs:{dim:-1}}),l=c.shape[0],u=c.shape[1],h=n.data.get(c.dataId).values,d=[l,r],p=Hu(vu(d),"int32");for(let f=0;f<l;++f){const e=f*u,t=new Float32Array(u-1);t[0]=h[e];for(let s=1;s<t.length;++s)t[s]=t[s-1]+h[e+s];const n=yw.alea(i.toString()),a=f*r;for(let s=0;s<r;++s){const e=n();p[a+s]=t.length;for(let n=0;n<t.length;n++)if(e<t[n]){p[a+s]=n;break}}}return o||n.disposeIntermediateTensorInfo(c),n.makeTensorInfo(d,"int32",p)}};function Az(e,t,n){const a=Wf(-1,n);return TF([],t,a,e,n)}const Mz={kernelName:Qd,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t;dD(a,"neg");const s=n.data.get(a.dataId).values,[r,i]=Az(s,a.shape,a.dtype);return n.makeTensorInfo(i,a.dtype,r)}},Pz=aS;const Dz={kernelName:Jd,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{boxes:s,scores:r}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:c}=a;dD(s,"NonMaxSuppression");const l=n.data.get(s.dataId).values,u=n.data.get(r.dataId).values,{selectedIndices:h}=Pz(l,u,i,o,c);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}},Oz=sS;const Fz={kernelName:$d,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{boxes:s,scores:r}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:c,padToMaxOutputSize:l}=a;dD(s,"NonMaxSuppressionPadded");const u=n.data.get(s.dataId).values,h=n.data.get(r.dataId).values,{selectedIndices:d,validOutputs:p}=Oz(u,h,i,o,c,l);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},Lz=rS;const zz={kernelName:ep,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{boxes:s,scores:r}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:c,softNmsSigma:l}=a;dD(s,"NonMaxSuppressionWithScore");const u=n.data.get(s.dataId).values,h=n.data.get(r.dataId).values,d=i,p=o,f=c,m=l,{selectedIndices:g,selectedScores:y}=Lz(u,h,d,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}},Bz=CD((e,t)=>e!==t?1:0),jz=HD(Zd,Bz,null,"bool"),Wz={kernelName:Zd,backendName:"cpu",kernelFunc:jz};const Vz={kernelName:np,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{indices:s}=t,{dtype:r,depth:i,onValue:o,offValue:c}=a;dD(s,"oneHot");const l=vu(s.shape),u=new Float32Array(l*i);u.fill(c);const h=n.data.get(s.dataId).values;for(let d=0;d<l;++d)h[d]>=0&&h[d]<i&&(u[d*i+h[d]]=o);return n.makeTensorInfo([...s.shape,i],r,u)}};function Uz(e){const{inputs:t,backend:n}=e,{x:a}=t;if("string"===a.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===a.dtype){const e=BD({inputs:{input:a},backend:n}),t=Uz({inputs:{x:e},backend:n}),s=JO({inputs:{input:a},backend:n}),r=Uz({inputs:{x:s},backend:n}),i=FD({inputs:{real:t,imag:r},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(r),i}return hL({backend:n,attrs:{shape:a.shape,value:0,dtype:a.dtype}})}const Hz={kernelName:lf,backendName:"cpu",kernelFunc:Uz};const Gz={kernelName:tp,backendName:"cpu",kernelFunc:function e(t){const{inputs:n,backend:a}=t,{x:s}=n;if("string"===s.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===s.dtype){const t=BD({inputs:{input:s},backend:a}),n=e({inputs:{x:t},backend:a}),r=JO({inputs:{input:s},backend:a}),i=Uz({inputs:{x:r},backend:a}),o=FD({inputs:{real:n,imag:i},backend:a});return a.disposeIntermediateTensorInfo(t),a.disposeIntermediateTensorInfo(n),a.disposeIntermediateTensorInfo(r),a.disposeIntermediateTensorInfo(i),o}return hL({backend:a,attrs:{shape:s.shape,value:1,dtype:s.dtype}})}};function qz(e){const{inputs:t,backend:n,attrs:a}=e,{axis:s}=a;if(1===t.length)return YF({inputs:{input:t[0]},backend:n,attrs:{dim:s}});const r=t[0].shape,i=t[0].dtype;t.forEach(e=>{bu(r,e.shape,"All tensors passed to stack must have matching shapes"),yu(i===e.dtype,()=>"All tensors passed to stack must have matching dtypes")});const o=[],c=eF({inputs:t.map(e=>{const t=YF({inputs:{input:e},backend:n,attrs:{dim:s}});return o.push(t),t}),backend:n,attrs:{axis:s}});return o.forEach(e=>n.disposeIntermediateTensorInfo(e)),c}const Kz={kernelName:ap,backendName:"cpu",kernelFunc:qz};const Xz={kernelName:sp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{paddings:r,constantValue:i}=a;dD(s,"pad");const o=r.map((e,t)=>e[0]+s.shape[t]+e[1]),c=r.map(e=>e[0]),l=n.data.get(s.dataId).values,u=vu(s.shape),h=s.shape.length,d=Bu(s.shape),p=vu(o),f=o.length,m=Bu(o),g=_u(s.dtype,p);0!==i&&g.fill(i);for(let y=0;y<u;y++){g[Ku(Xu(y,h,d).map((e,t)=>e+c[t]),f,m)]=l[y]}return{dataId:n.write(g,o,s.dtype),shape:o,dtype:s.dtype}}},Yz=CD((e,t)=>Math.pow(e,t)),Qz=HD(rp,Yz),Zz={kernelName:rp,backendName:"cpu",kernelFunc:Qz};function Jz(e,t,n,a){const[s,r]=Zx(e,a),i=mm(t,"int32"),o=Hu(vu(s),i),c=vu(r);for(let l=0;l<o.length;++l){const e=l*c;let t=1;for(let a=0;a<c;++a)t*=n[e+a];o[l]=t}return{outVals:o,outShape:s,outDtype:i}}const $z={kernelName:op,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{axis:r,keepDims:i}=a;dD(s,"prod");const o=s.shape.length,c=Eu(r,s.shape),l=ev(c,o);let u=c,h=s;const d=[];null!=l&&(h=lO({inputs:{x:s},backend:n,attrs:{perm:l}}),d.push(h),u=nv(u.length,o));const p=n.data.get(h.dataId).values,{outVals:f,outShape:m,outDtype:g}=Jz(h.shape,h.dtype,p,u);let y=m;return i&&(y=Jx(m,c)),d.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.makeTensorInfo(y,g,f)}};function eB(e,t,n,a){const s=[];let r=0;const i=t.length-1+n.length,o=new Array(i).fill(null).map(()=>[0]);!function(e,t){for(let n=0;n<e.length;++n){const a=e[n],s=n===e.length-1?t:e[n+1].length;if(0===a.length)throw new Error("Ragged splits may not be empty");if(a[0]<0)throw new Error("Ragged splits must be non-negative");if(a[a.length-1]>s)throw new Error("Ragged splits must not point past values");for(let e=1;e<a.length;++e)if(a[e-1]>a[e])throw new Error("Ragged splits must be sorted in ascending order")}}(n,a);let c=1;for(let l=0;l<t.length-1;++l){c*=t[l];const e=t[l+1];for(let t=1;t<c+1;++t)o[l].push(t*e)}for(let l=0;l<e.length;++l){let a=e[l],i=e[l]+1;for(let e=0;e<n.length;++e){const s=n[e],r=e+t.length-1;if(r>=0){const e=o[r],t=e[e.length-1]-s[a];for(let n=a;n<i;++n)o[r].push(s[n+1]+t)}a=s[a],i=s[i]}i!==a&&(s.push([a,i]),r+=i-a)}return{outSplits:o,valueSlices:s,numValues:r}}function tB(e,t){const n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let a=t;a<e.length;a++)n[t-1]*=e[a];return n}function nB(e,t,n,a,s){const r=t.slice();r[0]=s;const i=Au(n,vu(r)),o=e.length;return function(e,t,n,a,s,r){const i=tB(t,2)[1],o=tB(r,2)[1];let c=0;for(const l of n)for(let t=l[0];t<l[1];++t){for(let n=0;n<a;++n)s[c*o+n]=e[t*i+n];++c}}(e,t,a,0===o?0:o/t[0],i,r),[i,r]}function aB(e,t,n,a,s,r,i,o){if(0===e.length)throw new Error("paramsNestedSplits must be non empty");if(0===t[0].length)throw new Error("Split tensors must not be scalars");if(function(e,t,n){e.forEach((e,a)=>{if(e<0||e>=n){const s=Xu(a,t.length,Bu(t)).join(",");throw new Error("indices[".concat(s,"] = ").concat(e," is not in [0, ").concat(n,")"))}})}(r,i,t[0][0]-1),0===a.length)throw new Error("params.rank must be nonzero");const c=a[0],{outSplits:l,valueSlices:u,numValues:h}=eB(r,i,e,c),d=function(e){const t=[];for(let n=0;n<e.length;++n){const a=Au("int32",e[n].length);t.push(a),e[n].forEach((e,t)=>a[t]=e)}return t}(l),p=nB(n,a,s,u,h);return[d,p[0],p[1]]}const sB={kernelName:cp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{paramsNestedSplits:s,paramsDenseValues:r,indices:i}=t,{outputRaggedRank:o}=a,c=s.map(e=>n.data.get(e.dataId).values),l=s.map(e=>e.shape),u=n.data.get(r.dataId).values,h=n.data.get(i.dataId).values,[d,p,f]=aB(c,l,u,r.shape,r.dtype,h,i.shape),m=d.map(e=>n.makeTensorInfo([e.length],"int32",e)),g=n.makeTensorInfo(f,r.dtype,p);return m.concat([g])}},rB=2147483647;function iB(e,t,n,a,s,r,i){if(t.length>1)throw new Error("starts must be a scalar or vector");if(s.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");const o=0===t.length,c=0===s.length,l=0===i.length,u=[];o||u.push(t[0]),c||u.push(s[0]),l||u.push(i[0]);for(let m=1;m<u.length;++m)if(u[m]!==u[m-1])throw new Error("starts, limits, and deltas must have the same shape");const h=0===u.length?1:u[0],d=Au("int32",h+1);d[0]=0;for(let m=0;m<h;++m){const t=o?e[0]:e[m],n=c?a[0]:a[m],s=l?r[0]:r[m];if(0===s)throw new Error("Requires delta != 0");let i;if(s>0&&n<t||s<0&&n>t)i=0;else if(i=Math.ceil(Math.abs((n-t)/s)),i>rB)throw new Error("Requires ((limit - start) / delta) <= ".concat(rB));d[m+1]=d[m]+i}const p=Au(n,d[h]);let f=0;for(let m=0;m<h;++m){const t=d[m+1]-d[m];let n=o?e[0]:e[m];const a=l?r[0]:r[m];for(let e=0;e<t;++e)p[f++]=n,n+=a}return[d,p]}const oB={kernelName:lp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{starts:a,limits:s,deltas:r}=t,i=n.data.get(a.dataId).values,o=n.data.get(s.dataId).values,c=n.data.get(r.dataId).values,[l,u]=iB(i,a.shape,a.dtype,o,s.shape,c,r.shape);return[n.makeTensorInfo([l.length],"int32",l),n.makeTensorInfo([u.length],a.dtype,u)]}};var cB=$S;class lB{constructor(e,t,n,a,s,r,i,o,c,l){this.shape=e,this.shapeShape=t,this.values=n,this.valuesShape=a,this.valuesDType=s,this.defaultValue=r,this.defaultValueShape=i,this.rowPartitionValues=o,this.rowPartitionValuesShapes=c,this.rowPartitionTypes=tC(l),this.raggedRank=nC(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===cB.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===cB.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case cB.VALUE_ROWIDS:return lB.getMaxWidthValueRowID(t);case cB.ROW_SPLITS:return lB.getMaxWidthRowSplit(t);default:throw new Error("Cannot handle partition type ".concat(cB[this.getRowPartitionTypeByDimension(e-1)]))}}static getMaxWidthRowSplit(e){const t=e.length;if(0===t||1===t)return 0;let n=0;for(let a=0;a<t-1;++a){const t=e[a+1]-e[a];t>n&&(n=t)}return n}static getMaxWidthValueRowID(e){const t=e.length;if(0===t)return 0;let n=0,a=e[0],s=0;for(let r=1;r<t;++r){const t=e[r];t!==a&&(a=t,s=Math.max(r-n,s),n=r)}return Math.max(t-n,s)}tensorShapeFromTensor(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(0===t.length){if(-1===e[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return hB(e,n)}calculateOutputSize(e){const t=this.valuesShape;aC(this.defaultValueShape,t);const n=this.tensorShapeFromTensor(this.shape,this.shapeShape),a=eC(this.raggedRank,n,t);a[0]<0&&(a[0]=e);for(let s=1;s<=this.raggedRank;++s)a[s]<0&&(a[s]=this.getMaxWidth(s));return a}calculateFirstParentOutputIndex(e,t,n){const a=Math.min(e,n),s=[];let r=0;for(let i=0;i<a;++i,r+=t)s.push(r);for(let i=a;i<e;++i)s.push(-1);return yu(s.length===e,()=>"Final length of result must be equal to firstDimension."),s}calculateOutputIndexRowSplit(e,t,n,a){const s=e.length,r=[];for(let i=0;i<s-1;++i){const s=e[i+1]-e[i];let o=Math.min(a,s),c=t[i];-1===c&&(o=0);for(let e=0;e<o;++e)r.push(c),c+=n;for(let e=0;e<s-o;++e)r.push(-1)}if(s>0&&r.length!==e[s-1])throw new Error("Invalid row split size.");return r}calculateOutputIndexValueRowID(e,t,n,a){const s=e.length,r=[];if(0===s)return[];let i=0,o=e[0];if(o>=t.length)throw new Error("Got currentValueRowId=".concat(o,", which is not less than ").concat(t.length));let c=t[o];r.push(c);for(let l=1;l<s;++l){const s=e[l];if(s===o)c>=0&&(++i,i<a?c+=n:c=-1);else{if(i=0,o=s,s>=t.length)throw new Error("Got nextValueRowId=".concat(s," which is not less than ").concat(t.length));c=t[s]}r.push(c)}if(r.length!==e.length)throw new Error("Invalid row ids.");return r}calculateOutputIndex(e,t,n,a){const s=this.getRowPartitionTensor(e),r=this.getRowPartitionTypeByDimension(e);switch(r){case cB.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(s,t,n,a);case cB.ROW_SPLITS:if(s.length-1>t.length)throw new Error("Row partition size is greater than output size: ".concat(s.length-1," > ").concat(t.length));return this.calculateOutputIndexRowSplit(s,t,n,a);default:throw new Error("Unsupported partition type: ".concat(cB[r]))}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case cB.FIRST_DIM_SIZE:return e[0];case cB.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case cB.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error("Cannot handle type ".concat(cB[t]))}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),t=this.calculateOutputSize(e),n=new Array(this.raggedRank+1);n[n.length-1]=1;for(let r=n.length-2;r>=0;--r)n[r]=n[r+1]*t[r+1];const a=hB(t,!1),s=Au(this.valuesDType,vu(a));if(n[0]*t[0]>0){let r=this.calculateFirstParentOutputIndex(e,n[0],t[0]);for(let e=1;e<=this.raggedRank;++e){r=this.calculateOutputIndex(e-1,r,n[e],t[e])}this.setOutput(this.raggedRank,r,s,a)}return[a,s]}setOutput(e,t,n,a){if(0===n.length)return;const s=this.values,r=n;let i=a.slice();i=i.slice(e+1);const o=vu(i),c=t.length;let l=this.defaultValue;if(l.length!==o&&1!==l.length){const e=this.defaultValueShape;Km(()=>{const t=tx(l,e),n=bx(t,i);l=n.dataSync()})}let u=0,h=0,d=0;for(let p=0;p<=c;++p){let e=p<c?t[p]:-1;if(e!==d){if(h<d){const e=s.subarray(u*o);uB(r.subarray(h*o),e,(d-h)*o)}if(p>=c){const t=n.length;e=Math.floor(t/o)}if(e>d)if(1===this.defaultValue.length)r.subarray(d*o,e*o).fill(this.defaultValue[0]),d=e;else for(;e>d;){uB(r.slice(d*o),l,o),++d}e<0?(u=p+1,h=d):(u=p,h=d,d=h+1)}else++d}}}function uB(e,t,n){for(let a=0;a<n;a++)e[a]=t[a]}function hB(e,t){const n=[];for(let a of e){if(a<0){if(!t)throw new Error("Dimension ".concat(a," must be >= 0"));if(a<-1)throw new Error("Dimension ".concat(a," must be >= -1"));a=-1}n.push(a)}return n}function dB(e,t,n,a,s,r,i,o,c,l){return new lB(e,t,n,a,s,r,i,o,c,l).compute()}const pB={kernelName:up,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{shape:s,values:r,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:c}=a,l=n.data.get(s.dataId).values,u=n.data.get(r.dataId).values,h=n.data.get(i.dataId).values,d=o.map(e=>n.data.get(e.dataId).values),p=o.map(e=>e.shape),[f,m]=dB(l,s.shape,u,r.shape,r.dtype,h,i.shape,d,p,c);return n.makeTensorInfo(f,r.dtype,m)}};function fB(e,t,n,a){if(e===t||e<t&&n<0||t<e&&n>1)return Hu(0,a);const s=Hu(Math.abs(Math.ceil((t-e)/n)),a);t<e&&1===n&&(n=-1),s[0]=e;for(let r=1;r<s.length;r++)s[r]=s[r-1]+n;return s}const mB={kernelName:hp,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:a,stop:s,dtype:r,step:i}=n,o=fB(a,s,i,r);return t.makeTensorInfo([o.length],r,o)}},gB=gD(pp,e=>1/e),yB={kernelName:pp,backendName:"cpu",kernelFunc:gB};const bB={kernelName:bp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:s}=t,{alignCorners:r,halfPixelCenters:i,size:o}=a;dD(s,"resizeBilinear");const c=Bu(s.shape),[l,u]=o,[h,d,p,f]=s.shape,m=n.data.get(s.dataId).values,g=new Float32Array(vu([h,l,u,f])),y=[r&&l>1?d-1:d,r&&u>1?p-1:p],b=[r&&l>1?l-1:l,r&&u>1?u-1:u];let x=0;const v=y[0]/b[0],w=y[1]/b[1];for(let k=0;k<h;k++)for(let e=0;e<l;e++){let t;t=i?v*(e+.5)-.5:v*e;const n=Math.max(0,Math.floor(t)),a=t-n,s=Math.min(d-1,Math.ceil(t)),r=k*c[0]+n*c[1],o=k*c[0]+s*c[1];for(let e=0;e<u;e++){let t;t=i?w*(e+.5)-.5:w*e;const n=Math.max(0,Math.floor(t)),s=t-n,l=Math.min(p-1,Math.ceil(t)),u=r+n*c[2],h=o+n*c[2],d=r+l*c[2],y=o+l*c[2];for(let e=0;e<f;e++){const t=m[u+e],n=m[h+e],r=t+(m[d+e]-t)*s,i=r+(n+(m[y+e]-n)*s-r)*a;g[x++]=i}}}return n.makeTensorInfo([h,l,u,f],"float32",g)}};const xB={kernelName:xp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:s,dy:r}=t,{alignCorners:i}=a;dD([r,s],"resizeBilinearGrad");const o=Bu(s.shape),[c,l,u,h]=s.shape,[,d,p]=r.shape,f=new Float32Array(c*l*u*h),m=[i&&d>1?l-1:l,i&&p>1?u-1:u],g=[i&&d>1?d-1:d,i&&p>1?p-1:p],y=m[0]/g[0],b=m[1]/g[1],x=n.data.get(r.dataId).values;let v=0;for(let w=0;w<c;w++){const e=w*o[0];for(let t=0;t<d;t++){const n=t*y,a=Math.floor(n),s=Math.min(Math.ceil(n),l-1),r=e+a*o[1],i=e+s*o[1],c=n-a,d=1-c;for(let e=0;e<p;e++){const t=e*b,n=Math.floor(t),a=Math.min(Math.ceil(t),u-1),s=t-n,l=1-s,p=r+n*o[2],m=r+a*o[2],g=i+n*o[2],y=i+a*o[2],w=d*l,k=d*s,S=c*l,C=c*s;for(let e=0;e<h;e++){const t=x[v++];f[p+e]+=t*w,f[m+e]+=t*k,f[g+e]+=t*S,f[y+e]+=t*C}}}}return n.makeTensorInfo([c,u,l,h],"float32",f)}};const vB={kernelName:gp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:s}=t,{alignCorners:r,halfPixelCenters:i,size:o}=a;dD(s,"resizeNearestNeighbor");const c=Bu(s.shape),[l,u]=o,[h,d,p,f]=s.shape,m=n.data.get(s.dataId).values,g=new Float32Array(h*l*u*f),y=[r&&l>1?d-1:d,r&&u>1?p-1:p],b=[r&&l>1?l-1:l,r&&u>1?u-1:u],x=y[0]/b[0],v=y[1]/b[1];let w=0;for(let k=0;k<h;k++){const e=k*c[0];for(let t=0;t<l;t++){const n=i?x*(t+.5):x*t;let a=Math.min(d-1,r?Math.round(n):Math.floor(n));i&&(a=Math.max(0,a));const s=e+a*c[1];for(let e=0;e<u;e++){const t=i?v*(e+.5):v*e;let n=Math.min(p-1,r?Math.round(t):Math.floor(t));i&&(n=Math.max(0,n));const a=s+n*c[2];for(let e=0;e<f;e++){const t=m[a+e];g[w++]=t}}}}return n.makeTensorInfo([h,l,u,f],s.dtype,g)}};const wB={kernelName:yp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:s,dy:r}=t,{alignCorners:i}=a;dD([r,s],"resizeNearestNeighborGrad");const o=Bu(s.shape),c=Bu(r.shape),[l,u,h,d]=s.shape,[,p,f]=r.shape,m=new Float32Array(l*u*h*d),g=n.data.get(r.dataId).values,y=[i&&p>1?u-1:u,i&&f>1?h-1:h],b=[i&&p>1?p-1:p,i&&f>1?f-1:f],x=y[0]/b[0],v=y[1]/b[1],w=1/x,k=1/v,S=2*Math.ceil(w)+2,C=2*Math.ceil(k)+2;for(let I=0;I<l;I++){const e=I*o[0];for(let t=0;t<u;t++){const n=e+t*o[1],a=Math.floor(t*w),s=Math.floor(a-S/2);for(let r=0;r<h;r++){const a=n+r*o[2],l=Math.floor(r*k),y=Math.floor(l-C/2);for(let n=0;n<d;n++){let o=0;for(let a=0;a<S;a++){const l=a+s;if(l<0||l>=p)continue;const d=e+l*c[1],m=l*x;if(t===Math.min(u-1,i?Math.round(m):Math.floor(m)))for(let e=0;e<C;e++){const t=e+y;if(t<0||t>=f)continue;const a=d+t*c[2],s=t*v;r===Math.min(h-1,i?Math.round(s):Math.floor(s))&&(o+=g[a+n])}}m[a+n]=o}}}}return n.makeTensorInfo(s.shape,s.dtype,m)}};const kB={kernelName:wp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{dims:r}=a;dD(s,"reverse");const i=s.shape.length,o=Eu(r,s.shape);if(0===i)return vD({inputs:{x:s},backend:n});const c=new nm(s.shape,s.dtype),l=n.bufferSync(s);for(let u=0;u<c.size;u++){const e=c.indexToLoc(u),t=e.slice();o.forEach(e=>t[e]=s.shape[e]-1-t[e]),c.set(l.get(...t),...e)}return n.makeTensorInfo(c.shape,c.dtype,c.values)}},SB={kernelName:df,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e;const{image:s}=t,{radians:r,fillValue:i,center:o}=n,c=a,l=_u(s.dtype,vu(s.shape)),[u,h,d,p]=s.shape,[f,m]=iC(o,h,d),g=Math.sin(r),y=Math.cos(r),b=c.data.get(s.dataId).values;for(let x=0;x<u;x++){const e=x*d*h*p;for(let t=0;t<h;t++){const n=t*(d*p);for(let a=0;a<d;a++){const s=a*p;for(let r=0;r<p;r++){const o=[u,t,a,r],c=o[2],x=o[1];let v=(c-f)*y-(x-m)*g,w=(c-f)*g+(x-m)*y;v=Math.round(v+f),w=Math.round(w+m);let k=i;if("number"!==typeof i&&(k=3===r?255:i[r]),v>=0&&v<d&&w>=0&&w<h){k=b[e+w*(d*p)+v*p+r]}l[e+n+s+r]=k}}}}return{dataId:c.write(l,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},CB=gD(kp,e=>{const t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2===0?t:t+1}),IB={kernelName:kp,backendName:"cpu",kernelFunc:CB},NB=mD(e=>1/Math.sqrt(e)),TB=yD(Sp,NB),EB={kernelName:Sp,backendName:"cpu",kernelFunc:TB};function RB(e,t,n,a,s,r,i,o,c,l){const u=[a/s,s],h=e.values,d=t.values;if(0===a)return ty(n,t.dtype);const p=c instanceof nm?c:ty(u,t.dtype);"string"===typeof c||"number"===typeof c?p.values.fill(c):"boolean"===typeof c&&p.values.fill(+c);for(let f=0;f<r;f++){const e=[];let r=0;for(let t=0;t<i;t++){const n=h[f*i+t];e.push(n),r+=n*o[t]}if(r<0||r>=a/s)throw new Error("Invalid indices: ".concat(e," does not index into ").concat(n));for(let n=0;n<s;n++)l?p.values[r*s+n]+=d[f*s+n]:p.values[r*s+n]=0===t.rank?d[0]:d[f*s+n]}return p}const _B={kernelName:Cp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{indices:s,updates:r}=t,{shape:i}=a,{sliceRank:o,numUpdates:c,sliceSize:l,strides:u,outputSize:h}=pk(0,s,i),d=RB(n.bufferSync(s),n.bufferSync(r),i,h,l,c,o,u,0,!0);return n.makeTensorInfo(i,d.dtype,d.values)}};function AB(e,t){let n=0,a=e.length,s=0;for(;n<a;)s=Math.floor((n+a)/2),e[s]<t?n=s+1:a=s;return a}function MB(e,t){let n=0,a=e.length,s=0;for(;n<a;)s=Math.floor((n+a)/2),e[s]<=t?n=s+1:a=s;return a}const PB={kernelName:Np,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{sortedSequence:s,values:r}=t,{side:i}=a,o=function(e,t,n,a,s,r){const i=Au("int32",n*s);for(let o=0;o<n;++o){const n=e.slice(o*a,(o+1)*a),c=o*s;for(let e=0;e<s;++e)i[c+e]="left"===r?AB(n,t[e+c]):MB(n,t[e+c])}return i}(n.data.get(s.dataId).values,n.data.get(r.dataId).values,s.shape[0],s.shape[1],r.shape[1],i);return n.makeTensorInfo(r.shape,"int32",o)}};const DB={kernelName:Tp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:a,t:s,e:r}=t;dD([a,s,r],"select");const i=a.shape.length,o=n.data.get(a.dataId).values,c=n.data.get(s.dataId).values,l=n.data.get(r.dataId).values,u=mm(s.dtype,r.dtype),h=Hu(vu(s.shape),u);let d=0;const p=0===i||i>1||1===s.shape.length?1:vu(s.shape.slice(1));for(let f=0;f<o.length;f++)for(let e=0;e<p;e++)1===o[f]?h[d++]=c[f]:h[d++]=l[f];return n.makeTensorInfo(s.shape,u,h)}},OB=pC,FB=fC,LB=gD(Ep,e=>e>=0?FB*e:OB*(Math.exp(e)-1)),zB={kernelName:Ep,backendName:"cpu",kernelFunc:LB},BB=gD(Mp,e=>e<0?-1:e>0?1:0),jB={kernelName:Mp,backendName:"cpu",kernelFunc:BB},WB=gD(_p,e=>Math.sin(e)),VB={kernelName:_p,backendName:"cpu",kernelFunc:WB},UB=gD(Ap,e=>Math.sinh(e)),HB={kernelName:Ap,backendName:"cpu",kernelFunc:UB},GB=Math.log(1.1920928955078125e-7)+2,qB=gD(Dp,e=>{const t=e>-GB,n=e<GB,a=Math.exp(e);let s;return s=n?a:t?e:Math.log(1+a),s}),KB={kernelName:Dp,backendName:"cpu",kernelFunc:qB};const XB={kernelName:Lp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{blockShape:r,paddings:i}=a;dD([s],"spaceToBatchND");const o=vu(r),c=[[0,0]];c.push(...i);for(let g=1+r.length;g<s.shape.length;++g)c.push([0,0]);const l=Xz.kernelFunc({inputs:{x:s},backend:n,attrs:{paddings:c,constantValue:0}}),u=oC(l.shape,r,o,!1),h=cC(u.length,r.length,!1),d=lC(l.shape,r,o,!1),p=QD({inputs:{x:l},backend:n,attrs:{shape:u}}),f=lO({inputs:{x:p},backend:n,attrs:{perm:h}}),m=QD({inputs:{x:f},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}};function YB(e,t,n,a,s,r,i){const o=t[0],c=r[0],l=new Array(c),u=new Array(o),h=t[1];if(0===c){if(0!==o)throw new Error(jC(o));return[Au(n,0),[0,h],Au(s,0),l,u]}let d=!0,p=0;const f=new Array(c).fill(0);for(let g=0;g<o;++g){const t=e[g*h];if(t<0)throw new Error(WC(g,t));if(t>=c)throw new Error(VC(g,t,c));++f[t],d=d&&t>=p,p=t}let m=!0;for(let g=0;g<c;++g){const e=0===f[g];l[g]=e,m=m&&!e,f[g]=Math.max(f[g],1),g>0&&(f[g]+=f[g-1])}if(m&&d){const t=e,n=a;for(let e=0;e<o;++e)u[e]=e;return[t,[o,h],n,l,u]}{const t=f[c-1],r=Au(n,t*h),d=Au(s,t),p=new Array(c).fill(0);for(let n=0;n<o;++n){const t=e[n*h],s=p[t],i=(0===t?0:f[t-1])+s;p[t]++;for(let a=0;a<h;++a)r[i*h+a]=e[n*h+a];d[i]=a[n],u[n]=i}for(let e=0;e<c;++e){if(0===p[e]){const t=0===e?0:f[e-1];r[t*h+0]=e;for(let e=1;e<h;++e)r[t*h+e]=0;d[t]=i}}return[r,[t,h],d,l,u]}}const QB={kernelName:jp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:a,values:s,denseShape:r,defaultValue:i}=t;if(1!==r.shape.length)throw new Error("Dense shape must be a vector, saw:\n        ".concat(r.shape));if(2!==a.shape.length)throw new Error("Indices must be a matrix, saw:\n        ".concat(a.shape));if(1!==s.shape.length)throw new Error("Values must be a vector, saw:\n        ".concat(s.shape));if(0!==i.shape.length)throw new Error("Default value must be a scalar, saw:\n        ".concat(i.shape));const o=n.data.get(a.dataId).values,c=n.data.get(s.dataId).values,l=n.data.get(r.dataId).values,u=n.data.get(i.dataId).values[0],[h,d,p,f,m]=YB(o,a.shape,a.dtype,c,s.dtype,l,u);return[n.makeTensorInfo(d,a.dtype,h),n.makeTensorInfo([d[0]],s.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(e=>Number(e)))),n.makeTensorInfo([m.length],a.dtype,new Int32Array(m))]}};function ZB(e,t,n,a,s){const r=vu(a),i=t[0],o=s.length,c=[];let l=1,u=-1;for(let m=0;m<o;++m){const e=s[m];if(-1===e){if(-1!==u)throw new Error(UC(u,m));u=m,c.push(1)}else{if(e<0)throw new Error(HC(m,e));l*=e,c.push(e)}}if(-1!==u){if(l<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");const e=Math.trunc(r/l);if(l*e!==r)throw new Error(qC(a,c));c[u]=e}if(vu(c)!==r)throw new Error(KC(a,c));const h=a.length,d=[];if(h>0){d[h-1]=1;for(let e=h-2;e>=0;--e)d[e]=d[e+1]*a[e+1]}const p=[];if(o>0){p[o-1]=1;for(let e=o-2;e>=0;--e)p[e]=p[e+1]*c[e+1]}const f=Au(n,i*o);for(let m=0;m<i;++m){let t=0;for(let n=0;n<h;++n)t+=e[m*h+n]*d[n];for(let e=0;e<o;++e)f[m*o+e]=Math.trunc(t/p[e]),t%=p[e]}return[f,[i,o],c]}const JB={kernelName:Wp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:a,inputShape:s,newShape:r}=t;if(2!==a.shape.length)throw new Error("Input indices should be a matrix but received shape\n        ".concat(a.shape));if(1!==s.shape.length)throw new Error("Input shape should be a vector but received shape\n        ".concat(s.shape));if(1!==r.shape.length)throw new Error("Target shape should be a vector but received shape ".concat(r.shape));const i=Array.from(n.data.get(s.dataId).values),o=n.data.get(a.dataId).values,c=Array.from(n.data.get(r.dataId).values),[l,u,h]=ZB(o,a.shape,a.dtype,i,c);return[n.makeTensorInfo(u,a.dtype,l),n.makeTensorInfo([h.length],r.dtype,new Int32Array(h))]}};function $B(e,t,n,a,s){let r=arguments.length>5&&void 0!==arguments[5]&&arguments[5],i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;const o=a.length,c=[t[0],e.length/t[0]],l=c[1],u=o>0?s[o-1]+1:0;if(u<0)throw new Error("segment ids must be >= 0");const h=t.slice();h[0]=u;const d=Au(n,h.reduce((e,t)=>e*t,1));if(0===o)return u>0&&d.fill(i),[d,h];if(u<=0)throw new Error("segment ids must be >= 0");let p=0,f=1,m=0,g=s[p];for(;;){let t=0;if(f<o){if(t=s[f],g===t){++f;continue}if(g>=t)throw new Error(YC())}if(g<0||g>=u)throw new Error(QC(g,u));g>m&&d.fill(i,m*l,g*l);for(let n=p;n<f;++n){const t=a[n];if(t<0||t>=c[0])throw new Error(ZC(n,a[n],c[0]));for(let n=0;n<l;n++)d[g*l+n]+=e[t*l+n]}if(r)for(let e=0;e<l;e++)d[g*l+e]/=f-p;if(p=f,++f,m=g+1,g=t,f>o)break}return m<u&&d.fill(i,m*l,u*l),[d,h]}const ej={kernelName:Vp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:a,indices:s,segmentIds:r}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error("Indices should be a vector but received shape\n          ".concat(s.shape));if(1!==r.shape.length)throw new Error("Segment ids should be a vector but received shape\n          ".concat(r.shape));if(s.shape[0]!==r.shape[0])throw new Error("segmentIds and indices should have same size.");const i=n.data.get(a.dataId).values,o=n.data.get(s.dataId).values,c=n.data.get(r.dataId).values,[l,u]=$B(i,a.shape,a.dtype,o,c,!0);return n.makeTensorInfo(u,a.dtype,l)}};const tj={kernelName:Up,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:a,indices:s,segmentIds:r}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error("Indices should be a vector but received shape\n         ".concat(s.shape));if(1!==r.shape.length)throw new Error("Segment ids should be a vector but received shape\n         ".concat(r.shape));if(s.shape[0]!==r.shape[0])throw new Error("segmentIds and indices should have same size.");const i=n.data.get(a.dataId).values,o=n.data.get(s.dataId).values,c=n.data.get(r.dataId).values,[l,u]=$B(i,a.shape,a.dtype,o,c);return n.makeTensorInfo(u,a.dtype,l)}};const nj={kernelName:Hp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{sparseIndices:s,sparseValues:r,defaultValue:i}=t,{outputShape:o}=a,{sliceRank:c,numUpdates:l,sliceSize:u,strides:h,outputSize:d}=pk(0,s,o),p=!1,f=n.bufferSync(s);let m;switch(r.dtype){case"bool":m=RB(f,n.bufferSync(r),o,d,u,l,c,h,Boolean(n.data.get(i.dataId).values[0]),p);break;case"float32":m=RB(f,n.bufferSync(r),o,d,u,l,c,h,n.data.get(i.dataId).values[0],p);break;case"int32":m=RB(f,n.bufferSync(r),o,d,u,l,c,h,n.data.get(i.dataId).values[0],p);break;case"string":m=RB(f,n.bufferSync(r),o,d,u,l,c,h,Gf(n.data.get(i.dataId).values[0]),p);break;default:throw new Error("Unsupported type ".concat(r.dtype))}return n.makeTensorInfo(o,m.dtype,m.values)}};const aj={kernelName:zp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{numOrSizeSplits:r,axis:i}=a,o=Eu(i,s.shape)[0],c=BC(s,r,o),l=new Array(s.shape.length).fill(0),u=s.shape.slice();return c.map(e=>{const t=[...u];t[o]=e;const a=OO({inputs:{x:s},backend:n,attrs:{begin:l,size:t}});return l[o]+=e,a})}},sj=mD(e=>Math.sqrt(e)),rj=gD(Op,e=>Math.sqrt(e)),ij={kernelName:Op,backendName:"cpu",kernelFunc:rj},oj={kernelName:qp,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n}=e;const{x:a}=t,s=n;dD(a,"square");const r=s.data.get(a.dataId).values,i=new Float32Array(r.length);for(let o=0;o<r.length;++o){const e=r[o];i[o]=e*e}return{dataId:s.write(i,a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}},cj=CD((e,t)=>{const n=e-t;return n*n}),lj=HD(Gp,cj),uj={kernelName:Gp,backendName:"cpu",kernelFunc:lj},hj=mD((e,t)=>{const{pattern:n,replaceGlobal:a,rewrite:s}=t;return e.replace(new RegExp(n,a?"g":""),s)}),dj=yD(Kp,hj),pj={kernelName:Kp,backendName:"cpu",kernelFunc:dj},fj=gD(uf,(e,t)=>{const n=t;return isNaN(e)?NaN:e>0?1:n.alpha}),mj={kernelName:uf,backendName:"cpu",kernelFunc:fj};function gj(e,t,n,a){const s=ty(e,t.dtype);for(let r=0;r<s.size;r++){const e=s.indexToLoc(r),i=new Array(e.length);for(let t=0;t<i.length;t++)i[t]=e[t]*n[t]+a[t];s.set(t.get(...i),...e)}return s}const yj={kernelName:Xp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{begin:r,end:i,strides:o,beginMask:c,endMask:l,ellipsisMask:u,newAxisMask:h,shrinkAxisMask:d}=a;dD(s,"stridedSlice");const{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:x,strides:v}=Nb(s.shape,r,i,o,c,l,u,h,d);let w;if(m)w=QD({inputs:{x:s},backend:n,attrs:{shape:f}});else if(g||y){yu(s.shape.length>=1,()=>"Input must have rank at least 1, got: ".concat(s.shape.length));const e=pb(b,x,v),t=OO({inputs:{x:s},backend:n,attrs:{begin:b,size:e}});w=QD({inputs:{x:t},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(t)}else{const e=gj(p,n.bufferSync(s),v,b);w=n.makeTensorInfo(f,e.dtype,e.values)}return w}};class bj{constructor(e,t,n,a,s,r){this.separator=Hf(e),this.nGramWidths=t,this.leftPad=Hf(n),this.rightPad=Hf(a),this.padWidth=s,this.preserveShort=r}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,a,s,r){for(let i=0;i<s;++i){const o=this.getPadWidth(r),c=Math.max(0,o-i),l=Math.max(0,o-(s-(i+1))),u=r-(c+l),h=t+(c>0?0:i-o);let d=0;d+=c*this.leftPad.length;for(let t=0;t<u;++t)d+=e[h+t].length;d+=l*this.rightPad.length;d+=(c+l+u-1)*this.separator.length,n[a+i]=new Uint8Array(d);const p=n[a+i];let f=0;const m=e=>e.forEach(e=>p[f++]=e);for(let e=0;e<c;++e)m(this.leftPad),m(this.separator);for(let t=0;t<u-1;++t)m(e[h+t]),m(this.separator);if(u>0){m(e[h+u-1]);for(let e=0;e<l;++e)m(this.separator),m(this.rightPad)}else{for(let e=0;e<l-1;++e)m(this.rightPad),m(this.separator);m(this.rightPad)}}}compute(e,t){const n=e.length,a=t.length;if(a>0){let e=t[0];if(0!==e)throw new Error("First split value must be 0, got ".concat(e));for(let s=1;s<a;++s){let a=t[s]>=e;if(a=a&&t[s]<=n,!a)throw new Error("Invalid split value ".concat(t[s],", must be in [").concat(e,", ").concat(n,"]"));e=t[s]}if(e!==n)throw new Error("Last split value must be data size. Expected ".concat(n,", got ").concat(e))}const s=a-1,r=Au("int32",a);if(0===n||0===a){const e=new Array(n);for(let t=0;t<=s;++t)r[t]=0;return[e,r]}r[0]=0;for(let o=1;o<=s;++o){const e=t[o]-t[o-1];let n=0;this.nGramWidths.forEach(t=>{n+=this.getNumNGrams(e,t)}),this.preserveShort&&e>0&&0===n&&(n=1),r[o]=r[o-1]+n}const i=new Array(r[s]);for(let o=0;o<s;++o){const n=t[o];let a=r[o];if(this.nGramWidths.forEach(s=>{const r=t[o+1]-t[o],c=this.getNumNGrams(r,s);this.createNGrams(e,n,i,a,c,s),a+=c}),this.preserveShort&&a===r[o]){const s=t[o+1]-t[o];if(0===s)continue;const r=s+2*this.padWidth,c=1;this.createNGrams(e,n,i,a,c,r)}}return[i,r]}}function xj(e,t,n,a,s,r,i,o){return new bj(n,a,s,r,i,o).compute(e,t)}const vj={kernelName:Yp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{separator:s,nGramWidths:r,leftPad:i,rightPad:o,padWidth:c,preserveShortSequences:l}=a,{data:u,dataSplits:h}=t,d=n.data.get(u.dataId).values,p=n.data.get(h.dataId).values,[f,m]=xj(d,p,s,r,i,o,c,l);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(h.shape,"int32",m)]}};function wj(e,t,n,a){if(!e.length)return;if(0===t.length){for(let t=0;t<e.length;++t)a.push(e.subarray(t,t+1));return}if(1===t.length){const s=t[0];let r=e.indexOf(s);for(;-1!==r;){const t=e.subarray(0,r);n&&0===t.length||a.push(t),r=(e=e.subarray(r+1)).indexOf(s)}return void(n&&0===e.length||a.push(e))}let s=0;for(let r=0;r<e.length+1;r++)if(r===e.length||-1!==t.indexOf(e[r])){const t=e.subarray(s,r);n&&0===t.length||a.push(t),s=r+1}}function kj(e,t,n){const a=e.length,s=[];let r=0,i=0;const o=new Array(a);for(let d=0;d<a;++d){const a=s.length;wj(e[d],t,n,s);const c=s.length-a;o[d]=c,r+=c,i=Math.max(i,c)}const c=Au("int32",2*r),l=new Array(r),u=[a,i];let h=0;for(let d=0;d<a;++d)for(let e=0;e<o[d];++e)c[2*h]=d,c[2*h+1]=e,l[h]=s[h],++h;return[c,l,u]}const Sj={kernelName:Qp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{skipEmpty:s}=a,{input:r,delimiter:i}=t;if("string"!==r.dtype)throw new Error("Input must be of datatype string");if(1!==r.shape.length)throw new Error("Input must be a vector, got shape: ".concat(r.shape));if(0!==i.shape.length)throw new Error("Delimiter must be a scalar, got shape: ".concat(i.shape));const o=n.data.get(r.dataId).values,c=n.data.get(i.dataId).values[0],[l,u,h]=kj(o,c,s),d=u.length;return[n.makeTensorInfo([d,2],"int32",l),n.makeTensorInfo([d],"string",u),n.makeTensorInfo([2],"int32",new Int32Array(h))]}};function Cj(e,t){const n=Au("int32",e.length);for(let a=0;a<e.length;++a)n[a]=jf(e[a]).modulo(t).getLowBitsUnsigned();return n}const Ij={kernelName:Zp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{numBuckets:s}=a,{input:r}=t;if("string"!==r.dtype)throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const i=Cj(n.data.get(r.dataId).values,s);return n.makeTensorInfo(r.shape,"int32",i)}},Nj=gD($p,e=>Math.tan(e)),Tj={kernelName:$p,backendName:"cpu",kernelFunc:Nj},Ej=gD(ef,e=>Math.tanh(e));const Rj={kernelName:Ip,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{tensor:a,indices:s,updates:r}=t,{sliceRank:i,numUpdates:o,sliceSize:c,strides:l,outputSize:u}=pk(0,s,a.shape),h=n.bufferSync(s),d=n.bufferSync(r),p=n.bufferSync(a),f=RB(h,d,a.shape,u,c,o,i,l,p,!1);return n.makeTensorInfo(a.shape,f.dtype,f.values)}};function _j(e,t){const n=new Array(e.rank);for(let s=0;s<n.length;s++)n[s]=e.shape[s]*t[s];const a=ty(n,e.dtype);for(let s=0;s<a.values.length;++s){const t=a.indexToLoc(s),n=new Array(e.rank);for(let a=0;a<n.length;a++)n[a]=t[a]%e.shape[a];const r=e.locToIndex(n);a.values[s]=e.values[r]}return a}const Aj={kernelName:tf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{reps:r}=a;dD(s,"tile");const i=_j(n.bufferSync(s),r);return n.makeTensorInfo(i.shape,i.dtype,i.values)}},Mj=(e,t)=>{const n=t.value-e.value;return 0===n?e.index-t.index:n};function Pj(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:e.length-1;for(;a>n;){if(a-n>600){const s=a-n+1,r=t-n+1,i=Math.log(s),o=.5*Math.exp(2*i/3),c=.5*Math.sqrt(i*o*(s-o)/s)*Math.sign(r-s/2);Pj(e,t,Math.max(n,Math.floor(t-r*o/s+c)),Math.min(a,Math.floor(t+(s-r)*o/s+c)))}const s=e[t];let r=n,i=a;for(mu(e,n,t),Mj(e[a],s)>0&&mu(e,n,a);r<i;){for(mu(e,r,i),r++,i--;Mj(e[r],s)<0;)r+=1;for(;Mj(e[i],s)>0;)i-=1}0===Mj(e[n],s)?mu(e,n,i):(i+=1,mu(e,i,a)),i<=t&&(n=i+1),t<=i&&(a=i-1)}}function Dj(e,t,n,a,s){const r=t[t.length-1],[i,o]=[e.length/r,r],c=_u(n,i*a),l=_u("int32",i*a);for(let h=0;h<i;h++){const t=h*o,n=e.subarray(t,t+o);let r=new Array(n.length);n.forEach((e,t)=>r[t]={value:e,index:t}),a<r.length&&(Pj(r,a),r=r.slice(0,a)),s&&r.sort(Mj);const i=h*a,u=c.subarray(i,i+a),d=l.subarray(i,i+a);for(let e=0;e<a;e++)u[e]=r[e].value,d[e]=r[e].index}const u=t.slice();return u[u.length-1]=a,[ty(u,n,c),ty(u,"int32",l)]}const Oj={kernelName:nf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{k:r,sorted:i}=a;dD(s,"topk");const o=n.data.get(s.dataId).values,[c,l]=Dj(o,s.shape,s.dtype,r,i);return[n.makeTensorInfo(c.shape,c.dtype,c.values),n.makeTensorInfo(l.shape,l.dtype,l.values)]}};const Fj={kernelName:af,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:a}=e,{image:s,transforms:r}=t,{interpolation:i,fillMode:o,fillValue:c,outputShape:l}=n,[u,h,d,p]=s.shape,[f,m]=null!=l?l:[h,d],g=[u,f,m,p],y=Bu(s.shape),b=y[0],x=y[1],v=y[2],w=Bu(g),k=w[0],S=w[1],C=w[2],I=_u(s.dtype,vu(g));I.fill(c);const N=a.data.get(s.dataId).values,T=a.data.get(r.dataId).values;for(let E=0;E<u;++E){const e=1===r.shape[0]?T:T.subarray(8*E,8*E+8);for(let t=0;t<f;++t)for(let n=0;n<m;++n)for(let a=0;a<p;++a){let s;const r=e[6]*n+e[7]*t+1;if(0===r)continue;const l=(e[0]*n+e[1]*t+e[2])/r,u=(e[3]*n+e[4]*t+e[5])/r,p=Lj(l,d,o),f=Lj(u,h,o);switch(i){case"nearest":s=Bj(N,h,d,b,x,v,E,f,p,a,c);break;case"bilinear":s=jj(N,h,d,b,x,v,E,f,p,a,c);break;default:throw new Error("Error in Transform: Expect 'nearest' or "+"'bilinear', but got ".concat(i))}I[E*k+t*S+n*C+a]=s}return a.makeTensorInfo(g,s.dtype,I)}return{dataId:a.write(I,g,s.dtype),shape:s.shape,dtype:s.dtype}}};function Lj(e,t,n){switch(n){case"reflect":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=2*t;n<e&&(n=e*Math.trunc(-n/e)+n),n=n<-t?n+e:-n-1}else if(n>t-1)if(t<=1)n=0;else{const e=2*t;n-=e*Math.trunc(n/e),n>=t&&(n=e-n-1)}return pu(0,n,t-1)}(e,t);case"wrap":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=t-1;n+=t*(Math.trunc(-n/e)+1)}else if(n>t-1)if(t<=1)n=0;else{const e=t-1;n-=t*Math.trunc(n/e)}return pu(0,n,t-1)}(e,t);case"nearest":return function(e,t){return pu(0,e,t-1)}(e,t);default:return function(e){return e}(e)}}function zj(e,t,n,a,s,r,i,o,c,l,u){return 0<=o&&o<t&&0<=c&&c<n?e[i*a+o*s+c*r+l]:u}function Bj(e,t,n,a,s,r,i,o,c,l,u){return zj(e,t,n,a,s,r,i,Math.round(o),Math.round(c),l,u)}function jj(e,t,n,a,s,r,i,o,c,l,u){const h=Math.floor(o),d=Math.floor(c),p=h+1,f=d+1;return(p-o)*((f-c)*zj(e,t,n,a,s,r,i,h,d,l,u)+(c-d)*zj(e,t,n,a,s,r,i,h,f,l,u))+(o-h)*((f-c)*zj(e,t,n,a,s,r,i,p,d,l,u)+(c-d)*zj(e,t,n,a,s,r,i,p,f,l,u))}function Wj(e,t,n,a){const s=Eu(t,n)[0],r=[1,n[0],1];for(let f=0;f<s;f++)r[0]*=n[f];r[1]=n[s];for(let f=s+1;f<n.length;f++)r[2]*=n[f];const i=new Map,o=new Int32Array(n[s]),c=new nm(r,a,e),l=[],u=1===r[0]&&1===r[2];for(let f=0;f<n[s];f++){let t;if(u)t=e[f].toString();else{const e=[];for(let t=0;t<r[0];t++)for(let n=0;n<r[2];n++)e.push(c.get(t,f,n));t=e.join(",")}const n=i.get(t);if(null!=n)o[f]=n;else{const e=i.size;i.set(t,e),o[f]=e,l.push(f)}}const h=r.slice();h[1]=i.size;const d=new nm(h,a);l.forEach((e,t)=>{for(let n=0;n<r[0];n++)for(let a=0;a<r[2];a++)d.set(c.get(n,e,a),n,t,a)});const p=n.slice();return p[s]=h[1],{outputValues:d.values,outputShape:p,indices:o}}const Vj={kernelName:rf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:a}=e,{axis:s}=n,{x:r}=t;dD(r,"unique");const i=a.data.get(r.dataId).values,{outputValues:o,outputShape:c,indices:l}=Wj(i,s,r.shape,r.dtype);return[a.makeTensorInfo(c,r.dtype,o),a.makeTensorInfo([l.length],"int32",l)]}};const Uj={kernelName:of,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{value:s}=t;let{axis:r}=a;r<0&&(r+=s.shape.length);const i=s.shape.length,o=s.shape[r],c=new Array(i-1);let l=0;for(let p=0;p<i;p++)p!==r&&(c[l++]=s.shape[p]);const u=new Array(i).fill(0),h=s.shape.slice();h[r]=1;const d=new Array(o);for(let p=0;p<d.length;p++){u[r]=p;const e=OO({inputs:{x:s},backend:n,attrs:{begin:u,size:h}});d[p]=QD({inputs:{x:e},backend:n,attrs:{shape:c}}),n.disposeIntermediateTensorInfo(e)}return d}};const Hj={kernelName:cf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,segmentIds:r}=t,{numSegments:i}=a;dD(s,"unsortedSegmentSum");const o=[],c=[],l=s.shape.length-r.shape.length;let u=r;for(let d=0;d<l;++d){const e=YF({inputs:{input:u},backend:n,attrs:{dim:d+1}});u=e,c.push(e)}for(let d=0;d<i;++d){const e=Wf(d,"int32"),t=n.makeTensorInfo([],"int32",e),a=FF({inputs:{a:t,b:u},backend:n}),r=VD({inputs:{x:a},backend:n,attrs:{dtype:"float32"}}),i=RF({inputs:{a:r,b:s},backend:n}),l=AF({inputs:{x:i},backend:n,attrs:{axis:0,keepDims:!1}});o.push(l),c.push(t),c.push(a),c.push(r),c.push(i),c.push(l)}const h=qz({inputs:o,backend:n,attrs:{axis:0}});return c.forEach(e=>n.disposeIntermediateTensorInfo(e)),h}},Gj=[eO,nO,sO,iO,YD,oO,hO,dO,pO,fO,gO,bO,vO,SO,IO,RO,_O,AO,MO,$D,PO,LO,jO,UO,HO,UD,KO,YO,LD,QO,tF,aF,sF,rF,iF,oF,cF,uF,dF,pF,fF,mF,gF,yF,xF,vF,wF,kF,SF,CF,IF,NF,PF,xD,DF,LF,GF,XF,QF,$F,uL,dL,pL,gL,xL,vL,wL,SL,IL,EL,AL,wD,ML,$O,DL,FL,zL,SD,WL,HL,qL,YL,ZL,ez,nz,rz,iz,oz,uz,pz,fz,mz,gz,yz,bz,xz,vz,Sz,Cz,Tz,_z,_F,Mz,Dz,Fz,zz,Wz,Vz,Gz,Kz,Xz,Zz,TD,$z,sB,oB,pB,mB,jD,nL,yB,RD,AD,ZD,bB,xB,vB,wB,kB,SB,IB,EB,_B,PB,DB,zB,DD,jB,VB,HB,FO,Rz,KB,XB,QB,JB,ej,tj,nj,aj,ij,oj,uj,pj,mj,yj,vj,Sj,Ij,iL,MF,Tj,{kernelName:ef,backendName:"cpu",kernelFunc:Ej},Rj,Aj,Oj,Fj,uO,Vj,Uj,Hj,Hz];for(const n of Gj)Sf(n);const qj={},Kj={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function Xj(e,t){if(!(e in qj)||null!=t){const n=function(e,t){if(1!==e&&2!==e)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const n=null==t?function(e){if($u().getBool("IS_SAFARI")||"undefined"===typeof OffscreenCanvas||2!==e){if("undefined"!==typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}return new OffscreenCanvas(300,150)}(e):t;n.addEventListener("webglcontextlost",t=>{t.preventDefault(),delete qj[e]},!1),$u().getBool("SOFTWARE_WEBGL_ENABLED")&&(Kj.failIfMajorPerformanceCaveat=!1);if(1===e)return n.getContext("webgl",Kj)||n.getContext("experimental-webgl",Kj);return n.getContext("webgl2",Kj)}(e,t);if(null===n)return console.log("Could not get context for WebGL version",e),null;qj[e]=n}const n=qj[e];return null==n||n.isContextLost()?(delete qj[e],Xj(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),qj[e])}var Yj,Qj,Zj;function Jj(e,t){return[t,e]}function $j(e){const t=vu(e);return Cu(Math.ceil(t/4))}function eW(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function tW(e,t){const n=e;let a,s,r,i,o,c,l,u,h,d;return 2===$u().getNumber("WEBGL_VERSION")?(a=n.R32F,s=n.R16F,r=n.RGBA16F,i=n.RGBA32F,o=n.RED,l=4,u=1,h=n.HALF_FLOAT,d=n.FLOAT,c=n.RGBA8):(a=e.RGBA,s=e.RGBA,r=e.RGBA,i=n.RGBA,o=e.RGBA,l=4,u=4,h=null!=t?t.HALF_FLOAT_OES:null,d=e.FLOAT,c=e.RGBA),{internalFormatFloat:a,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:r,internalFormatPackedFloat:i,textureFormatFloat:o,downloadTextureFormat:c,downloadUnpackNumChannels:l,defaultNumChannels:u,textureTypeHalfFloat:h,textureTypeFloat:d}}function nW(e,t){const n=t();return $u().getBool("DEBUG")&&function(e){const t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+function(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return"Unknown error code ".concat(t)}}(e,t))}(e),n}!function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"}(Yj||(Yj={})),function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"}(Qj||(Qj={})),function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(Zj||(Zj={}));function aW(e){return!!($u().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||5.96e-8<Math.abs(e)&&Math.abs(e)<65504)}function sW(e,t){return pW(e,()=>e.getExtension(t),'Extension "'+t+'" not supported on this browser.')}const rW=/ERROR: [0-9]+:([0-9]+):/g;function iW(e,t){const n=rW.exec(t);if(null==n)return console.log("Couldn't parse line number in error: ".concat(t)),void console.log(e);const a=+n[1],s=e.split("\n"),r=s.length.toString().length+2,i=s.map((e,t)=>Iu((t+1).toString(),r)+e);let o=0;for(let h=0;h<i.length;h++)o=Math.max(i[h].length,o);const c=i.slice(0,a-1),l=i.slice(a-1,a),u=i.slice(a);console.log(c.join("\n")),console.log(t.split("\n")[0]),console.log("%c ".concat(Iu(l[0],o)),"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(u.join("\n"))}function oW(e,t){if(nW(e,()=>e.validateProgram(t)),!1===e.getProgramParameter(t,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function cW(e,t,n,a,s,r,i){const o=e.getAttribLocation(t,n);return-1!==o&&(nW(e,()=>e.bindBuffer(e.ARRAY_BUFFER,a)),nW(e,()=>e.vertexAttribPointer(o,s,e.FLOAT,!1,r,i)),nW(e,()=>e.enableVertexAttribArray(o)),!0)}function lW(e,t,n,a){nW(e,()=>function(e,t,n){fW(e,n),nW(e,()=>e.activeTexture(e.TEXTURE0+n)),nW(e,()=>e.bindTexture(e.TEXTURE_2D,t))}(e,t,a)),nW(e,()=>e.uniform1i(n,a))}function uW(e,t,n){nW(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,n)),nW(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0))}function hW(e,t){nW(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,t)),nW(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0))}function dW(e){const t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return"unknown error ".concat(t)}}(e,t))}function pW(e,t,n){const a=nW(e,()=>t());if(null==a)throw new Error(n);return a}function fW(e,t){const n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,a=t+e.TEXTURE0;if(a<e.TEXTURE0||a>n){const e="[gl.TEXTURE0, gl.TEXTURE".concat(n,"]");throw new Error("textureUnit must be in ".concat(e,"."))}}function mW(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:2;return vu(e.slice(0,e.length-t))}function gW(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function yW(e){let t=[1,1,1];return 0===e.length||1===e.length&&1===e[0]||(t=[mW(e),...gW(e)]),t}function bW(e){return e%2===0}function xW(e,t){if(ku(e=e.slice(-2),t=t.slice(-2)))return!0;if(!e.length||!t.length)return!0;if(0===e[0]||0===e[1]||0===t[0]||0===t[1])return!0;if(e.length!==t.length){const n=e[e.length-1],a=t[t.length-1];if(n===a)return!0;if(bW(n)&&bW(a)&&(1===e[0]||1===t[0]))return!0}return e[1]===t[1]&&bW(e[0])&&bW(t[0])}let vW,wW;function kW(e,t){return null!=e.getExtension(t)}function SW(e){try{if(null!=Xj(e))return!0}catch(G5){return console.log("Error when getting WebGL context: ",G5),!1}return!1}function CW(e){if(0===e)return!1;const t=Xj(e);if(1!==e){if(kW(t,"EXT_color_buffer_float"))return IW(t);const e="EXT_color_buffer_half_float";if(kW(t,e)){const n=t.getExtension(e);return function(e,t){const n=tW(e,t),a=e.createTexture();e.bindTexture(e.TEXTURE_2D,a);const s=1,r=1;e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,s,r,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const i=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,i),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,a,0);const o=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(a),e.deleteFramebuffer(i),o}(t,n)}return!1}if(!kW(t,"OES_texture_float"))return!1;if(!kW(t,"WEBGL_color_buffer_float"))return!1;return IW(t)}function IW(e){const t=tW(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n);e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const a=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,a),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);const s=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(a),s}function NW(e,t){Array.isArray(e)||(e=[e]),e.forEach(e=>{null!=e&&yu("complex64"!==e.dtype,()=>"".concat(t," does not support complex64 tensors ")+"in the WebGL backend.")})}const TW=$u();function EW(){let e,t,n,a,s,r,i,o,c,l;return 2===$u().getNumber("WEBGL_VERSION")?(e="#version 300 es",t="in",n="out",a="in",s="texture",r="outputColor",i="out vec4 outputColor;",o=$u().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",c="",l="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(e="",t="attribute",n="varying",a="varying",s="texture2D",r="gl_FragColor",i="",o="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",c="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",l="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:e,attribute:t,varyingVs:n,varyingFs:a,texture2D:s,output:r,defineOutput:i,defineSpecialNaN:o,defineSpecialInf:c,defineRound:l}}function RW(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index";const a=Bu(t);return a.map((t,s)=>{const r="int ".concat(e[s]," = ").concat(n," / ").concat(t),i=s===a.length-1?"int ".concat(e[s+1]," = ").concat(n," - ").concat(e[s]," * ").concat(t):"index -= ".concat(e[s]," * ").concat(t);return"".concat(r,"; ").concat(i,";")}).join("")}function _W(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index";const a=Bu(t);return a.map((t,s)=>{const r="int ".concat(e[s]," = ").concat(n," / outShapeStrides[").concat(s,"]"),i=s===a.length-1?"int ".concat(e[s+1]," = ").concat(n," - ").concat(e[s]," * outShapeStrides[").concat(s,"]"):"index -= ".concat(e[s]," * outShapeStrides[").concat(s,"]");return"".concat(r,"; ").concat(i,";")}).join("")}function AW(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index";const a=function(e,t){const n=e.length,a=e.map(e=>"".concat(t,"[").concat(e,"]")),s=new Array(n-1);s[n-2]=a[n-1];for(let r=n-3;r>=0;--r)s[r]="(".concat(s[r+1]," * ").concat(a[r+1],")");return s}(e.map((e,t)=>t),t);return a.map((t,s)=>{const r="int ".concat(e[s]," = ").concat(n," / ").concat(a[s]),i=s===a.length-1?"int ".concat(e[s+1]," = ").concat(n," - ").concat(e[s]," * ").concat(a[s]):"index -= ".concat(e[s]," * ").concat(a[s]);return"".concat(r,"; ").concat(i,";")}).join("")}function MW(e){const t=Bu(e).map(e=>e.toString());return"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ".concat(t[0]," + coords.y * ").concat(t[1]," + coords.z;\n  }\n")}TW.registerFlag("HAS_WEBGL",()=>TW.getNumber("WEBGL_VERSION")>0),TW.registerFlag("WEBGL_VERSION",()=>SW(2)?2:SW(1)?1:0),TW.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1),TW.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>2===TW.get("WEBGL_VERSION")),TW.registerFlag("WEBGL_CPU_FORWARD",()=>!0),TW.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),TW.registerFlag("WEBGL_PACK",()=>TW.getBool("HAS_WEBGL")),TW.registerFlag("WEBGL_PACK_NORMALIZATION",()=>TW.getBool("WEBGL_PACK")),TW.registerFlag("WEBGL_PACK_CLIP",()=>TW.getBool("WEBGL_PACK")),TW.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>TW.getBool("WEBGL_PACK")),TW.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>TW.getBool("WEBGL_PACK")),TW.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>TW.getBool("WEBGL_PACK")),TW.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>TW.getBool("WEBGL_PACK")),TW.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>TW.getBool("WEBGL_PACK")),TW.registerFlag("WEBGL_PACK_REDUCE",()=>TW.getBool("WEBGL_PACK")),TW.registerFlag("WEBGL_LAZILY_UNPACK",()=>TW.getBool("WEBGL_PACK")),TW.registerFlag("WEBGL_CONV_IM2COL",()=>TW.getBool("WEBGL_PACK")),TW.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>TW.getBool("WEBGL_PACK")),TW.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>function(e){if(null==vW){const t=Xj(e);vW=t.getParameter(t.MAX_TEXTURE_SIZE)}return vW}(TW.getNumber("WEBGL_VERSION"))),TW.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>function(e){if(null==wW){const t=Xj(e);wW=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,wW)}(TW.getNumber("WEBGL_VERSION"))),TW.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const e=TW.getNumber("WEBGL_VERSION");return 0===e?0:function(e){if(0===e)return 0;let t;const n=Xj(e);return t=kW(n,"EXT_disjoint_timer_query_webgl2")&&2===e?2:kW(n,"EXT_disjoint_timer_query")?1:0,t}(e)}),TW.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>TW.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!_m()),TW.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>function(e){if(0===e)return!1;const t=Xj(e);if(1===e){if(!kW(t,"OES_texture_float"))return!1}else if(!kW(t,"EXT_color_buffer_float"))return!1;return IW(t)}(TW.getNumber("WEBGL_VERSION"))),TW.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>!TW.getBool("WEBGL_FORCE_F16_TEXTURES")&&TW.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),TW.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>CW(TW.getNumber("WEBGL_VERSION"))),TW.registerFlag("WEBGL_FENCE_API_ENABLED",()=>{return 2===(e=TW.getNumber("WEBGL_VERSION"))&&null!=Xj(e).fenceSync;var e}),TW.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>TW.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0),TW.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,e=>{if("number"!==typeof e)throw new Error("WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but "+"got ".concat(e,"."));if(e<0&&-1!==e)throw new Error("WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never "+"delete) or at least 0, but got ".concat(e,"."))}),TW.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>_m()?1:-1,e=>{if("number"!==typeof e)throw new Error("WEBGL_FLUSH_THRESHOLD must be a number but got "+"".concat(e,"."));if(e<0&&-1!==e)throw new Error("WEBGL_FLUSH_THRESHOLD must be -1 (indicating never "+"manual flush) or at least 0, but got ".concat(e,"."))}),TW.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128),TW.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1),TW.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5),TW.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128),TW.registerFlag("WEBGL_EXP_CONV",()=>!1),TW.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>TW.getBool("IS_TEST")),TW.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0),TW.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1),TW.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1),TW.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);const PW="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:DW}=r;function OW(e,t,n){const a=[];if(e.forEach(e=>{const t=vu(e.shapeInfo.logicalShape);if(e.shapeInfo.isUniform?a.push("uniform float ".concat(e.name).concat(t>1?"[".concat(t,"]"):"",";")):(a.push("uniform sampler2D ".concat(e.name,";")),a.push("uniform int offset".concat(e.name,";"))),n.enableShapeUniforms){const{uniformShape:t}=GW(n.packedInputs,e.shapeInfo.logicalShape,e.shapeInfo.texShape);switch(t.length){case 1:a.push("uniform int ".concat(e.name,"Shape;"));break;case 2:a.push("uniform ivec2 ".concat(e.name,"Shape;"));break;case 3:a.push("uniform ivec3 ".concat(e.name,"Shape;"));break;case 4:a.push("uniform ivec4 ".concat(e.name,"Shape;"))}a.push("uniform ivec2 ".concat(e.name,"TexShape;"))}}),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:a.push("uniform int outShape;");break;case 2:a.push("uniform ivec2 outShape;"),a.push("uniform int outShapeStrides;");break;case 3:a.push("uniform ivec3 outShape;"),a.push("uniform ivec2 outShapeStrides;");break;case 4:a.push("uniform ivec4 outShape;"),a.push("uniform ivec3 outShapeStrides;")}a.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach(e=>{a.push("uniform ".concat(e.type," ").concat(e.name).concat(e.arrayIndex?"[".concat(e.arrayIndex,"]"):"",";"))});const s=a.join("\n"),r=e.map(e=>function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3?arguments[3]:void 0,s="";s+=n?LW(e,a):FW(e,a);const r=e.shapeInfo.logicalShape,i=t.logicalShape;r.length<=i.length&&(s+=n?function(e,t){const n=e.name,a=n.charAt(0).toUpperCase()+n.slice(1),s="get"+a+"AtOutCoords",r=e.shapeInfo.logicalShape.length,i=t.logicalShape.length,o=DW(e.shapeInfo.logicalShape,t.logicalShape),c=HW(i),l=i-r;let u;const h=["x","y","z","w","u","v"];u=0===r?"":i<2&&o.length>=1?"coords = 0;":o.map(e=>"coords.".concat(h[e+l]," = 0;")).join("\n");let d="";d=i<2&&r>0?"coords":e.shapeInfo.logicalShape.map((e,t)=>"coords.".concat(h[t+l])).join(", ");let p="return outputValue;";const f=1===vu(e.shapeInfo.logicalShape),m=vu(t.logicalShape),g=1===m;if(1!==r||f||g){if(f&&!g)p=1===i?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(o.length){const e=r-2,t=r-1;o.indexOf(e)>-1&&o.indexOf(t)>-1?p="return vec4(outputValue.x);":o.indexOf(e)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":o.indexOf(t)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}}else p="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return"\n    vec4 ".concat(s,"() {\n      ").concat(c," coords = getOutputCoords();\n      ").concat(u,"\n      vec4 outputValue = get").concat(a,"(").concat(d,");\n      ").concat(p,"\n    }\n  ")}(e,t):function(e,t){const n=e.name,a=n.charAt(0).toUpperCase()+n.slice(1),s="get"+a+"AtOutCoords",r=t.texShape,i=e.shapeInfo.texShape,o=e.shapeInfo.logicalShape.length,c=t.logicalShape.length;if(!e.shapeInfo.isUniform&&o===c&&null==e.shapeInfo.flatOffset&&ku(i,r))return"\n      float ".concat(s,"() {\n        return sampleTexture(").concat(n,", resultUV);\n      }\n    ");const l=HW(c),u=DW(e.shapeInfo.logicalShape,t.logicalShape),h=c-o;let d;const p=["x","y","z","w","u","v"];d=0===o?"":c<2&&u.length>=1?"coords = 0;":u.map(e=>"coords.".concat(p[e+h]," = 0;")).join("\n");let f="";f=c<2&&o>0?"coords":e.shapeInfo.logicalShape.map((e,t)=>"coords.".concat(p[t+h])).join(", ");return"\n    float ".concat(s,"() {\n      ").concat(l," coords = getOutputCoords();\n      ").concat(d,"\n      return get").concat(a,"(").concat(f,");\n    }\n  ")}(e,t));return s}(e,t,n.packedInputs,n.enableShapeUniforms)).join("\n"),i=t.texShape,o=EW(),c=function(e){return"\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ".concat(e.texture2D,"(textureSampler, uv).r;\n    }\n  ")}(o);let l,u,h=function(e){const t="".concat(e.version,"\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ").concat(e.varyingFs," vec2 resultUV;\n    ").concat(e.defineOutput,"\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ").concat(e.defineSpecialNaN,"\n    ").concat(e.defineSpecialInf,"\n    ").concat(e.defineRound,"\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ").concat(zW,"\n    ").concat(BW,"\n    ").concat(jW,"\n  ");return t}(o);t.isPacked?(l=function(e,t,n){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(e,t,n){const a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(1===a[0])return n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ".concat(a[1],".0);\n      }\n    ");if(1===a[1])return n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ".concat(a[0],".0);\n      }\n    ");if(n)return"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ";return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(a[0],", ").concat(a[1],"));\n      return 2 * (resTexRC.x * ").concat(a[1]," + resTexRC.y);\n    }\n  ")}(0,t,n);case 2:return function(e,t,n){const a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(ku(e,t))return n?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(".concat(a[0],", ").concat(a[1],"));\n      }\n    ");const s=Math.ceil(e[1]/2);if(n)return"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ";return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(a[0],", ").concat(a[1],"));\n\n      int index = resTexRC.x * ").concat(a[1]," + resTexRC.y;\n      int r = 2 * (index / ").concat(s,");\n      int c = imod(index, ").concat(s,") * 2;\n\n      return ivec2(r, c);\n    }\n  ")}(e,t,n);case 3:return function(e,t,n){if(n)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(e[2]/2),r=s*Math.ceil(e[1]/2);return"\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(a[0],", ").concat(a[1],"));\n      int index = resTexRC.x * ").concat(a[1]," + resTexRC.y;\n\n      int b = index / ").concat(r,";\n      index -= b * ").concat(r,";\n\n      int r = 2 * (index / ").concat(s,");\n      int c = imod(index, ").concat(s,") * 2;\n\n      return ivec3(b, r, c);\n    }\n  ")}(e,t,n);default:return function(e,t,n){if(n)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(e[e.length-1]/2),r=s*Math.ceil(e[e.length-2]/2);let i=r,o="",c="b, r, c";for(let l=2;l<e.length-1;l++)i*=e[e.length-l-1],o="\n      int b".concat(l," = index / ").concat(i,";\n      index -= b").concat(l," * ").concat(i,";\n    ")+o,c="b".concat(l,", ")+c;return"\n    ivec".concat(e.length," getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(").concat(a[0],", ").concat(a[1],"));\n      int index = resTexRC.x * ").concat(a[1]," + resTexRC.y;\n\n      ").concat(o,"\n\n      int b = index / ").concat(r,";\n      index -= b * ").concat(r,";\n\n      int r = 2 * (index / ").concat(s,");\n      int c = imod(index, ").concat(s,") * 2;\n\n      return ivec").concat(e.length,"(").concat(c,");\n    }\n  ")}(e,t,n)}}(t.logicalShape,i,n.enableShapeUniforms),u=function(e){return"\n    void setOutput(vec4 val) {\n      ".concat(e.output," = val;\n    }\n  ")}(o)):(l=function(e,t,n){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(e,t,n){if(1===t[0])return n?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":"\n      int getOutputCoords() {\n        return int(resultUV.x * ".concat(t[1],".0);\n      }\n    ");if(1===t[1])return n?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":"\n      int getOutputCoords() {\n        return int(resultUV.y * ".concat(t[0],".0);\n      }\n    ");if(n)return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ";return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(t[0],", ").concat(t[1],"));\n      return resTexRC.x * ").concat(t[1]," + resTexRC.y;\n    }\n  ")}(0,t,n);case 2:return function(e,t,n){if(ku(e,t))return n?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(".concat(t[0],", ").concat(t[1],"));\n      }\n    ");if(1===e[1])return n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(".concat(t[0],", ").concat(t[1],"));\n        int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ");if(1===e[0])return n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(".concat(t[0],", ").concat(t[1],"));\n        int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ");if(n)return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ";return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(t[0],", ").concat(t[1],"));\n      int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n      int r = index / ").concat(e[1],";\n      int c = index - r * ").concat(e[1],";\n      return ivec2(r, c);\n    }\n  ")}(e,t,n);case 3:return function(e,t,n){if(n){const t=_W(["r","c","d"],e);return"\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ".concat(t,"\n    return ivec3(r, c, d);\n  }\n")}const a=RW(["r","c","d"],e);return"\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(t[0],", ").concat(t[1],"));\n      int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n      ").concat(a,"\n      return ivec3(r, c, d);\n    }\n  ")}(e,t,n);case 4:return function(e,t,n){if(n){const t=_W(["r","c","d","d2"],e);return"\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ".concat(t,"\n      return ivec4(r, c, d, d2);\n    }\n  ")}const a=RW(["r","c","d","d2"],e);return"\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(".concat(t[0],", ").concat(t[1],"));\n      int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n      ").concat(a,"\n      return ivec4(r, c, d, d2);\n    }\n  ")}(e,t,n);case 5:return function(e,t){const n=RW(["r","c","d","d2","d3"],e);return"\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(".concat(t[0],",\n                             ").concat(t[1],"));\n\n      int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n\n      ").concat(n,"\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  ")}(e,t);case 6:return function(e,t){const n=RW(["r","c","d","d2","d3","d4"],e);return"\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(".concat(t[0],", ").concat(t[1],"));\n      int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n\n      ").concat(n,"\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  ")}(e,t);default:throw new Error("".concat(e.length,"-D output sampling is not yet supported"))}}(t.logicalShape,i,n.enableShapeUniforms),u=function(e){return"\n    void setOutput(float val) {\n      ".concat(e.output," = vec4(val, 0, 0, 0);\n    }\n  ")}(o)),n.packedInputs&&(h+=WW);return[h,c,u,s,l,r,n.userCode].join("\n")}function FW(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const n=e.shapeInfo.logicalShape;switch(n.length){case 0:return function(e,t){const n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return"float ".concat(a,"() {return ").concat(n,";}");const[s,r]=e.shapeInfo.texShape;if(1===s&&1===r)return"\n      float ".concat(a,"() {\n        return sampleTexture(").concat(n,", halfCR);\n      }\n    ");const i=VW(n);if(t)return"\n    float ".concat(a,"() {\n      vec2 uv = uvFromFlat(").concat(n,"TexShape[0], ").concat(n,"TexShape[1], ").concat(i,");\n      return sampleTexture(").concat(n,", uv);\n    }\n  ");const[o,c]=e.shapeInfo.texShape;return"\n    float ".concat(a,"() {\n      vec2 uv = uvFromFlat(").concat(o,", ").concat(c,", ").concat(i,");\n      return sampleTexture(").concat(n,", uv);\n    }\n  ")}(e,t);case 1:return function(e,t){const n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return"\n      float ".concat(a,"(int index) {\n        ").concat(UW(e),"\n      }\n    ");const s=e.shapeInfo.texShape,r=s[0],i=s[1];if(1===i&&1===r)return"\n      float ".concat(a,"(int index) {\n        return sampleTexture(").concat(n,", halfCR);\n      }\n    ");const o=VW(n);if(1===i)return t?"\n      float ".concat(a,"(int index) {\n        vec2 uv = vec2(0.5, (float(index + ").concat(o,") + 0.5) / float(").concat(n,"TexShape[0]));\n        return sampleTexture(").concat(n,", uv);\n      }\n    "):"\n      float ".concat(a,"(int index) {\n        vec2 uv = vec2(0.5, (float(index + ").concat(o,") + 0.5) / ").concat(r,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");if(1===r)return t?"\n      float ".concat(a,"(int index) {\n        vec2 uv = vec2((float(index + ").concat(o,") + 0.5) / float(").concat(n,"TexShape[1]), 0.5);\n        return sampleTexture(").concat(n,", uv);\n      }\n    "):"\n      float ".concat(a,"(int index) {\n        vec2 uv = vec2((float(index + ").concat(o,") + 0.5) / ").concat(i,".0, 0.5);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");if(t)return"\n    float ".concat(a,"(int index) {\n      vec2 uv = uvFromFlat(").concat(n,"TexShape[0], ").concat(n,"TexShape[1], index + ").concat(o,");\n      return sampleTexture(").concat(n,", uv);\n    }\n  ");return"\n    float ".concat(a,"(int index) {\n      vec2 uv = uvFromFlat(").concat(r,", ").concat(i,", index + ").concat(o,");\n      return sampleTexture(").concat(n,", uv);\n    }\n  ")}(e,t);case 2:return function(e,t){const n=e.shapeInfo.logicalShape,a=e.name,s="get"+a.charAt(0).toUpperCase()+a.slice(1),r=e.shapeInfo.texShape;if(null!=r&&ku(n,r)){if(t)return"\n      float ".concat(s,"(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n        return sampleTexture(").concat(a,", uv);\n      }\n    ");const e=r[0],n=r[1];return"\n    float ".concat(s,"(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(n,".0, ").concat(e,".0);\n      return sampleTexture(").concat(a,", uv);\n    }\n  ")}const{newShape:i,keptDims:o}=Ru(n),c=i;if(c.length<n.length){const n=qW(e,c),a=["row","col"];return"\n      ".concat(FW(n,t),"\n      float ").concat(s,"(int row, int col) {\n        return ").concat(s,"(").concat(KW(a,o),");\n      }\n    ")}if(e.shapeInfo.isUniform)return"\n      float ".concat(s,"(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(").concat(n[1],", 1)));\n        ").concat(UW(e),"\n      }\n    ");const l=r[0],u=r[1],h=VW(a);if(1===u)return t?"\n      float ".concat(s,"(int row, int col) {\n        float index = dot(vec3(row, col, ").concat(h,"), vec3(").concat(a,"Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(").concat(a,"TexShape[0]));\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n    float ".concat(s,"(int row, int col) {\n      float index = dot(vec3(row, col, ").concat(h,"), vec3(").concat(n[1],", 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ").concat(l,".0);\n      return sampleTexture(").concat(a,", uv);\n    }\n  ");if(1===l)return t?"\n      float ".concat(s,"(int row, int col) {\n        float index = dot(vec3(row, col, ").concat(h,"), vec3(").concat(a,"Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(").concat(a,"TexShape[1]), 0.5);\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n    float ".concat(s,"(int row, int col) {\n      float index = dot(vec3(row, col, ").concat(h,"), vec3(").concat(n[1],", 1, 1));\n      vec2 uv = vec2((index + 0.5) / ").concat(u,".0, 0.5);\n      return sampleTexture(").concat(a,", uv);\n    }\n  ");if(t)return"\n      float ".concat(s,"(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ").concat(a,"Shape[1] + col + ").concat(h,";\n        vec2 uv = uvFromFlat(").concat(a,"TexShape[0], ").concat(a,"TexShape[1], index);\n        return sampleTexture(").concat(a,", uv);\n      }\n    ");return"\n  float ".concat(s,"(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ").concat(n[1]," + col + ").concat(h,";\n    vec2 uv = uvFromFlat(").concat(l,", ").concat(u,", index);\n    return sampleTexture(").concat(a,", uv);\n  }\n")}(e,t);case 3:return function(e,t){const n=e.shapeInfo.logicalShape,a=e.name,s="get"+a.charAt(0).toUpperCase()+a.slice(1),r=n[1]*n[2],i=n[2],{newShape:o,keptDims:c}=Ru(n),l=o;if(l.length<n.length){const n=qW(e,l),a=["row","col","depth"];return"\n        ".concat(FW(n,t),"\n        float ").concat(s,"(int row, int col, int depth) {\n          return ").concat(s,"(").concat(KW(a,c),");\n        }\n      ")}if(e.shapeInfo.isUniform)return"\n      float ".concat(s,"(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(").concat(r,", ").concat(i,", 1)));\n        ").concat(UW(e),"\n      }\n    ");const u=e.shapeInfo.texShape,h=u[0],d=u[1],p=e.shapeInfo.flatOffset;if(d===r&&null==p)return t?"\n      float ".concat(s,"(int row, int col, int depth) {\n        int stride1 = ").concat(a,"Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n        float ".concat(s,"(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(").concat(i,", 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(").concat(d,".0, ").concat(h,".0);\n          return sampleTexture(").concat(a,", uv);\n        }\n      ");if(d===i&&null==p)return t?"\n      float ".concat(s,"(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(").concat(a,"Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n    float ".concat(s,"(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(").concat(n[1],", 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(d,".0, ").concat(h,".0);\n      return sampleTexture(").concat(a,", uv);\n    }\n  ");const f=VW(a);if(t)return"\n    float ".concat(s,"(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ").concat(a,"Shape[1] * ").concat(a,"Shape[2];\n      int stride1 = ").concat(a,"Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ").concat(f,";\n      vec2 uv = uvFromFlat(").concat(a,"TexShape[0], ").concat(a,"TexShape[1], index);\n      return sampleTexture(").concat(a,", uv);\n    }\n    ");return"\n      float ".concat(s,"(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ").concat(r," + col * ").concat(i," + depth + ").concat(f,";\n        vec2 uv = uvFromFlat(").concat(h,", ").concat(d,", index);\n        return sampleTexture(").concat(a,", uv);\n      }\n  ")}(e,t);case 4:return function(e,t){const n=e.shapeInfo.logicalShape,a=e.name,s="get"+a.charAt(0).toUpperCase()+a.slice(1),r=n[3],i=n[2]*r,o=n[1]*i,{newShape:c,keptDims:l}=Ru(n);if(c.length<n.length){const n=qW(e,c),a=["row","col","depth","depth2"];return"\n      ".concat(FW(n,t),"\n      float ").concat(s,"(int row, int col, int depth, int depth2) {\n        return ").concat(s,"(").concat(KW(a,l),");\n      }\n    ")}if(e.shapeInfo.isUniform)return"\n      float ".concat(s,"(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(").concat(o,", ").concat(i,", ").concat(r,", 1)));\n        ").concat(UW(e),"\n      }\n    ");const u=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,d=h[0],p=h[1],f="int stride2 = ".concat(a,"Shape[3];"),m="int stride1 = ".concat(a,"Shape[2] * stride2;"),g="int stride0 = ".concat(a,"Shape[1] * stride1;");if(p===o&&null==u)return t?"\n      float ".concat(s,"(int row, int col, int depth, int depth2) {\n        ").concat(f,"\n        ").concat(m,"\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n      float ".concat(s,"(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(").concat(i,", ").concat(r,", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(p,".0, ").concat(d,".0);\n        return sampleTexture(").concat(a,", uv);\n      }\n    ");if(p===r&&null==u)return t?"\n      float ".concat(s,"(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(").concat(a,"Shape[1] * ").concat(a,"Shape[2], ").concat(a,"Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n      float ".concat(s,"(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(").concat(n[1]*n[2],", ").concat(n[2],", 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(p,".0, ").concat(d,".0);\n        return sampleTexture(").concat(a,", uv);\n      }\n    ");const y=VW(a);if(t)return"\n    float ".concat(s,"(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ").concat(f,"\n      ").concat(m,"\n      ").concat(g,"\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(").concat(a,"TexShape[0], ").concat(a,"TexShape[1], index + ").concat(y,");\n      return sampleTexture(").concat(a,", uv);\n    }\n  ");return"\n    float ".concat(s,"(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(o," + col * ").concat(i," +\n          depth * ").concat(r," + depth2;\n      vec2 uv = uvFromFlat(").concat(d,", ").concat(p,", index + ").concat(y,");\n      return sampleTexture(").concat(a,", uv);\n    }\n  ")}(e,t);case 5:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),s=t[4],r=t[3]*s,i=t[2]*r,o=t[1]*i,{newShape:c,keptDims:l}=Ru(t);if(c.length<t.length){const t=qW(e,c),n=["row","col","depth","depth2","depth3"];return"\n      ".concat(FW(t),"\n      float ").concat(a,"(int row, int col, int depth, int depth2, int depth3) {\n        return ").concat(a,"(").concat(KW(n,l),");\n      }\n    ")}if(e.shapeInfo.isUniform)return"\n      float ".concat(a,"(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(o,", ").concat(i,", ").concat(r,", ").concat(s,")) +\n          depth3;\n        ").concat(UW(e),"\n      }\n    ");const u=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,d=h[0],p=h[1];if(p===o&&null==u)return"\n      float ".concat(a,"(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(").concat(i,", ").concat(r,", ").concat(s,", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(p,".0, ").concat(d,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");if(p===s&&null==u)return"\n      float ".concat(a,"(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(t[1]*t[2]*t[3],",\n               ").concat(t[2]*t[3],", ").concat(t[3],", 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(p,".0, ").concat(d,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");const f=VW(n);return"\n    float ".concat(a,"(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(o," + col * ").concat(i," + depth * ").concat(r," +\n          depth2 * ").concat(s," + depth3 + ").concat(f,";\n      vec2 uv = uvFromFlat(").concat(d,", ").concat(p,", index);\n      return sampleTexture(").concat(n,", uv);\n    }\n  ")}(e);case 6:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:s,keptDims:r}=Ru(t);if(s.length<t.length){const t=qW(e,s),n=["row","col","depth","depth2","depth3","depth4"];return"\n      ".concat(FW(t),"\n      float ").concat(a,"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ").concat(a,"(").concat(KW(n,r),");\n      }\n    ")}const i=t[5],o=t[4]*i,c=t[3]*o,l=t[2]*c,u=t[1]*l;if(e.shapeInfo.isUniform)return"\n      float ".concat(a,"(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(u,", ").concat(l,", ").concat(c,", ").concat(o,")) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(").concat(i,", 1)));\n        ").concat(UW(e),"\n      }\n    ");const h=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,p=d[0],f=d[1];if(f===u&&null==h)return"\n      float ".concat(a,"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(").concat(l,", ").concat(c,", ").concat(o,", ").concat(i,")) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(f,".0, ").concat(p,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");if(f===i&&null==h)return"\n      float ".concat(a,"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(").concat(t[1]*t[2]*t[3]*t[4],",\n               ").concat(t[2]*t[3]*t[4],",\n               ").concat(t[3]*t[4],",\n               ").concat(t[4],")) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(f,".0, ").concat(p,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");const m=VW(n);return"\n    float ".concat(a,"(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(u," + col * ").concat(l," + depth * ").concat(c," +\n          depth2 * ").concat(o," + depth3 * ").concat(i," + depth4 + ").concat(m,";\n      vec2 uv = uvFromFlat(").concat(p,", ").concat(f,", index);\n      return sampleTexture(").concat(n,", uv);\n    }\n  ")}(e);default:throw new Error("".concat(n.length,"-D input sampling")+" is not yet supported")}}function LW(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return function(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),a=EW();return"\n    vec4 ".concat(n,"() {\n      return ").concat(a.texture2D,"(").concat(t,", halfCR);\n    }\n  ")}(e);case 1:return function(e,t){const n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e.shapeInfo.texShape,r=EW();if(t)return"\n    vec4 ".concat(a,"(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(n,"TexShape[0]) / 2.0), ceil(float(").concat(n,"TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ").concat(r.texture2D,"(").concat(n,", uv);\n    }\n  ");const i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return"\n    vec4 ".concat(a,"(int index) {\n      vec2 uv = packedUVfrom1D(\n        ").concat(i[0],", ").concat(i[1],", index);\n      return ").concat(r.texture2D,"(").concat(n,", uv);\n    }\n  ")}(e,t);case 2:return function(e,t){const n=e.shapeInfo.logicalShape,a=e.name,s="get"+a.charAt(0).toUpperCase()+a.slice(1),r=e.shapeInfo.texShape,i=r[0],o=r[1],c=EW();if(null!=r&&ku(n,r))return t?"\n      vec4 ".concat(s,"(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n\n        return ").concat(c.texture2D,"(").concat(a,", uv);\n      }\n    "):"\n      vec4 ".concat(s,"(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(o,".0, ").concat(i,".0);\n\n        return ").concat(c.texture2D,"(").concat(a,", uv);\n      }\n    ");if(t)return"\n    vec4 ".concat(s,"(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(a,"TexShape[0]) / 2.0), ceil(float(").concat(a,"TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(").concat(a,"Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ").concat(c.texture2D,"(").concat(a,", uv);\n    }\n  ");const l=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)],u=Math.ceil(n[1]/2);return"\n    vec4 ".concat(s,"(int row, int col) {\n      vec2 uv = packedUVfrom2D(").concat(u,", ").concat(l[0],", ").concat(l[1],", row, col);\n      return ").concat(c.texture2D,"(").concat(a,", uv);\n    }\n  ")}(e,t);case 3:return function(e,t){const n=e.shapeInfo.logicalShape,a=e.name,s="get"+a.charAt(0).toUpperCase()+a.slice(1),r=e.shapeInfo.texShape,i=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];if(1===n[0]){const a=[1,2],r=qW(e,n.slice(1)),i=["b","row","col"];return"\n        ".concat(LW(r,t),"\n        vec4 ").concat(s,"(int b, int row, int col) {\n          return ").concat(s,"(").concat(KW(i,a),");\n        }\n      ")}const o=EW();if(t)return"\n    vec4 ".concat(s,"(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(a,"TexShape[0]) / 2.0), ceil(float(").concat(a,"TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(").concat(a,"Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(").concat(a,"Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ").concat(o.texture2D,"(").concat(a,", uv);\n    }\n  ");const c=i[0],l=i[1],u=Math.ceil(n[2]/2),h=u*Math.ceil(n[1]/2);return"\n    vec4 ".concat(s,"(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ").concat(c,", ").concat(l,", ").concat(h,", ").concat(u,", b, row, col);\n      return ").concat(o.texture2D,"(").concat(a,", uv);\n    }\n  ")}(e,t);default:return function(e,t){const n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),s=EW();if(t)return"\n    vec4 ".concat(a,"(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(").concat(n,"Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(").concat(n,"Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ").concat(n,"Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(n,"TexShape[0]) / 2.0), ceil(float(").concat(n,"TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ").concat(s.texture2D,"(").concat(n,", uv);\n    }\n  ");const r=e.shapeInfo.logicalShape,i=r.length,o=e.shapeInfo.texShape,c=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],l=c[0],u=c[1],h=Math.ceil(r[i-1]/2);let d=h*Math.ceil(r[i-2]/2),p="int b, int row, int col",f="b * ".concat(d," + (row / 2) * ").concat(h," + (col / 2)");for(let m=2;m<i-1;m++)p="int b".concat(m,", ")+p,d*=r[i-m-1],f="b".concat(m," * ").concat(d," + ")+f;return"\n    vec4 ".concat(a,"(").concat(p,") {\n      int index = ").concat(f,";\n      int texR = index / ").concat(u,";\n      int texC = index - texR * ").concat(u,";\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(u,", ").concat(l,");\n      return ").concat(s.texture2D,"(").concat(n,", uv);\n    }\n  ")}(e,t)}}const zW="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",BW="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",jW="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",WW="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function VW(e){return"offset".concat(e)}function UW(e){const t=e.name,n=vu(e.shapeInfo.logicalShape);return n<2?"return ".concat(t,";"):"\n    for (int i = 0; i < ".concat(n,"; i++) {\n      if (i == index) {\n        return ").concat(t,"[i];\n      }\n    }\n  ")}function HW(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error("GPU for rank ".concat(e," is not yet supported"))}function GW(e,t,n){const{newShape:a,keptDims:s}=Ru(t),r=t.length,i=e&&3===r&&1===t[0],o=i?t.slice(1):a,c=!e&&r>1&&!ku(t,n)&&a.length<r||i;return{useSqueezeShape:c,uniformShape:c?o:t,keptDims:s}}function qW(e,t){const n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function KW(e,t){return t.map(t=>e[t]).join(", ")}function XW(e,t,n,a){const s=n.map((e,n)=>{const a={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:!e.isUniform&&e.texData.isPacked,flatOffset:null};return null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0&&(a.flatOffset=e.texData.slice.flatOffset),{name:t.variableNames[n],shapeInfo:a}}),r=s.map(e=>e.shapeInfo),i={logicalShape:a.shape,texShape:a.texData.texShape,isUniform:!1,isPacked:a.texData.isPacked,flatOffset:null},o=OW(s,i,t),c=function(e,t){const n=pW(e,()=>e.createShader(e.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(nW(e,()=>e.shaderSource(n,t)),nW(e,()=>e.compileShader(n)),$u().get("ENGINE_COMPILE_ONLY"))return n;if(!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw iW(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}(e.gl,o),l=e.createProgram(c);return $u().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:c,source:o,webGLProgram:l,inShapeInfos:r,outShapeInfo:i,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(e.buildVao(l),Object.assign({program:t,fragmentShader:c,source:o,webGLProgram:l,inShapeInfos:r,outShapeInfo:i},YW(e,t,l)))}function YW(e,t,n){const a=[],s=[];let r,i,o,c=null,l=null;l=e.getUniformLocation(n,"NAN",!1),1===$u().getNumber("WEBGL_VERSION")&&(c=e.getUniformLocation(n,"INFINITY",!1));const u=!1;for(const h of t.variableNames){const s={name:h,uniform:e.getUniformLocation(n,h,u),offset:e.getUniformLocation(n,"offset".concat(h),u)};t.enableShapeUniforms&&(s.shape=e.getUniformLocation(n,"".concat(h,"Shape"),u),s.texShape=e.getUniformLocation(n,"".concat(h,"TexShape"),u)),a.push(s)}if(t.enableShapeUniforms&&(r=e.getUniformLocation(n,"outShape",u),o=e.getUniformLocation(n,"outShapeStrides",u),i=e.getUniformLocation(n,"outTexShape",u)),t.customUniforms)for(const h of t.customUniforms)s.push(e.getUniformLocation(n,h.name,u));return{variablesLocations:a,customUniformLocations:s,infLoc:c,nanLoc:l,outShapeLocation:r,outShapeStridesLocation:o,outTexShapeLocation:i}}function QW(e,t){if(e.length!==t.length)throw Error("Binary was compiled with ".concat(e.length," inputs, but ")+"was executed with ".concat(t.length," inputs"));e.forEach((e,n)=>{const a=e.logicalShape,s=t[n],r=s.shape;if(!ku(a,r))throw Error("Binary was compiled with different shapes than "+"the current args. Shapes ".concat(a," and ").concat(r," must match"));if(e.isUniform&&s.isUniform)return;const i=e.texShape,o=s.isUniform?null:s.texData.texShape;if(!ku(i,o))throw Error("Binary was compiled with different texture shapes than the"+" current args. Shape ".concat(i," and ").concat(o," must match"))})}function ZW(e){return $u().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}class JW{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=Yj.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=EW();this.outputShape=e,this.enableShapeUniforms=ZW(this.outputShape.length),this.userCode="\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ".concat(this.enableShapeUniforms?_W(["r","c","d"],e):RW(["r","c","d"],e),"\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ").concat(t.output," = result;\n      }\n    ")}}class $W{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=Yj.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=EW();this.outputShape=e,this.enableShapeUniforms=ZW(this.outputShape.length),this.userCode="\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ".concat(this.enableShapeUniforms?_W(["r","c","d"],e):RW(["r","c","d"],e),"\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ").concat(t.output," = result;\n      }\n    ")}}class eV{constructor(e){this.variableNames=["A"],this.outTexUsage=Qj.DOWNLOAD;const t=EW();this.outputShape=e,this.userCode="\n      ".concat(PW,"\n\n      void main() {\n        float x = getAAtOutCoords();\n        ").concat(t.output," = encode_float(x);\n      }\n    ")}}class tV{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=Qj.DOWNLOAD;const t=EW();this.outputShape=e,this.userCode="\n      ".concat(PW,"\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ").concat(t.output," = encode_float(x);\n      }\n    ")}}const nV={R:0,G:1,B:2,A:3};class aV{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"RGBA";this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const a=EW();this.outputShape=e,this.enableShapeUniforms=ZW(this.outputShape.length);let s="result";t&&(s="floor(result * 255. + 0.5)");let r="";for(let i=0;i<n.length;i++){const e=n[i];r+="\n          if(offset == ".concat(i,") {\n            result = values[").concat(nV[e],"];\n          }")}this.userCode="\n      ".concat(this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":MW(e),"\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ").concat(n.length,");\n\n        flatIndex = idiv(flatIndex, ").concat(n.length,", 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ").concat(a.texture2D,"(A, uv);\n          ").concat(r,"\n        }\n        ").concat(a.output," = vec4(").concat(s,", 0., 0., 0.);\n      }\n    ")}}class sV{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=EW();this.outputShape=e,this.enableShapeUniforms=ZW(this.outputShape.length);let a="",s="result";t&&(s="floor(result * 255. + 0.5)");for(let r=0;r<=1;r++)for(let t=0;t<=1;t++){const s=2*r+t;a+="\n          localCoords = coords;\n          if(localCoords[2] + ".concat(t," < ").concat(this.enableShapeUniforms?"outShape[2]":"".concat(e[2]),") {\n          localCoords[2] += ").concat(t,";\n          if (localCoords[1] + ").concat(r," < ").concat(this.enableShapeUniforms?"outShape[1]":"".concat(e[1]),") {\n            localCoords[1] += ").concat(r,";\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ").concat(n.texture2D,"(A, uv);\n\n            if (offset == 0) {\n              result[").concat(s,"] = values[0];\n            } else if (offset == 1) {\n              result[").concat(s,"] = values[1];\n            } else if (offset == 2) {\n              result[").concat(s,"] = values[2];\n            } else {\n              result[").concat(s,"] = values[3];\n            }\n          }\n        }\n        ")}this.userCode="\n        ".concat(this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":MW(e),"\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ").concat(a,"\n\n          ").concat(n.output," = ").concat(s,";\n        }\n    ")}}function rV(e){const t=EW();return function(e,t){const n=pW(e,()=>e.createShader(e.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(nW(e,()=>e.shaderSource(n,t)),nW(e,()=>e.compileShader(n)),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}(e,"".concat(t.version,"\n    precision highp float;\n    ").concat(t.attribute," vec3 clipSpacePos;\n    ").concat(t.attribute," vec2 uv;\n    ").concat(t.varyingVs," vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }"))}function iV(e){return function(e,t){const n=pW(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return nW(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),nW(e,()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW)),n}(e,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function oV(e){return function(e,t){const n=pW(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return nW(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n)),nW(e,()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW)),n}(e,new Uint16Array([0,1,2,2,1,3]))}function cV(e,t,n,a,s,r){!function(e,t){const n=$u().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0){const n="[".concat(e,"x").concat(t,"]");throw new Error("Requested texture size "+n+" is invalid.")}if(e>n||t>n){const a="[".concat(e,"x").concat(t,"]"),s="[".concat(n,"x").concat(n,"]");throw new Error("Requested texture size "+a+" greater than WebGL maximum on this browser / GPU "+s+".")}}(t,n);const i=function(e){return pW(e,()=>e.createTexture(),"Unable to create WebGLTexture.")}(e),o=e.TEXTURE_2D;return nW(e,()=>e.bindTexture(o,i)),nW(e,()=>e.texParameteri(o,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE)),nW(e,()=>e.texParameteri(o,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE)),nW(e,()=>e.texParameteri(o,e.TEXTURE_MIN_FILTER,e.NEAREST)),nW(e,()=>e.texParameteri(o,e.TEXTURE_MAG_FILTER,e.NEAREST)),1===$u().getNumber("WEBGL_VERSION")?nW(e,()=>e.texImage2D(o,0,a,t,n,0,s,r,null)):nW(e,()=>e.texStorage2D(o,1,a,t,n)),nW(e,()=>e.bindTexture(e.TEXTURE_2D,null)),{texture:i,texShape:[n,t]}}function lV(e){return e.internalFormatFloat}function uV(e){return e.internalFormatHalfFloat}function hV(e){return e.downloadTextureFormat}function dV(e){return e.internalFormatPackedFloat}function pV(e){return e.internalFormatPackedHalfFloat}function fV(e,t,n,a,s,r,i,o){const c=e,l=new Float32Array(function(e,t){const[n,a]=eW(e,t);return n*a*4}(r,i));return c.bindBuffer(c.PIXEL_PACK_BUFFER,t),c.getBufferSubData(c.PIXEL_PACK_BUFFER,0,l),c.bindBuffer(c.PIXEL_PACK_BUFFER,null),l}class mV{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const t=$u().getNumber("WEBGL_VERSION");if(null!=e?(this.gl=e,function(e,t){qj[e]=t}(t,e)):this.gl=Xj(t),e=this.gl,2===$u().getNumber("WEBGL_VERSION")){const t=e;this.createVertexArray=()=>nW(t,()=>t.createVertexArray()),this.bindVertexArray=e=>nW(t,()=>t.bindVertexArray(e)),this.deleteVertexArray=e=>nW(t,()=>t.deleteVertexArray(e)),this.getVertexArray=()=>nW(t,()=>t.getParameter(t.VERTEX_ARRAY_BINDING))}else if(null!=e){const t=e.getExtension("OES_vertex_array_object");if(null==t)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>nW(e,()=>t.createVertexArrayOES()),this.bindVertexArray=n=>nW(e,()=>t.bindVertexArrayOES(n)),this.deleteVertexArray=n=>nW(e,()=>t.deleteVertexArrayOES(n)),this.getVertexArray=()=>nW(e,()=>e.getParameter(t.VERTEX_ARRAY_BINDING_OES))}let n="WEBGL_color_buffer_float";const a="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===$u().getNumber("WEBGL_VERSION")){const e="OES_texture_float",t="OES_texture_half_float";if(this.textureFloatExtension=sW(this.gl,e),kW(this.gl,t))this.textureHalfFloatExtension=sW(this.gl,t);else if($u().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),kW(this.gl,a))this.colorBufferHalfFloatExtension=sW(this.gl,a);else if($u().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",kW(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!kW(this.gl,a))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(a)}this.vertexBuffer=iV(this.gl),this.indexBuffer=oV(this.gl),this.framebuffer=function(e){return pW(e,()=>e.createFramebuffer(),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=tW(this.gl,this.textureHalfFloatExtension)}get debug(){return $u().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;nW(e,()=>e.finish()),nW(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),nW(e,()=>e.deleteFramebuffer(this.framebuffer)),nW(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),nW(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),nW(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,a){const[s,r]=Jj(t,n);return cV(e,s,r,lV(a),a.textureFormatFloat,e.FLOAT)}(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,a){const[s,r]=Jj(t,n);return cV(e,s,r,uV(a),a.textureFormatFloat,a.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,a){const[s,r]=Jj(t,n);return cV(e,s,r,hV(a),e.RGBA,e.UNSIGNED_BYTE)}(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),function(e,t,n){nW(e,()=>e.bindTexture(e.TEXTURE_2D,t)),n.data instanceof Uint8Array?2===$u().getNumber("WEBGL_VERSION")?nW(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data)):nW(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data)):2===$u().getNumber("WEBGL_VERSION")?nW(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n)):nW(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n)),nW(e,()=>e.bindTexture(e.TEXTURE_2D,null))}(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,a){this.throwIfDisposed(),function(e,t,n,a,s,r){let i,o,c;nW(e,()=>e.bindTexture(e.TEXTURE_2D,t)),s instanceof Uint8Array?(i=new Uint8Array(n*a*4),o=e.UNSIGNED_BYTE,c=e.RGBA):(i=new Float32Array(n*a*4),o=e.FLOAT,c=r.internalFormatPackedFloat),i.set(s),2===$u().getNumber("WEBGL_VERSION")?nW(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,a,e.RGBA,o,i)):nW(e,()=>e.texImage2D(e.TEXTURE_2D,0,c,n,a,0,e.RGBA,o,i)),nW(e,()=>e.bindTexture(e.TEXTURE_2D,null))}(this.gl,e,t,n,a,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,a){const[s,r]=eW(t,n);return cV(e,s,r,pV(a),e.RGBA,a.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,a){const[s,r]=eW(t,n);return cV(e,s,r,dV(a),e.RGBA,e.FLOAT)}(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(hW(this.gl,this.framebuffer),this.outputTexture=null),nW(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,()=>function(e,t,n,a){const[s,r]=Jj(t,n),i=new Uint8Array(t*n*4);return nW(e,()=>e.readPixels(0,0,s,r,a.downloadTextureFormat,e.UNSIGNED_BYTE,i)),new Float32Array(i.buffer)}(this.gl,t,n,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,n,a,s,r){return fV(this.gl,e,0,0,0,s,r,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return function(e,t,n){const a=e,s=new Float32Array(n);return a.bindBuffer(a.PIXEL_PACK_BUFFER,t),a.getBufferSubData(a.PIXEL_PACK_BUFFER,0,s),a.bindBuffer(a.PIXEL_PACK_BUFFER,null),s}(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);const a=function(e,t,n){const a=e.createBuffer();nW(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,a));const s=16*t*n;return nW(e,()=>e.bufferData(e.PIXEL_PACK_BUFFER,s,e.STREAM_READ)),nW(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0)),nW(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null)),a}(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),a}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if($u().getBool("WEBGL_FENCE_API_ENABLED")){const a=e,s=a.fenceSync(a.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{const e=a.clientWaitSync(s,0,0);return e===a.ALREADY_SIGNALED||e===a.CONDITION_SATISFIED},t=s}else $u().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,$u().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,()=>function(e,t,n){const a=new Float32Array(t*n*4);return nW(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,a)),a}(this.gl,t,n))}createProgram(e){this.throwIfDisposed();const t=this.gl;null==this.vertexShader&&(this.vertexShader=rV(t));const n=function(e){return pW(e,()=>e.createProgram(),"Unable to create WebGLProgram.")}(t);nW(t,()=>t.attachShader(n,this.vertexShader)),nW(t,()=>t.attachShader(n,e)),function(e,t){if(nW(e,()=>e.linkProgram(t)),!$u().get("ENGINE_COMPILE_ONLY")&&!1===e.getProgramParameter(t,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}(t,n);const a=Object.assign(n,{vao:this.createVertexArray()});return this.debug&&oW(t,a),a}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);const t=this.gl;nW(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),function(e,t,n){nW(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),cW(e,t,"clipSpacePos",n,3,20,0)&&cW(e,t,"uv",n,2,20,12)}(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&(nW(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,null!=this.program&&this.debug&&oW(this.gl,this.program),nW(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];return this.throwIfDisposed(),n?function(e,t,n){return pW(e,()=>e.getUniformLocation(t,n),'uniform "'+n+'" not present in program.')}(this.gl,e,t):function(e,t,n){return e.getUniformLocation(t,n)}(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),nW(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),lW(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();const[a,s]=eW(t,n);this.setOutputMatrixTextureDriver(e,a,s)}setOutputMatrixWriteRegion(e,t,n,a){this.setOutputMatrixWriteRegionDriver(n,e,a,t)}setOutputPackedMatrixWriteRegion(e,t,n,a){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&oW(this.gl,this.program),dW(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}nW(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),nW(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=sW(this.gl,2===$u().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===$u().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2(),n=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,n),n}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(2===$u().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2();return void e.endQuery(t.TIME_ELAPSED_EXT)}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await Nu(()=>this.disposed||this.isQueryAvailable(e,$u().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,$u().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(0===t)return null;if(2===t){const t=this.gl;return t.getQueryParameter(e,t.QUERY_RESULT)/1e6}{const t=this.getQueryTimerExtensionWebGL1();return t.getQueryObjectEXT(e,t.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(0===t)return!0;if(2===t){const t=this.gl,n=this.getQueryTimerExtensionWebGL2(),a=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),a&&!this.disjoint}{const t=this.getQueryTimerExtensionWebGL1(),n=t.getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){const e=function(e){let t=0;for(;t<e.length;++t){if(!e[t]())break}return t-1}(this.itemsToPoll.map(e=>e.isDoneFn));for(let t=0;t<=e;++t){const{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let n;"setTimeoutCustom"in $u().platform&&(n=$u().platform.setTimeoutCustom.bind($u().platform)),Nu(()=>(this.pollItems(),0===this.itemsToPoll.length),()=>0,null,n)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),uW(this.gl,e,this.framebuffer),this.debug&&dW(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(uW(this.gl,this.outputTexture,this.framebuffer),this.debug&&dW(this.gl)):hW(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();const a=this.gl;uW(a,e,this.framebuffer),this.debug&&dW(a),this.outputTexture=e,nW(a,()=>a.viewport(0,0,t,n)),nW(a,()=>a.scissor(0,0,t,n))}setOutputMatrixWriteRegionDriver(e,t,n,a){this.throwIfDisposed(),nW(this.gl,()=>this.gl.scissor(e,t,n,a))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{mx:gV,XI:yV,Nk:bV,f6:xV,ct:vV,YG:wV,hH:kV,z3:SV,sG:CV,uM:IV,vS:NV,qB:TV,GG:EV,rq:RV,lg:_V,WR:AV,cu:MV,GE:PV,px:DV,jC:OV,He:FV,hE:LV,BF:zV,Dk:BV,cl:jV,_B:WV,ub:VV,_f:UV,Ku:HV,qy:GV,Zy:qV,bu:KV,zv:XV,dH:YV,HS:QV,yH:ZV,l3:JV,z9:$V,x6:eU,_m:tU,eW:nU,GK:aU,SP:sU,yr:rU,dl:iU,Dw:oU,xT:cU,_X:lU,wz:uU}=N;function hU(e,t){return["x","y","z","w","u","v"].slice(0,t).map(t=>"".concat(e,".").concat(t))}function dU(e,t){return 1===t?[e]:hU(e,t)}class pU{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=ZW(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const e=dU("rc",this.rank),t=HW(this.rank),n=this.getOutOfBoundsCondition(e),a=this.getSetup(e),s=this.getOutput(e);this.userCode="\n        void main() {\n          ".concat(t," rc = getOutputCoords();\n\n          if(").concat(n,") {\n            setOutput(vec4(0));\n          } else {\n            ").concat(a,"\n\n            setOutput(vec4(").concat(s,"));\n          }\n        }\n      ")}}getSourceCoordsArr(e){const t=[];for(let n=0;n<=1;n++)for(let a=0;a<=1;a++){let s="".concat(0===n?"r":"rp1",", ").concat(0===a?"c":"cp1");for(let t=2;t<this.rank;t++)s="".concat(e[e.length-1-t],",")+s;t.push(s)}return t}getOutOfBoundsCondition(e){if(1===this.rank)return"rc > ".concat(this.enableShapeUniforms?"outShape":this.outputShape[0]);let t="";for(let n=this.rank-2;n<this.rank;n++)t+="".concat(e[n]," >= ").concat(this.enableShapeUniforms?"outShape[".concat(n,"]"):this.outputShape[n]),n<this.rank-1&&(t+="||");return t}getSetup(e){if(1===this.rank)return"";const t=e.slice(-2),n=this.enableShapeUniforms?"outShape[".concat(this.rank," - 1]"):this.outputShape[this.rank-1],a=this.enableShapeUniforms?"outShape[".concat(this.rank," - 2]"):this.outputShape[this.rank-2];return"\n      int r = ".concat(t[0],";\n      int c = ").concat(t[1],";\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ").concat(n,";\n      bool rEdge = rp1 >= ").concat(a,";\n    ")}getOutput(e){const t=this.getSourceCoordsArr(e);if(1===this.rank){const e=this.enableShapeUniforms?"outShape":this.outputShape[0];return"getA(rc), (rc + 1 >= ".concat(e," ? 0. : getA(rc + 1)), 0, 0")}return"getA(".concat(t[0],"),\n            cEdge ? 0. : getA(").concat(t[1],"),\n            rEdge ? 0. : getA(").concat(t[2],"),\n            rEdge || cEdge ? 0. : getA(").concat(t[3],")")}}class fU{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=ZW(this.outputShape.length);let n="";for(let a=0;a<4;a++){let e="thisRC = rc;";a%2===1&&(e+="thisRC.z += 1;"),a>1&&(e+="thisRC.y += 1;"),n+="\n        ".concat(e,"\n        ").concat(a>0?"if(thisRC.y < rows && thisRC.z < cols){":"","\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[").concat(a,"] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ").concat(a>0?"}":"","\n      ")}this.userCode="\n      ".concat(function(e,t){const n=t?AW(["r","c","d"],"inputShape"):RW(["r","c","d"],e);return"\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ".concat(n,"\n      return ivec3(r, c, d);\n    }\n  ")}(t,this.enableShapeUniforms),"\n      ").concat(this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":MW(e),"\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ").concat(this.enableShapeUniforms?"outShape[1]":e[1],";\n        int cols = ").concat(this.enableShapeUniforms?"outShape[2]":e[2],";\n\n        ").concat(n,"\n\n        setOutput(result);\n      }\n    ")}}class mU{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,n){const a=yU(t,n),s=bU(e,a,n);s in this.freeTextures||(this.freeTextures[s]=[]),s in this.usedTextures||(this.usedTextures[s]=[]);const r=gU(e,a,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[s].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=r,this.log();const e=this.freeTextures[s].pop();return this.usedTextures[s].push(e),e}let i;return a===Zj.PACKED_2X2_FLOAT32?i=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):a===Zj.PACKED_2X2_FLOAT16?i=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):a===Zj.UNPACKED_FLOAT32?i=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):a===Zj.UNPACKED_FLOAT16?i=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):a===Zj.PACKED_4X1_UNSIGNED_BYTE&&(i=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[s].push(i),this.numUsedTextures++,this._numBytesAllocated+=r,this.log(),i}releaseTexture(e,t,n,a){if(null==this.freeTextures)return;const s=yU(n,a),r=bU(t,s,a);r in this.freeTextures||(this.freeTextures[r]=[]);const i=gU(t,s,this.gpgpu.gl,this.gpgpu.textureConfig,a),o=$u().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==o&&this._numBytesAllocated>o?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=i):(this.freeTextures[r].push(e),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;const c=this.usedTextures[r],l=c&&c.indexOf(e);if(null==l||l<0)throw new Error("Cannot release a texture that was never provided by this texture manager");c[l]=c[c.length-1],c.pop(),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used","".concat(this.numFreeTextures," / ").concat(this.numUsedTextures),"(".concat(e,")"));const t=this._numBytesFree/this._numBytesAllocated;console.log("Bytes allocated: ".concat(this._numBytesAllocated)),console.log("Bytes unused: ".concat(this._numBytesFree," (").concat(Math.round(100*t),"%)"))}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const e in this.freeTextures)this.freeTextures[e].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});for(const e in this.usedTextures)this.usedTextures[e].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function gU(e,t,n,a,s){const r=function(e,t){switch(e){case Zj.PACKED_2X2_FLOAT32:return dV(t);case Zj.PACKED_2X2_FLOAT16:return pV(t);case Zj.UNPACKED_FLOAT32:return lV(t);case Zj.UNPACKED_FLOAT16:return uV(t);case Zj.PACKED_4X1_UNSIGNED_BYTE:return hV(t);default:throw new Error("Unknown physical texture type ".concat(e))}}(t,a);let i;if(s){const[t,n]=eW(e[0],e[1]);i=t*n}else{const[t,n]=Jj(e[0],e[1]);i=t*n}const o=function(e,t){const n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error("Unknown internal format ".concat(t))}(n,r);return i*o}function yU(e,t){if(e===Qj.UPLOAD)return Zj.PACKED_2X2_FLOAT32;if(e===Qj.RENDER||null==e)return function(e){return $u().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?Zj.PACKED_2X2_FLOAT32:Zj.UNPACKED_FLOAT32:e?Zj.PACKED_2X2_FLOAT16:Zj.UNPACKED_FLOAT16}(t);if(e===Qj.DOWNLOAD||e===Qj.PIXELS)return Zj.PACKED_4X1_UNSIGNED_BYTE;throw new Error("Unknown logical texture type ".concat(e))}function bU(e,t,n){return"".concat(e[0],"_").concat(e[1],"_").concat(t,"_").concat(n)}class xU{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=ZW(this.outputShape.length),this.userCode="\n      float unaryOperation(float x) {\n        ".concat(t,"\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ")}}const vU="if (isnan(x)) return x;",wU="return abs(x);";const kU=vU+"\n  return (x < 0.0) ? 0.0 : x;\n",SU=vU+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",CU="return x;";class IU{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=ZW(this.outputShape.length),this.userCode="\n      vec4 unaryOperation(vec4 x) {\n        ".concat(t,"\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ")}}class NU{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=ZW(this.outputShape.length);const t=e.length,n=dU("rc",t),a=HW(t),s=function(e,t){if(1===e)return"rc";let n="";for(let a=0;a<e;a++)n+=t[a],a<e-1&&(n+=",");return n}(t,n),r=n.slice(-2),i=t<=1?"rc":"vec2(".concat(r.join(","),")");this.userCode="\n      void main() {\n        ".concat(a," rc = getOutputCoords();\n        vec4 packedInput = getA(").concat(s,");\n\n        setOutput(getChannel(packedInput, ").concat(i,"));\n      }\n    ")}}const TU=kk,EU={};const RU=$u().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");class _U extends uu{nextDataId(){return _U.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!$u().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(null!=e){if(e instanceof mV)t=e;else{const n=Xj($u().getNumber("WEBGL_VERSION"),e);t=new mV(n)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const e=Xj($u().getNumber("WEBGL_VERSION"));t=new mV(e),this.binaryCache=((n=$u().getNumber("WEBGL_VERSION"))in EU||(EU[n]={}),EU[n]),this.gpgpuCreatedLocally=!0}var n;this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new mU(this.gpgpu),this.numMBBeforeWarning=null==$u().global.screen?1024:$u().global.screen.height*$u().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new lu(this,Gm())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,n,a,s,r){const i=this.makeTensorInfo(t,n),o=this.texData.get(i.dataId);o.isPacked=!1,o.texture={texture:e,texShape:[a,s]},o.texShape=[a,s];const c=yW(t),l=new aV(c,!1,r),u=this.runWebGLProgram(l,[i],n,[[a,s]]);return u.shape=t,o.texture=null,this.disposeIntermediateTensorInfo(i),u.dataId}write(e,t,n){if(($u().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||$u().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const a={id:this.nextDataId()};return this.texData.set(a,{shape:t,dtype:n,values:e,usage:Qj.UPLOAD,refCount:1}),a}refCount(e){if(this.texData.has(e)){return this.texData.get(e).refCount}return 0}incRef(e){this.texData.get(e).refCount++}decRef(e){if(this.texData.has(e)){this.texData.get(e).refCount--}}move(e,t,n,a,s){if($u().getBool("DEBUG")&&this.checkNumericalProblems(t),"complex64"===a)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:a,values:t,usage:Qj.UPLOAD,refCount:s})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:n,dtype:a,complexTensorInfos:s,slice:r,shape:i,isPacked:o}=t;if(null!=r){let t;t=o?new IU(i,CU):new xU(i,CU);const n=this.runWebGLProgram(t,[{dataId:e,shape:i,dtype:a}],a),s=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),s}if(null!=n)return this.convertAndCacheOnCPU(e);if("string"===a)return n;const c=null!=this.activeTimers;let l,u;if(c&&(l=Uf()),"complex64"===a){u=wC(this.readSync(s.real.dataId),this.readSync(s.imag.dataId))}else u=this.getValuesFromTexture(e);return c&&(this.downloadWaitMs+=Uf()-l),this.convertAndCacheOnCPU(e,u)}async read(e){if(this.pendingRead.has(e)){const t=this.pendingRead.get(e);return new Promise(e=>t.push(e))}const t=this.texData.get(e),{values:n,shape:a,slice:s,dtype:r,complexTensorInfos:i,isPacked:o}=t;if(null!=s){let t;t=o?new IU(a,CU):new xU(a,CU);const n=this.runWebGLProgram(t,[{dataId:e,shape:a,dtype:r}],r),s=this.read(n.dataId);return this.disposeIntermediateTensorInfo(n),s}if(null!=n)return this.convertAndCacheOnCPU(e);if($u().getBool("DEBUG")&&!$u().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===$u().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let c,l,u=null;if("complex64"!==r&&$u().get("WEBGL_BUFFER_SUPPORTED")){c=this.decode(e);const t=this.texData.get(c.dataId);u=this.gpgpu.createBufferFromTexture(t.texture.texture,...$j(a))}if(this.pendingRead.set(e,[]),"complex64"!==r&&await this.gpgpu.createAndWaitForFence(),"complex64"===r){const e=await Promise.all([this.read(i.real.dataId),this.read(i.imag.dataId)]);l=wC(e[0],e[1])}else if(null==u)l=this.getValuesFromTexture(e);else{const e=vu(a);l=this.gpgpu.downloadFloat32MatrixFromBuffer(u,e)}if(null!=c&&this.disposeIntermediateTensorInfo(c),null!=u){const e=this.gpgpu.gl;nW(e,()=>e.deleteBuffer(u))}const h=this.convertAndCacheOnCPU(e,l),d=this.pendingRead.get(e);return this.pendingRead.delete(e),d.forEach(e=>e(h)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&Gm().removeDataId(e,this),this.pendingDeletes--),h}readToGPU(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=this.texData.get(e),{values:a,shape:s,slice:r,dtype:i,isPacked:o,texture:c}=n;if("complex64"===i)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=r){let n;n=o?new IU(s,CU):new xU(s,CU);const a=this.runWebGLProgram(n,[{dataId:e,shape:s,dtype:i}],i),r=this.readToGPU(a,t);return this.disposeIntermediateTensorInfo(a),r}if(null==c)throw null!=a?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const l=this.decode(e,t.customTexShape),u=Gm().makeTensorFromTensorInfo(l),h=this.texData.get(l.dataId);return Object.assign({tensorRef:u},h.texture)}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map(e=>Gf(e));return ty(e.shape,e.dtype,n)}catch(n){throw new Error("Failed to decode encoded string bytes into utf-8")}return ty(e.shape,e.dtype,t)}checkNumericalProblems(e){if(null!=e)for(let t=0;t<e.length;t++){const n=e[t];if(!aW(n)){if($u().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error("The value ".concat(n," cannot be represented with your ")+"current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'");throw Error("The value ".concat(n," cannot be represented on this device."))}}}getValuesFromTexture(e){const{shape:t,dtype:n,isPacked:a}=this.texData.get(e),s=vu(t);if($u().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(e),a=this.texData.get(n.dataId),r=this.gpgpu.downloadMatrixFromPackedTexture(a.texture.texture,...$j(t)).subarray(0,s);return this.disposeIntermediateTensorInfo(n),r}const r=$u().getBool("WEBGL_PACK")&&!0===a,i=r?yW(t):t,o=r?new tV(i):new eV(i),c=this.runWebGLProgram(o,[{shape:i,dtype:n,dataId:e}],"float32"),l=this.texData.get(c.dataId),u=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(l.texture.texture,l.texShape[0],l.texShape[1]).subarray(0,s);return this.disposeIntermediateTensorInfo(c),u}timerAvailable(){return $u().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,n=[];let a=!1;null==this.programTimersStack?(this.programTimersStack=n,a=!0):this.activeTimers.push(n),this.activeTimers=n,e();const s=Kf(this.activeTimers.map(e=>e.query)).filter(e=>null!=e),r=Kf(this.activeTimers.map(e=>e.name)).filter(e=>null!=e);this.activeTimers=t,a&&(this.programTimersStack=null);const i={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if($u().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const e=await Promise.all(s);i.kernelMs=gu(e),i.getExtraProfileInfo=()=>e.map((e,t)=>({name:r[t],ms:e})).map(e=>"".concat(e.name,": ").concat(e.ms)).join(", ")}else i.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,i})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return $u().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:Uf(),endMs:null}}endTimer(e){return $u().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=Uf(),e)}async getQueryTime(e){if($u().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:n}=this.texData.get(e);return null!=n&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:n,texShape:a,usage:s,isPacked:r,slice:i}=this.texData.get(e),o=i&&i.origDataId||e,c=this.dataRefCount.get(o);c>1?this.dataRefCount.set(o,c-1):(this.dataRefCount.delete(o),null!=t&&(this.numBytesInGPU-=this.computeBytes(a,n),this.textureManager.releaseTexture(t,a,s,r)));const l=this.texData.get(e);l.texture=null,l.texShape=null,l.isPacked=!1,l.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:RU;return $u().getBool("WEBGL_CPU_FORWARD")&&e.every(e=>null==this.texData.get(e.dataId).texture&&vu(e.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){gf("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return TU(e.shape,t)}packedUnaryOp(e,t,n){const a=new IU(e.shape,t),s=this.compileAndRun(a,[e],n);return Gm().makeTensorFromTensorInfo(s)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const t=YV(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,t)}if($u().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,wU,e.dtype);const t=new xU(e.shape,wU),n=this.compileAndRun(t,[e]);return Gm().makeTensorFromTensorInfo(n)}makeTensorInfo(e,t,n){let a;if("string"===t&&null!=n&&n.length>0&&Du(n[0])){const s=n.map(e=>Hf(e));a=this.write(s,e,t)}else a=this.write(n,e,t);return this.texData.get(a).usage=null,{dataId:a,shape:e,dtype:t}}makeOutput(e,t,n){return Gm().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,n),this)}unpackTensor(e){const t=new NU(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new pU(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const n=[mW(e.shape),...gW(e.shape)],a={dtype:e.dtype,shape:n,dataId:e.dataId},s=[mW(t),...gW(t)],r=new fU(s,n),i=[n],o=this.runWebGLProgram(r,[a],e.dtype,i,!0);return{dataId:o.dataId,shape:t,dtype:o.dtype}}decode(e,t){const n=this.texData.get(e),{isPacked:a,shape:s,dtype:r}=n;if(null!=t){yu(vu(s)<=t[0]*t[1]*4,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const i=yW(s);let o;o=a?new $W(i):new JW(i);const c=[null!=t?t:$j(i)];return{dtype:r,shape:s,dataId:this.runWebGLProgram(o,[{shape:i,dtype:r,dataId:e}],r,c,!0,t).dataId}}runWebGLProgram(e,t,n,a){let s=arguments.length>4&&void 0!==arguments[4]&&arguments[4],r=arguments.length>5?arguments[5]:void 0;const i=this.makeTensorInfo(e.outputShape,n),o=this.texData.get(i.dataId);if(e.packedOutput&&(o.isPacked=!0),e.outPackingScheme===Yj.DENSE){const t=null!=r?r:$j(e.outputShape);o.texShape=t.map(e=>2*e)}if(null!=e.outTexUsage&&(o.usage=e.outTexUsage),0===vu(i.shape))return o.values=_u(i.dtype,0),i;const c=[],l=t.map(t=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(t.dataId);if(null==n.texture){if(!e.packedInputs&&vu(t.shape)<=$u().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:t.shape,texData:null,isUniform:!0,uniformValues:n.values};e.packedInputs&&(n.isPacked=!0,n.shape=t.shape)}if(this.uploadToGPU(t.dataId),!!n.isPacked!==!!e.packedInputs)t=n.isPacked?this.unpackTensor(t):this.packTensor(t),c.push(t),n=this.texData.get(t.dataId);else if(n.isPacked&&!xW(n.shape,t.shape)){const e=t,a=t.shape;t.shape=n.shape,t=this.packedReshape(t,a),c.push(t),n=this.texData.get(t.dataId),e.shape=a}return{shape:t.shape,texData:n,isUniform:!1}});this.uploadToGPU(i.dataId);const u={shape:i.shape,texData:o,isUniform:!1},h=function(e,t,n){let a="";t.concat(n).forEach(t=>{const s=null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!t.isUniform){const r=t.texData.texShape,{useSqueezeShape:i,uniformShape:o,keptDims:c}=GW(e.packedInputs,t.shape,r);let l="",u="",h="";if(1===o.length&&e.packedInputs){const e=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];l="".concat(e[0]>1,"_").concat(e[1]>1)}else if(2!==o.length||e.packedInputs){if(o.length>2&&!e.packedInputs){const e=Bu(o);h="".concat(e[0]===r[1],"_").concat(e[e.length-1]===r[1])}}else u="".concat(o[0]>1,"_").concat(o[1]>1);const d=t.shape.length,p=2===o.length&&ku(t.shape,r),f=1===vu(t.shape),m=Ty(t.shape,n.shape),g=!e.packedInputs&&d===n.shape.length&&ku(r,n.texData.texShape),y=e.packedInputs||o.length>2?"":"".concat(r[0]>1,"_").concat(r[1]>1);a+="".concat(d,"_").concat(g,"_").concat(i?c:"","_").concat(o.length,"_").concat(f,"_").concat(m,"_").concat(p,"_").concat(l,"_").concat(u,"_").concat(h,"_").concat(y,"_").concat(s)}else{const e=t.isUniform?"uniform":t.texData.texShape;a+="".concat(t.shape,"_").concat(e,"_").concat(s)}});const s=e.userCode;let r=e.constructor.name;return r+="_"+a+"_"+s+"".concat($u().getNumber("WEBGL_VERSION")),r}(e,l,u),d=this.getAndSaveBinary(h,()=>XW(this.gpgpu,e,l,u)),p=null!=this.activeTimers;let f;p&&(f=this.startTimer()),$u().get("ENGINE_COMPILE_ONLY")||function(e,t,n,a,s){t.program.enableShapeUniforms||(QW(t.inShapeInfos,n),QW([t.outShapeInfo],[a]));const r=a.texData.texture,i=a.texData.texShape;a.texData.isPacked?e.setOutputPackedMatrixTexture(r.texture,i[0],i[1]):e.setOutputMatrixTexture(r.texture,i[0],i[1]),e.setProgram(t.webGLProgram),e.bindVertexArray(t.webGLProgram.vao),1===$u().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&e.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&e.gl.uniform1f(t.nanLoc,NaN);for(let c=0;c<n.length;++c){const a=n[c],{uniform:s,offset:r,shape:i,texShape:o}=t.variablesLocations[c];if(i){const{uniformShape:n}=GW(t.program.packedInputs,a.shape,a.texData.texShape);switch(n.length){case 1:e.gl.uniform1iv(i,new Int32Array(n));break;case 2:e.gl.uniform2iv(i,new Int32Array(n));break;case 3:e.gl.uniform3iv(i,new Int32Array(n));break;case 4:e.gl.uniform4iv(i,new Int32Array(n))}}if(o&&e.gl.uniform2i(o,a.texData.texShape[0],a.texData.texShape[1]),null!=s)if(a.isUniform)if(vu(a.shape)<2)e.gl.uniform1f(s,a.uniformValues[0]);else{let t=a.uniformValues;t instanceof Float32Array||(t=new Float32Array(t)),e.gl.uniform1fv(s,t)}else null!=a.texData.slice&&null!=r&&e.gl.uniform1i(r,a.texData.slice.flatOffset),e.setInputMatrixTexture(a.texData.texture.texture,s,c)}const o=t.outShapeLocation;if(o)switch(a.shape.length){case 1:e.gl.uniform1iv(o,new Int32Array(a.shape));break;case 2:e.gl.uniform2iv(o,new Int32Array(a.shape));break;case 3:e.gl.uniform3iv(o,new Int32Array(a.shape));break;case 4:e.gl.uniform4iv(o,new Int32Array(a.shape))}if(t.outShapeStridesLocation){const n=Bu(a.shape);switch(a.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(n));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(n));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(n))}}if(t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,a.texData.texShape[0],a.texData.texShape[1]),t.program.customUniforms&&s)for(let c=0;c<t.program.customUniforms.length;++c){const n=t.program.customUniforms[c],a=t.customUniformLocations[c],r=s[c];if("float"===n.type)e.gl.uniform1fv(a,r);else if("vec2"===n.type)e.gl.uniform2fv(a,r);else if("vec3"===n.type)e.gl.uniform3fv(a,r);else if("vec4"===n.type)e.gl.uniform4fv(a,r);else if("int"===n.type)e.gl.uniform1iv(a,r);else if("ivec2"===n.type)e.gl.uniform2iv(a,r);else if("ivec3"===n.type)e.gl.uniform3iv(a,r);else{if("ivec4"!==n.type)throw Error("uniform type ".concat(n.type," is not supported yet."));e.gl.uniform4iv(a,r)}}e.executeProgram()}(this.gpgpu,d,l,u,a),c.forEach(e=>this.disposeIntermediateTensorInfo(e)),p&&(f=this.endTimer(f),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(f)}));const m=$u().getNumber("WEBGL_FLUSH_THRESHOLD");if(m>0){const e=Uf();e-this.lastGlFlushTime>m&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=e)}if(!$u().getBool("WEBGL_LAZILY_UNPACK")&&o.isPacked&&!1===s){const e=this.unpackTensor(i);return this.disposeIntermediateTensorInfo(i),e}return i}compileAndRun(e,t,n,a){let s=arguments.length>4&&void 0!==arguments[4]&&arguments[4];n=n||t[0].dtype;return this.runWebGLProgram(e,t,n,a,s)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){if(!this.disposed){if(!$u().getBool("IS_TEST")){Object.keys(this.binaryCache).forEach(e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]})}this.textureManager.dispose(),null!=this.canvas&&"undefined"!==typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0}}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=Km(()=>{if(!$u().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=$u().getBool("DEBUG");$u().set("DEBUG",!1);const t=this.abs(py(1e-8)).dataSync()[0];if($u().set("DEBUG",e),t>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const t=this.texData.get(e),{shape:n,dtype:a,values:s,texture:r,usage:i,isPacked:o}=t;if(null!=r)return;const c=null!=this.activeTimers;let l;c&&(l=Uf());let u=t.texShape;if(null==u&&(u=function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=$u().getNumber("WEBGL_MAX_TEXTURE_SIZE"),a=$u().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");if(a===1/0&&$u().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(a=n/2),t&&(n*=2,a*=2,1===(e=e.map((t,n)=>n>=e.length-2?fu(e[n]):e[n])).length&&(e=[2,e[0]])),2!==e.length){const t=Ru(e);e=t.newShape}let s=vu(e),r=null;e.length<=1&&s<=n?r=[1,s]:2===e.length&&e[0]<=n&&e[1]<=n?r=e:3===e.length&&e[0]*e[1]<=n&&e[2]<=n?r=[e[0]*e[1],e[2]]:3===e.length&&e[0]<=n&&e[1]*e[2]<=n?r=[e[0],e[1]*e[2]]:4===e.length&&e[0]*e[1]*e[2]<=n&&e[3]<=n?r=[e[0]*e[1]*e[2],e[3]]:4===e.length&&e[0]<=n&&e[1]*e[2]*e[3]<=n&&(r=[e[0],e[1]*e[2]*e[3]]);const i=null!=r&&Math.max(...r)>a&&Math.min(...r)<=(t?2:1)&&Math.min(...r)>0;if(null==r||i)if(t){const t=mW(e);let n=2,a=2;e.length&&([n,a]=gW(e)),s=t*(n/2)*(a/2),r=Cu(s).map(e=>2*e)}else r=Cu(s);return r}(n,o),t.texShape=u),null!=s){const e=yW(n);let r,i=u[1],h=u[0];const d=s instanceof Uint8Array||s instanceof Uint8ClampedArray;!o&&d||([i,h]=eW(u[0],u[1])),r=o?new sV(e,d):new aV(e,d);const p=d?[h,i]:u,f=this.makeTensorInfo(p,a),m=this.texData.get(f.dataId);m.usage=d?Qj.PIXELS:Qj.UPLOAD,m.texShape=p,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(f.dataId),i,h,s);const g=[[h,i]],y=!0,b=this.runWebGLProgram(r,[f],a,g,y),x=this.texData.get(b.dataId);t.texShape=x.texShape,t.isPacked=x.isPacked,t.usage=x.usage,$u().get("ENGINE_COMPILE_ONLY")?this.disposeData(b.dataId):(t.texture=x.texture,t.values=null,this.texData.delete(b.dataId)),this.disposeIntermediateTensorInfo(f),c&&(this.uploadWaitMs+=Uf()-l)}else{const e=this.acquireTexture(u,i,a,o);t.texture=e}}convertAndCacheOnCPU(e,t){const n=this.texData.get(e),{dtype:a}=n;return null!=t&&(n.values=function(e,t){if("float32"===t||"complex64"===t)return e;if("int32"===t||"bool"===t){const n="int32"===t?new Int32Array(e.length):new Uint8Array(e.length);for(let t=0;t<n.length;++t)n[t]=Math.round(e[t]);return n}throw new Error("Unknown dtype ".concat(t))}(t,a)),n.values}acquireTexture(e,t,n,a){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const e=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn("High memory usage in GPU: ".concat(e," MB, ")+"most likely due to a memory leak")}return this.textureManager.acquireTexture(e,t,a)}computeBytes(e,t){return e[0]*e[1]*Pu(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}for(const[,t]of Object.entries(this.binaryCache)){const n=new Promise(e=>{try{this.checkCompletion_(t),e(!0)}catch(n){throw n}});e.push(n)}return Promise.all(e)}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await QS(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)){if(console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS))throw iW(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.");throw new Error("Failed to link vertex and fragment shaders.")}return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:t,customUniformLocations:n,infLoc:a,nanLoc:s,outShapeLocation:r,outShapeStridesLocation:i,outTexShapeLocation:o}=YW(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=n,e.infLoc=a,e.nanLoc=s,e.outShapeLocation=r,e.outShapeStridesLocation=i,e.outTexShapeLocation=o}}createTensorFromGPUData(e,t,n){e.channels=e.channels||"RGBA";const{texture:a,height:s,width:r,channels:i}=e,o=Gm().backend;if(!o.gpgpu.gl.isTexture(a))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const c=o.writeTexture(a,t,n,s,r,i);return Gm().makeTensorFromDataId(c,t,n,o)}}_U.nextDataId=0;Am()&&Zm("webgl",()=>new _U,2);const AU="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n";class MU{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=Ry(t,n),this.enableShapeUniforms=ZW(this.outputShape.length),this.userCode="\n      float binaryOperation(float a, float b) {\n        ".concat(e,"\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    ")}}const PU="\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n";class DU{constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Ry(t,n);const s=this.outputShape.length;this.enableShapeUniforms=ZW(s);let r="";if(a)if(0===s||1===vu(this.outputShape))r="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else{const e=HW(s);if(r="\n          ".concat(e," coords = getOutputCoords();\n        "),1===s)this.enableShapeUniforms?r+="\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":r+="\n            result.y = (coords + 1) >= ".concat(this.outputShape[0]," ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ");else{const e=dU("coords",s);this.enableShapeUniforms?r+="\n            bool nextRowOutOfBounds =\n              (".concat(e[s-2]," + 1) >= outShape[").concat(s," - 2];\n            bool nextColOutOfBounds =\n              (").concat(e[s-1]," + 1) >= outShape[").concat(s," - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          "):r+="\n            bool nextRowOutOfBounds =\n              (".concat(e[s-2]," + 1) >= ").concat(this.outputShape[s-2],";\n            bool nextColOutOfBounds =\n              (").concat(e[s-1]," + 1) >= ").concat(this.outputShape[s-1],";\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          ")}}this.userCode="\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ".concat(e,"\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ").concat(r,"\n\n        setOutput(result);\n      }\n    ")}}function OU(e){const{inputs:t,backend:n}=e,{x:a}=t;return n.incRef(a.dataId),{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}const FU={kernelName:xd,backendName:"webgl",kernelFunc:OU};function LU(e){const{inputs:t,backend:n}=e,{real:a,imag:s}=t,r=n.makeTensorInfo(a.shape,"complex64"),i=n.texData.get(r.dataId),o=OU({inputs:{x:a},backend:n}),c=OU({inputs:{x:s},backend:n});return i.complexTensorInfos={real:o,imag:c},r}const zU={kernelName:_h,backendName:"webgl",kernelFunc:LU},BU="return (a < 0.) ? b * a : a;",jU="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";const WU={kernelName:Id,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{alpha:r}=a,i=n.makeTensorInfo([],"float32",Wf(r,"float32")),o=$u().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new DU(jU,s.shape,i.shape):new MU(BU,s.shape,i.shape),c=n.runWebGLProgram(o,[s,i],"float32");return n.disposeIntermediateTensorInfo(i),c}},VU="return (a < 0.) ? b * a : a;",UU="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";const HU={kernelName:ip,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a,alpha:s}=t,r=$u().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new DU(UU,a.shape,s.shape):new MU(VU,a.shape,s.shape);return n.runWebGLProgram(r,[a,s],"float32")}},GU="if (isnan(x)) return x;";function qU(e){let{opSnippet:t,packedOpSnippet:n,cpuKernelImpl:a,dtype:s}=e;return e=>{let{inputs:r,backend:i}=e;const{x:o}=r,c=i,l=s||o.dtype;if(c.shouldExecuteOnCPU([o])&&null!=a){const e=c.texData.get(o.dataId),t=a(e.values,l);return c.makeTensorInfo(o.shape,l,t)}let u;return u=$u().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=n?new IU(o.shape,n):new xU(o.shape,t),c.runWebGLProgram(u,[o],l)}}function KU(e){let{opSnippet:t,packedOpSnippet:n,checkOutOfBounds:a=!1,supportsComplex:s=!1,cpuKernelImpl:r,dtype:i}=e;return e=>{let{inputs:o,backend:c}=e;const{a:l,b:u}=o,h=c;if(s&&"complex64"===l.dtype){const e=h.texData.get(l.dataId),n=h.texData.get(u.dataId),[a,s]=[[e.complexTensorInfos.real,n.complexTensorInfos.real],[e.complexTensorInfos.imag,n.complexTensorInfos.imag]].map(e=>{const[n,a]=e,s={dataId:n.dataId,dtype:n.dtype,shape:l.shape},r={dataId:a.dataId,dtype:a.dtype,shape:u.shape},i=new MU(t,l.shape,u.shape);return h.runWebGLProgram(i,[s,r],mm(n.dtype,a.dtype))}),r=LU({inputs:{real:a,imag:s},backend:h});return h.disposeIntermediateTensorInfo(a),h.disposeIntermediateTensorInfo(s),r}const d=i||mm(l.dtype,u.dtype);if(("string"===l.dtype||"string"===u.dtype||h.shouldExecuteOnCPU([l,u]))&&null!=r){const e=h.texData.get(l.dataId).values,t=h.texData.get(u.dataId).values,n="string"===l.dtype?tI(e):e,a="string"===l.dtype?tI(t):t,[s,i]=r(l.shape,u.shape,n,a,d),o=h.makeTensorInfo(i,d);return h.texData.get(o.dataId).values=s,o}let p;return p=$u().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=n?new DU(n,l.shape,u.shape,a):new MU(t,l.shape,u.shape),h.runWebGLProgram(p,[l,u],d)}}function XU(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if("linear"===e)return"return x;";if("relu"===e)return t?"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":kU;if("elu"===e)return t?"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n":"return (x >= 0.0) ? x : (exp(x) - 1.0);";if("relu6"===e)return t?"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":SU;if("prelu"===e)return t?UU:VU;if("leakyrelu"===e)return t?jU:BU;if("sigmoid"===e)return"return 1.0 / (1.0 + exp(-1.0 * x));";throw new Error("Activation ".concat(e," has not been implemented for the WebGL backend."))}class YU{constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=arguments.length>4&&void 0!==arguments[4]&&arguments[4],r=arguments.length>5&&void 0!==arguments[5]&&arguments[5],i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,o=arguments.length>7&&void 0!==arguments[7]&&arguments[7],c=arguments.length>8&&void 0!==arguments[8]&&arguments[8];this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=ZW(this.outputShape.length);const l=a?e[1]:e[2],u=Math.ceil(l/2),h=a?"i * 2, rc.y":"rc.y, i * 2",d=s?"rc.z, i * 2":"i * 2, rc.z",p=a?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],f=s?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let m="",g="";i&&(m=o?"vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ".concat(i,"\n        }"):c?"vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ".concat(i,"\n        }"):"vec4 activation(vec4 x) {\n          ".concat(i,"\n        }"),g="result = activation(result);");const y=r?"result += getBiasAtOutCoords();":"";r&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),c&&this.variableNames.push("leakyreluAlpha");let b="rc.x",x="rc.x";e[0]<t[0]?b="imod(rc.x, ".concat(e[0],")"):t[0]<e[0]&&(x="imod(rc.x, ".concat(t[0],")")),this.userCode="\n      ".concat(m,"\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ").concat(u,".0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        int batchA = ").concat(b,";\n        int batchB = ").concat(x,";\n        for (int i = 0; i < ").concat(u,"; i++) {\n          vec4 a = getMatrixA(batchA, ").concat(h,");\n          vec4 b = getMatrixB(batchB, ").concat(d,");\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (").concat(p[0]," * ").concat(f[0],");\n          result += (").concat(p[1]," * ").concat(f[1],");\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ").concat(y,"\n\n        ").concat(g,"\n\n        setOutput(result);\n      }\n    ")}}const QU="return areal * breal - aimag * bimag;",ZU="return areal * bimag + aimag * breal;";class JU{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Ry(t,n),this.userCode="\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ".concat(e,"\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    ")}}const $U="return a * b;";function eH(e){const{inputs:t,backend:n}=e,{a:a,b:s}=t,r=mm(a.dtype,s.dtype);if("complex64"===a.dtype){const e=n.texData.get(a.dataId),t=n.texData.get(s.dataId),r=new JU(QU,a.shape,s.shape),i=new JU(ZU,a.shape,s.shape),o=[{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:a.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:a.shape},{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:s.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:s.shape}],c=n.runWebGLProgram(r,o,"float32"),l=n.runWebGLProgram(i,o,"float32"),u=LU({inputs:{real:c,imag:l},backend:n});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(l),u}if(n.shouldExecuteOnCPU([a,s])){const e=n.texData.get(a.dataId),t=n.texData.get(s.dataId),[i,o]=zV(a.shape,s.shape,e.values,t.values,r),c=n.makeTensorInfo(o,r);return n.texData.get(c.dataId).values=i,c}let i;return i=$u().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new DU($U,a.shape,s.shape):new MU($U,a.shape,s.shape),n.runWebGLProgram(i,[a,s],r)}const tH={kernelName:Yd,backendName:"webgl",kernelFunc:eH};function nH(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{shape:r}=a,i=n,o=vu(s.shape),c=Tu(r,o),l=vu(c);yu(o===l,()=>"The new shape (".concat(c,") has ").concat(l," elements and the old ")+"shape (".concat(s.shape,") has ").concat(o," elements. The new shape and old ")+"shape must have the same number of elements.");const u=i.texData.get(s.dataId);return!u.isPacked||xW(s.shape,c)||null!==u.texture&&xW(u.shape,c)?(i.incRef(s.dataId),{dataId:s.dataId,shape:c,dtype:s.dtype}):function(e,t,n){const a=[mW(e.shape),...gW(e.shape)],s={dtype:e.dtype,shape:a,dataId:e.dataId},r=[mW(t),...gW(t)],i=new fU(r,a),o=[a],c=n.runWebGLProgram(i,[s],e.dtype,o,!0);return{dataId:c.dataId,shape:t,dtype:c.dtype}}(s,c,i)}const aH={kernelName:mp,backendName:"webgl",kernelFunc:nH};class sH{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:a,inSize:s,outSize:r}=e;this.outputShape=[a,r];const i=4*Math.floor(n/4),o=n%4;let c="sumValue += dot(values, ones);";if(null!=t){const e=1/t;c="sumValue += dot(values * ".concat(Su(e)?e.toPrecision(2):e,", ones);")}let l="";s%n>0&&(l="\n        if (inIdx < 0 || inIdx >= ".concat(s,") {\n          return 0.0;\n        }\n      ")),this.userCode="\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ".concat(l,"\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ").concat(n,";\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ").concat(i,"; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ").concat(c,"\n        }\n\n        int inIdx = inOffset + ").concat(i,";\n        if (").concat(1===o,") {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ").concat(c,"\n        } else if (").concat(2===o,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ").concat(c,"\n        } else if (").concat(3===o,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ").concat(c,"\n        }\n        setOutput(sumValue);\n      }\n    ")}}class rH{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:a,inSize:s,outSize:r}=e;this.outputShape=[a,r];let i="0.0",o="";"prod"===t?i="1.0":"min"===t?(i="1.0 / 1e-20",o="min"):"max"===t&&(i="-1.0 / 1e-20",o="max");let c="".concat(t,"(").concat(t,"(").concat(t,"(")+"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"sum"===t?c="sumValue":"prod"===t?c="prodValue":"all"===t?c="allValue":"any"===t&&(c="anyValue");const l=4*Math.floor(n/4),u=n%4;let h="\n      if (".concat("sum"===t,") {\n        sumValue += dot(values, ones);\n      } else if (").concat("prod"===t,") {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ").concat(o,"(values, minMaxValue);\n        if (").concat("min"===t," || ").concat("max"===t,") {\n          minMaxValue = ").concat(o,"(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    "),d="vec4";"all"===t?(i="1.0",h="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",d="bvec4"):"any"===t&&(i="0.0",h="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",d="bvec4");let p="";s%n>0&&(p="\n        if (inIdx < 0 || inIdx >= ".concat(s,") {\n          return initializationValue;\n        }\n      ")),this.userCode="\n      const float initializationValue = ".concat(i,";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ").concat(p,"\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ").concat(n,";\n\n        vec4 minMaxValue = vec4(").concat(i,");\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ").concat(l,"; i += 4) {\n          int inIdx = inOffset + i;\n          ").concat(d," values = ").concat(d,"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ").concat(h,"\n        }\n\n        int inIdx = inOffset + ").concat(l,";\n        if (").concat(1===u,") {\n          ").concat(d," values = ").concat(d,"(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ").concat(h,"\n        } else if (").concat(2===u,") {\n          ").concat(d," values = ").concat(d,"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ").concat(h,"\n        } else if (").concat(3===u,") {\n          ").concat(d," values = ").concat(d,"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ").concat(h,"\n        }\n        setOutput(").concat(c,");\n      }\n    ")}}function iH(e,t,n,a){const s=function(e){const t=[];for(;0===t.length||1!==t[t.length-1].outSize;){const n=t.length?t[t.length-1].outSize:e[1],a=rC(n);t.push({inSize:n,windowSize:a,outSize:Math.ceil(n/a)})}return t}(e.shape);let r=e;for(let i=0;i<s.length;i++){const{inSize:o,windowSize:c,outSize:l}=s[i];let u,h;u="mean"===n?0===i?new sH({windowSize:c,inSize:o,batchSize:e.shape[0],outSize:l},o):new sH({windowSize:c,inSize:o,batchSize:e.shape[0],outSize:l}):new rH({windowSize:c,inSize:o,batchSize:e.shape[0],outSize:l},n),h=r,r=a.runWebGLProgram(u,[r],t),h.dataId!==e.dataId&&a.disposeIntermediateTensorInfo(h)}return r}class oH{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];this.outputShape=n,this.rank=n.length;const a=HW(this.rank),s=function(e){const t=e.length;if(t>6)throw Error("Transpose for rank ".concat(t," is not yet supported"));const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],a=new Array(t);for(let s=0;s<e.length;s++)a[e[s]]=n[s];return a.join()}(t);this.userCode="\n    void main() {\n      ".concat(a," resRC = getOutputCoords();\n      setOutput(getA(").concat(s,"));\n    }\n    ")}}class cH{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(e.length);for(let l=0;l<n.length;l++)n[l]=e[t[l]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error("Packed transpose for rank ".concat(this.rank," is not yet supported."));const a=HW(this.rank),s=hU("rc",this.rank),r=new Array(this.rank);for(let l=0;l<t.length;l++)r[t[l]]=s[l];const i="vec2(".concat(r.slice(-2).join(),")"),o="++".concat(s[this.rank-1]," < ").concat(n[this.rank-1]),c="getChannel(getA(".concat(r.join(),"), ").concat(i,")");this.userCode="\n    void main() {\n      ".concat(a," rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ").concat(c,";\n      if(").concat(o,") {\n        result[1] = ").concat(c,";\n      }\n      --").concat(s[this.rank-1],";\n      if(++").concat(s[this.rank-2]," < ").concat(n[this.rank-2],") {\n        result[2] = ").concat(c,";\n        if(").concat(o,") {\n          result[3] = ").concat(c,";\n        }\n      }\n      setOutput(result);\n    }\n    ")}}function lH(e,t,n){const a=$u().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new cH(e.shape,t):new oH(e.shape,t);return n.runWebGLProgram(a,[e],e.dtype)}function uH(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{axis:r,keepDims:i}=a;return function(e,t,n,a){const s=t,r=e.shape.length,i=Eu(s,e.shape);let o=i;const c=ev(o,r),l=null!=c;let u=e;l&&(u=lH(e,c,a),o=nv(o.length,r)),$x("sum",o,r);const[h,d]=Zx(u.shape,o);let p=h;n&&(p=Jx(h,i));const f=vu(d),m=nH({inputs:{x:u},attrs:{shape:[vu(e.shape)/f,f]},backend:a}),g=iH(m,gm(e.dtype),"sum",a),y=nH({inputs:{x:g},attrs:{shape:p},backend:a});return a.disposeIntermediateTensorInfo(m),a.disposeIntermediateTensorInfo(g),l&&a.disposeIntermediateTensorInfo(u),y}(s,r,i,n)}const hH={kernelName:Fp,backendName:"webgl",kernelFunc:uH};function dH(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{perm:r}=a,i=n,o=s.shape.length,c=new Array(o);for(let u=0;u<c.length;u++)c[u]=s.shape[r[u]];let l;if(i.shouldExecuteOnCPU([s])){const e=i.texData.get(s.dataId).values,t=lU(e,s.shape,s.dtype,r,c);l=i.makeTensorInfo(c,s.dtype);i.texData.get(l.dataId).values=t}else l=lH(s,r,i);return l}const pH={kernelName:sf,backendName:"webgl",kernelFunc:dH};function fH(e){let{a:t,b:n,transposeA:a,transposeB:s,backend:r,bias:i=null,preluActivationWeights:o=null,leakyreluAlpha:c=0,activation:l=null}=e;const u=t.shape.length,h=n.shape.length,d=a?t.shape[u-2]:t.shape[u-1],p=s?n.shape[h-1]:n.shape[h-2],f=a?t.shape[u-1]:t.shape[u-2],m=s?n.shape[h-2]:n.shape[h-1],g=t.shape.slice(0,-2),y=n.shape.slice(0,-2),b=vu(g),x=vu(y),v=Ry(t.shape.slice(0,-2),n.shape.slice(0,-2)).concat([f,m]);yu(d===p,()=>"Error in matMul: inner shapes (".concat(d,") and (")+"".concat(p,") of Tensors with shapes ").concat(t.shape," and ")+"".concat(n.shape," and transposeA=").concat(a)+" and transposeB=".concat(s," must match."));const w=a?[b,d,f]:[b,f,d],k=s?[x,m,p]:[x,p,m],S=nH({inputs:{x:t},backend:r,attrs:{shape:w}}),C=nH({inputs:{x:n},backend:r,attrs:{shape:k}}),I=[S,C],N=Math.max(b,x),T=a?S.shape[1]:S.shape[2],E=null!=i,R=null!=o,_="leakyrelu"===l,A=null!=l?XU(l,!0):null;let M;if((1===f||1===m)&&T>1e3&&!1===(E||R||_||null!=A)){let e=S,t=C;a&&(e=dH({inputs:{x:S},backend:r,attrs:{perm:[0,2,1]}}),I.push(e)),s&&(t=dH({inputs:{x:C},backend:r,attrs:{perm:[0,2,1]}}),I.push(t));const n=1===m;let i=e;1!==m&&(i=nH({inputs:{x:e},backend:r,attrs:{shape:[N,T,1]}}),I.push(i));const o=1===m?2:1;let c=t;n&&(c=nH({inputs:{x:t},backend:r,attrs:{shape:[N,1,T]}}),I.push(c));const l=eH({inputs:{a:i,b:c},backend:r});M=uH({inputs:{x:l},backend:r,attrs:{axis:o,keepDims:!0}}),I.push(l)}else{const e=mm(t.dtype,n.dtype),l=new YU(w,k,[N,f,m],a,s,E,A,R,_),u=[S,C];if(null!=i&&u.push(i),R&&u.push(o),_){const e=r.makeTensorInfo([],"float32",Wf(c,"float32"));u.push(e),I.push(e)}M=r.runWebGLProgram(l,u,e)}const P=nH({inputs:{x:M},backend:r,attrs:{shape:v}});I.push(M);for(const D of I)r.disposeIntermediateTensorInfo(D);return P}const mH={kernelName:pf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{a:s,b:r,bias:i,preluActivationWeights:o}=t,{transposeA:c,transposeB:l,activation:u,leakyreluAlpha:h}=a;return fH({a:s,b:r,transposeA:c,transposeB:l,backend:n,bias:i,preluActivationWeights:o,leakyreluAlpha:h,activation:u})}},gH="return abs(x);";const yH={kernelName:sh,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t;if(n.shouldExecuteOnCPU([a])&&"complex64"!==a.dtype){const e=n.texData.get(a.dataId),t=YV(e.values);return n.makeTensorInfo(a.shape,a.dtype,t)}let s;return s=$u().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new IU(a.shape,gH):new xU(a.shape,gH),n.runWebGLProgram(s,[a],a.dtype)}},bH=qU({opSnippet:vU+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),xH={kernelName:rh,backendName:"webgl",kernelFunc:bH},vH=qU({opSnippet:vU+"\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),wH={kernelName:ih,backendName:"webgl",kernelFunc:vH},kH="return a + b;",SH=KU({opSnippet:kH,packedOpSnippet:kH,supportsComplex:!0,cpuKernelImpl:gV}),CH={kernelName:oh,backendName:"webgl",kernelFunc:SH};class IH{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((e,t)=>"T".concat(t));const n=[];this.variableNames.forEach(e=>{n.push("float v".concat(e," = get").concat(e,"AtOutCoords();"))});const a=this.variableNames.map(e=>"v".concat(e)).join(" + ");this.userCode="\n      void main() {\n        ".concat(n.join("\n        "),"\n\n        float result = ").concat(a,";\n        setOutput(result);\n      }\n    ")}}class NH{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((e,t)=>"T".concat(t));const n=[];this.variableNames.forEach(e=>{n.push("vec4 v".concat(e," = get").concat(e,"AtOutCoords();"))});const a=this.variableNames.map(e=>"v".concat(e)).join(" + ");this.userCode="\n      void main() {\n        ".concat(n.join("\n        "),"\n\n        vec4 result = ").concat(a,";\n        setOutput(result);\n      }\n    ")}}const TH={kernelName:ch,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:a}=t,s=n;if(1===s.length)return OU({inputs:{x:s[0]},backend:a});if(s.length>$u().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const t=Math.floor(s.length/2),n=e({inputs:s.slice(0,t),backend:a}),r=e({inputs:s.slice(t),backend:a});return e({inputs:[n,r],backend:a})}const r=s.map(e=>e.dtype).reduce((e,t)=>mm(e,t)),i=s.map(e=>e.shape),o=$u().getBool("WEBGL_PACK")?new NH(s[0].shape,i):new IH(s[0].shape,i);return a.runWebGLProgram(o,s,r)}};const EH={kernelName:lh,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{axis:r,keepDims:i}=a,o=s.shape.length,c=Eu(r,s.shape);let l=c;const u=ev(l,o);let h=s;null!=u&&(h=dH({inputs:{x:s},backend:n,attrs:{perm:u}}),l=nv(l.length,o)),$x("all",l,o);const[d,p]=Zx(h.shape,l),f=nH({inputs:{x:h},backend:n,attrs:{shape:[-1,vu(p)]}}),m=iH(f,f.dtype,"all",n);let g;if(i){g=nH({inputs:{x:m},backend:n,attrs:{shape:Jx(d,c)}})}else g=nH({inputs:{x:m},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=u&&n.disposeIntermediateTensorInfo(h),g}};const RH={kernelName:uh,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{axis:r,keepDims:i}=a,o=s.shape.length,c=Eu(r,s.shape);let l=c;const u=ev(l,o);let h=s;null!=u&&(h=dH({inputs:{x:s},backend:n,attrs:{perm:u}}),l=nv(l.length,o)),$x("any",l,o);const[d,p]=Zx(h.shape,l),f=nH({inputs:{x:h},backend:n,attrs:{shape:[-1,vu(p)]}}),m=iH(f,f.dtype,"any",n);let g;if(i){g=nH({inputs:{x:m},backend:n,attrs:{shape:Jx(d,c)}})}else g=nH({inputs:{x:m},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=u&&n.disposeIntermediateTensorInfo(h),g}};class _H{constructor(e,t,n){this.variableNames=["A"];const{windowSize:a,batchSize:s,outSize:r}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[s,r];const i="max"===t?">":"<",o=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ".concat(a,";\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ").concat(a,"; i++) {\n          int inIdx = ").concat(o,";\n          float candidate = getA(batch, inIdx);\n          if (candidate ").concat(i," bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    ")}}class AH{constructor(e,t,n,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,yu(e.length>2,()=>"Packed arg".concat(n.charAt(0).toUpperCase()+n.slice(1)," supports only inputs with rank above 2."));const s=e[e.length-1],r=Math.ceil(s/t);this.outputShape=e.slice(0,-1),r>1&&this.outputShape.push(r),a||this.variableNames.push("bestIndicesA");const i=this.outputShape,o=i.length,c=HW(o),l=dU("coords",o);let u,h;if(1===r){h=o+1;const e=HW(h);u="\n        ".concat(e," sourceLocR = ").concat(e,"(").concat(l.join(),", 0);\n        ++").concat(l[o-1],";\n        ").concat(e," sourceLocG = ").concat(e,"(").concat(l.join(),", 0);\n        ++").concat(l[o-2],";\n        ").concat(e," sourceLocA = ").concat(e,"(").concat(l.join(),", 0);\n        --").concat(l[o-1],";\n        ").concat(e," sourceLocB = ").concat(e,"(").concat(l.join(),", 0);\n        --").concat(l[o-2],";")}else h=o,u="\n        ".concat(c," sourceLocR = coords;\n        ++").concat(l[o-1],";\n        ").concat(c," sourceLocG = coords;\n        ++").concat(l[o-2],";\n        ").concat(c," sourceLocA = coords;\n        --").concat(l[o-1],";\n        ").concat(c," sourceLocB = coords;\n        --").concat(l[o-2],";");const d=["x","y","z","w","u","v"].slice(0,h),p="."+d[h-1],f=d.map(e=>"int "+e),m=dU("sourceLocR",h-1).concat("inIdx.r"),g=dU("sourceLocG",h-1).concat("inIdx.g"),y=dU("sourceLocB",h-1).concat("inIdx.b"),b=dU("sourceLocA",h-1).concat("inIdx.a"),x="max"===n?"greaterThan":"lessThan",v=a?"":"\n          inIdx = round(vec4(getBestIndicesAChannel(".concat(m.join(),"),\n                             getBestIndicesAChannel(").concat(g.join(),"),\n                             getBestIndicesAChannel(").concat(y.join(),"),\n                             getBestIndicesAChannel(").concat(b.join(),")));"),w="vec4(\n            getAChannel(".concat(m.join(),"),\n            hasNextCol ? getAChannel(").concat(g.join(),") : 0.,\n            hasNextRow ? getAChannel(").concat(y.join(),") : 0.,\n            hasNextRow && hasNextCol ? getAChannel(").concat(b.join(),") : 0.)"),k=a?"":"\n      float getBestIndicesAChannel(".concat(f.join(),") {\n        return getChannel(getBestIndicesA(").concat(d.join(),"),\n                                          vec2(").concat(d.slice(-2).join(),"));\n      }");this.userCode="\n      float getAChannel(".concat(f.join(),") {\n        return getChannel(getA(").concat(d.join(),"),\n                               vec2(").concat(d.slice(-2).join(),"));\n      }\n      ").concat(k,"\n      void main() {\n        ").concat(c," coords = getOutputCoords();\n        bool hasNextCol = ").concat(l[o-1]," < ").concat(i[o-1]-1,";\n        bool hasNextRow = ").concat(l[o-2]," < ").concat(i[o-2]-1,";\n        ").concat(u,"\n        ivec4 srcIdx = ivec4(sourceLocR").concat(p,", sourceLocG").concat(p,",\n          sourceLocB").concat(p,", sourceLocA").concat(p,") * ").concat(t,";\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ").concat(w,";\n\n        for (int i = 0; i < ").concat(t,"; i++) {\n          inIdx = srcIdx;\n          ").concat(v,"\n          vec4 candidate = ").concat(w,";\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(").concat(x,"(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    ")}}function MH(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,s=t.shape[0],r=t.shape[1];null!=a&&(s=a.shape[0],r=a.shape[1]);const i=rC(r),o={windowSize:i,inSize:r,batchSize:s,outSize:Math.ceil(r/i)},c=new _H(o,n,null==a),l=[t];null!=a&&l.push(a);const u=e.runWebGLProgram(c,l,"int32");if(1===u.shape[1])return u;const h=MH(e,t,n,u);return e.disposeIntermediateTensorInfo(u),h}function PH(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const s=null!=a?a.shape:t.shape,r=rC(s[s.length-1]),i=new AH(s,r,n,null==a),o=null==a?[t]:[t,a],c=e.runWebGLProgram(i,o,"int32");if(c.shape.length===t.shape.length){const a=PH(e,t,n,c);return e.disposeIntermediateTensorInfo(c),a}return c}function DH(e,t,n,a){const s=[n];if($x("arg"+a.charAt(0).toUpperCase()+a.slice(1),s,t.shape.length),!$u().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const n=[],r=e.texData.get(t.dataId);let i=t;null!==r&&r.isPacked&&(i=e.unpackTensor(t),n.push(i));const[o,c]=Zx(i.shape,s),l=vu(c),u=nH({inputs:{x:i},backend:e,attrs:{shape:[-1,l]}});n.push(u);const h=MH(e,u,a);n.push(h);const d=nH({inputs:{x:h},backend:e,attrs:{shape:o}});return n.forEach(t=>e.disposeIntermediateTensorInfo(t)),d}return PH(e,t,a)}const OH={kernelName:hh,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{axis:r}=a;let i=Eu(r,s.shape);const o=ev(i,s.shape.length);let c=s;const l=[];null!=o&&(c=dH({inputs:{x:s},backend:n,attrs:{perm:o}}),l.push(c),i=nv(i.length,c.shape.length)),$x("argMax",[i[0]],c.shape.length);const u=DH(n,c,i[0],"max");return l.forEach(e=>n.disposeIntermediateTensorInfo(e)),u}};const FH={kernelName:dh,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{axis:r}=a;let i=Eu(r,s.shape);const o=ev(i,s.shape.length);let c=s;const l=[];null!=o&&(c=dH({inputs:{x:s},backend:n,attrs:{perm:o}}),l.push(c),i=nv(i.length,c.shape.length)),$x("argMin",[i[0]],c.shape.length);const u=DH(n,c,i[0],"min");return l.forEach(e=>n.disposeIntermediateTensorInfo(e)),u}},LH=qU({opSnippet:vU+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),zH={kernelName:ph,backendName:"webgl",kernelFunc:LH},BH=qU({opSnippet:vU+"return log(x + sqrt(x * x + 1.0));"}),jH={kernelName:fh,backendName:"webgl",kernelFunc:BH},WH=qU({opSnippet:vU+"\n  return atan(x);\n"}),VH={kernelName:mh,backendName:"webgl",kernelFunc:WH},UH=KU({opSnippet:AU+"\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+PU+"\n  return result;\n"}),HH={kernelName:yh,backendName:"webgl",kernelFunc:UH},GH=qU({opSnippet:vU+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),qH={kernelName:gh,backendName:"webgl",kernelFunc:GH};class KH{constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const r=e.filterWidth,i=e.strideHeight,o=e.strideWidth,c=e.dilationHeight,l=e.dilationWidth,u=e.effectiveFilterHeight,h=e.effectiveFilterWidth,d=e.padInfo.top,p=e.padInfo.left;this.outputShape=e.outShape;const f="avg"===t,m="((batch  * ".concat(e.inHeight," + xR) * ").concat(e.inWidth," + xC) * ").concat(e.inChannels," + d"),g="(xR * ".concat(e.inWidth," + xC) * ").concat(e.inChannels," + d");let y="0.0";if(f||(y="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode="\n        const ivec2 strides = ivec2(".concat(i,", ").concat(o,");\n        const ivec2 pads = ivec2(").concat(d,", ").concat(p,");\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ").concat(u,";\n              wR += ").concat(c,") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ").concat(e.inHeight,") {\n              continue;\n            }\n\n            for (int wC = 0; wC < ").concat(h,";\n                wC += ").concat(l,") {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ").concat(t," currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ").concat(a?s?m:g:"wR * ".concat(h," + wC"),";\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      "))}let b="".concat(t,"(").concat(t,"(").concat(t,"(")+"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"avg"===t&&(b="avgValue / max(count, 1.0)");const x=4*Math.floor(r/4),v=r%4,w="\n      if (".concat(f,") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ").concat("max","(values, minMaxValue);\n      }\n    ");this.userCode="\n      const ivec2 strides = ivec2(".concat(i,", ").concat(o,");\n      const ivec2 pads = ivec2(").concat(d,", ").concat(p,");\n      const float initializationValue = ").concat(y,";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ").concat(e.inWidth,") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(").concat(y,");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ").concat(u,";\n            wR += ").concat(c,") {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ").concat(e.inHeight,") {\n            continue;\n          }\n\n          for (int wC = 0; wC < ").concat(x,"; wC += 4) {\n            int xC = xCCorner + wC * ").concat(l,";\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ").concat(l,", d),\n              getValue(batch, xR, xC + 2 * ").concat(l,", d),\n              getValue(batch, xR, xC + 3 * ").concat(l,", d)\n            );\n\n            ").concat(w,"\n          }\n\n          int xC = xCCorner + ").concat(x,";\n          if (").concat(1===v,") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ").concat(w,"\n          } else if (").concat(2===v,") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ").concat(l,", d),\n              initializationValue,\n              initializationValue\n            );\n\n            ").concat(w,"\n          } else if (").concat(3===v,") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ").concat(l,", d),\n              getValue(batch, xR, xC + 2 * ").concat(l,", d),\n              initializationValue\n            );\n\n            ").concat(w,"\n          }\n        }\n        setOutput(").concat(b,");\n      }\n    ")}}class XH{constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const r=e.filterWidth,i=e.strideDepth,o=e.strideHeight,c=e.strideWidth,l=e.dilationDepth,u=e.dilationHeight,h=e.dilationWidth,d=e.effectiveFilterDepth,p=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=e.padInfo.front,g=e.padInfo.top,y=e.padInfo.left;this.outputShape=e.outShape;const b="avg"===t;let x="0.0";if(b||(x="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode="\n        const ivec3 strides =\n            ivec3(".concat(i,", ").concat(o,", ").concat(c,");\n        const ivec3 pads = ivec3(").concat(m,", ").concat(g,", ").concat(y,");\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ").concat(d,";\n              wD += ").concat(l,") {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ").concat(e.inDepth,") {\n              continue;\n            }\n\n            for (int wR = 0; wR < ").concat(p,";\n                wR += ").concat(u,") {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ").concat(e.inHeight,") {\n                continue;\n              }\n\n              for (int wC = 0; wC < ").concat(f,";\n                  wC += ").concat(h,") {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ").concat(t," currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ").concat(a?s?"(((batch * ".concat(e.inDepth," + xD) * ").concat(e.inHeight," + xR) * ").concat(e.inWidth," + xC) * ").concat(e.inChannels," + ch"):"((xD * ".concat(e.inHeight," + xR) * ").concat(e.inWidth," + xC) * ").concat(e.inChannels," + ch"):"wD * ".concat(p," * ").concat(f," +\n                      wR * ").concat(f," + wC"),";\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      "))}let v="".concat(t,"(").concat(t,"(").concat(t,"(")+"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"avg"===t&&(v="avgValue / max(count, 1.0)");const w=4*Math.floor(r/4),k=r%4,S="\n      if (".concat(b,") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ").concat("max","(values, minMaxValue);\n      }\n    ");this.userCode="\n      const ivec3 strides =\n        ivec3(".concat(i,", ").concat(o,", ").concat(c,");\n      const ivec3 pads = ivec3(").concat(m,", ").concat(g,", ").concat(y,");\n      const float initializationValue = ").concat(x,";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ").concat(e.inWidth,") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(").concat(x,");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ").concat(d,";\n            wD += ").concat(l,") {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ").concat(e.inDepth,") {\n            continue;\n          }\n\n          for (int wR = 0; wR < ").concat(p,";\n            wR += ").concat(u,") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ").concat(e.inHeight,") {\n              continue;\n            }\n\n            for (int wC = 0; wC < ").concat(w,"; wC += 4) {\n              int xC = xCCorner + wC * ").concat(h,";\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ").concat(h,", ch),\n                getValue(batch, xD, xR, xC + 2 * ").concat(h,", ch),\n                getValue(batch, xD, xR, xC + 3 * ").concat(h,", ch)\n              );\n\n              ").concat(S,"\n            }\n\n            int xC = xCCorner + ").concat(w,";\n            if (").concat(1===k,") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ").concat(S,"\n            } else if (").concat(2===k,") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ").concat(h,", ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ").concat(S,"\n            } else if (").concat(3===k,") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ").concat(h,", ch),\n                getValue(batch, xD, xR, xC + 2 * ").concat(h,", ch),\n                initializationValue\n              );\n\n              ").concat(S,"\n            }\n          }\n        }\n        setOutput(").concat(v,");\n      }\n    ")}}const YH={kernelName:bh,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t;NW(s,"avgPool");const{filterSize:r,strides:i,pad:o,dimRoundingMode:c}=a;yu(Zb(i,1),()=>"Error in avgPool: Either strides or dilations must be 1. "+"Got strides ".concat(i," and dilations '").concat(1,"'"));const l=Wb(s.shape,r,i,1,o,c);if(1===l.filterWidth&&1===l.filterHeight&&ku(l.inShape,l.outShape))return OU({inputs:{x:s},backend:n});const u=new KH(l,"avg",!1);return n.runWebGLProgram(u,[s],"float32")}};const QH={kernelName:vh,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{filterSize:r,strides:i,pad:o,dimRoundingMode:c,dataFormat:l}=a,u=Vb(s.shape,r,i,[1,1,1],o,c,l),h=new XH(u,"avg",!1);return n.runWebGLProgram(h,[s],"float32")}};class ZH{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,a=e.strideHeight,s=e.strideWidth,r=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterHeight,c=e.effectiveFilterWidth,l=o-1-e.padInfo.top,u=c-1-e.padInfo.left,h=1/(t*n);this.userCode="\n      const ivec2 pads = ivec2(".concat(l,", ").concat(u,");\n      const float avgMultiplier = float(").concat(h,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(o,";\n            wR += ").concat(r,") {\n          float dyR = float(dyRCorner + wR) / ").concat(a,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ").concat(c,";\n            wC+= ").concat(i,") {\n            float dyC = float(dyCCorner + wC) / ").concat(s,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class JH{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,a=e.filterWidth,s=e.strideDepth,r=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,c=e.dilationHeight,l=e.dilationWidth,u=e.effectiveFilterDepth,h=e.effectiveFilterHeight,d=e.effectiveFilterWidth,p=u-1-e.padInfo.front,f=h-1-e.padInfo.top,m=d-1-e.padInfo.left,g=1/(t*n*a);this.userCode="\n      const ivec3 pads = ivec3(".concat(p,", ").concat(f,", ").concat(m,");\n      const float avgMultiplier = float(").concat(g,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ").concat(u,";\n            wD += ").concat(o,") {\n          float dyD = float(dyDCorner + wD) / ").concat(s,".0;\n\n          if (dyD < 0.0 || dyD >= ").concat(e.outDepth,".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ").concat(h,";\n              wR += ").concat(c,") {\n            float dyR = float(dyRCorner + wR) / ").concat(r,".0;\n\n            if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ").concat(d,";\n                wC += ").concat(l,") {\n              float dyC = float(dyCCorner + wC) / ").concat(i,".0;\n\n              if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}const $H={kernelName:wh,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:s,input:r}=t,i=r,{filterSize:o,strides:c,pad:l,dimRoundingMode:u}=a,h=Vb(i.shape,o,c,[1,1,1],l,u),d=new JH(h);return n.runWebGLProgram(d,[s],i.dtype)}};const eG={kernelName:xh,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:s,input:r}=t,i=r;NW([s,r],"avgPoolGrad");const{filterSize:o,strides:c,pad:l}=a,u=Wb(i.shape,o,c,1,l),h=new ZH(u);return n.runWebGLProgram(h,[s],i.dtype)}};const tG={kernelName:kh,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{a:s,b:r}=t,{transposeA:i,transposeB:o}=a;return fH({a:s,b:r,transposeA:i,transposeB:o,backend:n})}};class nG{constructor(e,t,n,a,s,r){this.outputShape=[],this.variableNames=["x","mean","variance"],Ry(e,t),Ry(e,n);let i="0.0";null!=a&&(Ry(e,a),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="1.0";null!=s&&(Ry(e,s),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode="\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ".concat(i,";\n        float scale = ").concat(o,";\n        float inv = scale * inversesqrt(variance + float(").concat(r,"));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    ")}}class aG{constructor(e,t,n,a,s,r){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Ry(e,t),Ry(e,n);let i="vec4(0.0)";null!=a&&(Ry(e,a),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="vec4(1.0)";null!=s&&(Ry(e,s),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode="\n      void main() {\n        vec4 offset = ".concat(i,";\n        vec4 scale = ").concat(o,";\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(").concat(r,"));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    ")}}const sG={kernelName:fd,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:a}=e;const{x:s,mean:r,variance:i,offset:o,scale:c}=t;yu(r.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),yu(null==o||r.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),yu(null==c||r.shape.length===c.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=a;null==l&&(l=.001);const u=[s,r,i];let h=null;null!=o&&(h=o.shape,u.push(o));let d=null;null!=c&&(d=c.shape,u.push(c));const p=$u().getBool("WEBGL_PACK_NORMALIZATION")?new aG(s.shape,r.shape,i.shape,h,d,l):new nG(s.shape,r.shape,i.shape,h,d,l);return n.runWebGLProgram(p,u,u[0].dtype)}};class rG{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=HW(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=function(e){if(1===e)return"sourceLoc";if(e<=6)return iG.slice(0,e).map(e=>"sourceLoc."+e).join(",");throw Error("Slicing for rank ".concat(e," is not yet supported"))}(this.rank);let a;const s=e.map((e,t)=>"sourceLoc.".concat(iG[t]," = start[").concat(t,"] + coords.").concat(iG[t],";"));a="\n        ".concat(t," sourceLoc;\n        ").concat(t," coords = getOutputCoords();\n        ").concat(s.join("\n"),"\n      "),this.userCode="\n      void main() {\n        ".concat(a,"\n        setOutput(getSource(").concat(n,"));\n      }\n    ")}}const iG=["x","y","z","w","u","v"];class oG{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=HW(this.rank),n=dU("coords",this.rank),a=dU("sourceLoc",this.rank),s=1===this.rank?"sourceLoc":"vec2(".concat(a.slice(-2).join(),")"),r="getChannel(getSource(".concat(a.join(),"), ").concat(s,")"),i="\n      result.x = ".concat(r,";\n      if (++").concat(n[this.rank-1]," < ").concat(e[this.rank-1],") {\n        ++").concat(a[this.rank-1],";\n        result.y = ").concat(r,";\n        --").concat(a[this.rank-1],";\n      }\n    "),o=1===this.rank?"":"\n      --".concat(n[this.rank-1],";\n      if (++").concat(n[this.rank-2]," < ").concat(e[this.rank-2],") {\n        ++").concat(a[this.rank-2],";\n        result.z = ").concat(r,";\n        if (++").concat(n[this.rank-1]," < ").concat(e[this.rank-1],") {\n          ++").concat(a[this.rank-1],";\n          result.w = ").concat(r,";\n        }\n      }\n    "),c=this.rank<=4?"sourceLoc = coords +\n            ".concat(t,"(").concat(e.map((e,t)=>"start[".concat(t,"]")).join(),");"):e.map((e,t)=>"".concat(a[t]," = ").concat(n[t]," + start[").concat(t,"];")).join("\n");this.userCode="\n      void main() {\n        ".concat(t," coords = getOutputCoords();\n        ").concat(t," sourceLoc;\n        ").concat(c,"\n        vec4 result = vec4(0.);\n        ").concat(i,"\n        ").concat(o,"\n        setOutput(result);\n      }\n    ")}}function cG(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{begin:r,size:i}=a,[o,c]=Ib(s,r,i);if(hb(s,o,c),0===vu(c))return n.makeTensorInfo(c,s.dtype,[]);if(n.shouldExecuteOnCPU([s])||"string"===s.dtype){const e=n.texData.get(s.dataId),t=QV(e.values,o,c,s.shape,s.dtype);return n.makeTensorInfo(c,s.dtype,t)}const{isPacked:l}=n.texData.get(s.dataId),u=Sb(s.shape,o,c);if(l||!u){const e=$u().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new oG(c):new rG(c),t=[o];return n.runWebGLProgram(e,[s],s.dtype,t)}return n.uploadToGPU(s.dataId),function(e,t,n,a){const s=a.texData.get(e.dataId),r=a.makeTensorInfo(n,e.dtype),i=a.texData.get(r.dataId);Object.assign(i,s),i.refCount=1,i.shape=n,i.dtype=e.dtype;let o=Cb(t,Bu(e.shape));s.slice&&(o+=s.slice.flatOffset),i.slice={flatOffset:o,origDataId:s.slice&&s.slice.origDataId||e.dataId};const c=a.dataRefCount.get(i.slice.origDataId)||1;return a.dataRefCount.set(i.slice.origDataId,c+1),r}(s,o,c,n)}const lG={kernelName:Rp,backendName:"webgl",kernelFunc:cG},uG={kernelName:Sh,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{blockShape:r,crops:i}=a;yu(s.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const o=r.reduce((e,t)=>e*t),c=oC(s.shape,r,o),l=cC(c.length,r.length),u=lC(s.shape,r,o),h=uC(i,r.length),d=hC(u,i,r.length),p=[],f=nH({inputs:{x:s},backend:n,attrs:{shape:c}}),m=dH({inputs:{x:f},backend:n,attrs:{perm:l}}),g=nH({inputs:{x:m},backend:n,attrs:{shape:u}}),y=cG({inputs:{x:g},backend:n,attrs:{begin:h,size:d}});return p.push(f),p.push(m),p.push(g),p.forEach(e=>n.disposeIntermediateTensorInfo(e)),y}};const hG={kernelName:Ch,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,weights:r}=t,{size:i}=a,o=n.readSync(s.dataId),c=n.readSync(r.dataId),l=yV(o,c,r.dtype,r.shape,i);return n.makeTensorInfo([i],r.dtype,l)}};const dG={kernelName:Ih,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{a:a,b:s}=t,r=$u().getBool("WEBGL_PACK_BINARY_OPERATIONS"),i=$u().getNumber("WEBGL_VERSION");if(n.shouldExecuteOnCPU([a,s])||1===i){const e=n.texData.get(a.dataId).values,t=n.texData.get(s.dataId).values,[r,i]=xV(a.shape,s.shape,e,t,a.dtype),o=n.makeTensorInfo(i,a.dtype);return n.texData.get(o.dataId).values=r,o}let o;return o=r?new DU("\n  int r = int(a.r) & int(b.r);\n  int g = int(a.g) & int(b.g);\n  int rb = int(a.b) & int(b.b);\n  int ra = int(a.a) & int(b.a);\n  return vec4(r, g, rb, ra);\n",a.shape,s.shape,!1):new MU("\n  return float(int(a.r) & int(b.r));\n",a.shape,s.shape),n.runWebGLProgram(o,[a,s],a.dtype)}};const pG={kernelName:Nh,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{s0:a,s1:s}=t,r=n.readSync(a.dataId),i=n.readSync(s.dataId),o=Ry(Array.from(r),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}},fG=KU({opSnippet:"return float(a != b);",cpuKernelImpl:jV,dtype:"bool"}),mG={kernelName:Zd,backendName:"webgl",kernelFunc:fG};function gG(e){const{inputs:t,backend:n}=e,{input:a}=t;return OU({inputs:{x:n.texData.get(a.dataId).complexTensorInfos.real},backend:n})}const yG={kernelName:dp,backendName:"webgl",kernelFunc:gG};const bG={kernelName:Th,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:a,attrs:s}=t,{x:r}=n,{dtype:i}=s;if("complex64"===i){if("complex64"===r.dtype)return OU({inputs:{x:r},backend:a});const t=Gv(r.shape),n=e({inputs:{x:r},backend:a,attrs:{dtype:"float32"}}),s=LU({inputs:{real:n,imag:t},backend:a});return t.dispose(),a.disposeIntermediateTensorInfo(n),s}if("complex64"===r.dtype){const t=gG({inputs:{input:r},backend:a}),n=e({inputs:{x:t},backend:a,attrs:{dtype:i}});return a.disposeIntermediateTensorInfo(t),n}if(!Mu(r.dtype,i)){const e=OU({inputs:{x:r},backend:a});return{dataId:e.dataId,shape:e.shape,dtype:i}}if(a.shouldExecuteOnCPU([r])){const e=a.texData.get(r.dataId).values,[t,n,s]=vV(e,r.shape,r.dtype,i);return a.makeTensorInfo(t,n,s)}if("int32"===i)return function(e,t){const n=new xU(e.shape,"return float(int(x));"),a=t.runWebGLProgram(n,[e],"int32");return{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}(r,a);if("bool"===i){const e=a.makeTensorInfo([],"bool",_u("bool",1)),t=fG({inputs:{a:r,b:e},backend:a});return a.disposeIntermediateTensorInfo(e),t}throw new Error("Error in Cast: failed to cast ".concat(r.dtype," to ").concat(i))}},xG="return ceil(x);",vG=qU({opSnippet:xG,packedOpSnippet:xG,cpuKernelImpl:wV}),wG={kernelName:Eh,backendName:"webgl",kernelFunc:vG};class kG{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}class SG{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}const CG={kernelName:Rh,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{clipValueMin:r,clipValueMax:i}=a;let o;o=$u().getBool("WEBGL_PACK_CLIP")?new SG(s.shape):new kG(s.shape);const c=[[r],[i]];return n.runWebGLProgram(o,[s],s.dtype,c)}};class IG{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function NG(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}const TG={kernelName:Ah,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t,s=n.texData.get(a.dataId),r=new IG(a.shape),i=[NG(a,s.complexTensorInfos.real),NG(a,s.complexTensorInfos.imag)];return n.runWebGLProgram(r,i,i[0].dtype)}};class EG{constructor(e){this.outputShape=[],this.outputShape=JS(e,1),this.variableNames=e.map((e,t)=>"T".concat(t));const t=new Array(e.length-1);t[0]=e[0][1];for(let r=1;r<t.length;r++)t[r]=t[r-1]+e[r][1];const n=["if (yC < ".concat(t[0],") setOutput(getT0(yR, yC));")];for(let r=1;r<t.length;r++){const e=t[r-1];n.push("else if (yC < ".concat(t[r],") ")+"setOutput(getT".concat(r,"(yR, yC-").concat(e,"));"))}const a=t.length,s=t[t.length-1];n.push("else setOutput(getT".concat(a,"(yR, yC-").concat(s,"));")),this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ".concat(n.join("\n        "),"\n      }\n    ")}}class RG{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=JS(e,t);const n=this.outputShape,a=n.length,s=HW(a),r=dU("coords",a),i=["x","y","z","w","u","v"].slice(0,a);this.variableNames=e.map((e,t)=>"T".concat(t));const o=new Array(e.length-1);o[0]=e[0][t];for(let f=1;f<o.length;f++)o[f]=o[f-1]+e[f][t];const c=i[t],l=i.slice(-2),u=i.join();let h="if (".concat(c," < ").concat(o[0],") {\n        return getChannel(\n            getT0(").concat(u,"), vec2(").concat(l.join(),"));\n        }");for(let f=1;f<o.length;f++){const e=o[f-1];h+="\n        if (".concat(c," < ").concat(o[f],"  && ").concat(c," >= ").concat(o[f-1],") {\n          return getChannel(\n            getT").concat(f,"(").concat(_G(i,c,e),"),\n            vec2(").concat(_G(l,c,e),"));\n        }")}const d=o.length,p=o[o.length-1];h+="\n        return getChannel(\n          getT".concat(d,"(").concat(_G(i,c,p),"),\n          vec2(").concat(_G(l,c,p),"));"),this.userCode="\n      float getValue(".concat(i.map(e=>"int "+e),") {\n        ").concat(h,"\n      }\n\n      void main() {\n        ").concat(s," coords = getOutputCoords();\n        vec4 result = vec4(getValue(").concat(r,"), 0., 0., 0.);\n\n        ").concat(r[a-1]," = ").concat(r[a-1]," + 1;\n        if (").concat(r[a-1]," < ").concat(n[a-1],") {\n          result.g = getValue(").concat(r,");\n        }\n\n        ").concat(r[a-2]," = ").concat(r[a-2]," + 1;\n        if (").concat(r[a-2]," < ").concat(n[a-2],") {\n          result.a = getValue(").concat(r,");\n        }\n\n        ").concat(r[a-1]," = ").concat(r[a-1]," - 1;\n        if (").concat(r[a-2]," < ").concat(n[a-2]," &&\n            ").concat(r[a-1]," < ").concat(n[a-1],") {\n          result.b = getValue(").concat(r,");\n        }\n        setOutput(result);\n      }\n    ")}}function _G(e,t,n){const a=e.indexOf(t);return e.map((e,t)=>t===a?"".concat(e," - ").concat(n):e).join()}function AG(e){const{inputs:t,backend:n}=e,{input:a}=t;return OU({inputs:{x:n.texData.get(a.dataId).complexTensorInfos.imag},backend:n})}const MG={kernelName:wd,backendName:"webgl",kernelFunc:AG};function PG(e,t,n){const a=e[0].dtype;if("complex64"===a){const a=e.map(e=>gG({inputs:{input:e},backend:n})),s=e.map(e=>AG({inputs:{input:e},backend:n})),r=PG(a,t,n),i=PG(s,t,n),o=LU({inputs:{real:r,imag:i},backend:n});return a.forEach(e=>n.disposeIntermediateTensorInfo(e)),s.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(i),o}let s=n.shouldExecuteOnCPU(e);if("string"===a&&(s=!0),s){const s=e.map(e=>{const a=vu(e.shape.slice(t));return nH({inputs:{x:e},backend:n,attrs:{shape:[-1,a]}})}),r=s.map(e=>({vals:n.readSync(e.dataId),shape:e.shape})),i=JS(s.map(e=>e.shape),1),o=1===s[0].shape[0],c=kV(r,i,a,o),l=JS(e.map(e=>e.shape),t),u=n.makeTensorInfo(l,a,c);return s.forEach(e=>n.disposeIntermediateTensorInfo(e)),u}const r=e.filter(e=>vu(e.shape)>0),i=$u().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&r[0].shape.length>1;if(1===r.length){const t=i?new xU(e[0].shape,CU):new IU(e[0].shape,CU);return n.runWebGLProgram(t,e,a)}const o=$u().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(r.length>o){const e=[];for(let s=0;s<r.length;s+=o){const a=r.slice(s,s+o);e.push(PG(a,t,n))}const a=PG(e,t,n);for(const t of e)n.disposeIntermediateTensorInfo(t);return a}if(i){const e=new RG(r.map(e=>e.shape),t);return n.runWebGLProgram(e,r,a)}const{tensors2D:c,outShape:l}=function(e,t,n){const a=JS(e.map(e=>e.shape),t),s=e.map(e=>nH({inputs:{x:e},attrs:{shape:[-1,vu(e.shape.slice(t))]},backend:n}));return{tensors2D:s,outShape:a}}(r,t,n),u=new EG(c.map(e=>e.shape)),h=n.runWebGLProgram(u,c,a);c.forEach(e=>n.disposeIntermediateTensorInfo(e));const d=nH({inputs:{x:h},attrs:{shape:l},backend:n});return n.disposeIntermediateTensorInfo(h),d}function DG(e){const{inputs:t,backend:n,attrs:a}=e,{axis:s}=a,r=Eu(s,t[0].shape)[0];ZS(t.map(e=>e.shape),r);const i=JS(t.map(e=>e.shape),r);if(0===vu(i))return n.makeTensorInfo(i,t[0].dtype,[]);const o=t.filter(e=>vu(e.shape)>0);return 1===o.length?OU({inputs:{x:o[0]},backend:n}):PG(o,r,n)}const OG={kernelName:Mh,backendName:"webgl",kernelFunc:DG};class FG{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.outputShape=e.outShape;const r=e.padInfo.top,i=e.padInfo.left,o=e.strideHeight,c=e.strideWidth,l=e.dilationHeight,u=e.dilationWidth,h=e.filterHeight,d=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4,m="channelsLast"===e.dataFormat,g=m?1:2,y=m?2:3,b=m?3:1;let x="",v="";n&&(x=a?"float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ".concat(n,"\n        }"):s?"float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ".concat(n,"\n        }"):"\n          float activation(float x) {\n            ".concat(n,"\n          }\n        "),v="result = activation(result);");const w=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n      ".concat(x,"\n\n      const ivec2 strides = ivec2(").concat(o,", ").concat(c,");\n      const ivec2 pads = ivec2(").concat(r,", ").concat(i,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[").concat(b,"];\n\n        ivec2 xRCCorner =\n            ivec2(coords[").concat(g,"], coords[").concat(y,"]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(h,"; wR++) {\n          int xR = xRCorner + wR * ").concat(l,";\n\n          if (xR < 0 || xR >= ").concat(e.inHeight,") {\n            continue;\n          }\n\n          for (int wC = 0; wC < ").concat(d,"; wC++) {\n            int xC = xCCorner + wC * ").concat(u,";\n\n            if (xC < 0 || xC >= ").concat(e.inWidth,") {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ").concat(p,"; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (").concat(m,") {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (").concat(1===f,") {\n\n              if (").concat(m,") {\n                dotProd +=\n                    getX(batch, xR, xC, ").concat(p,") *\n                    getW(wR, wC, ").concat(p,", d2);\n              } else {\n                dotProd +=\n                    getX(batch, ").concat(p,", xR, xC) *\n                    getW(wR, wC, ").concat(p,", d2);\n              }\n\n            } else if (").concat(2===f,") {\n              vec2 wValues = vec2(\n                getW(wR, wC, ").concat(p,", d2),\n                getW(wR, wC, ").concat(p," + 1, d2)\n              );\n\n              if (").concat(m,") {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ").concat(p,"),\n                  getX(batch, xR, xC, ").concat(p," + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ").concat(p,", xR, xC),\n                  getX(batch, ").concat(p," + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (").concat(3===f,") {\n              vec3 wValues = vec3(\n                getW(wR, wC, ").concat(p,", d2),\n                getW(wR, wC, ").concat(p," + 1, d2),\n                getW(wR, wC, ").concat(p," + 2, d2)\n              );\n\n              if (").concat(m,") {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ").concat(p,"),\n                  getX(batch, xR, xC, ").concat(p," + 1),\n                  getX(batch, xR, xC, ").concat(p," + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ").concat(p,", xR, xC),\n                  getX(batch, ").concat(p," + 1, xR, xC),\n                  getX(batch, ").concat(p," + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ").concat(w,"\n        ").concat(v,"\n        setOutput(result);\n      }\n    ")}}class LG{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,n=e.padInfo.top,a=e.padInfo.left,s=e.strideDepth,r=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,c=e.dilationHeight,l=e.dilationWidth,u=e.filterDepth,h=e.filterHeight,d=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4;this.userCode="\n      const ivec3 strides = ivec3(".concat(s,", ").concat(r,", ").concat(i,");\n      const ivec3 pads = ivec3(").concat(t,", ").concat(n,", ").concat(a,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ").concat(u,"; wF++) {\n          int xF = xFCorner + wF * ").concat(o,";\n\n          if (xF < 0 || xF >= ").concat(e.inDepth,") {\n            continue;\n          }\n\n          for (int wR = 0; wR < ").concat(h,"; wR++) {\n            int xR = xRCorner + wR * ").concat(c,";\n\n            if (xR < 0 || xR >= ").concat(e.inHeight,") {\n              continue;\n            }\n\n            for (int wC = 0; wC < ").concat(d,"; wC++) {\n              int xC = xCCorner + wC * ").concat(l,";\n\n              if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ").concat(p,"; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (").concat(1===f,") {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ").concat(p,") *\n                  getW(wF, wR, wC, ").concat(p,", d2);\n              } else if (").concat(2===f,") {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ").concat(p,"),\n                  getX(batch, xF, xR, xC, ").concat(p," + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ").concat(p,", d2),\n                  getW(wF, wR, wC, ").concat(p," + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (").concat(3===f,") {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ").concat(p,"),\n                  getX(batch, xF, xR, xC, ").concat(p," + 1),\n                  getX(batch, xF, xR, xC, ").concat(p," + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ").concat(p,", d2),\n                  getW(wF, wR, wC, ").concat(p," + 1, d2),\n                  getW(wF, wR, wC, ").concat(p," + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class zG{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=ZW(this.outputShape.length);const r=e.padInfo.left,i=e.strideWidth,o=e.dilationWidth,c=e.filterHeight,l=e.filterWidth,u=l;let h="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let m=0;m<l;m++)h+="\n           vec4 xTexelC".concat(2*m,";\n           int xTexelC").concat(2*m,"Ready;\n           vec4 xTexelC").concat(2*m+1,";\n           int xTexelC").concat(2*m+1,"Ready;\n           vec4 xC").concat(m,";");h+="\n     for (int r = 0; r < ".concat(c,"; r++) {\n      for (int d1 = 0; d1 < ").concat(e.inChannels,"; d1 += 2) {\n       ");for(let m=0;m<l;m++)h+="\n           xTexelC".concat(2*m," = vec4(0.0);\n           xTexelC").concat(2*m,"Ready = 0;\n           xTexelC").concat(2*m+1," = vec4(0.0);\n           xTexelC").concat(2*m+1,"Ready = 0;\n           xC").concat(m," = vec4(0.0);");h+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let m=0;m<(u+1)/2;m++){const t=2*m;if(h+="\n           xC = xCCorner + ".concat(t*o,";\n           "),1===i){if(t<l&&(r%2===1?(h+="\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(t,"Ready == 0) {\n                   xTexelC").concat(t," = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC").concat(t,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(t,"Ready = 1;\n                 }\n               "),h+=1===o&&t>0?"\n                 xC".concat(t," = vec4(xTexelC").concat(t-2,".zw, xTexelC").concat(t,".xy);\n                 "):"\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC".concat(t," = vec4(previous.zw, xTexelC").concat(t,".xy);\n                   } else {\n                     xC").concat(t," = vec4(0.0, 0.0, xTexelC").concat(t,".xy);\n                   }\n                   ")):h+="\n                 if (xC >= 0 && xC < inDims[1] && xTexelC".concat(t,"Ready == 0) {\n                   xTexelC").concat(t," = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC").concat(t,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(t,"Ready = 1;\n                 }\n\n                 xC").concat(t," = xTexelC").concat(t,";\n                 "),t+1<l)){const e=r%2===0?fu(o):o;o%2===0&&r%2===1||o%2!==0&&r%2!==1?(h+="\n                   xCOffset = xC + imod(pads[1], 2) + ".concat(e,";\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(t+1,"Ready == 0) {\n                     xTexelC").concat(t+1," = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC").concat(t+1,".zw = vec2(0.0);\n                     }\n                     xTexelC").concat(t+1,"Ready = 1;\n                   }\n                   "),h+=o>1?"\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC".concat(t+1," = vec4(previous.zw, xTexelC").concat(t+1,".xy);\n                     } else {\n                      xC").concat(t+1," = vec4(0.0, 0.0, xTexelC").concat(t+1,".xy);\n                     }\n                     "):"\n                     xC".concat(t+1," = vec4(xTexelC").concat(t,".zw, xTexelC").concat(t+1,".xy);\n                     ")):h+=1===e?"\n                     xC".concat(t+1," = xTexelC").concat(t,";\n                     "):"\n                     xCOffset = xC + ".concat(e,";\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(t+1,"Ready == 0) {\n                       xTexelC").concat(t+1," = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC").concat(t+1,".zw = vec2(0.0);\n                       }\n                       xTexelC").concat(t+1,"Ready = 1;\n                     }\n\n                     xC").concat(t+1," = xTexelC").concat(t+1,";\n                     ")}}else t<l&&(r%2===1?(h+="\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(t,"Ready == 0) {\n                   xTexelC").concat(t," = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC").concat(t,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(t,"Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC").concat(t+1,"Ready == 0) {\n                   xTexelC").concat(t+1," = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC").concat(t+1,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(t+1,"Ready = 1;\n                 }\n\n                 xC").concat(t," = vec4(xTexelC").concat(t,".zw, xTexelC").concat(t+1,".zw);\n               "),t+1<l&&(h+="\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC".concat(t+1," = vec4(xTexelC").concat(t+1,".xy, final.xy);\n                 "))):(h+="\n                 if(xC >= 0 && xC < inDims[1] && xTexelC".concat(t,"Ready == 0) {\n                   xTexelC").concat(t," = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC").concat(t,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(t,"Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(t+1,"Ready == 0) {\n                   xTexelC").concat(t+1," = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC").concat(t+1,".zw = vec2(0.);\n                   }\n                   xTexelC").concat(t+1,"Ready = 1;\n                 }\n\n                 xC").concat(t," = vec4(\n                   xTexelC").concat(t,".xy, xTexelC").concat(t+1,".xy);\n               "),t+1<l&&(h+="\n                   xC".concat(t+1," = vec4(xTexelC").concat(t,".zw, xTexelC").concat(t+1,".zw);\n                 "))));t<l&&(h+="\n             wTexel = getW(r, ".concat(t,", d1, d2);\n             dotProd += xC").concat(t,".xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ").concat(e.inChannels,") {\n               dotProd += xC").concat(t,".yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           "),t+1<l&&(h+="\n               wTexel = getW(r, ".concat(t+1,", d1, d2);\n               dotProd += xC").concat(t+1,".xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ").concat(e.inChannels,") {\n                 dotProd += xC").concat(t+1,".yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             ")))}h+="\n     }\n   ",h+="\n     }\n   ",h+="\n     }\n   ";let d="",p="";n&&(d=a?"vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ".concat(n,"\n         }"):s?"vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ".concat(n,"\n         }"):"vec4 activation(vec4 x) {\n           ".concat(n,"\n         }"),p="result = activation(result);");const f=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n       ".concat(d,"\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ").concat(h,"\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ").concat(f,"\n         ").concat(p,"\n         setOutput(result);\n       }\n     ")}}class BG{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=ZW(this.outputShape.length);const{dataFormat:n}=t,a=EW(),s="channelsLast"===n,r=s?1:2,i=s?2:3,o=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":"if(blockIndex < ".concat(e[2]," && pos < ").concat(e[1],") {");let c="";for(let l=0;l<=1;l++)for(let e=0;e<=1;e++)c+="\n          blockIndex = rc.z + ".concat(e,";\n          pos = rc.y + ").concat(l,";\n\n          ").concat(o,"\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[").concat(r,"] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[").concat(i,"] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (").concat(s,") {\n                  innerDims = vec2(d1, ch);\n                  result[").concat(2*l+e,"] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[").concat(2*l+e,"] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        ");this.userCode="\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ".concat(c,"\n\n        ").concat(a.output," = result;\n      }\n    ")}}function jG(e,t){const n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&1===n&&e[0]>1?[e[0],1]:null}function WG(e){let{x:t,filter:n,convInfo:a,backend:s,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:c=null}=e;const l=t.shape,u=s.texData.get(t.dataId),h=a.inChannels,d=l[0]*l[1]*l[2],p=a.outChannels,f="channelsLast"===a.dataFormat,m=!1;let g;const y=[];if(null!=i){const e=jG(i.shape,f);null!=e&&(i=nH({inputs:{x:i},backend:s,attrs:{shape:e}}),y.push(i))}if(null!=r){const e=jG(r.shape,f);null!=e&&(r=nH({inputs:{x:r},backend:s,attrs:{shape:e}}),y.push(r))}if(!((1===d||1===p)&&h>1e3)&&u.isPacked&&f&&null!=u.texture&&l[2]%2!==0&&ku(u.shape.slice(-3),l.slice(-3))){const e=l[0]*l[1]*(l[2]+1),h={dataId:t.dataId,shape:[1,e,a.inChannels],dtype:t.dtype},d=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,yu(xW(u.shape,h.shape),()=>"packed reshape ".concat(u.shape," to ").concat(h.shape," isn't free"));const p=nH({inputs:{x:n},backend:s,attrs:{shape:[1,a.inChannels,a.outChannels]}});y.push(p);const f=fH({a:h,b:p,backend:s,transposeA:false,transposeB:m,bias:r,activation:c,preluActivationWeights:i,leakyreluAlpha:o}),b=s.texData.get(f.dataId);yu(b.isPacked,()=>"batchMatMul result is expected to be packed"),u.shape=d,b.shape=a.outShape,g=OU({inputs:{x:f},backend:s}),g.shape=a.outShape,y.push(f)}else{const e=a.outHeight*a.outWidth,l=nH({inputs:{x:t},backend:s,attrs:{shape:f?[a.batchSize,e,a.inChannels]:[a.batchSize,a.inChannels,e]}}),u=nH({inputs:{x:n},backend:s,attrs:{shape:[1,a.inChannels,a.outChannels]}}),h=fH({a:f?l:u,b:f?u:l,transposeA:!f,transposeB:m,backend:s,bias:r,activation:c,preluActivationWeights:i,leakyreluAlpha:o});g=nH({inputs:{x:h},backend:s,attrs:{shape:a.outShape}}),y.push(l),y.push(u),y.push(h)}for(const b of y)s.disposeIntermediateTensorInfo(b);return g}function VG(e){let{x:t,filter:n,convInfo:a,backend:s,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:c=null}=e;const{filterWidth:l,filterHeight:u,inChannels:h,outWidth:d,outHeight:p,dataFormat:f}=a,m="channelsLast"===f,g=l*u*h,y=p*d,b=[a.batchSize,g,y],x=[];if(null!=i){const e=jG(i.shape,m);null!=e&&(i=nH({inputs:{x:i},backend:s,attrs:{shape:e}}),x.push(i))}if(null!=r){const e=jG(r.shape,m);null!=e&&(r=nH({inputs:{x:r},backend:s,attrs:{shape:e}}),x.push(r))}const v=nH({inputs:{x:n},backend:s,attrs:{shape:[1,g,vu(n.shape)/g]}});x.push(v);const w=new BG(b,a),k=[t.shape,[a.padInfo.top,a.padInfo.left],[a.strideHeight,a.strideWidth],[a.dilationHeight,a.dilationWidth],[a.inChannels],[a.filterWidth*a.inChannels],[a.outWidth]],S=s.runWebGLProgram(w,[t],"float32",k),C=nH({inputs:{x:S},backend:s,attrs:{shape:b}});x.push(S),x.push(C);const I=null!=r,N=null!=i,T="leakyrelu"===c,E=c?XU(c,!0):null,R=new YU(m?C.shape:v.shape,m?v.shape:C.shape,m?[a.batchSize,y,a.outChannels]:[a.batchSize,a.outChannels,y],!0,!1,I,E,N,T),_=m?[C,v]:[v,C];if(r&&_.push(r),N&&_.push(i),T){const e=s.makeTensorInfo([],"float32",Wf(o,"float32"));_.push(e),x.push(e)}const A=s.runWebGLProgram(R,_,"float32"),M=nH({inputs:{x:A},backend:s,attrs:{shape:a.outShape}});x.push(A);for(const P of x)s.disposeIntermediateTensorInfo(P);return M}const UG={kernelName:Ph,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,filter:r}=t,{strides:i,pad:o,dataFormat:c,dilations:l,dimRoundingMode:u}=a,h=$b(c),d=Ub(s.shape,r.shape,i,l,o,u,!1,h);let p;if(1!==d.filterHeight||1!==d.filterWidth||1!==d.dilationHeight||1!==d.dilationWidth||1!==d.strideHeight||1!==d.strideWidth||"SAME"!==d.padInfo.type&&"VALID"!==d.padInfo.type)if(d.strideWidth<=2&&"channelsLast"===h&&$u().getBool("WEBGL_EXP_CONV")){const e=new zG(d),t=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];p=n.runWebGLProgram(e,[s,r],"float32",t)}else if($u().getBool("WEBGL_CONV_IM2COL"))p=VG({x:s,filter:r,convInfo:d,backend:n});else{const e=new FG(d);p=n.runWebGLProgram(e,[s,r],"float32")}else p=WG({x:s,filter:r,convInfo:d,backend:n});const f=nH({inputs:{x:p},backend:n,attrs:{shape:d.outShape}});return n.disposeIntermediateTensorInfo(p),f}};class HG{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,a=e.padInfo.top,s=e.padInfo.left,r="channelsLast"===e.dataFormat;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ".concat(e.batchSize,"; b++) {\n          for (int yR = 0; yR < ").concat(e.outHeight,"; yR++) {\n            int xR = wR + yR * ").concat(t," - ").concat(a,";\n\n            if (xR < 0 || xR >= ").concat(e.inHeight,") {\n              continue;\n            }\n\n            for (int yC = 0; yC < ").concat(e.outWidth,"; yC++) {\n              int xC = wC + yC * ").concat(n," - ").concat(s,";\n\n              if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                continue;\n              }\n\n              ").concat(r?"float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);":"float dyValue = getDy(b, d2, yR, yC);\n              float xValue = getX(b, d1, xR, xC);\n              dotProd += (xValue * dyValue);","\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class GG{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,a=e.strideHeight,s=e.strideWidth,r="channelsLast"===e.dataFormat,i=t-1-e.padInfo.top,o=n-1-e.padInfo.left,c=r?1:2,l=r?2:3,u=r?3:1;this.userCode="\n      const ivec2 pads = ivec2(".concat(i,", ").concat(o,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[").concat(u,"];\n\n        ivec2 dyCorner = ivec2(coords[").concat(c,"], coords[").concat(l,"]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(t,"; wR++) {\n          float dyR = float(dyRCorner + wR) / ").concat(a,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ").concat(t," - 1 - wR;\n\n          for (int wC = 0; wC < ").concat(n,"; wC++) {\n            float dyC = float(dyCCorner + wC) / ").concat(s,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ").concat(n," - 1 - wC;\n\n            for (int d2 = 0; d2 < ").concat(e.outChannels,"; d2++) {\n\n              if (").concat(r,") {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class qG{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,n=e.strideHeight,a=e.strideWidth,s=e.padInfo.front,r=e.padInfo.top,i=e.padInfo.left;this.userCode="\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ".concat(e.batchSize,"; b++) {\n          for (int yF = 0; yF < ").concat(e.outDepth,"; yF++) {\n            int xF = wF + yF * ").concat(t," - ").concat(s,";\n\n            if (xF < 0 || xF >= ").concat(e.inDepth,") {\n              continue;\n            }\n\n            for (int yR = 0; yR < ").concat(e.outHeight,"; yR++) {\n              int xR = wR + yR * ").concat(n," - ").concat(r,";\n\n              if (xR < 0 || xR >= ").concat(e.inHeight,") {\n                continue;\n              }\n\n              for (int yC = 0; yC < ").concat(e.outWidth,"; yC++) {\n                int xC = wC + yC * ").concat(a," - ").concat(i,";\n\n                if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class KG{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,a=e.filterWidth,s=e.strideDepth,r=e.strideHeight,i=e.strideWidth,o=t-1-e.padInfo.front,c=n-1-e.padInfo.top,l=a-1-e.padInfo.left;this.userCode="\n      const ivec3 pads = ivec3(".concat(o,", ").concat(c,", ").concat(l,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ").concat(t,"; wF++) {\n          float dyF = float(dyFCorner + wF) / ").concat(s,".0;\n\n          if (dyF < 0.0 || dyF >= ").concat(e.outDepth,".0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ").concat(t," - 1 - wF;\n\n          for (int wR = 0; wR < ").concat(n,"; wR++) {\n            float dyR = float(dyRCorner + wR) / ").concat(r,".0;\n\n            if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ").concat(n," - 1 - wR;\n\n            for (int wC = 0; wC < ").concat(a,"; wC++) {\n              float dyC = float(dyCCorner + wC) / ").concat(i,".0;\n\n              if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ").concat(a," - 1 - wC;\n\n              for (int d2 = 0; d2 < ").concat(e.outChannels,"; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}const XG={kernelName:Dh,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,dy:r}=t,{strides:i,pad:o,dataFormat:c,dimRoundingMode:l,filterShape:u}=a,h=$b(c),d=Ub(s.shape,u,i,1,o,l,!1,h),p=new HG(d);return n.runWebGLProgram(p,[s,r],"float32")}};class YG{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=ZW(this.outputShape.length);const t=e.filterHeight,n=e.filterWidth,a=t-1-e.padInfo.top,s=n-1-e.padInfo.left;this.userCode="\n      const ivec2 pads = ivec2(".concat(a,", ").concat(s,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        vec4 result = vec4(0.);\n        for (int wR = 0; wR < ").concat(t,"; wR++) {\n          float dyR = float(dyRCorner + wR) / strides[0];\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n          int wRPerm = ").concat(t," - 1 - wR;\n\n          for (int wC = 0; wC < ").concat(n,"; wC++) {\n            int wCPerm = ").concat(n," - 1 - wC;\n\n            float dyC = float(dyCCorner + wC) / strides[1];\n            bool idyCVal = (dyC >= 0.0) && (dyC < ").concat(e.outWidth,".0)\n              && (fract(dyC) == 0.0);\n            int idyC = int(dyC);\n\n            float dyC2 = float(dyCCorner + wC + 1) / strides[1];\n            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ").concat(e.outWidth,".0)\n              && (fract(dyC2) == 0.0);\n            int idyC2 = int(dyC2);\n\n            if (idyCVal && idyCVal2) {\n              for (int d2 = 0; d2 < ").concat(e.outChannels,"; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?\n                  dySample : getDy(batch, idyR, idyC2, d2);\n\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n\n                dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample2.xy : dySample2.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal) {\n              for (int d2 = 0; d2 < ").concat(e.outChannels,"; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal2) {\n              for (int d2 = 0; d2 < ").concat(e.outChannels,"; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC2, d2);\n                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            }\n          }\n        }\n        setOutput(result);\n      }\n    ")}}const QG={kernelName:Oh,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:s,filter:r}=t,{inputShape:i,strides:o,pad:c,dataFormat:l,dimRoundingMode:u}=a,h=$b(l),d=Ub(i,r.shape,o,1,c,u,!1,h);if($u().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&"channelsLast"===h){const e=[[d.strideHeight,d.strideWidth]],t=new YG(d);return n.runWebGLProgram(t,[s,r],"float32",e)}{const e=new GG(d);return n.runWebGLProgram(e,[s,r],"float32")}}};const ZG={kernelName:Fh,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,filter:r}=t,{strides:i,pad:o,dilations:c}=a,l=Hb(s.shape,r.shape,i,c,o),u=new LG(l);return n.runWebGLProgram(u,[s,r],"float32")}};const JG={kernelName:Lh,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,dy:r}=t,{strides:i,pad:o,filterShape:c}=a,l=Hb(s.shape,c,i,1,o),u=new qG(l);return n.runWebGLProgram(u,[s,r],"float32")}};const $G={kernelName:zh,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:s,filter:r}=t,{pad:i,strides:o,inputShape:c}=a,l=Hb(c,r.shape,o,1,i),u=new KG(l);return n.runWebGLProgram(u,[s,r],"float32")}},eq=qU({opSnippet:GU+"\n  return cos(x);\n",packedOpSnippet:"\n  vec4 result = cos(x);\n  bvec4 isNaN = isnan(x);\n  ".concat(PU,"\n  return result;\n")}),tq={kernelName:Bh,backendName:"webgl",kernelFunc:eq},nq=qU({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),aq={kernelName:jh,backendName:"webgl",kernelFunc:nq};class sq{constructor(e,t,n,a,s){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[r,i,o,c]=e,[l]=t,[u,h]=n;this.outputShape=[l,u,h,c];const d="bilinear"===a?1:0,[p,f]=["".concat(i-1,".0"),"".concat(o-1,".0")],[m,g,y]=u>1?["".concat((i-1)/(u-1)),"(y2-y1) * height_ratio","y1*".concat(p," + float(y)*(height_scale)")]:["0.0","0.0","0.5 * (y1+y2) * ".concat(p)],[b,x,v]=h>1?["".concat((o-1)/(h-1)),"(x2-x1) * width_ratio","x1*".concat(f," + float(x)*(width_scale)")]:["0.0","0.0","0.5 * (x1+x2) * ".concat(f)];this.userCode="\n      const float height_ratio = float(".concat(m,");\n      const float width_ratio = float(").concat(b,");\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ").concat(r,") {\n          return;\n        }\n\n        float height_scale = ").concat(g,";\n        float width_scale = ").concat(x,";\n\n        float in_y = ").concat(y,";\n        if( in_y < 0.0 || in_y > ").concat(p," ) {\n          setOutput(float(").concat(s,"));\n          return;\n        }\n        float in_x = ").concat(v,";\n        if( in_x < 0.0 || in_x > ").concat(f," ) {\n          setOutput(float(").concat(s,"));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(").concat(d," == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    ")}}const rq={kernelName:Uh,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{image:s,boxes:r,boxInd:i}=t,{cropSize:o,method:c,extrapolationValue:l}=a,u=new sq(s.shape,r.shape,o,c,l);return n.runWebGLProgram(u,[s,r,i],"float32")}};var iq;!function(e){e.Prod="*",e.Sum="+"}(iq||(iq={}));class oq{constructor(e,t,n,a){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const s=this.outputShape.length,r=this.op===iq.Prod?"1.0":"0.0",i=n?r:"getX(".concat(cq(s,"coords",this.op),")"),o=this.outputShape[this.outputShape.length-1];let c="",l="";n?(c=a?"end != ".concat(o-1):"end != 0",l=a?"end + 1":"end - 1"):(c=a?"end + pow2 < ".concat(o):"end >= pow2",l=a?"end + pow2":"end - pow2"),this.userCode="\n      void main() {\n        ".concat(HW(s)," coords = getOutputCoords();\n        int end = ").concat(lq(s,"coords",this.op),";\n        float val = ").concat(i,";\n        int pow2 = int(pow(2.0, index));\n        if (").concat(c,") {\n          int idx = ").concat(l,";\n          ").concat(lq(s,"coords",this.op)," = idx;\n          val ").concat(this.op,"= getX(").concat(cq(s,"coords",this.op),");\n        }\n        setOutput(val);\n      }\n    ")}}function cq(e,t,n){if(1===e)return"".concat(t);if(2===e)return"".concat(t,".x, ").concat(t,".y");if(3===e)return"".concat(t,".x, ").concat(t,".y, ").concat(t,".z");if(4===e)return"".concat(t,".x, ").concat(t,".y, ").concat(t,".z, ").concat(t,".w");throw new Error("Cumulative ".concat(n," for rank ").concat(e," is not yet supported"))}function lq(e,t,n){if(1===e)return"".concat(t);if(2===e)return"".concat(t,".y");if(3===e)return"".concat(t,".z");if(4===e)return"".concat(t,".w");throw new Error("Cumulative ".concat(n," for rank ").concat(e," is not yet supported"))}function uq(e,t,n,a,s,r){const i=t.shape.length,o=ev([a],i);let c=t;null!=o&&(c=dH({inputs:{x:t},backend:n,attrs:{perm:o}}));const l=nv(1,i)[0];if(l!==i-1)throw new Error("WebGL cumprod shader expects an inner-most axis=".concat(t.shape.length-1," ")+"but got axis=".concat(a));const u=c.shape[l];let h=OU({inputs:{x:c},backend:n});for(let d=0;d<=Math.ceil(Math.log2(u))-1;d++){const t=new oq(e,c.shape,!1,r),a=[[d]],s=h;h=n.runWebGLProgram(t,[h],h.dtype,a),n.disposeIntermediateTensorInfo(s)}if(s){const t=new oq(e,c.shape,s,r),a=h;h=n.runWebGLProgram(t,[h],h.dtype),n.disposeIntermediateTensorInfo(a)}if(null!=o){const e=dH({inputs:{x:h},backend:n,attrs:{perm:tv(o)}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(c),e}return h}const hq={kernelName:Wh,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{axis:r,exclusive:i,reverse:o}=a;return uq(iq.Prod,s,n,r,i,o)}};const dq={kernelName:Vh,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{axis:r,exclusive:i,reverse:o}=a;return uq(iq.Sum,s,n,r,i,o)}};const pq={kernelName:Hh,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,weights:r}=t,{size:i,binaryOutput:o}=a;if(1===s.shape.length){const e=n.readSync(s.dataId),t=n.readSync(r.dataId),a=yV(e,t,r.dtype,r.shape,i);return n.makeTensorInfo([i],r.dtype,a)}if(2===s.shape.length){const e=n.bufferSync(s),t=n.bufferSync(r),a=bV(e,t,i,o);return n.makeTensorInfo(a.shape,r.dtype,a.values)}throw new Error("Error in denseBincount: input must be at most rank 2, but got rank"+"".concat(s.shape.length,"."))}};class fq{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode="\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ".concat(this.getHeightCoordString(),";\n      int w = ").concat(this.getWidthCoordString(),";\n      int d = ").concat(this.getDepthCoordString(),";\n\n      int in_h = h / ").concat(t,";\n      int offset_h = imod(h, ").concat(t,");\n      int in_w = w / ").concat(t,";\n      int offset_w = imod(w, ").concat(t,");\n      int offset_d = (offset_h * ").concat(t," + offset_w) *\n        ").concat(this.getOutputDepthSize(),";\n      int in_d = d + offset_d;\n\n      float result = ").concat(this.getInputSamplingString(),";\n      setOutput(result);\n    }\n  ")}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const mq={kernelName:Gh,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{blockSize:r,dataFormat:i}=a,o=s.shape[0],c=("NHWC"===i?s.shape[1]:s.shape[2])*r,l=("NHWC"===i?s.shape[2]:s.shape[3])*r,u=("NHWC"===i?s.shape[3]:s.shape[1])/(r*r),h=new fq("NHWC"===i?[o,c,l,u]:[o,u,c,l],r,i);return n.runWebGLProgram(h,[s],s.dtype)}};class gq{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=ZW(this.outputShape.length);const r=e.filterHeight,i=e.filterWidth,o=e.outChannels/e.inChannels;let c="",l="";n&&(c=a?"float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ".concat(n,"\n        }"):s?"float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ".concat(n,"\n        }"):"\n          float activation(float x) {\n            ".concat(n,"\n          }\n        "),l="result = activation(result);");const u=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n      ".concat(c,"\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ").concat(o,";\n        int q = d2 - d1 * ").concat(o,";\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ").concat(r,"; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ").concat(i,"; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ").concat(u,"\n        ").concat(l,"\n        setOutput(result);\n      }\n    ")}}class yq{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=ZW(this.outputShape.length);const r=e.outChannels/e.inChannels,i=e.padInfo.left,o=e.strideWidth,c=e.dilationWidth,l=e.filterHeight,u=e.filterWidth,h=u;let d="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let g=0;g<u;g++)d+="\n          vec4 xTexelC".concat(2*g,";\n          int xTexelC").concat(2*g,"Ready;\n          vec4 xTexelC").concat(2*g+1,";\n          int xTexelC").concat(2*g+1,"Ready;\n          vec4 xC").concat(g,";");d+="\n    for (int r = 0; r < ".concat(l,"; r++) {\n      ");for(let g=0;g<u;g++)d+="\n          xTexelC".concat(2*g," = vec4(0.0);\n          xTexelC").concat(2*g,"Ready = 0;\n          xTexelC").concat(2*g+1," = vec4(0.0);\n          xTexelC").concat(2*g+1,"Ready = 0;\n          xC").concat(g," = vec4(0.0);");d+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let g=0;g<(h+1)/2;g++){const e=2*g;if(d+="\n          xC = xCCorner + ".concat(e*c,";\n          "),1===o){if(e<u&&(i%2===1?(d+="\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(e,"Ready == 0) {\n                  xTexelC").concat(e," = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC").concat(e,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(e,"Ready = 1;\n                }\n              "),d+=1===c&&e>0?"\n                xC".concat(e," = vec4(xTexelC").concat(e-2,".zw, xTexelC").concat(e,".xy);\n                "):"\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC".concat(e," = vec4(previous.zw, xTexelC").concat(e,".xy);\n                  } else {\n                    xC").concat(e," = vec4(0.0, 0.0, xTexelC").concat(e,".xy);\n                  }\n                  ")):d+="\n                if (xC >= 0 && xC < inDims[1] && xTexelC".concat(e,"Ready == 0) {\n                  xTexelC").concat(e," = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC").concat(e,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(e,"Ready = 1;\n                }\n\n                xC").concat(e," = xTexelC").concat(e,";\n                "),e+1<u)){const t=i%2===0?fu(c):c;c%2===0&&i%2===1||c%2!==0&&i%2!==1?(d+="\n                  xCOffset = xC + imod(pads[1], 2) + ".concat(t,";\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(e+1,"Ready == 0) {\n                    xTexelC").concat(e+1," = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC").concat(e+1,".zw = vec2(0.0);\n                    }\n                    xTexelC").concat(e+1,"Ready = 1;\n                  }\n                  "),d+=c>1?"\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC".concat(e+1," = vec4(previous.zw, xTexelC").concat(e+1,".xy);\n                    } else {\n                     xC").concat(e+1," = vec4(0.0, 0.0, xTexelC").concat(e+1,".xy);\n                    }\n                    "):"\n                    xC".concat(e+1," = vec4(xTexelC").concat(e,".zw, xTexelC").concat(e+1,".xy);\n                    ")):d+=1===t?"\n                    xC".concat(e+1," = xTexelC").concat(e,";\n                    "):"\n                    xCOffset = xC + ".concat(t,";\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(e+1,"Ready == 0) {\n                      xTexelC").concat(e+1," = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC").concat(e+1,".zw = vec2(0.0);\n                      }\n                      xTexelC").concat(e+1,"Ready = 1;\n                    }\n\n                    xC").concat(e+1," = xTexelC").concat(e+1,";\n                    ")}}else e<u&&(i%2===1?(d+="\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(e,"Ready == 0) {\n                  xTexelC").concat(e," = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC").concat(e,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(e,"Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC").concat(e+1,"Ready == 0) {\n                  xTexelC").concat(e+1," = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC").concat(e+1,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(e+1,"Ready = 1;\n                }\n\n                xC").concat(e," = vec4(xTexelC").concat(e,".zw, xTexelC").concat(e+1,".zw);\n              "),e+1<u&&(d+="\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC".concat(e+1," = vec4(xTexelC").concat(e+1,".xy, final.xy);\n                "))):(d+="\n                if(xC >= 0 && xC < inDims[1] && xTexelC".concat(e,"Ready == 0) {\n                  xTexelC").concat(e," = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC").concat(e,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(e,"Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(e+1,"Ready == 0) {\n                  xTexelC").concat(e+1," = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC").concat(e+1,".zw = vec2(0.);\n                  }\n                  xTexelC").concat(e+1,"Ready = 1;\n                }\n\n                xC").concat(e," = vec4(\n                  xTexelC").concat(e,".xy, xTexelC").concat(e+1,".xy);\n              "),e+1<u&&(d+="\n                  xC".concat(e+1," = vec4(xTexelC").concat(e,".zw, xTexelC").concat(e+1,".zw);\n                "))));e<u&&(d+="\n            wTexel = getW(r, ".concat(e,", d1, q);\n            dotProd += xC").concat(e," * vec4(wTexel.xz, wTexel.xz);\n          "),e+1<u&&(d+="\n              wTexel = getW(r, ".concat(e+1,", d1, q);\n              dotProd += xC").concat(e+1," * vec4(wTexel.xz, wTexel.xz);\n            ")))}d+="\n    }\n  ",d+="\n      }\n    ";let p="",f="";n&&(p=a?"vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ".concat(n,"\n        }"):s?"vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ".concat(n,"\n        }"):"vec4 activation(vec4 x) {\n          ".concat(n,"\n        }"),f="result = activation(result);");const m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n      ".concat(p,"\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ").concat(r,";\n        int q = d2 - d1 * ").concat(r,";\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ").concat(d,"\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ").concat(m,"\n        ").concat(f,"\n        setOutput(result);\n      }\n    ")}}const bq={kernelName:qh,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,filter:r}=t,{strides:i,pad:o,dilations:c,dimRoundingMode:l}=a;let u=c;null==u&&(u=[1,1]),yu(Zb(i,u),()=>"Error in depthwiseConv2d: Either strides or dilations must be "+"1. Got strides ".concat(i," and dilations '").concat(u,"'"));const h=Ub(s.shape,r.shape,i,u,o,l,!0);let d;d=$u().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels===1?new yq(h):new gq(h);const p=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];return n.runWebGLProgram(d,[s,r],"float32",p)}};class xq{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,a=e.padInfo.top,s=e.padInfo.left,r=e.outChannels/e.inChannels;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ".concat(r," + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ").concat(e.batchSize,"; b++) {\n          for (int yR = 0; yR < ").concat(e.outHeight,"; yR++) {\n            int xR = wR + yR * ").concat(t," - ").concat(a,";\n\n            if (xR < 0 || xR >= ").concat(e.inHeight,") {\n              continue;\n            }\n\n            for (int yC = 0; yC < ").concat(e.outWidth,"; yC++) {\n              int xC = wC + yC * ").concat(n," - ").concat(s,";\n\n              if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class vq{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,a=e.strideHeight,s=e.strideWidth,r=t-1-e.padInfo.top,i=n-1-e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode="\n      const ivec2 pads = ivec2(".concat(r,", ").concat(i,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ").concat(t,"; wR++) {\n          float dyR = float(dyRCorner + wR) / ").concat(a,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ").concat(t," - 1 - wR;\n\n          for (int wC = 0; wC < ").concat(n,"; wC++) {\n            float dyC = float(dyCCorner + wC) / ").concat(s,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ").concat(n," - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ").concat(o,"; dm++) {\n              int d2 = d1 * ").concat(o," + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}const wq={kernelName:Kh,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,dy:r}=t,{strides:i,dilations:o,pad:c,dimRoundingMode:l,filterShape:u}=a,h=Ub(s.shape,u,i,o,c,l,!0),d=new xq(h);return n.runWebGLProgram(d,[s,r],"float32")}};const kq={kernelName:Xh,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:s,filter:r}=t,{strides:i,dilations:o,pad:c,dimRoundingMode:l,inputShape:u}=a,h=Ub(u,r.shape,i,o,c,l,!0),d=new vq(h);return n.runWebGLProgram(d,[s,r],"float32")}};class Sq{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const Cq={kernelName:Yh,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t,s=[...a.shape,...a.shape],r=vu(a.shape),i=nH({inputs:{x:a},backend:n,attrs:{shape:[r]}}),o=new Sq(r),c=n.runWebGLProgram(o,[i],i.dtype),l=nH({inputs:{x:c},backend:n,attrs:{shape:s}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(c),l}};class Iq{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:n,padInfo:a,strideHeight:s,strideWidth:r,filterHeight:i,filterWidth:o,dilationHeight:c,dilationWidth:l}=e,{top:u,left:h}=a;this.userCode="\n      const ivec2 strides = ivec2(".concat(s,", ").concat(r,");\n      const ivec2 pads = ivec2(").concat(u,", ").concat(h,");\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ").concat(i,"; h++) {\n          int hIn = hBeg + h * ").concat(c,";\n\n          if (hIn >= 0 && hIn < ").concat(t,") {\n            for (int w = 0; w < ").concat(o,"; w++) {\n              int wIn = wBeg + w * ").concat(l,";\n\n              if (wIn >= 0 && wIn < ").concat(n,") {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    ")}}const Nq={kernelName:Qh,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,filter:r}=t,{strides:i,pad:o,dilations:c}=a,l=jb(s.shape,r.shape,i,o,"NHWC",c);let u;const h=new Iq(l);u=n.runWebGLProgram(h,[s,r],"float32");const d=nH({inputs:{x:u},backend:n,attrs:{shape:l.outShape}});return n.disposeIntermediateTensorInfo(u),d}};const Tq={kernelName:td,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{equation:s}=a,r=t,{allDims:i,summedDims:o,idDims:c}=PC(s,r.length);OC(i.length,c,r);const{path:l,steps:u}=FC(o,c),h=u.length;let d=null,p=i.length;const f=[];for(let m=0;m<h;++m){for(const e of u[m]){const{permutationIndices:t,expandDims:a}=DC(p,c[e]);let s;LC(t)?s=r[e]:(s=dH({inputs:{x:r[e]},backend:n,attrs:{perm:t}}),f.push(s));const i=s.shape.slice();for(let e=0;e<a.length;++e)i.splice(a[e],0,1);ku(s.shape,i)||(s=nH({inputs:{x:s},backend:n,attrs:{shape:i}}),f.push(s)),null===d?d=s:(d=eH({inputs:{a:s,b:d},backend:n}),f.push(d))}m<h-1&&(l[m]>=0&&(d=uH({inputs:{x:d},backend:n,attrs:{axis:l[m]-(i.length-p),keepDims:!1}}),f.push(d)),p--)}for(const m of f)m!==d&&n.disposeIntermediateTensorInfo(m);return d}},Eq=qU({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),Rq={kernelName:nd,backendName:"webgl",kernelFunc:Eq},_q={kernelName:ad,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n}=e,{dy:a,y:s}=t,r=$u().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new DU("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",a.shape,s.shape):new MU("return (b >= 0.0) ? a : a * (b + 1.0);",a.shape,s.shape);return n.runWebGLProgram(r,[a,s],a.dtype)}},Aq=KU({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:SV}),Mq={kernelName:rd,backendName:"webgl",kernelFunc:Aq},Pq=qU({opSnippet:'\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = '.concat(mC,";\n  float a1 = ").concat(gC,";\n  float a2 = ").concat(yC,";\n  float a3 = ").concat(bC,";\n  float a4 = ").concat(xC,";\n  float a5 = ").concat(vC,";\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n")}),Dq={kernelName:sd,backendName:"webgl",kernelFunc:Pq},Oq=qU({opSnippet:GU+"\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:CV,dtype:"float32"}),Fq={kernelName:id,backendName:"webgl",kernelFunc:Oq};function Lq(e){const{inputs:t,attrs:n,backend:a}=e,{dim:s}=n,{input:r}=t,i=r.shape.length,o=r.shape.slice();let c=s;return s<0&&(yu(-(i+1)<=s,()=>"Axis must be in the interval [".concat(-(i+1),", ").concat(i,"]")),c=i+s+1),o.splice(c,0,1),nH({inputs:{x:r},backend:a,attrs:{shape:o}})}const zq={kernelName:od,backendName:"webgl",kernelFunc:Lq},Bq="return exp(x) - 1.0;",jq=qU({opSnippet:Bq,packedOpSnippet:Bq,cpuKernelImpl:IV}),Wq={kernelName:cd,backendName:"webgl",kernelFunc:jq};class Vq{constructor(e,t,n){this.variableNames=["real","imag"];const a=t[1];this.outputShape=t;const s=n?"2.0 * ".concat(Math.PI):"-2.0 * ".concat(Math.PI),r=n?"".concat(a,".0"):"1.0";let i;if("real"===e)i="return real * expR - imag * expI;";else{if("imag"!==e)throw new Error('FFT component must be either "real" or "imag", got '.concat(e,"."));i="return real * expI + imag * expR;"}this.userCode="\n      const float exponentMultiplier = ".concat(s,";\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ").concat(i,"\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(").concat(a,");\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ").concat(a,"; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ").concat(r,";\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    ")}}function Uq(e,t,n){const a=n.texData.get(e.dataId),s=vu(e.shape),r=e.shape[e.shape.length-1],i=nH({inputs:{x:e},backend:n,attrs:{shape:[s/r,r]}}),o=i.shape,c=new Vq("real",o,t),l=new Vq("imag",o,t),u=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:o},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:o}],h=n.runWebGLProgram(c,u,"float32"),d=n.runWebGLProgram(l,u,"float32"),p=LU({inputs:{real:h,imag:d},backend:n});n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d);const f=nH({inputs:{x:p},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(p),f}const Hq={kernelName:ld,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:a}=t;return Uq(a,!1,n)}};class Gq{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}function qq(e){const{backend:t,attrs:n}=e,{shape:a,value:s}=n;let{dtype:r}=n;if(r=r||Fu(s),"string"===r){const e=Au(r,vu(a));return e.fill(s),t.makeTensorInfo(a,r,e)}{const e=new Gq(a,s),n=[[s]];return t.runWebGLProgram(e,[],r,n)}}const Kq={kernelName:ud,backendName:"webgl",kernelFunc:qq};class Xq{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode="\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ".concat(t," - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ").concat(t,") {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    ")}}const Yq={kernelName:hd,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n}=e;const{image:a}=t,s=n,r=new Xq(a.shape);return s.runWebGLProgram(r,[a],a.dtype)}},Qq="return floor(x);",Zq=qU({opSnippet:Qq,packedOpSnippet:Qq,cpuKernelImpl:NV}),Jq={kernelName:dd,backendName:"webgl",kernelFunc:Zq},$q=KU({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),eK={kernelName:pd,backendName:"webgl",kernelFunc:$q};class tK{constructor(e){this.variableNames=["A"];const t=EW(),[n,a]=e;this.outputShape=e,this.userCode="\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(".concat(a,".0, ").concat(n,".0);\n\n        vec4 values = ").concat(t.texture2D,"(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    ")}}class nK{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=EW(),[n,a]=e;this.outputShape=e,this.userCode="\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(".concat(a,".0, ").concat(n,".0);\n            vec4 values = ").concat(t.texture2D,"(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ").concat(t.output," = result;\n      }\n    ")}}const aK={kernelName:hf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e;let{pixels:s}=t;const{numChannels:r}=a,i="undefined"!==typeof HTMLVideoElement&&s instanceof HTMLVideoElement,o="undefined"!==typeof HTMLImageElement&&s instanceof HTMLImageElement,[c,l]=i?[s.videoWidth,s.videoHeight]:[s.width,s.height],u=[l,c],h=[l,c,r];if(o||i){const e=$u().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");null!=sK&&e===rK||(rK=e,sK=document.createElement("canvas").getContext("2d",{willReadFrequently:rK})),sK.canvas.width=c,sK.canvas.height=l,sK.drawImage(s,0,0,c,l),s=sK.canvas}const d=n.makeTensorInfo(u,"int32");n.texData.get(d.dataId).usage=Qj.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(d.dataId),s);const p=$u().getBool("WEBGL_PACK")?new nK(h):new tK(h),f=n.runWebGLProgram(p,[d],"int32");return n.disposeData(d.dataId),f}};let sK,rK=$u().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");const iK={kernelName:ff,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,filter:r,bias:i,preluActivationWeights:o}=t,{strides:c,pad:l,dataFormat:u,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=a,m=$b(u),g=Ub(s.shape,r.shape,c,h,l,d,!1,m);let y;const b=[],x=null!=i,v=null!=o,w="leakyrelu"===p,k=()=>{const e=[s,r],t=(e,t)=>{if("NCHW"===t&&1===e.shape.length&&1!==e.shape[0]){const t=nH({inputs:{x:e},backend:n,attrs:{shape:[e.shape[0],1,1]}});return b.push(t),t}return e};if(x&&e.push(t(i,u)),v&&e.push(t(o,u)),w){const t=n.makeTensorInfo([],"float32",Wf(f,"float32"));e.push(t),b.push(t)}return e};if(1!==g.filterHeight||1!==g.filterWidth||1!==g.dilationHeight||1!==g.dilationWidth||1!==g.strideHeight||1!==g.strideWidth||"SAME"!==g.padInfo.type&&"VALID"!==g.padInfo.type)if(g.strideWidth<=2&&"channelsLast"===m&&$u().getBool("WEBGL_EXP_CONV")){const e=p?XU(p,!0):null,t=new zG(g,x,e,v,w),a=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],s=k();y=n.runWebGLProgram(t,s,"float32",a)}else if($u().getBool("WEBGL_CONV_IM2COL"))y=VG({x:s,filter:r,convInfo:g,backend:n,bias:i,activation:p,preluActivationWeights:o,leakyreluAlpha:f});else{const e=p?XU(p,!1):null,t=new FG(g,x,e,v,w),a=k();y=n.runWebGLProgram(t,a,"float32")}else y=WG({x:s,filter:r,convInfo:g,backend:n,bias:i,activation:p,preluActivationWeights:o,leakyreluAlpha:f});const S=nH({inputs:{x:y},backend:n,attrs:{shape:g.outShape}});return b.push(y),b.forEach(e=>n.disposeIntermediateTensorInfo(e)),S}};const oK={kernelName:mf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,filter:r,bias:i,preluActivationWeights:o}=t,{strides:c,pad:l,dilations:u,dimRoundingMode:h,activation:d,leakyreluAlpha:p}=a,f=[];let m=u;null==m&&(m=[1,1]),yu(Zb(c,m),()=>"Error in depthwiseConv2d: Either strides or dilations must be "+"1. Got strides ".concat(c," and dilations '").concat(m,"'"));const g=Ub(s.shape,r.shape,c,m,l,h,!0),y=$u().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels===1,b=d?XU(d,y):null,x=[s,r],v=null!=i,w=null!=o,k="leakyrelu"===d;if(v&&x.push(i),w&&x.push(o),k){const e=n.makeTensorInfo([],"float32",Wf(p,"float32"));x.push(e),f.push(e)}let S;S=y?new yq(g,v,b,w,k):new gq(g,v,b,w,k);const C=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],I=n.runWebGLProgram(S,x,"float32",C);return f.forEach(e=>n.disposeIntermediateTensorInfo(e)),I}};class cK{constructor(e,t,n,a){this.sliceDim=e,this.strides=t,this.paramsShape=a,this.variableNames=["x","indices"],this.outputShape=n;const s=HW(n.length);let r="\n    int index;";for(let i=0;i<this.sliceDim;i++)r+="\n          index = round(getIndices(coords[0], ".concat(i,"));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ").concat(this.paramsShape[i],";\n          flattenIndex += index * ").concat(this.strides[i],";");this.userCode="\n         void main() {\n          ".concat(s," coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ").concat(r,"\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      ")}}const lK={kernelName:gd,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:a,indices:s}=t,r=s.shape,i=r[r.length-1],o=vu(a.shape),[c,l,u,h]=dC(a,s),d=nH({inputs:{x:s},backend:n,attrs:{shape:[l,i]}}),p=nH({inputs:{x:a},backend:n,attrs:{shape:[vu(a.shape)/u,u]}});if(n.shouldExecuteOnCPU([a,s])||"string"===a.dtype){const e=n.readSync(s.dataId),t=n.bufferSync(a),r=TV(e,t,a.dtype,l,i,u,h,a.shape,o);return n.makeTensorInfo(c,a.dtype,r.values)}const f=new cK(i,h,[l,u],a.shape),m=n.runWebGLProgram(f,[p,d],p.dtype),g=nH({inputs:{x:m},backend:n,attrs:{shape:c}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m),g}};class uK{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const n=HW(this.rank),a=function(e){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let a=0;a<e.length;a++)2===a?n.push("index"):n.push("".concat(t[a]));return n.join()}(e);this.userCode="\n      void main() {\n        ".concat(n," resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ").concat(e[2],") ? 1.0 : 0.0;\n        setOutput(inBounds * getA(").concat(a,"));\n      }\n    ")}}function hK(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,indices:r}=t,{axis:i,batchDims:o}=a,c=Eu(i,s.shape)[0];if($u().get("DEBUG")){const e=n.readSync(r.dataId),t=s.shape[c];for(let n=0;n<e.length;++n){const a=e[n];yu(a<=t-1&&a>=0,()=>"GatherV2: the index value ".concat(a," is not in [0, ").concat(t-1,"]"))}}const l=eI(s,r,c,o),u=vu(r.shape),h=[],d=nH({inputs:{x:s},backend:n,attrs:{shape:[l.batchSize,l.outerSize,l.dimSize,l.sliceSize]}}),p=nH({inputs:{x:r},backend:n,attrs:{shape:[l.batchSize,u/l.batchSize]}});h.push(d),h.push(p);const f=[l.batchSize,l.outerSize,u/l.batchSize,l.sliceSize];if(n.shouldExecuteOnCPU([s,r])||"string"===s.dtype){const e=n.bufferSync(p),t=n.bufferSync(d),a=EV(t,e,f);return h.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.makeTensorInfo(l.outputShape,a.dtype,a.values)}const m=new uK(d.shape,f),g=n.runWebGLProgram(m,[d,p],d.dtype);h.push(g);const y=nH({inputs:{x:g},backend:n,attrs:{shape:l.outputShape}});return h.forEach(e=>n.disposeIntermediateTensorInfo(e)),y}const dK={kernelName:md,backendName:"webgl",kernelFunc:hK},pK=KU({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:RV,dtype:"bool"}),fK={kernelName:yd,backendName:"webgl",kernelFunc:pK},mK=KU({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:_V}),gK={kernelName:bd,backendName:"webgl",kernelFunc:mK};const yK={kernelName:vd,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:a}=t;return Uq(a,!0,n)}},bK=qU({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),xK={kernelName:kd,backendName:"webgl",kernelFunc:bK},vK=qU({opSnippet:"return float(isinf(x));",dtype:"bool"}),wK={kernelName:Sd,backendName:"webgl",kernelFunc:vK},kK=qU({opSnippet:"return float(isnan(x));",dtype:"bool"}),SK={kernelName:Cd,backendName:"webgl",kernelFunc:kK},CK=KU({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:AV,dtype:"bool"}),IK={kernelName:Nd,backendName:"webgl",kernelFunc:CK},NK=KU({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:MV,dtype:"bool"}),TK={kernelName:Td,backendName:"webgl",kernelFunc:NK};const EK={kernelName:Ed,backendName:"webgl",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:a,stop:s,num:r}=n,i=PV(a,s,r);return t.makeTensorInfo([i.length],"float32",i)}},RK=qU({opSnippet:GU+"\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:DV}),_K={kernelName:Rd,backendName:"webgl",kernelFunc:RK},AK=qU({opSnippet:GU+"\n  return log(1.0 + x);\n"}),MK={kernelName:_d,backendName:"webgl",kernelFunc:AK},PK=KU({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),DK={kernelName:Ad,backendName:"webgl",kernelFunc:PK},OK=qU({opSnippet:"return float(!(x >= 1.0));"}),FK={kernelName:Md,backendName:"webgl",kernelFunc:OK},LK=KU({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),zK={kernelName:Pd,backendName:"webgl",kernelFunc:LK};class BK{constructor(e,t,n,a,s){this.variableNames=["x"],this.outputShape=[];const r=t,i=e[3]-1;let o;this.outputShape=e;const c="float(".concat(n,") + float(").concat(a,") * sum");o=.5===s?"inversesqrt(".concat(c,")"):1===s?"1.0/(".concat(c,")"):"exp(log(".concat(c,") * float(-").concat(s,"));"),this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -".concat(r,"; j <= ").concat(r,"; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ").concat(i,") {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ").concat(o,";\n        setOutput(val);\n      }\n    ")}}class jK{constructor(e,t,n,a,s){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const r=t,i=e[3]-1;let o;this.outputShape=e;const c="float(".concat(n,") + float(").concat(a,") * sum");o=.5===s?"inversesqrt(".concat(c,")"):1===s?"1.0/(".concat(c,")"):"exp(log(".concat(c,") * float(-").concat(s,"));"),this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ".concat(this.outputShape[3],";\n        bool hasNextRow = c < ").concat(this.outputShape[2],";\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ").concat(r,";\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ").concat(r,"; j <= ").concat(r,"; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(").concat(i,"));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ").concat(o,";\n        setOutput(result);\n      }\n    ")}}const WK={kernelName:Dd,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{depthRadius:r,bias:i,alpha:o,beta:c}=a,l=$u().getBool("WEBGL_PACK_NORMALIZATION")?new jK(s.shape,r,i,o,c):new BK(s.shape,r,i,o,c);return n.runWebGLProgram(l,[s],s.dtype)}};class VK{constructor(e,t,n,a,s){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=a,this.beta=s,this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ".concat(this.depth,"; ++d) {\n          int depthBegin = int(max(0.0, float(d - ").concat(t,")));\n          int depthEnd = int(min(float(").concat(this.depth,"),\n              float(d + ").concat(t," + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ").concat(this.depth,";\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(").concat(a,") * norm + float(").concat(n,");\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(").concat(a,")\n                * float(").concat(s,")\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ").concat(s,");\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    ")}}const UK={kernelName:Od,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{x:s,y:r,dy:i}=t,{depthRadius:o,bias:c,alpha:l,beta:u}=a,h=new VK(s.shape,o,c,l,u);return n.runWebGLProgram(h,[s,r,i],s.dtype)}};function HK(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{reductionIndices:r,keepDims:i}=a,o=s.shape.length,c=Eu(r,s.shape);let l=c;const u=ev(l,o),h=null!=u,d=n.shouldExecuteOnCPU([s]);let p=s;if(h){if(d){const e=n.texData.get(p.dataId).values,t=new Array(o);for(let n=0;n<t.length;n++)t[n]=s.shape[u[n]];const a=lU(e,s.shape,s.dtype,u,t);p=n.makeTensorInfo(t,s.dtype);n.texData.get(p.dataId).values=a}else p=lH(s,u,n);l=nv(l.length,o)}$x("max",l,o);const[f,m]=Zx(p.shape,l);let g,y=f;if(i&&(y=Jx(f,c)),d){const e=n.texData.get(p.dataId).values,t=OV(e,vu(m),y,s.dtype);g=n.makeTensorInfo(y,s.dtype);n.texData.get(g.dataId).values=t}else g=function(e,t,n,a){const s=vu(t),r=nH({inputs:{x:e},attrs:{shape:[vu(e.shape)/s,s]},backend:a}),i=iH(r,e.dtype,"max",a),o=nH({inputs:{x:i},attrs:{shape:n},backend:a});return a.disposeIntermediateTensorInfo(r),a.disposeIntermediateTensorInfo(i),o}(p,m,y,n);return h&&n.disposeIntermediateTensorInfo(p),g}const GK={kernelName:Fd,backendName:"webgl",kernelFunc:HK},qK=KU({opSnippet:AU+"\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+PU+"\n  return result;\n",cpuKernelImpl:FV}),KK={kernelName:Ld,backendName:"webgl",kernelFunc:qK};const XK={kernelName:zd,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t;NW(s,"maxPool");const{filterSize:r,strides:i,pad:o,dimRoundingMode:c}=a;yu(Zb(i,1),()=>"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(i," and dilations '").concat(1,"'"));const l=Wb(s.shape,r,i,1,o,c);if(1===l.filterWidth&&1===l.filterHeight&&ku(l.inShape,l.outShape))return OU({inputs:{x:s},backend:n});const u=new KH(l,"max",!1);return n.runWebGLProgram(u,[s],s.dtype)}};const YK={kernelName:jd,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{filterSize:r,strides:i,pad:o,dataFormat:c,dimRoundingMode:l}=a,u=Vb(s.shape,r,i,[1,1,1],o,l,c),h=new XH(u,"max",!1);return n.runWebGLProgram(h,[s],s.dtype)}};class QK{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,n=e.strideWidth,a=e.dilationHeight,s=e.effectiveFilterHeight,r=e.effectiveFilterWidth,i=s-1-e.padInfo.top,o=r-1-e.padInfo.left,c=s*r-1;this.userCode="\n      const ivec2 pads = ivec2(".concat(i,", ").concat(o,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(s,";\n          wR += ").concat(a,") {\n          float dyR = float(dyRCorner + wR) / ").concat(t,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ").concat(r,"; wC++) {\n            float dyC = float(dyCCorner + wC) / ").concat(n,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ").concat(c," - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ").concat(r," + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class ZK{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,n=e.strideHeight,a=e.strideWidth,s=e.dilationDepth,r=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterDepth,c=e.effectiveFilterHeight,l=e.effectiveFilterWidth,u=o-1-e.padInfo.front,h=c-1-e.padInfo.top,d=l-1-e.padInfo.left,p=o*c*l-1;this.userCode="\n      const ivec3 pads = ivec3(".concat(u,", ").concat(h,", ").concat(d,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ").concat(o,";\n           wD += ").concat(s,") {\n          float dyD = float(dyDCorner + wD) / ").concat(t,".0;\n\n          if (dyD < 0.0 || dyD >= ").concat(e.outDepth,".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ").concat(c,";\n              wR += ").concat(r,") {\n            float dyR = float(dyRCorner + wR) / ").concat(n,".0;\n\n            if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ").concat(l,";\n                wC += ").concat(i,") {\n              float dyC = float(dyCCorner + wC) / ").concat(a,".0;\n\n              if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ").concat(p," -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ").concat(c," * ").concat(l," +\n                  wR * ").concat(l," + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}const JK={kernelName:Wd,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:s,input:r}=t,i=r,{filterSize:o,strides:c,pad:l,dimRoundingMode:u}=a,h=Vb(i.shape,o,c,[1,1,1],l,u),d=new XH(h,"max",!0),p=n.runWebGLProgram(d,[i],i.dtype),f=new ZK(h),m=n.runWebGLProgram(f,[s,p],i.dtype);return n.disposeIntermediateTensorInfo(p),m}};const $K={kernelName:Bd,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:s,input:r,output:i}=t,o=r;NW([r,i],"maxPoolGrad");const{filterSize:c,strides:l,pad:u,dimRoundingMode:h}=a,d=Wb(o.shape,c,l,1,u,h),p=new KH(d,"max",!0),f=n.runWebGLProgram(p,[o],o.dtype),m=new QK(d),g=n.runWebGLProgram(m,[s,f],o.dtype);return n.disposeIntermediateTensorInfo(f),g}};const eX={kernelName:Vd,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e;const{x:s}=t,{filterSize:r,strides:i,pad:o,includeBatchInIndex:c}=n,l=a;yu(4===s.shape.length,()=>"Error in maxPool: input must be rank 4 but got rank ".concat(s.shape.length,"."));const u=[1,1];yu(Zb(i,u),()=>"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(i," and dilations '").concat(u,"'"));const h=Wb(s.shape,r,i,u,o),[d,p]=function(e,t,n,a){let s=new KH(n,"max",!1);const r=a.runWebGLProgram(s,[e],"float32");return s=new KH(n,"max",!0,!0,t),[r,a.runWebGLProgram(s,[e],"float32")]}(s,c,h,l);return[d,p]}};const tX={kernelName:Ud,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e;const{x:s}=t,{keepDims:r,axis:i}=n,o=a,c=s.shape.length,l=Eu(i,s.shape);let u=l;const h=ev(u,c),d=null!=h,p=o.shouldExecuteOnCPU([s]),f=[];let m=s;if(d){if(p){const e=o.texData.get(m.dataId).values,t=new Array(c);for(let a=0;a<t.length;a++)t[a]=s.shape[h[a]];const n=lU(e,s.shape,s.dtype,h,t);m=o.makeTensorInfo(t,s.dtype);o.texData.get(m.dataId).values=n}else m=lH(s,h,o);f.push(m),u=nv(u.length,c)}$x("sum",u,c);const[g,y]=Zx(m.shape,u);let b=g;r&&(b=Jx(g,l));const x=function(e,t,n,a){const s=vu(t),r=nH({inputs:{x:e},attrs:{shape:[vu(e.shape)/s,s]},backend:a}),i=iH(r,"float32","mean",a),o=nH({inputs:{x:i},attrs:{shape:n},backend:a});return a.disposeIntermediateTensorInfo(r),a.disposeIntermediateTensorInfo(i),o}(m,y,b,o);for(const v of f)o.disposeIntermediateTensorInfo(v);return x}};const nX={kernelName:Hd,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{axis:r,keepDims:i}=a,o=s.shape.length,c=Eu(r,s.shape);let l=c;const u=ev(l,o);let h=s;null!=u&&(h=dH({inputs:{x:s},backend:n,attrs:{perm:u}}),l=nv(l.length,s.shape.length)),$x("min",l,o);const[d,p]=Zx(h.shape,l),f=nH({inputs:{x:h},backend:n,attrs:{shape:[-1,vu(p)]}}),m=iH(f,f.dtype,"min",n);let g;if(i){g=nH({inputs:{x:m},backend:n,attrs:{shape:Jx(d,c)}})}else g=nH({inputs:{x:m},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=u&&n.disposeIntermediateTensorInfo(h),g}},aX=KU({opSnippet:AU+"\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+PU+"\n  return result;\n",cpuKernelImpl:LV}),sX={kernelName:Gd,backendName:"webgl",kernelFunc:aX};class rX{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map((t,n)=>t[0]+e[n]+t[1]);const a=e.length,s=HW(a),r=t.map(e=>e[0]).join(","),i=t.map((t,n)=>t[0]+e[n]).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,a),c="reflect"===n?0:1;this.userCode=1!==a?"\n      ".concat(s," start = ").concat(s,"(").concat(r,");\n      ").concat(s," end = ").concat(s,"(").concat(i,");\n\n      void main() {\n        ").concat(s," outC = getOutputCoords();\n        for (int i = 0; i < ").concat(a,"; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ").concat(c,";\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ").concat(c,";\n          }\n        }\n        ").concat(s," coords = outC - start;\n        setOutput(getX(").concat(o,"));\n      }\n    "):"\n        int start = ".concat(r,";\n        int end = ").concat(i,";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ").concat(c,";\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ").concat(c,";\n          }\n          setOutput(getX(outC - start));\n        }\n      ")}}class iX{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((t,n)=>t[0]+e[n]+t[1]);const a=e.length,s=HW(a),r=t.map(e=>e[0]).join(","),i=t.map((t,n)=>t[0]+e[n]).join(","),o=dU("rc",a),c=dU("source",a),l="".concat(o[a-1]," < ").concat(this.outputShape[a-1]),u=1===a?"source":"vec2(".concat(c.slice(-2).join(),")"),h="reflect"===n?0:1;let d="";if(1===a){const e="\n        ".concat(s," source = rc;\n        if (source < start) {\n          source = start * 2 - source - ").concat(h,";\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ").concat(h,";\n        }\n        source -= start;\n      ");d="\n        ".concat(s," rc = outputLoc;\n        ").concat(e,"\n        result[0] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n        ").concat(o[a-1]," += 1;\n        if(").concat(l,") {\n          ").concat(e,"\n          result[1] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n        }\n      ")}else{const e="\n        ".concat(s," source = rc;\n        ").concat(s," lt = ").concat(s,"(lessThan(source, start));\n        ").concat(s," gte = ").concat(s,"(greaterThanEqual(source, end));\n        ").concat(s," orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ").concat(h,") +\n                gte * ((end - 1) * 2 - source + ").concat(h,");\n        source -= start;\n      ");d="\n        ".concat(s," rc = outputLoc;\n        ").concat(e,"\n        result[0] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n        ").concat(o[a-1]," += 1;\n        if(").concat(l,") {\n          ").concat(e,"\n          result[1] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n        }\n        rc = outputLoc;\n        ").concat(o[a-2]," += 1;\n        if(").concat(o[a-2]," < ").concat(this.outputShape[a-2],") {\n          ").concat(e,"\n          result[2] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n          ").concat(o[a-1]," += 1;\n          if(").concat(l,") {\n            ").concat(e,"\n            result[3] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n          }\n        }\n      ")}this.userCode="\n      const ".concat(s," start = ").concat(s,"(").concat(r,");\n      const ").concat(s," end = ").concat(s,"(").concat(i,");\n\n      void main() {\n        ").concat(s," outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ").concat(d,"\n        setOutput(result);\n      }\n    ")}}const oX={kernelName:qd,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:a}=e;const{x:s}=t,{paddings:r,mode:i}=a,o=$u().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new iX(s.shape,r,i):new rX(s.shape,r,i);return n.runWebGLProgram(o,[s],s.dtype)}},cX=KU({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  "+PU+"\n  return result;\n"}),lX={kernelName:Kd,backendName:"webgl",kernelFunc:cX};class uX{constructor(e,t,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,n],this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ".concat(t-1,"; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(").concat(t-1,"));\n      }\n    ")}}const hX=KU({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),dX={kernelName:ed,backendName:"webgl",kernelFunc:hX},pX="return a - b;",fX=KU({opSnippet:pX,packedOpSnippet:pX,supportsComplex:!0,cpuKernelImpl:iU}),mX={kernelName:Jp,backendName:"webgl",kernelFunc:fX};function gX(e){const{inputs:t,backend:n,attrs:a}=e,{logits:s}=t,{dim:r}=a,i=Eu([r],s.shape),o=HK({inputs:{x:s},backend:n,attrs:{reductionIndices:i,keepDims:!1}}),c=Jx(o.shape,i),l=nH({inputs:{x:o},backend:n,attrs:{shape:c}}),u=fX({inputs:{a:s,b:l},backend:n}),h=Oq({inputs:{x:u},backend:n}),d=uH({inputs:{x:h},backend:n,attrs:{axis:i,keepDims:!1}}),p=nH({inputs:{x:d},backend:n,attrs:{shape:c}}),f=hX({inputs:{a:h,b:p},backend:n});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),f}const yX={kernelName:Bp,backendName:"webgl",kernelFunc:gX};const bX={kernelName:Xd,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{logits:s}=t,{numSamples:r,seed:i,normalized:o}=a,c=o?s:gX({inputs:{logits:s},backend:n,attrs:{dim:s.shape.length-1}}),l=c.shape[0],u=c.shape[1],h=new uX(l,u,r),d=[[i]],p=n.runWebGLProgram(h,[c],"int32",d);return o||n.disposeIntermediateTensorInfo(c),p}},xX=vU+"\n  return -x;\n";const vX={kernelName:Qd,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t;if(n.shouldExecuteOnCPU([a])){const e=n.texData.get(a.dataId),[t,s]=BV(e.values,a.shape,a.dtype);return n.makeTensorInfo(s,a.dtype,t)}let s;return s=$u().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new IU(a.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new xU(a.shape,xX),n.runWebGLProgram(s,[a],a.dtype)}},wX=aS;const kX={kernelName:Jd,backendName:"webgl",kernelFunc:function(e){gf("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:a}=e,{boxes:s,scores:r}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:c}=a,l=n.readSync(s.dataId),u=n.readSync(r.dataId),{selectedIndices:h}=wX(l,u,i,o,c);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}},SX=sS;const CX={kernelName:$d,backendName:"webgl",kernelFunc:function(e){gf("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:a}=e,{boxes:s,scores:r}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:c,padToMaxOutputSize:l}=a,u=n.readSync(s.dataId),h=n.readSync(r.dataId),{selectedIndices:d,validOutputs:p}=SX(u,h,i,o,c,l);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},IX=rS;const NX={kernelName:ep,backendName:"webgl",kernelFunc:function(e){gf("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:a}=e,{boxes:s,scores:r}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:c,softNmsSigma:l}=a,u=n.readSync(s.dataId),h=n.readSync(r.dataId),d=i,p=o,f=c,m=l,{selectedIndices:g,selectedScores:y}=IX(u,h,d,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}};class TX{constructor(e,t,n,a){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(".concat(a,"), float(").concat(n,"),\n                      float(index == coords.y)));\n      }\n    ")}}const EX={kernelName:np,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{indices:s}=t,{dtype:r,depth:i,onValue:o,offValue:c}=a,l=vu(s.shape),u=new TX(l,i,o,c),h=nH({inputs:{x:s},backend:n,attrs:{shape:[l]}}),d=n.runWebGLProgram(u,[h],r);n.disposeIntermediateTensorInfo(h);const p=nH({inputs:{x:d},backend:n,attrs:{shape:[...s.shape,i]}});return n.disposeIntermediateTensorInfo(d),p}};function RX(e){const{inputs:t,backend:n}=e,{x:a}=t;if("complex64"===a.dtype){const e=gG({inputs:{input:a},backend:n}),t=RX({inputs:{x:e},backend:n}),s=AG({inputs:{input:a},backend:n}),r=RX({inputs:{x:s},backend:n}),i=LU({inputs:{real:t,imag:r},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(r),i}return qq({attrs:{shape:a.shape,dtype:a.dtype,value:"string"===a.dtype?"":0},backend:n})}const _X={kernelName:lf,backendName:"webgl",kernelFunc:RX};const AX={kernelName:tp,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:a}=t,{x:s}=n;if("string"===s.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===s.dtype){const t=gG({inputs:{input:s},backend:a}),n=e({inputs:{x:t},backend:a}),r=AG({inputs:{input:s},backend:a}),i=RX({inputs:{x:r},backend:a}),o=LU({inputs:{real:n,imag:i},backend:a});return a.disposeIntermediateTensorInfo(t),a.disposeIntermediateTensorInfo(n),a.disposeIntermediateTensorInfo(r),a.disposeIntermediateTensorInfo(i),o}return qq({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:a})}};const MX={kernelName:ap,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{axis:s}=a;if(1===t.length)return Lq({inputs:{input:t[0]},backend:n,attrs:{dim:s}});const r=t[0].shape,i=t[0].dtype;t.forEach(e=>{bu(r,e.shape,"All tensors passed to stack must have matching shapes"),yu(i===e.dtype,()=>"All tensors passed to stack must have matching dtypes")});const o=[],c=DG({inputs:t.map(e=>{const t=Lq({inputs:{input:e},backend:n,attrs:{dim:s}});return o.push(t),t}),backend:n,attrs:{axis:s}});return o.forEach(e=>n.disposeIntermediateTensorInfo(e)),c}};class PX{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((t,n)=>t[0]+e[n]+t[1]);const a=e.length,s=HW(a),r=t.map(e=>e[0]).join(","),i=t.map((t,n)=>t[0]+e[n]).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,a);this.userCode=1!==a?"\n      ".concat(s," start = ").concat(s,"(").concat(r,");\n      ").concat(s," end = ").concat(s,"(").concat(i,");\n\n      void main() {\n        ").concat(s," outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ").concat(s," coords = outC - start;\n          setOutput(getX(").concat(o,"));\n        }\n      }\n    "):"\n        int start = ".concat(r,";\n        int end = ").concat(i,";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      ")}}class DX{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((t,n)=>t[0]+e[n]+t[1]);const a=e.length,s=HW(a),r=t.map(e=>e[0]).join(","),i=t.map((t,n)=>t[0]+e[n]).join(","),o=dU("rc",a),c=dU("source",a),l="".concat(o[a-1]," < ").concat(this.outputShape[a-1]),u=1===a?"source":"vec2(".concat(c.slice(-2).join(),")"),h=["".concat(s," rc = outputLoc;"),"".concat(o[a-1]," += 1;\n       if(").concat(l,") {\n      "),1===a?"":"}\n       rc = outputLoc;\n       ".concat(o[a-2]," += 1;\n       if(").concat(o[a-2]," < ").concat(this.outputShape[a-2],") {"),1===a?"":"  ".concat(o[a-1]," += 1;\n         if(").concat(l,") {")],d=1===a?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let p="";for(let f=0,m=1===a?2:4;f<m;f++)p+="\n        ".concat(h[f],"\n        if (").concat(d,") {\n          result[").concat(f,"] = float(value);\n        } else {\n          ").concat(s," source = rc - start;\n          result[").concat(f,"] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n        }\n      ");p+=1===a?"} ":"}}",this.userCode="\n      const ".concat(s," start = ").concat(s,"(").concat(r,");\n      const ").concat(s," end = ").concat(s,"(").concat(i,");\n\n      void main() {\n        ").concat(s," outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ").concat(p,"\n        setOutput(result);\n      }\n    ")}}const OX=e=>{const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{paddings:r,constantValue:i}=a;if(0===vu(s.shape)){const e=r.map((e,t)=>e[0]+s.shape[t]+e[1]);return qq({backend:n,attrs:{shape:e,value:i,dtype:s.dtype}})}const o=$u().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new DX(s.shape,r,i):new PX(s.shape,r,i),c=[[i]];return n.runWebGLProgram(o,[s],s.dtype,c)},FX={kernelName:sp,backendName:"webgl",kernelFunc:OX},LX=KU({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  "+PU+"\n  return result;\n"}),zX={kernelName:rp,backendName:"webgl",kernelFunc:LX};const BX={kernelName:op,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{axis:r,keepDims:i}=a,o=s.shape.length,c=[],l=Eu(r,s.shape);let u=l;const h=ev(u,o);let d,p=s;if(null!=h&&(p=dH({inputs:{x:s},backend:n,attrs:{perm:h}}),u=nv(u.length,o),c.push(p)),$x("prod",u,o),n.shouldExecuteOnCPU([p])){const e=n.texData.get(p.dataId).values,{outVals:t,outShape:a,outDtype:s}=WV(p.shape,p.dtype,e,u);d=n.makeTensorInfo(a,s,t)}else{const[e,t]=Zx(p.shape,u),a=vu(t),r=nH({inputs:{x:p},backend:n,attrs:{shape:[-1,a]}}),i=iH(r,gm(s.dtype),"prod",n);d=nH({inputs:{x:i},backend:n,attrs:{shape:e}}),c.push(r),c.push(i)}if(i){c.push(d);const e=Jx(d.shape,l);d=nH({inputs:{x:d},backend:n,attrs:{shape:e}})}return c.forEach(e=>n.disposeIntermediateTensorInfo(e)),d}};const jX={kernelName:cp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{paramsNestedSplits:s,paramsDenseValues:r,indices:i}=t,{outputRaggedRank:o}=a,c=s.map(e=>n.readSync(e.dataId)),l=s.map(e=>e.shape),u=n.readSync(r.dataId),h=n.readSync(i.dataId),[d,p,f]=VV(c,l,u,r.shape,r.dtype,h,i.shape,o),m=d.map(e=>n.makeTensorInfo([e.length],"int32",e)),g=n.makeTensorInfo(f,r.dtype,p);return m.concat([g])}};const WX={kernelName:lp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{starts:a,limits:s,deltas:r}=t,i=n.readSync(a.dataId),o=n.readSync(s.dataId),c=n.readSync(r.dataId),[l,u]=UV(i,a.shape,a.dtype,o,s.shape,c,r.shape);return[n.makeTensorInfo([l.length],"int32",l),n.makeTensorInfo([u.length],a.dtype,u)]}};const VX={kernelName:up,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{shape:s,values:r,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:c}=a,l=n.readSync(s.dataId),u=n.readSync(r.dataId),h=n.readSync(i.dataId),d=o.map(e=>n.readSync(e.dataId)),p=o.map(e=>e.shape),[f,m]=HV(l,s.shape,u,r.shape,r.dtype,h,i.shape,d,p,c);return n.makeTensorInfo(f,r.dtype,m)}},UX=e=>{const{backend:t,attrs:n}=e,{start:a,stop:s,step:r,dtype:i}=n,o=GV(a,s,r,i);return t.makeTensorInfo([o.length],i,o)},HX={kernelName:hp,backendName:"webgl",kernelFunc:UX},GX=qU({opSnippet:"return 1.0 / x;"}),qX={kernelName:pp,backendName:"webgl",kernelFunc:GX},KX=qU({opSnippet:vU+"\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),XX={kernelName:fp,backendName:"webgl",kernelFunc:KX},YX=qU({opSnippet:vU+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),QX={kernelName:vp,backendName:"webgl",kernelFunc:YX};class ZX{constructor(e,t,n,a,s){this.variableNames=["A"],this.outputShape=[];const[r,i,o,c]=e;this.outputShape=[r,t,n,c];const l=[a&&t>1?i-1:i,a&&n>1?o-1:o],u=[a&&t>1?t-1:t,a&&n>1?n-1:n];let h;h=s?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode="\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ".concat(l[0]/u[0],",\n          ").concat(l[1]/u[1],");\n      const vec2 inputShapeRC = vec2(").concat(i,".0, ").concat(o,".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ").concat(h,";\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    ")}}class JX{constructor(e,t,n,a,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[r,i,o,c]=e;this.outputShape=[r,t,n,c];const l=[a&&t>1?i-1:i,a&&n>1?o-1:o],u=[a&&t>1?t-1:t,a&&n>1?n-1:n];let h;h=s?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode="\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ".concat(l[0]/u[0],",\n          ").concat(l[1]/u[1],",\n          ").concat(l[1]/u[1],");\n      const vec3 inputShapeRC = vec3(").concat(i,".0, ").concat(o,".0,\n                                     ").concat(o,".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ").concat(h,";\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ").concat(c-1,";\n        bool hasNextRow = coords.z < ").concat(n-1,";\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    ")}}const $X={kernelName:bp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:s}=t,{alignCorners:r,halfPixelCenters:i,size:o}=a,[c,l]=o,u=$u().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new JX(s.shape,c,l,r,i):new ZX(s.shape,c,l,r,i);return n.runWebGLProgram(u,[s],"float32")}};class eY{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,a,s]=t,[,r,i]=e,o=[n&&r>1?a-1:a,n&&i>1?s-1:s],c=[n&&r>1?r-1:r,n&&i>1?i-1:i],l=o[0]/c[0],u=o[1]/c[1],h=1/l,d=1/u,p=2*Math.ceil(h)+2,f=2*Math.ceil(d)+2;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(".concat(l,");\n        const float widthScale = float(").concat(u,");\n\n        const float invHeightScale = float(").concat(h,");\n        const float invWidthScale = float(").concat(d,");\n\n        const int winHeight = int(").concat(p,");\n        const int winWidth = int(").concat(f,");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ").concat(r,") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ").concat(i,") {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ").concat(a-1,".0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ").concat(s-1,".0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ")}}const tY={kernelName:xp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:s,dy:r}=t,{alignCorners:i}=a,o=new eY(r.shape,s.shape,i);return n.runWebGLProgram(o,[r],r.dtype)}};class nY{constructor(e,t,n,a,s){this.variableNames=["A"],this.outputShape=[];const[r,i,o,c]=e;this.outputShape=[r,t,n,c];const l=[a&&t>1?i-1:i,a&&n>1?o-1:o],u=[a&&t>1?t-1:t,a&&n>1?n-1:n],h=a?"0.5":"0.0";let d;d=s?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode="\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ".concat(l[0]/u[0],",\n          ").concat(l[1]/u[1],");\n      const vec2 inputShapeRC = vec2(").concat(i,".0, ").concat(o,".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ").concat(d,";\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ").concat(h,")));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    ")}}class aY{constructor(e,t,n,a,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[r,i,o,c]=e;this.outputShape=[r,t,n,c];const l=[a&&t>1?i-1:i,a&&n>1?o-1:o],u=[a&&t>1?t-1:t,a&&n>1?n-1:n],h=a?"0.5":"0.0";let d;d=s?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode="\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ".concat(l[0]/u[0],",\n          ").concat(l[1]/u[1],",\n          ").concat(l[1]/u[1],");\n      const vec3 inputShapeRC = vec3(").concat(i,".0, ").concat(o,".0,\n                                     ").concat(o,".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ").concat(d,";\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ").concat(h,")));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ").concat(c-1,";\n        bool hasNextRow = coords.z < ").concat(n-1,";\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    ")}}const sY={kernelName:gp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:s}=t,{alignCorners:r,halfPixelCenters:i,size:o}=a,[c,l]=o,u=$u().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new aY(s.shape,c,l,r,i):new nY(s.shape,c,l,r,i);return n.runWebGLProgram(u,[s],s.dtype)}};class rY{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,a,s]=t,[,r,i]=e,o=[n&&r>1?a-1:a,n&&i>1?s-1:s],c=[n&&r>1?r-1:r,n&&i>1?i-1:i],l=o[0]/c[0],u=o[1]/c[1],h=1/l,d=1/u,p=2*Math.ceil(h)+2,f=2*Math.ceil(d)+2;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(".concat(l,");\n        const float widthScale = float(").concat(u,");\n\n        const float invHeightScale = float(").concat(h,");\n        const float invWidthScale = float(").concat(d,");\n\n        const int winHeight = int(").concat(p,");\n        const int winWidth = int(").concat(f,");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ").concat(r,") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ").concat(i,") {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(").concat(o[0],") *\n                (float(dyR) / float(").concat(c[0],"));\n\n            float sourceFracCol =\n                float(").concat(o[1],") *\n                  (float(dyC) / float(").concat(c[1],"));\n\n            int sourceNearestRow = int(min(\n                float(int(").concat(a,") - 1),\n                ").concat(n," ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(").concat(s,") - 1),\n                ").concat(n," ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ")}}const iY={kernelName:yp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:s,dy:r}=t,{alignCorners:i}=a,o=new rY(r.shape,s.shape,i);return n.runWebGLProgram(o,[r],r.dtype)}};class oY{constructor(e,t){this.variableNames=["x"];const n=e.length;if(n>4)throw new Error("WebGL backend: Reverse of rank-".concat(n," tensor is not yet supported"));if(this.outputShape=e,1===n)return void(this.userCode="\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(".concat(e[0]," - coord - 1));\n        }\n      "));const a=e.map((n,a)=>(n=>-1!==t.indexOf(n)&&1!==e[n]?"".concat(e[n]," - coords[").concat(n,"] - 1"):"coords[".concat(n,"]"))(a)).join(","),s=HW(n);this.userCode="\n      void main() {\n        ".concat(s," coords = getOutputCoords();\n        setOutput(getX(").concat(a,"));\n      }\n    ")}}class cY{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const n=e.length;if(n>4)throw new Error("WebGL backend: Reverse of rank-".concat(n," tensor is not yet supported"));this.outputShape=e;const a=dU("rc",n),s="".concat(a[n-1]," + 1 < ").concat(this.outputShape[n-1]),r="".concat(a[n-2]," + 1 < ").concat(this.outputShape[n-2]),i=HW(n);function o(n){const a=e.map((a,s)=>function(n,a){return-1!==t.indexOf(n)&&1!==e[n]?"".concat(e[n]," - ").concat(a[n]," - 1"):"".concat(a[n])}(s,n)),s=a.join(","),r=a.slice(-2).join(",");return"getChannel(getX(".concat(s,"), vec2(").concat(r,"))")}this.userCode=1===n?"\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(".concat(e[0]," - rc - 1),\n            ").concat(e[0]," - rc - 1);\n          if(").concat(s,"){\n              result.g = getChannel(getX(").concat(e[0]," - (rc  + 1) - 1),\n                ").concat(e[0]," - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      "):"\n        void main() {\n          ".concat(i," rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ").concat(function(e){return o(e)}(a.slice()),";\n          if(").concat(s,"){\n            result.g = ").concat(function(e){return e[n-1]="("+e[n-1]+" + 1)",o(e)}(a.slice()),";\n          }\n          if(").concat(r,") {\n            result.b = ").concat(function(e){return e[n-2]="("+e[n-2]+" + 1)",o(e)}(a.slice()),";\n            if(").concat(s,") {\n              result.a = ").concat(function(e){return e[n-1]="("+e[n-1]+" + 1)",e[n-2]="("+e[n-2]+" + 1)",o(e)}(a.slice()),";\n            }\n          }\n          setOutput(result);\n        }\n    ")}}const lY={kernelName:wp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{dims:r}=a,i=s.shape.length,o=Eu(r,s.shape);if(0===i)return OU({inputs:{x:s},backend:n});const c=$u().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new cY(s.shape,o):new oY(s.shape,o);return n.runWebGLProgram(c,[s],s.dtype)}};class uY{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const n=e[1],a=e[2];this.outputShape=e;let s="";s="number"===typeof t?"float outputValue = ".concat(t.toFixed(2),";"):"\n        vec3 fill = vec3(".concat(t.join(","),");\n        float outputValue = fill[coords[3]];"),this.userCode="\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ".concat(s,"\n          if(coordX >= 0 && coordX < ").concat(a," && coordY >= 0 && coordY < ").concat(n,") {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    ")}}const hY={kernelName:df,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e;const{image:s}=t,{radians:r,fillValue:i,center:o}=n,c=a,l=new uY(s.shape,i),[u,h]=iC(o,s.shape[1],s.shape[2]),d=[[u,h,Math.sin(r),Math.cos(r)]];return c.runWebGLProgram(l,[s],s.dtype,d)}},dY=qU({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),pY={kernelName:kp,backendName:"webgl",kernelFunc:dY},fY=qU({opSnippet:"return inversesqrt(x);",cpuKernelImpl:qV}),mY={kernelName:Sp,backendName:"webgl",kernelFunc:fY};class gY{constructor(e,t,n,a,s,r){let i=arguments.length>7&&void 0!==arguments[7]&&arguments[7];this.variableNames=["updates","indices","defaultValue"],this.outputShape=r;const o=HW(s.length),c=HW(r.length);let l="";1===n?l="i":2===n&&(l="i, j");const u="getIndices(".concat(l,")");let h="";1===a?h="i":2===a&&(h="i, coords[1]");const d="getUpdates(".concat(h,")");let p="";i&&(p="coords[0], coords[1]");const f="getDefaultValue(".concat(p,")"),m=t>1?"strides[j]":"strides";this.userCode="\n        ".concat(o," strides = ").concat(o,"(").concat(s,");\n\n        void main() {\n          ").concat(c," coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ").concat(e,"; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ").concat(t,"; j++) {\n              int index = round(").concat(u,");\n              flattenedIndex += index * ").concat(m,";\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ").concat(d,";\n              found = true;\n            }\n          }\n          setOutput(mix(").concat(f,", sum, float(found)));\n        }\n      ")}}class yY{constructor(e,t,n,a,s,r){let i=arguments.length>7&&void 0!==arguments[7]&&arguments[7];this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=r;const o=HW(s.length),c=HW(r.length);let l="";1===n?l="i":2===n&&(l="i, j");const u="getIndices(".concat(l,")");let h="";1===a?h="i":2===a&&(h="i, coords[1]");const d="getUpdates(".concat(h,")");let p="";i&&(p="coords[0], coords[1]");const f="getDefaultValue(".concat(p,")"),m=t>1?"strides[j]":"strides",g=t>1?"strides[j + 1]":"strides";this.userCode="\n        ".concat(o," strides = ").concat(o,"(").concat(s,");\n\n        void main() {\n          ").concat(c," coords = getOutputCoords();\n          vec4 sum = vec4(0.);\n          vec4 found = vec4(0.);\n          for (int i = 0; i < ").concat(e,"; i+=2) {\n            ivec2 flattenedIndex = ivec2(0);\n            for (int j = 0; j < ").concat(t,"; j+=2) {\n              ivec4 index = round(").concat(u,");\n              flattenedIndex += index.xz * ").concat(m,";\n              if (j + 1 < ").concat(t,") {\n                flattenedIndex += index.yw * ").concat(g,";\n              }\n            }\n            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||\n                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {\n              vec4 updVals = ").concat(d,";\n              if (flattenedIndex[0] == coords[0]) {\n                sum.xy += updVals.xy;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[0] == coords[0] + 1) {\n                sum.zw += updVals.xy;\n                found.zw = vec2(1.);\n              }\n              if (flattenedIndex[1] == coords[0]) {\n                sum.xy += updVals.zw;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[1] == coords[0] + 1) {\n                sum.zw += updVals.zw;\n                found.zw = vec2(1.);\n              }\n            }\n          }\n          setOutput(mix(").concat(f,", sum, found));\n        }\n      ")}}const bY={kernelName:Cp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{indices:s,updates:r}=t,{shape:i}=a,{sliceRank:o,numUpdates:c,sliceSize:l,strides:u,outputSize:h}=pk(0,s,i),d=[h/l,l];if(0===h)return n.makeTensorInfo(i,s.dtype);const p=nH({inputs:{x:s},backend:n,attrs:{shape:[c,o]}}),f=nH({inputs:{x:r},backend:n,attrs:{shape:[c,l]}}),m=n.makeTensorInfo([],"float32",new Float32Array([0]));let g;g=$u().getBool("WEBGL_PACK")?new yY(c,o,p.shape.length,f.shape.length,u,d):new gY(c,o,p.shape.length,f.shape.length,u,d);const y=n.runWebGLProgram(g,[f,p,m],f.dtype),b=nH({inputs:{x:y},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(m),b}};class xY{constructor(e,t,n,a){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,n];const s="for (int i = 0; i < ".concat(Math.ceil(Math.log2(t+1)),"; ++i) { if (left >= right) break;"),r=2===$u().getNumber("WEBGL_VERSION")?"while (left < right) {":s,i="left"===a?"<":"<=";this.userCode="\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ".concat(r,"\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ").concat(i," value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     ")}}const vY={kernelName:Np,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{sortedSequence:s,values:r}=t,{side:i}=a,o=new xY(s.shape[0],s.shape[1],r.shape[1],i),c=[[s.shape[1]]];return n.runWebGLProgram(o,[s,r],"int32",c)}};class wY{constructor(e,t,n){let a,s;if(this.variableNames=["c","a","b"],this.outputShape=t,n>4)throw Error("Where for rank ".concat(n," is not yet supported"));if(1===n)s="resRC",a="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[],i=[];for(let a=0;a<t.length;a++)i.push("".concat(n[a])),a<e&&r.push("".concat(n[a]));a=r.join(),s=i.join()}const r=HW(n);this.userCode="\n      void main() {\n        ".concat(r," resRC = getOutputCoords();\n        float cVal = getC(").concat(a,");\n        if (cVal >= 1.0) {\n          setOutput(getA(").concat(s,"));\n        } else {\n          setOutput(getB(").concat(s,"));\n        }\n      }\n    ")}}const kY={kernelName:Tp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:a,t:s,e:r}=t,i=new wY(a.shape.length,s.shape,s.shape.length);return n.runWebGLProgram(i,[a,s,r],mm(s.dtype,r.dtype))}},SY=qU({opSnippet:"\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ".concat(pC,";\n  float scale = ").concat(fC,";\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n")}),CY={kernelName:Ep,backendName:"webgl",kernelFunc:SY},IY=qU({opSnippet:GU+"\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:XV}),NY={kernelName:Pp,backendName:"webgl",kernelFunc:IY},TY=qU({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),EY={kernelName:Mp,backendName:"webgl",kernelFunc:TY},RY=qU({opSnippet:GU+"\n  return sin(x);\n",packedOpSnippet:"\n  vec4 result = sin(x);\n  bvec4 isNaN = isnan(x);\n  ".concat(PU,"\n  return result;\n")}),_Y={kernelName:_p,backendName:"webgl",kernelFunc:RY},AY=qU({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),MY={kernelName:Ap,backendName:"webgl",kernelFunc:AY},PY=qU({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),DY={kernelName:Dp,backendName:"webgl",kernelFunc:PY},OY={kernelName:Lp,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{blockShape:r,paddings:i}=a;yu(s.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const o=r.reduce((e,t)=>e*t),c=[[0,0]];c.push(...i);for(let y=1+r.length;y<s.shape.length;++y)c.push([0,0]);const l=[],u=OX({inputs:{x:s},backend:n,attrs:{paddings:c,constantValue:0}}),h=oC(u.shape,r,o,!1),d=cC(h.length,r.length,!1),p=lC(u.shape,r,o,!1),f=nH({inputs:{x:u},backend:n,attrs:{shape:h}}),m=dH({inputs:{x:f},backend:n,attrs:{perm:d}}),g=nH({inputs:{x:m},backend:n,attrs:{shape:p}});return l.push(u),l.push(f),l.push(m),l.forEach(e=>n.disposeIntermediateTensorInfo(e)),g}};const FY={kernelName:jp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:a,values:s,denseShape:r,defaultValue:i}=t;if(1!==r.shape.length)throw new Error("Dense shape must be a vector, saw:\n         ".concat(r.shape));if(2!==a.shape.length)throw new Error("Indices must be a matrix, saw:\n         ".concat(a.shape));if(1!==s.shape.length)throw new Error("Values must be a vector, saw:\n         ".concat(s.shape));if(0!==i.shape.length)throw new Error("Default value must be a scalar, saw:\n        ".concat(i.shape));const o=n.readSync(a.dataId),c=n.readSync(s.dataId),l=n.readSync(r.dataId),u=n.readSync(i.dataId)[0],[h,d,p,f,m]=ZV(o,a.shape,a.dtype,c,s.dtype,l,u);return[n.makeTensorInfo(d,a.dtype,h),n.makeTensorInfo([d[0]],s.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(e=>Number(e)))),n.makeTensorInfo([m.length],a.dtype,new Int32Array(m))]}};const LY={kernelName:Wp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:a,inputShape:s,newShape:r}=t;if(2!==a.shape.length)throw new Error("Input indices should be a matrix but received shape ".concat(a.shape));if(1!==s.shape.length)throw new Error("Input shape should be a vector but received shape ".concat(s.shape));if(1!==r.shape.length)throw new Error("Target shape should be a vector but received shape ".concat(r.shape));const i=Array.from(n.readSync(s.dataId)),o=n.readSync(a.dataId),c=Array.from(n.readSync(r.dataId)),[l,u,h]=JV(o,a.shape,a.dtype,i,c);return[n.makeTensorInfo(u,a.dtype,l),n.makeTensorInfo([h.length],r.dtype,new Int32Array(h))]}};const zY={kernelName:Vp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:a,indices:s,segmentIds:r}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error("Indices should be a vector but received shape\n              ".concat(s.shape));if(1!==r.shape.length)throw new Error("Segment ids should be a vector but received shape\n              ".concat(r.shape));const i=n.readSync(a.dataId),o=n.readSync(s.dataId),c=n.readSync(r.dataId),[l,u]=$V(i,a.shape,a.dtype,o,c,!0);return n.makeTensorInfo(u,a.dtype,l)}};const BY={kernelName:Up,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:a,indices:s,segmentIds:r}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error("Indices should be a vector but received shape\n             ".concat(s.shape));if(1!==r.shape.length)throw new Error("Segment ids should be a vector but received shape\n             ".concat(r.shape));const i=n.readSync(a.dataId),o=n.readSync(s.dataId),c=n.readSync(r.dataId),[l,u]=$V(i,a.shape,a.dtype,o,c);return n.makeTensorInfo(u,a.dtype,l)}};const jY={kernelName:Hp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{sparseIndices:s,sparseValues:r,defaultValue:i}=t,{outputShape:o}=a,{sliceRank:c,numUpdates:l,sliceSize:u,strides:h,outputSize:d}=pk(0,s,o),p=!1;if("string"===r.dtype){const e=n.bufferSync(s),t=n.bufferSync(r),a=Gf(n.readSync(i.dataId)[0]),f=KV(e,t,o,d,u,l,c,h,a,p);return n.makeTensorInfo(o,f.dtype,f.values)}const f=new gY(l,c,s.shape.length,r.shape.length,h,[d,1],p),m=n.runWebGLProgram(f,[r,s,i],r.dtype),g=nH({inputs:{x:m},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(m),g}};const WY={kernelName:zp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{numOrSizeSplits:r,axis:i}=a,o=Eu(i,s.shape)[0],c=BC(s,r,o),l=s.shape.length,u=new Array(l).fill(0),h=s.shape.slice();return c.map(e=>{const t=[...h];t[o]=e;const a=cG({inputs:{x:s},backend:n,attrs:{begin:u,size:t}});return u[o]+=e,a})}},VY="return sqrt(x);",UY=qU({opSnippet:VY,packedOpSnippet:VY,cpuKernelImpl:eU}),HY={kernelName:Op,backendName:"webgl",kernelFunc:UY},GY={kernelName:qp,backendName:"webgl",kernelFunc:qU({opSnippet:"return x * x;"})},qY="return (a - b) * (a - b);",KY=KU({opSnippet:qY,packedOpSnippet:qY}),XY={kernelName:Gp,backendName:"webgl",kernelFunc:KY};const YY={kernelName:Kp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");const r=tI(n.readSync(s.dataId)),i=tU(r,"string",a);return n.makeTensorInfo(s.shape,"string",i)}};const QY={kernelName:uf,backendName:"webgl",kernelFunc:function(e){let{inputs:t,attrs:n,backend:a}=e;const{x:s}=t,r=vU+"\n    return x > 0.0 ? 1.0 : float(".concat(n.alpha,");\n  "),i=new xU(s.shape,r);return a.runWebGLProgram(i,[s],s.dtype)}};class ZY{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;const a=n.length,s=HW(n.length),r=HW(n.length);let i="";if(1===a)i="coords * strides + begin";else{let e=0;i=n.map((t,a)=>(e++,1===n.length?"coords * strides[".concat(a,"] + begin[").concat(a,"]"):"coords[".concat(e-1,"] * strides[").concat(a,"] + begin[").concat(a,"]"))).join(",")}this.userCode="\n      ".concat(s," begin = ").concat(s,"(").concat(e,");\n      ").concat(s," strides = ").concat(s,"(").concat(t,");\n\n      void main() {\n        ").concat(r," coords = getOutputCoords();\n        setOutput(getX(").concat(i,"));\n      }\n    ")}}const JY={kernelName:Xp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{begin:r,end:i,strides:o,beginMask:c,endMask:l,ellipsisMask:u,newAxisMask:h,shrinkAxisMask:d}=a,{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:x,strides:v}=Nb(s.shape,r,i,o,c,l,u,h,d);let w;if(m)w=nH({inputs:{x:s},backend:n,attrs:{shape:f}});else if(g||y){yu(s.shape.length>=1,()=>"Input must have rank at least 1, got: ".concat(s.shape.length));const e=pb(b,x,v),t=cG({inputs:{x:s},backend:n,attrs:{begin:b,size:e}});w=nH({inputs:{x:t},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(t)}else{if(n.shouldExecuteOnCPU([s])){const e=n.readSync(s.dataId),t=ty(s.shape,s.dtype,e),a=nU(p,t,v,b);w=n.makeTensorInfo(f,s.dtype,a.values)}else{const e=new ZY(b,v,p);w=n.runWebGLProgram(e,[s],s.dtype)}}const k=nH({inputs:{x:w},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(w),k}};const $Y={kernelName:Yp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{separator:s,nGramWidths:r,leftPad:i,rightPad:o,padWidth:c,preserveShortSequences:l}=a,{data:u,dataSplits:h}=t,d=n.readSync(u.dataId),p=n.readSync(h.dataId),[f,m]=aU(d,p,s,r,i,o,c,l);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(h.shape,"int32",m)]}};const eQ={kernelName:Qp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{skipEmpty:s}=a,{input:r,delimiter:i}=t;if("string"!==r.dtype)throw new Error("Input must be of datatype string");if(1!==r.shape.length)throw new Error("Input must be a vector, got shape: ".concat(r.shape));if(0!==i.shape.length)throw new Error("Delimiter must be a scalar, got shape: ".concat(i.shape));const o=n.readSync(r.dataId),c=n.readSync(i.dataId)[0],[l,u,h]=sU(o,c,s),d=u.length;return[n.makeTensorInfo([d,2],"int32",l),n.makeTensorInfo([d],"string",u),n.makeTensorInfo([2],"int32",new Int32Array(h))]}};const tQ={kernelName:Zp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{numBuckets:s}=a,{input:r}=t;if("string"!==r.dtype)throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const i=n.readSync(r.dataId),o=rU(i,s);return n.makeTensorInfo(r.shape,"int32",o)}},nQ=qU({opSnippet:"return tan(x);"}),aQ={kernelName:$p,backendName:"webgl",kernelFunc:nQ},sQ=qU({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),rQ={kernelName:ef,backendName:"webgl",kernelFunc:sQ};const iQ={kernelName:Ip,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{tensor:s,indices:r,updates:i}=t,{}=a,{sliceRank:o,numUpdates:c,sliceSize:l,strides:u,outputSize:h}=pk(0,r,s.shape),d=[h/l,l];if(0===h)return n.makeTensorInfo(s.shape,r.dtype);const p=nH({inputs:{x:r},backend:n,attrs:{shape:[c,o]}}),f=nH({inputs:{x:i},backend:n,attrs:{shape:[c,l]}}),m=nH({inputs:{x:s},backend:n,attrs:{shape:d}}),g=new gY(c,o,p.shape.length,f.shape.length,u,d,!1,!0),y=n.runWebGLProgram(g,[f,p,m],m.dtype),b=nH({inputs:{x:y},backend:n,attrs:{shape:s.shape}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(y),b}};class oQ{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[r]*t[r];this.outputShape=n,this.rank=n.length;const a=HW(this.rank),s=function(e){const t=e.length;if(t>5)throw Error("Tile for rank ".concat(t," is not yet supported"));if(1===t)return"imod(resRC, ".concat(e[0],")");const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],a=[];for(let s=0;s<e.length;s++)a.push("imod(".concat(n[s],", ").concat(e[s],")"));return a.join()}(e);this.userCode="\n      void main() {\n        ".concat(a," resRC = getOutputCoords();\n        setOutput(getA(").concat(s,"));\n      }\n    ")}}function cQ(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{reps:r}=a;if("string"===s.dtype||s.shape.length>5){const e=n.readSync(s.dataId),t="string"===s.dtype?e.map(e=>Gf(e)):e,a=ty(s.shape,s.dtype,t),i=oU(a,r);return n.makeTensorInfo(i.shape,i.dtype,i.values)}const i=new oQ(s.shape,r);return n.runWebGLProgram(i,[s],s.dtype)}const lQ={kernelName:tf,backendName:"webgl",kernelFunc:cQ};class uQ{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class hQ{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}function dQ(e,t){null!==t&&e.disposeIntermediateTensorInfo(t)}function pQ(e){let t=1;for(;t<e;)t*=2;return t}const fQ={kernelName:nf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{k:r,sorted:i}=a,o=$u().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),c=$u().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),l=s.shape,u=l[l.length-1];if(n.shouldExecuteOnCPU([s])||u<o||r>c){const e=n.readSync(s.dataId),[t,a]=cU(e,l,s.dtype,r,i);return[n.makeTensorInfo(t.shape,t.dtype,t.values),n.makeTensorInfo(a.shape,a.dtype,a.values)]}if(0===r)return l[l.length-1]=0,[n.makeTensorInfo(l,s.dtype,[]),n.makeTensorInfo(l,"int32",[])];if(1===u)return[s,qq({attrs:{shape:l,dtype:"int32",value:0},backend:n})];const h=n.texData.get(s.dataId),d=null!==h&&h.isPacked,p=d?n.unpackTensor(s):s,f=vu(l)/u,m=nH({inputs:{x:p},attrs:{shape:[f,u]},backend:n});d&&dQ(n,p);const g=pQ(r),y=pQ(u);let b=null;const x=()=>null===b?[m,m]:[m,b],v=(e,t,a)=>{const s=x(),r=new uQ(a),i=[[u],[null===b?1:0],[Number.NEGATIVE_INFINITY],[e],[t]],o=b;b=n.runWebGLProgram(r,s,"int32",i),dQ(n,o)};for(let I=1;I<g;I*=2){const e=2*I;for(let t=I;t>=1;t/=2)v(e,t,[f,y])}for(let I=y;I>g;I/=2){const e=x(),t=new hQ([f,I/2]),a=[[u],[null===b?1:0],[g]],s=b;b=n.runWebGLProgram(t,e,"int32",a),dQ(n,s);const r=g/2,i=2*r;for(let n=r;n>=1;n/=2)v(i,n,b.shape)}let w=b;b=cG({inputs:{x:b},backend:n,attrs:{begin:0,size:[f,r]}}),dQ(n,w);let k=hK({inputs:{x:m,indices:b},backend:n,attrs:{axis:1,batchDims:1}});dQ(n,m);const S=l.slice(0,-1);S.push(r),w=b,b=nH({inputs:{x:b},attrs:{shape:S},backend:n}),dQ(n,w);const C=k;return k=nH({inputs:{x:k},attrs:{shape:S},backend:n}),dQ(n,C),[k,b]}};class mQ{constructor(e,t,n,a,s,r){this.variableNames=["Image","Transforms"],this.outputShape=r;const i="nearest"===n?1:2;let o;switch(a){case"constant":default:o=1;break;case"reflect":o=2;break;case"wrap":o=3;break;case"nearest":o=4}this.userCode="\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(".concat(o," == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (").concat(o," == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (").concat(o," == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ").concat(e," && 0 <= coordX && coordX < ").concat(t,") {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(").concat(s,");\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(").concat(s,");\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(").concat(t,"));\n                float mapY = mapCoord(inY, float(").concat(e,"));\n\n                if (").concat(i," == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        ")}}const gQ={kernelName:af,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{image:s,transforms:r}=t,{interpolation:i,fillMode:o,fillValue:c,outputShape:l}=a,[u,h,d,p]=s.shape,[f,m]=null!=l?l:[h,d],g=new mQ(h,d,i,o,c,[u,f,m,p]);return n.runWebGLProgram(g,[s,r],"float32")}};const yQ={kernelName:rf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,attrs:n,backend:a}=e,{axis:s}=n,{x:r}=t;NW(r,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const i=a.readSync(r.dataId),{outputValues:o,outputShape:c,indices:l}=uU(i,s,r.shape,r.dtype);return[a.makeTensorInfo(c,r.dtype,o),a.makeTensorInfo([l.length],"int32",l)]}};const bQ={kernelName:of,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{value:s}=t;let{axis:r}=a;r<0&&(r+=s.shape.length);const i=s,o=i.shape.length,c=s.shape[r],l=new Array(o-1);let u=0;for(let m=0;m<o;m++)m!==r&&(l[u++]=i.shape[m]);const h=[],d=new Array(o).fill(0),p=i.shape.slice();p[r]=1;const f=new Array(c);for(let m=0;m<f.length;m++){d[r]=m;const e=cG({inputs:{x:i},backend:n,attrs:{begin:d,size:p}}),t=nH({inputs:{x:e},backend:n,attrs:{shape:l}});f[m]=t,h.push(e)}return h.forEach(e=>n.disposeIntermediateTensorInfo(e)),f}};class xQ{constructor(e,t){this.variableNames=["x","segmentIds"];const n=e.windowSize,a=e.batchSize,s=e.inSize,r=e.numSegments,i=r*Math.ceil(s/n);this.outputShape=[a,i];const o=4*Math.floor(n/4),c=n%4,l="\n        sumValue += dot(values, segFilter);\n    ";let u="";s%n>0&&(u="\n        if (inIdx < 0 || inIdx >= ".concat(s,") {\n          return initializationValue;\n        }\n      "));let h="";s%n>0&&(h="\n        if (inIdx < 0 || inIdx >= ".concat(s,") {\n          return -1.0;\n        }\n      ")),this.userCode="\n      const float initializationValue = ".concat("0.0",";\n\n      float getValue(int batch, int inIdx) {\n        ").concat(u,"\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ").concat(h,"\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ").concat(r,")) * float(").concat(n,"));\n        int currentSeg = int(mod(float(outIdx), float(").concat(r,")));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ").concat(o,"; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ").concat(l,"\n        }\n\n        int inIdx = inOffset + ").concat(o,";\n        if (").concat(1===c,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ").concat(l,"\n        } else if (").concat(2===c,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ").concat(l,"\n        } else if (").concat(3===c,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ").concat(l,"\n        }\n        setOutput(").concat("sumValue",");\n      }\n    ")}}const vQ={kernelName:cf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,segmentIds:r}=t,{numSegments:i}=a,o=s.shape.length,c=[];let l=0;const u=ev([l],o);let h=s;null!=u&&(h=dH({inputs:{x:s},backend:n,attrs:{perm:u}}),c.push(h),l=nv(1,o)[0]);const d=$C(h.shape,l,i),p=vu([h.shape[l]]),f=nH({inputs:{x:h},backend:n,attrs:{shape:[-1,p]}});c.push(f);const m=gm(s.dtype),g=(e,t,a,s,r)=>{const i=e.shape[0],o=e.shape[1],l=JC(o,r),u=new xQ({windowSize:l,inSize:o,batchSize:i,numSegments:r},t),h=n.compileAndRun(u,[e,a],s);if(c.push(h),h.shape[1]===r)return h;const d=UX({backend:n,attrs:{start:0,stop:r,step:1,dtype:"float32"}}),p=cQ({inputs:{x:d},backend:n,attrs:{reps:[o/l]}});c.push(d),c.push(p);return g(h,t,p,s,r)},y=nH({inputs:{x:g(f,"unsortedSegmentSum",r,m,i)},backend:n,attrs:{shape:d}});let b=y;if(null!=u){c.push(y);const e=tv(u);b=dH({inputs:{x:b},backend:n,attrs:{perm:e}})}return c.forEach(e=>n.disposeIntermediateTensorInfo(e)),b}},wQ=[mH,yH,xH,wH,CH,TH,EH,RH,OH,FH,zH,jH,VH,HH,qH,YH,QH,$H,eG,tG,sG,uG,hG,dG,pG,bG,wG,CG,zU,TG,OG,UG,XG,QG,ZG,JG,$G,tq,aq,rq,hq,dq,pq,mq,bq,wq,kq,Cq,Nq,Tq,Rq,_q,Mq,Dq,Fq,zq,Wq,Hq,Kq,Yq,Jq,eK,aK,iK,oK,lK,dK,fK,gK,FU,yK,MG,xK,wK,SK,WU,IK,TK,EK,_K,MK,DK,FK,zK,WK,UK,GK,KK,XK,YK,JK,$K,eX,tX,nX,sX,oX,lX,bX,tH,vX,kX,CX,NX,mG,EX,AX,MX,FX,zX,HU,BX,jX,WX,VX,HX,yG,dX,qX,XX,QX,aH,$X,tY,sY,iY,lY,hY,pY,mY,bY,vY,kY,CY,NY,EY,_Y,MY,lG,yX,DY,OY,FY,LY,zY,BY,jY,WY,HY,GY,XY,YY,QY,JY,$Y,eQ,tQ,mX,hH,aQ,rQ,iQ,lQ,fQ,gQ,pH,yQ,bQ,vQ,_X];for(const n of wQ)Sf(n);var kQ=n(879);const SQ=$u();SQ.registerFlag("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE",()=>15),SQ.registerFlag("WEBGPU_CPU_FORWARD",()=>!0),SQ.registerFlag("WEBGPU_MATMUL_PROGRAM_TYPE",()=>-1),SQ.registerFlag("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE",()=>!0),SQ.registerFlag("WEBGPU_USE_LOW_POWER_GPU",()=>!1),SQ.registerFlag("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e3),SQ.registerFlag("WEBGPU_USE_PROFILE_TOOL",()=>!1),SQ.registerFlag("WEBGPU_IMPORT_EXTERNAL_TEXTURE",()=>!0),SQ.registerFlag("WEBGPU_USE_NAIVE_CONV2D_DEBUG",()=>!1),SQ.registerFlag("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL",()=>-1),SQ.registerFlag("WEBGPU_CONV_SEPARATE_IM2COL_SHADER",()=>!1),SQ.registerFlag("WEBGPU_PRINT_SHADER",()=>""),SQ.registerFlag("WEBGPU_ENGINE_COMPILE_ONLY",()=>!1);class CQ{constructor(e){e&&(this.vendor=e.vendor,this.architecture=e.architecture,this.intelGPUGeneration=this.getIntelGPUGeneration())}getIntelGPUGeneration(){if(this.isIntel()){if(this.architecture.startsWith("gen"))return Number(this.architecture.match(/\d+/));if(this.architecture.startsWith("xe"))return 12}return 0}isIntel(){return"intel"===this.vendor}}class IQ{constructor(e){this.device=e,this.numUsedBuffers=0,this.numFreeBuffers=0,this.freeBuffers=new Map,this.usedBuffers=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireBuffer(e,t){let n,a=arguments.length>2&&void 0!==arguments[2]&&arguments[2],s=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];const r=NQ(e,t);return s?(this.freeBuffers.has(r)||this.freeBuffers.set(r,[]),this.freeBuffers.get(r).length>0?(n=this.freeBuffers.get(r).pop(),this.numFreeBuffers--):(n=this.device.createBuffer({size:e,usage:t,mappedAtCreation:a}),this.numBytesAllocated+=e)):(n=this.device.createBuffer({size:e,usage:t,mappedAtCreation:a}),this.numBytesAllocated+=e),this.usedBuffers.has(r)||this.usedBuffers.set(r,[]),this.usedBuffers.get(r).push(n),this.numUsedBuffers++,this.numBytesUsed+=e,n}releaseBuffer(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];if(0===this.freeBuffers.size)return;const n=e.size,a=NQ(n,e.usage),s=this.usedBuffers.get(a),r=s.indexOf(e);if(r<0)throw new Error("Cannot find the buffer in buffer manager");s[r]=s[s.length-1],s.pop(),this.numUsedBuffers--,this.numBytesUsed-=n,t?(this.freeBuffers.get(a).push(e),this.numFreeBuffers++):(e.destroy(),this.numBytesAllocated-=n)}getNumUsedBuffers(){return this.numUsedBuffers}getNumFreeBuffers(){return this.numFreeBuffers}dispose(){this.freeBuffers.forEach((e,t)=>{e.forEach(e=>{e.destroy()})}),this.usedBuffers.forEach((e,t)=>{e.forEach(e=>{e.destroy()})}),this.freeBuffers=new Map,this.usedBuffers=new Map,this.numUsedBuffers=0,this.numFreeBuffers=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function NQ(e,t){return"".concat(e,"_").concat(t)}class TQ{constructor(e){this.device=e,this.numUsedTextures=0,this.numFreeTextures=0,this.freeTextures=new Map,this.usedTextures=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireTexture(e,t,n,a){const s=e*t*RQ(n),r=EQ(e,t,n,a);if(this.freeTextures.has(r)||this.freeTextures.set(r,[]),this.usedTextures.has(r)||this.usedTextures.set(r,[]),this.numBytesUsed+=s,this.numUsedTextures++,this.freeTextures.get(r).length>0){this.numFreeTextures--;const e=this.freeTextures.get(r).shift();return this.usedTextures.get(r).push(e),e}this.numBytesAllocated+=s;const i=this.device.createTexture({size:[e,t],format:n,usage:a});return this.usedTextures.get(r).push(i),i}releaseTexture(e){if(0===this.freeTextures.size)return;const t=e.width,n=e.height,a=e.format,s=EQ(t,n,a,e.usage);this.freeTextures.has(s)||this.freeTextures.set(s,[]),this.freeTextures.get(s).push(e),this.numFreeTextures++,this.numUsedTextures--;const r=this.usedTextures.get(s),i=r.indexOf(e);if(i<0)throw new Error("Cannot release a texture that was never provided by this texture manager");r.splice(i,1);const o=t*n*RQ(a);this.numBytesUsed-=o}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){this.freeTextures.forEach((e,t)=>{e.forEach(e=>{e.destroy()})}),this.usedTextures.forEach((e,t)=>{e.forEach(e=>{e.destroy()})}),this.freeTextures=new Map,this.usedTextures=new Map,this.numUsedTextures=0,this.numFreeTextures=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function EQ(e,t,n,a){return"".concat(e,"_").concat(t,"_").concat(n,"_").concat(a)}function RQ(e){if("rgba8unorm"===e)return 16;throw new Error("".concat(e," is not supported!"))}function _Q(e,t){if(Math.max(...e)>5)throw new Error("Cannot symbolically compute strides for rank > 6 tensor.");const n=e.length,a=e.map(e=>"".concat(t,".").concat("xyzwuv"[e])),s=new Array(n-1);s[n-2]=a[n-1];for(let r=n-3;r>=0;--r)s[r]="(".concat(s[r+1]," * ").concat(a[r+1],")");return s}const AQ=(e,t,n)=>"int32"===n?"atomicAdd(".concat(e,", bitcast<i32>(").concat(t,"));"):"\n          {\n            var oldValue = 0;\n            loop {\n              let newValueF32 = bitcast<f32>(oldValue) + (".concat(t,");\n              let newValue = bitcast<i32>(newValueF32);\n              let res = atomicCompareExchangeWeak(").concat(e,", oldValue, newValue);\n              if res.exchanged {\n                break;\n              }\n              oldValue = res.old_value;\n            }\n          }");var MQ;!function(e){e[e.FROM_PIXELS=0]="FROM_PIXELS",e[e.DRAW=1]="DRAW"}(MQ||(MQ={}));const PQ=(e,t,n,a,s)=>{const r=function(e,t,n){const a=[],s=n.workgroupSize[0]*n.workgroupSize[1]*n.workgroupSize[2];if(n.outputComponent=n.outputComponent?n.outputComponent:1,a.push("\n\n      var<private> localId: vec3<u32>;\n      var<private> localIndex: u32;\n      var<private> globalId: vec3<u32>;\n      var<private> numWorkgroups: vec3<u32>;\n      var<private> workgroupId: vec3<u32>;\n\n      // Only used when the y/z dimension of workgroup size is 1.\n      fn getGlobalIndex() -> i32 {\n        ".concat(UQ(n)?"  return i32(globalId.x);":"  return i32((workgroupId.z * numWorkgroups.x * numWorkgroups.y +\n                workgroupId.y * numWorkgroups.x + workgroupId.x) * ".concat(s,"u +\n                localIndex);\n        "),"\n      }\n    ")),null!=n.pixelsOpType){const s=n.pixelsOpType===MQ.FROM_PIXELS?"@group(0) @binding(0) var<storage, read_write> result: array<".concat(HQ(t.dtype,n.outputComponent),">;"):"@group(0) @binding(1) var<storage, read> inBuf : array<".concat(HQ(e[0].dtype,n.outputComponent),">;"),r=3===t.shape.length?"vec2<i32>":"i32";a.push("\n        struct Uniform {\n          outShapeStrides : ".concat(r,",\n          size            : i32,\n          numChannels     : i32,\n          alpha           : f32,\n        };\n\n        ").concat(s,"\n        @group(0) @binding(2) var<uniform> uniforms: Uniform;\n      "));const i=GQ(n);return[BQ,a.join("\n"),WQ(t.shape),n.getUserCode(),zQ(i,n)].join("\n")}let r,i,o="struct Uniforms { NAN : f32, INFINITY : f32, ";n.variableNames.forEach((t,n)=>{const a=OQ(e[n].shape.length);o+="".concat(t.charAt(0).toLowerCase()+t.slice(1),"Shape : ").concat(a,", "),r=e[n].shape.length-1,i=OQ(r),o+="".concat(t.charAt(0).toLowerCase()+t.slice(1),"ShapeStrides: ").concat(i,", ")});const c=OQ(t.shape.length);o+="outShape : ".concat(c,", "),r=t.shape.length-1,i=OQ(r),o+="\n         outShapeStrides: ".concat(i,", "),n.size&&(o+="size : i32, ");n.uniforms&&(o+=n.uniforms);o+="};",o=function(e){const t=/(\w+)\s*:\s*vec(5|6)/g;e=e.replace(t,e=>"@align(16) "+e);const n=/vec(5|6)\s*,\s*(\w+)/g;return e=e.replace(n,(e,t,n)=>"vec".concat(t,", @align(16) ").concat(n))}(o),a.push(o),n.atomic?a.push("\n      @group(0) @binding(0) var<storage, read_write> result: array<atomic<i32>>;\n    "):a.push("\n      @group(0) @binding(0) var<storage, read_write> result: array<".concat(HQ(t.dtype,n.outputComponent),">;\n    "));n.variableNames.forEach((t,s)=>{a.push("\n      @group(0) @binding(".concat(1+s,") var<storage, read> ").concat(t,": array<").concat(n.variableComponents?HQ(e[s].dtype,n.variableComponents[s]):HQ(e[s].dtype,n.outputComponent),">;\n        "))}),""!==o&&a.push("\n      @group(0) @binding(".concat(1+n.variableNames.length,") var<uniform> uniforms: Uniforms;\n      "));const l=function(e,t){const{x:n,y:a=[],z:s=[]}=t,r=e.length,i=n.length+a.length+s.length;if(i!==r)return"";if(n.length===r){const e=OQ(r);return"fn getOutputCoords() -> ".concat(e,"{\n    let globalIndex = getGlobalIndex();\n    return getCoordsFromIndex(globalIndex);\n  }\n  ")}let o="";const c=[n,a,s];for(let d=0;d<c.length;d++){const e=c[d];if(0!==e.length)if(1===e.length)o+="let d".concat(e[0]," = i32(globalId[").concat(d,"]);");else{const t=_Q(e,"uniforms.outShape");o+="var index".concat(d," = i32(globalId[").concat(d,"]);");for(let n=0;n<t.length;n++)o+="let d".concat(e[n]," = index").concat(d," / ").concat(t[n],";"),n===t.length-1?o+="let d".concat(e[n+1]," = ")+"index".concat(d," - d").concat(e[n]," * ").concat(t[n],";"):o+="index".concat(d," = index").concat(d," - d").concat(e[n]," * ").concat(t[n],";")}}const l=[];for(let d=0;d<i;d++)l.push("d".concat(d));const u=OQ(i);let h="fn getOutputCoords() -> ".concat(u," {\n  ").concat(o,"\n");0===l.length?h+="return ".concat(u,"(0); }"):h+="return ".concat(u,"(").concat(l.join(","),"); }");return h}(t.shape,n.dispatchLayout),u=[BQ,a.join("\n")+jQ,WQ(t.shape),l,VQ(t.shape.length)];n.atomic||u.push(function(e,t,n){const a=e.length,s=HQ(t,n);let r="fn setOutputAtIndex(flatIndex : i32, value : ".concat(DQ(n),") {\n      result[flatIndex] = ").concat(s,"(value);\n    }\n\n    fn setOutputAtIndexI32(flatIndex : i32, value : ").concat(DQ(n,"i32"),") {\n      result[flatIndex] = ").concat(s,"(value);\n    }\n    ");if(a>=2){const e=["d0","d1","d2","d3","d4","d5"].slice(0,a),t=OQ(a);r+="\n      fn setOutputAtCoords(".concat(e.map(e=>"".concat(e," : i32")).join(", "),", value : ").concat(DQ(n),") {\n        let flatIndex = getOutputIndexFromCoords(").concat(t,"(").concat(e.join(", "),"));\n        setOutputAtIndex(flatIndex").concat(1===n?"":" / ".concat(n),", value);\n      }\n      fn setOutputAtCoordsI32(").concat(e.map(e=>"".concat(e," : i32")).join(", "),", value : ").concat(DQ(n,"i32"),") {\n        let flatIndex = getOutputIndexFromCoords(").concat(t,"(").concat(e.join(", "),"));\n        setOutputAtIndexI32(flatIndex").concat(1===n?"":" / ".concat(n),", value);\n      }\n    ")}return r}(t.shape,t.dtype,n.outputComponent));n.variableNames.forEach((t,n)=>{u.push("".concat(WQ(e[n].shape,t)))});const h=e.map((e,a)=>function(e,t,n,a){let s=function(e,t){const n=e.name,a=e.shape.length,s=OQ(a),r="get"+n.charAt(0).toUpperCase()+n.slice(1),i=["d0","d1","d2","d3","d4","d5"].slice(0,a),o=i.map(e=>"".concat(e," : i32")).join(", ");if(a<1)return"\n      fn ".concat(r,"() -> ").concat(DQ(t)," {\n        return ").concat(DQ(t),"(").concat(n,"[0]);\n      }\n    ");const c="uniforms.".concat(n.charAt(0).toLowerCase()+n.slice(1),"Shape");let l="".concat(a,"D");0===a&&(l="1D");return"\n    fn ".concat(r,"(").concat(o,") -> ").concat(DQ(t)," {\n      return ").concat(DQ(t),"(").concat(n,"[getIndexFromCoords").concat(l,"(").concat(s,"(").concat(i.join(","),"),\n        ").concat(c,")").concat(1===t?"":" / ".concat(t),"]);\n    }\n   ")}(e,n);const r=e.shape;r.length<=t.length&&(s+=function(e,t,n,a){const s=e.name,r=s.charAt(0).toUpperCase()+s.slice(1),i="get"+r+"ByOutput",o=e.shape.length,c=t.length,l=OQ(c);if(ku(e.shape,t)&&a)return"\n    fn ".concat(i,"Index(globalIndex : i32) -> ").concat(DQ(n)," {\n      return ").concat(DQ(n),"(").concat(s,"[globalIndex]);\n    }\n\n    fn ").concat(i,"Coords(coords : ").concat(l,") -> ").concat(DQ(n)," {\n      return ").concat(DQ(n),"(").concat(s,"[").concat(c>1?"getOutputIndexFromCoords(coords)":"coords").concat(1===n?"":" / ".concat(n),"]);\n    }\n    ");const u=Ty(e.shape,t),h=c-o;let d="";if(0===o)return"\n    fn ".concat(i,"Index(globalIndex : i32) -> ").concat(DQ(n),"{\n      return get").concat(r,"();\n    }\n\n    fn ").concat(i,"Coords(coords : ").concat(l,") -> ").concat(DQ(n),"{\n      return get").concat(r,"();\n    }\n  ");d=c<2&&u.length>=1?"coords = 0;":u.map(e=>"coords.".concat(FQ(e+h)," = 0;")).join("\n");let p="";if(c<2&&o>0)p="coords";else if(c>1){const t=OQ(o),n=e.shape.map((e,t)=>"coords.".concat(FQ(t+h))).join(", ");p="".concat(t,"(").concat(n,")")}else p="coords";const f="uniforms.".concat(s.charAt(0).toLowerCase()+s.slice(1),"Shape"),m="".concat(o,"D");return"\n  fn ".concat(i,"Index(globalIndex : i32) -> ").concat(DQ(n)," {\n    var coords = getCoordsFromIndex(globalIndex);\n    ").concat(d,"\n    return ").concat(DQ(n),"(").concat(s,"[getIndexFromCoords").concat(m,"(").concat(p,", ").concat(f,")").concat(1===n?"":" / ".concat(n),"]);\n  }\n\n  fn ").concat(i,"Coords(coordsIn : ").concat(l,") -> ").concat(DQ(n)," {\n    var coords = coordsIn;\n    ").concat(d,"\n    return ").concat(DQ(n),"(").concat(s,"[getIndexFromCoords").concat(m,"(").concat(p,", ").concat(f,")").concat(1===n?"":" / ".concat(n),"]);\n  }\n")}(e,t,n,a));return s}(e,t.shape,n.variableComponents?n.variableComponents[a]:n.outputComponent,n.dispatchLayout.x.length===t.shape.length)).join("\n");u.push(h),u.push(n.getUserCode());const d=GQ(n);u.push(zQ(d,n));const p=u.join("\n");return p}(n,{dtype:a.dtype,shape:a.shape},t),i=e.createShaderModule({code:r,label:t.constructor.name});let o=$u().get("WEBGPU_PRINT_SHADER");if(""!==o){o=o.toLowerCase();const e=o.split(",");("all"===o||e.some(e=>t.shaderKey.toLowerCase().includes(e)))&&(console.group(t.shaderKey),console.debug(r),console.groupEnd())}return s?e.createComputePipelineAsync({compute:{module:i,entryPoint:"_start"},label:t.constructor.name,layout:"auto"}):e.createComputePipeline({compute:{module:i,entryPoint:"_start"},label:t.constructor.name,layout:"auto"})},DQ=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"f32";switch(e){case 1:return"".concat(t);case 2:return"vec2<".concat(t,">");case 3:return"vec3<".concat(t,">");case 4:return"vec4<".concat(t,">");default:throw new Error("".concat(e,"-component ").concat(t," is not supported."))}};function OQ(e){if(e<=1)return"i32";if(2===e)return"vec2<i32>";if(3===e)return"vec3<i32>";if(4===e)return"vec4<i32>";if(5===e)return"vec5";if(6===e)return"vec6";throw Error("GPU for rank ".concat(e," is not yet supported"))}function FQ(e){if(0===e)return"x";if(1===e)return"y";if(2===e)return"z";if(3===e)return"w";if(4===e)return"u";if(5===e)return"v";throw Error("Index ".concat(e," is not yet supported"))}function LQ(){let e;switch(arguments.length){case 0:e="\n        fn main()\n      ";break;case 1:e="\n        fn main(".concat(arguments.length<=0?void 0:arguments[0]," : i32)\n      ");break;default:throw Error("Unreachable")}return e}function zQ(e,t){let n;return n="\n     ".concat(function(e){return"\n  @compute @workgroup_size(".concat(e.workgroupSize[0],", ").concat(e.workgroupSize[1],", ").concat(e.workgroupSize[2],")\n")}(t),"\n      fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,\n                @builtin(global_invocation_id) GlobalId : vec3<u32>,\n                @builtin(local_invocation_index) LocalIndex: u32,\n                @builtin(workgroup_id) WorkgroupId : vec3<u32>,\n                @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {\n        localId = LocalId;\n        localIndex = LocalIndex;\n        globalId = GlobalId;\n        numWorkgroups = NumWorkgroups;\n        workgroupId = WorkgroupId;\n        ").concat(e?"main(getGlobalIndex());":"main();",";\n      }\n    "),n}const BQ="\n  struct vec5 {x: i32, y: i32, z: i32, w: i32, u: i32};\n  struct vec6 {x: i32, y: i32, z: i32, w: i32, u: i32, v: i32};\n\n  // Checks whether coordinates lie within the bounds of the shape.\n  fn coordsInBounds2D(coord : vec2<i32>, shape : vec2<i32>) -> bool {\n    return all(coord >= vec2<i32>(0)) && all(coord < shape);\n  }\n  fn coordsInBounds3D(coord : vec3<i32>, shape : vec3<i32>) -> bool {\n    return all(coord >= vec3<i32>(0)) && all(coord < shape);\n  }\n  fn coordsInBounds4D(coord : vec4<i32>, shape : vec4<i32>) -> bool {\n    return all(coord >= vec4<i32>(0)) && all(coord < shape);\n  }\n\n  fn getIndexFromCoords1D(coord : i32, shape : i32) -> i32 {\n    return coord;\n  }\n  fn getIndexFromCoords2D(coords : vec2<i32>, shape : vec2<i32>) -> i32 {\n    return dot(coords, vec2<i32>(shape.y, 1));\n  }\n  fn getIndexFromCoords3D(coords : vec3<i32>, shape : vec3<i32>) -> i32 {\n    return dot(coords, vec3<i32>(shape.y * shape.z, shape.z, 1));\n  }\n  fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\n    return dot(coords, vec4<i32>(\n        shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\n  }\n  fn getIndexFromCoords5D(coords : vec5, shape : vec5) -> i32 {\n    let shapeStrides: vec5 = vec5(shape.y * shape.z * shape.w * shape.u, shape.z * shape.w * shape.u, shape.w * shape.u, shape.u, 1);\n    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u;\n  }\n  fn getIndexFromCoords6D(coords : vec6, shape : vec6) -> i32 {\n    let shapeStrides: vec6 = vec6(shape.y * shape.z * shape.w * shape.u * shape.v, shape.z * shape.w * shape.u * shape.v, shape.w * shape.u * shape.v, shape.u * shape.v, shape.v, 1);\n    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u + coords.v*shapeStrides.v;\n  }\n\n  // NaN defination in IEEE 754-1985 is :\n  //   - sign = either 0 or 1.\n  //   - biased exponent = all 1 bits.\n  //   - fraction = anything except all 0 bits (since all 0 bits represents infinity).\n  // https://en.wikipedia.org/wiki/IEEE_754-1985#Representation_of_non-numbers\n  fn isnan(val: f32) -> bool {\n    let floatToUint: u32 = bitcast<u32>(val);\n    return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n  }\n  fn isnanVec4(val : vec4<f32>) -> vec4<bool> {\n    let floatToUint: vec4<u32> = bitcast<vec4<u32>>(val);\n    return (floatToUint & vec4<u32>(0x7fffffffu)) > vec4<u32>(0x7f800000u);\n  }\n",jQ="\n  fn isinf(val: f32) -> bool {\n    return abs(val) == uniforms.INFINITY;\n  }\n";function WQ(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"";const n=e.length,a=""!==t?"get".concat(t.charAt(0).toUpperCase()+t.slice(1),"CoordsFromIndex"):"getCoordsFromIndex",s=""!==t?"".concat(t.charAt(0).toLowerCase()+t.slice(1),"ShapeStrides"):"outShapeStrides";if(n<=1)return"fn ".concat(a,"(index : i32) -> i32 { return index; }");const r=Bu(e),i=OQ(n),o=[];for(let l=0;l<n;l++)o.push("d".concat(l));if(1===r.length)return"    fn ".concat(a,"(index : i32) -> vec2<i32> {\n      let d0 = index / uniforms.").concat(s,"; let d1 = index - d0 * uniforms.").concat(s,";\n      return vec2<i32>(d0, d1);\n    }");let c;return c="var index2 = index;"+r.map((e,t)=>{const n="let ".concat(o[t]," = index2 / uniforms.").concat(s,".").concat(FQ(t)),a=t===r.length-1?"let ".concat(o[t+1]," = index2 - ").concat(o[t]," * uniforms.").concat(s,".").concat(FQ(t)):"index2 = index2 - ".concat(o[t]," * uniforms.").concat(s,".").concat(FQ(t));return"".concat(n,"; ").concat(a,";")}).join(""),"\n    fn ".concat(a,"(index : i32) -> ").concat(i," {\n      ").concat(c,"\n      return ").concat(i,"(").concat(o.join(","),");\n    }\n  ")}function VQ(e){let t="";switch(e){case 0:case 1:t+="\n        fn getOutputIndexFromCoords(coords : i32) -> i32 {\n          return coords;\n        }\n        ";break;case 2:t+="\n        fn getOutputIndexFromCoords(coords : vec2<i32>) -> i32 {\n          return dot(coords, vec2<i32>(uniforms.outShapeStrides, 1));\n        }\n        ";break;case 3:t+="\n        fn getOutputIndexFromCoords(coords : vec3<i32>) -> i32 {\n          return dot(coords, vec3<i32>(uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, 1));\n        }\n        ";break;case 4:t+="\n        fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\n          return dot(coords, vec4<i32>(\n            uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, uniforms.outShapeStrides.z, 1));\n        }\n        ";break;case 5:t+="\n        fn getOutputIndexFromCoords(coords : vec5) -> i32 {\n          return coords.x * uniforms.outShapeStrides.x +\n              coords.y * uniforms.outShapeStrides.y +\n              coords.z * uniforms.outShapeStrides.z +\n              coords.w * uniforms.outShapeStrides.w +\n              coords.u;\n        }\n        ";break;case 6:t+="\n        fn getOutputIndexFromCoords(coords : vec6) -> i32 {\n          return coords.x * uniforms.outShapeStrides.x +\n              coords.y * uniforms.outShapeStrides.y +\n              coords.z * uniforms.outShapeStrides.z +\n              coords.w * uniforms.outShapeStrides.w +\n              coords.u * uniforms.outShapeStrides.u +\n              coords.v;\n        }\n        ";break;default:yu(!1,()=>"Unsupported ".concat(e,"D shape"))}return t}function UQ(e){return 1===e.dispatch[1]&&1===e.dispatch[2]}function HQ(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if("float32"===e)return DQ(t,"f32");if("int32"===e||"bool"===e)return DQ(t,"i32");throw new Error("type ".concat(e," is not supported."))}function GQ(e){return(!e.dispatchLayout.hasOwnProperty("y")||0===e.dispatchLayout.y.length)&&(!e.dispatchLayout.hasOwnProperty("z")||0===e.dispatchLayout.z.length)}const qQ=e=>{let t=1;for(let n=0;n<e.length;n++)t*=e[n];return t};function KQ(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[1,1,1],a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[1,1,1];const[s,r,i]=[Math.ceil(qQ(e.x.map(e=>t[e]))/(n[0]*a[0])),e.y?Math.ceil(qQ(e.y.map(e=>t[e]))/(n[1]*a[1])):1,e.z?Math.ceil(qQ(e.z.map(e=>t[e]))/(n[2]*a[2])):1];return[s,r,i]}function XQ(e,t){if(arguments.length>2&&void 0!==arguments[2]&&arguments[2])return[8,8,1];const n=qQ(e.x.map(e=>t[e])),a=qQ(e.y.map(e=>t[e]));return n<=4?[4,16,1]:a<=4?[16,4,1]:[16,16,1]}function YQ(e,t){if(arguments.length>2&&void 0!==arguments[2]&&arguments[2])return[4,4,1];const n=qQ(e.x.map(e=>t[e])),a=qQ(e.y.map(e=>t[e]));return n<=4?[1,2,1]:a<=4?[2,1,1]:[2,2,1]}function QQ(e){return{x:e.map((e,t)=>t)}}function ZQ(e){if("float32"===e||"int32"===e||"bool"===e||"string"===e)return 4;if("complex64"===e)return 8;throw new Error("Unknown dtype ".concat(e))}function JQ(){return!("undefined"===typeof globalThis||!globalThis.navigator||!globalThis.navigator.gpu)}function $Q(e,t){Array.isArray(e)||(e=[e]),e.forEach(e=>{null!=e&&yu("complex64"!==e.dtype,()=>"".concat(t," does not support complex64 tensors ")+"in the WebGPU backend.")})}var eZ;!function(e){e[e.MatMulReduceProgram=0]="MatMulReduceProgram",e[e.MatMulSplitKProgram=1]="MatMulSplitKProgram",e[e.MatMulSmallOutputSizeProgram=2]="MatMulSmallOutputSizeProgram",e[e.MatMulPackedProgram=3]="MatMulPackedProgram",e[e.MatMulMax=4]="MatMulMax"}(eZ||(eZ={}));const tZ=$u().getNumber("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD");class nZ extends uu{nextDataId(){return nZ.nextDataId++}constructor(e,t){if(super(),this.commandQueueOwnedIds=new WeakSet,this.dispatchCountInPass=0,this.disposed=!1,this.downloadWaitMs=0,this.tensorDataPendingDisposal=[],this.queryResolveBuffer=null,this.querySet=null,this.querySetCount=2,this.stagingPendingDisposal=[],this.uniformPendingDisposal=[],this.uploadWaitMs=0,this.hasReadSyncWarned=!1,this.hasTimestampQueryWarned=!1,!JQ())throw new Error("WebGPU is not supported on this device");this.pipelineCache={},this.device=e,this.queue=e.queue,this.commandEncoder=null,this.computePassEncoder=null,this.adapterInfo=new CQ(t),this.supportTimestampQuery=this.device.features.has("timestamp-query"),this.thresholdToIncreaseWorkgroups=this.adapterInfo.intelGPUGeneration>=12?16:8,this.bufferManager=new IQ(this.device),this.textureManager=new TQ(this.device),this.tensorMap=new lu(this,Gm()),$u().getBool("WEBGPU_USE_PROFILE_TOOL")&&(this.dummyCanvas=document.createElement("canvas"),this.dummyCanvas.width=1,this.dummyCanvas.height=1,this.dummyContext=this.dummyCanvas.getContext("webgpu"),this.dummyContext.configure({device:e,format:"bgra8unorm"}),document.body.appendChild(this.dummyCanvas))}floatPrecision(){return 32}disposeData(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this.tensorMap.has(e))return!0;const n=this.tensorMap.get(e);return t?n.refCount=0:n.refCount--,!(n.refCount>0)&&(null!=n.complexTensorInfos&&(this.disposeData(n.complexTensorInfos.real.dataId),this.disposeData(n.complexTensorInfos.imag.dataId)),this.commandQueueOwnedIds.has(e)?(this.tensorDataPendingDisposal.push(e),!0):(this.releaseResource(e),this.tensorMap.delete(e),!0))}memory(){return{numBytesInGPU:this.bufferManager.numBytesUsed,numBytesAllocatedInGPU:this.bufferManager.numBytesAllocated,unreliable:!1}}releaseResource(e){const t=this.tensorMap.get(e);t&&t.resource&&(t.external||(t.resource instanceof GPUBuffer?this.bufferManager.releaseBuffer(t.resource):t.resource instanceof GPUTexture&&this.textureManager.releaseTexture(t.resource)),t.resource=null)}refCount(e){if(this.tensorMap.has(e)){return this.tensorMap.get(e).refCount}return 0}incRef(e){this.tensorMap.get(e).refCount++}decRef(e){if(this.tensorMap.has(e)){this.tensorMap.get(e).refCount--}}write(e,t,n){if("complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const a={id:this.nextDataId()};return this.tensorMap.set(a,{dtype:n,shape:t,values:e,refCount:1}),a}move(e,t,n,a,s){if("complex64"===a)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.tensorMap.set(e,{dtype:a,shape:n,values:t,refCount:s})}submitQueue(){this.queue.submit([this.commandEncoder.finish()]),this.commandEncoder=null,this.dispatchCountInPass=0,this.commandQueueOwnedIds=new WeakSet,this.tensorDataPendingDisposal.forEach(e=>{this.releaseResource(e),this.tensorMap.delete(e)}),this.uniformPendingDisposal.forEach(e=>this.bufferManager.releaseBuffer(e)),this.stagingPendingDisposal.forEach(e=>this.bufferManager.releaseBuffer(e,!1)),this.tensorDataPendingDisposal=[],this.uniformPendingDisposal=[],this.stagingPendingDisposal=[]}ensureCommandEncoderReady(){this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder())}endComputePassEncoder(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}async checkCompileCompletionAsync(){let e;try{e=await Promise.all(Object.values(this.pipelineCache))}catch(G5){throw new Error(G5.message)}Object.keys(this.pipelineCache).map((t,n)=>{this.pipelineCache[t]=e[n]})}async getBufferData(e){if($u().getBool("WEBGPU_ENGINE_COMPILE_ONLY"))return console.warn("The data may be invalid since WEBGPU_ENGINE_COMPILE_ONLY is true, this can only be called when WEBGPU_ENGINE_COMPILE_ONLY is false"),null;const t=e.size,n=this.bufferManager.acquireBuffer(t,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ);this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(e,0,n,0,t),this.submitQueue(),await n.mapAsync(GPUMapMode.READ);const a=n.getMappedRange().slice(0);return n.unmap(),null!=n&&this.bufferManager.releaseBuffer(n),$u().getBool("WEBGPU_USE_PROFILE_TOOL")&&(yu(void 0!==this.dummyContext,()=>"Fail to get context for profiling tool"),this.dummyContext.getCurrentTexture()),a}convertAndCacheOnCPU(e,t){const n=this.tensorMap.get(e);return n.values=t,n.values}readSync(e){const t=this.tensorMap.get(e),{values:n,complexTensorInfos:a}=t;if(null!=n||"string"===t.dtype)return n;if("complex64"===t.dtype){const t=Vu(wC(this.readSync(a.real.dataId),this.readSync(a.imag.dataId)).buffer,"float32");return this.convertAndCacheOnCPU(e,t),t}this.hasReadSyncWarned||(this.hasReadSyncWarned=!0,console.warn("The performance of synchronously reading data from GPU to CPU is poor on the webgpu backend, please use asynchronous APIs instead."));const s=["opaque","premultiplied"],r=t.resource,i=r.size;yu(i%4===0,()=>"Because there is 4 bytes for one pixel, buffer size must be multiple of 4.");const o=i/4,c=new ArrayBuffer(i),l=256,u=256,h=s.map(e=>new OffscreenCanvas(l,u)),d=new OffscreenCanvas(l,u);this.endComputePassEncoder(),h.map((e,t)=>{const n=e.getContext("webgpu");return n.configure({device:this.device,format:"bgra8unorm",usage:GPUTextureUsage.COPY_DST,alphaMode:s[t]}),n.getCurrentTexture()}).map((e,t)=>{const n=(n,a,i)=>{this.ensureCommandEncoderReady(),this.commandEncoder.copyBufferToTexture({buffer:r,bytesPerRow:1024,offset:i},{texture:e},{width:n,height:a}),this.submitQueue();const o=d.getContext("2d",{willReadFrequently:!0});o.clearRect(0,0,n,a),o.drawImage(h[t],0,0);const l=o.getImageData(0,0,n,a).data,u=s[t],p=new Uint8ClampedArray(c,i,n*a*4);for(let e=0;e<p.length;e+=4)if("premultiplied"===u)p[e+3]=l[e+3];else{const t=l[e];p[e]=l[e+2],p[e+1]=l[e+1],p[e+2]=t}},a=Math.floor(o/65536);let i=l,p=u,f=0;for(let s=0;s<a;s++)n(i,p,f),f+=262144;const m=o%65536;p=Math.floor(m/l),p>0&&(n(i,p,f),f+=1024*p),i=m%l,i>0&&n(i,1,f)});const p=Vu(c,t.dtype);return this.convertAndCacheOnCPU(e,p),p}async read(e){if(!this.tensorMap.has(e))throw new Error("Tensor ".concat(e," was not registered!"));const t=this.tensorMap.get(e),{values:n}=t;if(null!=n)return n;let a;if("complex64"===t.dtype){const e=await Promise.all([this.read(t.complexTensorInfos.real.dataId),this.read(t.complexTensorInfos.imag.dataId)]);a=wC(e[0],e[1])}else{a=Vu(await this.getBufferData(t.resource),t.dtype)}return this.convertAndCacheOnCPU(e,a),a}copyBuffer(e){const t=e.size,n=e.usage,a=this.bufferManager.acquireBuffer(t,n);return this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(e,0,a,0,t),this.submitQueue(),a}createTensorFromGPUData(e,t,n){let a=e.buffer;if("complex64"===n)throw new Error("Cannot write to a complex64 dtype. ");const s={id:this.nextDataId()};this.tensorMap.set(s,{dtype:n,shape:t,values:null,refCount:1,external:e.zeroCopy});const r=this.tensorMap.get(s),i=ZQ(r.dtype)*vu(r.shape);if(e.buffer.size<i)throw new Error("GPUBuffer size(".concat(e.buffer.size,") is smaller than tensor size(").concat(i,")!"));if((e.buffer.usage&(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))!==(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))throw new Error("GPUBuffer.usage should include GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC!");return!0!==e.zeroCopy&&(a=this.copyBuffer(a)),r.resource=a,Gm().makeTensorFromDataId(s,t,n,this)}readToGPU(e){const t=this.tensorMap.get(e),{values:n,dtype:a,shape:s,resource:r}=t;if("complex64"===a)throw new Error("Does not support reading buffer for complex64 dtype.");if(null==r)throw null!=n?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const i=r,o=i.size,c=i.usage,l=this.bufferManager.acquireBuffer(o,c);this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(r,0,l,0,o),this.submitQueue();const u=this.makeTensorInfo(s,a),h=Gm().makeTensorFromTensorInfo(u);return this.tensorMap.get(u.dataId).resource=l,{tensorRef:h,buffer:l}}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map(e=>Gf(e));return ty(e.shape,e.dtype,n)}catch(n){throw new Error("Failed to decode encoded string bytes into utf-8")}return ty(e.shape,e.dtype,t)}async time(e){this.supportTimestampQuery||this.hasTimestampQueryWarned||(console.warn("This device doesn't support timestamp-query extension. Start Chrome browser with flag --enable-dawn-features=allow_unsafe_apis to try it again. Otherwise, zero will be shown for the kernel time when profiling mode is enabled."),this.hasTimestampQueryWarned=!0);const t=this.activeTimers,n=[];let a=!1;null==this.programTimersStack?(this.programTimersStack=n,a=!0):this.activeTimers.push(n),this.activeTimers=n,e();const s=Kf(this.activeTimers.map(e=>e.query)).filter(e=>null!=e),r=Kf(this.activeTimers.map(e=>e.name)).filter(e=>null!=e);this.activeTimers=t,a&&(this.programTimersStack=null);const i={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null},o=await Promise.all(s);return i.kernelMs=gu(o),i.getExtraProfileInfo=()=>o.map((e,t)=>({name:r[t],ms:e})).map(e=>"".concat(e.name,": ").concat(e.ms)).join(", "),this.uploadWaitMs=0,this.downloadWaitMs=0,i}makeTensorInfo(e,t,n){"string"===t&&null!=n&&n.length>0&&Du(n[0])&&(n=n.map(e=>Hf(e)));return{dataId:this.write(n,e,t),shape:e,dtype:t}}tensorToBinding(e){if(!e)return null;const t=this.tensorMap.get(e.dataId).resource;return t instanceof GPUBuffer?{buffer:t}:t instanceof GPUTexture?t.createView():t}uploadToGPU(e){const t=this.tensorMap.get(e);if(null!=t.resource)return;const n=ZQ(t.dtype)*vu(t.shape);let a;const s=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST;if(t.values){if(a=this.bufferManager.acquireBuffer(n,s,!0),"unmapped"===a.mapState){const e=this.bufferManager.acquireBuffer(n,GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC,!0,!1),s=e.getMappedRange();"int32"===t.dtype||"bool"===t.dtype?new Int32Array(s).set(t.values):new Float32Array(s).set(t.values),e.unmap(),this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(e,0,a,0,n),this.stagingPendingDisposal.push(e)}else{const e=a.getMappedRange();"int32"===t.dtype||"bool"===t.dtype?new Int32Array(e).set(t.values):new Float32Array(e).set(t.values),a.unmap()}t.values=null}else a=this.bufferManager.acquireBuffer(n,s);t.resource=a}makeUniforms(e){let t=0,n=0;const a=[];let s=1;e.forEach(e=>{let r;switch(0===e.data.length&&(e.data=[1]),e.data.length){case 1:r=4;break;case 2:r=8;break;case 3:case 4:case 5:case 6:r=16;break;default:yu(!1,()=>"Unsupported ".concat(e.data.length,"D shape"))}5!==n&&6!==n||(r=16),r>s&&(s=r),t=Math.ceil(t/r)*r,n=e.data.length,a.push(t),t+=4*e.data.length}),t=Math.ceil(t/s)*s;const r=new ArrayBuffer(t);e.forEach((e,t)=>{const n=a[t];"int32"===e.type?new Int32Array(r,n,e.data.length).set(e.data):"uint32"===e.type?new Uint32Array(r,n,e.data.length).set(e.data):new Float32Array(r,n,e.data.length).set(e.data)});const i=this.bufferManager.acquireBuffer(t,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);return this.queue.writeBuffer(i,0,r,0,t),this.uniformPendingDisposal.push(i),{offset:0,size:t,buffer:i}}runWebGPUProgram(e,t,n,a,s){if(s||(s=this.makeTensorInfo(e.outputShape,n)),0===vu(s.shape))return this.tensorMap.get(s.dataId).values=_u(s.dtype,0),s;this.uploadToGPU(s.dataId),e.dispatch=((e,t)=>{const n=e.limits.maxComputeWorkgroupsPerDimension,a=t.dispatchLayout,s=t.dispatch;if(s.every(e=>e<=n))return s;yu(s[0]>n&&void 0===a.y&&void 0===a.z,()=>"Dispatch size exceeds WebGPU limits in Y or Z dimension.");let r=Math.ceil(Math.sqrt(s[0]));return r>n?(r=Math.ceil(Math.cbrt(s[0])),yu(r<=n,()=>"Total dispatch size exceeds WebGPU maximum."),[r,r,r]):[r,r,1]})(this.device,e);const r=t.map((t,n)=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");return this.uploadToGPU(t.dataId),{dtype:this.tensorMap.get(t.dataId).dtype,shape:t.shape,name:e.variableNames[n]}});e.shaderKey=function(e,t,n){let a=e.shaderKey;if(null!=e.pixelsOpType)return a;const s=[],r=[];t.forEach(e=>{s.push(e.shape),r.push(e.dtype)}),s.push(n.shape),r.push(n.dtype);const i=t.map(e=>Ty(e.shape,n.shape)),o=t.map(e=>ku(e.shape,n.shape)).join("_"),c=i.map(e=>e.join("_")).join(";"),l=UQ(e)?"flatDispatch":"";return a+="_"+(e.workgroupSize?e.workgroupSize.join(","):"")+s.map(e=>e.length).join(",")+r.join(",")+e.variableNames.join(",")+c+o+l,a}(e,r,s);const i=$u().getBool("WEBGPU_ENGINE_COMPILE_ONLY");return e.shaderKey in this.pipelineCache||(this.pipelineCache[e.shaderKey]=PQ(this.device,e,r,s,i)),e.pipeline=this.pipelineCache[e.shaderKey],i||this.recordAndSubmit(e,s,t,a),s}recordAndSubmit(e,t,n,a){if(e.pipeline instanceof Promise)throw new Error("Please call checkCompileCompletionAsync to ensure parallel compilation is done!");let s=[],r=[];const i="int32";if(null==e.pixelsOpType){s.push({type:"float32",data:[NaN]},{type:"float32",data:[1/0]}),r=n.concat(t).map(e=>e.shape);const e="int32";r.map(t=>{s.push({type:e,data:t});const n=Bu(t);s.push({type:e,data:n})})}else{const e=Bu(t.shape);s.push({type:i,data:e})}if(e.size){const t=vu(e.outputShape);s.push({type:i,data:[e.outputComponent?t/e.outputComponent:t]})}a&&(s=[...s,...a]);const o=[this.tensorToBinding(t),...n.map(e=>this.tensorToBinding(e)),this.makeUniforms(s)];n.forEach(e=>{this.commandQueueOwnedIds.add(e.dataId)}),this.commandQueueOwnedIds.add(t.dataId);const c=this.device.createBindGroup({layout:e.pipeline.getBindGroupLayout(0),entries:o.map((e,t)=>({binding:t,resource:e}))}),l=null!=this.activeTimers;this.ensureCommandEncoderReady();const u={};l&&this.supportTimestampQuery?(this.endComputePassEncoder(),null==this.querySet&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.querySetCount})),u.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:0,endOfPassWriteIndex:1},this.computePassEncoder=this.commandEncoder.beginComputePass(u)):this.computePassEncoder||(this.computePassEncoder=this.commandEncoder.beginComputePass(u)),this.computePassEncoder.setPipeline(e.pipeline),this.computePassEncoder.setBindGroup(0,c),this.computePassEncoder.dispatchWorkgroups(e.dispatch[0],e.dispatch[1],e.dispatch[2]),this.dispatchCountInPass++,(l||$u().get("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE")<=this.dispatchCountInPass||e.pixelsOpType===MQ.DRAW)&&(this.endComputePassEncoder(),l?this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime()}):this.submitQueue())}async getQueryTime(){if(!this.supportTimestampQuery)return 0;null==this.queryResolveBuffer&&(this.queryResolveBuffer=this.bufferManager.acquireBuffer(8*this.querySetCount,GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST|GPUBufferUsage.QUERY_RESOLVE)),this.commandEncoder.resolveQuerySet(this.querySet,0,this.querySetCount,this.queryResolveBuffer,0);const e=this.bufferManager.acquireBuffer(8*this.querySetCount,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,e,0,8*this.querySetCount),this.submitQueue(),await e.mapAsync(GPUMapMode.READ);const t=new BigUint64Array(e.getMappedRange()),n=Number(t[1]-t[0])/1e6;return e.unmap(),this.bufferManager.releaseBuffer(e),n}shouldExecuteOnCPU(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:tZ;return $u().getBool("WEBGPU_CPU_FORWARD")&&e.every(e=>null==this.tensorMap.get(e.dataId).resource&&vu(e.shape)<t)}numDataIds(){return this.tensorMap.numDataIds()-this.tensorDataPendingDisposal.length}dispose(){this.disposed||(null!=this.querySet&&this.querySet.destroy(),this.bufferManager.dispose(),this.textureManager.dispose(),this.disposed=!0)}}var aZ;nZ.nextDataId=0,JQ()&&Zm("webgpu",async()=>{const e={powerPreference:$u().get("WEBGPU_USE_LOW_POWER_GPU")?"low-power":"high-performance"},t=await navigator.gpu.requestAdapter(e),n={},a=[];t.features.has("timestamp-query")&&a.push("timestamp-query"),t.features.has("bgra8unorm-storage")&&a.push(["bgra8unorm-storage"]),n.requiredFeatures=a;const s=t.limits;n.requiredLimits={maxComputeWorkgroupStorageSize:s.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:s.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:s.maxStorageBufferBindingSize,maxBufferSize:s.maxBufferSize,maxComputeWorkgroupSizeX:s.maxComputeWorkgroupSizeX,maxComputeInvocationsPerWorkgroup:s.maxComputeInvocationsPerWorkgroup};const r=await t.requestDevice(n),i="info"in t?t.info:"requestAdapterInfo"in t?await t.requestAdapterInfo():void 0;return new nZ(r,i)},3),function(e){e[e.ADD=0]="ADD",e[e.ATAN2=1]="ATAN2",e[e.COMPLEX_MULTIPLY_IMAG=2]="COMPLEX_MULTIPLY_IMAG",e[e.COMPLEX_MULTIPLY_REAL=3]="COMPLEX_MULTIPLY_REAL",e[e.DIV=4]="DIV",e[e.ELU_DER=5]="ELU_DER",e[e.EQUAL=6]="EQUAL",e[e.FLOOR_DIV=7]="FLOOR_DIV",e[e.GREATER=8]="GREATER",e[e.GREATER_EQUAL=9]="GREATER_EQUAL",e[e.LESS=10]="LESS",e[e.LESS_EQUAL=11]="LESS_EQUAL",e[e.LOGICAL_AND=12]="LOGICAL_AND",e[e.LOGICAL_OR=13]="LOGICAL_OR",e[e.MAX=14]="MAX",e[e.MIN=15]="MIN",e[e.MOD=16]="MOD",e[e.MUL=17]="MUL",e[e.NOT_EQUAL=18]="NOT_EQUAL",e[e.POW=19]="POW",e[e.PRELU=20]="PRELU",e[e.SQUARED_DIFFERENCE=21]="SQUARED_DIFFERENCE",e[e.SUB=22]="SUB"}(aZ||(aZ={}));function sZ(e,t){let n;do{switch(e){case aZ.ATAN2:n="let resultTemp = atan2(a, b);";break;case aZ.MAX:n="let resultTemp = max(a, b);";break;case aZ.MIN:n="let resultTemp = min(a, b);";break;case aZ.MOD:n=t?"\n  let isNaN = !vec4<bool>(b);\n  var resultTemp = vec4<f32>(a % b);\n  if (!((a[0] < 0. && b[0] < 0.) || (a[0] >= 0. && b[0] > 0.))) {\n    resultTemp[0] = (resultTemp[0] + b[0]) % b[0];\n  }\n  if (!((a[1] < 0. && b[1] < 0.) || (a[1] >= 0. && b[1] > 0.))) {\n    resultTemp[1] = (resultTemp[1] + b[1]) % b[1];\n  }\n  if (!((a[2] < 0. && b[2] < 0.) || (a[2] >= 0. && b[2] > 0.))) {\n    resultTemp[2] = (resultTemp[2] + b[2]) % b[2];\n  }\n  if (!((a[3] < 0. && b[3] < 0.) || (a[3] >= 0. && b[3] > 0.))) {\n    resultTemp[3] = (resultTemp[3] + b[3]) % b[3];\n  }\n":"\n  let isNaN = b == 0.;\n  var resultTemp = a % b;\n  resultTemp = select((resultTemp + b) % b, resultTemp,\n      (a < 0. && b < 0.) || (a >= 0. && b > 0.));\n";break;case aZ.NOT_EQUAL:n=t?"\n  var resultTemp = vec4<f32>(a != b);\n  let valueForNaN = 1.0;\n":"\n  var resultTemp = f32(a != b);\n  let valueForNaN = 1.0;\n";break;case aZ.POW:n=t?"\n  let isModRound1Bool = vec4<i32>(round(abs(b) % vec4<f32>(2.0))) == vec4<i32>(1);\n  let isModRound1 = vec4<f32>(isModRound1Bool);\n  let multiplier = sign(a) * isModRound1 + (vec4<f32>(1.0) - isModRound1);\n  var resultTemp = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  let isExpZero = b == vec4<f32>(0.0);\n  if (isExpZero.r) {\n    resultTemp.r = 1.0;\n  }\n  if (isExpZero.g) {\n    resultTemp.g = 1.0;\n  }\n  if (isExpZero.b) {\n    resultTemp.b = 1.0;\n  }\n  if (isExpZero.a) {\n    resultTemp.a = 1.0;\n  }\n  let isNaN = (a < vec4<f32>(0.0)) & (floor(b) < b);\n":"\n  let isNaN = a < 0.0 && floor(b) < b;\n  if (b == 0.0) {\n    return 1.0;\n  }\n  var resultTemp = select(sign(a) * pow(abs(a), b), pow(abs(a), b),\n      round(abs(b) % 2.0) != 1.0);\n";break;default:continue}let a,s,r;return t?(a="isnanVec4",s="vec4<f32>",r="vec4<bool>"):(a="isnan",s="f32",r="bool"),"\n      let aIsNaN = ".concat(a,"(a);\n      let aPostLegalization = select(a, ").concat(s,"(42), aIsNaN);\n      let bIsNaN = ").concat(a,"(b);\n      let bPostLegalization = select(b, ").concat(s,"(42), bIsNaN);\n      let isNaN = false;\n      let valueForNaN = uniforms.NAN;\n      {\n        let a = aPostLegalization;\n        let b = bPostLegalization;\n        ").concat(n,"\n        return select(\n            resultTemp, ").concat(s,"(valueForNaN),\n            ").concat(r,"(isNaN) | aIsNaN | bIsNaN);\n      }\n    ")}while(0);switch(e){case aZ.ADD:n="let resultTemp = a + b;";break;case aZ.COMPLEX_MULTIPLY_IMAG:n="let resultTemp = areal * bimag + aimag * breal;";break;case aZ.COMPLEX_MULTIPLY_REAL:n="let resultTemp = areal * breal - aimag * bimag;";break;case aZ.DIV:n="let resultTemp = a / b;";break;case aZ.ELU_DER:n="let resultTemp = select(a * (b + 1.0), a, b >= b - b);";break;case aZ.EQUAL:n="\n  let zero = sign(a) * 0 + 0;\n  let one = sign(b) * 0 + 1;\n  let resultTemp = select(zero, one, a == b);\n";break;case aZ.FLOOR_DIV:n="\n  let remainder =\n      select(a % b, round(a % b), (round(a) == a) & (round(b) == b));\n  let quotient = (a - remainder) / b;\n  let resultTemp =\n      round(select(quotient, quotient - 1, sign(remainder) == -sign(b)));\n";break;case aZ.GREATER:n="\n  let zero = sign(a) * 0 + 0;\n  let one = sign(b) * 0 + 1;\n  let resultTemp = select(zero, one, a > b);\n";break;case aZ.GREATER_EQUAL:n="\n  let zero = sign(a) * 0 + 0;\n  let one = sign(b) * 0 + 1;\n  let resultTemp = select(zero, one, a >= b);\n";break;case aZ.LESS:n="\n  let zero = sign(a) * 0 + 0;\n  let one = sign(b) * 0 + 1;\n  let resultTemp = select(zero, one, a < b);\n";break;case aZ.LESS_EQUAL:n="\n  let zero = sign(a) * 0 + 0;\n  let one = sign(b) * 0 + 1;\n  let resultTemp = select(zero, one, a <= b);\n";break;case aZ.LOGICAL_AND:return t?"return (vec4<f32>(a >= vec4<f32>(1.0)) *\n  vec4<f32>(b >= vec4<f32>(1.0)));":"return f32(a >= 1.0 && b >= 1.0);";case aZ.LOGICAL_OR:return t?"return min(vec4<f32>(a >= vec4<f32>(1.0)) +\n  vec4<f32>(b >= vec4<f32>(1.0)), vec4<f32>(1.0));":"return f32(a >= 1.0 || b >= 1.0);";case aZ.MUL:n="let resultTemp = a * b;";break;case aZ.PRELU:return t?"\n  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));\n  return (aLessThanZero * (b * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);\n":"if (a < 0.0) { return b * a; }  return a;";case aZ.SQUARED_DIFFERENCE:n="let resultTemp = (a - b) * (a - b);";break;case aZ.SUB:n="let resultTemp = a - b;"}return"\n    ".concat(n,"\n    return resultTemp;\n  ")}var rZ;!function(e){e[e.ABS=0]="ABS",e[e.ACOS=1]="ACOS",e[e.ACOSH=2]="ACOSH",e[e.ASIN=3]="ASIN",e[e.ASINH=4]="ASINH",e[e.ATAN=5]="ATAN",e[e.ATANH=6]="ATANH",e[e.CEIL=7]="CEIL",e[e.COS=8]="COS",e[e.COSH=9]="COSH",e[e.ELU=10]="ELU",e[e.ERF=11]="ERF",e[e.EXP=12]="EXP",e[e.EXPM1=13]="EXPM1",e[e.FLOOR=14]="FLOOR",e[e.IS_FINITE=15]="IS_FINITE",e[e.IS_INF=16]="IS_INF",e[e.IS_NAN=17]="IS_NAN",e[e.LINEAR=18]="LINEAR",e[e.LOG=19]="LOG",e[e.LOG1P=20]="LOG1P",e[e.LOGICAL_NOT=21]="LOGICAL_NOT",e[e.NEG=22]="NEG",e[e.RELU=23]="RELU",e[e.RELU6=24]="RELU6",e[e.LEAKYRELU=25]="LEAKYRELU",e[e.RECIPROCAL=26]="RECIPROCAL",e[e.ROUND=27]="ROUND",e[e.RSQRT=28]="RSQRT",e[e.SELU=29]="SELU",e[e.SIGMOID=30]="SIGMOID",e[e.SIGN=31]="SIGN",e[e.SIN=32]="SIN",e[e.SINH=33]="SINH",e[e.SOFTPLUS=34]="SOFTPLUS",e[e.SQRT=35]="SQRT",e[e.SQUARE=36]="SQUARE",e[e.STEP=37]="STEP",e[e.TAN=38]="TAN",e[e.TANH=39]="TANH",e[e.TO_INT=40]="TO_INT"}(rZ||(rZ={}));const iZ='\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  let p = '.concat(mC,";\n  let a1 = ").concat(gC,";\n  let a2 = ").concat(yC,";\n  let a3 = ").concat(bC,";\n  let a4 = ").concat(xC,";\n  let a5 = ").concat(vC,";\n\n  let sign = sign(a);\n  let absA = abs(a);\n  let t = 1.0 / (1.0 + p * absA);\n  return sign * (1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * exp(-absA * absA));\n"),oZ="\n  if (a >= 0.0) {\n    return ".concat(fC," * a;\n  } else {\n    return ").concat(pC," * (exp(a) - 1.0);\n  }\n");function cZ(e,t){switch(e){case rZ.ABS:return"return abs(a);";case rZ.ACOS:return"\n  if (abs(a) > 1.) {\n    return uniforms.NAN;\n  }\n  return acos(a);\n";case rZ.ACOSH:return"\n  if (a < 1.) {\n    return uniforms.NAN;\n  }\n  return acosh(a);\n";case rZ.ASIN:return"\n  if (abs(a) > 1.) {\n    return uniforms.NAN;\n  }\n  return asin(a);\n";case rZ.ASINH:return"return asinh(a);";case rZ.ATAN:return"\n  if (isnan(a)) {\n    return uniforms.NAN;\n  }\n  return atan(a);\n";case rZ.ATANH:return"\n  if (abs(a) > 1.) {\n    return uniforms.NAN;\n  }\n  if (a == 1.) {\n    return uniforms.INFINITY;\n  }\n  if (a == -1.) {\n    return -uniforms.INFINITY;\n  }\n  return atanh(a);\n";case rZ.COS:return"return cos(a);";case rZ.COSH:return"\n  let e2x = exp(-a);\n  return (e2x + 1.0 / e2x) / 2.0;\n";case rZ.CEIL:return"return ceil(a);";case rZ.ELU:return t?"\n  var resFloat = exp(a) - vec4<f32>(1.0);\n  if (a.r >= 0.0) {\n    resFloat.r = a.r;\n  }\n  if (a.g >= 0.0) {\n    resFloat.g = a.g;\n  }\n  if (a.b >= 0.0) {\n    resFloat.b = a.b;\n  }\n  if (a.a >= 0.0) {\n    resFloat.a = a.a;\n  }\n  return resFloat;\n":"if (a >= 0.0) { return a; }  return (exp(a) - 1.0);";case rZ.ERF:return iZ;case rZ.EXP:return"return exp(a);";case rZ.EXPM1:return"return exp(a) - 1.0;";case rZ.FLOOR:return"return floor(a);";case rZ.IS_FINITE:return"return f32(!isnan(a) && !isinf(a));";case rZ.IS_INF:return"return f32(isinf(a));";case rZ.IS_NAN:return"return f32(isnan(a));";case rZ.LINEAR:return"return a;";case rZ.LOG:return"if (a < 0.0) { return uniforms.NAN; }\n  return log(a);";case rZ.LOG1P:return"\n  if (isnan(a)) { return a; }\n  return log(1.0 + a);\n";case rZ.LOGICAL_NOT:return"return f32(!(a >= 1.0));";case rZ.NEG:return"return -a;";case rZ.LEAKYRELU:return t?"\n  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));\n  return (aLessThanZero * (uniforms.alpha * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);\n":"if (a < 0.0) { return uniforms.alpha * a; } return a;";case rZ.RECIPROCAL:return"return 1.0 / a;";case rZ.RELU:return t?"\n  return select(a, vec4<f32>(0.0), a < vec4<f32>(0.0));\n":"return select(a, 0.0, a < 0.0);";case rZ.RELU6:return t?"return clamp(a, vec4<f32>(0.0, 0.0, 0.0, 0.0), vec4<f32>(6.0, 6.0, 6.0, 6.0));":"return clamp(a, 0.0, 6.0);";case rZ.ROUND:return"return round(a);";case rZ.RSQRT:return"return inverseSqrt(a);";case rZ.SELU:return oZ;case rZ.SIGMOID:return"return 1.0 / (1.0 + exp(-1.0 * a));";case rZ.SIGN:return"return sign(a);";case rZ.SIN:return"return sin(a);";case rZ.SINH:return"\n  let e2x = exp(a);\n  return (e2x - 1.0 / e2x) / 2.0;\n";case rZ.SOFTPLUS:return"\n  let epsilon = 1.1920928955078125e-7;\n  let threshold = log(epsilon) + 2.0;\n\n  let too_large = a > -threshold;\n  let too_small = a < threshold;\n  let exp_a = exp(a);\n\n  if (too_large) {\n    return a;\n  } else if (too_small) {\n    return exp_a;\n  } else {\n    return log(exp_a + 1.0);\n  }\n";case rZ.SQRT:return"return sqrt(a);";case rZ.SQUARE:return"return a * a;";case rZ.STEP:return"\n  if (isnan(a)) {\n    return a;\n  }\n\n  return select(uniforms.stepAlpha, 1.0, a > 0.0);\n";case rZ.TAN:return"return tan(a);";case rZ.TANH:return"\n  let e2x = exp(-2.0 * abs(a));\n  return sign(a) * (1.0 - e2x) / (1.0 + e2x);\n";case rZ.TO_INT:return"return f32(i32((a)));";default:throw new Error("BinaryType ".concat(e," is not implemented!"))}}function lZ(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:3;if(null===e)return"";let s="";if("linear"===e)s=cZ(rZ.LINEAR);else if("relu"===e)s=cZ(rZ.RELU,n);else if("elu"===e)s=cZ(rZ.ELU,n);else if("relu6"===e)s=cZ(rZ.RELU6,n);else if("prelu"===e)s=sZ(aZ.PRELU,n);else if("sigmoid"===e)s=cZ(rZ.SIGMOID,n);else{if("leakyrelu"!==e)throw new Error("Activation ".concat(e," has not been implemented for the WebGPU backend."));s=cZ(rZ.LEAKYRELU,n)}const r=DQ(n?4:1);let i="";return i=t?"\n      fn activation(a : ".concat(r,", coords : vec").concat(a,"<i32>) -> ").concat(r," {\n        let b = getPreluActivationWeightsByOutputCoords(coords);\n        ").concat(s,"\n      }"):"\n      fn activation(a : ".concat(r,", coords : vec").concat(a,"<i32>) -> ").concat(r," {\n        ").concat(s,"\n      }"),i}function uZ(e,t){return"\n      ".concat(e?"value = value + getBiasByOutputCoords(coords);":"","\n      ").concat(t?"value = activation(value, coords);":"","\n      ")}function hZ(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4],s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;yu(e&&1===s||!e,()=>"transposeA ".concat(e," is not compatible with component size ").concat(s));const r="\n      ".concat(e?"value = getA(batch, col, row);":"value = getA(batch, row, col);","\n\n    "),i=t?"value = getB(batch, col, row);":"value = getB(batch, row, col);";return"\n  fn mm_readA(batch: i32, row: i32, col: i32) -> ".concat(DQ(s)," {\n    var value = ").concat(DQ(s),"(0.0);\n    ").concat(n&&a?r:"\n    ".concat(e?"if(row < uniforms.dimAOuter && col < uniforms.dimInner)":"if(row < uniforms.aShape[1] && col < uniforms.aShape[2])","\n    {\n      ").concat(r,"\n    }\n    "),"\n    return value;\n  }\n\n  fn mm_readB(batch: i32, row: i32, col: i32) -> ").concat(DQ(s)," {\n    var value = ").concat(DQ(s),"(0.0);\n    ").concat(i,"\n    return value;\n  }\n  ")}function dZ(e,t,n,a){let s=arguments.length>4&&void 0!==arguments[4]&&arguments[4],r=arguments.length>5&&void 0!==arguments[5]&&arguments[5],i=arguments.length>7&&void 0!==arguments[7]?arguments[7]:1;return"\n  ".concat(hZ(n,a,s,r,arguments.length>6&&void 0!==arguments[6]&&arguments[6],i),"\n  fn mm_write(batch: i32, row: i32, col: i32, valueIn: ").concat(DQ(i),") {\n    ").concat(s&&r?"":"if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)","\n    {\n      var value = valueIn;\n      let coords = vec3<i32>(batch, row, col);\n      ").concat(uZ(e,t),"\n      setOutputAtCoords(coords[0], coords[1], coords[2], value);\n    }\n  }\n  ")}function pZ(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:32,s=arguments.length>4&&void 0!==arguments[4]&&arguments[4],r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:32,i=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const o=t[1]*e[1],c=t[0]*e[0],l=n?o:a,u=n?a:o,h=l/t[0],d=a/t[1],p=e[1],f=e[0];return yu((n&&4===h&&4===e[1]||!n&&(3===h||4===h))&&l%t[0]===0&&a%t[1]===0&&4===e[0],()=>"If transposeA ".concat(n," is true, innerElementSize ").concat(h," and workPerThread[1] ").concat(e[1]," must be 4.\n          Otherwise, innerElementSize ").concat(h," must be 3 or 4.\n      tileAWidth ").concat(l," must be divisible by workgroupSize[0]").concat(t[0],". tileInner ").concat(a," must be divisible by workgroupSize[1] ").concat(t[1],". colPerThread ").concat(e[0]," must be 4.")),"\n  var<workgroup> mm_Asub : array<array<vec".concat(h,"<f32>, ").concat(l/h,">, ").concat(u,">;\n  var<workgroup> mm_Bsub : array<array<vec4<f32>, ").concat(c/e[0],">, ").concat(a,">;\n\n  ").concat(LQ()," {\n    let localRow = i32(localId.y);\n    let tileRow = localRow * ").concat(p,";\n    let tileCol = i32(localId.x);\n\n    let globalRow = i32(globalId.y) * ").concat(p,";\n    let globalCol = i32(globalId.x) * ").concat(f,";\n    let batch = ").concat(s?"0":"i32(globalId.z)",";\n    let batchA = ").concat(s||!i?"batch":"batch % uniforms.aShape[0]",";\n    let batchB = ").concat(s||!i?"batch":"batch % uniforms.bShape[0]",";\n    let globalRowStart = i32(workgroupId.y) * ").concat(o,";\n\n    let numTiles = ").concat(s?"".concat(Math.ceil(r/a)):"(uniforms.dimInner - 1) / ".concat(a," + 1"),";\n    var kStart = ").concat(s?"i32(globalId.z) * ".concat(r):"0",";\n\n    var acc: array<vec4<f32>, ").concat(p,">;\n\n    // Loop over shared dimension.\n    let tileRowB = localRow * ").concat(d,";\n    for (var t = 0; t < numTiles; t++) {\n        // Load one tile of A into local memory.\n        for (var innerRow = 0; innerRow < ").concat(p,"; innerRow++) {\n            let inputRow = tileRow + innerRow;\n            let inputCol = tileCol;\n            ").concat(((e,t)=>e?"\n        mm_Asub[inputRow][inputCol] = mm_readA(batchA,\n          kStart + inputRow,\n          globalRowStart + inputCol * ".concat(t,");\n        "):"\n        mm_Asub[inputRow][inputCol] = mm_readA(batchA,\n          globalRow + innerRow,\n          kStart + inputCol * ".concat(t,");\n        "))(n,h),"\n        }\n\n        // Load one tile of B into local memory.\n        for (var innerRow = 0; innerRow < ").concat(d,"; innerRow++) {\n            let inputRow = tileRowB + innerRow;\n            let inputCol = tileCol;\n            mm_Bsub[inputRow][inputCol] = mm_readB(batchB, kStart + inputRow, globalCol);\n        }\n        kStart = kStart + ").concat(a,";\n        workgroupBarrier();\n\n        // Compute acc values for a single thread.\n        ").concat(((e,t,n,a)=>{if(e)return"\n      for (var k = 0; k < ".concat(a,"; k++) {\n        let BCached0 = mm_Bsub[k][tileCol];\n        let ACached0 = mm_Asub[k][localRow];\n        for (var i = 0; i < ").concat(n,"; i++) {\n          acc[i] = fma(BCached0, vec4<f32>(ACached0[i]), acc[i]);\n        }\n      }");{let e="",s="";for(let n=0;n<t;n++)e+="let BCached".concat(n," = mm_Bsub[k * ").concat(t," + ").concat(n,"][tileCol];"),s+="acc[i] = fma(BCached".concat(n,", vec4<f32>(ACached[").concat(n,"]), acc[i]);");return"\n      for (var k = 0; k < ".concat(a/t,"; k++) {\n        ").concat(e,"\n        for (var i = 0; i < ").concat(n,"; i++) {\n          let ACached = mm_Asub[tileRow + i][k];\n          ").concat(s,"\n        }\n      }")}})(n,h,p,a),"\n        workgroupBarrier();\n    }\n\n    for (var innerRow = 0; innerRow < ").concat(p,"; innerRow++) {\n        mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);\n    }\n  }")}const fZ=e=>e?"\n        mm_Asub[inputRow][inputCol] = mm_readA(batchA,\n          kStart + inputRow,\n          globalRowStart + inputCol);\n        ":"\n        mm_Asub[inputRow][inputCol] = mm_readA(batchA,\n          globalRowStart + inputRow,\n          kStart + inputCol);\n        ";function mZ(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:32,s=arguments.length>4&&void 0!==arguments[4]&&arguments[4],r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:32,i=arguments.length>6&&void 0!==arguments[6]&&arguments[6],o=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const c=e[1]*t[1],l=e[0]*t[0],u=n?c:a,h=n?a:c;yu(h%t[1]===0&&u%t[0]===0&&a%t[1]===0,()=>"tileAHight ".concat(h," must be divisible by workgroupSize[1]").concat(t[1],", tileAWidth ").concat(u," must be divisible by workgroupSize[0]").concat(t[0],", tileInner ").concat(a," must be divisible by workgroupSize[1]").concat(t[1]));const d=h/t[1],p=u/t[0],f=a/t[1],m=e[1],g=e[0],y=i?"\n      let localRow = i32(localId.y);\n      let localCol = i32(localId.x);\n      let globalRowStart = i32(workgroupId.y) * ".concat(c,";\n      let globalColStart = i32(workgroupId.x) * ").concat(l,";\n\n      // Loop over shared dimension.\n      for (var t = 0; t < numTiles; t++) {\n        // Load one tile of A into local memory.\n        for (var inputRow = localRow; inputRow < ").concat(h,"; inputRow = inputRow + ").concat(t[1],") {\n          for (var inputCol = localCol; inputCol < ").concat(u,"; inputCol = inputCol + ").concat(t[0],") {\n            ").concat(fZ(n),"\n          }\n        }\n        // Load one tile of B into local memory.\n        for (var inputRow = localRow; inputRow < ").concat(a,"; inputRow = inputRow + ").concat(t[1],") {\n              for (var inputCol = localCol; inputCol < ").concat(l,"; inputCol = inputCol + ").concat(t[0],") {\n            mm_Bsub[inputRow][inputCol] = mm_readB(batchB,\n              kStart + inputRow,\n              globalColStart + inputCol);\n          }\n        }\n        kStart = kStart + ").concat(a,";\n        workgroupBarrier();\n\n        // Compute acc values for a single thread.\n        var BCached : array<f32, ").concat(g,">;\n        for (var k = 0; k < ").concat(a,"; k++) {\n          for (var inner = 0; inner < ").concat(g,"; inner++) {\n            BCached[inner] = mm_Bsub[k][localCol + inner * ").concat(t[0],"];\n          }\n          for (var innerRow = 0; innerRow < ").concat(m,"; innerRow++) {\n            let ACached = ").concat(n?"mm_Asub[k][localRow + innerRow * ".concat(t[1],"];"):"mm_Asub[localRow + innerRow * ".concat(t[1],"][k];"),"\n            for (var innerCol = 0; innerCol < ").concat(g,"; innerCol++) {\n              acc[innerRow][innerCol] =\n                  fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);\n            }\n          }\n        }\n        workgroupBarrier();\n      }\n      for (var innerRow = 0; innerRow < ").concat(m,"; innerRow++) {\n        let gRow = globalRowStart + localRow + innerRow * ").concat(t[1],";\n        for (var innerCol = 0; innerCol < ").concat(g,"; innerCol++) {\n          let gCol = globalColStart + localCol + innerCol * ").concat(t[0],";\n          mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);\n        }\n      }\n      "):"\n  let tileRow = i32(localId.y) * ".concat(m,";\n  let tileCol = i32(localId.x) * ").concat(g,";\n\n  let globalRow = i32(globalId.y) * ").concat(m,";\n  let globalCol = i32(globalId.x) * ").concat(g,";\n  let globalRowStart = i32(workgroupId.y) * ").concat(c,";\n\n  let tileRowA = i32(localId.y) * ").concat(d,";\n  let tileColA = i32(localId.x) * ").concat(p,";\n  let tileRowB = i32(localId.y) * ").concat(f,";\n  // Loop over shared dimension.\n  for (var t = 0; t < numTiles; t++) {\n    // Load one tile of A into local memory.\n    for (var innerRow = 0; innerRow < ").concat(d,"; innerRow++) {\n      for (var innerCol = 0; innerCol < ").concat(p,"; innerCol++) {\n        let inputRow = tileRowA + innerRow;\n        let inputCol = tileColA + innerCol;\n        ").concat(fZ(n),"\n      }\n    }\n\n    // Load one tile of B into local memory.\n    for (var innerRow = 0; innerRow < ").concat(f,"; innerRow++) {\n      for (var innerCol = 0; innerCol < ").concat(g,"; innerCol++) {\n        let inputRow = tileRowB + innerRow;\n        let inputCol = tileCol + innerCol;\n        mm_Bsub[inputRow][inputCol] = mm_readB(batchB,\n          kStart + inputRow,\n          globalCol + innerCol);\n      }\n    }\n    kStart = kStart + ").concat(a,";\n    workgroupBarrier();\n\n    // Compute acc values for a single thread.\n    var BCached : array<f32, ").concat(g,">;\n    for (var k = 0; k < ").concat(a,"; k++) {\n      for (var inner = 0; inner < ").concat(g,"; inner++) {\n        BCached[inner] = mm_Bsub[k][tileCol + inner];\n      }\n\n      for (var innerRow = 0; innerRow < ").concat(m,"; innerRow++) {\n        ").concat((e=>e?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];")(n),"\n        for (var innerCol = 0; innerCol < ").concat(g,"; innerCol++) {\n          acc[innerRow][innerCol] =\n              fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);\n        }\n      }\n    }\n\n    workgroupBarrier();\n  }\n\n  for (var innerRow = 0; innerRow < ").concat(m,"; innerRow++) {\n    for (var innerCol = 0; innerCol < ").concat(g,"; innerCol++) {\n      mm_write(batch, globalRow + innerRow, globalCol + innerCol,\n          acc[innerRow][innerCol]);\n    }\n  }\n  ");return"\n    var<workgroup> mm_Asub : array<array<f32, ".concat(u,">, ").concat(h,">;\n    var<workgroup> mm_Bsub : array<array<f32, ").concat(l,">, ").concat(a,">;\n\n    ").concat(LQ()," {\n      let batch = ").concat(s?"0":"i32(globalId.z)",";\n      let batchA = ").concat(s||!o?"batch":"batch % uniforms.aShape[0]",";\n      let batchB = ").concat(s||!o?"batch":"batch % uniforms.bShape[0]",";\n      let numTiles = ").concat(s?"".concat(Math.ceil(r/a)):"(uniforms.dimInner - 1) / ".concat(a," + 1"),";\n      var kStart = ").concat(s?"i32(globalId.z) * ".concat(r):"0",";\n\n      var acc : array<array<f32, ").concat(g,">, ").concat(m,">;\n\n      // Without this initialization strange values show up in acc.\n      for (var innerRow = 0; innerRow < ").concat(m,"; innerRow++) {\n        for (var innerCol = 0; innerCol < ").concat(g,"; innerCol++) {\n          acc[innerRow][innerCol] = 0.0;\n        }\n      }\n      ").concat(y,"\n    }\n  ")}class gZ{constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,o=arguments.length>7&&void 0!==arguments[7]&&arguments[7];this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=t,this.dispatchLayout={x:[2],y:[1],z:[0]};const c=n?e[1]:e[2];if(this.isVec4=(c%4===0&&!n||t[1]%4===0&&n)&&t[2]%4===0&&!a,this.outputComponent=this.isVec4?4:1,this.isVectorA=1===t[1]&&!n,!this.isVec4&&this.isVectorA)this.elementsPerThread=[1,1,1],this.workgroupSize=[32,1,1];else{const e=function(e,t,n){const a=[8,8,1],s=[4,4,1];return arguments.length>3&&void 0!==arguments[3]&&arguments[3]||(e<=8&&(s[1]=1),t<=16&&n<=16&&(a[0]=4)),{workgroupSize:a,elementsPerThread:s}}(t[1],c,t[2],n);this.workgroupSize=e.workgroupSize,this.elementsPerThread=e.elementsPerThread}this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread);const l=null!=s,u=null!=i;l&&this.variableNames.push("bias"),u&&this.variableNames.push("preluActivationWeights"),this.sequentialAccessByThreads=o,this.transposeA=n,this.transposeB=a,this.addBias=l,this.activation=r,this.hasPreluActivationWeights=u,[this.fitAOuter,this.fitBOuter,this.fitInner]=this.getShapeFit(t[1],t[2],c),this.shaderKey="matMulPacked_".concat(this.elementsPerThread,"_").concat(n,"_").concat(a,"_").concat(this.activation,"_").concat(this.fitAOuter,"_").concat(this.fitBOuter,"_").concat(this.fitInner,"_").concat(this.isVec4,"_").concat(this.isVectorA,"_").concat(this.sequentialAccessByThreads)}getShapeFit(e,t,n){const a=this.workgroupSize[1]*this.elementsPerThread[1],s=this.workgroupSize[0]*this.elementsPerThread[0];!this.isVec4&&this.isVectorA?this.tileInner=4*this.workgroupSize[0]:this.tileInner=s;return[e%a===0,t%s===0,n%this.tileInner===0]}getUserCode(){const e="\n      ".concat(lZ(this.activation,this.hasPreluActivationWeights,this.isVec4),"\n      ").concat(dZ(this.addBias,this.activation,!1,this.transposeB,this.fitAOuter,this.fitBOuter,this.fitInner,this.isVec4?4:1),"\n      ").concat(this.isVec4?pZ(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,!0):this.isVectorA?function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];yu(1===e[1]&&1===e[2],()=>"A linear work group size is required. But got ".concat(e,"."));const n=4*e[0];return"\n    var<workgroup> mm_Asub : array<vec4<f32>, ".concat(e[0],">;\n\n    ").concat(LQ()," {\n      let tileCol = i32(localId.x);\n      let globalCol = i32(globalId.x);\n      let globalRow = i32(globalId.y);\n\n      let numTiles = (uniforms.dimInner - 1) / ").concat(n," + 1;\n      let batch = i32(globalId.z);\n      let batchA = batch % uniforms.aShape[0];\n      let batchB = batch % uniforms.bShape[0];\n      // Without this initialization strange values show up in acc.\n      var acc = 0.0;\n\n      // Loop over shared dimension.\n      for (var t = 0; t < numTiles; t++) {\n        // Load one tile of A into local memory.\n        let colA = t * ").concat(n," + tileCol * 4;\n        mm_Asub[tileCol] = vec4<f32>(").concat((e=>e?"\n      mm_readA(batchA, colA, globalRow),\n      mm_readA(batchA, colA + 1, globalRow),\n      mm_readA(batchA, colA + 2, globalRow),\n      mm_readA(batchA, colA + 3, globalRow)\n  ":"\n      mm_readA(batchA, globalRow, colA),\n      mm_readA(batchA, globalRow, colA + 1),\n      mm_readA(batchA, globalRow, colA + 2),\n      mm_readA(batchA, globalRow, colA + 3)\n  ")(t),");\n        workgroupBarrier();\n\n        // Compute acc values for a single thread.\n        for (var k = 0; k < ").concat(n/4,"; k++) {\n          let rowB = t * ").concat(n," + k * 4;\n          let BCached = vec4<f32>(mm_readB(batchB, rowB, globalCol),\n                              mm_readB(batchB, rowB + 1, globalCol),\n                              mm_readB(batchB, rowB + 2, globalCol),\n                              mm_readB(batchB, rowB + 3, globalCol));\n\n          let ACached = mm_Asub[k];\n          acc = acc + dot(ACached, BCached);\n        }\n\n        workgroupBarrier();\n      }\n\n      mm_write(batch, globalRow, globalCol, acc);\n    }\n  ")}(this.workgroupSize,this.transposeA):mZ(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,this.sequentialAccessByThreads,!0),"\n    ");return e}}class yZ{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null;this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout={x:[],y:[1,2],z:[0]},this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize);const i=null!=a,o=null!=r;i&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),this.transposeA=t,this.transposeB=n,this.addBias=i,this.activation=s,this.hasPreluActivationWeights=o,this.shaderKey="matMulReduce_".concat(this.activation,"_").concat(t,"_").concat(n)}getUserCode(){var e;return"\n      ".concat(lZ(this.activation,this.hasPreluActivationWeights),"\n      ").concat(dZ(this.addBias,this.activation,this.transposeA,this.transposeB),"\n      ").concat((e=this.workgroupSize[0],"\n    var<workgroup> sumValues : array<f32, ".concat(e,">;\n    ").concat(LQ()," {\n      let coords = getOutputCoords();\n      let batch = coords[0];\n      let batchA = batch % uniforms.aShape[0];\n      let batchB = batch % uniforms.bShape[0];\n      let row = coords[1];\n      let col = coords[2];\n      var sum = 0.0;\n      let Length = uniforms.dimInner;\n      for (var k = i32(localId.x); k < Length; k = k + ").concat(e,") {\n        let dataA = mm_readA(batchA, row, k);\n        let dataB = mm_readB(batchB, k, col);\n        sum = sum + dataA * dataB;\n      }\n      sumValues[localId.x] = sum;\n      workgroupBarrier();\n\n      for(var currentSize = ").concat(e/2,"u; currentSize > 1u;\n          currentSize = currentSize / 2u) {\n        if (localId.x < currentSize)\n        {\n          sumValues[localId.x] = sumValues[localId.x] + sumValues[localId.x + currentSize];\n        }\n        workgroupBarrier();\n      }\n\n      if (localId.x == 0u) {\n        sum = sumValues[0] + sumValues[1];\n        mm_write(batch, row, col, sum);\n      }\n    }\n  ")),"\n    ")}}class bZ{constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=arguments.length>4&&void 0!==arguments[4]&&arguments[4],r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null;this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[16,8,1],this.outputShape=n,this.dispatchLayout={x:[2],y:[1],z:[0]},this.dispatch=[Math.ceil(n[2]/this.workgroupSize[0]),Math.ceil(n[1]/this.workgroupSize[1]),n[0]];const c=null!=r;c&&this.variableNames.push("bias");const l=null!=o;l&&this.variableNames.push("preluActivationWeights"),this.transposeA=a,this.transposeB=s,this.addBias=c,this.activation=i,this.hasPreluActivationWeights=l,this.shaderKey="matMulSmallOutputSize_".concat(this.activation,"_").concat(a,"_").concat(s)}getUserCode(){return"\n      ".concat(lZ(this.activation,this.hasPreluActivationWeights),"\n      ").concat(dZ(this.addBias,this.activation,this.transposeA,this.transposeB),"\n      ").concat(function(e){const t=e[1],n=e[0],a=t>n?t:n;return"\n  var<workgroup> mm_Asub : array<array<f32, ".concat(a,">, ").concat(t,">;\n  var<workgroup> mm_Bsub : array<array<f32, ").concat(n,">, ").concat(a,">;\n\n  // If the output size is small for matrix multiplication, avoid to use vec4\n  // and handle some elements per thread to optimally utilize the ALU.\n  // Read data from global memory to registers firstly, then store them into\n  // shared memory, so it is instruction-Level parallelism for arithmetic\n  // operations and others handle IO operations between barrier api, makes ALU\n  // and load/store units work simultaneously, could improves the performance.\n  ").concat(LQ()," {\n    let tileRow = i32(localId.y);\n    let tileCol = i32(localId.x);\n    let globalRow = i32(globalId.y);\n    let globalCol = i32(globalId.x);\n    let batch = i32(globalId.z);\n    let batchA = batch % uniforms.aShape[0];\n    let batchB = batch % uniforms.bShape[0];\n\n    // uniforms.dimInner should be greater than 0.\n    let numTiles = (uniforms.dimInner - 1) / ").concat(a," + 1;\n    var acc = 0.0;\n\n    var globalColA = tileCol;\n    var globalRowB = 0;\n    var regA = mm_readA(batchA, globalRow, globalColA);\n    var regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);\n    var regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);\n    globalColA = globalColA + ").concat(a,";\n    globalRowB = globalRowB + ").concat(a,";\n\n    for (var t = 0; t < numTiles; t = t + 1) {\n      mm_Asub[tileRow][tileCol] = regA;\n      mm_Bsub[2 * tileRow][tileCol] = regB0;\n      mm_Bsub[2 * tileRow + 1][tileCol] = regB1;\n\n      workgroupBarrier();\n\n      regA = mm_readA(batchA, globalRow, globalColA);\n      regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);\n      regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);\n      globalColA = globalColA + ").concat(a,";\n      globalRowB = globalRowB + ").concat(a,";\n\n      for (var k = 0; k < ").concat(a,"; k = k + 1) {\n        acc = acc + mm_Asub[tileRow][k] * mm_Bsub[k][tileCol];\n      }\n      workgroupBarrier();\n    }\n\n    mm_write(batch, globalRow, globalCol, acc);\n  }\n  ")}(this.workgroupSize),"\n    ")}}class xZ{constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[8,8,1],this.atomic=!0,this.splitedDimInner=128,yu(1===e[0],()=>"MatMulSplitKProgram only supports batch = 1."),this.outputShape=e,this.dispatchLayout={x:[2],y:[1],z:[0,3]};const s=(n&&this.outputShape[1]%4===0||!n&&t%4===0)&&this.outputShape[2]%4===0;this.elementsPerThread=[4,4,this.splitedDimInner],this.outputComponent=s?4:1,s||(this.outputShape[1]<16&&(this.elementsPerThread[1]=1),this.outputShape[2]<16&&(this.elementsPerThread[0]=1)),this.dispatch=KQ(this.dispatchLayout,[this.outputShape[0],this.outputShape[1],this.outputShape[2],t],this.workgroupSize,this.elementsPerThread),this.transposeA=n,this.transposeB=a,this.shaderKey="matMulSplitK_".concat(n,"_").concat(a,"_").concat(this.elementsPerThread,"_").concat(this.outputComponent)}getUserCode(){const e=this.outputComponent;return"\n      ".concat(hZ(!1,this.transposeB,!1,!1,!1,e),"\n      fn mm_write(batch: i32, row : i32, col : i32, value : ").concat(DQ(e),") {\n        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {\n          let coords = vec3<i32>(batch, row, col);\n          let flatIndex = getOutputIndexFromCoords(coords);\n          // The problem is that we should initialize output to zero before using.\n          // Otherwise, the original value will be added to the result.\n          for (var i = 0; i < ").concat(e,"; i = i + 1) {\n            ").concat(AQ("&result[flatIndex + i]","".concat(e>1?"value[i]":"value"),"float32"),"\n          }\n        }\n      }\n      ").concat(4===e?pZ(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner):mZ(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner),"\n    ")}}class vZ{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=QQ(this.outputShape),this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=null!=t,this.hasPreluActivationWeights=null!=a,this.activation=n,this.addBias&&this.variableNames.push("bias"),this.hasPreluActivationWeights&&this.variableNames.push("preluActivationWeights"),this.shaderKey="biasActivation_".concat(n)}getUserCode(){return"\n    ".concat(lZ(this.activation,this.hasPreluActivationWeights),"\n    ").concat(LQ("index")," {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        var value = getXByOutputIndex(index);\n        ").concat(uZ(this.addBias,this.activation),"\n        setOutputAtIndex(index, value);\n      }\n    }\n    ")}}class wZ{constructor(e){this.variableNames=[],this.outputShape=[],this.uniforms="value : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=QQ(this.outputShape),this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="fill"}getUserCode(){return"\n    ".concat(LQ("index")," {\n      if (index < uniforms.size) {\n        setOutputAtIndex(index, uniforms.value);\n      }\n    }\n  ")}}function kZ(e){const{backend:t,attrs:n}=e,{shape:a,value:s}=n;let{dtype:r}=n;if(r=r||Fu(s),"string"===r){const e=Au(r,vu(a));return e.fill(s),t.makeTensorInfo(a,r,e)}{const e=new wZ(a),n=[{type:"float32",data:[s]}];return t.runWebGPUProgram(e,[],r,n)}}const SZ={kernelName:ud,backendName:"webgpu",kernelFunc:kZ};function CZ(e){const{inputs:t,attrs:n}=e,{x:a}=t,{shape:s}=n,r=vu(a.shape),i=Tu(s,r),o=vu(i);return yu(r===o,()=>"The new shape (".concat(i,") has ").concat(o," elements and the old ")+"shape (".concat(a.shape,") has ").concat(r," elements. The new shape and old ")+"shape must have the same number of elements."),e.backend.incRef(a.dataId),{dataId:a.dataId,shape:i,dtype:a.dtype}}const IZ={kernelName:mp,backendName:"webgpu",kernelFunc:CZ};function NZ(e){let{a:t,b:n,transposeA:a,transposeB:s,backend:r,bias:i=null,preluActivationWeights:o=null,leakyreluAlpha:c=0,activation:l=null}=e;const u=t.shape.length,h=n.shape.length,d=a?t.shape[u-2]:t.shape[u-1],p=s?n.shape[h-1]:n.shape[h-2],f=a?t.shape[u-1]:t.shape[u-2],m=s?n.shape[h-2]:n.shape[h-1],g=t.shape.slice(0,-2),y=n.shape.slice(0,-2),b=vu(g),x=vu(y),v=Ry(t.shape.slice(0,-2),n.shape.slice(0,-2)).concat([f,m]);yu(d===p,()=>"Error in matMul: inner shapes (".concat(d,") and (")+"".concat(p,") of Tensors with shapes ").concat(t.shape," and ")+"".concat(n.shape," and transposeA=").concat(a)+" and transposeB=".concat(s," must match."));const w=a?[b,d,f]:[b,f,d],k=s?[x,m,p]:[x,p,m],S=CZ({inputs:{x:t},backend:r,attrs:{shape:w}}),C=CZ({inputs:{x:n},backend:r,attrs:{shape:k}}),I=[S,C],N=Math.max(b,x),T=[S,C],E=[{type:"int32",data:[f]},{type:"int32",data:[m]},{type:"int32",data:[d]}];let R,_;const A=[N,f,m];let M=$u().get("WEBGPU_MATMUL_PROGRAM_TYPE");if(M<0){const e=$u().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),t=e>0?e:r.thresholdToIncreaseWorkgroups,n=N*Math.ceil(f/32)*Math.ceil(m/32);M=n<=t||f<=8&&n<=2*t?N*f*m<=128?eZ.MatMulReduceProgram:1===N&&p>=2e3?eZ.MatMulSplitKProgram:eZ.MatMulSmallOutputSizeProgram:eZ.MatMulPackedProgram}switch(M){case eZ.MatMulReduceProgram:R=new yZ(A,a,s,i,l,o);break;case eZ.MatMulSplitKProgram:if(_=kZ({backend:r,attrs:{shape:A,value:0,dtype:t.dtype}}),R=new xZ(A,p,a,s),i||l){_=r.runWebGPUProgram(R,T,t.dtype,E,_);const e=new vZ(_.shape,i,l,o);let n=null;const a=[_];i&&a.push(i),o&&a.push(o),"leakyrelu"===l&&(n=[{type:"float32",data:[c]}],e.uniforms+=" alpha : f32,");const s=r.runWebGPUProgram(e,a,_.dtype,n);I.push(_);const u=CZ({inputs:{x:s},backend:r,attrs:{shape:v}});I.push(s);for(const t of I)r.disposeData(t.dataId);return u}break;case eZ.MatMulSmallOutputSizeProgram:R=new bZ(w,k,A,a,s,i,l,o);break;case eZ.MatMulPackedProgram:const e=r.adapterInfo.isIntel();R=new gZ(w,A,a,s,i,l,o,e);break;default:throw new Error("Unsupported MatMulProgramType ".concat(M,"."))}i&&T.push(i),o&&T.push(o),"leakyrelu"===l&&(E.push({type:"float32",data:[c]}),R.uniforms+=" alpha : f32,"),_=r.runWebGPUProgram(R,T,t.dtype,E,_);const P=CZ({inputs:{x:_},backend:r,attrs:{shape:v}});I.push(_);for(const D of I)r.disposeData(D.dataId);return P}const TZ={kernelName:pf,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{a:s,b:r,bias:i,preluActivationWeights:o}=t,{transposeA:c,transposeB:l,activation:u,leakyreluAlpha:h}=a;return NZ({a:s,b:r,transposeA:c,transposeB:l,backend:n,bias:i,preluActivationWeights:o,leakyreluAlpha:h,activation:u})}};class EZ{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.workgroupSize=[128,1,1],this.size=!0,this.outputShape=Ry(t,n),this.dispatchLayout=QQ(this.outputShape),this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="binaryOpComplex_".concat(e),this.op=e}getUserCode(){const e=sZ(this.op,!1);return"\n      fn binaryOpComplex(\n          areal : f32, aimag : f32, breal : f32, bimag : f32) -> f32 {\n        ".concat(e,"\n      }\n\n      ").concat(LQ("index")," {\n        if(index < uniforms.size) {\n          let areal = getARealByOutputIndex(index);\n          let aimag = getAImagByOutputIndex(index);\n          let breal = getBRealByOutputIndex(index);\n          let bimag = getBImagByOutputIndex(index);\n          setOutputAtIndex(index, binaryOpComplex(areal, aimag, breal, bimag));\n        }\n      }\n    ")}}class RZ{constructor(e,t,n){if(this.size=!0,this.variableNames=["A","B"],this.outputShape=Ry(t,n),this.dispatchLayout=QQ(this.outputShape),this.op=e,this.useSharedMemoryWithA=t.length<=1&&n.length>1&&t[0]<128,this.useSharedMemoryWithB=n.length<=1&&t.length>1&&n[0]<128,this.useSharedMemoryWithA||this.useSharedMemoryWithB)this.outputComponent=1,this.variableComponents=[1,1],this.lastDimensionSize=this.useSharedMemoryWithB?n[0]:t[0],this.shaderKey="binary_".concat(e,"_").concat(this.lastDimensionSize),this.type="shared",this.workgroupSize=[256,1,1];else{const a=t.length>0&&t[t.length-1]%4===0,s=n.length>0&&n[n.length-1]%4===0;a&&s?(this.outputComponent=4,this.variableComponents=[4,4]):a&&(wu(n)||1===n[n.length-1])||s&&(wu(t)||1===t[t.length-1])?(this.outputComponent=4,this.variableComponents=a?[4,1]:[1,4]):(this.outputComponent=1,this.variableComponents=[1,1]),this.type="nonshared",this.shaderKey="binary_".concat(e,"_").concat(this.variableComponents),this.workgroupSize=[128,1,1]}this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.outputComponent,1,1])}getUserCode(){let e;const t=4===this.outputComponent?"vec4<f32>":"f32",n="\n    fn binaryOperation(a : ".concat(t,", b : ").concat(t,") -> ").concat(t," {\n      ").concat(sZ(this.op,4===this.outputComponent),"\n    };\n    ");if("shared"===this.type){const t=this.lastDimensionSize>1?"coords[".concat(this.outputShape.length-1,"]"):"0",a=this.useSharedMemoryWithB?"let a = getAByOutputIndex(index);\n          let b = sharedBuf[".concat(t,"];"):"let a = sharedBuf[".concat(t,"];\n          let b = getBByOutputIndex(index);");e="\n        ".concat(n,"\n        var<workgroup> sharedBuf : array<f32, ").concat(this.lastDimensionSize,">;\n        ").concat(LQ("index")," {\n          // Fill in the shared memory buffer.\n          let localIndex = i32(localId.x);\n          if(localIndex < ").concat(this.lastDimensionSize,") {\n            sharedBuf[localIndex] = f32(").concat(this.useSharedMemoryWithB?"B":"A","[localIndex]);\n          }\n          workgroupBarrier();\n\n          if(index < uniforms.size) {\n            let coords = getCoordsFromIndex(index);\n            ").concat(a,"\n            setOutputAtIndex(index, binaryOperation(a, b));\n          }\n        }\n        ")}else e="\n       ".concat(n,"\n       ").concat(LQ("index")," {\n         if (index < uniforms.size) {\n           let coords = getCoordsFromIndex(index * ").concat(this.outputComponent,");\n           let a = ").concat(t,"(getAByOutputCoords(coords));\n           let b = ").concat(t,"(getBByOutputCoords(coords));\n           setOutputAtIndex(index, binaryOperation(a, b));\n         }\n       }\n       ");return e}}function _Z(e){const{inputs:t}=e,{x:n}=t;return e.backend.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}const AZ={kernelName:xd,backendName:"webgpu",kernelFunc:_Z};function MZ(e){const{inputs:t,backend:n}=e,{real:a,imag:s}=t,r=n.makeTensorInfo(a.shape,"complex64"),i=n.tensorMap.get(r.dataId),o=_Z({inputs:{x:a},backend:n}),c=_Z({inputs:{x:s},backend:n});return i.complexTensorInfos={real:o,imag:c},r}const PZ={kernelName:_h,backendName:"webgpu",kernelFunc:MZ};class DZ{constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";this.variableNames=["A"],this.size=!0;this.workgroupSize=[128,1,1],this.outputShape=e,this.dispatchLayout=QQ(this.outputShape),this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.op=t,""!==n&&(this.uniforms=n),this.shaderKey="unary_".concat(t)}getUserCode(){return"\n      fn unaryOperation(a : f32) -> f32 {\n        ".concat(cZ(this.op,!1),"\n      }\n      ").concat(LQ("index")," {\n        if (index < uniforms.size) {\n          let a = getAByOutputIndex(index);\n          setOutputAtIndex(index, unaryOperation(a));\n        }\n      }\n      ")}}function OZ(e){let{opType:t,cpuKernelImpl:n,dtype:a}=e;return e=>{let{inputs:s,backend:r}=e;const{x:i}=s,o=r,c=a||i.dtype;if(o.shouldExecuteOnCPU([i])&&null!=n){const e=o.tensorMap.get(i.dataId),t=n(e.values,c);return o.makeTensorInfo(i.shape,c,t)}const l=new DZ(i.shape,t);return o.runWebGPUProgram(l,[i],c)}}function FZ(e){let{opType:t,cpuKernelImpl:n,supportsComplex:a=!1,dtype:s}=e;return e=>{let{inputs:r,backend:i}=e;const{a:o,b:c}=r,l=i;if(a&&"complex64"===o.dtype){const e=l.tensorMap.get(o.dataId),n=l.tensorMap.get(c.dataId);let a,s;if(t!==aZ.MUL)[a,s]=[[e.complexTensorInfos.real,n.complexTensorInfos.real],[e.complexTensorInfos.imag,n.complexTensorInfos.imag]].map(e=>{const[n,a]=e,s={dataId:n.dataId,dtype:n.dtype,shape:o.shape},r={dataId:a.dataId,dtype:a.dtype,shape:c.shape},i=new RZ(t,o.shape,c.shape);return l.runWebGPUProgram(i,[s,r],mm(n.dtype,a.dtype))});else{const t=new EZ(aZ.COMPLEX_MULTIPLY_REAL,o.shape,c.shape),r=new EZ(aZ.COMPLEX_MULTIPLY_IMAG,o.shape,c.shape),i=[{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:o.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:o.shape},{dataId:n.complexTensorInfos.real.dataId,dtype:n.complexTensorInfos.real.dtype,shape:c.shape},{dataId:n.complexTensorInfos.imag.dataId,dtype:n.complexTensorInfos.imag.dtype,shape:c.shape}];a=l.runWebGPUProgram(t,i,"float32"),s=l.runWebGPUProgram(r,i,"float32")}const r=MZ({inputs:{real:a,imag:s},backend:l});return l.disposeData(a.dataId),l.disposeData(s.dataId),r}const u=s||mm(o.dtype,c.dtype);if(("string"===o.dtype||"string"===c.dtype||l.shouldExecuteOnCPU([o,c]))&&null!=n){const e=l.tensorMap.get(o.dataId).values,t=l.tensorMap.get(c.dataId).values,a="string"===o.dtype?tI(e):e,s="string"===o.dtype?tI(t):t,[r,i]=n(o.shape,c.shape,a,s,u);return l.makeTensorInfo(i,u,r)}const h=new RZ(t,o.shape,c.shape);return l.runWebGPUProgram(h,[o,c],u)}}const{mx:LZ,ct:zZ,YG:BZ,hH:jZ,z3:WZ,sG:VZ,uM:UZ,vS:HZ,C1:GZ,qB:qZ,GG:KZ,lg:XZ,rq:YZ,cu:QZ,WR:ZZ,px:JZ,jC:$Z,He:eJ,hE:tJ,BF:nJ,Dk:aJ,cl:sJ,_B:rJ,qy:iJ,Zy:oJ,bu:cJ,dH:lJ,HS:uJ,eW:hJ,GK:dJ,dl:pJ,Dw:fJ,xT:mJ,_X:gJ,wz:yJ}=N,bJ=OZ({opType:rZ.ABS,cpuKernelImpl:lJ}),xJ={kernelName:sh,backendName:"webgpu",kernelFunc:bJ},vJ=OZ({opType:rZ.ACOS}),wJ={kernelName:rh,backendName:"webgpu",kernelFunc:vJ},kJ=OZ({opType:rZ.ACOSH}),SJ={kernelName:ih,backendName:"webgpu",kernelFunc:kJ},CJ=FZ({opType:aZ.ADD,cpuKernelImpl:LZ,supportsComplex:!0}),IJ={kernelName:oh,backendName:"webgpu",kernelFunc:CJ};class NJ{constructor(e){this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e[0],this.variableNames=e.map((e,t)=>"T".concat(t)),this.dispatchLayout=QQ(this.outputShape),this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="addN"}getUserCode(){const e=[];this.variableNames.forEach(t=>{e.push("let v".concat(t," = get").concat(t,"ByOutputCoords(coords);"))});const t=this.variableNames.map(e=>"v".concat(e)).join(" + ");return"\n      ".concat(LQ("index")," {\n        for (var i = 0; i < ").concat(this.workPerThread,"; i = i + 1) {\n          let flatIndex = index * ").concat(this.workPerThread," + i;\n          if (flatIndex < uniforms.size) {\n            let coords = getCoordsFromIndex(flatIndex);\n            ").concat(e.join("\n        "),"\n            setOutputAtIndex(flatIndex, ").concat(t,");\n          }\n        }\n      }\n    ")}}const TJ={kernelName:ch,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,a=t;if(1===a.length)return _Z({inputs:{x:a[0]},backend:n});const s=a.map(e=>e.dtype).reduce((e,t)=>mm(e,t)),r=a.map(e=>e.shape),i=new NJ(r);return n.runWebGPUProgram(i,a,s)}};class EJ{constructor(e,t){this.variableNames=["A"],this.workgroupSize=[16,16,1];const n=new Array(e.length);for(let a=0;a<n.length;a++)n[a]=e[t[a]];this.outputShape=n,this.dispatchLayout={x:[0],y:[1]},this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize,[1,1,1]),this.shaderKey="transposeShared"}getUserCode(){yu(this.workgroupSize[0]===this.workgroupSize[1],()=>"Must be a square tile, current tile shape is ".concat(this.workgroupSize[0]," x ").concat(this.workgroupSize[1]));const e=this.workgroupSize[0];return"\n      var<workgroup> tile : array<array<f32, ".concat(this.workgroupSize[0]+1,">, ").concat(this.workgroupSize[0],">;\n      ").concat(LQ()," {\n        var x = i32(workgroupId.x) * ").concat(e," + i32(localId.x);\n        var y = i32(workgroupId.y) * ").concat(e," + i32(localId.y);\n        let width = uniforms.outShape[0];\n        let height = uniforms.outShape[1];\n        if (x < width && y < height) {\n          tile[localId.y][localId.x] = f32(A[y * width + x]);\n        }\n        workgroupBarrier();\n\n        x = i32(workgroupId.y) * ").concat(e," + i32(localId.x);\n        y = i32(workgroupId.x) * ").concat(e," + i32(localId.y);\n        if (x < height && y < width) {\n          setOutputAtIndex((y * height + x), tile[localId.x]\n            [localId.y]);\n        }\n      }\n    ")}}class RJ{constructor(e,t){this.variableNames=["A"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0;const n=new Array(e.length);for(let a=0;a<n.length;a++)n[a]=e[t[a]];this.outputShape=n,this.dispatchLayout=QQ(this.outputShape),this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.newDim=t,this.shaderKey="transpose_".concat(t)}getUserCode(){const e=OQ(this.outputShape.length),t=_J(this.newDim);return"\n      ".concat(LQ("index")," {\n        for(var i = 0; i < ").concat(this.workPerThread,"; i = i + 1) {\n          let flatIndex = index * ").concat(this.workPerThread," + i;\n          if(flatIndex < uniforms.size) {\n            let coords = getCoordsFromIndex(flatIndex);\n            setOutputAtIndex(flatIndex, A[getIndexFromCoords").concat(this.outputShape.length,"D(\n              ").concat(e,"(").concat(t,"), uniforms.aShape)]);\n          }\n        }\n      }\n    ")}}function _J(e){const t=e.length;if(t>6)throw Error("Transpose for rank ".concat(t," is not yet supported"));const n=new Array(t);for(let a=0;a<e.length;a++)n[e[a]]="coords.".concat(FQ(a));return n.join()}function AJ(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{perm:r}=a,i=n,o=s.shape.length,c=new Array(o);for(let u=0;u<c.length;u++)c[u]=s.shape[r[u]];if(n.shouldExecuteOnCPU([s])){const e=i.tensorMap.get(s.dataId).values,t=gJ(e,s.shape,s.dtype,r,c);return n.makeTensorInfo(c,s.dtype,t)}if(2===s.shape.length&&ku(r,[1,0])){const e=new EJ(s.shape,r);return i.runWebGPUProgram(e,[s],s.dtype)}const l=new RJ(s.shape,r);return i.runWebGPUProgram(l,[s],s.dtype)}const MJ={kernelName:sf,backendName:"webgpu",kernelFunc:AJ};class PJ{constructor(e,t,n){this.variableNames=["x"],this.uniforms="reduceSize : i32,",this.size=!0,this.inputShape=[e.batchSize,e.inSize];const[a]=Zx(this.inputShape,[1]);this.outputShape=0===a.length?[1]:a,e.inSize>=32768&&n>=512?this.workgroupSize=[512,1,1]:e.inSize>=4096?this.workgroupSize=[256,1,1]:this.workgroupSize=[64,1,1],this.dispatchLayout=QQ(this.outputShape),this.dispatch=KQ(this.dispatchLayout,this.outputShape,[1,1,1]),this.reduceType=t,this.shaderKey="reduce_".concat(t)}getUserCode(){let e="",t="0.0";const n=this.workgroupSize[0];"min"===this.reduceType||"max"===this.reduceType?(e="\n         if (isnan(candidate)) {\n          bestValue = uniforms.NAN;\n         } else if (!isnan(bestValue) && candidate ".concat("min"===this.reduceType?"<":">"," bestValue)\n           {  bestValue = candidate; }"),t="f32(x[offset])"):"sum"===this.reduceType||"mean"===this.reduceType?e=" bestValue = bestValue + candidate; ":"prod"===this.reduceType?(e=" bestValue = bestValue * candidate; ",t="1.0"):"all"===this.reduceType?(e=" bestValue = f32(bestValue >= 1.0 && candidate >= 1.0); ",t="1.0"):"any"===this.reduceType&&(e=" bestValue = f32(bestValue >= 1.0 || candidate >= 1.0); ",t="0.0");const a="mean"===this.reduceType?"setOutputAtIndex(outputIndex, bestValue / f32(uniforms.reduceSize));":"setOutputAtIndex(outputIndex, bestValue);",s="\n         var<workgroup> xBestValues : array<f32, ".concat(n,">;\n       ");return"\n       fn DIV_CEIL(a : u32, b : u32) -> u32 {\n        return ((a - 1u) / b + 1u);\n       }\n\n       ".concat(s,"\n       fn getOffset(outputIndex : i32) -> i32 {\n         let outputCoords = getCoordsFromIndex(outputIndex);\n         let offset = ").concat(1===this.outputShape.length?"outputCoords":"outputCoords[0]"," * uniforms.reduceSize;\n          return offset;\n       }\n       ").concat(LQ("index")," {\n         let outputIndex = index / ").concat(n,";\n         let offset = getOffset(outputIndex);\n         var bestValue = ").concat(t,";\n         let Length = uniforms.reduceSize;\n         let WorkPerThread = DIV_CEIL(u32(Length), ").concat(n,"u);\n         for (var k = i32(localId.x); k < Length && outputIndex < uniforms.size;\n             k = k + ").concat(n,") {\n           let candidate = f32(x[offset + k]);\n           ").concat(e,"\n         }\n         xBestValues[localId.x] = bestValue;\n         workgroupBarrier();\n\n         var reduceSize = min(u32(Length), ").concat(n,"u);\n         for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n             currentSize = reduceSize / 2u) {\n           let interval = DIV_CEIL(reduceSize, 2u);\n           if (localId.x < currentSize) {\n            let candidate = xBestValues[localId.x + interval];\n            ").concat(e,"\n            xBestValues[localId.x] = bestValue;\n           }\n           reduceSize = interval;\n           workgroupBarrier();\n         }\n\n         if (localId.x == 0u && outputIndex < uniforms.size) {\n          ").concat(a,"\n        }\n       }\n     ")}}const DJ={mean:"float32",all:"bool",any:"bool"};function OJ(e,t,n,a,s){const r=e.shape.length,i=[],o=Eu(t,e.shape);let c=o;const l=ev(c,r);let u=e;null!=l&&(u=AJ({inputs:{x:e},attrs:{perm:l},backend:s}),c=nv(c.length,r),i.push(u)),$x(a,c,r);const[h,d]=Zx(u.shape,c);let p,f=h;if(n&&(f=Jx(h,o)),"max"!==a&&"prod"!==a||!s.shouldExecuteOnCPU([u])){const t=vu(d),n={windowSize:t,inSize:t,batchSize:vu(u.shape)/t,outSize:1},r=DJ[a]||gm(e.dtype),o=[{type:"int32",data:[t]}],c=new PJ(n,a,s.device.limits.maxComputeWorkgroupSizeX),l=s.runWebGPUProgram(c,[u],r,o);i.push(l),p=CZ({inputs:{x:l},attrs:{shape:f},backend:s})}else{const t=s.tensorMap.get(u.dataId).values;switch(a){case"max":const n=$Z(t,vu(d),f,e.dtype);p=s.makeTensorInfo(f,e.dtype,n);break;case"prod":const{outVals:r,outShape:i,outDtype:o}=rJ(u.shape,u.dtype,t,c);p=s.makeTensorInfo(i,o,r);break;default:throw new Error("".concat(a," CPU implementation is not yet supported."))}}return i.forEach(e=>s.disposeData(e.dataId)),p}const FJ={kernelName:lh,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{keepDims:r,axis:i}=a;return OJ(s,i,r,"all",n)}};const LJ={kernelName:uh,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{keepDims:r,axis:i}=a;return OJ(s,i,r,"any",n)}};class zJ{constructor(e,t,n){this.workgroupSize=[64,1,1],this.variableNames=["x"],this.uniforms="infinityValue : f32,",this.size=!0;const a=[t];this.op="min"===n?"<":">";const[s,r]=Zx(e,a);this.outputShape=0===s.length?[1]:s,this.dispatchLayout=QQ(this.outputShape),vu(r)<32?(this.type="plain",this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize)):(this.type="shared",this.dispatch=KQ(this.dispatchLayout,this.outputShape,[1,1,1])),this.inputShape=e,this.shaderKey="argMinMax_".concat(this.op,"_").concat(this.type)}getUserCode(){const e=this.workgroupSize[0],t=()=>1===this.inputShape.length?"uniforms.xShape":"uniforms.xShape.".concat(FQ(this.inputShape.length-1)),n=()=>{let e="";if(1===this.outputShape.length)1!==this.inputShape.length&&(e+="outputCoords,");else for(let t=0;t<this.outputShape.length;t++)e+="outputCoords.".concat(FQ(t),",");return e};if("shared"===this.type){const a="\n      var<workgroup> xBestIndices : array<i32, ".concat(e,">;\n      var<workgroup> xBestValues : array<f32, ").concat(e,">;\n    ");return"\n      fn DIV_CEIL(a : u32, b : u32) -> u32 {\n        return ((a - 1u) / b + 1u);\n      }\n\n      ".concat(a,"\n\n      ").concat(LQ("index")," {\n        let outputIndex = index / ").concat(e,";\n        let reduceLength = ").concat(t(),";\n\n        var bestIndex = i32(localId.x);\n        var bestValue = uniforms.infinityValue;\n        let outputCoords = getCoordsFromIndex(outputIndex);\n        for (var k = i32(localId.x); k < reduceLength && outputIndex < uniforms.size;\n            k = k + ").concat(e,") {\n          let candidate = getX(").concat(n()," k);\n          if (!isnan(candidate) && candidate ").concat(this.op," bestValue) {\n            bestValue = candidate;\n            bestIndex = k;\n          }\n        }\n        xBestValues[localId.x] = bestValue;\n        xBestIndices[localId.x] = bestIndex;\n        workgroupBarrier();\n\n        var reduceSize = min(u32(reduceLength), ").concat(e,"u);\n        for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n            currentSize = reduceSize / 2u) {\n          let interval = DIV_CEIL(reduceSize, 2u);\n          if (localId.x < currentSize) {\n            let candidate = xBestValues[localId.x + interval];\n            if (candidate ").concat(this.op," bestValue) {\n              bestValue = candidate;\n              xBestValues[localId.x] = bestValue;\n              xBestIndices[localId.x] = xBestIndices[localId.x + interval];\n            }\n          }\n          reduceSize = interval;\n          workgroupBarrier();\n        }\n\n        if (localId.x == 0u && outputIndex < uniforms.size) {\n          setOutputAtIndexI32(outputIndex, xBestIndices[localId.x]);\n        }\n      }\n    ")}return"\n      ".concat(LQ("index")," {\n        if (index < uniforms.size) {\n          let outputCoords = getCoordsFromIndex(index);\n          var bestIndex = 0;\n          var bestValue = getX(").concat(n()," 0);\n          let reduceLength = ").concat(t(),";\n          for (var i = 1; i < reduceLength; i++) {\n            let candidate = getX(").concat(n()," i);\n            if (candidate ").concat(this.op," bestValue) {\n              bestValue = candidate;\n              bestIndex = i;\n            }\n          }\n          setOutputAtIndexI32(index, bestIndex);\n        }\n      }\n      ")}}const BJ={kernelName:hh,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{axis:r}=a;let i=Eu(r,s.shape);const o=ev(i,s.shape.length);let c=s;const l=[];null!=o&&(c=AJ({inputs:{x:s},backend:n,attrs:{perm:o}}),l.push(c),i=nv(i.length,c.shape.length)),$x("argMax",[i[0]],c.shape.length);const u=new zJ(c.shape,i[0],"max"),h=[{type:"float32",data:[Number.NEGATIVE_INFINITY]}],d=n.runWebGPUProgram(u,[c],"int32",h);return l.forEach(e=>n.disposeData(e.dataId)),d}};const jJ={kernelName:dh,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{axis:r}=a;let i=Eu(r,s.shape);const o=ev(i,s.shape.length);let c=s;const l=[];null!=o&&(c=AJ({inputs:{x:s},backend:n,attrs:{perm:o}}),l.push(c),i=nv(i.length,c.shape.length)),$x("argMin",[i[0]],c.shape.length);const u=new zJ(c.shape,i[0],"min"),h=[{type:"float32",data:[Number.POSITIVE_INFINITY]}],d=n.runWebGPUProgram(u,[c],"int32",h);return l.forEach(e=>n.disposeData(e.dataId)),d}},WJ=OZ({opType:rZ.ASIN}),VJ={kernelName:ph,backendName:"webgpu",kernelFunc:WJ},UJ=OZ({opType:rZ.ASINH}),HJ={kernelName:fh,backendName:"webgpu",kernelFunc:UJ},GJ=OZ({opType:rZ.ATAN}),qJ={kernelName:mh,backendName:"webgpu",kernelFunc:GJ},KJ=FZ({opType:aZ.ATAN2}),XJ={kernelName:yh,backendName:"webgpu",kernelFunc:KJ},YJ=OZ({opType:rZ.ATANH}),QJ={kernelName:gh,backendName:"webgpu",kernelFunc:YJ};class ZJ{constructor(e){this.variableNames=["x"],this.uniforms="strides : vec2<i32>,",this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=QQ(this.outputShape),this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="poolWithFilterSizeEqualsOne"}getUserCode(){return"\n      ".concat(LQ("index")," {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let batch = coords[0];\n          let d = coords[3];\n\n          let xRCCorner = coords.yz * uniforms.strides;\n          let xRCorner = xRCCorner.x;\n          let xCCorner = xRCCorner.y;\n\n          let value = getX(batch, xRCorner, xCCorner, d);\n          setOutputAtIndex(index, value);\n        }\n      }\n    ")}}class JJ{constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(this.variableNames=["x"],this.uniforms="strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, convDims : vec2<i32>, filterDims : vec2<i32>,",this.workgroupSize=[128,1,1],this.size=!0,"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");this.outputShape=e.outShape,this.dispatchLayout=QQ(this.outputShape),this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.poolType=t,this.computePositions=n,this.flattenPositions=a,this.includeBatchIndex=s,this.shaderKey="pool2D_".concat(t,"_").concat(n,"_").concat(a,"_").concat(s)}getUserCode(){let e;if("avg"===this.poolType)e="resultValue = resultValue + value; count = count + 1.0;";else if(this.computePositions){const t=this.flattenPositions?this.includeBatchIndex?"((batch * uniforms.xShape[1] + xR) * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d":"(xR * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d":"wR * uniforms.filterDims.y + wC";e="let currMaxValue = mix(value, maxValue, maxValueFound);\n      if (value >= currMaxValue) {\n        maxValue = value;\n        maxValueFound = 1.0;\n        maxPosition = ".concat(t,";\n      }")}else e="resultValue = max(value, resultValue);";let t="resultValue";"avg"===this.poolType&&(t="resultValue / max(count, 1.0)");return"\n      ".concat(LQ("index")," {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n          let batch = coords[0];\n          let d = coords[3];\n          let xRCCorner = vec2<i32>(coords.yz) * uniforms.strides - uniforms.pads;\n          let xRCorner = xRCCorner.x;\n          let xCCorner = xRCCorner.y;\n\n          ").concat(this.computePositions?"var maxValue = 0.0;\n            var maxValueFound = 0.0;\n            var maxPosition = 0;":"var resultValue = ".concat("avg"===this.poolType?"0.0":"-1.0 / pow(10.0, -20.0)",";"),"\n\n          var count = 0.0;\n          for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + uniforms.dilations.x) {\n            let xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= uniforms.convDims.x) {\n              continue;\n            }\n\n            for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + uniforms.dilations.y) {\n              let xC = xCCorner + wC;\n              if (xC < 0 || xC >= uniforms.convDims.y) {\n                continue;\n              }\n\n              let value = getX(batch, xR, xC, d);\n              ").concat(e,"\n            }\n          }\n\n          ").concat(this.computePositions?"setOutputAtIndexI32(index, maxPosition);":"setOutputAtIndex(index, ".concat(t,");"),"\n        }\n      }\n    ")}}class $J{constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(this.variableNames=["x"],this.uniforms="strides : vec3<i32>, pads : vec3<i32>, convDims : vec3<i32>, filterDims : vec3<i32>,",this.workgroupSize=[128,1,1],this.size=!0,"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");this.outputShape=e.outShape,this.dispatchLayout=QQ(this.outputShape),this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.poolType=t,this.computePositions=n,this.flattenPositions=a,this.includeBatchIndex=s,this.shaderKey="pool3D_".concat(t,"_").concat(n,"_").concat(a,"_").concat(s)}getUserCode(){let e;if("avg"===this.poolType)e="resultValue += value; count += 1.0;";else if(this.computePositions){const t=this.flattenPositions?this.includeBatchIndex?"(((batch * uniforms.xShape.y + xD) * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch":"((xD * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch":"wD * uniforms.filterDims.y * uniforms.filterDims.y + wR * uniforms.filterDims.z + wC";e="let currMaxValue = mix(value, maxValue, maxValueFound);\n      if (value >= currMaxValue) {\n        maxValue = value;\n        maxValueFound = 1.0;\n        maxPosition = ".concat(t,";\n      }")}else e="resultValue = max(value, resultValue);";let t="resultValue";"avg"===this.poolType&&(t="resultValue / max(count, 1.0)");return"\n      ".concat(LQ("index")," {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let batch = coords.x;\n          let ch = coords.u;\n\n          let xCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;\n          let xDCorner = xCorner.x;\n          let xRCorner = xCorner.y;\n          let xCCorner = xCorner.z;\n\n          ").concat(this.computePositions?"var maxValue = 0.0;\n            var maxValueFound = 0.0;\n            var maxPosition = 0;":"var resultValue = ".concat("avg"===this.poolType?"0.0":"-1.0 / pow(10.0, -20.0)",";"),"\n\n          var count = 0.0;\n          for (var wD = 0; wD < uniforms.filterDims.x; wD++) {\n            let xD = xDCorner + wD;\n            if (xD < 0 || xD >= uniforms.convDims.x) {\n              continue;\n            }\n\n            for (var wR = 0; wR < uniforms.filterDims.y; wR++) {\n              let xR = xRCorner + wR;\n              if (xR < 0 || xR >= uniforms.convDims.y) {\n                continue;\n              }\n\n              for (var wC = 0; wC < uniforms.filterDims.z; wC++) {\n                let xC = xCCorner + wC;\n                if (xC < 0 || xC >= uniforms.convDims.z) {\n                  continue;\n                }\n\n                let value = getX(batch, xD, xR, xC, ch);\n                ").concat(e,"\n              }\n            }\n          }\n\n          ").concat(this.computePositions?"setOutputAtIndexI32(index, maxPosition);":"setOutputAtIndex(index, ".concat(t,");"),"\n        }\n      }\n    ")}}function e$(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{reductionIndices:r,keepDims:i}=a;return OJ(s,r,i,"max",n)}const t$={kernelName:Fd,backendName:"webgpu",kernelFunc:e$};function n$(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{keepDims:r,axis:i}=a;return OJ(s,i,r,"mean",n)}const a$={kernelName:Ud,backendName:"webgpu",kernelFunc:n$};function s$(e,t,n,a){if(1===t.filterWidth&&1===t.filterHeight&&ku(t.inShape,t.outShape))return _Z({inputs:{x:e},backend:a});if(t.filterWidth===t.inWidth&&t.filterHeight===t.inHeight&&1===t.batchSize&&"VALID"===t.padInfo.type){const s=e.shape.length,r=CZ({inputs:{x:e},backend:a,attrs:{shape:[e.shape[s-3]*e.shape[s-2],e.shape[s-1]]}});let i;"avg"===n?i=n$({inputs:{x:r},backend:a,attrs:{axis:0,keepDims:!1}}):(yu("max"===n,()=>"Invalid pool type ".concat(n)),i=e$({inputs:{x:r},backend:a,attrs:{reductionIndices:0,keepDims:!1}}));const o=CZ({inputs:{x:i},backend:a,attrs:{shape:t.outShape}});return a.disposeData(r.dataId),a.disposeData(i.dataId),o}let s;const r=[{type:"int32",data:[t.strideHeight,t.strideWidth]}];return 1===t.filterHeight&&1===t.filterWidth?s=new ZJ(t):("avg"===n?s=new JJ(t,"avg"):(yu("max"===n,()=>"Invalid pool type ".concat(n)),s=new JJ(t,"max")),r.push({type:"int32",data:[t.padInfo.top,t.padInfo.left]},{type:"int32",data:[t.dilationHeight,t.dilationWidth]},{type:"int32",data:[t.inHeight,t.inWidth]},{type:"int32",data:[t.effectiveFilterHeight,t.effectiveFilterWidth]})),a.runWebGPUProgram(s,[e],e.dtype,r)}const r$={kernelName:bh,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{filterSize:r,strides:i,pad:o,dimRoundingMode:c}=a;return s$(s,Wb(s.shape,r,i,1,o,c),"avg",n)}};const i$={kernelName:vh,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{filterSize:r,strides:i,pad:o,dataFormat:c,dimRoundingMode:l}=a,u=Vb(s.shape,r,i,[1,1,1],o,l,c),h=new $J(u,"avg"),d=[{type:"int32",data:[u.strideDepth,u.strideHeight,u.strideWidth]},{type:"int32",data:[u.padInfo.front,u.padInfo.top,u.padInfo.left]},{type:"int32",data:[u.inDepth,u.inHeight,u.inWidth]},{type:"int32",data:[u.effectiveFilterDepth,u.effectiveFilterHeight,u.effectiveFilterWidth]}];return n.runWebGPUProgram(h,[s],s.dtype,d)}};class o${constructor(e){this.variableNames=["dy"],this.uniforms="strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,\n       outHeight : i32, outWidth : i32, avgMultiplier : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=QQ(this.outputShape),this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avgPool2DBackprop"}getUserCode(){return"\n      ".concat(LQ("index")," {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords[0];\n        let d = coords[3];\n\n        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;\n        let dyRCorner = dyRCCorner.x;\n        let dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        for (var wR = 0; wR < uniforms.filterDims[0]; wR = wR + uniforms.dilations[0]) {\n          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);\n\n          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {\n            continue;\n          }\n          let idyR = i32(dyR);\n\n          for (var wC = 0; wC < uniforms.filterDims[1]; wC = wC + uniforms.dilations[1]) {\n            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);\n\n            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {\n              continue;\n            }\n            let idyC = i32(dyC);\n\n            let dyValue = getDy(batch, idyR, idyC, d);\n\n            dotProd = dotProd + dyValue * uniforms.avgMultiplier;\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n    ")}}class c${constructor(e){this.variableNames=["dy"],this.uniforms="strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,\n       outDepth : i32, outHeight : i32, outWidth : i32, avgMultiplier : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=QQ(this.outputShape),this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avgPool3DBackprop"}getUserCode(){return"\n      ".concat(LQ("index")," {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords.x;\n        let ch = coords.u;\n\n        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;\n        let dyDCorner = dyCorner.x;\n        let dyRCorner = dyCorner.y;\n        let dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {\n          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);\n\n          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {\n            continue;\n          }\n          let idyD = i32(dyD);\n\n          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {\n            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);\n\n            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {\n              continue;\n            }\n            let idyR = i32(dyR);\n\n            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {\n              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);\n\n              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {\n                continue;\n              }\n              let idyC = i32(dyC);\n\n              let dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              dotProd += dyValue * uniforms.avgMultiplier;\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n    ")}}const l$={kernelName:wh,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:s,input:r}=t,i=r,{filterSize:o,strides:c,pad:l,dimRoundingMode:u}=a,h=Vb(i.shape,o,c,1,l,u),d=new c$(h),p=1/(h.filterDepth*h.filterHeight*h.filterWidth),f=[{type:"int32",data:[h.strideDepth,h.strideHeight,h.strideWidth]},{type:"int32",data:[h.effectiveFilterDepth-1-h.padInfo.front,h.effectiveFilterHeight-1-h.padInfo.top,h.effectiveFilterWidth-1-h.padInfo.left]},{type:"int32",data:[h.effectiveFilterDepth,h.effectiveFilterHeight,h.effectiveFilterWidth]},{type:"int32",data:[h.outDepth]},{type:"int32",data:[h.outHeight]},{type:"int32",data:[h.outWidth]},{type:"float32",data:[p]}];return n.runWebGPUProgram(d,[s],i.dtype,f)}};const u$={kernelName:xh,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:s,input:r}=t,i=r;$Q([s,r],"avgPoolGrad");const{filterSize:o,strides:c,pad:l}=a,u=Wb(i.shape,o,c,1,l),h=new o$(u),d=1/(u.filterHeight*u.filterWidth),p=[{type:"int32",data:[u.strideHeight,u.strideWidth]},{type:"int32",data:[u.effectiveFilterHeight-1-u.padInfo.top,u.effectiveFilterWidth-1-u.padInfo.left]},{type:"int32",data:[u.dilationHeight,u.dilationWidth]},{type:"int32",data:[u.effectiveFilterHeight,u.effectiveFilterWidth]},{type:"int32",data:[u.outHeight]},{type:"int32",data:[u.outWidth]},{type:"float32",data:[d]}];return n.runWebGPUProgram(h,[s],i.dtype,p)}};const h$={kernelName:kh,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{a:s,b:r}=t,{transposeA:i,transposeB:o}=a;return NZ({a:s,b:r,transposeA:i,transposeB:o,backend:n})}};class d${constructor(e,t){this.variableNames=["source"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.rank=t.length,this.dispatchLayout=QQ(this.outputShape),this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.start=e,this.uniforms="start : ".concat(OQ(e.length),", "),this.shaderKey="slice"}getUserCode(){const e=OQ(this.rank),t=function(e){if(1===e)return"sourceLoc";if(e<=6)return p$.slice(0,e).map(e=>"sourceLoc.".concat(e)).join(",");throw Error("Slicing for rank ".concat(e," is not yet supported"))}(this.rank);let n;n=1===this.start.length?this.outputShape.map((e,t)=>"sourceLoc = uniforms.start + coords;"):this.outputShape.map((e,t)=>"sourceLoc.".concat(p$[t]," = uniforms.start.").concat(FQ(t)," + coords.").concat(p$[t],";"));return"\n      ".concat(LQ("index")," {\n        if (index < uniforms.size) {\n          var sourceLoc : ").concat(e,";\n          let coords = getCoordsFromIndex(index);\n          ").concat(n.join("\n"),"\n          setOutputAtIndex(index, getSource(").concat(t,"));\n        }\n      }\n    ")}}const p$=["x","y","z","w","u","v"];function f$(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{begin:r,size:i}=a,[o,c]=Ib(s,r,i);if(hb(s,o,c),n.shouldExecuteOnCPU([s])||"string"===s.dtype){const e=n.tensorMap.get(s.dataId),t=uJ(e.values,o,c,s.shape,s.dtype);return n.makeTensorInfo(c,s.dtype,t)}if(0===vu(c))return n.makeTensorInfo(c,s.dtype,[]);const l=new d$(o,c),u=[{type:"int32",data:o}];return n.runWebGPUProgram(l,[s],s.dtype,u)}const m$={kernelName:Rp,backendName:"webgpu",kernelFunc:f$},g$={kernelName:Sh,backendName:"webgpu",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{blockShape:r,crops:i}=a;yu(s.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGPU backend not implemented yet");const o=r.reduce((e,t)=>e*t),c=oC(s.shape,r,o),l=cC(c.length,r.length),u=lC(s.shape,r,o),h=uC(i,r.length),d=hC(u,i,r.length),p=[],f=CZ({inputs:{x:s},backend:n,attrs:{shape:c}}),m=AJ({inputs:{x:f},backend:n,attrs:{perm:l}}),g=CZ({inputs:{x:m},backend:n,attrs:{shape:u}}),y=f$({inputs:{x:g},backend:n,attrs:{begin:h,size:d}});return p.push(f),p.push(m),p.push(g),p.forEach(e=>n.disposeData(e.dataId)),y}},y$="\n  fn bincount_write(index: i32, value: f32) {\n    ".concat(AQ("&result[index]","value","float32"),"\n  }\n");class b${constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];this.outputShape=[],this.variableNames=["x"],this.uniforms="binCountSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.hasWeights=!0,this.binaryOutput=!1,this.outputShape=e,this.rank=e.length,this.dispatchLayout=QQ(this.outputShape),this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.binaryOutput=n,n&&(this.atomic=!1),this.hasWeights=t,this.hasWeights&&this.variableNames.push("w"),this.shaderKey="bincount_".concat(this.hasWeights,"_").concat(this.binaryOutput,"_").concat(this.rank)}getUserCode(){return"\n    ".concat(this.binaryOutput?"\n  fn bincount_write(index: i32, value: f32) {\n    atomicStore(&result[index], bitcast<i32>(value));\n  }\n":y$,"\n  ").concat(LQ("index")," {\n    ").concat(1===this.rank?"if (index < uniforms.xShape) {\n      let indexVal = i32(getX(index));\n      if (indexVal < uniforms.binCountSize) {\n        let value = ".concat(this.binaryOutput?1:this.hasWeights?"getW(index)":"1.",";\n        bincount_write(indexVal, value);\n      }\n    }"):"let coord = getCoordsFromIndex(index);\n    if (coordsInBounds2D(coord, uniforms.xShape)) {\n      let indexVal = i32(getX(coord[0], coord[1]));\n      if (indexVal < uniforms.binCountSize) {\n        let value = ".concat(this.binaryOutput?1:this.hasWeights?"getW(coord[0], coord[1])":"1.",";\n        bincount_write(coord.x * uniforms.binCountSize + indexVal, value);\n      }\n    }"),"\n  }\n  ")}}const x$={kernelName:Ch,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,weights:r}=t,{size:i}=a,o=vu(s.shape),c=vu(r.shape)>0,l=[i],u=r.dtype,h=kZ({backend:n,attrs:{shape:l,value:0,dtype:u}}),d=new b$([o],c),p=[{type:"int32",data:[i]}],f=c?[s,r]:[s];return n.runWebGPUProgram(d,f,u,p,h)}};class v${constructor(e){this.outputShape=[],this.variableNames=["s0","s1"],this.uniforms="s0Size : i32, s1Size : i32, ",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e],this.dispatchLayout=QQ(this.outputShape),this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="broadcastArgs"}getUserCode(){return"\n  ".concat(LQ("index")," {\n    if (index < uniforms.size) {\n      var s0 = 1.0;\n      var s1 = 1.0;\n      let indexS0 = index - uniforms.size + uniforms.s0Size;\n      let indexS1 = index - uniforms.size + uniforms.s1Size;\n      if (indexS0 >= 0) {\n        s0 = getS0(indexS0);\n      }\n      if (indexS1 >= 0) {\n        s1 = getS1(indexS1);\n      }\n\n      if (s0 == 1.0) {\n        setOutputAtIndex(index, s1);\n      } else if (s1 == 1.0) {\n        setOutputAtIndex(index, s0);\n      } else if (s0 != s1) {\n        setOutputAtIndex(index, uniforms.NAN);\n      } else {\n        setOutputAtIndex(index, s0);\n      }\n    }\n  }\n  ")}}const w$={kernelName:Nh,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{s0:a,s1:s}=t;if(n.shouldExecuteOnCPU([a,s])){const e=n.tensorMap.get(a.dataId),t=n.tensorMap.get(s.dataId),r=e.values,i=t.values,o=Ry(Array.from(r),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}const r=vu(a.shape),i=vu(s.shape),o=Math.max(r,i),c=new v$(o),l=[{type:"int32",data:[r]},{type:"int32",data:[i]}];return n.runWebGPUProgram(c,[a,s],"int32",l)}},k$=FZ({opType:aZ.NOT_EQUAL,dtype:"bool",cpuKernelImpl:sJ}),S$={kernelName:Zd,backendName:"webgpu",kernelFunc:k$};function C$(e){const{inputs:t,backend:n}=e,{input:a}=t;return _Z({inputs:{x:n.tensorMap.get(a.dataId).complexTensorInfos.real},backend:n})}const I$={kernelName:dp,backendName:"webgpu",kernelFunc:C$};const N$={kernelName:Th,backendName:"webgpu",kernelFunc:function e(t){const{inputs:n,backend:a,attrs:s}=t,{x:r}=n,{dtype:i}=s;if("complex64"===i){if("complex64"===r.dtype)return _Z({inputs:{x:r},backend:a});const t=Gv(r.shape),n=e({inputs:{x:r},backend:a,attrs:{dtype:"float32"}}),s=MZ({inputs:{real:n,imag:t},backend:a});return t.dispose(),a.disposeData(n.dataId),s}if("complex64"===r.dtype){const t=C$({inputs:{input:r},backend:a}),n=e({inputs:{x:t},backend:a,attrs:{dtype:i}});return a.disposeData(t.dataId),n}if(!Mu(r.dtype,i)){const e=_Z({inputs:{x:r},backend:a});return{dataId:e.dataId,shape:e.shape,dtype:i}}if(a.shouldExecuteOnCPU([r])){const e=a.tensorMap.get(r.dataId).values,[t,n,s]=zZ(e,r.shape,r.dtype,i);return a.makeTensorInfo(t,n,s)}if("int32"===i)return function(e,t){const n=new DZ(e.shape,rZ.TO_INT),a=t.runWebGPUProgram(n,[e],"int32");return{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}(r,a);if("bool"===i){const e=a.makeTensorInfo([],"bool",_u("bool",1)),t=k$({inputs:{a:r,b:e},backend:a});return a.disposeData(e.dataId),t}throw new Error("Error in Cast: failed to cast ".concat(r.dtype," to ").concat(i))}},T$=OZ({opType:rZ.CEIL,cpuKernelImpl:BZ}),E$={kernelName:Eh,backendName:"webgpu",kernelFunc:T$};class R${constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workPerThread=4,this.workgroupSize=[64,1,1],this.outputComponent=4,this.size=!0,this.outputShape=e,this.dispatchLayout=QQ(this.outputShape),this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="clipVec4"}getUserCode(){return"\n      ".concat(LQ("index")," {\n        if(index < uniforms.size) {\n          let value = getAByOutputIndex(index);\n          var clampedValue = clamp(\n              value, vec4<f32>(uniforms.minVal), vec4<f32>(uniforms.maxVal));\n          clampedValue = select(clampedValue, value, isnanVec4(value));\n          setOutputAtIndex(index, clampedValue);\n        }\n      }\n    ")}}class _${constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=QQ(this.outputShape),this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="clip"}getUserCode(){return"\n      ".concat(LQ("index")," {\n        if(index < uniforms.size) {\n          let value = getAByOutputIndex(index);\n          if (isnan(value)) {\n            setOutputAtIndex(index, value);\n            return;\n          }\n          setOutputAtIndex(index, clamp(value, uniforms.minVal, uniforms.maxVal));\n        }\n      }\n    ")}}const A$={kernelName:Rh,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{clipValueMin:r,clipValueMax:i}=a;let o;const c=[{type:"float32",data:[r]},{type:"float32",data:[i]}];return o=vu(s.shape)%4===0?new R$(s.shape):new _$(s.shape),n.runWebGPUProgram(o,[s],s.dtype,c)}};class M${constructor(e){this.outputShape=[],this.variableNames=["real","imag"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=QQ(this.outputShape),this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="complexAbs"}getUserCode(){return"\n    ".concat(LQ("index")," {\n      if (index < uniforms.size) {\n        let re = abs(getRealByOutputIndex(index));\n        let im = abs(getImagByOutputIndex(index));\n        let mx = max(re, im);\n\n        // The length function in wgsl may be not underflow-safe on some GPUs.\n        // So the safe solution is to ensure underflow-safety in all cases.\n        setOutputAtIndex(index, select(mx * length(vec2<f32>(1, min(re, im)/mx)), 0.0, mx == 0.0));\n      }\n    }\n  ")}}function P$(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}const D$={kernelName:Ah,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t,s=n.tensorMap.get(a.dataId),r=new M$(a.shape),i=[P$(a,s.complexTensorInfos.real),P$(a,s.complexTensorInfos.imag)];return n.runWebGPUProgram(r,i,i[0].dtype)}};class O${constructor(e){this.uniforms="",this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=JS(e,1),this.variableNames=e.map((e,t)=>"T".concat(t)),this.dispatchLayout=QQ(this.outputShape),this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.offsetLength=e.length-1;for(let t=0;t<this.offsetLength;t++)this.uniforms+="offset".concat(t," : i32,");this.shaderKey="concat"}getUserCode(){const e=[];if(this.offsetLength>0){e.push("if (yC < uniforms.offset0){ setOutputAtCoords(coords.x, coords.y, getT0(yR, yC)); }");for(let a=1;a<this.offsetLength;a++)e.push("else if (yC < uniforms.offset".concat([a],"){ ")+"setOutputAtCoords(coords.x, coords.y, getT".concat(a,"(yR, yC - uniforms.offset").concat(a-1,")); }"));const t=this.offsetLength,n=this.offsetLength-1;e.push("else { setOutputAtCoords(coords.x, coords.y, getT".concat(t,"(yR, yC - uniforms.offset").concat(n,")); }"))}else e.push("setOutputAtCoords(coords.x, coords.y, getT0(yR, yC));");return"\n      ".concat(LQ("index")," {\n        for(var i = 0; i < ").concat(this.workPerThread,"; i = i + 1) {\n          let flatIndex = index * ").concat(this.workPerThread," + i;\n          if(flatIndex < uniforms.size) {\n            let coords = getCoordsFromIndex(flatIndex);\n            let yR = coords.x;\n            let yC = coords.y;\n\n            ").concat(e.join("\n        "),"\n          }\n        }\n      }\n    ")}}function F$(e){const{inputs:t,backend:n}=e,{input:a}=t;return _Z({inputs:{x:n.tensorMap.get(a.dataId).complexTensorInfos.imag},backend:n})}const L$={kernelName:wd,backendName:"webgpu",kernelFunc:F$};function z$(e,t,n){const a=e[0].dtype;if("complex64"===a){const a=e.map(e=>C$({inputs:{input:e},backend:n})),s=e.map(e=>F$({inputs:{input:e},backend:n})),r=z$(a,t,n),i=z$(s,t,n),o=MZ({inputs:{real:r,imag:i},backend:n});return a.forEach(e=>n.disposeData(e.dataId)),s.forEach(e=>n.disposeData(e.dataId)),n.disposeData(r.dataId),n.disposeData(i.dataId),o}let s=n.shouldExecuteOnCPU(e);if("string"===a&&(s=!0),s){const s=e.map(e=>{const a=vu(e.shape.slice(t));return CZ({inputs:{x:e},backend:n,attrs:{shape:[-1,a]}})}),r=s.map(e=>({vals:n.readSync(e.dataId),shape:e.shape})),i=JS(s.map(e=>e.shape),1),o=1===s[0].shape[0],c=jZ(r,i,a,o),l=JS(e.map(e=>e.shape),t),u=n.makeTensorInfo(l,a,c);return s.forEach(e=>n.disposeData(e.dataId)),u}const r=n.device.limits.maxStorageBuffersPerShaderStage-1;if(e.length>r){const a=[];for(let i=0;i<e.length;i+=r){const s=e.slice(i,i+r);a.push(z$(s,t,n))}const s=z$(a,t,n);for(const e of a)n.disposeData(e.dataId);return s}const{tensors2D:i,outShape:o}=function(e,t,n){const a=JS(e.map(e=>e.shape),t),s=e.map(e=>CZ({inputs:{x:e},backend:n,attrs:{shape:[vu(e.shape.slice(0,t)),vu(e.shape.slice(t))]}}));return{tensors2D:s,outShape:a}}(e,t,n),c=i.map(e=>e.shape),l=new O$(c),u=[],h=new Array(c.length-1);if(h.length>0){h[0]=c[0][1],u.push({type:"int32",data:[h[0]]});for(let e=1;e<h.length;e++)h[e]=h[e-1]+c[e][1],u.push({type:"int32",data:[h[e]]})}const d=n.runWebGPUProgram(l,i,i[0].dtype,u);i.forEach(e=>n.disposeData(e.dataId));const p=CZ({inputs:{x:d},backend:n,attrs:{shape:o}});return n.disposeData(d.dataId),p}function B$(e){const{inputs:t,backend:n,attrs:a}=e,{axis:s}=a,r=Eu(s,t[0].shape)[0];ZS(t.map(e=>e.shape),r);const i=JS(t.map(e=>e.shape),r);if(0===vu(i))return n.makeTensorInfo(i,t[0].dtype,[]);const o=t.filter(e=>vu(e.shape)>0);return 1===o.length?_Z({inputs:{x:o[0]},backend:n}):z$(o,r,n)}const j$={kernelName:Mh,backendName:"webgpu",kernelFunc:B$};class W${constructor(e,t,n,a){let s=arguments.length>4&&void 0!==arguments[4]&&arguments[4],r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,i=arguments.length>6&&void 0!==arguments[6]&&arguments[6],o=arguments.length>7&&void 0!==arguments[7]&&arguments[7];this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.outShape,this.isChannelsLast="channelsLast"===e.dataFormat,this.isVec4=((e.inChannels%4===0||e.inChannels%3===0)&&this.isChannelsLast||e.outWidth%4===0&&!this.isChannelsLast)&&e.outChannels%4===0,this.dispatchLayout=this.isChannelsLast?{x:[3],y:[1,2],z:[0]}:{x:[2,3],y:[1],z:[0]},this.workgroupSize=XQ(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=YQ(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4?(this.outputComponent=4,this.isChannelsLast&&e.inChannels%4!==0?(this.innerElementSize=3,this.variableComponents=[1,4]):(this.innerElementSize=4,this.variableComponents=[4,4]),s&&(this.variableNames.push("bias"),this.variableComponents.push(4)),i&&(this.variableNames.push("preluActivationWeights"),this.variableComponents.push(4))):(this.innerElementSize=this.elementsPerThread[0],s&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights")),this.sequentialAccessByThreads=o,this.addBias=s,this.activation=r,this.hasPreluActivationWeights=i,this.tileAOuter=this.workgroupSize[1]*this.elementsPerThread[1],this.tileBOuter=this.workgroupSize[0]*this.elementsPerThread[0],this.tileInner=Math.max(this.workgroupSize[0]*this.innerElementSize,this.workgroupSize[1]),this.fitAOuter=t%this.tileAOuter===0,this.fitBOuter=n%this.tileBOuter===0,this.fitInner=a%this.tileInner===0,this.shaderKey="conv2DMM_".concat(this.elementsPerThread,"_").concat(this.activation,"}_").concat(this.fitAOuter,"_").concat(this.fitBOuter,"_").concat(this.fitInner,"_").concat(this.isVec4,"_").concat(this.innerElementSize,"_").concat(this.isChannelsLast,"_").concat(this.sequentialAccessByThreads)}getUserCode(){const e=this.isVec4?pZ(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner):mZ(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner,!1,null,this.sequentialAccessByThreads),t=this.isVec4?[this.innerElementSize,4,4]:[1,1,1],n="\n    ".concat(function(e,t,n,a){let s=arguments.length>4&&void 0!==arguments[4]&&arguments[4],r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,i=arguments.length>6&&void 0!==arguments[6]&&arguments[6],o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:4,c=arguments.length>8&&void 0!==arguments[8]?arguments[8]:4,l=arguments.length>9&&void 0!==arguments[9]?arguments[9]:4;const u=e?"\n      let coord = vec4<i32>(batch, xRow, xCol, xCh);\n      ":"\n      let coord = vec4<i32>(batch, xCh, xRow, xCol);\n      ",h=e?"\n      let coords = vec4<i32>(\n        batch,\n        row / outWidth,\n        row % outWidth,\n        col);\n      ":"\n      let coords = vec4<i32>(\n        batch,\n        row,\n        col / outWidth,\n        col % outWidth);\n      ",d=e?"uniforms.xShape[1]":"uniforms.xShape[2]",p=e?"uniforms.xShape[2]":"uniforms.xShape[3]",f=e?"row":"col",m=e?"col":"row",g="\n      let inChannels = uniforms.wShape[2];\n      let outWidth = ".concat(e?"uniforms.outShape[2]":"uniforms.outShape[3]",";\n      let outRow = ").concat(f," / outWidth;\n      let outCol = ").concat(f," % outWidth;\n\n      let WRow = ").concat(m," / (uniforms.filterDims[1] * inChannels);\n      let WCol = ").concat(m," / inChannels % uniforms.filterDims[1];\n      let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * WRow - uniforms.pads[0];\n      let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * WCol - uniforms.pads[1];\n      let xCh = ").concat(m," % inChannels;\n      var resData = ").concat(DQ(o),"(0.0);\n      // The bounds checking is always needed since we use it to pad zero for\n      // the 'same' padding type.\n      if (xRow >= 0 && xRow < ").concat(d," && xCol >= 0 && xCol < ").concat(p,") {\n        ").concat(u,"\n        let xIndex = getIndexFromCoords4D(coord, uniforms.xShape);\n        ").concat((e=>{switch(e){case 1:return"resData = f32(x[xIndex]);";case 3:return"resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);";case 4:return"resData = vec4<f32>(x[xIndex / 4]);";default:throw new Error("innerElementSize ".concat(e," is not supported."))}})(o),"\n      }\n      return resData;"),y=e?t&&a?"\n      ".concat(g):"\n      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {\n        ".concat(g,"\n      }\n      return ").concat(DQ(o),"(0.0);"):a&&n?"\n      ".concat(g):"\n      if (row < uniforms.dimInner && col < uniforms.dimBOuter) {\n        ".concat(g,"\n      }\n      return ").concat(DQ(o),"(0.0);"),b="".concat((e=>{switch(e){case 1:return"return f32(W[row * uniforms.wShape[3] + col]);";case 4:return"return vec4<f32>(W[(row * uniforms.wShape[3] + col) / 4]);";default:throw new Error("innerElementSize ".concat(e," is not supported."))}})(c)),x=DQ(l),v=DQ(e?o:c),w=DQ(e?c:o);return"\n      ".concat(lZ(r,i,4===l,4),"\n      fn mm_readA(batch: i32, row : i32, col : i32) -> ").concat(v," {\n        ").concat(e?y:b,"\n      }\n\n      fn mm_readB(batch: i32, row : i32, col : i32) -> ").concat(w," {\n        ").concat(e?b:y,"\n      }\n\n      fn mm_write(batch: i32, row : i32, col : i32, valueIn : ").concat(x,") {\n        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)\n        {\n        var value = valueIn;\n        let outWidth = ").concat(e?"uniforms.outShape[2]":"uniforms.outShape[3]",";\n        ").concat(h,"\n        ").concat(uZ(s,r),"\n        setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n        }\n      }")}(this.isChannelsLast,this.fitAOuter,this.fitBOuter,this.fitInner,this.addBias,this.activation,this.hasPreluActivationWeights,t[0],t[1],t[2]),"\n    ").concat(e,"\n  ");return n}}class V${constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];this.variableNames=["x","W"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>,",this.workgroupSize=[4,4,8],this.outputShape=e.outShape,this.isChannelsLast="channelsLast"===e.dataFormat,this.dispatchLayout=this.isChannelsLast?{x:[2],y:[1],z:[0,3]}:{x:[3],y:[2],z:[0,1]},this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=t,this.activation=n,this.hasPreluActivationWeights=a,t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),this.shaderKey="conv2dnaive_".concat(this.activation,"_").concat(this.isChannelsLast)}getUserCode(){return"\n       ".concat(lZ(this.activation,this.hasPreluActivationWeights,!1,4),"\n       fn readInp(batch : i32, row : i32, col : i32, chan : i32) -> f32{\n         let coords = vec4<i32>(batch, row, col, chan);\n         if (coordsInBounds4D(coords, uniforms.xShape)) {\n           return  getX(batch, row, col, chan);\n         } else {\n          return 0.0;\n         }\n       }\n       fn readFilt(row : i32, col : i32, xChannel : i32, outChannel : i32) -> f32{\n         let coords = vec4<i32>(row, col, xChannel, outChannel);\n         if(coordsInBounds4D(coords, uniforms.wShape)) {\n           return getW(row, col, xChannel, outChannel);\n          } else {\n            return 0.0;\n          }\n       }\n       fn writeResult(batch : i32, row : i32, col : i32, chan : i32, valueIn : f32) {\n         let coords = ").concat(this.isChannelsLast?"vec4<i32>(batch, row, col, chan);":"vec4<i32>(batch, chan, row, col);","\n         if (coordsInBounds4D(coords, uniforms.outShape)) {\n           var value = valueIn;\n           ").concat(uZ(this.addBias,this.activation),"\n           setOutputAtCoords(coords.x, coords.y, coords.z, coords.w, value);\n         }\n       }\n       ").concat(LQ("index")," {\n         let coords = getOutputCoords();\n         let batch = coords[0];\n         let outChannel = ").concat(this.isChannelsLast?"coords[3];":"coords[1];","\n         let outRow = ").concat(this.isChannelsLast?"coords[1];":"coords[2];","\n         let outCol = ").concat(this.isChannelsLast?"coords[2];":"coords[3];","\n         var acc : f32 = 0.0;\n         for (var row = 0; row < uniforms.filterDims[0]; row = row + 1) {\n           for (var col = 0; col < uniforms.filterDims[1]; col = col + 1) {\n             let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * row - uniforms.pads[0];\n             let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * col - uniforms.pads[1];\n             for (var xChannel = 0; xChannel < ").concat(this.isChannelsLast?"uniforms.xShape[3];":"uniforms.xShape[1];"," xChannel = xChannel + 1) {\n               ").concat(this.isChannelsLast?"let v = readInp(batch, xRow, xCol, xChannel);":"let v = readInp(batch, xChannel, xRow, xCol);","\n               let f = readFilt(row, col, xChannel, outChannel);\n               acc = acc + v * f;\n             }\n           }\n         }\n         writeResult(batch, outRow, outCol, outChannel, acc);\n       }\n     ")}}class U${constructor(e,t){this.variableNames=["x"],this.uniforms="pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, outWidth : i32, itemsPerBlockRow : i32,\n       inChannels : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=QQ(this.outputShape),this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=t,this.shaderKey="im2col_".concat(this.isChannelsLast)}getUserCode(){const e=this.isChannelsLast?1:2,t=this.isChannelsLast?2:3,n=this.isChannelsLast?"coords[1]":"coords[2]",a=this.isChannelsLast?"coords[2]":"coords[1]",s=this.isChannelsLast?"getX(batch, xRow, xCol, ch)":"getX(batch, ch, xRow, xCol)";return"\n    ".concat(LQ("index")," {\n      let coords = getCoordsFromIndex(index);\n      if(index < uniforms.size) {\n        let batch = coords[0];\n        let row = ").concat(n,";\n        let col = ").concat(a,";\n        let offsetY = (row / uniforms.outWidth) * uniforms.strides[0] - uniforms.pads[0];\n        let xRow = offsetY + uniforms.dilations[0] * (col / uniforms.itemsPerBlockRow);\n        var value = 0.0;\n        if(xRow < uniforms.xShape[").concat(e,"] && xRow >= 0) {\n          let offsetX = (row % uniforms.outWidth) * uniforms.strides[1] -\n              uniforms.pads[1];\n          let xCol = offsetX + uniforms.dilations[1] * ((col %\n              uniforms.itemsPerBlockRow) / uniforms.inChannels);\n          let ch = col % uniforms.inChannels;\n          if(xCol < uniforms.xShape[").concat(t,"] && xCol >= 0) {\n            value = ").concat(s,";\n          }\n        }\n        setOutputAtIndex(index, value);\n      }\n    }\n   ")}}function H$(e,t){const n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&1===n&&e[0]>1?[e[0],1]:null}function G$(e){let{x:t,filter:n,convInfo:a,backend:s,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:c=null}=e;const l=null!=r,u=null!=i,h="channelsLast"===a.dataFormat,d=h&&a.filterHeight===a.inHeight&&a.filterWidth===a.inWidth&&"VALID"===a.padInfo.type,p=$u().getBool("WEBGPU_USE_NAIVE_CONV2D_DEBUG");if(!p&&(d||1===a.filterHeight&&1===a.filterWidth&&1===a.dilationHeight&&1===a.dilationWidth&&1===a.strideHeight&&1===a.strideWidth&&("SAME"===a.padInfo.type||"VALID"===a.padInfo.type)))return function(e){let{x:t,filter:n,convInfo:a,backend:s,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:c=null}=e;const l="channelsLast"===a.dataFormat,u=!l,h=[];let d,p;if(l&&a.filterHeight===a.inHeight&&a.filterWidth===a.inWidth&&"VALID"===a.padInfo.type){const e=a.inHeight*a.inWidth*a.inChannels;d=CZ({inputs:{x:t},backend:s,attrs:{shape:[1,a.batchSize,e]}}),p=CZ({inputs:{x:n},backend:s,attrs:{shape:[1,e,a.outChannels]}})}else d=CZ({inputs:{x:t},backend:s,attrs:{shape:l?[a.batchSize,a.inHeight*a.inWidth,a.inChannels]:[a.batchSize,a.inChannels,a.inHeight*a.inWidth]}}),p=CZ({inputs:{x:n},backend:s,attrs:{shape:[1,a.inChannels,a.outChannels]}});if(h.push(d),h.push(p),null!=i){const e=H$(i.shape,l);null!=e&&(i=CZ({inputs:{x:i},backend:s,attrs:{shape:e}}),h.push(i))}if(null!=r){const e=H$(r.shape,l);null!=e&&(r=CZ({inputs:{x:r},backend:s,attrs:{shape:e}}),h.push(r))}const f=NZ({a:l?d:p,b:l?p:d,transposeA:u,transposeB:!1,backend:s,bias:r,activation:c,preluActivationWeights:i,leakyreluAlpha:o}),m=CZ({inputs:{x:f},backend:s,attrs:{shape:a.outShape}});h.push(f);for(const g of h)s.disposeData(g.dataId);return m}({x:t,filter:n,convInfo:a,backend:s,bias:r,activation:c,preluActivationWeights:i,leakyreluAlpha:o});const f=$u().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),m=f>-1?f:s.thresholdToIncreaseWorkgroups,g=a.batchSize*Math.ceil(a.outHeight*a.outWidth/32)*Math.ceil(a.outChannels/32);if($u().getBool("WEBGPU_CONV_SEPARATE_IM2COL_SHADER")||g<=m)return function(e){let{x:t,filter:n,convInfo:a,backend:s,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:c=null}=e;const{filterWidth:l,filterHeight:u,inChannels:h,strideWidth:d,strideHeight:p,padInfo:f,outWidth:m,outHeight:g,dilationWidth:y,dilationHeight:b,dataFormat:x}=a,v="channelsLast"===x,w=l*u*h,k=g*m,S=v?[a.batchSize,k,w]:[a.batchSize,w,k],C=new U$(S,v),I=[{type:"int32",data:[f.top,f.left]},{type:"int32",data:[p,d]},{type:"int32",data:[b,y]},{type:"int32",data:[m]},{type:"int32",data:[h*l]},{type:"int32",data:[h]}],N=s.runWebGPUProgram(C,[t],t.dtype,I),T=[];T.push(N);const E=CZ({inputs:{x:n},backend:s,attrs:{shape:[1,w,-1]}});if(T.push(E),null!=i){const e=H$(i.shape,v);null!=e&&(i=CZ({inputs:{x:i},backend:s,attrs:{shape:e}}),T.push(i))}if(null!=r){const e=H$(r.shape,v);null!=e&&(r=CZ({inputs:{x:r},backend:s,attrs:{shape:e}}),T.push(r))}const R=NZ({a:v?N:E,b:v?E:N,transposeA:!v,transposeB:!1,backend:s,bias:r,activation:c,preluActivationWeights:i,leakyreluAlpha:o}),_=CZ({inputs:{x:R},backend:s,attrs:{shape:a.outShape}});T.push(R);for(const A of T)s.disposeData(A.dataId);return _}({x:t,filter:n,convInfo:a,backend:s,bias:r,preluActivationWeights:i,leakyreluAlpha:o,activation:c});let y;const b=[a.padInfo.top,a.padInfo.left],x=[{type:"int32",data:[a.filterHeight,a.filterWidth]},{type:"int32",data:[...b]},{type:"int32",data:[a.strideHeight,a.strideWidth]},{type:"int32",data:[a.dilationHeight,a.dilationWidth]}];if(p)y=new V$(a,l,c,u);else{const e=h?a.outHeight*a.outWidth:a.outChannels,t=h?a.outChannels:a.outHeight*a.outWidth,n=a.filterHeight*a.filterWidth*a.inChannels;x.push({type:"int32",data:[e]},{type:"int32",data:[t]},{type:"int32",data:[n]});const r=s.adapterInfo.isIntel();y=new W$(a,e,t,n,l,c,u,r)}const v=[],w=[t,n];l&&(h||1!==r.shape.length||(r=CZ({inputs:{x:r},backend:s,attrs:{shape:[r.shape[0],1,1]}}),v.push(r)),w.push(r)),u&&(h||1!==i.shape.length||(i=CZ({inputs:{x:i},backend:s,attrs:{shape:[i.shape[0],1,1]}}),v.push(i)),w.push(i)),"leakyrelu"===c&&(x.push({type:"float32",data:[o]}),y.uniforms+=" alpha : f32,");const k=s.runWebGPUProgram(y,w,t.dtype,x);for(const S of v)s.disposeData(S.dataId);return k}const q$={kernelName:Ph,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:a}=e,{x:s,filter:r}=t,{strides:i,pad:o,dataFormat:c,dilations:l,dimRoundingMode:u}=n,h=$b(c);return G$({x:s,filter:r,convInfo:Ub(s.shape,r.shape,i,l,o,u,!1,h),backend:a})}};class K${constructor(e){this.variableNames=["dy","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>,",this.workgroupSize=[64,1,1],this.size=!1,this.isVec4=!1,this.workPerThread=1,this.outputShape=e.inShape,this.isChannelsLast="channelsLast"===e.dataFormat,this.isVec4=this.isChannelsLast&&e.outChannels%4===0&&e.inChannels%4===0,this.isVec4?(this.workPerThread=2,this.outputComponent=4,this.workgroupSize=[4,4,4],this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize,[4,this.workPerThread,1])):(this.size=!0,this.workPerThread=1,this.workgroupSize=[64,1,1],this.dispatchLayout=QQ(this.outputShape),this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize)),this.shaderKey="conv2DDerInput_".concat(this.isChannelsLast,"_").concat(this.isVec4,"_").concat(this.workPerThread)}getUserCode(){const e=this.isChannelsLast?1:2,t=this.isChannelsLast?2:3,n=this.isChannelsLast?3:1,a="\n    ".concat(LQ()," {\n      let batch = i32(globalId.z) / uniforms.outShape[1];\n      let r = i32(globalId.z) % uniforms.outShape[1];\n      let c = i32(globalId.y) * ").concat(this.workPerThread,";\n      let d1 = i32(globalId.x) * 4;\n\n      let dyCorner = vec2<i32>(r, c) - uniforms.pads;\n\n      // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n      // ? = to be determined. : = across all values in that axis.\n      var dotProd: array<vec4<f32>, ").concat(this.workPerThread,">;\n      for (var i = 0; i < ").concat(this.workPerThread,"; i++) {\n        dotProd[i] = vec4<f32>(0.0);\n      }\n      for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {\n        let dyR = f32(dyCorner.x + wR) / f32(uniforms.strides.x);\n        let wRPerm = uniforms.filterDims.x - 1 - wR;\n        if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) ||\n            fract(dyR) > 0.0) {\n          continue;\n        }\n        let idyR = i32(dyR);\n\n        for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {\n          let dyC = f32(dyCorner.y + wC) / f32(uniforms.strides.y);\n          let dyC2 = f32(dyCorner.y + 1 + wC) / f32(uniforms.strides.y);\n          let wCPerm = uniforms.filterDims.y - 1 - wC;\n          var bDyCVal = true;\n          var bDyCVal2 = true;\n          if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||\n              fract(dyC) > 0.0) {\n            bDyCVal = false;\n          }\n          if (dyC2 < 0.0 || dyC2 >= f32(uniforms.outBackprop[2]) ||\n              fract(dyC2) > 0.0) {\n            bDyCVal2 = false;\n          }\n\n          let idyC = i32(dyC);\n          let idyC2 = i32(dyC2);\n          if (bDyCVal && bDyCVal2) {\n            let d2Length = uniforms.outBackprop[3];\n            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {\n              let wValue0 = getW(wRPerm, wCPerm, d1, d2);\n              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);\n              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);\n              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);\n              var xValue =  getDy(batch, idyR, idyC, d2);\n              let tmpval = vec4<f32>(dot(xValue, wValue0),\n                                     dot(xValue, wValue1),\n                                     dot(xValue, wValue2),\n                                     dot(xValue, wValue3));\n              dotProd[0] = dotProd[0] + tmpval;\n              xValue = getDy(batch, idyR, idyC2, d2);\n              dotProd[1] = dotProd[1] + vec4<f32>(dot(xValue, wValue0),\n                                                  dot(xValue, wValue1),\n                                                  dot(xValue, wValue2),\n                                                  dot(xValue, wValue3));\n            }\n          } else if (bDyCVal) {\n            let d2Length = uniforms.outBackprop[3];\n            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {\n              let wValue0 = getW(wRPerm, wCPerm, d1, d2);\n              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);\n              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);\n              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);\n              var xValue =  getDy(batch, idyR, idyC, d2);\n              let tmpval = vec4<f32>(dot(xValue, wValue0),\n                                     dot(xValue, wValue1),\n                                     dot(xValue, wValue2),\n                                     dot(xValue, wValue3));\n              dotProd[0] = dotProd[0] + tmpval;\n            }\n          } else if (bDyCVal2) {\n            let d2Length = uniforms.outBackprop[3];\n            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {\n              let wValue0 = getW(wRPerm, wCPerm, d1, d2);\n              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);\n              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);\n              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);\n              var xValue =  getDy(batch, idyR, idyC2, d2);\n              let tmpval = vec4<f32>(dot(xValue, wValue0),\n                                     dot(xValue, wValue1),\n                                     dot(xValue, wValue2),\n                                     dot(xValue, wValue3));\n              dotProd[1] = dotProd[1] + tmpval;\n            }\n          }\n        }\n      }\n\n      for (var i = 0; i < ").concat(this.workPerThread,"; i = i + 1) {\n        let coords = vec4<i32>(batch, r, c + i, d1);\n        if (coordsInBounds4D(coords, uniforms.outShape)) {\n          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], dotProd[i]);\n        }\n      }\n    }\n    ");return this.isVec4?"\n    ".concat(a,"\n    "):"\n    ".concat(LQ("index")," {\n      if(index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords[0];\n        let d1 = coords[").concat(n,"];\n\n        let dyCorner = vec2<i32>(coords[").concat(e,"], coords[").concat(t,"]) - uniforms.pads;\n        let dyRCorner = dyCorner.x;\n        let dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {\n          let dyR = (f32(dyRCorner) + f32(wR)) / f32(uniforms.strides.x);\n          let wRPerm = uniforms.filterDims.x - 1 - wR;\n          if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) || fract(dyR) > 0.0 ||\n              wRPerm < 0) {\n            continue;\n          }\n          let idyR = i32(dyR);\n\n          for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {\n            let dyC = (f32(dyCCorner) + f32(wC)) / f32(uniforms.strides.y);\n            let wCPerm = uniforms.filterDims.y - 1 - wC;\n            if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||\n                fract(dyC) > 0.0 || wCPerm < 0) {\n              continue;\n            }\n            let idyC = i32(dyC);\n\n            for (var d2 = 0; d2 < uniforms.outBackprop[3]; d2 = d2 + 1) {\n              let xValue = ").concat(this.isChannelsLast?"getDy(batch, idyR, idyC, d2)":"getDy(batch, d2, idyR, idyC)",";\n              let wValue = getW(wRPerm, wCPerm, d1, d2);\n              dotProd = dotProd + xValue * wValue;\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n  ")}}class X${constructor(e){this.variableNames=["x","dy"],this.uniforms="pads : vec2<i32>, strides : vec2<i32>, batchSize : i32, outHeight : i32, outWidth : i32, inHeight : i32, inWidth : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=QQ(this.outputShape),this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast="channelsLast"===e.dataFormat,this.shaderKey="conv2DDerFilter_".concat(this.isChannelsLast)}getUserCode(){return"\n    ".concat(LQ("index")," {\n      if(index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let wR = coords[0];\n        let wC = coords[1];\n        let d1 = coords[2];\n        let d2 = coords[3];\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        for (var b = 0; b < uniforms.batchSize; b = b + 1) {\n          for (var yR = 0; yR < uniforms.outHeight; yR = yR + 1) {\n            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];\n            if (xR < 0 || xR >= uniforms.inHeight) {\n              continue;\n            }\n\n            for (var yC = 0; yC < uniforms.outWidth; yC = yC + 1) {\n              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];\n\n              if (xC < 0 || xC >= uniforms.inWidth) {\n                continue;\n              }\n\n              if (").concat(this.isChannelsLast,") {\n                let dyValue = getDy(b, yR, yC, d2);\n                let xValue = getX(b, xR, xC, d1);\n                dotProd = dotProd + xValue * dyValue;\n              } else {\n                let dyValue = getDy(b, d2, yR, yC);\n                let xValue = getX(b, d1, xR, xC);\n                dotProd = dotProd + xValue * dyValue;\n              }\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n  ")}}class Y${constructor(e){this.variableNames=["x","dy"],this.uniforms="pads : vec3<i32>, strides : vec3<i32>, batchSize : i32, outDepth : i32,\n       outHeight : i32, outWidth : i32, inDepth : i32, inHeight : i32, inWidth : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=QQ(this.outputShape),this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3DDerFilter"}getUserCode(){return"\n    ".concat(LQ("index")," {\n      if(index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let wF = coords.x;\n        let wR = coords.y;\n        let wC = coords.z;\n        let d1 = coords.w;\n        let d2 = coords.u;\n\n        var dotProd = 0.0;\n        for (var b = 0; b < uniforms.batchSize; b++) {\n          for (var yF = 0; yF < uniforms.outDepth; yF++) {\n            let xF = wF + yF * uniforms.strides[0] - uniforms.pads[0];\n            if (xF < 0 || xF >= uniforms.inDepth) {\n              continue;\n            }\n\n            for (var yR = 0; yR < uniforms.outHeight; yR++) {\n              let xR = wR + yR * uniforms.strides[1] - uniforms.pads[1];\n              if (xR < 0 || xR >= uniforms.inHeight) {\n                continue;\n              }\n\n              for (var yC = 0; yC < uniforms.outWidth; yC++) {\n                let xC = wC + yC * uniforms.strides[2] - uniforms.pads[2];\n                if (xC < 0 || xC >= uniforms.inWidth) {\n                  continue;\n                }\n\n                let dyValue = getDy(b, yF, yR, yC, d2);\n                let xValue = getX(b, xF, xR, xC, d1);\n                dotProd += xValue * dyValue;\n              }\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n  ")}}class Q${constructor(e){this.variableNames=["dy","W"],this.uniforms="filterDims : vec3<i32>, pads : vec3<i32>, strides : vec3<i32>,\n      outDepth : i32, outHeight : i32, outWidth : i32, outChannels : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=QQ(this.outputShape),this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3DDerInput"}getUserCode(){return"\n    ".concat(LQ("index")," {\n      if(index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords.x;\n        let d1 = coords.u;\n\n        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;\n        let dyFCorner = dyCorner.x;\n        let dyRCorner = dyCorner.y;\n        let dyCCorner = dyCorner.z;\n\n        var dotProd = 0.0;\n        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {\n          let dyF = f32(dyFCorner + wF) / f32(uniforms.strides[0]);\n          if (dyF < 0.0 || dyF >= f32(uniforms.outDepth) || fract(dyF) > 0.0) {\n            continue;\n          }\n          let idyF = i32(dyF);\n\n          let wFPerm = uniforms.filterDims[0] - 1 - wF;\n\n          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {\n            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);\n\n            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {\n              continue;\n            }\n            let idyR = i32(dyR);\n\n            let wRPerm = uniforms.filterDims[1] - 1 - wR;\n\n            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {\n              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);\n\n              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {\n                continue;\n              }\n              let idyC = i32(dyC);\n\n              let wCPerm = uniforms.filterDims[2] - 1 - wC;\n\n              for (var d2 = 0; d2 < uniforms.outChannels; d2++) {\n                let xValue = getDy(batch, idyF, idyR, idyC, d2);\n                let wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n  ")}}const Z$={kernelName:Dh,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,dy:r}=t,{strides:i,pad:o,dataFormat:c,dimRoundingMode:l,filterShape:u}=a,h=$b(c),d=Ub(s.shape,u,i,1,o,l,!1,h),p=new X$(d),f=[{type:"int32",data:[d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.batchSize]},{type:"int32",data:[d.outHeight]},{type:"int32",data:[d.outWidth]},{type:"int32",data:[d.inHeight]},{type:"int32",data:[d.inWidth]}];return n.runWebGPUProgram(p,[s,r],s.dtype,f)}};class J${constructor(e){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.inShape,yu("channelsLast"===e.dataFormat,()=>"TODO: NCHW is unimplemented"),this.isVec4=e.inChannels%4===0&&e.outChannels%4===0,this.dispatchLayout={x:[3],y:[1,2],z:[0]},this.workgroupSize=XQ(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=YQ(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4&&(this.outputComponent=4,this.variableComponents=[4,1]),this.shaderKey="conv2DDerInputMM_".concat(this.isVec4,"_").concat(this.elementsPerThread)}getUserCode(){const e=this.isVec4?pZ(this.elementsPerThread,this.workgroupSize):mZ(this.elementsPerThread,this.workgroupSize),t="\n    ".concat(function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:4;const t="\n      let outRow = row / uniforms.outShape[2];\n      let outCol = row % uniforms.outShape[2];\n\n      let WRow = col / (uniforms.filterDims[1] * uniforms.outBackprop[3]);\n      let WCol = col / uniforms.outBackprop[3] % uniforms.filterDims[1];\n      let xR = f32(outRow - uniforms.pads[0] + WRow) / f32(uniforms.strides[0]);\n      let xC = f32(outCol - uniforms.pads[1] + WCol) / f32(uniforms.strides[1]);\n      if (xR < 0.0 || xR >= f32(uniforms.outBackprop[1]) || fract(xR) > 0.0) {\n        return ".concat(DQ(e),"(0.0);\n      }\n      if (xC < 0.0 || xC >= f32(uniforms.outBackprop[2]) || fract(xC) > 0.0) {\n        return ").concat(DQ(e),"(0.0);\n      }\n      let coord = vec4<i32>(\n          batch,\n          i32(xR),\n          i32(xC),\n          col % uniforms.outBackprop[3]);\n      return x[getIndexFromCoords4D(coord, uniforms.xShape)/").concat(e,"];"),n="if (row < uniforms.dimAOuter && col < uniforms.dimInner) {\n        ".concat(t,"\n      }\n      return ").concat(DQ(e),"(0.0);");return"\n  fn mm_readA(batch: i32, row : i32, col : i32) -> ".concat(DQ(e)," {\n    ").concat(n,"\n  }\n\n  fn mm_readB(batch: i32, row : i32, col : i32) -> ").concat(DQ(e)," {\n    let coordX = uniforms.filterDims.x - 1 -\n        row / (uniforms.filterDims[1] * uniforms.outBackprop[3]);\n    let coordY = uniforms.filterDims.y - 1 -\n        (row / uniforms.outBackprop[3]) % uniforms.filterDims[1];\n    if (row < uniforms.dimInner && col < uniforms.dimBOuter &&\n        coordX >= 0 && coordY >= 0) {\n      let rowInner = row % uniforms.outBackprop[3];\n      let coord = vec4<i32>(coordX, coordY, col, rowInner);\n      ").concat((e=>{switch(e){case 1:return"return W[getIndexFromCoords4D(coord, uniforms.wShape)];";case 4:return"\n            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);\n            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);\n            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);\n            let v0 = W[getIndexFromCoords4D(coord, uniforms.wShape)];\n            let v1 = W[getIndexFromCoords4D(coord1, uniforms.wShape)];\n            let v2 = W[getIndexFromCoords4D(coord2, uniforms.wShape)];\n            let v3 = W[getIndexFromCoords4D(coord3, uniforms.wShape)];\n            return vec4<f32>(v0, v1, v2, v3);\n            ";default:throw new Error("innerElementSize ".concat(e," is not supported."))}})(e),"\n    }\n    return ").concat(DQ(e),"(0.0);\n  }\n\n  fn mm_write(batch: i32, row : i32, col : i32, valueInput : ").concat(DQ(e),") {\n    if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {\n      var value = valueInput;\n      let outCoord = vec4<i32>(\n          batch,\n          row / uniforms.outShape[2],\n          row % uniforms.outShape[2],\n          col);\n      result[getIndexFromCoords4D(outCoord, uniforms.outShape)/").concat(e,"] = value;\n    }\n  }")}(this.isVec4?4:1),"\n    ").concat(e,"\n    ");return t}}const $$={kernelName:Oh,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:s,filter:r}=t,{inputShape:i,strides:o,pad:c,dataFormat:l,dimRoundingMode:u}=a,h=$b(l),d=Ub(i,r.shape,o,1,c,u,!1,h),p=[{type:"int32",data:[d.filterHeight,d.filterWidth]},{type:"int32",data:[d.filterHeight-1-d.padInfo.top,d.filterWidth-1-d.padInfo.left]},{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.batchSize,d.outHeight,d.outWidth,d.outChannels]}];let f;if($u().getBool("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE")||"channelsLast"!==d.dataFormat)f=new K$(d);else{f=new J$(d);const e=d.inHeight*d.inWidth,t=d.inChannels,n=d.filterHeight*d.filterWidth*d.outChannels;p.push({type:"uint32",data:[e]},{type:"uint32",data:[t]},{type:"uint32",data:[n]})}return n.runWebGPUProgram(f,[s,r],"float32",p)}};class e0{constructor(e){this.variableNames=["x","W"],this.uniforms="filterDims: vec3<i32>, pads: vec3<i32>, strides: vec3<i32>, dilations: vec3<i32>,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=QQ(this.outputShape),this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3dnaive"}getUserCode(){return"\n    ".concat(LQ("index")," {\n      if (index < uniforms.size) {\n        let coords = getOutputCoords();\n        let batch = coords.x;\n        let d2 = coords.u;\n\n        let xFRCCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;\n        let xFCorner = xFRCCorner.x;\n        let xRCorner = xFRCCorner.y;\n        let xCCorner = xFRCCorner.z;\n\n        let inputDepthNearestVec4 = (uniforms.xShape.u / 4) * 4;\n        let inputDepthVec4Remainder = uniforms.xShape.u % 4;\n\n        var dotProd = 0.0;\n        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {\n          let xF = xFCorner + wF * uniforms.dilations[0];\n          if (xF < 0 || xF >= uniforms.xShape.y) {\n            continue;\n          }\n\n          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {\n            let xR = xRCorner + wR * uniforms.dilations[1];\n            if (xR < 0 || xR >= uniforms.xShape.z) {\n              continue;\n            }\n\n            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {\n              let xC = xCCorner + wC * uniforms.dilations[2];\n              if (xC < 0 || xC >= uniforms.xShape.w) {\n                continue;\n              }\n\n              for (var d1 = 0; d1 < inputDepthNearestVec4; d1 += 4) {\n                let xValues = vec4<f32>(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                let wValues = vec4<f32>(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (inputDepthVec4Remainder == 1) {\n                dotProd += getX(batch, xF, xR, xC, inputDepthNearestVec4) *\n                  getW(wF, wR, wC, inputDepthNearestVec4, d2);\n              } else if (inputDepthVec4Remainder == 2) {\n                let xValues = vec2<f32>(\n                  getX(batch, xF, xR, xC, inputDepthNearestVec4),\n                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1)\n                );\n                let wValues = vec2<f32>(\n                  getW(wF, wR, wC, inputDepthNearestVec4, d2),\n                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (inputDepthVec4Remainder == 3) {\n                let xValues = vec3<f32>(\n                  getX(batch, xF, xR, xC, inputDepthNearestVec4),\n                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),\n                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2)\n                );\n                let wValues = vec3<f32>(\n                  getW(wF, wR, wC, inputDepthNearestVec4, d2),\n                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2),\n                  getW(wF, wR, wC, inputDepthNearestVec4 + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }")}}const t0={kernelName:Fh,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,filter:r}=t,{strides:i,pad:o,dilations:c}=a,l=Hb(s.shape,r.shape,i,c,o),u=[l.padInfo.front,l.padInfo.top,l.padInfo.left],h=[{type:"int32",data:[l.filterDepth,l.filterHeight,l.filterWidth]},{type:"int32",data:[...u]},{type:"int32",data:[l.strideDepth,l.strideHeight,l.strideWidth]},{type:"int32",data:[l.dilationDepth,l.dilationHeight,l.dilationWidth]}],d=new e0(l),p=mm(s.dtype,r.dtype);return n.runWebGPUProgram(d,[s,r],p,h)}};const n0={kernelName:Lh,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,dy:r}=t,{strides:i,pad:o,filterShape:c}=a,l=Hb(s.shape,c,i,1,o),u=new Y$(l),h=[{type:"int32",data:[l.padInfo.front,l.padInfo.top,l.padInfo.left]},{type:"int32",data:[l.strideDepth,l.strideHeight,l.strideWidth]},{type:"int32",data:[l.batchSize]},{type:"int32",data:[l.outDepth]},{type:"int32",data:[l.outHeight]},{type:"int32",data:[l.outWidth]},{type:"int32",data:[l.inDepth]},{type:"int32",data:[l.inHeight]},{type:"int32",data:[l.inWidth]}];return n.runWebGPUProgram(u,[s,r],r.dtype,h)}};const a0={kernelName:zh,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:s,filter:r}=t,{strides:i,pad:o,inputShape:c}=a,l=Hb(c,r.shape,i,1,o),u=new Q$(l),h=[{type:"int32",data:[l.filterDepth,l.filterHeight,l.filterWidth]},{type:"int32",data:[l.filterDepth-1-l.padInfo.front,l.filterHeight-1-l.padInfo.top,l.filterWidth-1-l.padInfo.left]},{type:"int32",data:[l.strideDepth,l.strideHeight,l.strideWidth]},{type:"int32",data:[l.outDepth]},{type:"int32",data:[l.outHeight]},{type:"int32",data:[l.outWidth]},{type:"int32",data:[l.outChannels]}];return n.runWebGPUProgram(u,[s,r],s.dtype,h)}},s0=OZ({opType:rZ.COS}),r0={kernelName:Bh,backendName:"webgpu",kernelFunc:s0},i0=OZ({opType:rZ.COSH}),o0={kernelName:jh,backendName:"webgpu",kernelFunc:i0};class c0{constructor(e,t,n,a){this.variableNames=["Image","Boxes","BoxInd"],this.uniforms="extrapolationValue : f32,",this.workgroupSize=[64,1,1],this.size=!0;const[s]=t;this.outputShape=[s,n[0],n[1],e],this.dispatchLayout=QQ(this.outputShape),this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.methodId="bilinear"===a?1:0,this.cropHeightBiggerThan1=this.outputShape[1]>1,this.cropWidthBiggerThan1=this.outputShape[2]>1,this.shaderKey="cropAndResize_".concat(this.methodId,"_").concat(this.cropHeightBiggerThan1,"_").concat(this.cropWidthBiggerThan1)}getUserCode(){const[e,t]=["f32(uniforms.imageShape[1] - 1)","f32(uniforms.imageShape[2] - 1)"],[n,a,s]=this.cropHeightBiggerThan1?["(".concat(e," / f32(uniforms.outShape[1] - 1))"),"(y2-y1) * height_ratio","y1*".concat(e," + f32(y)*(height_scale)")]:["0.0","0.0","0.5 * (y1+y2) * ".concat(e)],[r,i,o]=this.cropWidthBiggerThan1?["(".concat(t," / f32(uniforms.outShape[2] - 1))"),"(x2-x1) * width_ratio","x1*".concat(t," + f32(x)*(width_scale)")]:["0.0","0.0","0.5 * (x1+x2) * ".concat(t)];return"\n    ".concat(LQ("index")," {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let height_ratio = f32(").concat(n,");\n        let width_ratio = f32(").concat(r,");\n        let b = coords[0];\n        let y = coords[1];\n        let x = coords[2];\n        let d = coords[3];\n        // get box vals\n        let y1 = getBoxes(b, 0);\n        let x1 = getBoxes(b, 1);\n        let y2 = getBoxes(b, 2);\n        let x2 = getBoxes(b, 3);\n        // get image in batch index\n        let bInd = i32(round(getBoxInd(b)));\n        if(bInd < 0 || bInd >= uniforms.outShape[0]) {\n          return;\n        }\n        let height_scale = ").concat(a,";\n        let width_scale = ").concat(i,";\n        let in_y = ").concat(s,";\n        if( in_y < 0.0 || in_y > ").concat(e," ) {\n          setOutputAtIndex(index, uniforms.extrapolationValue);\n          return;\n        }\n        let in_x = ").concat(o,";\n        if( in_x < 0.0 || in_x > ").concat(t," ) {\n          setOutputAtIndex(index, uniforms.extrapolationValue);\n          return;\n        }\n        let sourceFracIndexCR = vec2<f32>(in_x,in_y);\n        if(").concat(this.methodId," == 1) {\n          // Compute the four integer indices.\n          let sourceFloorCR = vec2<i32>(sourceFracIndexCR);\n          let sourceCeilCR = vec2<i32>(ceil(sourceFracIndexCR));\n          let topLeft = getImage(bInd, sourceFloorCR.y, sourceFloorCR.x, d);\n          let bottomLeft = getImage(bInd, sourceCeilCR.y, sourceFloorCR.x, d);\n          let topRight = getImage(bInd, sourceFloorCR.y, sourceCeilCR.x, d);\n          let bottomRight = getImage(bInd, sourceCeilCR.y, sourceCeilCR.x, d);\n          let fracCR = sourceFracIndexCR - vec2<f32>(sourceFloorCR);\n          let top = topLeft + (topRight - topLeft) * fracCR.x;\n          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          let newValue = top + (bottom - top) * fracCR.y;\n          setOutputAtIndex(index, newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          let sourceNearestCR = vec2<i32>(floor(\n            sourceFracIndexCR + vec2<f32>(0.5,0.5)));\n          let newValue = getImage(\n            bInd, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutputAtIndex(index, newValue);\n        }\n      }\n    }\n    ")}}const l0={kernelName:Uh,backendName:"webgpu",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{image:s,boxes:r,boxInd:i}=t,{cropSize:o,method:c,extrapolationValue:l}=a,u=new c0(s.shape[3],r.shape,o,c),h=[{type:"float32",data:[l]}];return n.runWebGPUProgram(u,[s,r,i],"float32",h)}};var u0;!function(e){e.Prod="*",e.Sum="+"}(u0||(u0={}));class h0{constructor(e,t,n,a){this.variableNames=["x"],this.uniforms="index : f32,",this.size=!0,this.workgroupSize=[128,1,1],this.outputShape=t,this.dispatchLayout=QQ(this.outputShape),this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.exclusive=n,this.reverse=a,this.op=e,this.shaderKey="cum_".concat(this.op,"_").concat(this.exclusive,"_").concat(this.reverse)}getUserCode(){const e=this.outputShape.length,t=this.op===u0.Prod?"1.0":"0.0",n=this.exclusive?t:"getX(".concat(d0(e,"coords",this.op),")"),a=this.outputShape[this.outputShape.length-1];let s="",r="";return this.exclusive?(s=this.reverse?"end != ".concat(a-1):"end != 0",r=this.reverse?"end + 1":"end - 1"):(s=this.reverse?"end + pow2 < ".concat(a):"end >= pow2",r=this.reverse?"end + pow2":"end - pow2"),"\n      ".concat(LQ("index")," {\n       if (index < uniforms.size) {\n         var coords = getCoordsFromIndex(index);\n\n         let end = ").concat(p0(e,"coords",this.op),";\n         var val = ").concat(n,";\n         let pow2 = i32(pow(2.0, uniforms.index));\n         if (").concat(s,") {\n           let idx = ").concat(r,";\n           ").concat(p0(e,"coords",this.op)," = idx;\n           val ").concat(this.op,"= getX(").concat(d0(e,"coords",this.op),");\n         }\n         setOutputAtIndex(index, val);\n       }\n      }\n    ")}}function d0(e,t,n){if(1===e)return"".concat(t);if(2===e)return"".concat(t,".x, ").concat(t,".y");if(3===e)return"".concat(t,".x, ").concat(t,".y, ").concat(t,".z");if(4===e)return"".concat(t,".x, ").concat(t,".y, ").concat(t,".z, ").concat(t,".w");throw Error("Cumulative ".concat(n," for rank ").concat(e," is not yet supported"))}function p0(e,t,n){if(1===e)return"".concat(t);if(2===e)return"".concat(t,".y");if(3===e)return"".concat(t,".z");if(4===e)return"".concat(t,".w");throw Error("Cumulative ".concat(n," for rank ").concat(e," is not yet supported"))}function f0(e,t,n,a,s,r){const i=t.shape.length,o=ev([a],i);let c=t;null!=o&&(c=AJ({inputs:{x:t},backend:n,attrs:{perm:o}}));const l=nv(1,i)[0];if(l!==i-1)throw new Error("WebGPU cumprod shader expects an inner-most axis=".concat(t.shape.length-1," ")+"but got axis=".concat(a));const u=c.shape[l];let h=_Z({inputs:{x:c},backend:n});for(let d=0;d<=Math.ceil(Math.log2(u))-1;d++){const t=new h0(e,c.shape,!1,r),a=h,s=[{type:"float32",data:[d]}];h=n.runWebGPUProgram(t,[h],h.dtype,s),n.disposeData(a.dataId)}if(s){const t=new h0(e,c.shape,s,r),a=h,i=[{type:"float32",data:[0]}];h=n.runWebGPUProgram(t,[h],h.dtype,i),n.disposeData(a.dataId)}if(null!=o){const e=AJ({inputs:{x:h},backend:n,attrs:{perm:tv(o)}});return n.disposeData(h.dataId),n.disposeData(c.dataId),e}return h}const m0={kernelName:Wh,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{axis:r,exclusive:i,reverse:o}=a;return f0(u0.Prod,s,n,r,i,o)}};const g0={kernelName:Vh,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{axis:r,exclusive:i,reverse:o}=a;return f0(u0.Sum,s,n,r,i,o)}};const y0={kernelName:Hh,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,weights:r}=t,{size:i,binaryOutput:o}=a,c=1===s.shape.length,l=vu(r.shape)>0,u=r.dtype,h=c?[s.shape[0]]:[s.shape[0],s.shape[1]],d=kZ({backend:n,attrs:{shape:c?[i]:[s.shape[0],i],value:0,dtype:u}}),p=new b$(h,l,o),f=[{type:"int32",data:[i]}],m=l?[s,r]:[s];return n.runWebGPUProgram(p,m,u,f,d)}};class b0{constructor(e,t){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.uniforms="blockSize : i32,",this.outputShape=e,this.dispatchLayout=QQ(this.outputShape),this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthToSpace_".concat(t),this.dataFormat=t}getUserCode(){return"\n      ".concat(LQ("index")," {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let b = coords[0];\n          let h = ").concat(this.getHeightCoordString(),";\n          let w = ").concat(this.getWidthCoordString(),";\n          let d = ").concat(this.getDepthCoordString(),";\n\n          let in_h = h / uniforms.blockSize;\n          let offset_h = h % uniforms.blockSize;\n          let in_w = w / uniforms.blockSize;\n          let offset_w = w % uniforms.blockSize;\n          let offset_d = (offset_h * uniforms.blockSize + offset_w) *\n            ").concat(this.getOutputDepthSize(),";\n          let in_d = d + offset_d;\n\n          let rlt = ").concat(this.getInputSamplingString(),";\n          setOutputAtIndex(index, rlt);\n        }\n      }")}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?"uniforms.outShape[3]":"uniforms.outShape[1]"}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const x0={kernelName:Gh,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{blockSize:r,dataFormat:i}=a,o=s.shape[0],c=("NHWC"===i?s.shape[1]:s.shape[2])*r,l=("NHWC"===i?s.shape[2]:s.shape[3])*r,u=("NHWC"===i?s.shape[3]:s.shape[1])/(r*r),h=[{type:"int32",data:[r]}],d=new b0("NHWC"===i?[o,c,l,u]:[o,u,c,l],i);return n.runWebGPUProgram(d,[s],s.dtype,h)}};class v0{constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,r=arguments.length>5&&void 0!==arguments[5]&&arguments[5];this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>,",this.workgroupSize=[16,16,1],this.outputShape=e,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize),a&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.addBias=a,this.activation=s,this.hasPreluActivation=r,this.filterHeight=t,this.filterWidth=n,this.shaderKey="depthwiseNCHW_".concat(this.activation,"_").concat(this.filterHeight,"_").concat(this.filterWidth)}getUserCode(){const e=this.filterWidth*this.filterHeight,t=this.workgroupSize[0]*this.workgroupSize[1]*this.workgroupSize[2],n=this.workgroupSize[1]+this.filterHeight-1,a=this.workgroupSize[0]+this.filterWidth-1;return"\n      ".concat(lZ(this.activation,this.hasPreluActivation,!1,4),"\n\n      var<workgroup> mm_Asub : array<array<f32, ").concat(a,">, ").concat(n,">;\n      var<workgroup> mm_Bsub : array<array<f32, ").concat(this.filterWidth,">, ").concat(this.filterHeight,">;\n      fn readX(batch : i32, channel : i32, row : i32, col : i32) -> f32 {\n        var value = 0.0;\n        if (row >=0 && row < uniforms.inDims[0] && col >=0 && col < uniforms.inDims[1])\n        {\n          value = getX(batch, channel, row, col);\n        }\n        return value;\n      }\n\n      ").concat(LQ()," {\n        let coords = getOutputCoords();\n        let batch = coords[0];\n        let xRCCorner = vec2<i32>(coords.zw) - uniforms.pads;\n        let channelMul = uniforms.wShape[3];\n        let d1 = coords[1] / channelMul;\n        let q = coords[1] % channelMul;\n\n        let inputRowStart = xRCCorner.x;\n        let inputColStart = xRCCorner.y;\n\n        let localRow = i32(localId.y);\n        let localCol = i32(localId.x);\n\n        // Load one tile of X into local memory.\n        for (var inputRow = localRow; inputRow < ").concat(n,"; inputRow = inputRow + ").concat(this.workgroupSize[1],") {\n          for (var inputCol = localCol; inputCol < ").concat(a,"; inputCol = inputCol + ").concat(this.workgroupSize[0],") {\n            let rowOffset = inputRow - localRow;\n            let colOffset = inputCol - localCol;\n            mm_Asub[inputRow][inputCol] = readX(batch, d1, inputRowStart + rowOffset, inputColStart + colOffset);\n          }\n        }\n\n        // Load one tile of W into local memory.\n        var wIndex = i32(localIndex);\n        ").concat(e<t?"if (wIndex < ".concat(e,")"):"for(; wIndex < ".concat(e,"; wIndex = wIndex + ").concat(t,")"),"\n\n        {\n          let wRow = wIndex / ").concat(this.filterWidth,";\n          let wCol = wIndex % ").concat(this.filterWidth,";\n          mm_Bsub[wRow][wCol] = getW(wRow, wCol, d1, q);\n        }\n\n        workgroupBarrier();\n\n        var value = 0.0;\n        for (var wR = 0; wR < ").concat(this.filterHeight,"; wR = wR + 1) {\n          for (var wC = 0; wC < ").concat(this.filterWidth,"; wC = wC + 1) {\n            let xVal = mm_Asub[localRow + wR][localCol + wC];\n            let wVal = mm_Bsub[wR][wC];\n            value = fma(xVal, wVal, value);\n          }\n        }\n        ").concat(uZ(this.addBias,this.activation),"\n        if (coordsInBounds4D(coords, uniforms.outShape)) {\n          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n        }\n      }\n    ")}}class w0{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>, virtualWidth : i32,",this.workgroupSize=[64,1,1],this.workPerThread=4,this.outputComponent=4,this.outputShape=e.outShape,this.virtualWidth=Math.ceil(this.outputShape[2]/this.workPerThread)*this.workPerThread;const s=[this.outputShape[0],this.outputShape[1],this.virtualWidth,this.outputShape[3]];this.dispatchLayout=QQ(s),this.dispatch=KQ(this.dispatchLayout,s,this.workgroupSize,[this.outputComponent*this.workPerThread,1,1]),yu("channelsLast"===e.dataFormat,()=>"TODO: NCHW is unimplemented"),t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=n,this.hasPreluActivation=a,this.shaderKey="depthwiseVec4_".concat(n,"_").concat(this.convInfo.filterHeight,"_").concat(this.convInfo.filterWidth,"_").concat(this.convInfo.strideHeight,"_").concat(this.convInfo.strideWidth,"_").concat(this.workPerThread)}getUserCode(){const e=(this.workPerThread-1)*this.convInfo.strideWidth+this.convInfo.filterWidth,t=this.convInfo.strideHeight,n=this.convInfo.strideWidth;return"\n      ".concat(lZ(this.activation,this.hasPreluActivation,!0,4),"\n      fn readX(batch : i32, row : i32, col : i32, channel : i32) -> vec4<f32> {\n        var value = vec4<f32>(0.0);\n        if (col >=0 && col < uniforms.inDims[1]) {\n          value = getX(batch, row, col, channel);\n        }\n        return value;\n      }\n\n      ").concat(LQ("index")," {\n        let width0 = uniforms.outShape[3] / ").concat(this.outputComponent,";\n        let d1 = (index % width0) * ").concat(this.outputComponent,";\n        var index1 = index / width0;\n        let width1 = uniforms.virtualWidth / ").concat(this.workPerThread,";\n        let c = (index1 % width1) * ").concat(this.workPerThread,";\n        index1 = index1 / width1;\n        let r = index1 % uniforms.outShape[1];\n        let batch = index1 / uniforms.outShape[1];\n\n        let xRCCorner = vec2<i32>(r, c) * vec2<i32>(").concat(t,", ").concat(n,") - uniforms.pads;\n\n        let xRCorner = xRCCorner.x;\n        let xCCorner = xRCCorner.y;\n        var xVals : array<vec4<f32>, ").concat(e,">;\n        var dotProd : array<vec4<f32>, ").concat(this.workPerThread,">;\n        for (var i = 0; i < ").concat(this.workPerThread,"; i++) {\n          dotProd[i] = vec4<f32>(0.0);\n        }\n\n        // Use constant instead of uniform can give better performance.\n        for (var wR = 0; wR < ").concat(this.convInfo.filterHeight,"; wR = wR + 1) {\n          let xR = xRCorner + wR;\n          if (xR >=0 && xR < uniforms.inDims[0]) {\n            for (var i = 0; i < ").concat(e,"; i++) {\n              xVals[i] = readX(batch, xR, xCCorner + i, d1);\n            }\n            for (var wC = 0; wC < ").concat(this.convInfo.filterWidth,"; wC = wC + 1) {\n              let wValue = getW(wR, wC, d1, 0);\n              for (var i = 0; i < ").concat(this.workPerThread,"; i++) {\n                dotProd[i] = fma(xVals[i * ").concat(n," + wC], wValue, dotProd[i]);\n              }\n            }\n          }\n        }\n\n        for (var i = 0; i < ").concat(this.workPerThread,"; i = i + 1) {\n          let coords = vec4<i32>(batch, r, c + i, d1);\n          if (coordsInBounds4D(coords, uniforms.outShape)) {\n            var value = dotProd[i];\n            ").concat(uZ(this.addBias,this.activation),"\n            setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n          }\n        }\n      }\n    ")}}class k0{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>, filterHeight : i32,\n      filterWidth : i32, strides : vec2<i32>, dilations : vec2<i32>,",this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=QQ(this.outputShape),this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast="channelsLast"===e.dataFormat,t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=n,this.hasPreluActivation=a,this.shaderKey="depthwise_".concat(this.activation,"_").concat(this.isChannelsLast)}getUserCode(){const e=this.isChannelsLast?"getX(batch, xR, xC, d1);":"getX(batch, d1, xR, xC);";return"\n      ".concat(lZ(this.activation,this.hasPreluActivation,!1,4),"\n\n      ").concat(LQ("index")," {\n        if (index < uniforms.size) {\n          let coords = getOutputCoords();\n          let batch = coords[0];\n          let xRCCorner = vec2<i32>(coords.").concat(this.isChannelsLast?"yz":"zw",") * uniforms.strides - uniforms.pads;\n          let d2 = coords[").concat(this.isChannelsLast?3:1,"];\n          let channelMul = uniforms.wShape[3];\n          let d1 = d2 / channelMul;\n          let q = d2 % channelMul;\n\n          let inputRowStart = xRCCorner.x;\n          let inputColStart = xRCCorner.y;\n          let inputRowEnd = inputRowStart + uniforms.filterHeight *\n              uniforms.dilations[0];\n          let inputColEnd = inputColStart + uniforms.filterWidth *\n              uniforms.dilations[1];\n\n          // Convolve x(?, ?, d1)|x(d1, ?, ?) with w(:, :, d1, q) to get\n          // y(yR, yC, d2)|y(d2, yR, yC). ? = to be determined. : = across all\n          // values in that axis. x(?, ?, d1) and y(yR, yC, d2) is for NHWC.\n          // x(d1, ?, ?) and y(d2, yR, yC) is for NCHW.\n          var value = 0.0;\n\n          // Extract if checking out of for loop for performance.\n          if (inputRowStart >= 0 && inputColStart >= 0 &&\n            inputRowEnd < uniforms.inDims[0] &&\n                inputColEnd < uniforms.inDims[1]) {\n              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {\n                let xR = inputRowStart + wR * uniforms.dilations[0];\n\n                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {\n                  let xC = inputColStart + wC * uniforms.dilations[1];\n\n                  let xVal = ").concat(e,";\n                  let wVal = getW(wR, wC, d1, q);\n                  value = value + xVal * wVal;\n                }\n              }\n            } else {\n              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {\n                let xR = inputRowStart + wR * uniforms.dilations[0];\n\n                if (xR < 0 || xR >= uniforms.inDims[0]) {\n                  continue;\n                }\n\n                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {\n                  let xC = inputColStart + wC * uniforms.dilations[1];\n\n                  if (xC < 0 || xC >= uniforms.inDims[1]) {\n                    continue;\n                  }\n\n                  let xVal = ").concat(e,";\n                  let wVal = getW(wR, wC, d1, q);\n                  value = value + xVal * wVal;\n                }\n              }\n            }\n            ").concat(uZ(this.addBias,this.activation),"\n          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n        }\n      }\n    ")}}const S0={kernelName:qh,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,filter:r}=t,{strides:i,pad:o,dataFormat:c,dilations:l,dimRoundingMode:u}=a,h=$b(c);let d=l;null==d&&(d=[1,1]);const p=Ub(s.shape,r.shape,i,d,o,u,!0,h),f=[{type:"int32",data:[p.padInfo.top,p.padInfo.left]},{type:"int32",data:[p.inHeight,p.inWidth]}],m="channelsLast"===p.dataFormat;let g;return!m&&p.inHeight>16&&p.inWidth>16&&1===p.strideHeight&&1===p.strideWidth&&1===p.dilationWidth&&1===p.dilationHeight&&p.inChannels===p.outChannels?g=new v0(p.outShape,p.filterHeight,p.filterWidth):m&&p.outHeight>4&&p.outWidth>4&&p.strideWidth<=2&&p.inChannels===p.outChannels&&1===p.dilationHeight&&1===p.dilationWidth&&p.inChannels%4===0?(g=new w0(p),f.push({type:"int32",data:[g.virtualWidth]})):(g=new k0(p),f.push({type:"int32",data:[p.filterHeight]},{type:"int32",data:[p.filterWidth]},{type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.dilationHeight,p.dilationWidth]})),n.runWebGPUProgram(g,[s,r],s.dtype,f)}};class C0{constructor(e){this.variableNames=["x","dy"],this.uniforms="strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>, outHeight : i32,\n      outWidth : i32, inHeight : i32, inWidth : i32, batchSize : i32, channelMul : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=QQ(this.outputShape),this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthwise_conv2d_backprop_filter"}getUserCode(){return"\n      ".concat(LQ("index")," {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let wR = coords[0];\n        let wC = coords[1];\n        let d1 = coords[2];\n        let dm = coords[3];\n        let d2 = d1 * uniforms.channelMul + dm;\n\n        var dotProd = 0.0;\n        for (var b = 0; b < uniforms.batchSize; b++) {\n          for (var yR = 0; yR < uniforms.outHeight; yR++) {\n            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];\n\n            if (xR < 0 || xR >= uniforms.inHeight) {\n              continue;\n            }\n\n            for (var yC = 0; yC < uniforms.outWidth; yC++) {\n              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];\n\n              if (xC < 0 || xC >= uniforms.inWidth) {\n                continue;\n              }\n\n              let dyValue = getDy(b, yR, yC, d2);\n              let xValue = getX(b, xR, xC, d1);\n              dotProd += xValue * dyValue;\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n    ")}}class I0{constructor(e){this.variableNames=["dy","W"],this.uniforms="strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>,\n       outHeight : i32, outWidth : i32, channelMul : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=QQ(this.outputShape),this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthwise_conv2d_backprop_input"}getUserCode(){return"\n      ".concat(LQ("index")," {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords[0];\n        let d1 = coords[3];\n        let dyCorner = coords.yz - uniforms.pads;\n        let dyRCorner = dyCorner.x;\n        let dyCCorner = dyCorner.y;\n\n        var dotProd = 0.0;\n        for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {\n          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);\n\n          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {\n            continue;\n          }\n\n          let idyR = i32(dyR);\n          let wRPerm = uniforms.filterDims[0] - 1 - wR;\n\n          for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {\n            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);\n\n            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {\n              continue;\n            }\n\n            let idyC = i32(dyC);\n            let wCPerm = uniforms.filterDims[1] - 1 - wC;\n\n            for (var dm = 0; dm < uniforms.channelMul; dm++) {\n              let d2 = d1 * uniforms.channelMul + dm;\n              let xValue = getDy(batch, idyR, idyC, d2);\n              let wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n    ")}}const N0={kernelName:Kh,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,dy:r}=t,{strides:i,dilations:o,pad:c,dimRoundingMode:l,filterShape:u}=a,h=Ub(s.shape,u,i,o,c,l,!0),d=new C0(h),p=[{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.filterHeight,h.filterWidth]},{type:"int32",data:[h.outHeight]},{type:"int32",data:[h.outWidth]},{type:"int32",data:[h.inHeight]},{type:"int32",data:[h.inWidth]},{type:"int32",data:[h.batchSize]},{type:"int32",data:[h.outChannels/h.inChannels]}];return n.runWebGPUProgram(d,[s,r],"float32",p)}};const T0={kernelName:Xh,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:s,filter:r}=t,{strides:i,dilations:o,pad:c,dimRoundingMode:l,inputShape:u}=a,h=Ub(u,r.shape,i,o,c,l,!0),d=new I0(h),p=[{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.filterHeight-1-h.padInfo.top,h.filterWidth-1-h.padInfo.left]},{type:"int32",data:[h.filterHeight,h.filterWidth]},{type:"int32",data:[h.outHeight]},{type:"int32",data:[h.outWidth]},{type:"int32",data:[h.outChannels/h.inChannels]}];return n.runWebGPUProgram(d,[s,r],s.dtype,p)}};class E0{constructor(e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,e],this.dispatchLayout=QQ(this.outputShape),this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="diag"}getUserCode(){return"\n      ".concat(LQ("index")," {\n        if (index < uniforms.size) {\n          let coords = getOutputCoords();\n          let value = select(0.0, getX(coords[0]), coords[0] == coords[1]);\n          setOutputAtIndex(index, value);\n        }\n      }\n    ")}}const R0={kernelName:Yh,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t,s=[...a.shape,...a.shape],r=vu(a.shape),i=CZ({inputs:{x:a},backend:n,attrs:{shape:[r]}}),o=new E0(r),c=n.runWebGPUProgram(o,[i],i.dtype),l=CZ({inputs:{x:c},backend:n,attrs:{shape:s}});return n.disposeData(i.dataId),n.disposeData(c.dataId),l}};class _0{constructor(e){this.variableNames=["x","w"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=QQ(this.outputShape),this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="dilation2d"}getUserCode(){return"\n       ".concat(LQ("index")," {\n         if (index < uniforms.size) {\n           let neg_infinity = -3.4e38;\n           let coords = getOutputCoords();\n           let batch = coords.x;\n           let d1 = coords.w;\n           let outTopLeftCorner = coords.yz * uniforms.strides - uniforms.pads;\n           let hBeg = outTopLeftCorner.x;\n           let wBeg = outTopLeftCorner.y;\n\n           var curVal = neg_infinity;\n           for (var h = 0; h < uniforms.filterDims[0]; h = h + 1) {\n             let hIn = hBeg + h * uniforms.dilations[0];\n\n             if (hIn >= 0 && hIn < uniforms.xShape[1]) {\n               for (var w = 0; w < uniforms.filterDims[1]; w = w + 1) {\n                 let wIn = wBeg + w * uniforms.dilations[1];\n\n                 if (wIn >= 0 && wIn < uniforms.xShape[2]) {\n                   let val = getX(batch, hIn, wIn, d1) + getW(h, w, d1);\n                   if (val > curVal) {\n                     curVal = val;\n                   }\n                 }\n               }\n             }\n           }\n\n           setOutputAtIndex(index, curVal);\n         }\n       }\n     ")}}const A0={kernelName:Qh,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,filter:r}=t,{strides:i,pad:o,dilations:c}=a,l=jb(s.shape,r.shape,i,o,"NHWC",c),u=[l.padInfo.top,l.padInfo.left],h=[{type:"int32",data:[l.filterHeight,l.filterWidth]},{type:"int32",data:[...u]},{type:"int32",data:[l.strideHeight,l.strideWidth]},{type:"int32",data:[l.dilationHeight,l.dilationWidth]}],d=new _0(l);return n.runWebGPUProgram(d,[s,r],s.dtype,h)}};class M0{constructor(e,t){if(this.variableNames=["x","w","dy"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e.inShape,this.dispatchLayout=QQ(e.outShape),this.dispatch=KQ(this.dispatchLayout,e.outShape,this.workgroupSize),"float32"!==t&&"int32"!==t)throw new Error("Dilation2DBackpropInput only supports float32 and int32\n          types, does not support ".concat(t," type."));this.type=t,this.shaderKey="dilation2DBackpropInput"}getUserCode(){return"\n       ".concat(LQ("index")," {\n         if (index < uniforms.dySize) {\n           let coords = getDyCoordsFromIndex(index);\n           let b = coords[0];\n           let r = coords[1];\n           let c = coords[2];\n           let d = coords[3];\n\n           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;\n           var curVal = -3.4e38;  // neg_infinity\n           var xRMax = 0;\n           var xCMax = 0;\n\n           // In the case of multiple argmax branches, we only back-propagate\n           // along the last branch, i.e., the one with largest value of\n           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling\n           // backward routines.\n           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {\n             let xR = dyCorner.x + wR * uniforms.dilations[0];\n\n             if (xR >= 0 && xR < uniforms.xShape[1]) {\n               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {\n                 let xC = dyCorner.y + wC * uniforms.dilations[1];\n\n                 if (xC >= 0 && xC < uniforms.xShape[2]) {\n                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);\n                   if (val > curVal) {\n                     curVal = val;\n                     xRMax = xR;\n                     xCMax = xC;\n                   }\n                 }\n               }\n             }\n           }\n\n           let flatIndexIn = d + uniforms.xShape[3] *\n               (xCMax + uniforms.xShape[2] * (xRMax + uniforms.xShape[1] * b));\n           let value = getDy(b, r, c, d);\n           ").concat(AQ("&result[flatIndexIn]","value",this.type),"\n         }\n       }\n     ")}}class P0{constructor(e,t,n){if(this.variableNames=["x","w","dy"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e.filterShape,this.dispatchLayout=QQ(e.outShape),this.dispatch=KQ(this.dispatchLayout,e.outShape,this.workgroupSize),"float32"!==n&&"int32"!==n)throw new Error("Dilation2DBackpropFilter only supports float32 and int32\n          types, does not support ".concat(n," type."));this.type=n,this.shaderKey="dilation2DBackpropFilter"}getUserCode(){return"\n       ".concat(LQ("index")," {\n         if (index < uniforms.dySize) {\n           let coords = getDyCoordsFromIndex(index);\n           let b = coords[0];\n           let r = coords[1];\n           let c = coords[2];\n           let d = coords[3];\n\n           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;\n           var curVal = -3.4e38;  // neg_infinity\n           var wRMax = 0;\n           var wCMax = 0;\n\n           // In the case of multiple argmax branches, we only back-propagate\n           // along the last branch, i.e., the one with largest value of\n           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling\n           // backward routines.\n           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {\n             let xR = dyCorner.x + wR * uniforms.dilations[0];\n\n             if (xR >= 0 && xR < uniforms.xShape[1]) {\n               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {\n                 let xC = dyCorner.y + wC * uniforms.dilations[1];\n\n                 if (xC >= 0 && xC < uniforms.xShape[2]) {\n                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);\n                   if (val > curVal) {\n                     curVal = val;\n                     wRMax = wR;\n                     wCMax = wC;\n                   }\n                 }\n               }\n             }\n           }\n\n           let flatIndexIn = d + uniforms.wShape[2] * (wCMax + wRMax * uniforms.wShape[1]);\n           let value = getDy(b, r, c, d);\n           ").concat(AQ("&result[flatIndexIn]","value",this.type),"\n         }\n       }\n     ")}}const D0={kernelName:Jh,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,filter:r,dy:i}=t,{strides:o,pad:c,dilations:l}=a,u=jb(s.shape,r.shape,o,c,"NHWC",l),h=r.dtype,d=new P0(u,r.shape,h),p=[{type:"int32",data:[u.filterHeight,u.filterWidth]},{type:"int32",data:[u.padInfo.top,u.padInfo.left]},{type:"int32",data:[u.strideHeight,u.strideWidth]},{type:"int32",data:[u.dilationHeight,u.dilationWidth]},{type:"int32",data:[vu(u.outShape)]}],f=kZ({backend:n,attrs:{shape:r.shape,value:0,dtype:h}});return n.runWebGPUProgram(d,[s,r,i],h,p,f)}};const O0={kernelName:Zh,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,filter:r,dy:i}=t,{strides:o,pad:c,dilations:l}=a,u=jb(s.shape,r.shape,o,c,"NHWC",l),h=s.dtype,d=new M0(u,h),p=[{type:"int32",data:[u.filterHeight,u.filterWidth]},{type:"int32",data:[u.padInfo.top,u.padInfo.left]},{type:"int32",data:[u.strideHeight,u.strideWidth]},{type:"int32",data:[u.dilationHeight,u.dilationWidth]},{type:"int32",data:[vu(u.outShape)]}],f=kZ({backend:n,attrs:{shape:u.inShape,value:0,dtype:h}});return n.runWebGPUProgram(d,[s,r,i],h,p,f)}};class F0{constructor(e,t,n){this.variableNames=["Image"],this.uniforms="alpha: f32,",this.workgroupSize=[64,1,1],this.pixelsOpType=MQ.DRAW,this.size=!0,this.outputShape=e,this.dispatchLayout=QQ(this.outputShape),this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.type=t,this.textureFormat=n,this.shaderKey="draw_".concat(t,"_").concat(n)}getUserCode(){let e;const t="float32"===this.type?"value":"value / 255.0";e="\n      if (uniforms.numChannels == 1) {\n        rgba[0] = ".concat(t,";\n        rgba[1] = ").concat(t,";\n        rgba[2] = ").concat(t,";\n      } else {\n        rgba[d] = ").concat(t,";\n      }");return"\n       @group(0) @binding(0) var outImage : texture_storage_2d<".concat(this.textureFormat,", write>;\n       ").concat(LQ("index")," {\n         if (index < uniforms.size) {\n           var rgba = vec4<f32>(0.0, 0.0, 0.0, uniforms.alpha);\n           for (var d = 0; d < uniforms.numChannels; d = d + 1) {\n             let value = f32(inBuf[index * uniforms.numChannels + d]);\n             ").concat(e,"\n           }\n           rgba.x = rgba.x * rgba.w;\n           rgba.y = rgba.y * rgba.w;\n           rgba.z = rgba.z * rgba.w;\n           let coords = getCoordsFromIndex(index);\n           textureStore(outImage, vec2<i32>(coords.yx), rgba);\n         }\n       }\n      ")}}const L0={kernelName:$h,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{image:s}=t,{canvas:r,options:i}=a,[o,c]=s.shape.slice(0,2),{imageOptions:l}=i||{},u=(null===l||void 0===l?void 0:l.alpha)||1,h=n.device.features.has("bgra8unorm-storage")?"bgra8unorm":"rgba8unorm",d=[o,c],p=new F0(d,s.dtype,h);r.width=c,r.height=o;const f="webgpu";let m,g=r.getContext(f);g||(m=new OffscreenCanvas(c,o),g=m.getContext(f));const y=3===s.shape.length?s.shape[2]:1;g.configure({device:n.device,format:h,usage:GPUTextureUsage.STORAGE_BINDING,alphaMode:"premultiplied"});const b="int32",x=n.makeTensorInfo(d,b),v=n.tensorMap.get(x.dataId);v.resource=g.getCurrentTexture(),v.external=!0;const w=[{type:"uint32",data:[y]},{type:"float32",data:[u]}];if(n.runWebGPUProgram(p,[s],b,w,x),m){const e=r.getContext("2d");if(!e)throw new Error("Please make sure this canvas has only been used for 2d or webgpu context!");e.drawImage(m,0,0)}return n.disposeData(x.dataId),s}},z0=FZ({opType:aZ.MUL,cpuKernelImpl:nJ,supportsComplex:!0}),B0={kernelName:Yd,backendName:"webgpu",kernelFunc:z0};function j0(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{axis:r,keepDims:i}=a;return OJ(s,r,i,"sum",n)}const W0={kernelName:Fp,backendName:"webgpu",kernelFunc:j0};const V0={kernelName:td,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{equation:s}=a,r=t,{allDims:i,summedDims:o,idDims:c}=PC(s,r.length);OC(i.length,c,r);const{path:l,steps:u}=FC(o,c),h=u.length;let d=null,p=i.length;const f=[];for(let m=0;m<h;++m){for(const e of u[m]){const{permutationIndices:t,expandDims:a}=DC(p,c[e]);let s;LC(t)?s=r[e]:(s=AJ({inputs:{x:r[e]},backend:n,attrs:{perm:t}}),f.push(s));const i=s.shape.slice();for(let e=0;e<a.length;++e)i.splice(a[e],0,1);ku(s.shape,i)||(s=CZ({inputs:{x:s},backend:n,attrs:{shape:i}}),f.push(s)),null===d?d=s:(d=z0({inputs:{a:s,b:d},backend:n}),f.push(d))}m<h-1&&(l[m]>=0&&(d=j0({inputs:{x:d},backend:n,attrs:{axis:l[m]-(i.length-p),keepDims:!1}}),f.push(d)),p--)}for(const m of f)m!==d&&n.disposeData(m.dataId);return d}},U0=OZ({opType:rZ.ELU}),H0={kernelName:nd,backendName:"webgpu",kernelFunc:U0},G0={kernelName:ad,backendName:"webgpu",kernelFunc:e=>{const{inputs:t,backend:n}=e,{dy:a,y:s}=t,r=new RZ(aZ.ELU_DER,a.shape,s.shape);return n.runWebGPUProgram(r,[a,s],a.dtype)}},q0=FZ({opType:aZ.EQUAL,dtype:"bool",cpuKernelImpl:WZ}),K0={kernelName:rd,backendName:"webgpu",kernelFunc:q0},X0=OZ({opType:rZ.ERF}),Y0={kernelName:sd,backendName:"webgpu",kernelFunc:X0},Q0=OZ({opType:rZ.EXP,cpuKernelImpl:VZ,dtype:"float32"}),Z0={kernelName:id,backendName:"webgpu",kernelFunc:Q0};function J0(e){const{inputs:t,attrs:n,backend:a}=e,{dim:s}=n,{input:r}=t,i=r.shape.length,o=r.shape.slice();let c=s;return s<0&&(yu(-(i+1)<=s,()=>"Axis must be in the interval [".concat(-(i+1),", ").concat(i,"]")),c=i+s+1),o.splice(c,0,1),CZ({inputs:{x:r},backend:a,attrs:{shape:o}})}const $0={kernelName:od,backendName:"webgpu",kernelFunc:J0},e1=OZ({opType:rZ.EXPM1,cpuKernelImpl:UZ}),t1={kernelName:cd,backendName:"webgpu",kernelFunc:e1};class n1{constructor(e,t){this.variableNames=["real","imag"],this.outputShape=[],this.uniforms="exponentMultiplier : f32, denominator: f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=QQ(this.outputShape),this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.component=e,this.shaderKey="fft_".concat(e)}getUserCode(){const e="real"===this.component?"return real * expR - imag * expI;":"return real * expI + imag * expR;";return"\n    fn unaryOpComplex(real: f32, expR: f32, imag: f32, expI: f32) -> f32 {\n      ".concat(e,"\n    }\n\n    fn mulMatDFT(batch: i32, index: i32) -> f32 {\n      let indexRatio = f32(index) / f32(uniforms.realShape[1]);\n      let exponentMultiplierTimesIndexRatio =\n          uniforms.exponentMultiplier * indexRatio;\n\n      var result = 0.0;\n\n      for (var i = 0; i < uniforms.realShape[1]; i = i + 1) {\n        // x = (-2|2 * PI / N) * index * i;\n        let x = exponentMultiplierTimesIndexRatio * f32(i);\n        let expR = cos(x);\n        let expI = sin(x);\n        let real = getReal(batch, i);\n        let imag = getImag(batch, i);\n\n        result = result +\n            unaryOpComplex(real, expR, imag, expI) / uniforms.denominator;\n      }\n\n      return result;\n    }\n\n    ").concat(LQ("index")," {\n      if (index < uniforms.size) {\n        let coords = getOutputCoords();\n        setOutputAtIndex(index, mulMatDFT(coords[0], coords[1]));\n      }\n    }\n  ")}}function a1(e,t,n){const a=n.tensorMap.get(e.dataId),s=vu(e.shape),r=e.shape[e.shape.length-1],i=[],o=CZ({inputs:{x:e},backend:n,attrs:{shape:[s/r,r]}});i.push(o);const c=o.shape,l=new n1("real",c),u=new n1("imag",c),h=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:c},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:c}],d=[{type:"float32",data:[t?2*Math.PI:-2*Math.PI]},{type:"float32",data:[t?c[1]:1]}],p=n.runWebGPUProgram(l,h,"float32",d);i.push(p);const f=n.runWebGPUProgram(u,h,"float32",d);i.push(f);const m=MZ({inputs:{real:p,imag:f},backend:n});i.push(m);const g=CZ({inputs:{x:m},backend:n,attrs:{shape:e.shape}});return i.forEach(e=>n.disposeData(e.dataId)),g}const s1={kernelName:ld,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:a}=t;return a1(a,!1,n)}};class r1{constructor(e){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=QQ(this.outputShape),this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="flipLeftRight"}getUserCode(){return"\n      ".concat(LQ("index")," {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let coordX = uniforms.xShape[2] - coords[2] - 1;\n          let outputValue = getX(coords[0], coords[1], coordX, coords[3]);\n          setOutputAtIndex(index, outputValue);\n        }\n      }\n    ")}}const i1={kernelName:hd,backendName:"webgpu",kernelFunc:e=>{let{inputs:t,backend:n}=e;const{image:a}=t,s=n,r=new r1(a.shape);return s.runWebGPUProgram(r,[a],a.dtype)}},o1=OZ({opType:rZ.FLOOR,cpuKernelImpl:HZ}),c1={kernelName:dd,backendName:"webgpu",kernelFunc:o1},l1=FZ({opType:aZ.FLOOR_DIV,cpuKernelImpl:GZ,dtype:"int32"}),u1={kernelName:pd,backendName:"webgpu",kernelFunc:l1};class h1{constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];this.pixelsOpType=MQ.FROM_PIXELS,this.outputShape=[0],this.variableNames=[],this.workgroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout=QQ(this.outputShape),this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize,[t,1,1]),this.importVideo=n,this.shaderKey="fromPixels_".concat(this.importVideo)}getUserCode(){const e=this.importVideo?"textureLoad(src, vec2<i32>(coords.yx));":"textureLoad(src, vec2<i32>(coords.yx), 0)",t=this.importVideo?"texture_external":"texture_2d<f32>";return"\n      @binding(1) @group(0) var src: ".concat(t,";\n      ").concat(LQ("index")," {\n        let flatIndex = index * uniforms.numChannels;\n        if (flatIndex < uniforms.size) {\n          let coords = getCoordsFromIndex(flatIndex);\n          let values = ").concat(e,";\n          for (var i = 0; i < uniforms.numChannels; i = i + 1) {\n            result[flatIndex + i] = i32(floor(255.0 * values[i]));\n          }\n        }\n      }\n  ")}}const d1={kernelName:hf,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e;let{pixels:s}=t;const{numChannels:r}=a;if(null==s)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");const i="undefined"!==typeof HTMLVideoElement&&s instanceof HTMLVideoElement,o="undefined"!==typeof HTMLImageElement&&s instanceof HTMLImageElement,c="undefined"!==typeof HTMLCanvasElement&&s instanceof HTMLCanvasElement||"undefined"!==typeof OffscreenCanvas&&s instanceof OffscreenCanvas,l="undefined"!==typeof ImageBitmap&&s instanceof ImageBitmap,[u,h]=i?[s.videoWidth,s.videoHeight]:[s.width,s.height],d=[h,u,r],p=$u().getBool("WEBGPU_IMPORT_EXTERNAL_TEXTURE")&&i,f=i||o;if(l||c||f){let e;if(p)e=n.device.importExternalTexture({source:s});else{if(f){const e=$u().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");null!=p1&&e===f1||(f1=e,p1=document.createElement("canvas").getContext("2d",{willReadFrequently:f1})),p1.canvas.width=u,p1.canvas.height=h,p1.drawImage(s,0,0,u,h),s=p1.canvas}const t=GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,a="rgba8unorm",r=n.textureManager.acquireTexture(d[1],d[0],a,t);n.queue.copyExternalImageToTexture({source:s},{texture:r},[d[1],d[0]]),e=r}const t=vu(d),a=Bu(d),i=new h1(d,r,p),o=[{type:"uint32",data:[t]},{type:"uint32",data:[r]},{type:"uint32",data:[...a]}],c=n.makeTensorInfo([h,u],"int32");n.tensorMap.get(c.dataId).resource=e;const l=n.runWebGPUProgram(i,[c],"int32",o);return n.disposeData(c.dataId),l}const m=s.data;let g=m;if(null!=r&&4!==r){g=new Uint8Array(s.width*s.height*r);const e=m.length;let t=0;for(let n=0;n<e;n++)n%4<r&&(g[t++]=m[n])}const y=n.makeTensorInfo(d,"int32",new Int32Array(g));return n.uploadToGPU(y.dataId),y}};let p1,f1=$u().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");class m1{constructor(e,t,n,a,s){this.uniforms="varianceEpsilon : f32,",this.workgroupSize=[128,1,1],this.size=!0,this.variableNames=["x","mean","variance"],Ry(e,t),Ry(e,n),this.outputShape=e,this.dispatchLayout=QQ(this.outputShape),this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize),null!=a&&(Ry(e,a),this.variableNames.push("offset")),null!=s&&(Ry(e,s),this.variableNames.push("scale")),this.offsetShape=a,this.scaleShape=s,this.shaderKey="batchNorm"}getUserCode(){let e="0.0";null!=this.offsetShape&&(e="getOffsetByOutputIndex(index)");let t="1.0";null!=this.scaleShape&&(t="getScaleByOutputIndex(index)");return"\n      ".concat(LQ("index")," {\n        if (index < uniforms.size)\n        {\n          let xValue = getXByOutputIndex(index);\n          let meanValue = getMeanByOutputIndex(index);\n          let varianValue = getVarianceByOutputIndex(index);\n          let offsetValue = ").concat(e,";\n          let scaleValue = ").concat(t,";\n          let inv = scaleValue * inverseSqrt(varianValue + f32(uniforms.varianceEpsilon));\n          setOutputAtIndex(index,dot(vec3<f32>(xValue, -meanValue, offsetValue), vec3<f32>(inv, inv, 1.0)));\n        }\n      }\n  ")}}const g1={kernelName:fd,backendName:"webgpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e;const{x:s,scale:r,offset:i,mean:o,variance:c}=t,{varianceEpsilon:l}=n,u=a,h=[s,o,c];let d=null;null!=i&&(d=i.shape,h.push(i));let p=null;null!=r&&(p=r.shape,h.push(r));const f=new m1(s.shape,o.shape,c.shape,d,p),m=[{type:"float32",data:[l]}];return u.runWebGPUProgram(f,h,s.dtype,m)}};const y1={kernelName:ff,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,filter:r,bias:i,preluActivationWeights:o}=t,{strides:c,pad:l,dataFormat:u,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=a,m=$b(u);return G$({x:s,filter:r,convInfo:Ub(s.shape,r.shape,c,h,l,d,!1,m),backend:n,bias:i,preluActivationWeights:o,leakyreluAlpha:f,activation:p})}};const b1={kernelName:mf,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,filter:r,bias:i,preluActivationWeights:o}=t,{strides:c,pad:l,dilations:u,dimRoundingMode:h,activation:d,leakyreluAlpha:p}=a;let f=u;null==f&&(f=[1,1]),yu(Zb(c,f),()=>"Error in depthwiseConv2d: Either strides or dilations must be "+"1. Got strides ".concat(c," and dilations '").concat(f,"'"));const m=Ub(s.shape,r.shape,c,f,l,h,!0),g=[s,r],y=null!=i,b=null!=o;y&&g.push(i),b&&g.push(o);const x=[{type:"int32",data:[m.padInfo.top,m.padInfo.left]},{type:"int32",data:[m.inHeight,m.inWidth]}];let v;return m.outHeight>4&&m.outWidth>4&&m.strideWidth<=2&&m.inChannels===m.outChannels&&1===m.dilationHeight&&1===m.dilationWidth&&m.inChannels%4===0?(v=new w0(m,y,d,b),x.push({type:"int32",data:[v.virtualWidth]})):(v=new k0(m,y,d,b),x.push({type:"int32",data:[m.filterHeight]},{type:"int32",data:[m.filterWidth]},{type:"int32",data:[m.strideHeight,m.strideWidth]},{type:"int32",data:[m.dilationHeight,m.dilationWidth]})),"leakyrelu"===d&&(x.push({type:"float32",data:[p]}),v.uniforms+=" alpha : f32,"),n.runWebGPUProgram(v,g,"float32",x)}};class x1{constructor(e,t){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=QQ(this.outputShape),this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="gathernd_".concat(e),this.sliceDim=e,this.uniforms="sliceDim : i32, strides : ".concat(OQ(e),",")}getUserCode(){let e;e=this.sliceDim>1?"uniforms.strides[j]":"uniforms.strides";return"\n      ".concat(LQ("index")," {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          var flattenIndex = 0;\n          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {\n            let indexTemp = i32(round(getIndices(coords[0], j)));\n            let strideNum = ").concat(e,";\n            flattenIndex = flattenIndex + indexTemp * strideNum;\n          }\n\n          setOutputAtIndex(index, getA(flattenIndex, coords[1]));\n        }\n      }\n      ")}}const v1={kernelName:gd,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:a,indices:s}=t,r=s.shape,i=r[r.length-1],o=vu(a.shape),[c,l,u,h]=dC(a,s),d=CZ({inputs:{x:s},backend:n,attrs:{shape:[l,i]}}),p=CZ({inputs:{x:a},backend:n,attrs:{shape:[vu(a.shape)/u,u]}});if(n.shouldExecuteOnCPU([a,s])||"string"===a.dtype){const e=n.readSync(s.dataId),t=n.bufferSync(a),r=qZ(e,t,a.dtype,l,i,u,h,a.shape,o);return n.makeTensorInfo(c,a.dtype,r.values)}const f=new x1(i,[l,u]),m=[{type:"int32",data:[i]},{type:"int32",data:h}],g=n.runWebGPUProgram(f,[p,d],p.dtype,m),y=CZ({inputs:{x:g},backend:n,attrs:{shape:c}});return n.disposeData(d.dataId),n.disposeData(p.dataId),n.disposeData(g.dataId),y}};class w1{constructor(e,t){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.slice(),this.aShape=e,this.outputShape=t,this.dispatchLayout=QQ(this.outputShape),this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="gather"}getUserCode(){const e=function(e){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let a=0;a<e.length;a++)2===a?n.push("indexZ"):n.push("".concat(t[a]));return n.join()}(this.aShape);return"\n      ".concat(LQ("index")," {\n        if (index < uniforms.size) {\n          let resRC = getCoordsFromIndex(index);\n          let indexZ = i32(getIndices(resRC.x, resRC.z));\n          let inBounds = select(0.0, 1.0, indexZ >= 0 && indexZ < uniforms.aShape[2]);\n          setOutputAtIndex(index, inBounds * getA(").concat(e,"));\n        }\n      }\n    ")}}function k1(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,indices:r}=t,{axis:i,batchDims:o}=a,c=eI(s,r,Eu(i,s.shape)[0],o),l=vu(r.shape),u=[],h=CZ({inputs:{x:s},backend:n,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),d=CZ({inputs:{x:r},backend:n,attrs:{shape:[c.batchSize,l/c.batchSize]}});u.push(h),u.push(d);const p=[c.batchSize,c.outerSize,l/c.batchSize,c.sliceSize];if(n.shouldExecuteOnCPU([s,r])){const e=n.tensorMap.get(d.dataId).values,t=ty(d.shape,d.dtype,e),a=n.tensorMap.get(h.dataId).values,s=ty(h.shape,h.dtype,a),r=KZ(s,t,p);return u.forEach(e=>n.disposeData(e.dataId)),n.makeTensorInfo(c.outputShape,r.dtype,r.values)}const f=new w1(h.shape,p),m=n.runWebGPUProgram(f,[h,d],h.dtype);u.push(m);const g=CZ({inputs:{x:m},backend:n,attrs:{shape:c.outputShape}});return u.forEach(e=>n.disposeData(e.dataId)),g}const S1={kernelName:md,backendName:"webgpu",kernelFunc:k1},C1=FZ({opType:aZ.GREATER,cpuKernelImpl:YZ,dtype:"bool"}),I1={kernelName:yd,backendName:"webgpu",kernelFunc:C1},N1=FZ({opType:aZ.GREATER_EQUAL,dtype:"bool",cpuKernelImpl:XZ}),T1={kernelName:bd,backendName:"webgpu",kernelFunc:N1};const E1={kernelName:vd,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:a}=t;return a1(a,!0,n)}},R1=OZ({opType:rZ.IS_FINITE,dtype:"bool"}),_1={kernelName:kd,backendName:"webgpu",kernelFunc:R1},A1=OZ({opType:rZ.IS_INF,dtype:"bool"}),M1={kernelName:Sd,backendName:"webgpu",kernelFunc:A1},P1=OZ({opType:rZ.IS_NAN,dtype:"bool"}),D1={kernelName:Cd,backendName:"webgpu",kernelFunc:P1};const O1={kernelName:Id,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{alpha:r}=a,i=[{type:"float32",data:[r]}],o=new DZ(s.shape,rZ.LEAKYRELU,"alpha : f32,");return n.runWebGPUProgram(o,[s],"float32",i)}},F1=FZ({opType:aZ.LESS,dtype:"bool",cpuKernelImpl:ZZ}),L1={kernelName:Nd,backendName:"webgpu",kernelFunc:F1},z1=FZ({opType:aZ.LESS_EQUAL,dtype:"bool",cpuKernelImpl:QZ}),B1={kernelName:Td,backendName:"webgpu",kernelFunc:z1};class j1{constructor(e){this.variableNames=[],this.outputShape=[],this.uniforms="start : f32, step : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e],this.dispatchLayout=QQ(this.outputShape),this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="linSpace"}getUserCode(){return"\n      ".concat(LQ("index")," {\n        if (index < uniforms.size) {\n          setOutputAtIndex(index, uniforms.start + f32(index) * uniforms.step);\n        }\n      }\n    ")}}const W1={kernelName:Ed,backendName:"webgpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:a,stop:s,num:r}=n,i=(s-a)/(r-1),o=new j1(r),c=[{type:"float32",data:[a]},{type:"float32",data:[i]}];return t.runWebGPUProgram(o,[],"float32",c)}},V1=OZ({opType:rZ.LOG,cpuKernelImpl:JZ}),U1={kernelName:Rd,backendName:"webgpu",kernelFunc:V1},H1=OZ({opType:rZ.LOG1P}),G1={kernelName:_d,backendName:"webgpu",kernelFunc:H1},q1=FZ({opType:aZ.LOGICAL_AND,dtype:"bool"}),K1={kernelName:Ad,backendName:"webgpu",kernelFunc:q1},X1=OZ({opType:rZ.LOGICAL_NOT}),Y1={kernelName:Md,backendName:"webgpu",kernelFunc:X1},Q1=FZ({opType:aZ.LOGICAL_OR}),Z1={kernelName:Pd,backendName:"webgpu",kernelFunc:Q1},J1="\n  var powValue = 0.0;\n  let basis = uniforms.bias + uniforms.alpha * sum;\n  if (uniforms.beta == 0.5) {\n    powValue = inverseSqrt(basis);\n  } else if (uniforms.beta == 1.0) {\n    powValue = 1.0 / basis;\n  } else {\n    powValue = exp(log(basis) * (-uniforms.beta));\n  }\n";class $1{constructor(e){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=QQ(this.outputShape),this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn"}getUserCode(){return"\n    ".concat(LQ("index")," {\n      if (index < uniforms.size) {\n        let coords = getOutputCoords();\n        let b = coords[0];\n        let r = coords[1];\n        let c = coords[2];\n        let d = coords[3];\n\n        let x = getX(b, r, c, d);\n        var sum = 0.0;\n        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {\n          let idx = d + i;\n          if (idx >= 0 && idx < uniforms.xShape[3]) {\n            let z = getX(b, r, c, idx);\n            sum = sum + z * z;\n          }\n        }\n        ").concat(J1,"\n\n        setOutputAtIndex(index, x * powValue);\n      }\n    }\n  ")}}class e2{constructor(e,t){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[256,1,1],this.maxAllowRadius=16,yu(t<=this.maxAllowRadius,()=>"Radius must be less than or equal to ".concat(this.maxAllowRadius,", current radius is ").concat(t)),this.outputShape=e,this.elementsPerWorkgroup=this.workgroupSize[0]-2*this.maxAllowRadius,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=KQ(this.dispatchLayout,this.outputShape,[this.elementsPerWorkgroup,this.workgroupSize[1],this.workgroupSize[2]]),this.shaderKey="lrn_shared"}getUserCode(){return"\n    var <workgroup>lrnSub: array<f32, ".concat(this.workgroupSize[0],">;\n    const elementsPerWorkgroup = ").concat(this.elementsPerWorkgroup,";\n    const maxAllowRadius = ").concat(this.maxAllowRadius,";\n\n    ").concat(LQ()," {\n      let localDepth = i32(localId.x);\n      let workgroupDepth = i32(workgroupId.x) * elementsPerWorkgroup;\n      let xDepth = workgroupDepth + localDepth - maxAllowRadius;\n      let b = i32(globalId.z) / uniforms.xShape[1];\n      let r = i32(globalId.z) - b * uniforms.xShape[1];\n      let c = i32(globalId.y);\n      let d = workgroupDepth + localDepth;\n\n      var x = 0.0;\n      if (xDepth >= 0 && xDepth < uniforms.xShape[3]) {\n        x = getX(b, r, c, xDepth);\n      }\n      lrnSub[localDepth] = x;\n      workgroupBarrier();\n\n      if (localDepth < elementsPerWorkgroup && d < uniforms.outShape[3]) {\n        var sum = 0.0;\n        let index = localDepth + maxAllowRadius;\n        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {\n          let z = lrnSub[index + i];\n          sum = sum + z * z;\n        }\n        ").concat(J1,"\n\n        setOutputAtCoords(b, r, c, d, lrnSub[index] * powValue);\n      }\n    } ")}}const t2={kernelName:Dd,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{depthRadius:r,bias:i,alpha:o,beta:c}=a;let l;l=r>16?new $1(s.shape):new e2(s.shape,r);const u=[{type:"int32",data:[r]},{type:"float32",data:[i]},{type:"float32",data:[o]},{type:"float32",data:[c]}];return n.runWebGPUProgram(l,[s],s.dtype,u)}};class n2{constructor(e){this.outputShape=[],this.variableNames=["inputImage","outputImage","dy"],this.uniforms="depthRadius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=QQ(this.outputShape),this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn_grad"}getUserCode(){return"\n    ".concat(LQ("index")," {\n      if (index < uniforms.size) {\n        let coords = getOutputCoords();\n        let b = coords[0];\n        let r = coords[1];\n        let c = coords[2];\n\n        let MIN_DEPTH_BEGIN = 0;\n        let MAX_DEPTH_END = uniforms.outShape[3];\n        var result = 0.0;\n        for (var d = MIN_DEPTH_BEGIN; d < MAX_DEPTH_END; d++) {\n          let depthBegin = max(MIN_DEPTH_BEGIN, d - uniforms.depthRadius);\n          let depthEnd = min(MAX_DEPTH_END, d + uniforms.depthRadius + 1);\n\n          var norm = 0.0;\n          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {\n            if (k < depthBegin) {\n              continue;\n            } else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            } else {\n              break;\n            }\n          }\n\n          norm = uniforms.alpha * norm + uniforms.bias;\n\n          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {\n            if (k < depthBegin) {\n              continue;\n            } else if (k >= depthBegin && k < depthEnd) {\n              var dyi = -2.0 * uniforms.alpha * uniforms.beta\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d) / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * uniforms.beta);\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            } else {\n              break;\n            }\n          }\n        }\n\n        setOutputAtIndex(index, result);\n      }\n    }\n  ")}}const a2={kernelName:Od,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,y:r,dy:i}=t,{depthRadius:o,bias:c,alpha:l,beta:u}=a,h=new n2(s.shape),d=[{type:"int32",data:[o]},{type:"float32",data:[c]},{type:"float32",data:[l]},{type:"float32",data:[u]}];return n.runWebGPUProgram(h,[s,r,i],s.dtype,d)}},s2=FZ({opType:aZ.MAX,cpuKernelImpl:eJ}),r2={kernelName:Ld,backendName:"webgpu",kernelFunc:s2};const i2={kernelName:zd,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{filterSize:r,strides:i,pad:o,dimRoundingMode:c}=a;return s$(s,Wb(s.shape,r,i,1,o,c),"max",n)}};const o2={kernelName:jd,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{filterSize:r,strides:i,pad:o,dataFormat:c,dimRoundingMode:l}=a,u=Vb(s.shape,r,i,[1,1,1],o,l,c),h=new $J(u,"max"),d=[{type:"int32",data:[u.strideDepth,u.strideHeight,u.strideWidth]},{type:"int32",data:[u.padInfo.front,u.padInfo.top,u.padInfo.left]},{type:"int32",data:[u.inDepth,u.inHeight,u.inWidth]},{type:"int32",data:[u.effectiveFilterDepth,u.effectiveFilterHeight,u.effectiveFilterWidth]}];return n.runWebGPUProgram(h,[s],s.dtype,d)}};class c2{constructor(e){this.variableNames=["dy","maxPos"],this.uniforms="strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,\n       outHeight : i32, outWidth : i32",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=QQ(this.outputShape),this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="maxPool2DBackprop"}getUserCode(){return"\n      ".concat(LQ("index")," {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords[0];\n        let d = coords[3];\n\n        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;\n        let dyRCorner = dyRCCorner.x;\n        let dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] - 1;\n        for (var wR = 0; wR < uniforms.filterDims[0]; wR += uniforms.dilations[0]) {\n          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);\n\n          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {\n            continue;\n          }\n          let idyR = i32(dyR);\n\n          for (var wC = 0; wC < uniforms.filterDims[1]; wC += uniforms.dilations[1]) {\n            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);\n\n            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {\n              continue;\n            }\n            let idyC = i32(dyC);\n\n            let dyValue = getDy(batch, idyR, idyC, d);\n            let maxPosValue = lastIndex - i32(getMaxPos(batch, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            let curPosValue = wR * uniforms.filterDims[1] + wC;\n            let mask = select(0.0, 1.0, maxPosValue == curPosValue);\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n    ")}}class l2{constructor(e){this.variableNames=["dy","maxPos"],this.uniforms="strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,\n      outDepth : i32, outHeight : i32, outWidth : i32",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=QQ(this.outputShape),this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="maxPool3DBackprop"}getUserCode(){return"\n      ".concat(LQ("index")," {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords.x;\n        let ch = coords.u;\n\n        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;\n        let dyDCorner = dyCorner.x;\n        let dyRCorner = dyCorner.y;\n        let dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] * uniforms.filterDims[2] - 1;\n\n        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {\n          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);\n\n          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {\n            continue;\n          }\n          let idyD = i32(dyD);\n\n          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {\n            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);\n\n            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {\n              continue;\n            }\n            let idyR = i32(dyR);\n\n            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {\n              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);\n\n              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {\n                continue;\n              }\n              let idyC = i32(dyC);\n\n              let dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              let maxPosValue = lastIndex - i32(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              let curPosValue = wD * uniforms.filterDims[1] * uniforms.filterDims[2] + wR * uniforms.filterDims[2] + wC;\n              let mask = select(0.0, 1.0, maxPosValue == curPosValue);\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n    ")}}const u2={kernelName:Wd,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:s,input:r}=t,i=r,{filterSize:o,strides:c,pad:l,dimRoundingMode:u}=a,h=Vb(i.shape,o,c,[1,1,1],l,u),d=new $J(h,"max",!0);let p=[{type:"int32",data:[h.strideDepth,h.strideHeight,h.strideWidth]},{type:"int32",data:[h.padInfo.front,h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.inDepth,h.inHeight,h.inWidth]},{type:"int32",data:[h.effectiveFilterDepth,h.effectiveFilterHeight,h.effectiveFilterWidth]}];const f=n.runWebGPUProgram(d,[i],"int32",p),m=new l2(h);p=[{type:"int32",data:[h.strideDepth,h.strideHeight,h.strideWidth]},{type:"int32",data:[h.effectiveFilterDepth-1-h.padInfo.front,h.effectiveFilterHeight-1-h.padInfo.top,h.effectiveFilterWidth-1-h.padInfo.left]},{type:"int32",data:[h.effectiveFilterDepth,h.effectiveFilterHeight,h.effectiveFilterWidth]},{type:"int32",data:[h.outDepth]},{type:"int32",data:[h.outHeight]},{type:"int32",data:[h.outWidth]}];const g=n.runWebGPUProgram(m,[s,f],i.dtype,p);return n.disposeData(f.dataId),g}};const h2={kernelName:Bd,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:s,input:r,output:i}=t,o=r;$Q([r,i],"maxPoolGrad");const{filterSize:c,strides:l,pad:u,dimRoundingMode:h}=a,d=Wb(o.shape,c,l,1,u,h),p=new JJ(d,"max",!0);let f=[{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]},{type:"int32",data:[d.inHeight,d.inWidth]},{type:"int32",data:[d.effectiveFilterHeight,d.effectiveFilterWidth]}];const m=n.runWebGPUProgram(p,[o],"int32",f),g=new c2(d);f=[{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.effectiveFilterHeight-1-d.padInfo.top,d.effectiveFilterWidth-1-d.padInfo.left]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]},{type:"int32",data:[d.effectiveFilterHeight,d.effectiveFilterWidth]},{type:"int32",data:[d.outHeight]},{type:"int32",data:[d.outWidth]}];const y=n.runWebGPUProgram(g,[s,m],o.dtype,f);return n.disposeData(m.dataId),y}};const d2={kernelName:Vd,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{filterSize:s,strides:r,pad:i,includeBatchInIndex:o}=a,{x:c}=t;yu(4===c.shape.length,()=>"Error in maxPool: input must be rank 4 but got rank ".concat(c.shape.length,"."));const l=[1,1];yu(Zb(r,l),()=>"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(r," and dilations '").concat(l,"'"));const u=Wb(c.shape,s,r,l,i),h=[{type:"int32",data:[u.strideHeight,u.strideWidth]},{type:"int32",data:[u.padInfo.top,u.padInfo.left]},{type:"int32",data:[u.dilationHeight,u.dilationWidth]},{type:"int32",data:[u.inHeight,u.inWidth]},{type:"int32",data:[u.effectiveFilterHeight,u.effectiveFilterWidth]}];let d=new JJ(u,"max",!1);const p=n.runWebGPUProgram(d,[c],c.dtype,h);return d=new JJ(u,"max",!0,!0,o),[p,n.runWebGPUProgram(d,[c],"int32",h)]}};const p2={kernelName:Hd,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{axis:r,keepDims:i}=a;return OJ(s,r,i,"min",n)}},f2=FZ({opType:aZ.MIN,cpuKernelImpl:tJ}),m2={kernelName:Gd,backendName:"webgpu",kernelFunc:f2};class g2{constructor(e,t,n){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.map((t,n)=>t[0]+e[n]+t[1]),this.dispatchLayout=QQ(this.outputShape),this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=e,t.map((e,t)=>{this.uniforms+=" pad".concat(t," : vec2<i32>,")}),this.offset="reflect"===n?0:1,this.shaderKey="mirrorPad_".concat(n)}getUserCode(){const e=this.xShape.length,t=this.xShape.map((e,t)=>"uniforms.pad".concat(t,"[0]")).join(","),n=this.xShape.map((t,n)=>"uniforms.pad".concat(n,"[0] + uniforms.xShape").concat(e>1?"[".concat(n,"]"):"")).join(","),a=1===e?"start":"start[i]",s=1===e?"end":"end[i]",r=1===e?"outC":"outC[i]",i=OQ(e),o=e>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e):"coords";return"\n      ".concat(LQ("index")," {\n        if (index < uniforms.size) {\n          let start = ").concat(i,"(").concat(t,");\n          let end = ").concat(i,"(").concat(n,");\n          var outC = getCoordsFromIndex(index);\n          for (var i = 0; i < ").concat(e,"; i = i + 1) {\n            if (").concat(r," < ").concat(a,") {\n              ").concat(r," = ").concat(a," * 2 - ").concat(r," - ").concat(this.offset,";\n            } else if(").concat(r," >= ").concat(s,") {\n              ").concat(r," = (").concat(s," - 1) * 2 - ").concat(r," + ").concat(this.offset,";\n            }\n          }\n          let coords = outC - start;\n          setOutputAtIndex(index, getX(").concat(o,"));\n        }\n      }\n    ")}}const y2={kernelName:qd,backendName:"webgpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e;const{x:s}=t,{paddings:r,mode:i}=n,o=a,c=r.map(e=>({type:"int32",data:[e[0],e[1]]})),l=new g2(s.shape,r,i);return o.runWebGPUProgram(l,[s],s.dtype,c)}},b2=FZ({opType:aZ.MOD}),x2={kernelName:Kd,backendName:"webgpu",kernelFunc:b2};class v2{constructor(e,t){this.variableNames=["probs"],this.outputShape=[],this.uniforms="seed : f32, numOutcomes: i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,t],this.dispatchLayout=QQ(this.outputShape),this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="multinomial"}getUserCode(){return"\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    fn random (seed : f32, resultUV : vec2<f32>) -> f32 {\n      let HASHSCALE1 = 443.8975;\n      let p = resultUV * seed;\n      var p3  = fract(vec3<f32>(p.xyx) * HASHSCALE1);\n      p3 = p3 + dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ".concat(LQ("index")," {\n      if (index < uniforms.size) {\n        let coords = getOutputCoords();\n        let batch = coords[0];\n\n        let resUV = vec2<f32>(f32(coords[1]) / f32(uniforms.outShape[1]),\n            f32(coords[0]) / f32(uniforms.outShape[0]));\n        let r = random(uniforms.seed, resUV);\n        var cdf = 0.0;\n        for (var i = 0; i < uniforms.numOutcomes - 1; i = i + 1) {\n          cdf = cdf + getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutputAtIndexI32(index, i);\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutputAtIndexI32(index, uniforms.numOutcomes - 1);\n      }\n    }\n  ")}}class w2{constructor(e){this.variableNames=["logits"],this.outputShape=e,this.dispatchLayout=QQ(this.outputShape),this.dispatch=[this.outputShape[0],1,1],this.outputShape[1]>=4096?this.workgroupSize=[256,1,1]:this.workgroupSize=[64,1,1],this.shaderKey="softmax"}getUserCode(){return"\n    var<workgroup> buf : array<f32, ".concat(this.workgroupSize[0],">;\n    var<workgroup> rowMaxShared : f32;\n    var<workgroup> rowSumShared : f32;\n    const blockSize = ").concat(this.workgroupSize[0],";\n    ").concat(LQ("index")," {\n      let row = index / blockSize;\n      let tid = i32(localId.x);\n      let cols = uniforms.outShape[1];\n\n      var threadMax = -3.402823e+38f;\n      for (var col = tid; col < cols; col += blockSize) {\n        let value = getLogits(row, col);\n        threadMax = max(threadMax, value);\n      }\n      if (tid < cols) {\n        buf[tid] = threadMax;\n      }\n      workgroupBarrier();\n\n      var reduceSize = min(cols, blockSize);\n      for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {\n        reduceSize = currSize + (reduceSize & 1);\n        if (tid < currSize) {\n          buf[tid] = max(buf[tid], buf[tid + reduceSize]);\n        }\n        workgroupBarrier();\n      }\n\n      if (tid == 0) {\n        rowMaxShared = buf[0];\n      }\n      workgroupBarrier();\n\n      var threadSum = 0.0;\n      for (var col = tid; col < cols; col += blockSize) {\n        let subExp = exp(getLogits(row, col) - rowMaxShared);\n        threadSum += subExp;\n      }\n      buf[tid] = threadSum;\n      workgroupBarrier();\n\n      for (var currSize = blockSize >> 1;  currSize > 0; currSize = currSize >> 1) {\n        if (tid < currSize) {\n          buf[tid] = buf[tid] + buf[tid + currSize];\n        }\n        workgroupBarrier();\n      }\n\n      if (tid == 0) {\n        rowSumShared = buf[0];\n      }\n      workgroupBarrier();\n\n      for (var col = tid; col < cols; col += blockSize) {\n        let value = exp(getLogits(row, col) - rowMaxShared) / rowSumShared;\n        setOutputAtCoords(row, col, value);\n      }\n  }\n    ")}}function k2(e){const{inputs:t,backend:n,attrs:a}=e,{logits:s}=t,{dim:r}=a,i=CZ({inputs:{x:s},backend:n,attrs:{shape:[vu(s.shape)/s.shape[r],s.shape[r]]}}),o=new w2(i.shape),c=n.runWebGPUProgram(o,[i],s.dtype),l=CZ({inputs:{x:c},backend:n,attrs:{shape:s.shape}});return n.disposeData(i.dataId),n.disposeData(c.dataId),l}const S2={kernelName:Bp,backendName:"webgpu",kernelFunc:k2};const C2={kernelName:Xd,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{logits:s}=t,{numSamples:r,seed:i,normalized:o}=a,c=o?s:k2({inputs:{logits:s},backend:n,attrs:{dim:s.shape.length-1}}),l=c.shape[0],u=c.shape[1],h=new v2(l,r),d=[{type:"float32",data:[i]},{type:"int32",data:[u]}],p=n.runWebGPUProgram(h,[c],"int32",d);return o||n.disposeData(c.dataId),p}};const I2={kernelName:Qd,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t;if(n.shouldExecuteOnCPU([a])){const e=n.tensorMap.get(a.dataId),[t,s]=aJ(e.values,a.shape,a.dtype);return n.makeTensorInfo(s,a.dtype,t)}const s=new DZ(a.shape,rZ.NEG);return n.runWebGPUProgram(s,[a],a.dtype)}};const N2={kernelName:Jd,backendName:"webgpu",kernelFunc:function(e){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:a}=e,{boxes:s,scores:r}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:c}=a,l=n.readSync(s.dataId),u=n.readSync(r.dataId),{selectedIndices:h}=aS(l,u,i,o,c);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}};const T2={kernelName:ep,backendName:"webgpu",kernelFunc:function(e){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:a}=e,{boxes:s,scores:r}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:c,softNmsSigma:l}=a,u=n.readSync(s.dataId),h=n.readSync(r.dataId),d=i,p=o,f=c,m=l,{selectedIndices:g,selectedScores:y}=rS(u,h,d,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}};class E2{constructor(e,t){this.variableNames=["x"],this.uniforms="onValue : f32, offValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,t],this.dispatchLayout=QQ(this.outputShape),this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="onehot"}getUserCode(){return"\n      ".concat(LQ("index")," {\n        if(index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          setOutputAtIndex(index, mix(uniforms.offValue, uniforms.onValue,\n                                      f32(i32(round(getX(coords.x))) == coords.y)));\n        }\n      }\n    ")}}const R2={kernelName:np,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{indices:s}=t,{dtype:r,depth:i,onValue:o,offValue:c}=a,l=vu(s.shape),u=new E2(l,i),h=CZ({inputs:{x:s},backend:n,attrs:{shape:[l]}}),d=[{type:"float32",data:[o]},{type:"float32",data:[c]}],p=n.runWebGPUProgram(u,[h],r,d);n.disposeData(h.dataId);const f=CZ({inputs:{x:p},backend:n,attrs:{shape:[...s.shape,i]}});return n.disposeData(p.dataId),f}};function _2(e){const{inputs:t,backend:n}=e,{x:a}=t;if("complex64"===a.dtype){const e=C$({inputs:{input:a},backend:n}),t=_2({inputs:{x:e},backend:n}),s=F$({inputs:{input:a},backend:n}),r=_2({inputs:{x:s},backend:n}),i=MZ({inputs:{real:t,imag:r},backend:n});return n.disposeData(e.dataId),n.disposeData(t.dataId),n.disposeData(s.dataId),n.disposeData(r.dataId),i}return kZ({attrs:{shape:a.shape,dtype:a.dtype,value:"string"===a.dtype?"":0},backend:n})}const A2={kernelName:lf,backendName:"webgpu",kernelFunc:_2};const M2={kernelName:tp,backendName:"webgpu",kernelFunc:function e(t){const{inputs:n,backend:a}=t,{x:s}=n;if("string"===s.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===s.dtype){const t=C$({inputs:{input:s},backend:a}),n=e({inputs:{x:t},backend:a}),r=F$({inputs:{input:s},backend:a}),i=_2({inputs:{x:r},backend:a}),o=MZ({inputs:{real:n,imag:i},backend:a});return a.disposeData(t.dataId),a.disposeData(n.dataId),a.disposeData(r.dataId),a.disposeData(i.dataId),o}return kZ({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:a})}};const P2={kernelName:ap,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{axis:s}=a;if(1===t.length)return J0({inputs:{input:t[0]},backend:n,attrs:{dim:s}});const r=t[0].shape,i=t[0].dtype;t.forEach(e=>{bu(r,e.shape,"All tensors passed to stack must have matching shapes"),yu(i===e.dtype,()=>"All tensors passed to stack must have matching dtypes")});const o=[],c=B$({inputs:t.map(e=>{const t=J0({inputs:{input:e},backend:n,attrs:{dim:s}});return o.push(t),t}),backend:n,attrs:{axis:s}});return o.forEach(e=>n.disposeData(e.dataId)),c}};function D2(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const n=e.length,a=OQ(n),s=e.map((e,t)=>"uniforms.pad".concat(t,"[0]")).join(","),r=e.map((e,t)=>"uniforms.pad".concat(t,"[0] + uniforms.xShape").concat(n>1?"[".concat(t,"]"):"")).join(","),i=n>1?"".concat(a,"(").concat(s,")"):"".concat(s),o=n>1?"".concat(a,"(").concat(r,")"):"".concat(r),c=n>1?"any(paddedCoords < start)":"paddedCoords < start",l=n>1?"any(paddedCoords >= end)":"paddedCoords >= end",u=n>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,n):"coords";return"\n        let start = ".concat(i,";\n        let end = ").concat(o,";\n        if (").concat(c," || ").concat(l,") {\n          setOutputAtIndex(index, ").concat(t?0:"uniforms.constantValue",");\n        } else {\n          let coords = paddedCoords - start;\n          setOutputAtIndex(index, getX(").concat(u,"));\n        }\n  ")}class O2{constructor(e,t){this.variableNames=["x"],this.uniforms="constantValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.map((t,n)=>t[0]+e[n]+t[1]),this.dispatchLayout=QQ(this.outputShape),this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize),t.map((e,t)=>{this.uniforms+=" pad".concat(t," : vec2<i32>,")}),this.xShape=e,this.shaderKey="pad"}getUserCode(){return"\n      ".concat(LQ("index")," {\n        if (index < uniforms.size) {\n          let paddedCoords = getCoordsFromIndex(index);\n          ").concat(D2(this.xShape),"\n        }\n      }\n    ")}}const F2={kernelName:sp,backendName:"webgpu",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{paddings:r,constantValue:i}=a;if(r.every(e=>ku(e,[0,0])))return _Z({inputs:{x:s},backend:n});if(0===vu(s.shape)){const e=r.map((e,t)=>e[0]+s.shape[t]+e[1]);return kZ({backend:n,attrs:{shape:e,value:i,dtype:s.dtype}})}const o=[{type:"float32",data:[i]}];r.map(e=>o.push({type:"int32",data:[e[0],e[1]]}));const c=new O2(s.shape,r);return n.runWebGPUProgram(c,[s],s.dtype,o)}},L2=FZ({opType:aZ.POW}),z2={kernelName:rp,backendName:"webgpu",kernelFunc:L2};const B2={kernelName:ip,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a,alpha:s}=t,r=new RZ(aZ.PRELU,a.shape,s.shape);return n.runWebGPUProgram(r,[a,s],"float32")}};const j2={kernelName:op,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{axis:r,keepDims:i}=a;return OJ(s,r,i,"prod",n)}},W2={kernelName:hp,backendName:"webgpu",kernelFunc:e=>{const{backend:t,attrs:n}=e,{start:a,stop:s,step:r,dtype:i}=n,o=iJ(a,s,r,i);return t.makeTensorInfo([o.length],i,o)}},V2=FZ({opType:aZ.DIV}),U2={kernelName:ed,backendName:"webgpu",kernelFunc:V2},H2=OZ({opType:rZ.RECIPROCAL}),G2={kernelName:pp,backendName:"webgpu",kernelFunc:H2},q2=OZ({opType:rZ.RELU}),K2={kernelName:fp,backendName:"webgpu",kernelFunc:q2},X2=OZ({opType:rZ.RELU6}),Y2={kernelName:vp,backendName:"webgpu",kernelFunc:X2};class Q2{constructor(e,t,n){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, halfPixelCenters : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],t,n,e[3]],this.dispatchLayout=QQ(this.outputShape),this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="resizeBilinear"}getUserCode(){return"\n      ".concat(LQ("index")," {\n        if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n          let b = coords[0];\n          let d = coords[3];\n          let rc = coords.yz;\n\n          let effectiveInSize = vec2<f32>(\n            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveOutSize = vec2<f32>(\n            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveInputOverOutputRatioRC =\n              effectiveInSize / effectiveOutSize;\n\n          // Fractional source index\n          let sourceFracIndexRC =\n            (vec2<f32>(rc) + vec2<f32>(uniforms.halfPixelCenters)) *\n            effectiveInputOverOutputRatioRC - vec2<f32>(uniforms.halfPixelCenters);\n\n          // Compute the four integer indices.\n          let sourceFloorRC = vec2<i32>(sourceFracIndexRC);\n          let sourceCeilRC = vec2<i32>(\n            min(vec2<f32>(uniforms.xShape.yz) - vec2<f32>(1.0), ceil(sourceFracIndexRC)));\n\n          let topLeft = getX(b, sourceFloorRC.x, sourceFloorRC.y, d);\n          let bottomLeft = getX(b, sourceCeilRC.x, sourceFloorRC.y, d);\n          let topRight = getX(b, sourceFloorRC.x, sourceCeilRC.y, d);\n          let bottomRight = getX(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n          let fracRC = sourceFracIndexRC - vec2<f32>(sourceFloorRC);\n\n          let top = topLeft + (topRight - topLeft) * fracRC.y;\n          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n          let newValue = top + (bottom - top) * fracRC.x;\n\n          setOutputAtIndex(index, newValue);\n        }\n      }\n    ")}}const Z2={kernelName:bp,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:s}=t,{alignCorners:r,size:i,halfPixelCenters:o}=a,[c,l]=i,u=[{type:"float32",data:[r&&c>1?1:0,r&&l>1?1:0]},{type:"float32",data:[o?.5:0]}],h=new Q2(s.shape,c,l);return n.runWebGPUProgram(h,[s],"float32",u)}};class J2{constructor(e,t){this.variableNames=["dy"],this.uniforms="effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, heightScale : f32, widthScale : f32,\n       invHeightScale : f32, invWidthScale : f32, winHeight : i32, winWidth : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=QQ(this.outputShape),this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.alignCorners=t,this.shaderKey="resizeBilinearBackprop_".concat(t)}getUserCode(){return"\n      ".concat(LQ("index")," {\n        if (index < uniforms.size) {\n          let coords = getOutputCoords();\n          let b = coords[0];\n          let d = coords[3];\n          let r = coords[1];\n          let c = coords[2];\n\n          var accumulator = 0.0;\n\n          // Compute bounds for where in dy we will look\n          let startRLerp = floor(f32(r) * uniforms.invHeightScale);\n          let startDyR = i32(startRLerp - f32(uniforms.winHeight / 2));\n\n          let startCLerp = floor(f32(c) * uniforms.invWidthScale);\n          let startDyC = i32(startCLerp - f32(uniforms.winWidth / 2));\n\n          // Loop over dy\n          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {\n            let dyR = startDyR + dyROffset;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {\n              continue;\n            }\n\n            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {\n              let dyC = startDyC + dyCOffset;\n\n              // Guard against the window exceeding the bounds of dy\n              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {\n                continue;\n              }\n\n              let dxR = f32(dyR) * uniforms.heightScale;\n              let topDxRIndex = i32(floor(dxR));\n              let bottomDxRIndex = i32(min(ceil(dxR), f32(uniforms.outShape[1] - 1)));\n              let dxRLerp = dxR - f32(topDxRIndex);\n              let inverseDxRLerp = 1.0 - dxRLerp;\n\n              let dxC = f32(dyC) * uniforms.widthScale;\n              let leftDxCIndex = i32(floor(dxC));\n              let rightDxCIndex = i32(min(ceil(dxC), f32(uniforms.outShape[2] - 1)));\n              let dxCLerp = dxC - f32(leftDxCIndex);\n              let inverseDxCLerp = 1.0 - dxCLerp;\n\n              if (r == topDxRIndex && c == leftDxCIndex) {\n                // topLeft\n                accumulator +=\n                  getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n              }\n\n              if (r == topDxRIndex && c == rightDxCIndex) {\n                // topRight\n                accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n              }\n\n              if (r == bottomDxRIndex && c == leftDxCIndex) {\n                // bottomLeft\n                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n              }\n\n              if (r == bottomDxRIndex && c == rightDxCIndex) {\n                // bottomRight\n                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n              }\n            }\n          }\n          // End loop over dy\n\n          setOutputAtIndex(index, accumulator);\n        }\n      }\n    ")}}const $2={kernelName:xp,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:s,dy:r}=t,{alignCorners:i}=a,[,o,c]=s.shape,[,l,u]=r.shape,h=[i&&l>1?o-1:o,i&&u>1?c-1:c],d=[i&&l>1?l-1:l,i&&u>1?u-1:u],p=h[0]/d[0],f=h[1]/d[1],m=1/p,g=1/f,y=2*Math.ceil(m)+2,b=2*Math.ceil(g)+2,x=new J2(s.shape,i),v=[{type:"int32",data:h},{type:"int32",data:d},{type:"float32",data:[p]},{type:"float32",data:[f]},{type:"float32",data:[m]},{type:"float32",data:[g]},{type:"int32",data:[y]},{type:"int32",data:[b]}];return n.runWebGPUProgram(x,[r],r.dtype,v)}};class e3{constructor(e,t,n,a){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, roundBase : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],t,n,e[3]],this.dispatchLayout=QQ(this.outputShape),this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.halfPixelCenters=a,this.shaderKey="resizeNearest_".concat(a)}getUserCode(){let e;e=this.halfPixelCenters?"max((vec2<f32>(rc) + vec2<f32>(0.5)) * effectiveInputOverOutputRatioRC, vec2<f32>(0.0))":"vec2<f32>(rc) * effectiveInputOverOutputRatioRC";return"\n      ".concat(LQ("index")," {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let b = coords[0];\n          let d = coords[3];\n          let rc = coords.yz;\n\n          let effectiveInSize = vec2<f32>(\n            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveOutSize = vec2<f32>(\n            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveInputOverOutputRatioRC =\n              effectiveInSize / effectiveOutSize;\n\n          // Fractional source index\n          let sourceFracIndexRC = ").concat(e,";\n\n          // Compute the coordinators of nearest neighbor point.\n          let inputShapeRC = vec2<f32>(f32(uniforms.xShape.y), f32(uniforms.xShape.z));\n          let sourceNearestRC = vec2<i32>(\n            min(inputShapeRC - 1.0, floor(sourceFracIndexRC + uniforms.roundBase)));\n          let newValue = getX(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n          setOutputAtIndex(index, newValue);\n        }\n      }\n    ")}}const t3={kernelName:gp,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:s}=t,{alignCorners:r,halfPixelCenters:i,size:o}=a,[c,l]=o,u=[{type:"float32",data:[r&&c>1?1:0,r&&l>1?1:0]},{type:"float32",data:[r?.5:0]}],h=new e3(s.shape,c,l,i);return n.runWebGPUProgram(h,[s],s.dtype,u)}};class n3{constructor(e,t){this.variableNames=["dy"],this.uniforms="effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, invHeightScale : f32, invWidthScale : f32,\n       winHeight : i32, winWidth : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=QQ(this.outputShape),this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.alignCorners=t,this.shaderKey="resizeNearestNeigborBackprop_".concat(t)}getUserCode(){return"\n      ".concat(LQ("index")," {\n        if (index < uniforms.size) {\n          let coords = getOutputCoords();\n          let b = coords[0];\n          let d = coords[3];\n          let r = coords[1];\n          let c = coords[2];\n\n          var accumulator = 0.0;\n\n          // Compute bounds for where in dy we will look\n          let startRLerp = floor(f32(r) * uniforms.invHeightScale);\n          let startDyR = i32(floor(startRLerp - f32(uniforms.winHeight / 2)));\n\n          let startCLerp = floor(f32(c) * uniforms.invWidthScale);\n          let startDyC = i32(floor(startCLerp - f32(uniforms.winWidth / 2)));\n\n          // Loop over dy\n          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {\n            let dyR = startDyR + dyROffset;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {\n              continue;\n            }\n\n            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {\n              let dyC = startDyC + dyCOffset;\n\n              // Guard against the window exceeding the bounds of dy\n              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {\n                continue;\n              }\n\n              let sourceFracRow = f32(uniforms.effectiveXSize[0]) *\n                  (f32(dyR) / f32(uniforms.effectiveYSize[0]));\n\n              let sourceFracCol = f32(uniforms.effectiveXSize[1]) *\n                  (f32(dyC) / f32(uniforms.effectiveYSize[1]));\n\n              let sourceNearestRow =\n                  i32(min(f32(uniforms.outShape[1] - 1),\n                  ").concat(this.alignCorners?"floor(sourceFracRow + 0.5)":"floor(sourceFracRow)","));\n\n              let sourceNearestCol =\n                  i32(min(f32(uniforms.outShape[2] - 1),\n                  ").concat(this.alignCorners?"floor(sourceFracCol + 0.5)":"floor(sourceFracCol)","));\n\n              if (r == sourceNearestRow && c == sourceNearestCol) {\n                accumulator += getDy(b, dyR, dyC, d);\n              }\n            }\n          }\n          // End loop over dy\n\n          setOutputAtIndex(index, accumulator);\n        }\n      }\n    ")}}const a3={kernelName:yp,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:s,dy:r}=t,{alignCorners:i}=a,[,o,c]=s.shape,[,l,u]=r.shape,h=[i&&l>1?o-1:o,i&&u>1?c-1:c],d=[i&&l>1?l-1:l,i&&u>1?u-1:u],p=1/(h[0]/d[0]),f=1/(h[1]/d[1]),m=2*Math.ceil(p)+2,g=2*Math.ceil(f)+2,y=new n3(s.shape,i),b=[{type:"int32",data:h},{type:"int32",data:d},{type:"float32",data:[p]},{type:"float32",data:[f]},{type:"int32",data:[m]},{type:"int32",data:[g]}];return n.runWebGPUProgram(y,[r],r.dtype,b)}};class s3{constructor(e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=QQ(this.outputShape),this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=" axis : vec4<i32>,",this.shaderKey="reverse"}getUserCode(){return"\n      ".concat("\n      // Using uniform variables as judging conditions, so the function has\n      // coherent execution within all threads.\n      fn getReverseCoords(coords : vec4<i32>) -> vec4<i32> {\n        var reverseCoords = coords;\n        if (uniforms.axis[0] == 1) {\n          reverseCoords[0] = uniforms.xShape[0] - coords[0] - 1;\n        }\n        if (uniforms.axis[1] == 1) {\n          reverseCoords[1] = uniforms.xShape[1] - coords[1] - 1;\n        }\n        if (uniforms.axis[2] == 1) {\n          reverseCoords[2] = uniforms.xShape[2] - coords[2] - 1;\n        }\n        if (uniforms.axis[3] == 1) {\n          reverseCoords[3] = uniforms.xShape[3] - coords[3] - 1;\n        }\n\n        return reverseCoords;\n      }\n    ","\n      ").concat(LQ("index")," {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let reverseCoords = getReverseCoords(coords);\n          setOutputAtIndex(index, getX(reverseCoords[0],\n              reverseCoords[1], reverseCoords[2], reverseCoords[3]));\n        }\n      }\n    ")}}const r3={kernelName:wp,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{dims:r}=a,i=s.shape.length;if(0===i)return _Z({inputs:{x:s},backend:n});const o=s.shape,c=[1,1,1,1];o.forEach((e,t)=>{c[t+4-i]=e});const l=Eu(r,s.shape),u=[0,0,0,0];l.forEach(e=>{u[e+4-i]=1});const h=[{type:"int32",data:u}],d=CZ({inputs:{x:s},backend:n,attrs:{shape:c}}),p=new s3(c),f=n.runWebGPUProgram(p,[d],d.dtype,h);n.disposeData(d.dataId);const m=CZ({inputs:{x:f},backend:n,attrs:{shape:o}});return n.disposeData(f.dataId),m}};class i3{constructor(e,t){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=QQ(this.outputShape),this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms="centerX : f32, centerY : f32, sinRadians : f32,\n          cosRadians : f32,",this.shaderKey="rotate",this.outputShape=e,"number"===typeof t?(this.uniforms+=" fillValue : f32,",this.fillSnippet="var outputValue = uniforms.fillValue;",this.shaderKey+="_float"):(this.uniforms+=" fillValue : vec3<f32>,",this.fillSnippet="var outputValue = uniforms.fillValue[coords[3]];",this.shaderKey+="_vec3")}getUserCode(){return"\n        ".concat(LQ("index")," {\n          if (index < uniforms.size) {\n            let coords = getCoordsFromIndex(index);\n            let coordXFloat = (f32(coords[2]) - uniforms.centerX) *\n                uniforms.cosRadians - (f32(coords[1]) - uniforms.centerY) *\n                uniforms.sinRadians;\n            let coordYFloat = (f32(coords[2]) - uniforms.centerX) *\n                uniforms.sinRadians + (f32(coords[1]) - uniforms.centerY) *\n                uniforms.cosRadians;\n            let coordX = i32(round(coordXFloat + uniforms.centerX));\n            let coordY = i32(round(coordYFloat + uniforms.centerY));\n            ").concat(this.fillSnippet,"\n            if(coordX >= 0 && coordX < uniforms.xShape[2] && coordY >= 0 &&\n                coordY < uniforms.xShape[1]) {\n              outputValue = getX(coords[0], coordY, coordX, coords[3]);\n            }\n            setOutputAtIndex(index, outputValue);\n          }\n        }\n      ")}}const o3={kernelName:df,backendName:"webgpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e;const{image:s}=t,{radians:r,fillValue:i,center:o}=n,c=a,l=new i3(s.shape,i),[u,h]=iC(o,s.shape[1],s.shape[2]),d=[{type:"float32",data:[u]},{type:"float32",data:[h]},{type:"float32",data:[Math.sin(r)]},{type:"float32",data:[Math.cos(r)]}];"number"===typeof i?d.push({type:"float32",data:[Number.parseFloat(i.toFixed(2))]}):d.push({type:"float32",data:i});return c.runWebGPUProgram(l,[s],s.dtype,d)}},c3=OZ({opType:rZ.ROUND}),l3={kernelName:kp,backendName:"webgpu",kernelFunc:c3},u3=OZ({opType:rZ.RSQRT,cpuKernelImpl:oJ}),h3={kernelName:Sp,backendName:"webgpu",kernelFunc:u3};class d3{constructor(e,t,n,a,s,r,i){let o=!(arguments.length>7&&void 0!==arguments[7])||arguments[7];this.variableNames=["updates","indices"],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=r,this.type=i,this.sumDupeIndices=o,this.dispatchLayout=QQ(e),this.dispatch=KQ(this.dispatchLayout,e,this.workgroupSize),this.sliceDimGreaterThanOne=t>1,this.shaderKey="scatter_".concat(n,"_").concat(a,"_").concat(this.sliceDimGreaterThanOne,"_").concat(i,"_").concat(o,"_").concat(s.length);const c=OQ(s.length);this.uniforms="sliceDim : i32, strides: ".concat(c,", updatesSize: i32,"),this.updatesRank=a,this.indicesRank=n}getUserCode(){let e="";1===this.indicesRank?e="coords[0]":2===this.indicesRank&&(e="coords[0], j");const t="getIndices(".concat(e,")"),n=this.sliceDimGreaterThanOne?"uniforms.strides[j]":"uniforms.strides";let a="",s="";1===this.dispatchLayout.x.length?(a="flattenedIndex",s="\n      fn getUpdatesCoordsFromFlatIndex(index : i32) -> i32 {\n        return index;\n      }\n      "):2===this.dispatchLayout.x.length&&(a="vec2<i32>(flattenedIndex, coords[1])",s="\n      fn getUpdatesCoordsFromFlatIndex(index : i32) -> vec2<i32> {\n        // N.B. |updates| could be a scalar tensor, conceptually representing a\n        // 2D tensor with all values equal to that. By design, its size must be\n        // the same as |outShape[1]| in one dimension, and |indicesShape[0]|\n        // gives the other.\n        let sliceSize = uniforms.outShape[1];\n        let d0 = index / sliceSize;\n        let d1 = index - d0 * sliceSize;\n        return vec2<i32>(d0, d1);\n      }\n      ");const r=Array.from({length:this.updatesRank},(e,t)=>"coords[".concat(t,"]")),i="getUpdates(".concat(r.join(", "),")");return"\n    ".concat(s,"\n      ").concat(LQ("index")," {\n        if (index < uniforms.updatesSize) {\n          let coords = getUpdatesCoordsFromFlatIndex(index);\n          var flattenedIndex = 0;\n          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {\n            let indexInside = i32(round(").concat(t,"));\n            flattenedIndex = flattenedIndex + indexInside * ").concat(n,";\n          }\n          let updateValue =\n              ").concat(HQ(this.type),"(").concat(i,");\n          let flatIndex = getOutputIndexFromCoords(").concat(a,");\n\n          ").concat(this.sumDupeIndices?AQ("&result[flatIndex]","updateValue",this.type):"atomicStore(&result[flatIndex], bitcast<i32>(updateValue));","\n        }\n      }")}}const p3={kernelName:Cp,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{indices:s,updates:r}=t,{shape:i}=a,{sliceRank:o,numUpdates:c,sliceSize:l,strides:u,outputSize:h}=pk(0,s,i),d=[h/l,l];if(0===h)return n.makeTensorInfo(i,s.dtype);const p=CZ({inputs:{x:s},backend:n,attrs:{shape:[c,o]}}),f=CZ({inputs:{x:r},backend:n,attrs:{shape:[c,l]}}),m=f.dtype,g=kZ({backend:n,attrs:{shape:d,value:0,dtype:m}}),y=[{type:"int32",data:[o]},{type:"int32",data:u},{type:"int32",data:[vu(f.shape)]}],b=new d3(f.shape,o,p.shape.length,f.shape.length,u,d,m),x=n.runWebGPUProgram(b,[f,p],m,y,g),v=CZ({inputs:{x:x},backend:n,attrs:{shape:i}});return n.disposeData(p.dataId),n.disposeData(f.dataId),n.disposeData(x.dataId),v}};class f3{constructor(e,t){this.outputShape=[],this.variableNames=["sortedSequence","values"],this.uniforms="numInputs : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=QQ(this.outputShape),this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.side=t,this.shaderKey="search_sorted_".concat(t)}getUserCode(){const e="left"===this.side?"<":"<=";return"\n      fn findBound(batch: i32, value: f32) -> i32 {\n        var left = i32(0);\n        var right = uniforms.numInputs;\n        while (left < right) {\n          var mid = (left + right) / 2;\n          if (getSortedSequence(batch, mid) ".concat(e," value) {\n            left = mid + 1;\n          } else {\n            right = mid;\n          }\n        }\n        return right;\n      }\n\n      ").concat(LQ("index")," {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let value = getValuesByOutputIndex(index);\n          setOutputAtIndexI32(index, findBound(coords[0], value));\n        }\n      }\n    ")}}const m3={kernelName:Np,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{sortedSequence:s,values:r}=t,{side:i}=a,o=new f3([r.shape[0],r.shape[1]],i),c=[{type:"int32",data:[s.shape[1]]}];return n.runWebGPUProgram(o,[s,r],"int32",c)}};class g3{constructor(e,t,n){this.variableNames=["c","a","b"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=QQ(this.outputShape),this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.cRank=e,this.rank=n,this.shaderKey="select"}getUserCode(){let e,t;if(this.rank>4)throw Error("Where for rank ".concat(this.rank," is not yet supported"));if(1===this.rank)t="resRC",e="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],a=[],s=[];for(let e=0;e<this.outputShape.length;e++)s.push("".concat(n[e])),e<this.cRank&&a.push("".concat(n[e]));e=a.join(),t=s.join()}return"\n      ".concat(LQ("index")," {\n        if (index < uniforms.size) {\n          let resRC = getCoordsFromIndex(index);\n          let cVal = getC(").concat(e,");\n          if (cVal >= 1.0) {\n            setOutputAtIndex(index, getA(").concat(t,"));\n          } else {\n            setOutputAtIndex(index, getB(").concat(t,"));\n          }\n        }\n      }\n    ")}}const y3={kernelName:Tp,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:a,t:s,e:r}=t,i=new g3(a.shape.length,s.shape,s.shape.length);return n.runWebGPUProgram(i,[a,s,r],mm(s.dtype,r.dtype))}},b3=OZ({opType:rZ.SELU}),x3={kernelName:Ep,backendName:"webgpu",kernelFunc:b3},v3=OZ({opType:rZ.SIGMOID}),w3={kernelName:Pp,backendName:"webgpu",kernelFunc:v3},k3=OZ({opType:rZ.SIGN}),S3={kernelName:Mp,backendName:"webgpu",kernelFunc:k3},C3=OZ({opType:rZ.SIN}),I3={kernelName:_p,backendName:"webgpu",kernelFunc:C3},N3=OZ({opType:rZ.SINH}),T3={kernelName:Ap,backendName:"webgpu",kernelFunc:N3},E3=OZ({opType:rZ.SOFTPLUS}),R3={kernelName:Dp,backendName:"webgpu",kernelFunc:E3};class _3{constructor(e,t,n,a,s,r){this.variableNames=["x"],this.outputShape=[],this.uniforms="",this.workgroupSize=[64,1,1],this.size=!0;const i=new Array(a.length);for(let o=0;o<i.length;o++)i[o]=a[s[o]];this.outputShape=i,this.newDim=s,this.dispatchLayout=QQ(this.outputShape),this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=e,this.paddedXShape=t,this.uniforms+="reshapedPaddedXShape : ".concat(OQ(a.length),", paddedXShapeStrides : ").concat(OQ(r),", "),n.map((e,t)=>{this.uniforms+=" pad".concat(t," : vec2<i32>,")}),this.shaderKey="spaceToBatchND_".concat(s)}getUserCode(){const e=OQ(this.outputShape.length),t=_J(this.newDim);return"\n      ".concat(WQ(this.paddedXShape,"PaddedX"),"\n      ").concat(LQ("index")," {\n        if(index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let switchedIndex = getIndexFromCoords").concat(this.outputShape.length,"D(").concat(e,"(").concat(t,"), uniforms.reshapedPaddedXShape);\n          let paddedCoords = getPaddedXCoordsFromIndex(switchedIndex);\n          ").concat(D2(this.xShape,!0),"\n        }\n      }\n    ")}}const A3={kernelName:Lp,backendName:"webgpu",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{blockShape:r,paddings:i}=a;yu(s.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGPU backend not implemented yet");const o=r.reduce((e,t)=>e*t),c=[[0,0]];c.push(...i);for(let b=1+r.length;b<s.shape.length;++b)c.push([0,0]);const l=c.map((e,t)=>e[0]+s.shape[t]+e[1]),u=oC(l,r,o,!1),h=cC(u.length,r.length,!1),d=lC(l,r,o,!1),p=Bu(l),f=new _3(s.shape,l,c,u,h,p.length),m=[{type:"int32",data:u},{type:"int32",data:p}];c.map(e=>m.push({type:"int32",data:[e[0],e[1]]}));const g=n.runWebGPUProgram(f,[s],s.dtype,m),y=CZ({inputs:{x:g},backend:n,attrs:{shape:d}});return n.disposeData(g.dataId),y}};class M3{constructor(e,t,n){this.variableNames=["input","indices","segmentIds"],this.outputShape=[],this.uniforms="segmentSize : i32, sparseSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e,this.type=n,this.dispatchLayout=QQ([t]),this.dispatch=KQ(this.dispatchLayout,[t],this.workgroupSize),this.shaderKey="sparseSegmentSum"}getUserCode(){return"\n    ".concat(LQ("index")," {\n      if (index < uniforms.sparseSize) {\n        let indexInSegmentIds = index / uniforms.segmentSize;\n        let indexInSegment = index % uniforms.segmentSize;\n        let indexInInput = indices[indexInSegmentIds];\n        let segmentId = segmentIds[indexInSegmentIds];\n\n        let value = input[indexInInput * uniforms.segmentSize + indexInSegment];\n        let outIndex = segmentId * uniforms.segmentSize + indexInSegment;\n        ").concat(AQ("&result[outIndex]","value",this.type),"\n      }\n    }\n  ")}}class P3{constructor(e,t){this.variableNames=["segmentIds"],this.outputShape=[],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=[e],this.dispatchLayout=QQ(t),this.dispatch=KQ(this.dispatchLayout,t,this.workgroupSize),this.shaderKey="sparseSegmentIdCountProgram"}getUserCode(){return"\n    ".concat(LQ("index")," {\n      if (index < uniforms.segmentIdsShape) {\n        let segmentId = segmentIds[index];\n        ").concat(AQ("&result[segmentId]","1","int32"),"\n      }\n    }\n  ")}}class D3{constructor(e,t){this.variableNames=["segmentSum","sameSegmentIdCount"],this.outputShape=[],this.uniforms="segmentSize : i32",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.type=t,this.dispatchLayout=QQ(e),this.dispatch=KQ(this.dispatchLayout,e,this.workgroupSize),this.shaderKey="sparseSegmentMean"}getUserCode(){return"\n    ".concat(LQ("index")," {\n      if (index < uniforms.size) {\n        let segmentId = index / uniforms.segmentSize;\n        let count = sameSegmentIdCount[segmentId];\n        if (count != 0) {\n          ").concat("float32"===this.type?"setOutputAtIndex(index, segmentSum[index] / f32(count));":"setOutputAtIndexI32(index, segmentSum[index] / count);","\n        }\n      }\n    }\n  ")}}function O3(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=arguments.length>4?arguments[4]:void 0;const r=vu(e.shape)/e.shape[0],i=e.dtype,o=vu(t.shape),c=s.readSync(n.dataId),l=o>0?c[o-1]+1:0;let u;const h=e.shape.slice();h[0]=l;const d=o*r,p=kZ({backend:s,attrs:{shape:h,value:0,dtype:i}});u=new M3(h,d,i);let f=[{type:"int32",data:[r]},{type:"int32",data:[d]}];const m=s.runWebGPUProgram(u,[e,t,n],i,f,p);if(a)return m;const g=kZ({backend:s,attrs:{shape:[l],value:0,dtype:"int32"}});u=new P3(l,n.shape);const y=s.runWebGPUProgram(u,[n],"int32",null,g),b=kZ({backend:s,attrs:{shape:h,value:0,dtype:i}});u=new D3(h,i),f=[{type:"int32",data:[r]}];const x=s.runWebGPUProgram(u,[m,y],i,f,b);return s.disposeData(m.dataId),s.disposeData(y.dataId),x}const F3={kernelName:Vp,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:a,indices:s,segmentIds:r}=t;return O3(a,s,r,!1,n)}};const L3={kernelName:Up,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:a,indices:s,segmentIds:r}=t;return O3(a,s,r,!0,n)}};class z3{constructor(e,t){this.variableNames=["A"],this.workgroupSize=[64,1,1],this.size=!0;const n=new Array(e.length);for(let a=0;a<n.length;a++)n[a]=e[a]*t[a];this.outputShape=n,this.dispatchLayout=QQ(this.outputShape),this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.rank=this.outputShape.length,this.shaderKey="tile"}getUserCode(){const e=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"";if(e>=5)throw Error("Tile for rank ".concat(e," is not yet supported"));if(1===e)return"(resRC % ".concat(t,"aShape)");const n=["resRC.x","resRC.y","resRC.z","resRC.w"],a=[];for(let s=0;s<e;s++)a.push("(".concat(n[s]," % ").concat(t,"aShape[").concat(s,"])"));return a.join()}(this.rank,"uniforms.");return"\n      ".concat(LQ("index")," {\n        if (index < uniforms.size) {\n          let resRC = getCoordsFromIndex(index);\n          setOutputAtIndex(index, getA(").concat(e,"));\n        }\n      }\n    ")}}function B3(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{reps:r}=a;if(n.shouldExecuteOnCPU([s])||"string"===s.dtype||s.shape.length>=5){const e=n.readSync(s.dataId),t="string"===s.dtype?e.map(e=>Gf(e)):e,a=ty(s.shape,s.dtype,t),i=fJ(a,r);return n.makeTensorInfo(i.shape,i.dtype,i.values)}const i=new z3(s.shape,r);return n.runWebGPUProgram(i,[s],s.dtype)}const j3={kernelName:tf,backendName:"webgpu",kernelFunc:B3};const W3={kernelName:Hp,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{sparseIndices:s,sparseValues:r,defaultValue:i}=t,{outputShape:o}=a,{sliceRank:c,numUpdates:l,sliceSize:u,strides:h,outputSize:d}=pk(0,s,o),p=!1;if("string"===r.dtype){const e=n.bufferSync(s),t=n.bufferSync(r),a=Gf(n.readSync(i.dataId)[0]),f=cJ(e,t,o,d,u,l,c,h,a,p);return n.makeTensorInfo(o,f.dtype,f.values)}const f=[d/u,u],m=CZ({inputs:{x:s},backend:n,attrs:{shape:[l,c]}}),g=r.shape.length?CZ({inputs:{x:r},backend:n,attrs:{shape:[l,u]}}):_Z({inputs:{x:r},backend:n}),y=g.dtype,b=n.makeTensorInfo([],y,Hu(1,y)),x=CZ({inputs:{x:i},backend:n,attrs:{shape:Array(f.length).fill(1)}}),v=B3({inputs:{x:x},backend:n,attrs:{reps:f}}),w=[{type:"int32",data:[c]},{type:"int32",data:h},{type:"int32",data:[vu([l,u])]}];switch(l){case 0:break;case 1:{const e=new d3([l,u],c,m.shape.length,g.shape.length,h,f,y,p);n.runWebGPUProgram(e,[g,m],y,w,v)}break;default:{const e=new d3([l,u],c,m.shape.length,b.shape.length,h,f,y,p);n.runWebGPUProgram(e,[b,m],y,w,v)}{const e=new d3([l,u],c,m.shape.length,g.shape.length,h,f,y);n.runWebGPUProgram(e,[g,m],y,w,v)}}const k=CZ({inputs:{x:v},backend:n,attrs:{shape:o}});return n.disposeData(m.dataId),n.disposeData(g.dataId),n.disposeData(x.dataId),n.disposeData(b.dataId),n.disposeData(v.dataId),k}};const V3={kernelName:zp,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{numOrSizeSplits:r,axis:i}=a,o=Eu(i,s.shape)[0],c=BC(s,r,o),l=s.shape.length,u=new Array(l).fill(0),h=s.shape.slice();return c.map(e=>{const t=[...h];t[o]=e;const a=f$({inputs:{x:s},backend:n,attrs:{begin:u,size:t}});return u[o]+=e,a})}},U3=OZ({opType:rZ.SQRT}),H3={kernelName:Op,backendName:"webgpu",kernelFunc:U3},G3={kernelName:qp,backendName:"webgpu",kernelFunc:e=>{let{inputs:t,backend:n}=e;const{x:a}=t,s=n,r=new DZ(a.shape,rZ.SQUARE);return s.runWebGPUProgram(r,[a],a.dtype)}},q3=FZ({opType:aZ.SQUARED_DIFFERENCE}),K3={kernelName:Gp,backendName:"webgpu",kernelFunc:q3};const X3={kernelName:uf,backendName:"webgpu",kernelFunc:function(e){let{inputs:t,attrs:n,backend:a}=e;const{x:s}=t,r=new DZ(s.shape,rZ.STEP,"stepAlpha : f32,"),i=[{type:"float32",data:[n.alpha]}];return a.runWebGPUProgram(r,[s],s.dtype,i)}};class Y3{constructor(e){this.variableNames=["x"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=QQ(this.outputShape),this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]);const t=OQ(this.outputShape.length);this.uniforms="begin : ".concat(t,",  strides : ").concat(t,", "),this.shaderKey="stridedSlice"}getUserCode(){let e="";if(1===this.outputShape.length)e="coords * uniforms.strides + uniforms.begin";else{let t=0;e=this.outputShape.map((e,n)=>(t++,1===this.outputShape.length?"coords * uniforms.strides[".concat(n,"] + uniforms.begin[").concat(n,"]"):"coords[".concat(t-1,"] * uniforms.strides[").concat(n,"] + uniforms.begin[").concat(n,"]"))).join(",")}return"\n       ".concat(LQ("index")," {\n         if (index < uniforms.size) {\n           let coords = getCoordsFromIndex(index);\n           setOutputAtIndex(index, getX(").concat(e,"));\n         }\n       }\n     ")}}const Q3={kernelName:Xp,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{begin:r,end:i,strides:o,beginMask:c,endMask:l,ellipsisMask:u,newAxisMask:h,shrinkAxisMask:d}=a,{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:x,strides:v}=Nb(s.shape,r,i,o,c,l,u,h,d);let w;if(m)w=CZ({inputs:{x:s},backend:n,attrs:{shape:f}});else if(g||y){yu(s.shape.length>=1,()=>"Input must have rank at least 1, got: ".concat(s.shape.length));const e=pb(b,x,v),t=f$({inputs:{x:s},backend:n,attrs:{begin:b,size:e}});w=CZ({inputs:{x:t},backend:n,attrs:{shape:f}}),n.disposeData(t.dataId)}else{if(n.shouldExecuteOnCPU([s])){const e=n.readSync(s.dataId),t=ty(s.shape,s.dtype,e),a=hJ(p,t,v,b);w=n.makeTensorInfo(f,s.dtype,a.values)}else{const e=new Y3(p),t=[{type:"int32",data:b},{type:"int32",data:v}],a=n.runWebGPUProgram(e,[s],s.dtype,t);w=CZ({inputs:{x:a},backend:n,attrs:{shape:f}}),n.disposeData(a.dataId)}}return w}};const Z3={kernelName:Yp,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{separator:s,nGramWidths:r,leftPad:i,rightPad:o,padWidth:c,preserveShortSequences:l}=a,{data:u,dataSplits:h}=t,d=n.readSync(u.dataId),p=n.readSync(h.dataId),[f,m]=dJ(d,p,s,r,i,o,c,l);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(h.shape,"int32",m)]}},J3=FZ({opType:aZ.SUB,cpuKernelImpl:pJ,supportsComplex:!0}),$3={kernelName:Jp,backendName:"webgpu",kernelFunc:J3},e4=OZ({opType:rZ.TAN}),t4={kernelName:$p,backendName:"webgpu",kernelFunc:e4},n4=OZ({opType:rZ.TANH}),a4={kernelName:ef,backendName:"webgpu",kernelFunc:n4};const s4={kernelName:Ip,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{tensor:s,indices:r,updates:i}=t,{}=a,{sliceRank:o,numUpdates:c,sliceSize:l,strides:u,outputSize:h}=pk(0,r,s.shape),d=[h/l,l];if(0===h)return n.makeTensorInfo(s.shape,r.dtype);const p=[],f=CZ({inputs:{x:r},backend:n,attrs:{shape:[c,o]}});p.push(f);const m=CZ({inputs:{x:i},backend:n,attrs:{shape:[c,l]}});p.push(m);const g=CZ({inputs:{x:s},backend:n,attrs:{shape:d}});p.push(g);const y=B3({inputs:{x:g},backend:n,attrs:{reps:Array(d.length).fill(1)}}),b=new d3([c,l],o,f.shape.length,m.shape.length,u,d,s.dtype,!1),x=[{type:"int32",data:[o]},{type:"int32",data:u},{type:"int32",data:[vu([c,l])]}],v=n.runWebGPUProgram(b,[m,f],g.dtype,x,y);p.push(v);const w=CZ({inputs:{x:v},backend:n,attrs:{shape:s.shape}});return p.forEach(e=>n.disposeData(e.dataId)),w}};class r4{constructor(e){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=QQ(this.outputShape),this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms="inputSize : i32, firstPass : i32, negativeInf : f32,\n        dir : i32, inc : i32,",this.shaderKey="swap"}getUserCode(){return"\n        ".concat(LQ("index")," {\n          if (index < uniforms.size) {\n            let outC = getCoordsFromIndex(index);\n            let batch = outC[0];\n            let elemIdx = outC[1];\n            // We compare elements pair-wise within a group of size 2 * inc.\n            // The comparing rule for each group alternates between ascending\n            // and descending. Within each group, we compare each pair at\n            // positions i and i+inc. To decide whether an element at position i\n            // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n            // inc, it is in the first half of the group, we denote it as x0,\n            // otherwise we denote it as x1.\n            // For example, as shown in the Bitonic top K paper referenced\n            // above, Figure5(a) shows that element[1] is in the second half of\n            // the group when group size is 2, but it is in the first half of\n            // the group when group size is 4.\n            let isFirstInPair = elemIdx % (2 * uniforms.inc) < uniforms.inc;\n            var i = 0;\n            if (isFirstInPair) {\n              i = elemIdx;\n            } else {\n              i = elemIdx - uniforms.inc;\n            }\n\n            var i0 = 0;\n            if (uniforms.firstPass == 1) {\n              i0 = i;\n            } else {\n              i0 = i32(getIndices(batch, i));\n            }\n\n            var i1 = 0;\n            if (uniforms.firstPass == 1) {\n              i1 = i + uniforms.inc;\n            } else {\n              i1 = i32(getIndices(batch, i + uniforms.inc));\n            }\n\n            var x0 = f32(0.0);\n            var x1 = f32(0.0);\n            if (i0 < uniforms.inputSize) {\n              x0 = getX(batch, i0);\n            } else {\n              x0 = uniforms.negativeInf;\n            }\n            if (i1 < uniforms.inputSize) {\n              x1 = getX(batch, i1);\n            } else {\n              x1 = uniforms.negativeInf;\n            }\n\n            let reverse = elemIdx % (2 * uniforms.dir) >= uniforms.dir;\n            let isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n            if (reverse == isGreater) {\n              // Elements in opposite order of direction\n              let iTemp = i0;\n              i0 = i1;\n              i1 = iTemp;\n            }\n            if (isFirstInPair) {\n              setOutputAtIndex(index, f32(i0));\n            } else {\n              setOutputAtIndex(index, f32(i1));\n            }\n          }\n        }\n      ")}}class i4{constructor(e){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=QQ(this.outputShape),this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms="inputSize : i32, firstPass : i32, k : i32,",this.shaderKey="merge"}getUserCode(){return"\n        ".concat(LQ("index")," {\n          if (index < uniforms.size) {\n            let outC = getCoordsFromIndex(index);\n            let batch = outC[0];\n            let elemIdx = outC[1];\n            // The output size is half of the previous size.\n            // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _\n            // (k=4), we only need to output the indices at positions |, the\n            // indices at positions _ can be thrown away, see Figure5(b) After\n            // Phase 2 (Merge phase) in the Bitonic Top K paper referenced\n            // above.\n            // For example, the paper shows we only need to output the orange\n            // bars. The output sequence should look like this | | | | | | | |.\n            // Because the sequence is halved, to map the output index back to\n            // the previous sequence to find the corresponding value, we need\n            // to double the index. When we double the index, we basically\n            // interpolate a position, so 2i looks like\n            // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k\n            // position of each 2k positions by - elemIdx % k. E.g. for output\n            // at index 4,5,6,7, we want to get the corresponding element at\n            // original index 8,9,10,11, for output at index 8,9,10,11,\n            // we want to get the corresponding element at original index\n            // 16,17,18,19, so on and so forth.\n\n            var i = 0;\n            if (elemIdx < uniforms.k) {\n              i = elemIdx;\n            } else {\n              i = elemIdx * 2 - elemIdx % uniforms.k;\n            }\n            var i0 = 0;\n            if (uniforms.firstPass == 1) {\n              i0 = i;\n            } else {\n              i0 = i32(getIndices(batch, i));\n            }\n            var i1 = 0;\n            if (uniforms.firstPass == 1) {\n              i1 = i + uniforms.k;\n            } else {\n              i1 = i32(getIndices(batch, i + uniforms.k));\n            }\n\n            let x0 = getX(batch, i0);\n            var x1 = f32(0.0);\n            if (i1 < uniforms.inputSize) {\n              x1 = getX(batch, i1);\n            } else {\n              x1 = x0;\n            }\n\n            if (x0 >= x1) {\n              setOutputAtIndex(index, f32(i0));\n            } else {\n              setOutputAtIndex(index, f32(i1));\n            }\n          }\n        }\n      ")}}function o4(e,t){null!==t&&e.disposeData(t.dataId)}function c4(e){let t=1;for(;t<e;)t*=2;return t}const l4={kernelName:nf,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{k:r,sorted:i}=a,o=s.shape,c=o[o.length-1];if(n.shouldExecuteOnCPU([s])){const e=n.readSync(s.dataId),[t,a]=mJ(e,o,s.dtype,r,i);return[n.makeTensorInfo(t.shape,t.dtype,t.values),n.makeTensorInfo(a.shape,a.dtype,a.values)]}if(0===r)return o[o.length-1]=0,[n.makeTensorInfo(o,s.dtype,[]),n.makeTensorInfo(o,"int32",[])];if(1===c)return[s,kZ({attrs:{shape:o,dtype:"int32",value:0},backend:n})];const l=vu(o)/c,u=CZ({inputs:{x:s},attrs:{shape:[l,c]},backend:n}),h=c4(r),d=c4(c);let p=null;const f=()=>null===p?[u,u]:[u,p],m=(e,t,a)=>{const s=f(),r=new r4(a),i=[{type:"int32",data:[c]},{type:"int32",data:[null===p?1:0]},{type:"float32",data:[Number.NEGATIVE_INFINITY]},{type:"int32",data:[e]},{type:"int32",data:[t]}],o=p;p=n.runWebGPUProgram(r,s,"int32",i),o4(n,o)};for(let v=1;v<h;v*=2){const e=2*v;for(let t=v;t>=1;t/=2)m(e,t,[l,d])}for(let v=d;v>h;v/=2){const e=f(),t=new i4([l,v/2]),a=[{type:"int32",data:[c]},{type:"int32",data:[null===p?1:0]},{type:"int32",data:[h]}],s=p;p=n.runWebGPUProgram(t,e,"int32",a),o4(n,s);const r=h/2,i=2*r;for(let n=r;n>=1;n/=2)m(i,n,p.shape)}let g=p;p=f$({inputs:{x:p},backend:n,attrs:{begin:0,size:[l,r]}}),o4(n,g);let y=k1({inputs:{x:u,indices:p},backend:n,attrs:{axis:1,batchDims:1}});o4(n,u);const b=o.slice(0,-1);b.push(r),g=p,p=CZ({inputs:{x:p},attrs:{shape:b},backend:n}),o4(n,g);const x=y;return y=CZ({inputs:{x:y},attrs:{shape:b},backend:n}),o4(n,x),[y,p]}};class u4{constructor(e){this.variableNames=["Image","Transforms"],this.uniforms="interpolationModeId : i32, fillModeId : i32, fillValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=QQ(this.outputShape),this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="transform"}getUserCode(){return"\n          fn mapCoord(outCoord : f32, len : f32) -> f32{\n            var inCoord = outCoord;\n            if(uniforms.fillModeId == 2) {\n              if (inCoord < 0.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz2 = 2.0 * len;\n                  if (inCoord < sz2) {\n                    inCoord = sz2 * f32(i32(f32(-inCoord / sz2))) +\n                    inCoord;\n                  }\n                  if (inCoord < -len) {\n                    inCoord = inCoord + sz2;\n                  } else {\n                    inCoord = -inCoord - 1.0;\n                  }\n                }\n              } else if (inCoord > len - 1.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz2 = 2.0 * len;\n                  inCoord = inCoord - sz2 * f32(i32(f32(inCoord / sz2)));\n                  if (inCoord >= len) {\n                    inCoord = sz2 - inCoord - 1.0;\n                  }\n                }\n              }\n              return clamp(inCoord, 0.0, len - 1.0);\n            } else if (uniforms.fillModeId == 3) {\n              if (inCoord < 0.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz = len - 1.0;\n                  inCoord = inCoord + len * (f32(i32(f32(-inCoord / sz))) + 1.0);\n                }\n              } else if (inCoord > len - 1.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz = len - 1.0;\n                  inCoord = inCoord - len * f32(i32(f32(inCoord / sz)));\n                }\n              }\n              return clamp(inCoord, 0.0, len - 1.0);\n            } else if (uniforms.fillModeId == 4) {\n              return clamp(outCoord, 0.0, len - 1.0);\n            }\n            return outCoord;\n          }\n          fn readWithFillValue(batch : i32, coordY : i32, coordX : i32,\n            channel : i32) -> f32 {\n            var outputValue : f32;\n            if (0 <= coordY && coordY < uniforms.imageShape[1] && 0 <= coordX && coordX < uniforms.imageShape[2]) {\n                outputValue = getImage(batch, coordY, coordX, channel);\n            } else {\n              outputValue = uniforms.fillValue;\n            }\n            return outputValue;\n          }\n\n          ".concat(LQ("index")," {\n            if (index < uniforms.size) {\n              let coords = getCoordsFromIndex(index);\n              var outputValue : f32;\n              let batch = coords[0];\n              let x = coords[2];\n              let y = coords[1];\n              let channel = coords[3];\n              let xf = f32(x);\n              let yf = f32(y);\n              let a1 = getTransforms(batch, 0);\n              let a2 = getTransforms(batch, 1);\n              let a3 = getTransforms(batch, 2);\n              let b1 = getTransforms(batch, 3);\n              let b2 = getTransforms(batch, 4);\n              let b3 = getTransforms(batch, 5);\n              let c1 = getTransforms(batch, 6);\n              let c2 = getTransforms(batch, 7);\n              let projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = uniforms.fillValue;\n              } else {\n                let inX = (a1 * xf + a2 * yf + a3) / projection;\n                let inY = (b1 * xf + b2 * yf + b3) / projection;\n                let mapX = mapCoord(inX, f32(uniforms.imageShape[2]));\n                let mapY = mapCoord(inY, f32(uniforms.imageShape[1]));\n\n                if (uniforms.interpolationModeId == 1) {\n                  let coordY = i32(round(mapY));\n                  let coordX = i32(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  let yFloor = floor(mapY);\n                  let xFloor = floor(mapX);\n                  let yCeil = yFloor + 1.0;\n                  let xCeil = xFloor + 1.0;\n                  let valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, i32(yFloor), i32(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, i32(yFloor), i32(xCeil), channel);\n                  let valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, i32(yCeil), i32(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, i32(yCeil), i32(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutputAtIndex(index, outputValue);\n            }\n          }\n        ")}}const h4={kernelName:af,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{image:s,transforms:r}=t,{interpolation:i,fillMode:o,fillValue:c,outputShape:l}=a,[u,h,d,p]=s.shape,[f,m]=null!=l?l:[h,d],g=new u4([u,f,m,p]),y="nearest"===i?1:2;let b;switch(o){case"constant":default:b=1;break;case"reflect":b=2;break;case"wrap":b=3;break;case"nearest":b=4}const x=[{type:"int32",data:[y]},{type:"int32",data:[b]},{type:"float32",data:[c]}];return n.runWebGPUProgram(g,[s,r],"float32",x)}};const d4={kernelName:of,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{value:s}=t;let{axis:r}=a;r<0&&(r+=s.shape.length);const i=s,o=i.shape.length,c=s.shape[r],l=new Array(o-1);let u=0;for(let m=0;m<o;m++)m!==r&&(l[u++]=i.shape[m]);const h=[],d=new Array(o).fill(0),p=i.shape.slice();p[r]=1;const f=new Array(c);for(let m=0;m<f.length;m++){d[r]=m;const e=f$({inputs:{x:i},backend:n,attrs:{begin:d,size:p}}),t=CZ({inputs:{x:e},backend:n,attrs:{shape:l}});f[m]=t,h.push(e)}return h.forEach(e=>n.disposeData(e.dataId)),f}};class p4{constructor(e,t,n){if(this.outputShape=[],this.variableNames=["x","segmentIds"],this.uniforms="numSegments : i32, xSize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=t,this.dispatchLayout=QQ(e),this.dispatch=KQ(this.dispatchLayout,e,this.workgroupSize),"float32"!==n&&"int32"!==n)throw new Error("UnsortedSegmentSum only supports float32 and int32\n              types, does not support ".concat(n," type."));this.type=n,this.shaderKey="unsortedSegmentSum"}getUserCode(){return"\n    ".concat(LQ("index")," {\n      if (index < uniforms.xSize) {\n        let coords = getXCoordsFromIndex(index);\n        let b = coords[0];\n        let inCol = coords[1];\n\n        let segmentId = i32(getSegmentIds(inCol));\n        if (segmentId >= 0) {\n          let flatIndex = b * uniforms.numSegments + segmentId % uniforms.numSegments;\n          let value = getX(b, inCol);\n\n          ").concat(AQ("&result[flatIndex]","value",this.type),"\n        }\n      }\n    }\n  ")}}const f4={kernelName:cf,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,segmentIds:r}=t,{numSegments:i}=a,o=s.shape.length,c=[];let l=0;const u=ev([l],o);let h=s;null!=u&&(h=AJ({inputs:{x:s},backend:n,attrs:{perm:u}}),c.push(h),l=nv(1,o)[0]);const d=$C(h.shape,l,i),p=vu([h.shape[l]]),f=CZ({inputs:{x:h},backend:n,attrs:{shape:[-1,p]}});c.push(f);const m=s.dtype,g=[f.shape[0],i],y=kZ({backend:n,attrs:{shape:g,value:0,dtype:m}}),b=new p4(f.shape,g,m),x=[{type:"int32",data:[i]},{type:"int32",data:[vu(f.shape)]}],v=n.runWebGPUProgram(b,[f,r],m,x,y),w=CZ({inputs:{x:v},backend:n,attrs:{shape:d}});c.push(v);let k=w;if(null!=u){c.push(w);const e=tv(u);k=AJ({inputs:{x:k},backend:n,attrs:{perm:e}})}return c.forEach(e=>n.disposeData(e.dataId)),k}},m4=[TZ,xJ,wJ,SJ,IJ,TJ,FJ,LJ,BJ,jJ,VJ,HJ,qJ,XJ,QJ,r$,i$,l$,u$,h$,g$,x$,w$,N$,E$,A$,PZ,D$,j$,q$,Z$,$$,t0,n0,a0,r0,o0,l0,m0,g0,y0,x0,N0,T0,S0,R0,A0,D0,O0,L0,V0,H0,G0,K0,Y0,Z0,$0,t1,s1,SZ,i1,d1,c1,u1,g1,y1,b1,v1,S1,I1,T1,AZ,E1,L$,_1,M1,D1,O1,L1,B1,W1,G1,U1,K1,Y1,Z1,t2,a2,t$,r2,i2,h2,o2,u2,d2,a$,p2,m2,y2,x2,C2,B0,I2,N2,T2,S$,R2,M2,P2,F2,z2,B2,j2,W2,I$,U2,G2,K2,Y2,IZ,Z2,$2,t3,a3,r3,o3,l3,h3,p3,m3,y3,x3,w3,S3,I3,T3,m$,X3,Q3,Z3,S2,R3,A3,F3,L3,W3,V3,H3,G3,K3,$3,W0,t4,a4,s4,j3,l4,h4,MJ,d4,f4,A2];for(const n of m4)Sf(n);var g4=function(e,t){return(g4=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])})(e,t)};function y4(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Class extends value "+String(t)+" is not a constructor or null");function n(){this.constructor=e}g4(e,t),e.prototype=null===t?Object.create(t):(n.prototype=t.prototype,new n)}var b4=function(){return(b4=Object.assign||function(e){for(var t,n=1,a=arguments.length;n<a;n++)for(var s in t=arguments[n])Object.prototype.hasOwnProperty.call(t,s)&&(e[s]=t[s]);return e}).apply(this,arguments)};function x4(e,t,n,a){return new(n||(n=Promise))(function(s,r){function i(e){try{c(a.next(e))}catch(e){r(e)}}function o(e){try{c(a.throw(e))}catch(e){r(e)}}function c(e){var t;e.done?s(e.value):(t=e.value,t instanceof n?t:new n(function(e){e(t)})).then(i,o)}c((a=a.apply(e,t||[])).next())})}function v4(e,t){var n,a,s,r,i={label:0,sent:function(){if(1&s[0])throw s[1];return s[1]},trys:[],ops:[]};return r={next:o(0),throw:o(1),return:o(2)},"function"==typeof Symbol&&(r[Symbol.iterator]=function(){return this}),r;function o(r){return function(o){return function(r){if(n)throw new TypeError("Generator is already executing.");for(;i;)try{if(n=1,a&&(s=2&r[0]?a.return:r[0]?a.throw||((s=a.return)&&s.call(a),0):a.next)&&!(s=s.call(a,r[1])).done)return s;switch(a=0,s&&(r=[2&r[0],s.value]),r[0]){case 0:case 1:s=r;break;case 4:return i.label++,{value:r[1],done:!1};case 5:i.label++,a=r[1],r=[0];continue;case 7:r=i.ops.pop(),i.trys.pop();continue;default:if(!((s=(s=i.trys).length>0&&s[s.length-1])||6!==r[0]&&2!==r[0])){i=0;continue}if(3===r[0]&&(!s||r[1]>s[0]&&r[1]<s[3])){i.label=r[1];break}if(6===r[0]&&i.label<s[1]){i.label=s[1],s=r;break}if(s&&i.label<s[2]){i.label=s[2],i.ops.push(r);break}s[2]&&i.ops.pop(),i.trys.pop();continue}r=t.call(e,i)}catch(e){r=[6,e],a=0}finally{n=s=0}if(5&r[0])throw r[1];return{value:r[0]?r[1]:void 0,done:!0}}([r,o])}}}function w4(e,t,n){if(n||2===arguments.length)for(var a,s=0,r=t.length;s<r;s++)!a&&s in t||(a||(a=Array.prototype.slice.call(t,0,s)),a[s]=t[s]);return e.concat(a||Array.prototype.slice.call(t))}var k4=["nose","left_eye","right_eye","left_ear","right_ear","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle"],S4=["nose","left_eye_inner","left_eye","left_eye_outer","right_eye_inner","right_eye","right_eye_outer","left_ear","right_ear","mouth_left","mouth_right","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_pinky","right_pinky","left_index","right_index","left_thumb","right_thumb","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle","left_heel","right_heel","left_foot_index","right_foot_index"],C4={left:[1,2,3,7,9,11,13,15,17,19,21,23,25,27,29,31],right:[4,5,6,8,10,12,14,16,18,20,22,24,26,28,30,32],middle:[0]},I4={left:[1,3,5,7,9,11,13,15],right:[2,4,6,8,10,12,14,16],middle:[0]},N4=[[0,1],[0,2],[1,3],[2,4],[5,6],[5,7],[5,11],[6,8],[6,12],[7,9],[8,10],[11,12],[11,13],[12,14],[13,15],[14,16]],T4=[[0,1],[0,4],[1,2],[2,3],[3,7],[4,5],[5,6],[6,8],[9,10],[11,12],[11,13],[11,23],[12,14],[14,16],[12,24],[13,15],[15,17],[16,18],[16,20],[15,17],[15,19],[15,21],[16,22],[17,19],[18,20],[23,25],[23,24],[24,26],[25,27],[26,28],[27,29],[28,30],[27,31],[28,32],[29,31],[30,32]];function E4(e){return e instanceof SVGAnimatedLength?e.baseVal.value:e}function R4(e){return x4(this,void 0,void 0,function(){var t,n;return v4(this,function(a){switch(a.label){case 0:return t=document.createElement("canvas"),e instanceof im?[4,ob(e,t)]:[3,2];case 1:return a.sent(),[3,3];case 2:t.width=E4(e.width),t.height=E4(e.height),n=t.getContext("2d"),e instanceof ImageData?n.putImageData(e,0,0):n.drawImage(e,0,0),a.label=3;case 3:return[2,t]}})})}function _4(e){return x4(this,void 0,void 0,function(){var t,n,a,s,r,i;return v4(this,function(o){switch(o.label){case 0:return e instanceof im?(t=e.shape.slice(0,2),n=t[0],a=t[1],s=ImageData.bind,[4,ob(e)]):[3,2];case 1:return[2,new(s.apply(ImageData,[void 0,o.sent(),a,n]))];case 2:return r=document.createElement("canvas"),i=r.getContext("2d"),r.width=E4(e.width),r.height=E4(e.height),i.drawImage(e,0,0),[2,i.getImageData(0,0,r.width,r.height)]}})})}function A4(e){return x4(this,void 0,void 0,function(){var t;return v4(this,function(n){switch(n.label){case 0:return e instanceof SVGImageElement||e instanceof OffscreenCanvas?[4,R4(e)]:[3,2];case 1:return t=n.sent(),[3,3];case 2:t=e,n.label=3;case 3:return[2,cb(t,4)]}})})}function M4(e){if(e<0||e>=256)throw new Error("Mask value must be in range [0, 255] but got ".concat(e));if(!Number.isInteger(e))throw new Error("Mask value must be an integer but got ".concat(e))}var P4={runtime:"mediapipe",enableSmoothing:!0,enableSegmentation:!1,smoothSegmentation:!0,modelType:"full"},D4=function(){function e(e){this.mask=e}return e.prototype.toCanvasImageSource=function(){return x4(this,void 0,void 0,function(){return v4(this,function(e){return[2,this.mask]})})},e.prototype.toImageData=function(){return x4(this,void 0,void 0,function(){return v4(this,function(e){return[2,_4(this.mask)]})})},e.prototype.toTensor=function(){return x4(this,void 0,void 0,function(){return v4(this,function(e){return[2,A4(this.mask)]})})},e.prototype.getUnderlyingType=function(){return"canvasimagesource"},e}();function O4(e){return M4(e),"person"}var F4=function(){function e(e){var t,n=this;switch(this.width=0,this.height=0,this.selfieMode=!1,this.poseSolution=new kQ.Pose({locateFile:function(t,n){if(e.solutionPath){var a=e.solutionPath.replace(/\/+$/,"");return"".concat(a,"/").concat(t)}return"".concat(n,"/").concat(t)}}),e.modelType){case"lite":t=0;break;case"heavy":t=2;break;default:t=1}this.poseSolution.setOptions({modelComplexity:t,smoothLandmarks:e.enableSmoothing,enableSegmentation:e.enableSegmentation,smoothSegmentation:e.smoothSegmentation,selfieMode:this.selfieMode}),this.poseSolution.onResults(function(e){if(n.height=e.image.height,n.width=e.image.width,null==e.poseLandmarks)n.poses=[];else{var t=n.translateOutput(e.poseLandmarks,e.poseWorldLandmarks);e.segmentationMask&&(t.segmentation={maskValueToLabel:O4,mask:new D4(e.segmentationMask)}),n.poses=[t]}})}return e.prototype.translateOutput=function(e,t){var n=this,a={keypoints:e.map(function(e,t){return{x:e.x*n.width,y:e.y*n.height,z:e.z,score:e.visibility,name:S4[t]}})};return null!=t&&(a.keypoints3D=t.map(function(e,t){return{x:e.x,y:e.y,z:e.z,score:e.visibility,name:S4[t]}})),a},e.prototype.estimatePoses=function(e,t,n){return x4(this,void 0,void 0,function(){var a,s;return v4(this,function(r){switch(r.label){case 0:return t&&t.flipHorizontal&&t.flipHorizontal!==this.selfieMode&&(this.selfieMode=t.flipHorizontal,this.poseSolution.setOptions({selfieMode:this.selfieMode})),e instanceof im?(s=ImageData.bind,[4,ob(e)]):[3,2];case 1:return a=new(s.apply(ImageData,[void 0,r.sent(),e.shape[1],e.shape[0]])),[3,3];case 2:a=e,r.label=3;case 3:return e=a,[4,this.poseSolution.send({image:e},n)];case 4:return r.sent(),[2,this.poses]}})})},e.prototype.dispose=function(){this.poseSolution.close()},e.prototype.reset=function(){this.poseSolution.reset()},e.prototype.initialize=function(){return this.poseSolution.initialize()},e}();function L4(e){return x4(this,void 0,void 0,function(){var t,n;return v4(this,function(a){switch(a.label){case 0:return t=function(e){if(null==e)return b4({},P4);var t=b4({},e);return t.runtime="mediapipe",null==t.enableSegmentation&&(t.enableSegmentation=P4.enableSegmentation),null==t.enableSmoothing&&(t.enableSmoothing=P4.enableSmoothing),null==t.smoothSegmentation&&(t.smoothSegmentation=P4.smoothSegmentation),null==t.modelType&&(t.modelType=P4.modelType),t}(e),[4,(n=new F4(t)).initialize()];case 1:return a.sent(),[2,n]}})})}function z4(e){return e instanceof im?{height:e.shape[0],width:e.shape[1]}:{height:e.height,width:e.width}}function B4(e){return e-2*Math.PI*Math.floor((e+Math.PI)/(2*Math.PI))}function j4(e){return e instanceof im?e:cb(e)}function W4(e,t,n){return V4(n,"inputResolution"),[1/n.width*e[0][0]*t.width,1/n.height*e[0][1]*t.width,e[0][3]*t.width,1/n.width*e[1][0]*t.height,1/n.height*e[1][1]*t.height,e[1][3]*t.height,0,0]}function V4(e,t){yu(0!==e.width,function(){return"".concat(t," width cannot be 0.")}),yu(0!==e.height,function(){return"".concat(t," height cannot be 0.")})}function U4(e,t,n){var a=n.rotationVectorStartKeypointIndex,s=n.rotationVectorEndKeypointIndex,r=e.locationData,i=r.relativeKeypoints[a].x*t.width,o=r.relativeKeypoints[a].y*t.height,c=r.relativeKeypoints[s].x*t.width,l=r.relativeKeypoints[s].y*t.height,u=2*Math.sqrt((c-i)*(c-i)+(l-o)*(l-o)),h=function(e,t,n){var a,s=e.locationData,r=n.rotationVectorStartKeypointIndex,i=n.rotationVectorEndKeypointIndex;a=n.rotationVectorTargetAngle?n.rotationVectorTargetAngle:Math.PI*n.rotationVectorTargetAngleDegree/180;var o=s.relativeKeypoints[r].x*t.width,c=s.relativeKeypoints[r].y*t.height,l=s.relativeKeypoints[i].x*t.width,u=s.relativeKeypoints[i].y*t.height;return B4(a-Math.atan2(-(u-c),l-o))}(e,t,n);return{xCenter:i/t.width,yCenter:o/t.height,width:u/t.width,height:u/t.height,rotation:h}}function H4(e){if(16!==e.length)throw new Error("Array length must be 16 but got ".concat(e.length));return[[e[0],e[1],e[2],e[3]],[e[4],e[5],e[6],e[7]],[e[8],e[9],e[10],e[11]],[e[12],e[13],e[14],e[15]]]}function G4(e,t,n,a,s,r,i){return e[t][s]*(e[n][r]*e[a][i]-e[n][i]*e[a][r])}function q4(e,t,n){var a=(t+1)%4,s=(t+2)%4,r=(t+3)%4,i=(n+1)%4,o=(n+2)%4,c=(n+3)%4;return G4(e,a,s,r,i,o,c)+G4(e,s,r,a,i,o,c)+G4(e,r,a,s,i,o,c)}function K4(e,t,n){void 0===n&&(n={ignoreRotation:!1});for(var a=[],s=0,r=e;s<r.length;s++){var i=r[s],o=i.x-.5,c=i.y-.5,l=n.ignoreRotation?0:t.rotation,u=Math.cos(l)*o-Math.sin(l)*c,h=Math.sin(l)*o+Math.cos(l)*c;u=u*t.width+t.xCenter,h=h*t.height+t.yCenter;var d=i.z*t.width,p=b4({},i);p.x=u,p.y=h,p.z=d,a.push(p)}return a}function X4(e,t){var n=function(e,t,n,a){var s=(a-n)/255;return{scale:s,offset:n-0*s}}(0,0,t[0],t[1]);return Km(function(){return ry(cy(e,n.scale),n.offset)})}function Y4(e,t,n){var a,s,r,i,o,c,l,u,h,d,p,f,m=t.outputTensorSize,g=t.keepAspectRatio,y=t.borderMode,b=t.outputTensorFloatRange,x=z4(e),v=function(e,t){return t?{xCenter:t.xCenter*e.width,yCenter:t.yCenter*e.height,width:t.width*e.width,height:t.height*e.height,rotation:t.rotation}:{xCenter:.5*e.width,yCenter:.5*e.height,width:e.width,height:e.height,rotation:0}}(x,n),w=function(e,t,n){if(void 0===n&&(n=!1),!n)return{top:0,left:0,right:0,bottom:0};var a=t.height,s=t.width;V4(t,"targetSize"),V4(e,"roi");var r,i,o=a/s,c=e.height/e.width,l=0,u=0;return o>c?(r=e.width,i=e.width*o,u=(1-c/o)/2):(r=e.height/o,i=e.height,l=(1-o/c)/2),e.width=r,e.height=i,{top:u,left:l,right:l,bottom:u}}(v,m,g),k=(a=v,s=x.width,r=x.height,i=a.width,o=a.height,c=Math.cos(a.rotation),l=Math.sin(a.rotation),u=a.xCenter,h=a.yCenter,d=1/s,p=1/r,(f=new Array(16))[0]=i*c*1*d,f[1]=-o*l*d,f[2]=0,f[3]=(-.5*i*c*1+.5*o*l+u)*d,f[4]=i*l*1*p,f[5]=o*c*p,f[6]=0,f[7]=(-.5*o*c-.5*i*l*1+h)*p,f[8]=0,f[9]=0,f[10]=i*d,f[11]=0,f[12]=0,f[13]=0,f[14]=0,f[15]=1,H4(f));return{imageTensor:Km(function(){var t=j4(e),n=ok(W4(k,x,m),[1,8]),a="zero"===y?"constant":"nearest",s=US.transform(uv(ny(t,"float32")),n,"bilinear",a,0,[m.height,m.width]);return null!=b?X4(s,b):s}),padding:w,transformationMatrix:k}}function Q4(e,t,n,a){return 1===a?.5*(e+t):e+(t-e)*n/(a-1)}function Z4(e){return null!=e&&null!=e.currentTime}function J4(e){for(var t={locationData:{relativeKeypoints:[]}},n=Number.MAX_SAFE_INTEGER,a=Number.MIN_SAFE_INTEGER,s=Number.MAX_SAFE_INTEGER,r=Number.MIN_SAFE_INTEGER,i=0;i<e.length;++i){var o=e[i];n=Math.min(n,o.x),a=Math.max(a,o.x),s=Math.min(s,o.y),r=Math.max(r,o.y),t.locationData.relativeKeypoints.push({x:o.x,y:o.y})}return t.locationData.relativeBoundingBox={xMin:n,yMin:s,xMax:a,yMax:r,width:a-n,height:r-s},t}function $4(e,t,n,a){return x4(this,void 0,void 0,function(){var a,s,r,i,o;return v4(this,function(c){switch(c.label){case 0:return e.sort(function(e,t){return Math.max.apply(Math,t.score)-Math.max.apply(Math,e.score)}),a=ok(e.map(function(e){return[e.locationData.relativeBoundingBox.yMin,e.locationData.relativeBoundingBox.xMin,e.locationData.relativeBoundingBox.yMax,e.locationData.relativeBoundingBox.xMax]})),s=ik(e.map(function(e){return e.score[0]})),[4,US.nonMaxSuppressionAsync(a,s,t,n)];case 1:return[4,(r=c.sent()).array()];case 2:return i=c.sent(),o=e.filter(function(e,t){return i.indexOf(t)>-1}),Xm([a,s,r]),[2,o]}})})}function e6(e,t){return e.map(function(e){var n=b4(b4({},e),{x:e.x*t.width,y:e.y*t.height});return null!=e.z&&(n.z=e.z*t.width),n})}function t6(e,t,n){return x4(this,void 0,void 0,function(){var a,s,r,i,o,c,l,u,h,d,p,f,m,g,y,b,x,v,w,k,S,C,I,N;return v4(this,function(T){switch(T.label){case 0:if(a=tk(t,[0]),s=a.shape,r=s[0],i=s[1],o=s[2],e.length!==o)throw new Error("Expected heatmap to have same number of channels as the number of landmarks. But got landmarks length: "+"".concat(e.length,", heatmap length: ").concat(o));return c=[],[4,a.buffer()];case 1:for(l=T.sent(),u=0;u<e.length;u++)if(h=e[u],d=b4({},h),c.push(d),p=Math.trunc(d.x*i),f=Math.trunc(d.y*r),!(p<0||p>=i||f<0||p>=r)){for(m=Math.trunc((n.kernelSize-1)/2),g=Math.max(0,p-m),y=Math.min(i,p+m+1),b=Math.max(0,f-m),x=Math.min(r,f+m+1),v=0,w=0,k=0,S=0,C=b;C<x;++C)for(I=g;I<y;++I)N=l.get(C,I,u),v+=N,S=Math.max(S,N),w+=I*N,k+=C*N;S>=n.minConfidenceToRefine&&v>0&&(d.x=w/i/v,d.y=k/r/v)}return a.dispose(),[2,c]}})})}function n6(e,t){var n=t.left,a=t.top,s=t.left+t.right,r=t.top+t.bottom;return e.map(function(e){return b4(b4({},e),{x:(e.x-n)/(1-s),y:(e.y-a)/(1-r),z:e.z/(1-s)})})}function a6(e,t,n){return x4(this,void 0,void 0,function(){var a,s,r,i,o;return v4(this,function(c){switch(c.label){case 0:return a=e[0],s=e[1],r=function(e,t,n){return Km(function(){var a,s,r,i;n.reverseOutputOrder?(s=tk(ox(e,[0,n.boxCoordOffset+0],[-1,1])),a=tk(ox(e,[0,n.boxCoordOffset+1],[-1,1])),i=tk(ox(e,[0,n.boxCoordOffset+2],[-1,1])),r=tk(ox(e,[0,n.boxCoordOffset+3],[-1,1]))):(a=tk(ox(e,[0,n.boxCoordOffset+0],[-1,1])),s=tk(ox(e,[0,n.boxCoordOffset+1],[-1,1])),r=tk(ox(e,[0,n.boxCoordOffset+2],[-1,1])),i=tk(ox(e,[0,n.boxCoordOffset+3],[-1,1]))),s=ry(cy(oy(s,n.xScale),t.w),t.x),a=ry(cy(oy(a,n.yScale),t.h),t.y),n.applyExponentialOnBoxSize?(r=cy(lv(oy(r,n.hScale)),t.h),i=cy(lv(oy(i,n.wScale)),t.w)):(r=cy(oy(r,n.hScale),t.h),i=cy(oy(i,n.wScale),t.h));var o=Cy(a,oy(r,2)),c=Cy(s,oy(i,2)),l=ry(a,oy(r,2)),u=ry(s,oy(i,2)),h=sx([tx(o,[n.numBoxes,1]),tx(c,[n.numBoxes,1]),tx(l,[n.numBoxes,1]),tx(u,[n.numBoxes,1])],1);if(n.numKeypoints)for(var d=0;d<n.numKeypoints;++d){var p=n.keypointCoordOffset+d*n.numValuesPerKeypoint,f=void 0,m=void 0;n.reverseOutputOrder?(f=tk(ox(e,[0,p],[-1,1])),m=tk(ox(e,[0,p+1],[-1,1]))):(m=tk(ox(e,[0,p],[-1,1])),f=tk(ox(e,[0,p+1],[-1,1])));var g=ry(cy(oy(f,n.xScale),t.w),t.x),y=ry(cy(oy(m,n.yScale),t.h),t.y);h=sx([h,tx(g,[n.numBoxes,1]),tx(y,[n.numBoxes,1])],1)}return h})}(s,t,n),i=Km(function(){var e=a;return n.sigmoidScore?(null!=n.scoreClippingThresh&&(e=vx(a,-n.scoreClippingThresh,n.scoreClippingThresh)),e=ix(e)):e}),[4,s6(r,i,n)];case 1:return o=c.sent(),Xm([r,i]),[2,o]}})})}function s6(e,t,n){return x4(this,void 0,void 0,function(){var a,s,r,i,o,c,l,u,h,d,p,f;return v4(this,function(m){switch(m.label){case 0:return a=[],[4,e.data()];case 1:return s=m.sent(),[4,t.data()];case 2:for(r=m.sent(),i=0;i<n.numBoxes;++i)if(!(null!=n.minScoreThresh&&r[i]<n.minScoreThresh||(o=i*n.numCoords,c=r6(s[o+0],s[o+1],s[o+2],s[o+3],r[i],n.flipVertically,i),(l=c.locationData.relativeBoundingBox).width<0||l.height<0))){if(n.numKeypoints>0)for((u=c.locationData).relativeKeypoints=[],h=n.numKeypoints*n.numValuesPerKeypoint,d=0;d<h;d+=n.numValuesPerKeypoint)p=o+n.keypointCoordOffset+d,f={x:s[p+0],y:n.flipVertically?1-s[p+1]:s[p+1]},u.relativeKeypoints.push(f);a.push(c)}return[2,a]}})})}function r6(e,t,n,a,s,r,i){return{score:[s],ind:i,locationData:{relativeBoundingBox:{xMin:t,yMin:r?1-n:e,xMax:a,yMax:r?1-e:n,width:a-t,height:n-e}}}}function i6(e,t){return"none"===e?t:function(e){return 1/(1+Math.exp(-e))}(t)}function o6(e,t,n,a){return x4(this,void 0,void 0,function(){var s,r,i,o,c,l,u,h;return v4(this,function(d){switch(d.label){case 0:return n=n||t.flipHorizontally||!1,a=a||t.flipVertically||!1,s=e.size,r=s/t.numLandmarks,[4,e.data()];case 1:for(i=d.sent(),o=[],c=0;c<t.numLandmarks;++c)l=c*r,(h={x:0,y:0}).x=n?t.inputImageWidth-i[l]:i[l],r>1&&(h.y=a?t.inputImageHeight-i[l+1]:i[l+1]),r>2&&(h.z=i[l+2]),r>3&&(h.score=i6(t.visibilityActivation,i[l+3])),o.push(h);for(u=0;u<o.length;++u)(h=o[u]).x=h.x/t.inputImageWidth,h.y=h.y/t.inputImageHeight,h.z=h.z/t.inputImageWidth/(t.normalizeZ||1);return[2,o]}})})}function c6(e,t,n){var a=e.width,s=e.height,r=e.rotation;if(null==n.rotation&&null==n.rotationDegree||(r=function(e,t){return null!=t.rotation?e+=t.rotation:null!=t.rotationDegree&&(e+=Math.PI*t.rotationDegree/180),B4(e)}(r,n)),0===r)e.xCenter=e.xCenter+a*n.shiftX,e.yCenter=e.yCenter+s*n.shiftY;else{var i=(t.width*a*n.shiftX*Math.cos(r)-t.height*s*n.shiftY*Math.sin(r))/t.width,o=(t.width*a*n.shiftX*Math.sin(r)+t.height*s*n.shiftY*Math.cos(r))/t.height;e.xCenter=e.xCenter+i,e.yCenter=e.yCenter+o}if(n.squareLong){var c=Math.max(a*t.width,s*t.height);a=c/t.width,s=c/t.height}else if(n.squareShort){var l=Math.min(a*t.width,s*t.height);a=l/t.width,s=l/t.height}return e.width=a*n.scaleX,e.height=s*n.scaleY,e}function l6(e,t){return e.map(function(e){var n=b4(b4({},e),{x:e.x/t.width,y:e.y/t.height});return null!=e.z&&(e.z=e.z/t.width),n})}var u6=function(){function e(e){this.alpha=e,this.initialized=!1}return e.prototype.apply=function(e,t){var n;return this.initialized?n=null==t?this.storedValue+this.alpha*(e-this.storedValue):this.storedValue+this.alpha*t*Math.asinh((e-this.storedValue)/t):(n=e,this.initialized=!0),this.rawValue=e,this.storedValue=n,n},e.prototype.applyWithAlpha=function(e,t,n){return this.alpha=t,this.apply(e,n)},e.prototype.hasLastRawValue=function(){return this.initialized},e.prototype.lastRawValue=function(){return this.rawValue},e.prototype.reset=function(){this.initialized=!1},e}(),h6=function(){function e(e){this.frequency=e.frequency,this.minCutOff=e.minCutOff,this.beta=e.beta,this.thresholdCutOff=e.thresholdCutOff,this.thresholdBeta=e.thresholdBeta,this.derivateCutOff=e.derivateCutOff,this.x=new u6(this.getAlpha(this.minCutOff)),this.dx=new u6(this.getAlpha(this.derivateCutOff)),this.lastTimestamp=0}return e.prototype.apply=function(e,t,n){if(null==e)return e;var a=Math.trunc(t);if(this.lastTimestamp>=a)return e;0!==this.lastTimestamp&&0!==a&&(this.frequency=1/(1e-6*(a-this.lastTimestamp))),this.lastTimestamp=a;var s=this.x.hasLastRawValue()?(e-this.x.lastRawValue())*n*this.frequency:0,r=this.dx.applyWithAlpha(s,this.getAlpha(this.derivateCutOff)),i=this.minCutOff+this.beta*Math.abs(r),o=null!=this.thresholdCutOff?this.thresholdCutOff+this.thresholdBeta*Math.abs(r):null;return this.x.applyWithAlpha(e,this.getAlpha(i),o)},e.prototype.getAlpha=function(e){return 1/(1+this.frequency/(2*Math.PI*e))},e}(),d6=function(){function e(e){this.config=e}return e.prototype.apply=function(e,t,n){var a=this;if(null==e)return this.reset(),null;this.initializeFiltersIfEmpty(e);var s=1;if(!this.config.disableValueScaling){if(n<this.config.minAllowedObjectScale)return w4([],e,!0);s=1/n}return e.map(function(e,n){var r=b4(b4({},e),{x:a.xFilters[n].apply(e.x,t,s),y:a.yFilters[n].apply(e.y,t,s)});return null!=e.z&&(r.z=a.zFilters[n].apply(e.z,t,s)),r})},e.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},e.prototype.initializeFiltersIfEmpty=function(e){var t=this;null!=this.xFilters&&this.xFilters.length===e.length||(this.xFilters=e.map(function(e){return new h6(t.config)}),this.yFilters=e.map(function(e){return new h6(t.config)}),this.zFilters=e.map(function(e){return new h6(t.config)}))},e}(),p6=function(){function e(e){this.config=e,this.window=[],this.lowPassFilter=new u6(1),this.lastValue=0,this.lastValueScale=1,this.lastTimestamp=-1}return e.prototype.apply=function(e,t,n){if(null==e)return e;var a,s=Math.trunc(t);if(this.lastTimestamp>=s)return e;if(-1===this.lastTimestamp)a=1;else{for(var r=e*n-this.lastValue*this.lastValueScale,i=s-this.lastTimestamp,o=r,c=i,l=(1+this.window.length)*(1e6/30),u=0,h=this.window;u<h.length;u++){var d=h[u];if(c+d.duration>l)break;o+=d.distance,c+=d.duration}var p=o/(1e-6*c);a=1-1/(1+this.config.velocityScale*Math.abs(p)),this.window.unshift({distance:r,duration:i}),this.window.length>this.config.windowSize&&this.window.pop()}return this.lastValue=e,this.lastValueScale=n,this.lastTimestamp=s,this.lowPassFilter.applyWithAlpha(e,a)},e}(),f6=function(){function e(e){this.config=e}return e.prototype.apply=function(e,t,n){var a=this;if(null==e)return this.reset(),null;var s=1;if(!this.config.disableValueScaling){if(n<this.config.minAllowedObjectScale)return w4([],e,!0);s=1/n}return this.initializeFiltersIfEmpty(e),e.map(function(e,n){var r=b4(b4({},e),{x:a.xFilters[n].apply(e.x,t,s),y:a.yFilters[n].apply(e.y,t,s)});return null!=e.z&&(r.z=a.zFilters[n].apply(e.z,t,s)),r})},e.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},e.prototype.initializeFiltersIfEmpty=function(e){var t=this;null!=this.xFilters&&this.xFilters.length===e.length||(this.xFilters=e.map(function(e){return new p6(t.config)}),this.yFilters=e.map(function(e){return new p6(t.config)}),this.zFilters=e.map(function(e){return new p6(t.config)}))},e}(),m6=function(){function e(e){if(null!=e.velocityFilter)this.keypointsFilter=new f6(e.velocityFilter);else{if(null==e.oneEuroFilter)throw new Error("Either configure velocityFilter or oneEuroFilter, but got "+"".concat(e,"."));this.keypointsFilter=new d6(e.oneEuroFilter)}}return e.prototype.apply=function(e,t,n,a,s){if(void 0===a&&(a=!1),null==e)return this.keypointsFilter.reset(),null;var r=null!=s?function(e,t){return(e.width*t.width+e.height*t.height)/2}(s,n):1,i=a?e6(e,n):e,o=this.keypointsFilter.apply(i,t,r);return a?l6(o,n):o},e}(),g6=function(){function e(e){this.alpha=e.alpha}return e.prototype.apply=function(e){var t=this;if(null==e)return this.visibilityFilters=null,null;null!=this.visibilityFilters&&this.visibilityFilters.length===e.length||(this.visibilityFilters=e.map(function(e){return new u6(t.alpha)}));for(var n=[],a=0;a<e.length;++a){var s=e[a],r=b4({},s);r.score=this.visibilityFilters[a].apply(s.score),n.push(r)}return n},e}(),y6={reduceBoxesInLowestlayer:!1,interpolatedScaleAspectRatio:1,featureMapHeight:[],featureMapWidth:[],numLayers:5,minScale:.1484375,maxScale:.75,inputSizeHeight:224,inputSizeWidth:224,anchorOffsetX:.5,anchorOffsetY:.5,strides:[8,16,32,32,32],aspectRatios:[1],fixedAnchorSize:!0},b6={runtime:"tfjs",modelType:"full",enableSmoothing:!0,enableSegmentation:!1,smoothSegmentation:!0,detectorModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/detector/1",landmarkModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/full/2"},x6={maxPoses:1,flipHorizontal:!1},v6={applyExponentialOnBoxSize:!1,flipVertically:!1,ignoreClasses:[],numClasses:1,numBoxes:2254,numCoords:12,boxCoordOffset:0,keypointCoordOffset:4,numKeypoints:4,numValuesPerKeypoint:2,sigmoidScore:!0,scoreClippingThresh:100,reverseOutputOrder:!0,xScale:224,yScale:224,hScale:224,wScale:224,minScoreThresh:.5},w6={shiftX:0,shiftY:0,scaleX:1.25,scaleY:1.25,squareLong:!0},k6={outputTensorSize:{width:224,height:224},keepAspectRatio:!0,outputTensorFloatRange:[-1,1],borderMode:"zero"},S6={outputTensorSize:{width:256,height:256},keepAspectRatio:!0,outputTensorFloatRange:[0,1],borderMode:"zero"},C6={numLandmarks:39,inputImageWidth:256,inputImageHeight:256,visibilityActivation:"sigmoid",flipHorizontally:!1,flipVertically:!1},I6={numLandmarks:39,inputImageWidth:1,inputImageHeight:1,visibilityActivation:"sigmoid",flipHorizontally:!1,flipVertically:!1},N6={kernelSize:7,minConfidenceToRefine:.5},T6={alpha:.1},E6={oneEuroFilter:{frequency:30,minCutOff:.05,beta:80,derivateCutOff:1,minAllowedObjectScale:1e-6}},R6={oneEuroFilter:{frequency:30,minCutOff:.01,beta:10,derivateCutOff:1,minAllowedObjectScale:1e-6}},_6={oneEuroFilter:{frequency:30,minCutOff:.1,beta:40,derivateCutOff:1,minAllowedObjectScale:1e-6,disableValueScaling:!0}},A6={activation:"none"},M6={combineWithPreviousRatio:.7},P6=function(){function e(e){this.mask=e}return e.prototype.toCanvasImageSource=function(){return x4(this,void 0,void 0,function(){return v4(this,function(e){return[2,R4(this.mask)]})})},e.prototype.toImageData=function(){return x4(this,void 0,void 0,function(){return v4(this,function(e){return[2,_4(this.mask)]})})},e.prototype.toTensor=function(){return x4(this,void 0,void 0,function(){return v4(this,function(e){return[2,this.mask]})})},e.prototype.getUnderlyingType=function(){return"tensor"},e}();function D6(e){return M4(e),"person"}var O6=function(){function e(e,t,n,a,s,r){this.detectorModel=e,this.landmarkModel=t,this.enableSmoothing=n,this.enableSegmentation=a,this.smoothSegmentation=s,this.modelType=r,this.regionOfInterest=null,this.prevFilteredSegmentationMask=null,this.anchors=function(e){null==e.reduceBoxesInLowestLayer&&(e.reduceBoxesInLowestLayer=!1),null==e.interpolatedScaleAspectRatio&&(e.interpolatedScaleAspectRatio=1),null==e.fixedAnchorSize&&(e.fixedAnchorSize=!1);for(var t=[],n=0;n<e.numLayers;){for(var a=[],s=[],r=[],i=[],o=n;o<e.strides.length&&e.strides[o]===e.strides[n];){var c=Q4(e.minScale,e.maxScale,o,e.strides.length);if(0===o&&e.reduceBoxesInLowestLayer)r.push(1),r.push(2),r.push(.5),i.push(.1),i.push(c),i.push(c);else{for(var l=0;l<e.aspectRatios.length;++l)r.push(e.aspectRatios[l]),i.push(c);if(e.interpolatedScaleAspectRatio>0){var u=o===e.strides.length-1?1:Q4(e.minScale,e.maxScale,o+1,e.strides.length);i.push(Math.sqrt(c*u)),r.push(e.interpolatedScaleAspectRatio)}}o++}for(var h=0;h<r.length;++h){var d=Math.sqrt(r[h]);a.push(i[h]/d),s.push(i[h]*d)}var p=0,f=0;if(e.featureMapHeight.length>0)p=e.featureMapHeight[n],f=e.featureMapWidth[n];else{var m=e.strides[n];p=Math.ceil(e.inputSizeHeight/m),f=Math.ceil(e.inputSizeWidth/m)}for(var g=0;g<p;++g)for(var y=0;y<f;++y)for(var b=0;b<a.length;++b){var x={xCenter:(y+e.anchorOffsetX)/f,yCenter:(g+e.anchorOffsetY)/p,width:0,height:0};e.fixedAnchorSize?(x.width=1,x.height=1):(x.width=s[b],x.height=a[b]),t.push(x)}n=o}return t}(y6);var i=ik(this.anchors.map(function(e){return e.width})),o=ik(this.anchors.map(function(e){return e.height})),c=ik(this.anchors.map(function(e){return e.xCenter})),l=ik(this.anchors.map(function(e){return e.yCenter}));this.anchorTensor={x:c,y:l,w:i,h:o},this.prevFilteredSegmentationMask=this.enableSegmentation?ok([],[0,0]):null}return e.prototype.estimatePoses=function(e,t,n){return x4(this,void 0,void 0,function(){var a,s,r,i,o,c,l,u,h,d,p,f,m,g,y,b,x,v,w,k,S,C,I;return v4(this,function(N){switch(N.label){case 0:return a=function(e){var t;if(null==(t=null==e?x6:b4({},e)).maxPoses&&(t.maxPoses=1),t.maxPoses<=0)throw new Error("Invalid maxPoses ".concat(t.maxPoses,". Should be > 0."));if(t.maxPoses>1)throw new Error("Multi-pose detection is not implemented yet. Please set maxPoses to 1.");return t}(t),null==e?(this.reset(),[2,[]]):(this.maxPoses=a.maxPoses,this.timestamp=null!=n?1e3*n:Z4(e)?1e6*e.currentTime:null,s=z4(e),r=Km(function(){return ny(j4(e),"float32")}),null!=(i=this.regionOfInterest)?[3,2]:[4,this.detectPose(r)]);case 1:if(0===(o=N.sent()).length)return this.reset(),r.dispose(),[2,[]];c=o[0],i=this.poseDetectionToRoi(c,s),N.label=2;case 2:return[4,this.poseLandmarksByRoi(i,r)];case 3:return l=N.sent(),r.dispose(),null==l?(this.reset(),[2,[]]):(u=l.landmarks,h=l.auxiliaryLandmarks,d=l.poseScore,p=l.worldLandmarks,f=l.segmentationMask,m=this.poseLandmarkFiltering(u,h,p,s),g=m.actualLandmarksFiltered,y=m.auxiliaryLandmarksFiltered,b=m.actualWorldLandmarksFiltered,x=this.poseLandmarksToRoi(y,s),this.regionOfInterest=x,v=this.smoothSegmentation&&null!=f?this.poseSegmentationFiltering(f):f,null!=(w=null!=g?e6(g,s):null)&&w.forEach(function(e,t){e.name=S4[t]}),null!=(k=b)&&k.forEach(function(e,t){e.name=S4[t]}),S={score:d,keypoints:w,keypoints3D:k},null!==v&&(C=Km(function(){var e=uv(v,2),t=sw(e,[[0,0],[0,0],[0,1]]);return Yv(t,[[0,0],[0,0],[0,2]],"symmetric")}),this.smoothSegmentation||Xm(v),I={maskValueToLabel:D6,mask:new P6(C)},S.segmentation=I),[2,[S]])}})})},e.prototype.poseSegmentationFiltering=function(e){var t=this.prevFilteredSegmentationMask;return 0===t.size?this.prevFilteredSegmentationMask=e:(this.prevFilteredSegmentationMask=function(e,t,n){return"webgl"===Qm()?function(e,t,n){var a=n.combineWithPreviousRatio.toFixed(2),s={variableNames:["prevMask","newMask"],outputShape:e.shape,userCode:"\n  void main() {\n      ivec2 coords = getOutputCoords();\n      int height = coords[0];\n      int width = coords[1];\n\n      float prevMaskValue = getPrevMask(height, width);\n      float newMaskValue = getNewMask(height, width);\n\n      /*\n      * Assume p := newMaskValue\n      * H(p) := 1 + (p * log(p) + (1-p) * log(1-p)) / log(2)\n      * uncertainty alpha(p) =\n      *   Clamp(1 - (1 - H(p)) * (1 - H(p)), 0, 1) [squaring the\n      * uncertainty]\n      *\n      * The following polynomial approximates uncertainty alpha as a\n      * function of (p + 0.5):\n      */\n      const float c1 = 5.68842;\n      const float c2 = -0.748699;\n      const float c3 = -57.8051;\n      const float c4 = 291.309;\n      const float c5 = -624.717;\n      float t = newMaskValue - 0.5;\n      float x = t * t;\n\n      float uncertainty =\n        1.0 - min(1.0, x * (c1 + x * (c2 + x * (c3 + x * (c4 + x * c5)))));\n\n      float outputValue = newMaskValue + (prevMaskValue - newMaskValue) *\n                             (uncertainty * ".concat(a,");\n\n      setOutput(outputValue);\n    }\n")},r=Jm();return Km(function(){var n=r.compileAndRun(s,[e,t]);return Gm().makeTensorFromDataId(n.dataId,n.shape,n.dtype)})}(e,t,n):Km(function(){var a=Cy(t,.5),s=uy(a),r=Cy(1,Xv(1,cy(s,ry(5.68842,cy(s,ry(-.748699,cy(s,ry(-57.8051,cy(s,ry(291.309,cy(s,-624.717)))))))))));return ry(t,cy(Cy(e,t),cy(r,n.combineWithPreviousRatio)))})}(t,e,M6),Xm(e)),Xm(t),this.prevFilteredSegmentationMask},e.prototype.dispose=function(){this.detectorModel.dispose(),this.landmarkModel.dispose(),Xm([this.anchorTensor.x,this.anchorTensor.y,this.anchorTensor.w,this.anchorTensor.h,this.prevFilteredSegmentationMask])},e.prototype.reset=function(){this.regionOfInterest=null,this.enableSegmentation&&(Xm(this.prevFilteredSegmentationMask),this.prevFilteredSegmentationMask=ok([],[0,0])),this.visibilitySmoothingFilterActual=null,this.visibilitySmoothingFilterAuxiliary=null,this.landmarksSmoothingFilterActual=null,this.landmarksSmoothingFilterAuxiliary=null},e.prototype.detectPose=function(e){return x4(this,void 0,void 0,function(){var t,n,a,s,r,i,o,c,l,u;return v4(this,function(h){switch(h.label){case 0:return t=Y4(e,k6),n=t.imageTensor,a=t.padding,s=this.detectorModel.predict(n),r=function(e){return Km(function(){var t=function(e){return Km(function(){return[ox(e,[0,0,0],[1,-1,1]),ox(e,[0,0,1],[1,-1,-1])]})}(e),n=t[0],a=t[1];return{boxes:tk(a),logits:tk(n)}})}(s),i=r.boxes,[4,a6([o=r.logits,i],this.anchorTensor,v6)];case 1:return 0===(c=h.sent()).length?(Xm([n,s,o,i]),[2,c]):[4,$4(c,this.maxPoses,.3)];case 2:return l=h.sent(),u=function(e,t){void 0===e&&(e=[]);for(var n=t.left,a=t.top,s=t.left+t.right,r=t.top+t.bottom,i=0;i<e.length;i++){var o=e[i],c=o.locationData.relativeBoundingBox,l=(c.xMin-n)/(1-s),u=(c.yMin-a)/(1-r),h=c.width/(1-s),d=c.height/(1-r);c.xMin=l,c.yMin=u,c.width=h,c.height=d,c.xMax=l+h,c.yMax=u+d;var p=o.locationData.relativeKeypoints;p&&p.forEach(function(e){var t=(e.x-n)/(1-s),i=(e.y-a)/(1-r);e.x=t,e.y=i})}return e}(l,a),Xm([n,s,o,i]),[2,u]}})})},e.prototype.poseDetectionToRoi=function(e,t){return c6(U4(e,t,{rotationVectorEndKeypointIndex:1,rotationVectorStartKeypointIndex:0,rotationVectorTargetAngleDegree:90}),t,w6)},e.prototype.poseLandmarksByRoi=function(e,t){return x4(this,void 0,void 0,function(){var n,a,s,r,i,o,c,l,u,h,d,p,f,m;return v4(this,function(g){switch(g.label){case 0:if(n=z4(t),a=Y4(t,S6,e),s=a.imageTensor,r=a.padding,i=a.transformationMatrix,"lite"!==this.modelType&&"full"!==this.modelType&&"heavy"!==this.modelType)throw new Error("Model type must be one of lite, full or heavy,"+"but got ".concat(this.modelType));return o=["ld_3d","output_poseflag","activation_heatmap","world_3d"],this.enableSegmentation&&o.push("activation_segmentation"),c=this.landmarkModel.execute(s,o),[4,this.tensorsToPoseLandmarksAndSegmentation(c)];case 1:return null==(l=g.sent())?(Xm(c),Xm(s),[2,null]):(u=l.landmarks,h=l.auxiliaryLandmarks,d=l.poseScore,p=l.worldLandmarks,f=l.segmentationMask,[4,this.poseLandmarksAndSegmentationInverseProjection(n,e,r,i,u,h,p,f)]);case 2:return m=g.sent(),Xm(c),Xm(s),[2,b4({poseScore:d},m)]}})})},e.prototype.poseLandmarksAndSegmentationInverseProjection=function(e,t,n,a,s,r,i,o){return x4(this,void 0,void 0,function(){var c,l,u,h,d,p;return v4(this,function(f){return c=n6(s,n),l=n6(r,n),u=K4(c,t),h=K4(l,t),d=function(e,t){for(var n=[],a=0,s=e;a<s.length;a++){var r=s[a],i=r.x,o=r.y,c=t.rotation,l=Math.cos(c)*i-Math.sin(c)*o,u=Math.sin(c)*i+Math.cos(c)*o,h=b4({},r);h.x=l,h.y=u,n.push(h)}return n}(i,t),p=null,this.enableSegmentation&&(p=Km(function(){var t=o.shape,n=t[0],s=t[1],r=function(e){var t=H4(new Array(16).fill(0));t[0][0]=q4(e,0,0),t[1][0]=-q4(e,0,1),t[2][0]=q4(e,0,2),t[3][0]=-q4(e,0,3),t[0][2]=q4(e,2,0),t[1][2]=-q4(e,2,1),t[2][2]=q4(e,2,2),t[3][2]=-q4(e,2,3),t[0][1]=-q4(e,1,0),t[1][1]=q4(e,1,1),t[2][1]=-q4(e,1,2),t[3][1]=q4(e,1,3),t[0][3]=-q4(e,3,0),t[1][3]=q4(e,3,1),t[2][3]=-q4(e,3,2),t[3][3]=q4(e,3,3);for(var n=e[0][0]*t[0][0]+e[1][0]*t[0][1]+e[2][0]*t[0][2]+e[3][0]*t[0][3],a=0;a<t.length;a++)for(var s=0;s<t.length;s++)t[a][s]/=n;return t}(a),i=ok(W4(r,{width:s,height:n},e),[1,8]),c=[1,n,s,1];return tk(US.transform(tx(o,c),i,"bilinear","constant",0,[e.height,e.width]),[0,3])}),Xm(o)),[2,{landmarks:u,auxiliaryLandmarks:h,worldLandmarks:d,segmentationMask:p}]})})},e.prototype.tensorsToPoseLandmarksAndSegmentation=function(e){return x4(this,void 0,void 0,function(){var t,n,a,s,r,i,o,c,l,u,h,d,p;return v4(this,function(f){switch(f.label){case 0:return t=e[0],n=e[1],a=e[2],s=e[3],r=this.enableSegmentation?e[4]:null,[4,n.data()];case 1:return(i=f.sent()[0])<.5?[2,null]:[4,o6(t,C6)];case 2:return[4,t6(f.sent(),a,N6)];case 3:return o=f.sent(),c=o.slice(0,33),l=o.slice(33,35),[4,o6(s,I6)];case 4:return u=f.sent(),h=u.slice(0,33),d=function(e,t,n){void 0===n&&(n=!0);for(var a=[],s=0;s<e.length;s++){var r=b4({},t[s]);n&&(r.score=e[s].score),a.push(r)}return a}(c,h,!0),p=this.enableSegmentation?function(e,t){return Km(function(){var n=tk(e,[0]),a=n.shape[2];if(1===a){var s=n;switch(t.activation){case"none":break;case"sigmoid":s=ix(s);break;case"softmax":throw new Error("Softmax activation requires two channels.");default:throw new Error("Activation not supported (".concat(t.activation,")"))}return tk(s,[2])}throw new Error("Unsupported number of tensor channels ".concat(a))})}(r,A6):null,[2,{landmarks:c,auxiliaryLandmarks:l,poseScore:i,worldLandmarks:d,segmentationMask:p}]}})})},e.prototype.poseLandmarksToRoi=function(e,t){return c6(U4(J4(e),t,{rotationVectorStartKeypointIndex:0,rotationVectorEndKeypointIndex:1,rotationVectorTargetAngleDegree:90}),t,w6)},e.prototype.poseLandmarkFiltering=function(e,t,n,a){var s,r,i;if(null!=this.timestamp&&this.enableSmoothing){var o=U4(J4(t),a,{rotationVectorEndKeypointIndex:0,rotationVectorStartKeypointIndex:1,rotationVectorTargetAngleDegree:90});null==this.visibilitySmoothingFilterActual&&(this.visibilitySmoothingFilterActual=new g6(T6)),s=this.visibilitySmoothingFilterActual.apply(e),null==this.visibilitySmoothingFilterAuxiliary&&(this.visibilitySmoothingFilterAuxiliary=new g6(T6)),r=this.visibilitySmoothingFilterAuxiliary.apply(t),i=this.visibilitySmoothingFilterActual.apply(n),null==this.landmarksSmoothingFilterActual&&(this.landmarksSmoothingFilterActual=new m6(E6)),s=this.landmarksSmoothingFilterActual.apply(s,this.timestamp,a,!0,o),null==this.landmarksSmoothingFilterAuxiliary&&(this.landmarksSmoothingFilterAuxiliary=new m6(R6)),r=this.landmarksSmoothingFilterAuxiliary.apply(r,this.timestamp,a,!0,o),null==this.worldLandmarksSmoothingFilterActual&&(this.worldLandmarksSmoothingFilterActual=new m6(_6)),i=this.worldLandmarksSmoothingFilterActual.apply(n,this.timestamp)}else s=e,r=t,i=n;return{actualLandmarksFiltered:s,auxiliaryLandmarksFiltered:r,actualWorldLandmarksFiltered:i}},e}();function F6(e){return x4(this,void 0,void 0,function(){var t,n,a,s,r,i;return v4(this,function(o){switch(o.label){case 0:return t=function(e){var t=b4({},null==e?b6:e);if(null==t.enableSmoothing&&(t.enableSmoothing=b6.enableSmoothing),null==t.enableSegmentation&&(t.enableSegmentation=b6.enableSegmentation),null==t.smoothSegmentation&&(t.smoothSegmentation=b6.smoothSegmentation),null==t.modelType&&(t.modelType=b6.modelType),null==t.detectorModelUrl&&(t.detectorModelUrl=b6.detectorModelUrl),null==t.landmarkModelUrl)switch(t.modelType){case"lite":t.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/lite/2";break;case"heavy":t.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/heavy/2";break;default:t.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/full/2"}return t}(e),n="string"==typeof t.detectorModelUrl&&t.detectorModelUrl.indexOf("https://tfhub.dev")>-1,a="string"==typeof t.landmarkModelUrl&&t.landmarkModelUrl.indexOf("https://tfhub.dev")>-1,[4,Promise.all([DP(t.detectorModelUrl,{fromTFHub:n}),DP(t.landmarkModelUrl,{fromTFHub:a})])];case 1:return s=o.sent(),r=s[0],i=s[1],[2,new O6(r,i,t.enableSmoothing,t.enableSegmentation,t.smoothSegmentation,t.modelType)]}})})}var L6,z6,B6,j6=function(){function e(e){!function(e){if(e.maxTracks<1)throw new Error("Must specify 'maxTracks' to be at least 1, but "+"encountered ".concat(e.maxTracks));if(e.maxAge<=0)throw new Error("Must specify 'maxAge' to be positive, but "+"encountered ".concat(e.maxAge));if(void 0!==e.keypointTrackerParams){if(e.keypointTrackerParams.keypointConfidenceThreshold<0||e.keypointTrackerParams.keypointConfidenceThreshold>1)throw new Error("Must specify 'keypointConfidenceThreshold' to be in the range [0, 1], but encountered "+"".concat(e.keypointTrackerParams.keypointConfidenceThreshold));if(e.keypointTrackerParams.minNumberOfKeypoints<1)throw new Error("Must specify 'minNumberOfKeypoints' to be at least 1, but "+"encountered ".concat(e.keypointTrackerParams.minNumberOfKeypoints));for(var t=0,n=e.keypointTrackerParams.keypointFalloff;t<n.length;t++){var a=n[t];if(a<=0)throw new Error("Must specify each keypoint falloff parameterto be positive "+"but encountered ".concat(a))}}}(e),this.tracks=[],this.maxTracks=e.maxTracks,this.maxAge=1e3*e.maxAge,this.minSimilarity=e.minSimilarity,this.nextID=1}return e.prototype.apply=function(e,t){this.filterOldTracks(t);var n=this.computeSimilarity(e);return this.assignTracks(e,n,t),this.updateTracks(t),e},e.prototype.getTracks=function(){return this.tracks.slice()},e.prototype.getTrackIDs=function(){return new Set(this.tracks.map(function(e){return e.id}))},e.prototype.filterOldTracks=function(e){var t=this;this.tracks=this.tracks.filter(function(n){return e-n.lastTimestamp<=t.maxAge})},e.prototype.assignTracks=function(e,t,n){for(var a=Array.from(Array(t[0].length).keys()),s=[],r=0,i=Array.from(Array(e.length).keys());r<i.length;r++){var o=i[r];if(0!==a.length){for(var c=-1,l=-1,u=0,h=a;u<h.length;u++){var d=h[u],p=t[o][d];p>=this.minSimilarity&&p>l&&(c=d,l=p)}if(c>=0){var f=this.tracks[c];f=Object.assign(f,this.createTrack(e[o],n,f.id)),e[o].id=f.id;var m=a.indexOf(c);a.splice(m,1)}else s.push(o)}else s.push(o)}for(var g=0,y=s;g<y.length;g++){o=y[g];var b=this.createTrack(e[o],n);this.tracks.push(b),e[o].id=b.id}},e.prototype.updateTracks=function(e){this.tracks.sort(function(e,t){return t.lastTimestamp-e.lastTimestamp}),this.tracks=this.tracks.slice(0,this.maxTracks)},e.prototype.createTrack=function(e,t,n){var a={id:n||this.nextTrackID(),lastTimestamp:t,keypoints:w4([],e.keypoints,!0).map(function(e){return b4({},e)})};return void 0!==e.box&&(a.box=b4({},e.box)),a},e.prototype.nextTrackID=function(){var e=this.nextID;return this.nextID+=1,e},e.prototype.remove=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];this.tracks=this.tracks.filter(function(t){return!e.includes(t.id)})},e.prototype.reset=function(){this.tracks=[]},e}(),W6=function(e){function t(t){return e.call(this,t)||this}return y4(t,e),t.prototype.computeSimilarity=function(e){var t=this;return 0===e.length||0===this.tracks.length?[[]]:e.map(function(e){return t.tracks.map(function(n){return t.iou(e,n)})})},t.prototype.iou=function(e,t){var n=Math.max(e.box.xMin,t.box.xMin),a=Math.max(e.box.yMin,t.box.yMin),s=Math.min(e.box.xMax,t.box.xMax),r=Math.min(e.box.yMax,t.box.yMax);if(n>=s||a>=r)return 0;var i=(s-n)*(r-a);return i/(e.box.width*e.box.height+t.box.width*t.box.height-i)},t}(j6),V6=function(e){function t(t){var n=e.call(this,t)||this;return n.keypointThreshold=t.keypointTrackerParams.keypointConfidenceThreshold,n.keypointFalloff=t.keypointTrackerParams.keypointFalloff,n.minNumKeyoints=t.keypointTrackerParams.minNumberOfKeypoints,n}return y4(t,e),t.prototype.computeSimilarity=function(e){if(0===e.length||0===this.tracks.length)return[[]];for(var t=[],n=0,a=e;n<a.length;n++){for(var s=a[n],r=[],i=0,o=this.tracks;i<o.length;i++){var c=o[i];r.push(this.oks(s,c))}t.push(r)}return t},t.prototype.oks=function(e,t){for(var n=this.area(t.keypoints)+1e-6,a=0,s=0,r=0;r<e.keypoints.length;++r){var i=e.keypoints[r],o=t.keypoints[r];if(!(i.score<this.keypointThreshold||o.score<this.keypointThreshold)){s+=1;var c=Math.pow(i.x-o.x,2)+Math.pow(i.y-o.y,2),l=2*this.keypointFalloff[r];a+=Math.exp(-1*c/(2*n*Math.pow(l,2)))}}return s<this.minNumKeyoints?0:a/s},t.prototype.area=function(e){var t=this,n=e.filter(function(e){return e.score>t.keypointThreshold}),a=Math.min.apply(Math,w4([1],n.map(function(e){return e.x}),!1)),s=Math.max.apply(Math,w4([0],n.map(function(e){return e.x}),!1)),r=Math.min.apply(Math,w4([1],n.map(function(e){return e.y}),!1));return(s-a)*(Math.max.apply(Math,w4([0],n.map(function(e){return e.y}),!1))-r)},t}(j6);function U6(e){switch(e){case z6.BlazePose:return S4.reduce(function(e,t,n){return e[t]=n,e},{});case z6.PoseNet:case z6.MoveNet:return k4.reduce(function(e,t,n){return e[t]=n,e},{});default:throw new Error("Model ".concat(e," is not supported."))}}(B6=L6||(L6={})).Keypoint="keypoint",B6.BoundingBox="boundingBox",function(e){e.MoveNet="MoveNet",e.BlazePose="BlazePose",e.PoseNet="PoseNet"}(z6||(z6={}));Object.freeze({__proto__:null,getKeypointIndexBySide:function(e){switch(e){case z6.BlazePose:return C4;case z6.PoseNet:case z6.MoveNet:return I4;default:throw new Error("Model ".concat(e," is not supported."))}},getAdjacentPairs:function(e){switch(e){case z6.BlazePose:return T4;case z6.PoseNet:case z6.MoveNet:return N4;default:throw new Error("Model ".concat(e," is not supported."))}},getKeypointIndexByName:U6});var H6=["SinglePose.Lightning","SinglePose.Thunder","MultiPose.Lightning"],G6={modelType:"SinglePose.Lightning",enableSmoothing:!0},q6={},K6={frequency:30,minCutOff:2.5,beta:300,derivateCutOff:2.5,thresholdCutOff:.5,thresholdBeta:5,disableValueScaling:!0},X6={maxTracks:18,maxAge:1e3,minSimilarity:.2,keypointTrackerParams:{keypointConfidenceThreshold:.3,keypointFalloff:[.026,.025,.025,.035,.035,.079,.079,.072,.072,.062,.062,.107,.107,.087,.087,.089,.089],minNumberOfKeypoints:4}},Y6={maxTracks:18,maxAge:1e3,minSimilarity:.15,trackerParams:{}};function Q6(e,t){var n,a,s,r;return e?t.width>t.height?(n=1,a=t.height/t.width,s=0,r=(t.width/2-t.height/2)/t.width):(n=t.width/t.height,a=1,s=(t.height/2-t.width/2)/t.height,r=0):t.width>t.height?(n=t.width/t.height,a=1,s=(t.height/2-t.width/2)/t.height,r=0):(n=1,a=t.height/t.width,s=0,r=(t.width/2-t.height/2)/t.width),{yMin:s,xMin:r,yMax:s+n,xMax:r+a,height:n,width:a}}function Z6(e,t){var n={maxTracks:e.maxTracks,maxAge:e.maxAge,minSimilarity:e.minSimilarity};return null!=t.maxTracks&&(n.maxTracks=t.maxTracks),null!=t.maxAge&&(n.maxAge=t.maxAge),null!=t.minSimilarity&&(n.minSimilarity=t.minSimilarity),n}var J6=function(){function e(e,t){this.moveNetModel=e,this.modelInputResolution={height:0,width:0},this.keypointIndexByName=U6(z6.MoveNet),"SinglePose.Lightning"===t.modelType?(this.modelInputResolution.width=192,this.modelInputResolution.height=192):"SinglePose.Thunder"===t.modelType&&(this.modelInputResolution.width=256,this.modelInputResolution.height=256),this.multiPoseModel="MultiPose.Lightning"===t.modelType,this.multiPoseModel||(this.keypointFilter=new d6(K6),this.cropRegionFilterYMin=new u6(.9),this.cropRegionFilterXMin=new u6(.9),this.cropRegionFilterYMax=new u6(.9),this.cropRegionFilterXMax=new u6(.9)),this.enableSmoothing=t.enableSmoothing,t.minPoseScore?this.minPoseScore=t.minPoseScore:this.minPoseScore=.25,t.multiPoseMaxDimension?this.multiPoseMaxDimension=t.multiPoseMaxDimension:this.multiPoseMaxDimension=256,this.enableTracking=t.enableTracking,this.multiPoseModel&&this.enableTracking&&(t.trackerType===L6.Keypoint?this.tracker=new V6(t.trackerConfig):t.trackerType===L6.BoundingBox&&(this.tracker=new W6(t.trackerConfig)),this.enableSmoothing&&(this.keypointFilterMap=new Map))}return e.prototype.runSinglePersonPoseModel=function(e){return x4(this,void 0,void 0,function(){var t,n,a,s,r;return v4(this,function(i){switch(i.label){case 0:if(4!==(t=this.moveNetModel.execute(e)).shape.length||1!==t.shape[0]||1!==t.shape[1]||17!==t.shape[2]||3!==t.shape[3])throw t.dispose(),new Error("Unexpected output shape from model: [".concat(t.shape,"]"));return"webgpu"===Qm()?[3,1]:(n=t.dataSync(),[3,3]);case 1:return[4,t.data()];case 2:n=i.sent(),i.label=3;case 3:for(t.dispose(),a={keypoints:[],score:0},s=0,r=0;r<17;++r)a.keypoints[r]={y:n[3*r],x:n[3*r+1],score:n[3*r+2]},a.keypoints[r].score>.2&&(++s,a.score+=a.keypoints[r].score);return s>0&&(a.score/=s),[2,a]}})})},e.prototype.runMultiPersonPoseModel=function(e){return x4(this,void 0,void 0,function(){var t,n,a,s,r,i,o,c;return v4(this,function(l){switch(l.label){case 0:if(3!==(t=this.moveNetModel.execute(e)).shape.length||1!==t.shape[0]||56!==t.shape[2])throw t.dispose(),new Error("Unexpected output shape from model: [".concat(t.shape,"]"));return"webgpu"===Qm()?[3,1]:(n=t.dataSync(),[3,3]);case 1:return[4,t.data()];case 2:n=l.sent(),l.label=3;case 3:for(t.dispose(),a=[],s=n.length/56,r=0;r<s;++r)for(a[r]={keypoints:[]},i=56*r+51,a[r].box={yMin:n[i],xMin:n[i+1],yMax:n[i+2],xMax:n[i+3],width:n[i+3]-n[i+1],height:n[i+2]-n[i]},o=56*r+55,a[r].score=n[o],a[r].keypoints=[],c=0;c<17;++c)a[r].keypoints[c]={y:n[56*r+3*c],x:n[56*r+3*c+1],score:n[56*r+3*c+2]};return[2,a]}})})},e.prototype.estimatePoses=function(e,t,n){return void 0===t&&(t=q6),x4(this,void 0,void 0,function(){var a,s,r,i,o,c;return v4(this,function(l){switch(l.label){case 0:return t=function(e){return null==e?q6:b4({},e)}(t),null==e?(this.reset(),[2,[]]):(null==n?Z4(e)&&(n=1e6*e.currentTime):n*=1e3,a=j4(e),s=z4(a),r=uv(a,0),e instanceof im||a.dispose(),i=[],this.multiPoseModel?[3,2]:[4,this.estimateSinglePose(r,s,n)]);case 1:return i=l.sent(),[3,4];case 2:return[4,this.estimateMultiplePoses(r,s,n)];case 3:i=l.sent(),l.label=4;case 4:for(o=0;o<i.length;++o)for(c=0;c<i[o].keypoints.length;++c)i[o].keypoints[c].name=k4[c],i[o].keypoints[c].y*=s.height,i[o].keypoints[c].x*=s.width;return[2,i]}})})},e.prototype.estimateSinglePose=function(e,t,n){return x4(this,void 0,void 0,function(){var a,s,r,i,o=this;return v4(this,function(c){switch(c.label){case 0:return this.cropRegion||(this.cropRegion=Q6(null==this.cropRegion,t)),a=Km(function(){var t=ok([[o.cropRegion.yMin,o.cropRegion.xMin,o.cropRegion.yMax,o.cropRegion.xMax]]),n=Gv([1],"int32"),a=[o.modelInputResolution.height,o.modelInputResolution.width];return ny(US.cropAndResize(e,t,n,a,"bilinear",0),"int32")}),e.dispose(),[4,this.runSinglePersonPoseModel(a)];case 1:if(s=c.sent(),a.dispose(),s.score<this.minPoseScore)return this.reset(),[2,[]];for(r=0;r<s.keypoints.length;++r)s.keypoints[r].y=this.cropRegion.yMin+s.keypoints[r].y*this.cropRegion.height,s.keypoints[r].x=this.cropRegion.xMin+s.keypoints[r].x*this.cropRegion.width;return null!=n&&this.enableSmoothing&&(s.keypoints=this.keypointFilter.apply(s.keypoints,n,1)),i=function(e,t,n,a){for(var s={},r=0,i=k4;r<i.length;r++){var o=i[r];s[o]=[t[n[o]].y*a.height,t[n[o]].x*a.width]}if(function(e,t){return(e[t.left_hip].score>.2||e[t.right_hip].score>.2)&&(e[t.left_shoulder].score>.2||e[t.right_shoulder].score>.2)}(t,n)){var c=(s.left_hip[0]+s.right_hip[0])/2,l=(s.left_hip[1]+s.right_hip[1])/2,u=function(e,t,n,a,s){for(var r=["left_shoulder","right_shoulder","left_hip","right_hip"],i=0,o=0,c=0;c<r.length;c++)(p=Math.abs(a-n[r[c]][0]))>i&&(i=p),(f=Math.abs(s-n[r[c]][1]))>o&&(o=f);for(var l=0,u=0,h=0,d=Object.keys(n);h<d.length;h++){var p,f,m=d[h];e[t[m]].score<.2||((p=Math.abs(a-n[m][0]))>l&&(l=p),(f=Math.abs(s-n[m][1]))>u&&(u=f))}return[i,o,l,u]}(t,n,s,c,l),h=u[0],d=u[1],p=u[2],f=u[3],m=Math.max(1.9*d,1.9*h,1.2*p,1.2*f),g=[c-(m=Math.min(m,Math.max(l,a.width-l,c,a.height-c))),l-m];if(m>Math.max(a.width,a.height)/2)return Q6(null==e,a);var y=2*m;return{yMin:g[0]/a.height,xMin:g[1]/a.width,yMax:(g[0]+y)/a.height,xMax:(g[1]+y)/a.width,height:(g[0]+y)/a.height-g[0]/a.height,width:(g[1]+y)/a.width-g[1]/a.width}}return Q6(null==e,a)}(this.cropRegion,s.keypoints,this.keypointIndexByName,t),this.cropRegion=this.filterCropRegion(i),[2,[s]]}})})},e.prototype.estimateMultiplePoses=function(e,t,n){return x4(this,void 0,void 0,function(){var a,s,r,i,o,c,l,u,h,d,p,f=this;return v4(this,function(m){switch(m.label){case 0:return t.width>t.height?(s=this.multiPoseMaxDimension,r=Math.round(this.multiPoseMaxDimension*t.height/t.width),a=US.resizeBilinear(e,[r,s]),o=s,c=32*Math.ceil(r/32),i=sw(a,[[0,0],[0,c-r],[0,0],[0,0]])):(s=Math.round(this.multiPoseMaxDimension*t.width/t.height),r=this.multiPoseMaxDimension,a=US.resizeBilinear(e,[r,s]),o=32*Math.ceil(s/32),c=r,i=sw(a,[[0,0],[0,0],[0,o-s],[0,0]])),a.dispose(),e.dispose(),l=ny(i,"int32"),i.dispose(),[4,this.runMultiPersonPoseModel(l)];case 1:for(u=m.sent(),l.dispose(),u=u.filter(function(e){return e.score>=f.minPoseScore}),d=0;d<u.length;++d)for(h=0;h<u[d].keypoints.length;++h)u[d].keypoints[h].y*=c/r,u[d].keypoints[h].x*=o/s;if(this.enableTracking&&(this.tracker.apply(u,n),this.enableSmoothing)){for(d=0;d<u.length;++d)this.keypointFilterMap.has(u[d].id)||this.keypointFilterMap.set(u[d].id,new d6(K6)),u[d].keypoints=this.keypointFilterMap.get(u[d].id).apply(u[d].keypoints,n,1);p=this.tracker.getTrackIDs(),this.keypointFilterMap.forEach(function(e,t){p.has(t)||f.keypointFilterMap.delete(t)})}return[2,u]}})})},e.prototype.filterCropRegion=function(e){if(e){var t=this.cropRegionFilterYMin.apply(e.yMin),n=this.cropRegionFilterXMin.apply(e.xMin),a=this.cropRegionFilterYMax.apply(e.yMax),s=this.cropRegionFilterXMax.apply(e.xMax);return{yMin:t,xMin:n,yMax:a,xMax:s,height:a-t,width:s-n}}return this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset(),null},e.prototype.dispose=function(){this.moveNetModel.dispose()},e.prototype.reset=function(){this.cropRegion=null,this.resetFilters()},e.prototype.resetFilters=function(){this.keypointFilter.reset(),this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset()},e}();function $6(e){return void 0===e&&(e=G6),x4(this,void 0,void 0,function(){var t,n,a,s;return v4(this,function(r){switch(r.label){case 0:return t=function(e){var t,n=null==e?G6:b4({},e);if(null==n.modelType)n.modelType="SinglePose.Lightning";else if(H6.indexOf(n.modelType)<0)throw new Error("Invalid architecture ".concat(n.modelType,". ")+"Should be one of ".concat(H6));if(null==n.enableSmoothing&&(n.enableSmoothing=!0),null!=n.minPoseScore&&(n.minPoseScore<0||n.minPoseScore>1))throw new Error("minPoseScore should be between 0.0 and 1.0");if(null!=n.multiPoseMaxDimension&&(n.multiPoseMaxDimension%32!=0||n.multiPoseMaxDimension<32))throw new Error("multiPoseMaxDimension must be a multiple of 32 and higher than 0");if("MultiPose.Lightning"===n.modelType&&null==n.enableTracking&&(n.enableTracking=!0),"MultiPose.Lightning"===n.modelType&&!0===n.enableTracking)if(null==n.trackerType&&(n.trackerType=L6.BoundingBox),n.trackerType===L6.Keypoint)null!=n.trackerConfig?n.trackerConfig=function(e){var t=Z6(X6,e);return t.keypointTrackerParams=b4({},X6.keypointTrackerParams),null!=e.keypointTrackerParams&&(null!=e.keypointTrackerParams.keypointConfidenceThreshold&&(t.keypointTrackerParams.keypointConfidenceThreshold=e.keypointTrackerParams.keypointConfidenceThreshold),null!=e.keypointTrackerParams.keypointFalloff&&(t.keypointTrackerParams.keypointFalloff=e.keypointTrackerParams.keypointFalloff),null!=e.keypointTrackerParams.minNumberOfKeypoints&&(t.keypointTrackerParams.minNumberOfKeypoints=e.keypointTrackerParams.minNumberOfKeypoints)),t}(n.trackerConfig):n.trackerConfig=X6;else{if(n.trackerType!==L6.BoundingBox)throw new Error("Tracker type not supported by MoveNet");null!=n.trackerConfig?n.trackerConfig=(t=n.trackerConfig,Z6(Y6,t)):n.trackerConfig=Y6}return n}(e),a=!0,t.modelUrl?(a="string"==typeof t.modelUrl&&t.modelUrl.indexOf("https://tfhub.dev")>-1,[4,DP(t.modelUrl,{fromTFHub:a})]):[3,2];case 1:return n=r.sent(),[3,4];case 2:return s=void 0,"SinglePose.Lightning"===t.modelType?s="https://tfhub.dev/google/tfjs-model/movenet/singlepose/lightning/4":"SinglePose.Thunder"===t.modelType?s="https://tfhub.dev/google/tfjs-model/movenet/singlepose/thunder/4":"MultiPose.Lightning"===t.modelType&&(s="https://tfhub.dev/google/tfjs-model/movenet/multipose/lightning/1"),[4,DP(s,{fromTFHub:a})];case 3:n=r.sent(),r.label=4;case 4:return"webgl"===Qm()&&$u().set("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",0),[2,new J6(n,t)]}})})}var e5={architecture:"MobileNetV1",outputStride:16,multiplier:.75,inputResolution:{height:257,width:257}},t5=["MobileNetV1","ResNet50"],n5={MobileNetV1:[8,16],ResNet50:[16]},a5=[8,16,32],s5={MobileNetV1:[.5,.75,1],ResNet50:[1]},r5=[1,2,4],i5={maxPoses:1,flipHorizontal:!1},o5={maxPoses:5,flipHorizontal:!1,scoreThreshold:.5,nmsRadius:20},c5=[-123.15,-115.9,-103.06];function l5(e){return Math.floor(e/2)}var u5=function(){function e(e,t){this.priorityQueue=new Array(e),this.numberOfElements=-1,this.getElementValue=t}return e.prototype.enqueue=function(e){this.priorityQueue[++this.numberOfElements]=e,this.swim(this.numberOfElements)},e.prototype.dequeue=function(){var e=this.priorityQueue[0];return this.exchange(0,this.numberOfElements--),this.sink(0),this.priorityQueue[this.numberOfElements+1]=null,e},e.prototype.empty=function(){return-1===this.numberOfElements},e.prototype.size=function(){return this.numberOfElements+1},e.prototype.all=function(){return this.priorityQueue.slice(0,this.numberOfElements+1)},e.prototype.max=function(){return this.priorityQueue[0]},e.prototype.swim=function(e){for(;e>0&&this.less(l5(e),e);)this.exchange(e,l5(e)),e=l5(e)},e.prototype.sink=function(e){for(;2*e<=this.numberOfElements;){var t=2*e;if(t<this.numberOfElements&&this.less(t,t+1)&&t++,!this.less(e,t))break;this.exchange(e,t),e=t}},e.prototype.getValueAt=function(e){return this.getElementValue(this.priorityQueue[e])},e.prototype.less=function(e,t){return this.getValueAt(e)<this.getValueAt(t)},e.prototype.exchange=function(e,t){var n=this.priorityQueue[e];this.priorityQueue[e]=this.priorityQueue[t],this.priorityQueue[t]=n},e}();function h5(e,t,n,a,s,r){for(var i=r.shape,o=i[0],c=i[1],l=!0,u=Math.max(n-s,0),h=Math.min(n+s+1,o),d=u;d<h;++d){for(var p=Math.max(a-s,0),f=Math.min(a+s+1,c),m=p;m<f;++m)if(r.get(d,m,e)>t){l=!1;break}if(!l)break}return l}function d5(e){return x4(this,void 0,void 0,function(){return v4(this,function(t){return[2,Promise.all(e.map(function(e){return e.buffer()}))]})})}function p5(e,t,n,a){return{y:a.get(e,t,n),x:a.get(e,t,n+17)}}function f5(e,t,n){var a=p5(e.heatmapY,e.heatmapX,e.id,n),s=a.y,r=a.x;return{x:e.heatmapX*t+r,y:e.heatmapY*t+s}}function m5(e,t,n,a){var s=n.x,r=n.y;return e.some(function(e){var n,i,o,c,l=e.keypoints;return n=r,i=s,(o=l[a].y-n)*o+(c=l[a].x-i)*c<=t})}var g5=k4.reduce(function(e,t,n){return e[t]=n,e},{}),y5=[["nose","left_eye"],["left_eye","left_ear"],["nose","right_eye"],["right_eye","right_ear"],["nose","left_shoulder"],["left_shoulder","left_elbow"],["left_elbow","left_wrist"],["left_shoulder","left_hip"],["left_hip","left_knee"],["left_knee","left_ankle"],["nose","right_shoulder"],["right_shoulder","right_elbow"],["right_elbow","right_wrist"],["right_shoulder","right_hip"],["right_hip","right_knee"],["right_knee","right_ankle"]].map(function(e){var t=e[0],n=e[1];return[g5[t],g5[n]]}),b5=y5.map(function(e){return e[1]}),x5=y5.map(function(e){return e[0]});function v5(e,t,n){return e<t?t:e>n?n:e}function w5(e,t,n,a){return{y:v5(Math.round(e.y/t),0,n-1),x:v5(Math.round(e.x/t),0,a-1)}}function k5(e,t){return{x:e.x+t.x,y:e.y+t.y}}function S5(e,t,n,a,s,r,i,o){void 0===o&&(o=2);for(var c=a.shape,l=c[0],u=c[1],h={y:t.y,x:t.x},d=k5(h,function(e,t,n){var a=n.shape[2]/2;return{y:n.get(t.y,t.x,e),x:n.get(t.y,t.x,a+e)}}(e,w5(h,r,l,u),i)),p=0;p<o;p++){var f=w5(d,r,l,u),m=p5(f.y,f.x,n,s);d=k5({x:f.x*r,y:f.y*r},{x:m.x,y:m.y})}var g=w5(d,r,l,u),y=a.get(g.y,g.x,n);return{y:d.y,x:d.x,name:k4[n],score:y}}function C5(e,t,n,a,s,r){var i=t.shape[2],o=b5.length,c=new Array(i),l=e.part,u=e.score,h=f5(l,a,n);c[l.id]={score:u,name:k4[l.id],y:h.y,x:h.x};for(var d=o-1;d>=0;--d){var p=b5[d],f=x5[d];c[p]&&!c[f]&&(c[f]=S5(d,c[p],f,t,n,a,r))}for(d=0;d<o;++d)p=x5[d],f=b5[d],c[p]&&!c[f]&&(c[f]=S5(d,c[p],f,t,n,a,s));return c}function I5(e,t,n){return n.reduce(function(n,a,s){var r=a.y,i=a.x,o=a.score;return m5(e,t,{y:r,x:i},s)||(n+=o),n},0)/n.length}function N5(e,t,n,a,s,r,i,o){return void 0===i&&(i=.5),void 0===o&&(o=20),x4(this,void 0,void 0,function(){var c,l,u,h,d,p,f,m,g,y,b,x;return v4(this,function(v){switch(v.label){case 0:return[4,d5([e,t,n,a])];case 1:for(c=v.sent(),l=c[0],u=c[1],h=c[2],d=c[3],p=[],f=function(e,t,n){for(var a=n.shape,s=a[0],r=a[1],i=a[2],o=new u5(s*r*i,function(e){return e.score}),c=0;c<s;++c)for(var l=0;l<r;++l)for(var u=0;u<i;++u){var h=n.get(c,l,u);h<e||h5(u,h,c,l,1,n)&&o.enqueue({score:h,part:{heatmapY:c,heatmapX:l,id:u}})}return o}(i,0,l),m=o*o;p.length<r&&!f.empty();)g=f.dequeue(),y=f5(g.part,s,u),m5(p,m,y,g.part.id)||(b=C5(g,l,u,s,h,d),x=I5(p,m,b),p.push({keypoints:b,score:x}));return[2,p]}})})}function T5(){for(var e,t=[],n=0;n<arguments.length;n++)t[n]=arguments[n];switch(t.length){case 0:e="fn main() ";break;case 1:e="fn main(".concat(t[0]," : i32)");break;default:throw Error("Unreachable")}return e}var E5=function(){function e(e){this.variableNames=["A","B"],this.size=!0,this.workgroupSize=[32,1,1],this.outputShape=[e[0],1],this.dispatchLayout=QQ(this.outputShape),this.dispatch=KQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="getpointsConfidenceOp"}return e.prototype.getUserCode=function(){return"\n        ".concat(T5("index")," {\n          if (index < uniforms.size) {\n            let y = B[index * 2];\n            let x = B[index * 2 + 1];\n            let outIndex = y * uniforms.aShape.x * uniforms.aShape.z + x * uniforms.aShape.z + index;\n            result[index] = A[outIndex];\n          }\n        }\n        ")},e}();var R5=function(){function e(e){if(this.variableNames=["A","B"],this.size=!0,this.supportedLastDimension=2,2!==e.length||e[1]!==this.supportedLastDimension)throw new Error("GetOffsetVectorsProgram only supports shape of [x, ".concat(this.supportedLastDimension,"], but current shape is ").concat(e));this.workgroupSize=[32,1,1],this.outputShape=e;var t=[e[0],1];this.dispatchLayout=QQ(t),this.dispatch=KQ(this.dispatchLayout,t,this.workgroupSize),this.shaderKey="GetOffsetVectors"}return e.prototype.getUserCode=function(){return"\n    fn getOffsetPoint(y: i32, x: i32, index: i32) -> vec2<i32> {\n      let outIndexY = y * uniforms.bShape.x * uniforms.bShape.y + x * uniforms.bShape.y + index;\n      let outIndexX = outIndexY + uniforms.bShape.z;\n      let outY = i32(B[outIndexY]);\n      let outX = i32(B[outIndexX]);\n      return vec2<i32>(outY, outX);\n    }\n\n    ".concat(T5("index")," {\n      if (index < uniforms.size) {\n        let indexY = index * ").concat(this.supportedLastDimension,";\n        let indexX = indexY + 1;\n        let heatmapY = A[indexY];\n        let heatmapX = A[indexX];\n        let out = getOffsetPoint(i32(heatmapY), i32(heatmapX), index);\n        result[indexY] = f32(out[0]);\n        result[indexX] = f32(out[1]);\n      }\n    }\n    ")},e}();function _5(e){var t=e.shape,n=t[0],a=t[1],s=t[2];return Km(function(){var t,r,i=tx(e,[n*a,s]),o=Pb(i,0),c=uv(oy(o,py(a,"int32")),1),l=uv((t=o,r=a,Km(function(){var e=oy(t,py(r,"int32"));return Cy(t,cy(e,py(r,"int32")))})),1);return sx([c,l],1)})}function A5(e,t,n){return Km(function(){var a=function(e,t){for(var n=[],a=0;a<k4.length;a++){var s=M5(e.get(a,0).valueOf(),e.get(a,1).valueOf(),a,t),r=s.x,i=s.y;n.push(i),n.push(r)}return ok(n,[k4.length,2])}(e,n);return ry(ny(cy(e.toTensor(),py(t,"int32")),"float32"),a)})}function M5(e,t,n,a){return{y:a.get(e,t,n),x:a.get(e,t,n+k4.length)}}function P5(e,t,n){return x4(this,void 0,void 0,function(){var a,s,r,i,o,c,l,u,h,d;return v4(this,function(p){switch(p.label){case 0:return a=0,s=_5(e),[4,Promise.all([e.buffer(),t.buffer(),s.buffer()])];case 1:return r=p.sent(),i=r[0],o=r[1],c=r[2],[4,(l=A5(c,n,o)).buffer()];case 2:return u=p.sent(),h=Array.from(function(e,t){for(var n=t.shape[0],a=new Float32Array(n),s=0;s<n;s++){var r=t.get(s,0),i=t.get(s,1);a[s]=e.get(r,i,s)}return a}(i,c)),d=h.map(function(e,t){return a+=e,{y:u.get(t,0),x:u.get(t,1),score:e,name:k4[t]}}),s.dispose(),l.dispose(),[2,{keypoints:d,score:a/d.length}]}})})}function D5(e,t,n){return x4(this,void 0,void 0,function(){var a,s,r;return v4(this,function(i){return a=_5(e),s=function(e,t,n){return Km(function(){var a=function(e,t){if(Jm()instanceof nZ)return function(e,t){var n=Jm(),a=new R5(e.shape),s=n.runWebGPUProgram(a,[e,t],"float32");return Gm().makeTensorFromTensorInfo(s)}(e,t);throw new Error("getOffsetVectorsGPU is not supported in this backend!")}(e,n);return ry(ny(cy(e,py(t,"int32")),"float32"),a)})}(a,n,t),r=function(e,t){if(Jm()instanceof nZ)return function(e,t){var n=Jm(),a=new E5(t.shape),s=n.runWebGPUProgram(a,[e,t],"float32");return Gm().makeTensorFromTensorInfo(s)}(e,t);throw new Error("getPointsConfidenceWebGPU is not supported in this backend!")}(e,a),[2,[s,r]]})})}function O5(e,t){return(e-1)%t==0}var F5="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/mobilenet/",L5="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/resnet50/";function z5(e,t){return function(e,t){return(e-1)%t==0}(e,t)?e:Math.floor(e/t)*t+1}var B5=function(){function e(e,t){this.posenetModel=e;var n=this.posenetModel.inputs[0].shape;yu(-1===n[1]&&-1===n[2],function(){return"Input shape [".concat(n[1],", ").concat(n[2],"] ")+"must both be equal to or -1"});var a,s,r=(a=t.inputResolution,s=t.outputStride,{height:z5(a.height,s),width:z5(a.width,s)});!function(e){yu(a5.indexOf(e)>=0,function(){return"outputStride of ".concat(e," is invalid. ")+"It must be either 8 or 16."})}(t.outputStride),function(e,t){yu(O5(e.height,t),function(){return"height of ".concat(e.height," is invalid for output stride ")+"".concat(t,".")}),yu(O5(e.width,t),function(){return"width of ".concat(e.width," is invalid for output stride ")+"".concat(t,".")})}(r,t.outputStride),this.inputResolution=r,this.outputStride=t.outputStride,this.architecture=t.architecture}return e.prototype.estimatePoses=function(e,t){return void 0===t&&(t=i5),x4(this,void 0,void 0,function(){return v4(this,function(n){return[2,this.estimatePosesGPU(e,t,!1)]})})},e.prototype.estimatePosesGPU=function(e,t,n){return void 0===t&&(t=i5),void 0===n&&(n=!1),x4(this,void 0,void 0,function(){var a,s,r,i,o,c,l,u,h,d,p,f,m,g,y,b,x,v;return v4(this,function(w){switch(w.label){case 0:return a=function(e){var t=e;if(null==t.maxPoses&&(t.maxPoses=1),t.maxPoses<=0)throw new Error("Invalid maxPoses ".concat(t.maxPoses,". Should be > 0."));if(t.maxPoses>1){if((t=b4(b4({},o5),t)).scoreThreshold<0||t.scoreThreshold>1)throw new Error("Invalid scoreThreshold ".concat(t.scoreThreshold,". ")+"Should be in range [0.0, 1.0]");if(t.nmsRadius<=0)throw new Error("Invalid nmsRadius ".concat(t.nmsRadius,"."))}return t}(t),null==e?[2,n?[[],[]]:[]]:(this.maxPoses=a.maxPoses,s=Y4(e,{outputTensorSize:this.inputResolution,keepAspectRatio:!0,borderMode:"replicate"}),r=s.imageTensor,i=s.padding,o="ResNet50"===this.architecture?ry(r,c5):X4(r,[-1,1]),c=this.posenetModel.predict(o),"ResNet50"===this.architecture?(l=tk(c[2],[0]),u=tk(c[3],[0]),h=tk(c[0],[0]),d=tk(c[1],[0])):(l=tk(c[0],[0]),u=tk(c[1],[0]),h=tk(c[2],[0]),d=tk(c[3],[0])),p=ix(u),1!==this.maxPoses?[3,5]:n?[4,D5(p,l,this.outputStride)]:[3,2]);case 1:return m=w.sent(),y=m[0],g=m[1],f=[y,g],[3,4];case 2:return[4,P5(p,l,this.outputStride)];case 3:y=w.sent(),f=[y],w.label=4;case 4:return[3,7];case 5:if(n)throw new Error("GPU renderer only supports single pose!");return[4,N5(p,l,h,d,this.outputStride,this.maxPoses,a.scoreThreshold,a.nmsRadius)];case 6:f=w.sent(),w.label=7;case 7:if(n){if(!0===a.flipHorizontal)throw new Error("flipHorizontal is not supported!");b=this.getCanvasInfo(z4(e),this.inputResolution,i)}else v=z4(e),x=function(e,t,n,a){var s=t.height,r=t.width,i=s/(n.height*(1-a.top-a.bottom)),o=r/(n.width*(1-a.left-a.right)),c=-a.top*n.height,l=-a.left*n.width;if(1===o&&1===i&&0===c&&0===l)return e;for(var u=0,h=e;u<h.length;u++)for(var d=0,p=h[u].keypoints;d<p.length;d++){var f=p[d];f.x=(f.x+l)*o,f.y=(f.y+c)*i}return e}(f,v,this.inputResolution,i),a.flipHorizontal&&(x=function(e,t){for(var n=0,a=e;n<a.length;n++)for(var s=0,r=a[n].keypoints;s<r.length;s++){var i=r[s];i.x=t.width-1-i.x}return e}(x,v));return r.dispose(),o.dispose(),Xm(c),l.dispose(),u.dispose(),h.dispose(),d.dispose(),p.dispose(),[2,n?[f,b]:x]}})})},e.prototype.getCanvasInfo=function(e,t,n){var a=e.height,s=e.width,r=a/(t.height*(1-n.top-n.bottom)),i=s/(t.width*(1-n.left-n.right)),o=-n.top*t.height;return[-n.left*t.width,o,i,r,e.width,e.height]},e.prototype.dispose=function(){this.posenetModel.dispose()},e.prototype.reset=function(){},e}();function j5(e){return void 0===e&&(e=e5),x4(this,void 0,void 0,function(){var t,n,a,s,r;return v4(this,function(i){switch(i.label){case 0:return"ResNet50"!==(t=function(e){var t=e||e5;if(null==t.architecture&&(t.architecture="MobileNetV1"),t5.indexOf(t.architecture)<0)throw new Error("Invalid architecture ".concat(t.architecture,". ")+"Should be one of ".concat(t5));if(null==t.inputResolution&&(t.inputResolution={height:257,width:257}),null==t.outputStride&&(t.outputStride=16),n5[t.architecture].indexOf(t.outputStride)<0)throw new Error("Invalid outputStride ".concat(t.outputStride,". ")+"Should be one of ".concat(n5[t.architecture]," ")+"for architecture ".concat(t.architecture,"."));if(null==t.multiplier&&(t.multiplier=1),s5[t.architecture].indexOf(t.multiplier)<0)throw new Error("Invalid multiplier ".concat(t.multiplier,". ")+"Should be one of ".concat(s5[t.architecture]," ")+"for architecture ".concat(t.architecture,"."));if(null==t.quantBytes&&(t.quantBytes=4),r5.indexOf(t.quantBytes)<0)throw new Error("Invalid quantBytes ".concat(t.quantBytes,". ")+"Should be one of ".concat(r5," ")+"for architecture ".concat(t.architecture,"."));if("MobileNetV1"===t.architecture&&32===t.outputStride&&1!==t.multiplier)throw new Error("When using an output stride of 32, you must select 1 as the multiplier.");return t}(e)).architecture?[3,2]:(o=t.outputStride,c=t.quantBytes,l="model-stride".concat(o,".json"),n=4===c?L5+"float/"+l:L5+"quant".concat(c,"/")+l,[4,DP(t.modelUrl||n)]);case 1:return a=i.sent(),[2,new B5(a,t)];case 2:return s=function(e,t,n){var a={1:"100",.75:"075",.5:"050"},s="model-stride".concat(e,".json");return 4===n?F5+"float/".concat(a[t],"/")+s:F5+"quant".concat(n,"/").concat(a[t],"/")+s}(t.outputStride,t.multiplier,t.quantBytes),[4,DP(t.modelUrl||s)];case 3:return r=i.sent(),[2,new B5(r,t)]}var o,c,l})})}function W5(e,t){return x4(this,void 0,void 0,function(){var n,a;return v4(this,function(s){switch(e){case z6.PoseNet:return[2,j5(t)];case z6.BlazePose:if(a=void 0,null!=(n=t)){if("tfjs"===n.runtime)return[2,F6(t)];if("mediapipe"===n.runtime)return[2,L4(t)];a=n.runtime}throw new Error("Expect modelConfig.runtime to be either 'tfjs' "+"or 'mediapipe', but got ".concat(a));case z6.MoveNet:return[2,$6(t)];default:throw new Error("".concat(e," is not a supported model name."))}})})}var V5={modelType:{SINGLEPOSE_LIGHTNING:"SinglePose.Lightning",SINGLEPOSE_THUNDER:"SinglePose.Thunder",MULTIPOSE_LIGHTNING:"MultiPose.Lightning"}};const U5=()=>{const e=Te(),t=Re(),n=(0,E.useRef)(null),a=(0,E.useRef)(null),s=(0,E.useRef)(null),[r,i]=(0,E.useState)(null),[o,c]=(0,E.useState)(!1),[l,u]=(0,E.useState)(null),[h,d]=(0,E.useState)(null),[p,f]=(0,E.useState)(0),[m,g]=(0,E.useState)([]),[y,b]=(0,E.useState)(!1);(0,E.useEffect)(()=>{var n;null!==(n=e.state)&&void 0!==n&&n.pose?i(e.state.pose):t("/pose-detection")},[e.state,t]),(0,E.useEffect)(()=>{(async()=>{b(!0);try{await(e="webgl",Tm.setBackend(e)),await Tm.ready(),console.log("TensorFlow.js backend initialized:",Qm());const r=z6.MoveNet;let i=null;try{if(!V5||!V5.modelType)throw new Error("movenet.modelType not available");{const e={modelType:V5.modelType.SINGLEPOSE_LIGHTNING};i=await W5(r,e),console.log("MoveNet Lightning (enum) loaded successfully")}}catch(t){console.warn("MoveNet Lightning (enum) failed:",t.message);try{const e={modelType:"lightning"};i=await W5(r,e),console.log("MoveNet Lightning (string) loaded successfully")}catch(n){console.warn("MoveNet Lightning (string) failed:",n.message);try{const e={modelType:"thunder"};i=await W5(r,e),console.log("MoveNet Thunder loaded successfully")}catch(a){console.warn("MoveNet Thunder failed:",a.message);try{i=await W5(r),console.log("MoveNet (default) loaded successfully")}catch(s){throw new Error("All MoveNet variants failed. Last error: ".concat(s.message))}}}}if(!i)throw new Error("Failed to create detector");d(i)}catch(r){console.error("Error loading pose detection model:",r),console.error("Error details:",r.message);try{console.log("Attempting to load BlazePose as fallback...");const e=z6.BlazePose,t={runtime:"tfjs",modelType:"lite",enableSmoothing:!0},n=await W5(e,t);d(n),console.log("BlazePose model loaded successfully as fallback")}catch(i){console.error("All models failed to load:",i),g(["Error loading pose detection model.","Please check your internet connection and refresh the page.","The model needs to be downloaded on first use.","Error: ".concat(r.message||"Unknown error")])}}finally{b(!1)}var e})()},[]);const x=(0,E.useCallback)(()=>{u(!0)},[]),v=(0,E.useCallback)(()=>{u(!1),g(["Camera access denied. Please enable camera permissions."])},[]),w=(e,t,n,a,s,r)=>{if(!e||!t||e.score<.5||t.score<.5)return!1;const i=((e,t)=>{if(!e||!t)return 1/0;const n=e.x-t.x,a=e.y-t.y;return Math.sqrt(n*n+a*a)})(e,t);return!(i>.6*Math.max(s,r))&&(!((5===n&&7===a||6===n&&8===a)&&i>.4*s)&&!((11===n&&13===a||12===n&&14===a)&&i>.5*r))},k=(0,E.useCallback)(async()=>{if(!n.current||!a.current||!h)return;const e=n.current.video,t=a.current,r=t.getContext("2d");if(e&&4===e.readyState){const n=e.videoWidth,a=e.videoHeight;t.width=n,t.height=a,r.clearRect(0,0,n,a);try{const t=await h.estimatePoses(e);if(t&&t.length>0){let e=t[0].keypoints;e=e.map(e=>Ln(Ln({},e),{},{x:n-e.x}));const s=[...e];[s[5],s[6]]=[s[6],s[5]],[s[7],s[8]]=[s[8],s[7]],[s[9],s[10]]=[s[10],s[9]],[s[11],s[12]]=[s[12],s[11]],[s[13],s[14]]=[s[14],s[13]],[s[15],s[16]]=[s[16],s[15]],[s[1],s[2]]=[s[2],s[1]],[s[3],s[4]]=[s[4],s[3]],e=s;const i=(e=>{if(!e||0===e.length)return f(0),g(["No pose detected. Please ensure your full body is visible."]),0;const t=e.filter(e=>e&&e.score>.5).length/e.length*100;let n=0;const a=[],s=e[5],r=e[6],i=e[11],o=e[12];if(s&&r&&s.score>.5&&r.score>.5){const e=Math.abs(s.y-r.y);e<20?n+=20:e<40?(n+=10,a.push("Keep your shoulders more level")):a.push("Keep your shoulders level")}if(i&&o&&i.score>.5&&o.score>.5){const e=Math.abs(i.y-o.y);e<20?n+=20:e<40?(n+=10,a.push("Align your hips better")):a.push("Align your hips")}const c=[s,r,i,o].filter(e=>e&&e.score>.3).length;if(c>=4?n+=20:c>=3?(n+=10,a.push("Ensure your full body is visible in the frame")):a.push("Ensure your full body is visible in the frame"),s&&r&&i&&o){const e=s.score>.5&&i.score>.5,t=r.score>.5&&o.score>.5;e&&t?n+=20:a.push("Try to show both sides of your body")}const l=e.reduce((e,t)=>e+((null===t||void 0===t?void 0:t.score)||0),0)/e.length;l>.7?n+=20:l>.5&&(n+=10);const u=Math.min(100,.3*t+.7*n),h=Math.round(u);return f(h),u>=90?0===a.length&&a.push("Excellent pose! Perfect alignment - Green lines indicate correct form"):u>=70?0===a.length&&a.push("Good form! Minor adjustments needed to reach 90% accuracy"):0===a.length&&a.push("Adjust your pose for better alignment - Aim for 90% accuracy for green lines"),g(a),h})(e);((e,t,n,a,s)=>{if(!e||0===e.length)return;const r=s>=90,i=r?"#00ff00":"#ff0000",o=r?"#00ff00":"#ff0000",c=r?4:3;[[5,6],[5,7],[7,9],[6,8],[8,10],[5,11],[6,12],[11,12],[11,13],[13,15],[12,14],[14,16]].forEach(s=>{let[r,o]=s;if(r<e.length&&o<e.length){const s=e[r],l=e[o];w(s,l,r,o,n,a)&&(t.beginPath(),t.moveTo(s.x,s.y),t.lineTo(l.x,l.y),t.strokeStyle=i,t.lineWidth=c,t.lineCap="round",t.lineJoin="round",t.stroke())}}),e.forEach((s,r)=>{if(((e,t,n,a,s)=>{if(!e||e.score<.5)return!1;const r=e.x,i=e.y;if(r<0||r>a||i<0||i>s)return!1;const o=n[5],c=n[6],l=n[11],u=n[12];return!((5===t||7===t||9===t||11===t||13===t||15===t)&&c&&c.score>.5&&r>c.x+50)&&!((6===t||8===t||10===t||12===t||14===t||16===t)&&o&&o.score>.5&&r<o.x-50)&&!(13===t&&l&&l.score>.5&&i<l.y-20)&&!(14===t&&u&&u.score>.5&&i<u.y-20)&&!(15===t&&n[13]&&n[13].score>.5&&i<n[13].y-20)&&!(16===t&&n[14]&&n[14].score>.5&&i<n[14].y-20)})(s,r,e,n,a)){const e=s.x,n=s.y;t.beginPath(),t.arc(e,n,8,0,2*Math.PI),t.fillStyle="#ffffff",t.fill(),t.beginPath(),t.arc(e,n,6,0,2*Math.PI),t.fillStyle=o,t.fill(),t.beginPath(),t.arc(e,n,2,0,2*Math.PI),t.fillStyle="#ffffff",t.fill()}})})(e,r,n,a,i)}else f(0),g(["No pose detected. Please ensure your full body is visible."]),r.clearRect(0,0,n,a)}catch(i){console.error("Error detecting pose:",i)}}o&&(s.current=requestAnimationFrame(k))},[h,o]);(0,E.useEffect)(()=>{if(o&&h)k();else if(s.current&&cancelAnimationFrame(s.current),a.current){a.current.getContext("2d").clearRect(0,0,a.current.width,a.current.height)}return()=>{s.current&&cancelAnimationFrame(s.current)}},[o,h,k]);return r?(0,vn.jsx)("div",{className:"pose-detail-page",children:(0,vn.jsxs)("div",{className:"container",children:[(0,vn.jsxs)("button",{className:"back-button",onClick:()=>t("/pose-detection"),children:[(0,vn.jsx)(Ct,{})," Back to Poses"]}),(0,vn.jsx)("section",{className:"pose-info-section",children:(0,vn.jsxs)("div",{className:"pose-header",children:[(0,vn.jsxs)("div",{className:"pose-image-large",children:[(0,vn.jsx)("img",{src:r.image,alt:r.name,loading:"eager",onError:e=>{var t,n,a;const s=(null===(t=r.name.split("(")[1])||void 0===t||null===(n=t.split(")")[0])||void 0===n?void 0:n.trim())||(null===(a=r.name.split("-")[1])||void 0===a?void 0:a.trim())||"yoga pose";let i,o=s.toLowerCase().replace(/\s+/g,"%20").replace(/[^a-z0-9%]/g,"");i=s.toLowerCase().includes("warrior")||s.toLowerCase().includes("virabhadrasana")?"https://images.unsplash.com/photo-1758599878236-47f6a918aed2?w=600&h=400&fit=crop&auto=format&q=80":s.toLowerCase().includes("cobra")||s.toLowerCase().includes("bhujangasana")?"https://images.unsplash.com/photo-1717821552922-61e18814a44a?w=600&h=400&fit=crop&auto=format&q=80":s.toLowerCase().includes("cat")||s.toLowerCase().includes("cow")||s.toLowerCase().includes("marjariasana")?"https://images.unsplash.com/photo-1758599881262-7b79a56ac284?w=600&h=400&fit=crop&auto=format&q=80":s.toLowerCase().includes("bridge")||s.toLowerCase().includes("setu")||s.toLowerCase().includes("bandhasana")?"https://images.unsplash.com/photo-1767611086180-6b1176976371?w=600&h=400&fit=crop&auto=format&q=80":s.toLowerCase().includes("triangle")||s.toLowerCase().includes("trikonasana")?"https://images.unsplash.com/photo-1767611090899-163209a4ead1?w=600&h=400&fit=crop&auto=format&q=80":s.toLowerCase().includes("downward")||s.toLowerCase().includes("dog")||s.toLowerCase().includes("svanasana")||s.toLowerCase().includes("adho")?"https://images.unsplash.com/photo-1767611121194-3cb554c9a9ec?w=600&h=400&fit=crop&auto=format&q=80":s.toLowerCase().includes("sun")||s.toLowerCase().includes("salutation")||s.toLowerCase().includes("surya")||s.toLowerCase().includes("namaskar")?"https://images.unsplash.com/photo-1606663368493-131f4f97c095?w=600&h=400&fit=crop&auto=format&q=80":s.toLowerCase().includes("child")||s.toLowerCase().includes("balasana")?"https://images.unsplash.com/photo-1767611118672-d3887038786c?w=600&h=400&fit=crop&auto=format&q=80":s.toLowerCase().includes("lotus")||s.toLowerCase().includes("padmasana")?"https://images.unsplash.com/photo-1577344718665-3e7c0c1ecf6b?w=600&h=400&fit=crop&auto=format&q=80":s.toLowerCase().includes("thunderbolt")||s.toLowerCase().includes("vajrasana")?"https://images.unsplash.com/photo-1697274834392-04ff3b76ef20?w=600&h=400&fit=crop&auto=format&q=80":s.toLowerCase().includes("tree")||s.toLowerCase().includes("vrikshasana")?"https://images.unsplash.com/photo-1758274525911-402f99afec14?w=600&h=400&fit=crop&auto=format&q=80":"https://images.unsplash.com/600x400/?yoga%20".concat(o,"&sig=").concat(r.id);let c=0;e.target.onerror=()=>{c++,e.target.src=c>=2?"https://images.unsplash.com/photo-1506126613408-eca07ce68773?w=600&h=400&fit=crop&auto=format&q=80":i},e.target.src=i}}),(0,vn.jsx)("span",{className:"pose-difficulty-badge-large ".concat(r.difficulty.toLowerCase()),children:r.difficulty})]}),(0,vn.jsxs)("div",{className:"pose-details",children:[(0,vn.jsx)("h1",{children:r.name}),(0,vn.jsx)("p",{className:"pose-description-large",children:r.description}),(0,vn.jsxs)("div",{className:"pose-meta-large",children:[(0,vn.jsxs)("span",{children:["\u23f1 Duration: ",r.duration]}),(0,vn.jsxs)("span",{children:["\ud83d\udcc2 Category: ",r.category]})]})]})]})}),(0,vn.jsx)("section",{className:"pose-detection-section",children:(0,vn.jsxs)("div",{className:"detection-container",children:[(0,vn.jsx)("div",{className:"webcam-wrapper-detection",children:!1===l?(0,vn.jsxs)("div",{className:"permission-denied",children:[(0,vn.jsx)(qt,{}),(0,vn.jsx)("h3",{children:"Camera Access Denied"}),(0,vn.jsx)("p",{children:"Please enable camera permissions to use pose detection."})]}):(0,vn.jsxs)(vn.Fragment,{children:[(0,vn.jsxs)("div",{className:"webcam-container-detection",children:[(0,vn.jsx)(cu(),{ref:n,audio:!1,mirrored:!0,onUserMedia:x,onUserMediaError:v,className:"webcam-video-detection",videoConstraints:{width:640,height:480,facingMode:"user"}}),(0,vn.jsx)("canvas",{ref:a,className:"pose-canvas-detection"}),o&&(0,vn.jsx)("div",{className:"pose-overlay-detection",children:(0,vn.jsxs)("div",{className:"accuracy-display-detection",children:[(0,vn.jsx)("div",{className:"accuracy-circle-detection",style:{borderColor:p>=90?"#00ff00":"#ff0000",color:p>=90?"#00ff00":"#ff0000"},children:(0,vn.jsxs)("span",{children:[p,"%"]})}),(0,vn.jsxs)("p",{children:["Accuracy ",p>=90?"\u2713":"\u26a0"]}),(0,vn.jsx)("p",{className:"accuracy-hint",children:p>=90?"Green lines = Correct!":"Aim for 90% for green lines"})]})})]}),(0,vn.jsxs)("div",{className:"detection-controls",children:[o?(0,vn.jsxs)("button",{className:"btn btn-danger stop-detection-btn",onClick:()=>{c(!1),f(0),g([])},children:[(0,vn.jsx)(pn,{})," Stop Detection"]}):(0,vn.jsxs)("button",{className:"btn btn-primary start-detection-btn",onClick:()=>{h?(c(!0),g([])):g(["Pose detection model is still loading. Please wait..."])},disabled:!1===l||y||!h,children:[(0,vn.jsx)(on,{})," ",y?"Loading Model...":h?"Start Pose Detection":"Model Not Ready"]}),y&&(0,vn.jsx)("p",{className:"model-loading-message",children:"Loading pose detection model... This may take a moment on first use."})]})]})}),(0,vn.jsxs)("div",{className:"detection-feedback-panel",children:[(0,vn.jsxs)("h3",{children:[(0,vn.jsx)(Zt,{})," Real-time Feedback"]}),m.length>0?(0,vn.jsx)("ul",{className:"feedback-list-detection",children:m.map((e,t)=>(0,vn.jsxs)("li",{className:p>=90?"success":"warning",children:[p>=90?(0,vn.jsx)(Pt,{}):(0,vn.jsx)(qt,{}),(0,vn.jsx)("span",{children:e})]},t))}):(0,vn.jsx)("p",{className:"no-feedback-detection",children:o?"Position yourself in the camera frame to start detection...":'Click "Start Pose Detection" to begin practicing with real-time feedback.'})]})]})})]})}):(0,vn.jsx)("div",{className:"pose-detail-page",children:(0,vn.jsx)("div",{className:"container",children:(0,vn.jsx)("p",{children:"Loading pose details..."})})})},H5=()=>(0,vn.jsxs)("div",{className:"App",children:[(0,vn.jsx)(wn,{}),(0,vn.jsx)("main",{children:(0,vn.jsxs)(qe,{children:[(0,vn.jsx)(He,{path:"/",element:(0,vn.jsx)(Sn,{})}),(0,vn.jsx)(He,{path:"/about",element:(0,vn.jsx)(Cn,{})}),(0,vn.jsx)(He,{path:"/features",element:(0,vn.jsx)(In,{})}),(0,vn.jsx)(He,{path:"/how-it-works",element:(0,vn.jsx)(Nn,{})}),(0,vn.jsx)(He,{path:"/pose-detection",element:(0,vn.jsx)(Tn,{})}),(0,vn.jsx)(He,{path:"/pose/:poseId",element:(0,vn.jsx)(U5,{})}),(0,vn.jsx)(He,{path:"/tech-stack",element:(0,vn.jsx)(Mn,{})}),(0,vn.jsx)(He,{path:"/results",element:(0,vn.jsx)($l,{})}),(0,vn.jsx)(He,{path:"/team",element:(0,vn.jsx)(eu,{})}),(0,vn.jsx)(He,{path:"/contact",element:(0,vn.jsx)(tu,{})}),(0,vn.jsx)(He,{path:"/login",element:(0,vn.jsx)(su,{})}),(0,vn.jsx)(He,{path:"/profile",element:(0,vn.jsx)(ru,{})}),(0,vn.jsx)(He,{path:"/category/:categoryId",element:(0,vn.jsx)(iu,{})})]})}),(0,vn.jsx)(kn,{})]});_.createRoot(document.getElementById("root")).render((0,vn.jsx)(E.StrictMode,{children:(0,vn.jsx)(Je,{children:(0,vn.jsx)(H5,{})})}))})()})();
//# sourceMappingURL=main.c04c49e1.js.map