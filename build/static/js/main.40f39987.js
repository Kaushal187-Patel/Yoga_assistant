/*! For license information please see main.40f39987.js.LICENSE.txt */
(()=>{var e={16(e,t,n){var a;!function(e,s){function r(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var a=0;a<n.length+64;a++)t.x^=0|n.charCodeAt(a),a==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function i(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function o(e,t){var n=new r(e),a=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,a&&("object"==typeof a&&i(a,n),s.state=function(){return i(n,{})}),s}s&&s.exports?s.exports=o:n.amdD&&n.amdO?void 0===(a=function(){return o}.call(t,n,t,s))||(s.exports=a):this.xorwow=o}(0,e=n.nmd(e),n.amdD)},29(e,t,n){var a;a=function(e){return function(e){var t={};function n(a){if(t[a])return t[a].exports;var s=t[a]={i:a,l:!1,exports:{}};return e[a].call(s.exports,s,s.exports,n),s.l=!0,s.exports}return n.m=e,n.c=t,n.d=function(e,t,a){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:a})},n.r=function(e){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"===typeof e&&e&&e.__esModule)return e;var a=Object.create(null);if(n.r(a),Object.defineProperty(a,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var s in e)n.d(a,s,function(t){return e[t]}.bind(null,s));return a},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s="./src/react-webcam.tsx")}({"./src/react-webcam.tsx":function(e,t,n){"use strict";n.r(t);var a=n("react"),s=function(){var e=function(t,n){return e=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)t.hasOwnProperty(n)&&(e[n]=t[n])},e(t,n)};return function(t,n){function a(){this.constructor=t}e(t,n),t.prototype=null===n?Object.create(n):(a.prototype=n.prototype,new a)}}(),r=function(){return r=Object.assign||function(e){for(var t,n=1,a=arguments.length;n<a;n++)for(var s in t=arguments[n])Object.prototype.hasOwnProperty.call(t,s)&&(e[s]=t[s]);return e},r.apply(this,arguments)},i=function(e,t){var n={};for(var a in e)Object.prototype.hasOwnProperty.call(e,a)&&t.indexOf(a)<0&&(n[a]=e[a]);if(null!=e&&"function"===typeof Object.getOwnPropertySymbols){var s=0;for(a=Object.getOwnPropertySymbols(e);s<a.length;s++)t.indexOf(a[s])<0&&Object.prototype.propertyIsEnumerable.call(e,a[s])&&(n[a[s]]=e[a[s]])}return n};function o(){return!(!navigator.mediaDevices||!navigator.mediaDevices.getUserMedia)}"undefined"!==typeof window&&(void 0===navigator.mediaDevices&&(navigator.mediaDevices={}),void 0===navigator.mediaDevices.getUserMedia&&(navigator.mediaDevices.getUserMedia=function(e){var t=navigator.getUserMedia||navigator.webkitGetUserMedia||navigator.mozGetUserMedia||navigator.msGetUserMedia;return t?new Promise(function(n,a){t.call(navigator,e,n,a)}):Promise.reject(new Error("getUserMedia is not implemented in this browser"))}));var c=function(e){function t(t){var n=e.call(this,t)||this;return n.canvas=null,n.ctx=null,n.requestUserMediaId=0,n.unmounted=!1,n.state={hasUserMedia:!1},n}return s(t,e),t.prototype.componentDidMount=function(){var e=this.state,t=this.props;this.unmounted=!1,o()?(e.hasUserMedia||this.requestUserMedia(),t.children&&"function"!=typeof t.children&&console.warn("children must be a function")):t.onUserMediaError("getUserMedia not supported")},t.prototype.componentDidUpdate=function(e){var t=this.props;if(o()){var n=JSON.stringify(e.audioConstraints)!==JSON.stringify(t.audioConstraints),a=JSON.stringify(e.videoConstraints)!==JSON.stringify(t.videoConstraints),s=e.minScreenshotWidth!==t.minScreenshotWidth,r=e.minScreenshotHeight!==t.minScreenshotHeight;(a||s||r)&&(this.canvas=null,this.ctx=null),(n||a)&&(this.stopAndCleanup(),this.requestUserMedia())}else t.onUserMediaError("getUserMedia not supported")},t.prototype.componentWillUnmount=function(){this.unmounted=!0,this.stopAndCleanup()},t.stopMediaStream=function(e){e&&(e.getVideoTracks&&e.getAudioTracks?(e.getVideoTracks().map(function(t){e.removeTrack(t),t.stop()}),e.getAudioTracks().map(function(t){e.removeTrack(t),t.stop()})):e.stop())},t.prototype.stopAndCleanup=function(){var e=this.state;e.hasUserMedia&&(t.stopMediaStream(this.stream),e.src&&window.URL.revokeObjectURL(e.src))},t.prototype.getScreenshot=function(e){var t=this.state,n=this.props;if(!t.hasUserMedia)return null;var a=this.getCanvas(e);return a&&a.toDataURL(n.screenshotFormat,n.screenshotQuality)},t.prototype.getCanvas=function(e){var t=this.state,n=this.props;if(!this.video)return null;if(!t.hasUserMedia||!this.video.videoHeight)return null;if(!this.ctx){var a=this.video.videoWidth,s=this.video.videoHeight;if(!this.props.forceScreenshotSourceSize){var r=a/s;s=(a=n.minScreenshotWidth||this.video.clientWidth)/r,n.minScreenshotHeight&&s<n.minScreenshotHeight&&(a=(s=n.minScreenshotHeight)*r)}this.canvas=document.createElement("canvas"),this.canvas.width=(null===e||void 0===e?void 0:e.width)||a,this.canvas.height=(null===e||void 0===e?void 0:e.height)||s,this.ctx=this.canvas.getContext("2d")}var i=this.ctx,o=this.canvas;return i&&o&&(o.width=(null===e||void 0===e?void 0:e.width)||o.width,o.height=(null===e||void 0===e?void 0:e.height)||o.height,n.mirrored&&(i.translate(o.width,0),i.scale(-1,1)),i.imageSmoothingEnabled=n.imageSmoothing,i.drawImage(this.video,0,0,(null===e||void 0===e?void 0:e.width)||o.width,(null===e||void 0===e?void 0:e.height)||o.height),n.mirrored&&(i.scale(-1,1),i.translate(-o.width,0))),o},t.prototype.requestUserMedia=function(){var e=this,n=this.props,a=function(a,s){var r={video:"undefined"===typeof s||s};n.audio&&(r.audio="undefined"===typeof a||a),e.requestUserMediaId++;var i=e.requestUserMediaId;navigator.mediaDevices.getUserMedia(r).then(function(n){e.unmounted||i!==e.requestUserMediaId?t.stopMediaStream(n):e.handleUserMedia(null,n)}).catch(function(t){e.handleUserMedia(t)})};if("mediaDevices"in navigator)a(n.audioConstraints,n.videoConstraints);else{var s=function(e){return{optional:[{sourceId:e}]}},r=function(e){var t=e.deviceId;return"string"===typeof t?t:Array.isArray(t)&&t.length>0?t[0]:"object"===typeof t&&t.ideal?t.ideal:null};MediaStreamTrack.getSources(function(e){var t=null,i=null;e.forEach(function(e){"audio"===e.kind?t=e.id:"video"===e.kind&&(i=e.id)});var o=r(n.audioConstraints);o&&(t=o);var c=r(n.videoConstraints);c&&(i=c),a(s(t),s(i))})}},t.prototype.handleUserMedia=function(e,t){var n=this.props;if(e||!t)return this.setState({hasUserMedia:!1}),void n.onUserMediaError(e);this.stream=t;try{this.video&&(this.video.srcObject=t),this.setState({hasUserMedia:!0})}catch(a){this.setState({hasUserMedia:!0,src:window.URL.createObjectURL(t)})}n.onUserMedia(t)},t.prototype.render=function(){var e=this,t=this.state,n=this.props,s=n.audio,o=(n.forceScreenshotSourceSize,n.disablePictureInPicture),c=(n.onUserMedia,n.onUserMediaError,n.screenshotFormat,n.screenshotQuality,n.minScreenshotWidth,n.minScreenshotHeight,n.audioConstraints,n.videoConstraints,n.imageSmoothing,n.mirrored),l=n.style,u=void 0===l?{}:l,h=n.children,d=i(n,["audio","forceScreenshotSourceSize","disablePictureInPicture","onUserMedia","onUserMediaError","screenshotFormat","screenshotQuality","minScreenshotWidth","minScreenshotHeight","audioConstraints","videoConstraints","imageSmoothing","mirrored","style","children"]),p=c?r(r({},u),{transform:(u.transform||"")+" scaleX(-1)"}):u,f={getScreenshot:this.getScreenshot.bind(this)};return a.createElement(a.Fragment,null,a.createElement("video",r({autoPlay:!0,disablePictureInPicture:o,src:t.src,muted:!s,playsInline:!0,ref:function(t){e.video=t},style:p},d)),h&&h(f))},t.defaultProps={audio:!1,disablePictureInPicture:!1,forceScreenshotSourceSize:!1,imageSmoothing:!0,mirrored:!1,onUserMedia:function(){},onUserMediaError:function(){},screenshotFormat:"image/webp",screenshotQuality:.92},t}(a.Component);t.default=c},react:function(t,n){t.exports=e}}).default},e.exports=a(n(43))},43(e,t,n){"use strict";e.exports=n(202)},66(e,t,n){var a;!function(e,s){function r(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var a=0;a<n.length+64;a++)t.x^=0|n.charCodeAt(a),t.next()}function i(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function o(e,t){var n=new r(e),a=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,a&&("object"==typeof a&&i(a,n),s.state=function(){return i(n,{})}),s}s&&s.exports?s.exports=o:n.amdD&&n.amdO?void 0===(a=function(){return o}.call(t,n,t,s))||(s.exports=a):this.xor128=o}(0,e=n.nmd(e),n.amdD)},108(){},153(e,t,n){"use strict";var a=n(43),s=Symbol.for("react.element"),r=Symbol.for("react.fragment"),i=Object.prototype.hasOwnProperty,o=a.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,c={key:!0,ref:!0,__self:!0,__source:!0};function l(e,t,n){var a,r={},l=null,u=null;for(a in void 0!==n&&(l=""+n),void 0!==t.key&&(l=""+t.key),void 0!==t.ref&&(u=t.ref),t)i.call(t,a)&&!c.hasOwnProperty(a)&&(r[a]=t[a]);if(e&&e.defaultProps)for(a in t=e.defaultProps)void 0===r[a]&&(r[a]=t[a]);return{$$typeof:s,type:e,key:l,ref:u,props:r,_owner:o.current}}t.Fragment=r,t.jsx=l,t.jsxs=l},202(e,t){"use strict";var n=Symbol.for("react.element"),a=Symbol.for("react.portal"),s=Symbol.for("react.fragment"),r=Symbol.for("react.strict_mode"),i=Symbol.for("react.profiler"),o=Symbol.for("react.provider"),c=Symbol.for("react.context"),l=Symbol.for("react.forward_ref"),u=Symbol.for("react.suspense"),h=Symbol.for("react.memo"),d=Symbol.for("react.lazy"),p=Symbol.iterator;var f={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},m=Object.assign,g={};function y(e,t,n){this.props=e,this.context=t,this.refs=g,this.updater=n||f}function b(){}function x(e,t,n){this.props=e,this.context=t,this.refs=g,this.updater=n||f}y.prototype.isReactComponent={},y.prototype.setState=function(e,t){if("object"!==typeof e&&"function"!==typeof e&&null!=e)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,e,t,"setState")},y.prototype.forceUpdate=function(e){this.updater.enqueueForceUpdate(this,e,"forceUpdate")},b.prototype=y.prototype;var v=x.prototype=new b;v.constructor=x,m(v,y.prototype),v.isPureReactComponent=!0;var w=Array.isArray,k=Object.prototype.hasOwnProperty,S={current:null},C={key:!0,ref:!0,__self:!0,__source:!0};function I(e,t,a){var s,r={},i=null,o=null;if(null!=t)for(s in void 0!==t.ref&&(o=t.ref),void 0!==t.key&&(i=""+t.key),t)k.call(t,s)&&!C.hasOwnProperty(s)&&(r[s]=t[s]);var c=arguments.length-2;if(1===c)r.children=a;else if(1<c){for(var l=Array(c),u=0;u<c;u++)l[u]=arguments[u+2];r.children=l}if(e&&e.defaultProps)for(s in c=e.defaultProps)void 0===r[s]&&(r[s]=c[s]);return{$$typeof:n,type:e,key:i,ref:o,props:r,_owner:S.current}}function N(e){return"object"===typeof e&&null!==e&&e.$$typeof===n}var T=/\/+/g;function E(e,t){return"object"===typeof e&&null!==e&&null!=e.key?function(e){var t={"=":"=0",":":"=2"};return"$"+e.replace(/[=:]/g,function(e){return t[e]})}(""+e.key):t.toString(36)}function R(e,t,s,r,i){var o=typeof e;"undefined"!==o&&"boolean"!==o||(e=null);var c=!1;if(null===e)c=!0;else switch(o){case"string":case"number":c=!0;break;case"object":switch(e.$$typeof){case n:case a:c=!0}}if(c)return i=i(c=e),e=""===r?"."+E(c,0):r,w(i)?(s="",null!=e&&(s=e.replace(T,"$&/")+"/"),R(i,t,s,"",function(e){return e})):null!=i&&(N(i)&&(i=function(e,t){return{$$typeof:n,type:e.type,key:t,ref:e.ref,props:e.props,_owner:e._owner}}(i,s+(!i.key||c&&c.key===i.key?"":(""+i.key).replace(T,"$&/")+"/")+e)),t.push(i)),1;if(c=0,r=""===r?".":r+":",w(e))for(var l=0;l<e.length;l++){var u=r+E(o=e[l],l);c+=R(o,t,s,u,i)}else if(u=function(e){return null===e||"object"!==typeof e?null:"function"===typeof(e=p&&e[p]||e["@@iterator"])?e:null}(e),"function"===typeof u)for(e=u.call(e),l=0;!(o=e.next()).done;)c+=R(o=o.value,t,s,u=r+E(o,l++),i);else if("object"===o)throw t=String(e),Error("Objects are not valid as a React child (found: "+("[object Object]"===t?"object with keys {"+Object.keys(e).join(", ")+"}":t)+"). If you meant to render a collection of children, use an array instead.");return c}function _(e,t,n){if(null==e)return e;var a=[],s=0;return R(e,a,"","",function(e){return t.call(n,e,s++)}),a}function A(e){if(-1===e._status){var t=e._result;(t=t()).then(function(t){0!==e._status&&-1!==e._status||(e._status=1,e._result=t)},function(t){0!==e._status&&-1!==e._status||(e._status=2,e._result=t)}),-1===e._status&&(e._status=0,e._result=t)}if(1===e._status)return e._result.default;throw e._result}var M={current:null},P={transition:null},D={ReactCurrentDispatcher:M,ReactCurrentBatchConfig:P,ReactCurrentOwner:S};function O(){throw Error("act(...) is not supported in production builds of React.")}t.Children={map:_,forEach:function(e,t,n){_(e,function(){t.apply(this,arguments)},n)},count:function(e){var t=0;return _(e,function(){t++}),t},toArray:function(e){return _(e,function(e){return e})||[]},only:function(e){if(!N(e))throw Error("React.Children.only expected to receive a single React element child.");return e}},t.Component=y,t.Fragment=s,t.Profiler=i,t.PureComponent=x,t.StrictMode=r,t.Suspense=u,t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=D,t.act=O,t.cloneElement=function(e,t,a){if(null===e||void 0===e)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+e+".");var s=m({},e.props),r=e.key,i=e.ref,o=e._owner;if(null!=t){if(void 0!==t.ref&&(i=t.ref,o=S.current),void 0!==t.key&&(r=""+t.key),e.type&&e.type.defaultProps)var c=e.type.defaultProps;for(l in t)k.call(t,l)&&!C.hasOwnProperty(l)&&(s[l]=void 0===t[l]&&void 0!==c?c[l]:t[l])}var l=arguments.length-2;if(1===l)s.children=a;else if(1<l){c=Array(l);for(var u=0;u<l;u++)c[u]=arguments[u+2];s.children=c}return{$$typeof:n,type:e.type,key:r,ref:i,props:s,_owner:o}},t.createContext=function(e){return(e={$$typeof:c,_currentValue:e,_currentValue2:e,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null}).Provider={$$typeof:o,_context:e},e.Consumer=e},t.createElement=I,t.createFactory=function(e){var t=I.bind(null,e);return t.type=e,t},t.createRef=function(){return{current:null}},t.forwardRef=function(e){return{$$typeof:l,render:e}},t.isValidElement=N,t.lazy=function(e){return{$$typeof:d,_payload:{_status:-1,_result:e},_init:A}},t.memo=function(e,t){return{$$typeof:h,type:e,compare:void 0===t?null:t}},t.startTransition=function(e){var t=P.transition;P.transition={};try{e()}finally{P.transition=t}},t.unstable_act=O,t.useCallback=function(e,t){return M.current.useCallback(e,t)},t.useContext=function(e){return M.current.useContext(e)},t.useDebugValue=function(){},t.useDeferredValue=function(e){return M.current.useDeferredValue(e)},t.useEffect=function(e,t){return M.current.useEffect(e,t)},t.useId=function(){return M.current.useId()},t.useImperativeHandle=function(e,t,n){return M.current.useImperativeHandle(e,t,n)},t.useInsertionEffect=function(e,t){return M.current.useInsertionEffect(e,t)},t.useLayoutEffect=function(e,t){return M.current.useLayoutEffect(e,t)},t.useMemo=function(e,t){return M.current.useMemo(e,t)},t.useReducer=function(e,t,n){return M.current.useReducer(e,t,n)},t.useRef=function(e){return M.current.useRef(e)},t.useState=function(e){return M.current.useState(e)},t.useSyncExternalStore=function(e,t,n){return M.current.useSyncExternalStore(e,t,n)},t.useTransition=function(){return M.current.useTransition()},t.version="18.3.1"},234(e,t){"use strict";function n(e,t){var n=e.length;e.push(t);e:for(;0<n;){var a=n-1>>>1,s=e[a];if(!(0<r(s,t)))break e;e[a]=t,e[n]=s,n=a}}function a(e){return 0===e.length?null:e[0]}function s(e){if(0===e.length)return null;var t=e[0],n=e.pop();if(n!==t){e[0]=n;e:for(var a=0,s=e.length,i=s>>>1;a<i;){var o=2*(a+1)-1,c=e[o],l=o+1,u=e[l];if(0>r(c,n))l<s&&0>r(u,c)?(e[a]=u,e[l]=n,a=l):(e[a]=c,e[o]=n,a=o);else{if(!(l<s&&0>r(u,n)))break e;e[a]=u,e[l]=n,a=l}}}return t}function r(e,t){var n=e.sortIndex-t.sortIndex;return 0!==n?n:e.id-t.id}if("object"===typeof performance&&"function"===typeof performance.now){var i=performance;t.unstable_now=function(){return i.now()}}else{var o=Date,c=o.now();t.unstable_now=function(){return o.now()-c}}var l=[],u=[],h=1,d=null,p=3,f=!1,m=!1,g=!1,y="function"===typeof setTimeout?setTimeout:null,b="function"===typeof clearTimeout?clearTimeout:null,x="undefined"!==typeof setImmediate?setImmediate:null;function v(e){for(var t=a(u);null!==t;){if(null===t.callback)s(u);else{if(!(t.startTime<=e))break;s(u),t.sortIndex=t.expirationTime,n(l,t)}t=a(u)}}function w(e){if(g=!1,v(e),!m)if(null!==a(l))m=!0,P(k);else{var t=a(u);null!==t&&D(w,t.startTime-e)}}function k(e,n){m=!1,g&&(g=!1,b(N),N=-1),f=!0;var r=p;try{for(v(n),d=a(l);null!==d&&(!(d.expirationTime>n)||e&&!R());){var i=d.callback;if("function"===typeof i){d.callback=null,p=d.priorityLevel;var o=i(d.expirationTime<=n);n=t.unstable_now(),"function"===typeof o?d.callback=o:d===a(l)&&s(l),v(n)}else s(l);d=a(l)}if(null!==d)var c=!0;else{var h=a(u);null!==h&&D(w,h.startTime-n),c=!1}return c}finally{d=null,p=r,f=!1}}"undefined"!==typeof navigator&&void 0!==navigator.scheduling&&void 0!==navigator.scheduling.isInputPending&&navigator.scheduling.isInputPending.bind(navigator.scheduling);var S,C=!1,I=null,N=-1,T=5,E=-1;function R(){return!(t.unstable_now()-E<T)}function _(){if(null!==I){var e=t.unstable_now();E=e;var n=!0;try{n=I(!0,e)}finally{n?S():(C=!1,I=null)}}else C=!1}if("function"===typeof x)S=function(){x(_)};else if("undefined"!==typeof MessageChannel){var A=new MessageChannel,M=A.port2;A.port1.onmessage=_,S=function(){M.postMessage(null)}}else S=function(){y(_,0)};function P(e){I=e,C||(C=!0,S())}function D(e,n){N=y(function(){e(t.unstable_now())},n)}t.unstable_IdlePriority=5,t.unstable_ImmediatePriority=1,t.unstable_LowPriority=4,t.unstable_NormalPriority=3,t.unstable_Profiling=null,t.unstable_UserBlockingPriority=2,t.unstable_cancelCallback=function(e){e.callback=null},t.unstable_continueExecution=function(){m||f||(m=!0,P(k))},t.unstable_forceFrameRate=function(e){0>e||125<e?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):T=0<e?Math.floor(1e3/e):5},t.unstable_getCurrentPriorityLevel=function(){return p},t.unstable_getFirstCallbackNode=function(){return a(l)},t.unstable_next=function(e){switch(p){case 1:case 2:case 3:var t=3;break;default:t=p}var n=p;p=t;try{return e()}finally{p=n}},t.unstable_pauseExecution=function(){},t.unstable_requestPaint=function(){},t.unstable_runWithPriority=function(e,t){switch(e){case 1:case 2:case 3:case 4:case 5:break;default:e=3}var n=p;p=e;try{return t()}finally{p=n}},t.unstable_scheduleCallback=function(e,s,r){var i=t.unstable_now();switch("object"===typeof r&&null!==r?r="number"===typeof(r=r.delay)&&0<r?i+r:i:r=i,e){case 1:var o=-1;break;case 2:o=250;break;case 5:o=1073741823;break;case 4:o=1e4;break;default:o=5e3}return e={id:h++,callback:s,priorityLevel:e,startTime:r,expirationTime:o=r+o,sortIndex:-1},r>i?(e.sortIndex=r,n(u,e),null===a(l)&&e===a(u)&&(g?(b(N),N=-1):g=!0,D(w,r-i))):(e.sortIndex=o,n(l,e),m||f||(m=!0,P(k))),e},t.unstable_shouldYield=R,t.unstable_wrapCallback=function(e){var t=p;return function(){var n=p;p=t;try{return e.apply(this,arguments)}finally{p=n}}}},262(e,t,n){var a;!function(e,s){function r(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,a=t.d,s=t.a;return e=e<<25^e>>>7^n,n=n-a|0,a=a<<24^a>>>8^s,s=s-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-a|0,t.d=a<<16^n>>>16^s,t.a=s-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var a=0;a<n.length+20;a++)t.b^=0|n.charCodeAt(a),t.next()}function i(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function o(e,t){var n=new r(e),a=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,a&&("object"==typeof a&&i(a,n),s.state=function(){return i(n,{})}),s}s&&s.exports?s.exports=o:n.amdD&&n.amdO?void 0===(a=function(){return o}.call(t,n,t,s))||(s.exports=a):this.tychei=o}(0,e=n.nmd(e),n.amdD)},288(e,t,n){var a;!function(e,s){function r(e){var t=this;t.next=function(){var e,n,a=t.w,s=t.X,r=t.i;return t.w=a=a+1640531527|0,n=s[r+34&127],e=s[r=r+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=s[r]=n^e,t.i=r,n+(a^a>>>16)|0},function(e,t){var n,a,s,r,i,o=[],c=128;for(t===(0|t)?(a=t,t=null):(t+="\0",a=0,c=Math.max(c,t.length)),s=0,r=-32;r<c;++r)t&&(a^=t.charCodeAt((r+32)%t.length)),0===r&&(i=a),a^=a<<10,a^=a>>>15,a^=a<<4,a^=a>>>13,r>=0&&(i=i+1640531527|0,s=0==(n=o[127&r]^=a+i)?s+1:0);for(s>=128&&(o[127&(t&&t.length||0)]=-1),s=127,r=512;r>0;--r)a=o[s+34&127],n=o[s=s+1&127],a^=a<<13,n^=n<<17,a^=a>>>15,n^=n>>>12,o[s]=a^n;e.w=i,e.X=o,e.i=s}(t,e)}function i(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function o(e,t){null==e&&(e=+new Date);var n=new r(e),a=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,a&&(a.X&&i(a,n),s.state=function(){return i(n,{})}),s}s&&s.exports?s.exports=o:n.amdD&&n.amdO?void 0===(a=function(){return o}.call(t,n,t,s))||(s.exports=a):this.xor4096=o}(0,e=n.nmd(e),n.amdD)},334(e,t,n){var a=n(359),s=n(66),r=n(16),i=n(538),o=n(288),c=n(262),l=n(430);l.alea=a,l.xor128=s,l.xorwow=r,l.xorshift7=i,l.xor4096=o,l.tychei=c,e.exports=l},353(e){e.exports=n;var t=null;try{t=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(I){}function n(e,t,n){this.low=0|e,this.high=0|t,this.unsigned=!!n}function a(e){return!0===(e&&e.__isLong__)}n.prototype.__isLong__,Object.defineProperty(n.prototype,"__isLong__",{value:!0}),n.isLong=a;var s={},r={};function i(e,t){var n,a,i;return t?(i=0<=(e>>>=0)&&e<256)&&(a=r[e])?a:(n=c(e,(0|e)<0?-1:0,!0),i&&(r[e]=n),n):(i=-128<=(e|=0)&&e<128)&&(a=s[e])?a:(n=c(e,e<0?-1:0,!1),i&&(s[e]=n),n)}function o(e,t){if(isNaN(e))return t?y:g;if(t){if(e<0)return y;if(e>=p)return k}else{if(e<=-f)return S;if(e+1>=f)return w}return e<0?o(-e,t).neg():c(e%d|0,e/d|0,t)}function c(e,t,a){return new n(e,t,a)}n.fromInt=i,n.fromNumber=o,n.fromBits=c;var l=Math.pow;function u(e,t,n){if(0===e.length)throw Error("empty string");if("NaN"===e||"Infinity"===e||"+Infinity"===e||"-Infinity"===e)return g;if("number"===typeof t?(n=t,t=!1):t=!!t,(n=n||10)<2||36<n)throw RangeError("radix");var a;if((a=e.indexOf("-"))>0)throw Error("interior hyphen");if(0===a)return u(e.substring(1),t,n).neg();for(var s=o(l(n,8)),r=g,i=0;i<e.length;i+=8){var c=Math.min(8,e.length-i),h=parseInt(e.substring(i,i+c),n);if(c<8){var d=o(l(n,c));r=r.mul(d).add(o(h))}else r=(r=r.mul(s)).add(o(h))}return r.unsigned=t,r}function h(e,t){return"number"===typeof e?o(e,t):"string"===typeof e?u(e,t):c(e.low,e.high,"boolean"===typeof t?t:e.unsigned)}n.fromString=u,n.fromValue=h;var d=4294967296,p=d*d,f=p/2,m=i(1<<24),g=i(0);n.ZERO=g;var y=i(0,!0);n.UZERO=y;var b=i(1);n.ONE=b;var x=i(1,!0);n.UONE=x;var v=i(-1);n.NEG_ONE=v;var w=c(-1,2147483647,!1);n.MAX_VALUE=w;var k=c(-1,-1,!0);n.MAX_UNSIGNED_VALUE=k;var S=c(0,-2147483648,!1);n.MIN_VALUE=S;var C=n.prototype;C.toInt=function(){return this.unsigned?this.low>>>0:this.low},C.toNumber=function(){return this.unsigned?(this.high>>>0)*d+(this.low>>>0):this.high*d+(this.low>>>0)},C.toString=function(e){if((e=e||10)<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(S)){var t=o(e),n=this.div(t),a=n.mul(t).sub(this);return n.toString(e)+a.toInt().toString(e)}return"-"+this.neg().toString(e)}for(var s=o(l(e,6),this.unsigned),r=this,i="";;){var c=r.div(s),u=(r.sub(c.mul(s)).toInt()>>>0).toString(e);if((r=c).isZero())return u+i;for(;u.length<6;)u="0"+u;i=""+u+i}},C.getHighBits=function(){return this.high},C.getHighBitsUnsigned=function(){return this.high>>>0},C.getLowBits=function(){return this.low},C.getLowBitsUnsigned=function(){return this.low>>>0},C.getNumBitsAbs=function(){if(this.isNegative())return this.eq(S)?64:this.neg().getNumBitsAbs();for(var e=0!=this.high?this.high:this.low,t=31;t>0&&0==(e&1<<t);t--);return 0!=this.high?t+33:t+1},C.isZero=function(){return 0===this.high&&0===this.low},C.eqz=C.isZero,C.isNegative=function(){return!this.unsigned&&this.high<0},C.isPositive=function(){return this.unsigned||this.high>=0},C.isOdd=function(){return 1===(1&this.low)},C.isEven=function(){return 0===(1&this.low)},C.equals=function(e){return a(e)||(e=h(e)),(this.unsigned===e.unsigned||this.high>>>31!==1||e.high>>>31!==1)&&(this.high===e.high&&this.low===e.low)},C.eq=C.equals,C.notEquals=function(e){return!this.eq(e)},C.neq=C.notEquals,C.ne=C.notEquals,C.lessThan=function(e){return this.comp(e)<0},C.lt=C.lessThan,C.lessThanOrEqual=function(e){return this.comp(e)<=0},C.lte=C.lessThanOrEqual,C.le=C.lessThanOrEqual,C.greaterThan=function(e){return this.comp(e)>0},C.gt=C.greaterThan,C.greaterThanOrEqual=function(e){return this.comp(e)>=0},C.gte=C.greaterThanOrEqual,C.ge=C.greaterThanOrEqual,C.compare=function(e){if(a(e)||(e=h(e)),this.eq(e))return 0;var t=this.isNegative(),n=e.isNegative();return t&&!n?-1:!t&&n?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1},C.comp=C.compare,C.negate=function(){return!this.unsigned&&this.eq(S)?S:this.not().add(b)},C.neg=C.negate,C.add=function(e){a(e)||(e=h(e));var t=this.high>>>16,n=65535&this.high,s=this.low>>>16,r=65535&this.low,i=e.high>>>16,o=65535&e.high,l=e.low>>>16,u=0,d=0,p=0,f=0;return p+=(f+=r+(65535&e.low))>>>16,d+=(p+=s+l)>>>16,u+=(d+=n+o)>>>16,u+=t+i,c((p&=65535)<<16|(f&=65535),(u&=65535)<<16|(d&=65535),this.unsigned)},C.subtract=function(e){return a(e)||(e=h(e)),this.add(e.neg())},C.sub=C.subtract,C.multiply=function(e){if(this.isZero())return g;if(a(e)||(e=h(e)),t)return c(t.mul(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned);if(e.isZero())return g;if(this.eq(S))return e.isOdd()?S:g;if(e.eq(S))return this.isOdd()?S:g;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(m)&&e.lt(m))return o(this.toNumber()*e.toNumber(),this.unsigned);var n=this.high>>>16,s=65535&this.high,r=this.low>>>16,i=65535&this.low,l=e.high>>>16,u=65535&e.high,d=e.low>>>16,p=65535&e.low,f=0,y=0,b=0,x=0;return b+=(x+=i*p)>>>16,y+=(b+=r*p)>>>16,b&=65535,y+=(b+=i*d)>>>16,f+=(y+=s*p)>>>16,y&=65535,f+=(y+=r*d)>>>16,y&=65535,f+=(y+=i*u)>>>16,f+=n*p+s*d+r*u+i*l,c((b&=65535)<<16|(x&=65535),(f&=65535)<<16|(y&=65535),this.unsigned)},C.mul=C.multiply,C.divide=function(e){if(a(e)||(e=h(e)),e.isZero())throw Error("division by zero");var n,s,r;if(t)return this.unsigned||-2147483648!==this.high||-1!==e.low||-1!==e.high?c((this.unsigned?t.div_u:t.div_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?y:g;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return y;if(e.gt(this.shru(1)))return x;r=y}else{if(this.eq(S))return e.eq(b)||e.eq(v)?S:e.eq(S)?b:(n=this.shr(1).div(e).shl(1)).eq(g)?e.isNegative()?b:v:(s=this.sub(e.mul(n)),r=n.add(s.div(e)));if(e.eq(S))return this.unsigned?y:g;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();r=g}for(s=this;s.gte(e);){n=Math.max(1,Math.floor(s.toNumber()/e.toNumber()));for(var i=Math.ceil(Math.log(n)/Math.LN2),u=i<=48?1:l(2,i-48),d=o(n),p=d.mul(e);p.isNegative()||p.gt(s);)p=(d=o(n-=u,this.unsigned)).mul(e);d.isZero()&&(d=b),r=r.add(d),s=s.sub(p)}return r},C.div=C.divide,C.modulo=function(e){return a(e)||(e=h(e)),t?c((this.unsigned?t.rem_u:t.rem_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this.sub(this.div(e).mul(e))},C.mod=C.modulo,C.rem=C.modulo,C.not=function(){return c(~this.low,~this.high,this.unsigned)},C.and=function(e){return a(e)||(e=h(e)),c(this.low&e.low,this.high&e.high,this.unsigned)},C.or=function(e){return a(e)||(e=h(e)),c(this.low|e.low,this.high|e.high,this.unsigned)},C.xor=function(e){return a(e)||(e=h(e)),c(this.low^e.low,this.high^e.high,this.unsigned)},C.shiftLeft=function(e){return a(e)&&(e=e.toInt()),0===(e&=63)?this:e<32?c(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):c(0,this.low<<e-32,this.unsigned)},C.shl=C.shiftLeft,C.shiftRight=function(e){return a(e)&&(e=e.toInt()),0===(e&=63)?this:e<32?c(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):c(this.high>>e-32,this.high>=0?0:-1,this.unsigned)},C.shr=C.shiftRight,C.shiftRightUnsigned=function(e){if(a(e)&&(e=e.toInt()),0===(e&=63))return this;var t=this.high;return e<32?c(this.low>>>e|t<<32-e,t>>>e,this.unsigned):c(32===e?t:t>>>e-32,0,this.unsigned)},C.shru=C.shiftRightUnsigned,C.shr_u=C.shiftRightUnsigned,C.toSigned=function(){return this.unsigned?c(this.low,this.high,!1):this},C.toUnsigned=function(){return this.unsigned?this:c(this.low,this.high,!0)},C.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()},C.toBytesLE=function(){var e=this.high,t=this.low;return[255&t,t>>>8&255,t>>>16&255,t>>>24,255&e,e>>>8&255,e>>>16&255,e>>>24]},C.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,255&e,t>>>24,t>>>16&255,t>>>8&255,255&t]},n.fromBytes=function(e,t,a){return a?n.fromBytesLE(e,t):n.fromBytesBE(e,t)},n.fromBytesLE=function(e,t){return new n(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)},n.fromBytesBE=function(e,t){return new n(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)}},359(e,t,n){var a;!function(e,s){function r(e){var t=this,n=function(){var e=4022871197,t=function(t){t=String(t);for(var n=0;n<t.length;n++){var a=.02519603282416938*(e+=t.charCodeAt(n));a-=e=a>>>0,e=(a*=e)>>>0,e+=4294967296*(a-=e)}return 2.3283064365386963e-10*(e>>>0)};return t}();t.next=function(){var e=2091639*t.s0+2.3283064365386963e-10*t.c;return t.s0=t.s1,t.s1=t.s2,t.s2=e-(t.c=0|e)},t.c=1,t.s0=n(" "),t.s1=n(" "),t.s2=n(" "),t.s0-=n(e),t.s0<0&&(t.s0+=1),t.s1-=n(e),t.s1<0&&(t.s1+=1),t.s2-=n(e),t.s2<0&&(t.s2+=1),n=null}function i(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function o(e,t){var n=new r(e),a=t&&t.state,s=n.next;return s.int32=function(){return 4294967296*n.next()|0},s.double=function(){return s()+11102230246251565e-32*(2097152*s()|0)},s.quick=s,a&&("object"==typeof a&&i(a,n),s.state=function(){return i(n,{})}),s}s&&s.exports?s.exports=o:n.amdD&&n.amdO?void 0===(a=function(){return o}.call(t,n,t,s))||(s.exports=a):this.alea=o}(0,e=n.nmd(e),n.amdD)},391(e,t,n){"use strict";var a=n(950);t.createRoot=a.createRoot,t.hydrateRoot=a.hydrateRoot},430(e,t,n){var a;!function(s,r,i){var o,c=256,l=i.pow(c,6),u=i.pow(2,52),h=2*u,d=255;function p(e,t,n){var a=[],d=y(g((t=1==t?{entropy:!0}:t||{}).entropy?[e,b(r)]:null==e?function(){try{var e;return o&&(e=o.randomBytes)?e=e(c):(e=new Uint8Array(c),(s.crypto||s.msCrypto).getRandomValues(e)),b(e)}catch(a){var t=s.navigator,n=t&&t.plugins;return[+new Date,s,n,s.screen,b(r)]}}():e,3),a),p=new f(a),x=function(){for(var e=p.g(6),t=l,n=0;e<u;)e=(e+n)*c,t*=c,n=p.g(1);for(;e>=h;)e/=2,t/=2,n>>>=1;return(e+n)/t};return x.int32=function(){return 0|p.g(4)},x.quick=function(){return p.g(4)/4294967296},x.double=x,y(b(p.S),r),(t.pass||n||function(e,t,n,a){return a&&(a.S&&m(a,p),e.state=function(){return m(p,{})}),n?(i.random=e,t):e})(x,d,"global"in t?t.global:this==i,t.state)}function f(e){var t,n=e.length,a=this,s=0,r=a.i=a.j=0,i=a.S=[];for(n||(e=[n++]);s<c;)i[s]=s++;for(s=0;s<c;s++)i[s]=i[r=d&r+e[s%n]+(t=i[s])],i[r]=t;(a.g=function(e){for(var t,n=0,s=a.i,r=a.j,i=a.S;e--;)t=i[s=d&s+1],n=n*c+i[d&(i[s]=i[r=d&r+t])+(i[r]=t)];return a.i=s,a.j=r,n})(c)}function m(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function g(e,t){var n,a=[],s=typeof e;if(t&&"object"==s)for(n in e)try{a.push(g(e[n],t-1))}catch(r){}return a.length?a:"string"==s?e:e+"\0"}function y(e,t){for(var n,a=e+"",s=0;s<a.length;)t[d&s]=d&(n^=19*t[d&s])+a.charCodeAt(s++);return b(t)}function b(e){return String.fromCharCode.apply(0,e)}if(y(i.random(),r),e.exports){e.exports=p;try{o=n(996)}catch(x){}}else void 0===(a=function(){return p}.call(t,n,t,e))||(e.exports=a)}("undefined"!==typeof self?self:this,[],Math)},530(){},538(e,t,n){var a;!function(e,s){function r(e){var t=this;t.next=function(){var e,n,a=t.x,s=t.i;return e=a[s],n=(e^=e>>>7)^e<<24,n^=(e=a[s+1&7])^e>>>10,n^=(e=a[s+3&7])^e>>>3,n^=(e=a[s+4&7])^e<<7,e=a[s+7&7],n^=(e^=e<<13)^e<<9,a[s]=n,t.i=s+1&7,n},function(e,t){var n,a=[];if(t===(0|t))a[0]=t;else for(t=""+t,n=0;n<t.length;++n)a[7&n]=a[7&n]<<15^t.charCodeAt(n)+a[n+1&7]<<13;for(;a.length<8;)a.push(0);for(n=0;n<8&&0===a[n];++n);for(8==n?a[7]=-1:a[n],e.x=a,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function i(e,t){return t.x=e.x.slice(),t.i=e.i,t}function o(e,t){null==e&&(e=+new Date);var n=new r(e),a=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,a&&(a.x&&i(a,n),s.state=function(){return i(n,{})}),s}s&&s.exports?s.exports=o:n.amdD&&n.amdO?void 0===(a=function(){return o}.call(t,n,t,s))||(s.exports=a):this.xorshift7=o}(0,e=n.nmd(e),n.amdD)},551(){},579(e,t,n){"use strict";e.exports=n(153)},590(){},730(e,t,n){"use strict";var a=n(43),s=n(853);function r(e){for(var t="https://reactjs.org/docs/error-decoder.html?invariant="+e,n=1;n<arguments.length;n++)t+="&args[]="+encodeURIComponent(arguments[n]);return"Minified React error #"+e+"; visit "+t+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var i=new Set,o={};function c(e,t){l(e,t),l(e+"Capture",t)}function l(e,t){for(o[e]=t,e=0;e<t.length;e++)i.add(t[e])}var u=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),h=Object.prototype.hasOwnProperty,d=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,p={},f={};function m(e,t,n,a,s,r,i){this.acceptsBooleans=2===t||3===t||4===t,this.attributeName=a,this.attributeNamespace=s,this.mustUseProperty=n,this.propertyName=e,this.type=t,this.sanitizeURL=r,this.removeEmptyString=i}var g={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(e){g[e]=new m(e,0,!1,e,null,!1,!1)}),[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(e){var t=e[0];g[t]=new m(t,1,!1,e[1],null,!1,!1)}),["contentEditable","draggable","spellCheck","value"].forEach(function(e){g[e]=new m(e,2,!1,e.toLowerCase(),null,!1,!1)}),["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(e){g[e]=new m(e,2,!1,e,null,!1,!1)}),"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(e){g[e]=new m(e,3,!1,e.toLowerCase(),null,!1,!1)}),["checked","multiple","muted","selected"].forEach(function(e){g[e]=new m(e,3,!0,e,null,!1,!1)}),["capture","download"].forEach(function(e){g[e]=new m(e,4,!1,e,null,!1,!1)}),["cols","rows","size","span"].forEach(function(e){g[e]=new m(e,6,!1,e,null,!1,!1)}),["rowSpan","start"].forEach(function(e){g[e]=new m(e,5,!1,e.toLowerCase(),null,!1,!1)});var y=/[\-:]([a-z])/g;function b(e){return e[1].toUpperCase()}function x(e,t,n,a){var s=g.hasOwnProperty(t)?g[t]:null;(null!==s?0!==s.type:a||!(2<t.length)||"o"!==t[0]&&"O"!==t[0]||"n"!==t[1]&&"N"!==t[1])&&(function(e,t,n,a){if(null===t||"undefined"===typeof t||function(e,t,n,a){if(null!==n&&0===n.type)return!1;switch(typeof t){case"function":case"symbol":return!0;case"boolean":return!a&&(null!==n?!n.acceptsBooleans:"data-"!==(e=e.toLowerCase().slice(0,5))&&"aria-"!==e);default:return!1}}(e,t,n,a))return!0;if(a)return!1;if(null!==n)switch(n.type){case 3:return!t;case 4:return!1===t;case 5:return isNaN(t);case 6:return isNaN(t)||1>t}return!1}(t,n,s,a)&&(n=null),a||null===s?function(e){return!!h.call(f,e)||!h.call(p,e)&&(d.test(e)?f[e]=!0:(p[e]=!0,!1))}(t)&&(null===n?e.removeAttribute(t):e.setAttribute(t,""+n)):s.mustUseProperty?e[s.propertyName]=null===n?3!==s.type&&"":n:(t=s.attributeName,a=s.attributeNamespace,null===n?e.removeAttribute(t):(n=3===(s=s.type)||4===s&&!0===n?"":""+n,a?e.setAttributeNS(a,t,n):e.setAttribute(t,n))))}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(e){var t=e.replace(y,b);g[t]=new m(t,1,!1,e,null,!1,!1)}),"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(e){var t=e.replace(y,b);g[t]=new m(t,1,!1,e,"http://www.w3.org/1999/xlink",!1,!1)}),["xml:base","xml:lang","xml:space"].forEach(function(e){var t=e.replace(y,b);g[t]=new m(t,1,!1,e,"http://www.w3.org/XML/1998/namespace",!1,!1)}),["tabIndex","crossOrigin"].forEach(function(e){g[e]=new m(e,1,!1,e.toLowerCase(),null,!1,!1)}),g.xlinkHref=new m("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1),["src","href","action","formAction"].forEach(function(e){g[e]=new m(e,1,!1,e.toLowerCase(),null,!0,!0)});var v=a.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,w=Symbol.for("react.element"),k=Symbol.for("react.portal"),S=Symbol.for("react.fragment"),C=Symbol.for("react.strict_mode"),I=Symbol.for("react.profiler"),N=Symbol.for("react.provider"),T=Symbol.for("react.context"),E=Symbol.for("react.forward_ref"),R=Symbol.for("react.suspense"),_=Symbol.for("react.suspense_list"),A=Symbol.for("react.memo"),M=Symbol.for("react.lazy");Symbol.for("react.scope"),Symbol.for("react.debug_trace_mode");var P=Symbol.for("react.offscreen");Symbol.for("react.legacy_hidden"),Symbol.for("react.cache"),Symbol.for("react.tracing_marker");var D=Symbol.iterator;function O(e){return null===e||"object"!==typeof e?null:"function"===typeof(e=D&&e[D]||e["@@iterator"])?e:null}var F,L=Object.assign;function z(e){if(void 0===F)try{throw Error()}catch(n){var t=n.stack.trim().match(/\n( *(at )?)/);F=t&&t[1]||""}return"\n"+F+e}var B=!1;function j(e,t){if(!e||B)return"";B=!0;var n=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(t)if(t=function(){throw Error()},Object.defineProperty(t.prototype,"props",{set:function(){throw Error()}}),"object"===typeof Reflect&&Reflect.construct){try{Reflect.construct(t,[])}catch(l){var a=l}Reflect.construct(e,[],t)}else{try{t.call()}catch(l){a=l}e.call(t.prototype)}else{try{throw Error()}catch(l){a=l}e()}}catch(l){if(l&&a&&"string"===typeof l.stack){for(var s=l.stack.split("\n"),r=a.stack.split("\n"),i=s.length-1,o=r.length-1;1<=i&&0<=o&&s[i]!==r[o];)o--;for(;1<=i&&0<=o;i--,o--)if(s[i]!==r[o]){if(1!==i||1!==o)do{if(i--,0>--o||s[i]!==r[o]){var c="\n"+s[i].replace(" at new "," at ");return e.displayName&&c.includes("<anonymous>")&&(c=c.replace("<anonymous>",e.displayName)),c}}while(1<=i&&0<=o);break}}}finally{B=!1,Error.prepareStackTrace=n}return(e=e?e.displayName||e.name:"")?z(e):""}function W(e){switch(e.tag){case 5:return z(e.type);case 16:return z("Lazy");case 13:return z("Suspense");case 19:return z("SuspenseList");case 0:case 2:case 15:return e=j(e.type,!1);case 11:return e=j(e.type.render,!1);case 1:return e=j(e.type,!0);default:return""}}function V(e){if(null==e)return null;if("function"===typeof e)return e.displayName||e.name||null;if("string"===typeof e)return e;switch(e){case S:return"Fragment";case k:return"Portal";case I:return"Profiler";case C:return"StrictMode";case R:return"Suspense";case _:return"SuspenseList"}if("object"===typeof e)switch(e.$$typeof){case T:return(e.displayName||"Context")+".Consumer";case N:return(e._context.displayName||"Context")+".Provider";case E:var t=e.render;return(e=e.displayName)||(e=""!==(e=t.displayName||t.name||"")?"ForwardRef("+e+")":"ForwardRef"),e;case A:return null!==(t=e.displayName||null)?t:V(e.type)||"Memo";case M:t=e._payload,e=e._init;try{return V(e(t))}catch(n){}}return null}function U(e){var t=e.type;switch(e.tag){case 24:return"Cache";case 9:return(t.displayName||"Context")+".Consumer";case 10:return(t._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return e=(e=t.render).displayName||e.name||"",t.displayName||(""!==e?"ForwardRef("+e+")":"ForwardRef");case 7:return"Fragment";case 5:return t;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return V(t);case 8:return t===C?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if("function"===typeof t)return t.displayName||t.name||null;if("string"===typeof t)return t}return null}function H(e){switch(typeof e){case"boolean":case"number":case"string":case"undefined":case"object":return e;default:return""}}function G(e){var t=e.type;return(e=e.nodeName)&&"input"===e.toLowerCase()&&("checkbox"===t||"radio"===t)}function q(e){e._valueTracker||(e._valueTracker=function(e){var t=G(e)?"checked":"value",n=Object.getOwnPropertyDescriptor(e.constructor.prototype,t),a=""+e[t];if(!e.hasOwnProperty(t)&&"undefined"!==typeof n&&"function"===typeof n.get&&"function"===typeof n.set){var s=n.get,r=n.set;return Object.defineProperty(e,t,{configurable:!0,get:function(){return s.call(this)},set:function(e){a=""+e,r.call(this,e)}}),Object.defineProperty(e,t,{enumerable:n.enumerable}),{getValue:function(){return a},setValue:function(e){a=""+e},stopTracking:function(){e._valueTracker=null,delete e[t]}}}}(e))}function K(e){if(!e)return!1;var t=e._valueTracker;if(!t)return!0;var n=t.getValue(),a="";return e&&(a=G(e)?e.checked?"true":"false":e.value),(e=a)!==n&&(t.setValue(e),!0)}function X(e){if("undefined"===typeof(e=e||("undefined"!==typeof document?document:void 0)))return null;try{return e.activeElement||e.body}catch(t){return e.body}}function Y(e,t){var n=t.checked;return L({},t,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=n?n:e._wrapperState.initialChecked})}function Q(e,t){var n=null==t.defaultValue?"":t.defaultValue,a=null!=t.checked?t.checked:t.defaultChecked;n=H(null!=t.value?t.value:n),e._wrapperState={initialChecked:a,initialValue:n,controlled:"checkbox"===t.type||"radio"===t.type?null!=t.checked:null!=t.value}}function Z(e,t){null!=(t=t.checked)&&x(e,"checked",t,!1)}function J(e,t){Z(e,t);var n=H(t.value),a=t.type;if(null!=n)"number"===a?(0===n&&""===e.value||e.value!=n)&&(e.value=""+n):e.value!==""+n&&(e.value=""+n);else if("submit"===a||"reset"===a)return void e.removeAttribute("value");t.hasOwnProperty("value")?ee(e,t.type,n):t.hasOwnProperty("defaultValue")&&ee(e,t.type,H(t.defaultValue)),null==t.checked&&null!=t.defaultChecked&&(e.defaultChecked=!!t.defaultChecked)}function $(e,t,n){if(t.hasOwnProperty("value")||t.hasOwnProperty("defaultValue")){var a=t.type;if(!("submit"!==a&&"reset"!==a||void 0!==t.value&&null!==t.value))return;t=""+e._wrapperState.initialValue,n||t===e.value||(e.value=t),e.defaultValue=t}""!==(n=e.name)&&(e.name=""),e.defaultChecked=!!e._wrapperState.initialChecked,""!==n&&(e.name=n)}function ee(e,t,n){"number"===t&&X(e.ownerDocument)===e||(null==n?e.defaultValue=""+e._wrapperState.initialValue:e.defaultValue!==""+n&&(e.defaultValue=""+n))}var te=Array.isArray;function ne(e,t,n,a){if(e=e.options,t){t={};for(var s=0;s<n.length;s++)t["$"+n[s]]=!0;for(n=0;n<e.length;n++)s=t.hasOwnProperty("$"+e[n].value),e[n].selected!==s&&(e[n].selected=s),s&&a&&(e[n].defaultSelected=!0)}else{for(n=""+H(n),t=null,s=0;s<e.length;s++){if(e[s].value===n)return e[s].selected=!0,void(a&&(e[s].defaultSelected=!0));null!==t||e[s].disabled||(t=e[s])}null!==t&&(t.selected=!0)}}function ae(e,t){if(null!=t.dangerouslySetInnerHTML)throw Error(r(91));return L({},t,{value:void 0,defaultValue:void 0,children:""+e._wrapperState.initialValue})}function se(e,t){var n=t.value;if(null==n){if(n=t.children,t=t.defaultValue,null!=n){if(null!=t)throw Error(r(92));if(te(n)){if(1<n.length)throw Error(r(93));n=n[0]}t=n}null==t&&(t=""),n=t}e._wrapperState={initialValue:H(n)}}function re(e,t){var n=H(t.value),a=H(t.defaultValue);null!=n&&((n=""+n)!==e.value&&(e.value=n),null==t.defaultValue&&e.defaultValue!==n&&(e.defaultValue=n)),null!=a&&(e.defaultValue=""+a)}function ie(e){var t=e.textContent;t===e._wrapperState.initialValue&&""!==t&&null!==t&&(e.value=t)}function oe(e){switch(e){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function ce(e,t){return null==e||"http://www.w3.org/1999/xhtml"===e?oe(t):"http://www.w3.org/2000/svg"===e&&"foreignObject"===t?"http://www.w3.org/1999/xhtml":e}var le,ue,he=(ue=function(e,t){if("http://www.w3.org/2000/svg"!==e.namespaceURI||"innerHTML"in e)e.innerHTML=t;else{for((le=le||document.createElement("div")).innerHTML="<svg>"+t.valueOf().toString()+"</svg>",t=le.firstChild;e.firstChild;)e.removeChild(e.firstChild);for(;t.firstChild;)e.appendChild(t.firstChild)}},"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(e,t,n,a){MSApp.execUnsafeLocalFunction(function(){return ue(e,t)})}:ue);function de(e,t){if(t){var n=e.firstChild;if(n&&n===e.lastChild&&3===n.nodeType)return void(n.nodeValue=t)}e.textContent=t}var pe={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},fe=["Webkit","ms","Moz","O"];function me(e,t,n){return null==t||"boolean"===typeof t||""===t?"":n||"number"!==typeof t||0===t||pe.hasOwnProperty(e)&&pe[e]?(""+t).trim():t+"px"}function ge(e,t){for(var n in e=e.style,t)if(t.hasOwnProperty(n)){var a=0===n.indexOf("--"),s=me(n,t[n],a);"float"===n&&(n="cssFloat"),a?e.setProperty(n,s):e[n]=s}}Object.keys(pe).forEach(function(e){fe.forEach(function(t){t=t+e.charAt(0).toUpperCase()+e.substring(1),pe[t]=pe[e]})});var ye=L({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function be(e,t){if(t){if(ye[e]&&(null!=t.children||null!=t.dangerouslySetInnerHTML))throw Error(r(137,e));if(null!=t.dangerouslySetInnerHTML){if(null!=t.children)throw Error(r(60));if("object"!==typeof t.dangerouslySetInnerHTML||!("__html"in t.dangerouslySetInnerHTML))throw Error(r(61))}if(null!=t.style&&"object"!==typeof t.style)throw Error(r(62))}}function xe(e,t){if(-1===e.indexOf("-"))return"string"===typeof t.is;switch(e){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var ve=null;function we(e){return(e=e.target||e.srcElement||window).correspondingUseElement&&(e=e.correspondingUseElement),3===e.nodeType?e.parentNode:e}var ke=null,Se=null,Ce=null;function Ie(e){if(e=xs(e)){if("function"!==typeof ke)throw Error(r(280));var t=e.stateNode;t&&(t=ws(t),ke(e.stateNode,e.type,t))}}function Ne(e){Se?Ce?Ce.push(e):Ce=[e]:Se=e}function Te(){if(Se){var e=Se,t=Ce;if(Ce=Se=null,Ie(e),t)for(e=0;e<t.length;e++)Ie(t[e])}}function Ee(e,t){return e(t)}function Re(){}var _e=!1;function Ae(e,t,n){if(_e)return e(t,n);_e=!0;try{return Ee(e,t,n)}finally{_e=!1,(null!==Se||null!==Ce)&&(Re(),Te())}}function Me(e,t){var n=e.stateNode;if(null===n)return null;var a=ws(n);if(null===a)return null;n=a[t];e:switch(t){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(a=!a.disabled)||(a=!("button"===(e=e.type)||"input"===e||"select"===e||"textarea"===e)),e=!a;break e;default:e=!1}if(e)return null;if(n&&"function"!==typeof n)throw Error(r(231,t,typeof n));return n}var Pe=!1;if(u)try{var De={};Object.defineProperty(De,"passive",{get:function(){Pe=!0}}),window.addEventListener("test",De,De),window.removeEventListener("test",De,De)}catch(ue){Pe=!1}function Oe(e,t,n,a,s,r,i,o,c){var l=Array.prototype.slice.call(arguments,3);try{t.apply(n,l)}catch(u){this.onError(u)}}var Fe=!1,Le=null,ze=!1,Be=null,je={onError:function(e){Fe=!0,Le=e}};function We(e,t,n,a,s,r,i,o,c){Fe=!1,Le=null,Oe.apply(je,arguments)}function Ve(e){var t=e,n=e;if(e.alternate)for(;t.return;)t=t.return;else{e=t;do{0!==(4098&(t=e).flags)&&(n=t.return),e=t.return}while(e)}return 3===t.tag?n:null}function Ue(e){if(13===e.tag){var t=e.memoizedState;if(null===t&&(null!==(e=e.alternate)&&(t=e.memoizedState)),null!==t)return t.dehydrated}return null}function He(e){if(Ve(e)!==e)throw Error(r(188))}function Ge(e){return null!==(e=function(e){var t=e.alternate;if(!t){if(null===(t=Ve(e)))throw Error(r(188));return t!==e?null:e}for(var n=e,a=t;;){var s=n.return;if(null===s)break;var i=s.alternate;if(null===i){if(null!==(a=s.return)){n=a;continue}break}if(s.child===i.child){for(i=s.child;i;){if(i===n)return He(s),e;if(i===a)return He(s),t;i=i.sibling}throw Error(r(188))}if(n.return!==a.return)n=s,a=i;else{for(var o=!1,c=s.child;c;){if(c===n){o=!0,n=s,a=i;break}if(c===a){o=!0,a=s,n=i;break}c=c.sibling}if(!o){for(c=i.child;c;){if(c===n){o=!0,n=i,a=s;break}if(c===a){o=!0,a=i,n=s;break}c=c.sibling}if(!o)throw Error(r(189))}}if(n.alternate!==a)throw Error(r(190))}if(3!==n.tag)throw Error(r(188));return n.stateNode.current===n?e:t}(e))?qe(e):null}function qe(e){if(5===e.tag||6===e.tag)return e;for(e=e.child;null!==e;){var t=qe(e);if(null!==t)return t;e=e.sibling}return null}var Ke=s.unstable_scheduleCallback,Xe=s.unstable_cancelCallback,Ye=s.unstable_shouldYield,Qe=s.unstable_requestPaint,Ze=s.unstable_now,Je=s.unstable_getCurrentPriorityLevel,$e=s.unstable_ImmediatePriority,et=s.unstable_UserBlockingPriority,tt=s.unstable_NormalPriority,nt=s.unstable_LowPriority,at=s.unstable_IdlePriority,st=null,rt=null;var it=Math.clz32?Math.clz32:function(e){return e>>>=0,0===e?32:31-(ot(e)/ct|0)|0},ot=Math.log,ct=Math.LN2;var lt=64,ut=4194304;function ht(e){switch(e&-e){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return 4194240&e;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return 130023424&e;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return e}}function dt(e,t){var n=e.pendingLanes;if(0===n)return 0;var a=0,s=e.suspendedLanes,r=e.pingedLanes,i=268435455&n;if(0!==i){var o=i&~s;0!==o?a=ht(o):0!==(r&=i)&&(a=ht(r))}else 0!==(i=n&~s)?a=ht(i):0!==r&&(a=ht(r));if(0===a)return 0;if(0!==t&&t!==a&&0===(t&s)&&((s=a&-a)>=(r=t&-t)||16===s&&0!==(4194240&r)))return t;if(0!==(4&a)&&(a|=16&n),0!==(t=e.entangledLanes))for(e=e.entanglements,t&=a;0<t;)s=1<<(n=31-it(t)),a|=e[n],t&=~s;return a}function pt(e,t){switch(e){case 1:case 2:case 4:return t+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return t+5e3;default:return-1}}function ft(e){return 0!==(e=-1073741825&e.pendingLanes)?e:1073741824&e?1073741824:0}function mt(){var e=lt;return 0===(4194240&(lt<<=1))&&(lt=64),e}function gt(e){for(var t=[],n=0;31>n;n++)t.push(e);return t}function yt(e,t,n){e.pendingLanes|=t,536870912!==t&&(e.suspendedLanes=0,e.pingedLanes=0),(e=e.eventTimes)[t=31-it(t)]=n}function bt(e,t){var n=e.entangledLanes|=t;for(e=e.entanglements;n;){var a=31-it(n),s=1<<a;s&t|e[a]&t&&(e[a]|=t),n&=~s}}var xt=0;function vt(e){return 1<(e&=-e)?4<e?0!==(268435455&e)?16:536870912:4:1}var wt,kt,St,Ct,It,Nt=!1,Tt=[],Et=null,Rt=null,_t=null,At=new Map,Mt=new Map,Pt=[],Dt="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function Ot(e,t){switch(e){case"focusin":case"focusout":Et=null;break;case"dragenter":case"dragleave":Rt=null;break;case"mouseover":case"mouseout":_t=null;break;case"pointerover":case"pointerout":At.delete(t.pointerId);break;case"gotpointercapture":case"lostpointercapture":Mt.delete(t.pointerId)}}function Ft(e,t,n,a,s,r){return null===e||e.nativeEvent!==r?(e={blockedOn:t,domEventName:n,eventSystemFlags:a,nativeEvent:r,targetContainers:[s]},null!==t&&(null!==(t=xs(t))&&kt(t)),e):(e.eventSystemFlags|=a,t=e.targetContainers,null!==s&&-1===t.indexOf(s)&&t.push(s),e)}function Lt(e){var t=bs(e.target);if(null!==t){var n=Ve(t);if(null!==n)if(13===(t=n.tag)){if(null!==(t=Ue(n)))return e.blockedOn=t,void It(e.priority,function(){St(n)})}else if(3===t&&n.stateNode.current.memoizedState.isDehydrated)return void(e.blockedOn=3===n.tag?n.stateNode.containerInfo:null)}e.blockedOn=null}function zt(e){if(null!==e.blockedOn)return!1;for(var t=e.targetContainers;0<t.length;){var n=Yt(e.domEventName,e.eventSystemFlags,t[0],e.nativeEvent);if(null!==n)return null!==(t=xs(n))&&kt(t),e.blockedOn=n,!1;var a=new(n=e.nativeEvent).constructor(n.type,n);ve=a,n.target.dispatchEvent(a),ve=null,t.shift()}return!0}function Bt(e,t,n){zt(e)&&n.delete(t)}function jt(){Nt=!1,null!==Et&&zt(Et)&&(Et=null),null!==Rt&&zt(Rt)&&(Rt=null),null!==_t&&zt(_t)&&(_t=null),At.forEach(Bt),Mt.forEach(Bt)}function Wt(e,t){e.blockedOn===t&&(e.blockedOn=null,Nt||(Nt=!0,s.unstable_scheduleCallback(s.unstable_NormalPriority,jt)))}function Vt(e){function t(t){return Wt(t,e)}if(0<Tt.length){Wt(Tt[0],e);for(var n=1;n<Tt.length;n++){var a=Tt[n];a.blockedOn===e&&(a.blockedOn=null)}}for(null!==Et&&Wt(Et,e),null!==Rt&&Wt(Rt,e),null!==_t&&Wt(_t,e),At.forEach(t),Mt.forEach(t),n=0;n<Pt.length;n++)(a=Pt[n]).blockedOn===e&&(a.blockedOn=null);for(;0<Pt.length&&null===(n=Pt[0]).blockedOn;)Lt(n),null===n.blockedOn&&Pt.shift()}var Ut=v.ReactCurrentBatchConfig,Ht=!0;function Gt(e,t,n,a){var s=xt,r=Ut.transition;Ut.transition=null;try{xt=1,Kt(e,t,n,a)}finally{xt=s,Ut.transition=r}}function qt(e,t,n,a){var s=xt,r=Ut.transition;Ut.transition=null;try{xt=4,Kt(e,t,n,a)}finally{xt=s,Ut.transition=r}}function Kt(e,t,n,a){if(Ht){var s=Yt(e,t,n,a);if(null===s)Ha(e,t,a,Xt,n),Ot(e,a);else if(function(e,t,n,a,s){switch(t){case"focusin":return Et=Ft(Et,e,t,n,a,s),!0;case"dragenter":return Rt=Ft(Rt,e,t,n,a,s),!0;case"mouseover":return _t=Ft(_t,e,t,n,a,s),!0;case"pointerover":var r=s.pointerId;return At.set(r,Ft(At.get(r)||null,e,t,n,a,s)),!0;case"gotpointercapture":return r=s.pointerId,Mt.set(r,Ft(Mt.get(r)||null,e,t,n,a,s)),!0}return!1}(s,e,t,n,a))a.stopPropagation();else if(Ot(e,a),4&t&&-1<Dt.indexOf(e)){for(;null!==s;){var r=xs(s);if(null!==r&&wt(r),null===(r=Yt(e,t,n,a))&&Ha(e,t,a,Xt,n),r===s)break;s=r}null!==s&&a.stopPropagation()}else Ha(e,t,a,null,n)}}var Xt=null;function Yt(e,t,n,a){if(Xt=null,null!==(e=bs(e=we(a))))if(null===(t=Ve(e)))e=null;else if(13===(n=t.tag)){if(null!==(e=Ue(t)))return e;e=null}else if(3===n){if(t.stateNode.current.memoizedState.isDehydrated)return 3===t.tag?t.stateNode.containerInfo:null;e=null}else t!==e&&(e=null);return Xt=e,null}function Qt(e){switch(e){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 1;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 4;case"message":switch(Je()){case $e:return 1;case et:return 4;case tt:case nt:return 16;case at:return 536870912;default:return 16}default:return 16}}var Zt=null,Jt=null,$t=null;function en(){if($t)return $t;var e,t,n=Jt,a=n.length,s="value"in Zt?Zt.value:Zt.textContent,r=s.length;for(e=0;e<a&&n[e]===s[e];e++);var i=a-e;for(t=1;t<=i&&n[a-t]===s[r-t];t++);return $t=s.slice(e,1<t?1-t:void 0)}function tn(e){var t=e.keyCode;return"charCode"in e?0===(e=e.charCode)&&13===t&&(e=13):e=t,10===e&&(e=13),32<=e||13===e?e:0}function nn(){return!0}function an(){return!1}function sn(e){function t(t,n,a,s,r){for(var i in this._reactName=t,this._targetInst=a,this.type=n,this.nativeEvent=s,this.target=r,this.currentTarget=null,e)e.hasOwnProperty(i)&&(t=e[i],this[i]=t?t(s):s[i]);return this.isDefaultPrevented=(null!=s.defaultPrevented?s.defaultPrevented:!1===s.returnValue)?nn:an,this.isPropagationStopped=an,this}return L(t.prototype,{preventDefault:function(){this.defaultPrevented=!0;var e=this.nativeEvent;e&&(e.preventDefault?e.preventDefault():"unknown"!==typeof e.returnValue&&(e.returnValue=!1),this.isDefaultPrevented=nn)},stopPropagation:function(){var e=this.nativeEvent;e&&(e.stopPropagation?e.stopPropagation():"unknown"!==typeof e.cancelBubble&&(e.cancelBubble=!0),this.isPropagationStopped=nn)},persist:function(){},isPersistent:nn}),t}var rn,on,cn,ln={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(e){return e.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},un=sn(ln),hn=L({},ln,{view:0,detail:0}),dn=sn(hn),pn=L({},hn,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:In,button:0,buttons:0,relatedTarget:function(e){return void 0===e.relatedTarget?e.fromElement===e.srcElement?e.toElement:e.fromElement:e.relatedTarget},movementX:function(e){return"movementX"in e?e.movementX:(e!==cn&&(cn&&"mousemove"===e.type?(rn=e.screenX-cn.screenX,on=e.screenY-cn.screenY):on=rn=0,cn=e),rn)},movementY:function(e){return"movementY"in e?e.movementY:on}}),fn=sn(pn),mn=sn(L({},pn,{dataTransfer:0})),gn=sn(L({},hn,{relatedTarget:0})),yn=sn(L({},ln,{animationName:0,elapsedTime:0,pseudoElement:0})),bn=L({},ln,{clipboardData:function(e){return"clipboardData"in e?e.clipboardData:window.clipboardData}}),xn=sn(bn),vn=sn(L({},ln,{data:0})),wn={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},kn={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},Sn={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function Cn(e){var t=this.nativeEvent;return t.getModifierState?t.getModifierState(e):!!(e=Sn[e])&&!!t[e]}function In(){return Cn}var Nn=L({},hn,{key:function(e){if(e.key){var t=wn[e.key]||e.key;if("Unidentified"!==t)return t}return"keypress"===e.type?13===(e=tn(e))?"Enter":String.fromCharCode(e):"keydown"===e.type||"keyup"===e.type?kn[e.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:In,charCode:function(e){return"keypress"===e.type?tn(e):0},keyCode:function(e){return"keydown"===e.type||"keyup"===e.type?e.keyCode:0},which:function(e){return"keypress"===e.type?tn(e):"keydown"===e.type||"keyup"===e.type?e.keyCode:0}}),Tn=sn(Nn),En=sn(L({},pn,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0})),Rn=sn(L({},hn,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:In})),_n=sn(L({},ln,{propertyName:0,elapsedTime:0,pseudoElement:0})),An=L({},pn,{deltaX:function(e){return"deltaX"in e?e.deltaX:"wheelDeltaX"in e?-e.wheelDeltaX:0},deltaY:function(e){return"deltaY"in e?e.deltaY:"wheelDeltaY"in e?-e.wheelDeltaY:"wheelDelta"in e?-e.wheelDelta:0},deltaZ:0,deltaMode:0}),Mn=sn(An),Pn=[9,13,27,32],Dn=u&&"CompositionEvent"in window,On=null;u&&"documentMode"in document&&(On=document.documentMode);var Fn=u&&"TextEvent"in window&&!On,Ln=u&&(!Dn||On&&8<On&&11>=On),zn=String.fromCharCode(32),Bn=!1;function jn(e,t){switch(e){case"keyup":return-1!==Pn.indexOf(t.keyCode);case"keydown":return 229!==t.keyCode;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function Wn(e){return"object"===typeof(e=e.detail)&&"data"in e?e.data:null}var Vn=!1;var Un={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function Hn(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return"input"===t?!!Un[e.type]:"textarea"===t}function Gn(e,t,n,a){Ne(a),0<(t=qa(t,"onChange")).length&&(n=new un("onChange","change",null,n,a),e.push({event:n,listeners:t}))}var qn=null,Kn=null;function Xn(e){za(e,0)}function Yn(e){if(K(vs(e)))return e}function Qn(e,t){if("change"===e)return t}var Zn=!1;if(u){var Jn;if(u){var $n="oninput"in document;if(!$n){var ea=document.createElement("div");ea.setAttribute("oninput","return;"),$n="function"===typeof ea.oninput}Jn=$n}else Jn=!1;Zn=Jn&&(!document.documentMode||9<document.documentMode)}function ta(){qn&&(qn.detachEvent("onpropertychange",na),Kn=qn=null)}function na(e){if("value"===e.propertyName&&Yn(Kn)){var t=[];Gn(t,Kn,e,we(e)),Ae(Xn,t)}}function aa(e,t,n){"focusin"===e?(ta(),Kn=n,(qn=t).attachEvent("onpropertychange",na)):"focusout"===e&&ta()}function sa(e){if("selectionchange"===e||"keyup"===e||"keydown"===e)return Yn(Kn)}function ra(e,t){if("click"===e)return Yn(t)}function ia(e,t){if("input"===e||"change"===e)return Yn(t)}var oa="function"===typeof Object.is?Object.is:function(e,t){return e===t&&(0!==e||1/e===1/t)||e!==e&&t!==t};function ca(e,t){if(oa(e,t))return!0;if("object"!==typeof e||null===e||"object"!==typeof t||null===t)return!1;var n=Object.keys(e),a=Object.keys(t);if(n.length!==a.length)return!1;for(a=0;a<n.length;a++){var s=n[a];if(!h.call(t,s)||!oa(e[s],t[s]))return!1}return!0}function la(e){for(;e&&e.firstChild;)e=e.firstChild;return e}function ua(e,t){var n,a=la(e);for(e=0;a;){if(3===a.nodeType){if(n=e+a.textContent.length,e<=t&&n>=t)return{node:a,offset:t-e};e=n}e:{for(;a;){if(a.nextSibling){a=a.nextSibling;break e}a=a.parentNode}a=void 0}a=la(a)}}function ha(e,t){return!(!e||!t)&&(e===t||(!e||3!==e.nodeType)&&(t&&3===t.nodeType?ha(e,t.parentNode):"contains"in e?e.contains(t):!!e.compareDocumentPosition&&!!(16&e.compareDocumentPosition(t))))}function da(){for(var e=window,t=X();t instanceof e.HTMLIFrameElement;){try{var n="string"===typeof t.contentWindow.location.href}catch(a){n=!1}if(!n)break;t=X((e=t.contentWindow).document)}return t}function pa(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return t&&("input"===t&&("text"===e.type||"search"===e.type||"tel"===e.type||"url"===e.type||"password"===e.type)||"textarea"===t||"true"===e.contentEditable)}function fa(e){var t=da(),n=e.focusedElem,a=e.selectionRange;if(t!==n&&n&&n.ownerDocument&&ha(n.ownerDocument.documentElement,n)){if(null!==a&&pa(n))if(t=a.start,void 0===(e=a.end)&&(e=t),"selectionStart"in n)n.selectionStart=t,n.selectionEnd=Math.min(e,n.value.length);else if((e=(t=n.ownerDocument||document)&&t.defaultView||window).getSelection){e=e.getSelection();var s=n.textContent.length,r=Math.min(a.start,s);a=void 0===a.end?r:Math.min(a.end,s),!e.extend&&r>a&&(s=a,a=r,r=s),s=ua(n,r);var i=ua(n,a);s&&i&&(1!==e.rangeCount||e.anchorNode!==s.node||e.anchorOffset!==s.offset||e.focusNode!==i.node||e.focusOffset!==i.offset)&&((t=t.createRange()).setStart(s.node,s.offset),e.removeAllRanges(),r>a?(e.addRange(t),e.extend(i.node,i.offset)):(t.setEnd(i.node,i.offset),e.addRange(t)))}for(t=[],e=n;e=e.parentNode;)1===e.nodeType&&t.push({element:e,left:e.scrollLeft,top:e.scrollTop});for("function"===typeof n.focus&&n.focus(),n=0;n<t.length;n++)(e=t[n]).element.scrollLeft=e.left,e.element.scrollTop=e.top}}var ma=u&&"documentMode"in document&&11>=document.documentMode,ga=null,ya=null,ba=null,xa=!1;function va(e,t,n){var a=n.window===n?n.document:9===n.nodeType?n:n.ownerDocument;xa||null==ga||ga!==X(a)||("selectionStart"in(a=ga)&&pa(a)?a={start:a.selectionStart,end:a.selectionEnd}:a={anchorNode:(a=(a.ownerDocument&&a.ownerDocument.defaultView||window).getSelection()).anchorNode,anchorOffset:a.anchorOffset,focusNode:a.focusNode,focusOffset:a.focusOffset},ba&&ca(ba,a)||(ba=a,0<(a=qa(ya,"onSelect")).length&&(t=new un("onSelect","select",null,t,n),e.push({event:t,listeners:a}),t.target=ga)))}function wa(e,t){var n={};return n[e.toLowerCase()]=t.toLowerCase(),n["Webkit"+e]="webkit"+t,n["Moz"+e]="moz"+t,n}var ka={animationend:wa("Animation","AnimationEnd"),animationiteration:wa("Animation","AnimationIteration"),animationstart:wa("Animation","AnimationStart"),transitionend:wa("Transition","TransitionEnd")},Sa={},Ca={};function Ia(e){if(Sa[e])return Sa[e];if(!ka[e])return e;var t,n=ka[e];for(t in n)if(n.hasOwnProperty(t)&&t in Ca)return Sa[e]=n[t];return e}u&&(Ca=document.createElement("div").style,"AnimationEvent"in window||(delete ka.animationend.animation,delete ka.animationiteration.animation,delete ka.animationstart.animation),"TransitionEvent"in window||delete ka.transitionend.transition);var Na=Ia("animationend"),Ta=Ia("animationiteration"),Ea=Ia("animationstart"),Ra=Ia("transitionend"),_a=new Map,Aa="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function Ma(e,t){_a.set(e,t),c(t,[e])}for(var Pa=0;Pa<Aa.length;Pa++){var Da=Aa[Pa];Ma(Da.toLowerCase(),"on"+(Da[0].toUpperCase()+Da.slice(1)))}Ma(Na,"onAnimationEnd"),Ma(Ta,"onAnimationIteration"),Ma(Ea,"onAnimationStart"),Ma("dblclick","onDoubleClick"),Ma("focusin","onFocus"),Ma("focusout","onBlur"),Ma(Ra,"onTransitionEnd"),l("onMouseEnter",["mouseout","mouseover"]),l("onMouseLeave",["mouseout","mouseover"]),l("onPointerEnter",["pointerout","pointerover"]),l("onPointerLeave",["pointerout","pointerover"]),c("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),c("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),c("onBeforeInput",["compositionend","keypress","textInput","paste"]),c("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),c("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),c("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var Oa="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Fa=new Set("cancel close invalid load scroll toggle".split(" ").concat(Oa));function La(e,t,n){var a=e.type||"unknown-event";e.currentTarget=n,function(e,t,n,a,s,i,o,c,l){if(We.apply(this,arguments),Fe){if(!Fe)throw Error(r(198));var u=Le;Fe=!1,Le=null,ze||(ze=!0,Be=u)}}(a,t,void 0,e),e.currentTarget=null}function za(e,t){t=0!==(4&t);for(var n=0;n<e.length;n++){var a=e[n],s=a.event;a=a.listeners;e:{var r=void 0;if(t)for(var i=a.length-1;0<=i;i--){var o=a[i],c=o.instance,l=o.currentTarget;if(o=o.listener,c!==r&&s.isPropagationStopped())break e;La(s,o,l),r=c}else for(i=0;i<a.length;i++){if(c=(o=a[i]).instance,l=o.currentTarget,o=o.listener,c!==r&&s.isPropagationStopped())break e;La(s,o,l),r=c}}}if(ze)throw e=Be,ze=!1,Be=null,e}function Ba(e,t){var n=t[ms];void 0===n&&(n=t[ms]=new Set);var a=e+"__bubble";n.has(a)||(Ua(t,e,2,!1),n.add(a))}function ja(e,t,n){var a=0;t&&(a|=4),Ua(n,e,a,t)}var Wa="_reactListening"+Math.random().toString(36).slice(2);function Va(e){if(!e[Wa]){e[Wa]=!0,i.forEach(function(t){"selectionchange"!==t&&(Fa.has(t)||ja(t,!1,e),ja(t,!0,e))});var t=9===e.nodeType?e:e.ownerDocument;null===t||t[Wa]||(t[Wa]=!0,ja("selectionchange",!1,t))}}function Ua(e,t,n,a){switch(Qt(t)){case 1:var s=Gt;break;case 4:s=qt;break;default:s=Kt}n=s.bind(null,t,n,e),s=void 0,!Pe||"touchstart"!==t&&"touchmove"!==t&&"wheel"!==t||(s=!0),a?void 0!==s?e.addEventListener(t,n,{capture:!0,passive:s}):e.addEventListener(t,n,!0):void 0!==s?e.addEventListener(t,n,{passive:s}):e.addEventListener(t,n,!1)}function Ha(e,t,n,a,s){var r=a;if(0===(1&t)&&0===(2&t)&&null!==a)e:for(;;){if(null===a)return;var i=a.tag;if(3===i||4===i){var o=a.stateNode.containerInfo;if(o===s||8===o.nodeType&&o.parentNode===s)break;if(4===i)for(i=a.return;null!==i;){var c=i.tag;if((3===c||4===c)&&((c=i.stateNode.containerInfo)===s||8===c.nodeType&&c.parentNode===s))return;i=i.return}for(;null!==o;){if(null===(i=bs(o)))return;if(5===(c=i.tag)||6===c){a=r=i;continue e}o=o.parentNode}}a=a.return}Ae(function(){var a=r,s=we(n),i=[];e:{var o=_a.get(e);if(void 0!==o){var c=un,l=e;switch(e){case"keypress":if(0===tn(n))break e;case"keydown":case"keyup":c=Tn;break;case"focusin":l="focus",c=gn;break;case"focusout":l="blur",c=gn;break;case"beforeblur":case"afterblur":c=gn;break;case"click":if(2===n.button)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":c=fn;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":c=mn;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":c=Rn;break;case Na:case Ta:case Ea:c=yn;break;case Ra:c=_n;break;case"scroll":c=dn;break;case"wheel":c=Mn;break;case"copy":case"cut":case"paste":c=xn;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":c=En}var u=0!==(4&t),h=!u&&"scroll"===e,d=u?null!==o?o+"Capture":null:o;u=[];for(var p,f=a;null!==f;){var m=(p=f).stateNode;if(5===p.tag&&null!==m&&(p=m,null!==d&&(null!=(m=Me(f,d))&&u.push(Ga(f,m,p)))),h)break;f=f.return}0<u.length&&(o=new c(o,l,null,n,s),i.push({event:o,listeners:u}))}}if(0===(7&t)){if(c="mouseout"===e||"pointerout"===e,(!(o="mouseover"===e||"pointerover"===e)||n===ve||!(l=n.relatedTarget||n.fromElement)||!bs(l)&&!l[fs])&&(c||o)&&(o=s.window===s?s:(o=s.ownerDocument)?o.defaultView||o.parentWindow:window,c?(c=a,null!==(l=(l=n.relatedTarget||n.toElement)?bs(l):null)&&(l!==(h=Ve(l))||5!==l.tag&&6!==l.tag)&&(l=null)):(c=null,l=a),c!==l)){if(u=fn,m="onMouseLeave",d="onMouseEnter",f="mouse","pointerout"!==e&&"pointerover"!==e||(u=En,m="onPointerLeave",d="onPointerEnter",f="pointer"),h=null==c?o:vs(c),p=null==l?o:vs(l),(o=new u(m,f+"leave",c,n,s)).target=h,o.relatedTarget=p,m=null,bs(s)===a&&((u=new u(d,f+"enter",l,n,s)).target=p,u.relatedTarget=h,m=u),h=m,c&&l)e:{for(d=l,f=0,p=u=c;p;p=Ka(p))f++;for(p=0,m=d;m;m=Ka(m))p++;for(;0<f-p;)u=Ka(u),f--;for(;0<p-f;)d=Ka(d),p--;for(;f--;){if(u===d||null!==d&&u===d.alternate)break e;u=Ka(u),d=Ka(d)}u=null}else u=null;null!==c&&Xa(i,o,c,u,!1),null!==l&&null!==h&&Xa(i,h,l,u,!0)}if("select"===(c=(o=a?vs(a):window).nodeName&&o.nodeName.toLowerCase())||"input"===c&&"file"===o.type)var g=Qn;else if(Hn(o))if(Zn)g=ia;else{g=sa;var y=aa}else(c=o.nodeName)&&"input"===c.toLowerCase()&&("checkbox"===o.type||"radio"===o.type)&&(g=ra);switch(g&&(g=g(e,a))?Gn(i,g,n,s):(y&&y(e,o,a),"focusout"===e&&(y=o._wrapperState)&&y.controlled&&"number"===o.type&&ee(o,"number",o.value)),y=a?vs(a):window,e){case"focusin":(Hn(y)||"true"===y.contentEditable)&&(ga=y,ya=a,ba=null);break;case"focusout":ba=ya=ga=null;break;case"mousedown":xa=!0;break;case"contextmenu":case"mouseup":case"dragend":xa=!1,va(i,n,s);break;case"selectionchange":if(ma)break;case"keydown":case"keyup":va(i,n,s)}var b;if(Dn)e:{switch(e){case"compositionstart":var x="onCompositionStart";break e;case"compositionend":x="onCompositionEnd";break e;case"compositionupdate":x="onCompositionUpdate";break e}x=void 0}else Vn?jn(e,n)&&(x="onCompositionEnd"):"keydown"===e&&229===n.keyCode&&(x="onCompositionStart");x&&(Ln&&"ko"!==n.locale&&(Vn||"onCompositionStart"!==x?"onCompositionEnd"===x&&Vn&&(b=en()):(Jt="value"in(Zt=s)?Zt.value:Zt.textContent,Vn=!0)),0<(y=qa(a,x)).length&&(x=new vn(x,e,null,n,s),i.push({event:x,listeners:y}),b?x.data=b:null!==(b=Wn(n))&&(x.data=b))),(b=Fn?function(e,t){switch(e){case"compositionend":return Wn(t);case"keypress":return 32!==t.which?null:(Bn=!0,zn);case"textInput":return(e=t.data)===zn&&Bn?null:e;default:return null}}(e,n):function(e,t){if(Vn)return"compositionend"===e||!Dn&&jn(e,t)?(e=en(),$t=Jt=Zt=null,Vn=!1,e):null;switch(e){case"paste":default:return null;case"keypress":if(!(t.ctrlKey||t.altKey||t.metaKey)||t.ctrlKey&&t.altKey){if(t.char&&1<t.char.length)return t.char;if(t.which)return String.fromCharCode(t.which)}return null;case"compositionend":return Ln&&"ko"!==t.locale?null:t.data}}(e,n))&&(0<(a=qa(a,"onBeforeInput")).length&&(s=new vn("onBeforeInput","beforeinput",null,n,s),i.push({event:s,listeners:a}),s.data=b))}za(i,t)})}function Ga(e,t,n){return{instance:e,listener:t,currentTarget:n}}function qa(e,t){for(var n=t+"Capture",a=[];null!==e;){var s=e,r=s.stateNode;5===s.tag&&null!==r&&(s=r,null!=(r=Me(e,n))&&a.unshift(Ga(e,r,s)),null!=(r=Me(e,t))&&a.push(Ga(e,r,s))),e=e.return}return a}function Ka(e){if(null===e)return null;do{e=e.return}while(e&&5!==e.tag);return e||null}function Xa(e,t,n,a,s){for(var r=t._reactName,i=[];null!==n&&n!==a;){var o=n,c=o.alternate,l=o.stateNode;if(null!==c&&c===a)break;5===o.tag&&null!==l&&(o=l,s?null!=(c=Me(n,r))&&i.unshift(Ga(n,c,o)):s||null!=(c=Me(n,r))&&i.push(Ga(n,c,o))),n=n.return}0!==i.length&&e.push({event:t,listeners:i})}var Ya=/\r\n?/g,Qa=/\u0000|\uFFFD/g;function Za(e){return("string"===typeof e?e:""+e).replace(Ya,"\n").replace(Qa,"")}function Ja(e,t,n){if(t=Za(t),Za(e)!==t&&n)throw Error(r(425))}function $a(){}var es=null,ts=null;function ns(e,t){return"textarea"===e||"noscript"===e||"string"===typeof t.children||"number"===typeof t.children||"object"===typeof t.dangerouslySetInnerHTML&&null!==t.dangerouslySetInnerHTML&&null!=t.dangerouslySetInnerHTML.__html}var as="function"===typeof setTimeout?setTimeout:void 0,ss="function"===typeof clearTimeout?clearTimeout:void 0,rs="function"===typeof Promise?Promise:void 0,is="function"===typeof queueMicrotask?queueMicrotask:"undefined"!==typeof rs?function(e){return rs.resolve(null).then(e).catch(os)}:as;function os(e){setTimeout(function(){throw e})}function cs(e,t){var n=t,a=0;do{var s=n.nextSibling;if(e.removeChild(n),s&&8===s.nodeType)if("/$"===(n=s.data)){if(0===a)return e.removeChild(s),void Vt(t);a--}else"$"!==n&&"$?"!==n&&"$!"!==n||a++;n=s}while(n);Vt(t)}function ls(e){for(;null!=e;e=e.nextSibling){var t=e.nodeType;if(1===t||3===t)break;if(8===t){if("$"===(t=e.data)||"$!"===t||"$?"===t)break;if("/$"===t)return null}}return e}function us(e){e=e.previousSibling;for(var t=0;e;){if(8===e.nodeType){var n=e.data;if("$"===n||"$!"===n||"$?"===n){if(0===t)return e;t--}else"/$"===n&&t++}e=e.previousSibling}return null}var hs=Math.random().toString(36).slice(2),ds="__reactFiber$"+hs,ps="__reactProps$"+hs,fs="__reactContainer$"+hs,ms="__reactEvents$"+hs,gs="__reactListeners$"+hs,ys="__reactHandles$"+hs;function bs(e){var t=e[ds];if(t)return t;for(var n=e.parentNode;n;){if(t=n[fs]||n[ds]){if(n=t.alternate,null!==t.child||null!==n&&null!==n.child)for(e=us(e);null!==e;){if(n=e[ds])return n;e=us(e)}return t}n=(e=n).parentNode}return null}function xs(e){return!(e=e[ds]||e[fs])||5!==e.tag&&6!==e.tag&&13!==e.tag&&3!==e.tag?null:e}function vs(e){if(5===e.tag||6===e.tag)return e.stateNode;throw Error(r(33))}function ws(e){return e[ps]||null}var ks=[],Ss=-1;function Cs(e){return{current:e}}function Is(e){0>Ss||(e.current=ks[Ss],ks[Ss]=null,Ss--)}function Ns(e,t){Ss++,ks[Ss]=e.current,e.current=t}var Ts={},Es=Cs(Ts),Rs=Cs(!1),_s=Ts;function As(e,t){var n=e.type.contextTypes;if(!n)return Ts;var a=e.stateNode;if(a&&a.__reactInternalMemoizedUnmaskedChildContext===t)return a.__reactInternalMemoizedMaskedChildContext;var s,r={};for(s in n)r[s]=t[s];return a&&((e=e.stateNode).__reactInternalMemoizedUnmaskedChildContext=t,e.__reactInternalMemoizedMaskedChildContext=r),r}function Ms(e){return null!==(e=e.childContextTypes)&&void 0!==e}function Ps(){Is(Rs),Is(Es)}function Ds(e,t,n){if(Es.current!==Ts)throw Error(r(168));Ns(Es,t),Ns(Rs,n)}function Os(e,t,n){var a=e.stateNode;if(t=t.childContextTypes,"function"!==typeof a.getChildContext)return n;for(var s in a=a.getChildContext())if(!(s in t))throw Error(r(108,U(e)||"Unknown",s));return L({},n,a)}function Fs(e){return e=(e=e.stateNode)&&e.__reactInternalMemoizedMergedChildContext||Ts,_s=Es.current,Ns(Es,e),Ns(Rs,Rs.current),!0}function Ls(e,t,n){var a=e.stateNode;if(!a)throw Error(r(169));n?(e=Os(e,t,_s),a.__reactInternalMemoizedMergedChildContext=e,Is(Rs),Is(Es),Ns(Es,e)):Is(Rs),Ns(Rs,n)}var zs=null,Bs=!1,js=!1;function Ws(e){null===zs?zs=[e]:zs.push(e)}function Vs(){if(!js&&null!==zs){js=!0;var e=0,t=xt;try{var n=zs;for(xt=1;e<n.length;e++){var a=n[e];do{a=a(!0)}while(null!==a)}zs=null,Bs=!1}catch(s){throw null!==zs&&(zs=zs.slice(e+1)),Ke($e,Vs),s}finally{xt=t,js=!1}}return null}var Us=[],Hs=0,Gs=null,qs=0,Ks=[],Xs=0,Ys=null,Qs=1,Zs="";function Js(e,t){Us[Hs++]=qs,Us[Hs++]=Gs,Gs=e,qs=t}function $s(e,t,n){Ks[Xs++]=Qs,Ks[Xs++]=Zs,Ks[Xs++]=Ys,Ys=e;var a=Qs;e=Zs;var s=32-it(a)-1;a&=~(1<<s),n+=1;var r=32-it(t)+s;if(30<r){var i=s-s%5;r=(a&(1<<i)-1).toString(32),a>>=i,s-=i,Qs=1<<32-it(t)+s|n<<s|a,Zs=r+e}else Qs=1<<r|n<<s|a,Zs=e}function er(e){null!==e.return&&(Js(e,1),$s(e,1,0))}function tr(e){for(;e===Gs;)Gs=Us[--Hs],Us[Hs]=null,qs=Us[--Hs],Us[Hs]=null;for(;e===Ys;)Ys=Ks[--Xs],Ks[Xs]=null,Zs=Ks[--Xs],Ks[Xs]=null,Qs=Ks[--Xs],Ks[Xs]=null}var nr=null,ar=null,sr=!1,rr=null;function ir(e,t){var n=_l(5,null,null,0);n.elementType="DELETED",n.stateNode=t,n.return=e,null===(t=e.deletions)?(e.deletions=[n],e.flags|=16):t.push(n)}function or(e,t){switch(e.tag){case 5:var n=e.type;return null!==(t=1!==t.nodeType||n.toLowerCase()!==t.nodeName.toLowerCase()?null:t)&&(e.stateNode=t,nr=e,ar=ls(t.firstChild),!0);case 6:return null!==(t=""===e.pendingProps||3!==t.nodeType?null:t)&&(e.stateNode=t,nr=e,ar=null,!0);case 13:return null!==(t=8!==t.nodeType?null:t)&&(n=null!==Ys?{id:Qs,overflow:Zs}:null,e.memoizedState={dehydrated:t,treeContext:n,retryLane:1073741824},(n=_l(18,null,null,0)).stateNode=t,n.return=e,e.child=n,nr=e,ar=null,!0);default:return!1}}function cr(e){return 0!==(1&e.mode)&&0===(128&e.flags)}function lr(e){if(sr){var t=ar;if(t){var n=t;if(!or(e,t)){if(cr(e))throw Error(r(418));t=ls(n.nextSibling);var a=nr;t&&or(e,t)?ir(a,n):(e.flags=-4097&e.flags|2,sr=!1,nr=e)}}else{if(cr(e))throw Error(r(418));e.flags=-4097&e.flags|2,sr=!1,nr=e}}}function ur(e){for(e=e.return;null!==e&&5!==e.tag&&3!==e.tag&&13!==e.tag;)e=e.return;nr=e}function hr(e){if(e!==nr)return!1;if(!sr)return ur(e),sr=!0,!1;var t;if((t=3!==e.tag)&&!(t=5!==e.tag)&&(t="head"!==(t=e.type)&&"body"!==t&&!ns(e.type,e.memoizedProps)),t&&(t=ar)){if(cr(e))throw dr(),Error(r(418));for(;t;)ir(e,t),t=ls(t.nextSibling)}if(ur(e),13===e.tag){if(!(e=null!==(e=e.memoizedState)?e.dehydrated:null))throw Error(r(317));e:{for(e=e.nextSibling,t=0;e;){if(8===e.nodeType){var n=e.data;if("/$"===n){if(0===t){ar=ls(e.nextSibling);break e}t--}else"$"!==n&&"$!"!==n&&"$?"!==n||t++}e=e.nextSibling}ar=null}}else ar=nr?ls(e.stateNode.nextSibling):null;return!0}function dr(){for(var e=ar;e;)e=ls(e.nextSibling)}function pr(){ar=nr=null,sr=!1}function fr(e){null===rr?rr=[e]:rr.push(e)}var mr=v.ReactCurrentBatchConfig;function gr(e,t,n){if(null!==(e=n.ref)&&"function"!==typeof e&&"object"!==typeof e){if(n._owner){if(n=n._owner){if(1!==n.tag)throw Error(r(309));var a=n.stateNode}if(!a)throw Error(r(147,e));var s=a,i=""+e;return null!==t&&null!==t.ref&&"function"===typeof t.ref&&t.ref._stringRef===i?t.ref:(t=function(e){var t=s.refs;null===e?delete t[i]:t[i]=e},t._stringRef=i,t)}if("string"!==typeof e)throw Error(r(284));if(!n._owner)throw Error(r(290,e))}return e}function yr(e,t){throw e=Object.prototype.toString.call(t),Error(r(31,"[object Object]"===e?"object with keys {"+Object.keys(t).join(", ")+"}":e))}function br(e){return(0,e._init)(e._payload)}function xr(e){function t(t,n){if(e){var a=t.deletions;null===a?(t.deletions=[n],t.flags|=16):a.push(n)}}function n(n,a){if(!e)return null;for(;null!==a;)t(n,a),a=a.sibling;return null}function a(e,t){for(e=new Map;null!==t;)null!==t.key?e.set(t.key,t):e.set(t.index,t),t=t.sibling;return e}function s(e,t){return(e=Ml(e,t)).index=0,e.sibling=null,e}function i(t,n,a){return t.index=a,e?null!==(a=t.alternate)?(a=a.index)<n?(t.flags|=2,n):a:(t.flags|=2,n):(t.flags|=1048576,n)}function o(t){return e&&null===t.alternate&&(t.flags|=2),t}function c(e,t,n,a){return null===t||6!==t.tag?((t=Fl(n,e.mode,a)).return=e,t):((t=s(t,n)).return=e,t)}function l(e,t,n,a){var r=n.type;return r===S?h(e,t,n.props.children,a,n.key):null!==t&&(t.elementType===r||"object"===typeof r&&null!==r&&r.$$typeof===M&&br(r)===t.type)?((a=s(t,n.props)).ref=gr(e,t,n),a.return=e,a):((a=Pl(n.type,n.key,n.props,null,e.mode,a)).ref=gr(e,t,n),a.return=e,a)}function u(e,t,n,a){return null===t||4!==t.tag||t.stateNode.containerInfo!==n.containerInfo||t.stateNode.implementation!==n.implementation?((t=Ll(n,e.mode,a)).return=e,t):((t=s(t,n.children||[])).return=e,t)}function h(e,t,n,a,r){return null===t||7!==t.tag?((t=Dl(n,e.mode,a,r)).return=e,t):((t=s(t,n)).return=e,t)}function d(e,t,n){if("string"===typeof t&&""!==t||"number"===typeof t)return(t=Fl(""+t,e.mode,n)).return=e,t;if("object"===typeof t&&null!==t){switch(t.$$typeof){case w:return(n=Pl(t.type,t.key,t.props,null,e.mode,n)).ref=gr(e,null,t),n.return=e,n;case k:return(t=Ll(t,e.mode,n)).return=e,t;case M:return d(e,(0,t._init)(t._payload),n)}if(te(t)||O(t))return(t=Dl(t,e.mode,n,null)).return=e,t;yr(e,t)}return null}function p(e,t,n,a){var s=null!==t?t.key:null;if("string"===typeof n&&""!==n||"number"===typeof n)return null!==s?null:c(e,t,""+n,a);if("object"===typeof n&&null!==n){switch(n.$$typeof){case w:return n.key===s?l(e,t,n,a):null;case k:return n.key===s?u(e,t,n,a):null;case M:return p(e,t,(s=n._init)(n._payload),a)}if(te(n)||O(n))return null!==s?null:h(e,t,n,a,null);yr(e,n)}return null}function f(e,t,n,a,s){if("string"===typeof a&&""!==a||"number"===typeof a)return c(t,e=e.get(n)||null,""+a,s);if("object"===typeof a&&null!==a){switch(a.$$typeof){case w:return l(t,e=e.get(null===a.key?n:a.key)||null,a,s);case k:return u(t,e=e.get(null===a.key?n:a.key)||null,a,s);case M:return f(e,t,n,(0,a._init)(a._payload),s)}if(te(a)||O(a))return h(t,e=e.get(n)||null,a,s,null);yr(t,a)}return null}function m(s,r,o,c){for(var l=null,u=null,h=r,m=r=0,g=null;null!==h&&m<o.length;m++){h.index>m?(g=h,h=null):g=h.sibling;var y=p(s,h,o[m],c);if(null===y){null===h&&(h=g);break}e&&h&&null===y.alternate&&t(s,h),r=i(y,r,m),null===u?l=y:u.sibling=y,u=y,h=g}if(m===o.length)return n(s,h),sr&&Js(s,m),l;if(null===h){for(;m<o.length;m++)null!==(h=d(s,o[m],c))&&(r=i(h,r,m),null===u?l=h:u.sibling=h,u=h);return sr&&Js(s,m),l}for(h=a(s,h);m<o.length;m++)null!==(g=f(h,s,m,o[m],c))&&(e&&null!==g.alternate&&h.delete(null===g.key?m:g.key),r=i(g,r,m),null===u?l=g:u.sibling=g,u=g);return e&&h.forEach(function(e){return t(s,e)}),sr&&Js(s,m),l}function g(s,o,c,l){var u=O(c);if("function"!==typeof u)throw Error(r(150));if(null==(c=u.call(c)))throw Error(r(151));for(var h=u=null,m=o,g=o=0,y=null,b=c.next();null!==m&&!b.done;g++,b=c.next()){m.index>g?(y=m,m=null):y=m.sibling;var x=p(s,m,b.value,l);if(null===x){null===m&&(m=y);break}e&&m&&null===x.alternate&&t(s,m),o=i(x,o,g),null===h?u=x:h.sibling=x,h=x,m=y}if(b.done)return n(s,m),sr&&Js(s,g),u;if(null===m){for(;!b.done;g++,b=c.next())null!==(b=d(s,b.value,l))&&(o=i(b,o,g),null===h?u=b:h.sibling=b,h=b);return sr&&Js(s,g),u}for(m=a(s,m);!b.done;g++,b=c.next())null!==(b=f(m,s,g,b.value,l))&&(e&&null!==b.alternate&&m.delete(null===b.key?g:b.key),o=i(b,o,g),null===h?u=b:h.sibling=b,h=b);return e&&m.forEach(function(e){return t(s,e)}),sr&&Js(s,g),u}return function e(a,r,i,c){if("object"===typeof i&&null!==i&&i.type===S&&null===i.key&&(i=i.props.children),"object"===typeof i&&null!==i){switch(i.$$typeof){case w:e:{for(var l=i.key,u=r;null!==u;){if(u.key===l){if((l=i.type)===S){if(7===u.tag){n(a,u.sibling),(r=s(u,i.props.children)).return=a,a=r;break e}}else if(u.elementType===l||"object"===typeof l&&null!==l&&l.$$typeof===M&&br(l)===u.type){n(a,u.sibling),(r=s(u,i.props)).ref=gr(a,u,i),r.return=a,a=r;break e}n(a,u);break}t(a,u),u=u.sibling}i.type===S?((r=Dl(i.props.children,a.mode,c,i.key)).return=a,a=r):((c=Pl(i.type,i.key,i.props,null,a.mode,c)).ref=gr(a,r,i),c.return=a,a=c)}return o(a);case k:e:{for(u=i.key;null!==r;){if(r.key===u){if(4===r.tag&&r.stateNode.containerInfo===i.containerInfo&&r.stateNode.implementation===i.implementation){n(a,r.sibling),(r=s(r,i.children||[])).return=a,a=r;break e}n(a,r);break}t(a,r),r=r.sibling}(r=Ll(i,a.mode,c)).return=a,a=r}return o(a);case M:return e(a,r,(u=i._init)(i._payload),c)}if(te(i))return m(a,r,i,c);if(O(i))return g(a,r,i,c);yr(a,i)}return"string"===typeof i&&""!==i||"number"===typeof i?(i=""+i,null!==r&&6===r.tag?(n(a,r.sibling),(r=s(r,i)).return=a,a=r):(n(a,r),(r=Fl(i,a.mode,c)).return=a,a=r),o(a)):n(a,r)}}var vr=xr(!0),wr=xr(!1),kr=Cs(null),Sr=null,Cr=null,Ir=null;function Nr(){Ir=Cr=Sr=null}function Tr(e){var t=kr.current;Is(kr),e._currentValue=t}function Er(e,t,n){for(;null!==e;){var a=e.alternate;if((e.childLanes&t)!==t?(e.childLanes|=t,null!==a&&(a.childLanes|=t)):null!==a&&(a.childLanes&t)!==t&&(a.childLanes|=t),e===n)break;e=e.return}}function Rr(e,t){Sr=e,Ir=Cr=null,null!==(e=e.dependencies)&&null!==e.firstContext&&(0!==(e.lanes&t)&&(xo=!0),e.firstContext=null)}function _r(e){var t=e._currentValue;if(Ir!==e)if(e={context:e,memoizedValue:t,next:null},null===Cr){if(null===Sr)throw Error(r(308));Cr=e,Sr.dependencies={lanes:0,firstContext:e}}else Cr=Cr.next=e;return t}var Ar=null;function Mr(e){null===Ar?Ar=[e]:Ar.push(e)}function Pr(e,t,n,a){var s=t.interleaved;return null===s?(n.next=n,Mr(t)):(n.next=s.next,s.next=n),t.interleaved=n,Dr(e,a)}function Dr(e,t){e.lanes|=t;var n=e.alternate;for(null!==n&&(n.lanes|=t),n=e,e=e.return;null!==e;)e.childLanes|=t,null!==(n=e.alternate)&&(n.childLanes|=t),n=e,e=e.return;return 3===n.tag?n.stateNode:null}var Or=!1;function Fr(e){e.updateQueue={baseState:e.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function Lr(e,t){e=e.updateQueue,t.updateQueue===e&&(t.updateQueue={baseState:e.baseState,firstBaseUpdate:e.firstBaseUpdate,lastBaseUpdate:e.lastBaseUpdate,shared:e.shared,effects:e.effects})}function zr(e,t){return{eventTime:e,lane:t,tag:0,payload:null,callback:null,next:null}}function Br(e,t,n){var a=e.updateQueue;if(null===a)return null;if(a=a.shared,0!==(2&Tc)){var s=a.pending;return null===s?t.next=t:(t.next=s.next,s.next=t),a.pending=t,Dr(e,n)}return null===(s=a.interleaved)?(t.next=t,Mr(a)):(t.next=s.next,s.next=t),a.interleaved=t,Dr(e,n)}function jr(e,t,n){if(null!==(t=t.updateQueue)&&(t=t.shared,0!==(4194240&n))){var a=t.lanes;n|=a&=e.pendingLanes,t.lanes=n,bt(e,n)}}function Wr(e,t){var n=e.updateQueue,a=e.alternate;if(null!==a&&n===(a=a.updateQueue)){var s=null,r=null;if(null!==(n=n.firstBaseUpdate)){do{var i={eventTime:n.eventTime,lane:n.lane,tag:n.tag,payload:n.payload,callback:n.callback,next:null};null===r?s=r=i:r=r.next=i,n=n.next}while(null!==n);null===r?s=r=t:r=r.next=t}else s=r=t;return n={baseState:a.baseState,firstBaseUpdate:s,lastBaseUpdate:r,shared:a.shared,effects:a.effects},void(e.updateQueue=n)}null===(e=n.lastBaseUpdate)?n.firstBaseUpdate=t:e.next=t,n.lastBaseUpdate=t}function Vr(e,t,n,a){var s=e.updateQueue;Or=!1;var r=s.firstBaseUpdate,i=s.lastBaseUpdate,o=s.shared.pending;if(null!==o){s.shared.pending=null;var c=o,l=c.next;c.next=null,null===i?r=l:i.next=l,i=c;var u=e.alternate;null!==u&&((o=(u=u.updateQueue).lastBaseUpdate)!==i&&(null===o?u.firstBaseUpdate=l:o.next=l,u.lastBaseUpdate=c))}if(null!==r){var h=s.baseState;for(i=0,u=l=c=null,o=r;;){var d=o.lane,p=o.eventTime;if((a&d)===d){null!==u&&(u=u.next={eventTime:p,lane:0,tag:o.tag,payload:o.payload,callback:o.callback,next:null});e:{var f=e,m=o;switch(d=t,p=n,m.tag){case 1:if("function"===typeof(f=m.payload)){h=f.call(p,h,d);break e}h=f;break e;case 3:f.flags=-65537&f.flags|128;case 0:if(null===(d="function"===typeof(f=m.payload)?f.call(p,h,d):f)||void 0===d)break e;h=L({},h,d);break e;case 2:Or=!0}}null!==o.callback&&0!==o.lane&&(e.flags|=64,null===(d=s.effects)?s.effects=[o]:d.push(o))}else p={eventTime:p,lane:d,tag:o.tag,payload:o.payload,callback:o.callback,next:null},null===u?(l=u=p,c=h):u=u.next=p,i|=d;if(null===(o=o.next)){if(null===(o=s.shared.pending))break;o=(d=o).next,d.next=null,s.lastBaseUpdate=d,s.shared.pending=null}}if(null===u&&(c=h),s.baseState=c,s.firstBaseUpdate=l,s.lastBaseUpdate=u,null!==(t=s.shared.interleaved)){s=t;do{i|=s.lane,s=s.next}while(s!==t)}else null===r&&(s.shared.lanes=0);Oc|=i,e.lanes=i,e.memoizedState=h}}function Ur(e,t,n){if(e=t.effects,t.effects=null,null!==e)for(t=0;t<e.length;t++){var a=e[t],s=a.callback;if(null!==s){if(a.callback=null,a=n,"function"!==typeof s)throw Error(r(191,s));s.call(a)}}}var Hr={},Gr=Cs(Hr),qr=Cs(Hr),Kr=Cs(Hr);function Xr(e){if(e===Hr)throw Error(r(174));return e}function Yr(e,t){switch(Ns(Kr,t),Ns(qr,e),Ns(Gr,Hr),e=t.nodeType){case 9:case 11:t=(t=t.documentElement)?t.namespaceURI:ce(null,"");break;default:t=ce(t=(e=8===e?t.parentNode:t).namespaceURI||null,e=e.tagName)}Is(Gr),Ns(Gr,t)}function Qr(){Is(Gr),Is(qr),Is(Kr)}function Zr(e){Xr(Kr.current);var t=Xr(Gr.current),n=ce(t,e.type);t!==n&&(Ns(qr,e),Ns(Gr,n))}function Jr(e){qr.current===e&&(Is(Gr),Is(qr))}var $r=Cs(0);function ei(e){for(var t=e;null!==t;){if(13===t.tag){var n=t.memoizedState;if(null!==n&&(null===(n=n.dehydrated)||"$?"===n.data||"$!"===n.data))return t}else if(19===t.tag&&void 0!==t.memoizedProps.revealOrder){if(0!==(128&t.flags))return t}else if(null!==t.child){t.child.return=t,t=t.child;continue}if(t===e)break;for(;null===t.sibling;){if(null===t.return||t.return===e)return null;t=t.return}t.sibling.return=t.return,t=t.sibling}return null}var ti=[];function ni(){for(var e=0;e<ti.length;e++)ti[e]._workInProgressVersionPrimary=null;ti.length=0}var ai=v.ReactCurrentDispatcher,si=v.ReactCurrentBatchConfig,ri=0,ii=null,oi=null,ci=null,li=!1,ui=!1,hi=0,di=0;function pi(){throw Error(r(321))}function fi(e,t){if(null===t)return!1;for(var n=0;n<t.length&&n<e.length;n++)if(!oa(e[n],t[n]))return!1;return!0}function mi(e,t,n,a,s,i){if(ri=i,ii=t,t.memoizedState=null,t.updateQueue=null,t.lanes=0,ai.current=null===e||null===e.memoizedState?Ji:$i,e=n(a,s),ui){i=0;do{if(ui=!1,hi=0,25<=i)throw Error(r(301));i+=1,ci=oi=null,t.updateQueue=null,ai.current=eo,e=n(a,s)}while(ui)}if(ai.current=Zi,t=null!==oi&&null!==oi.next,ri=0,ci=oi=ii=null,li=!1,t)throw Error(r(300));return e}function gi(){var e=0!==hi;return hi=0,e}function yi(){var e={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return null===ci?ii.memoizedState=ci=e:ci=ci.next=e,ci}function bi(){if(null===oi){var e=ii.alternate;e=null!==e?e.memoizedState:null}else e=oi.next;var t=null===ci?ii.memoizedState:ci.next;if(null!==t)ci=t,oi=e;else{if(null===e)throw Error(r(310));e={memoizedState:(oi=e).memoizedState,baseState:oi.baseState,baseQueue:oi.baseQueue,queue:oi.queue,next:null},null===ci?ii.memoizedState=ci=e:ci=ci.next=e}return ci}function xi(e,t){return"function"===typeof t?t(e):t}function vi(e){var t=bi(),n=t.queue;if(null===n)throw Error(r(311));n.lastRenderedReducer=e;var a=oi,s=a.baseQueue,i=n.pending;if(null!==i){if(null!==s){var o=s.next;s.next=i.next,i.next=o}a.baseQueue=s=i,n.pending=null}if(null!==s){i=s.next,a=a.baseState;var c=o=null,l=null,u=i;do{var h=u.lane;if((ri&h)===h)null!==l&&(l=l.next={lane:0,action:u.action,hasEagerState:u.hasEagerState,eagerState:u.eagerState,next:null}),a=u.hasEagerState?u.eagerState:e(a,u.action);else{var d={lane:h,action:u.action,hasEagerState:u.hasEagerState,eagerState:u.eagerState,next:null};null===l?(c=l=d,o=a):l=l.next=d,ii.lanes|=h,Oc|=h}u=u.next}while(null!==u&&u!==i);null===l?o=a:l.next=c,oa(a,t.memoizedState)||(xo=!0),t.memoizedState=a,t.baseState=o,t.baseQueue=l,n.lastRenderedState=a}if(null!==(e=n.interleaved)){s=e;do{i=s.lane,ii.lanes|=i,Oc|=i,s=s.next}while(s!==e)}else null===s&&(n.lanes=0);return[t.memoizedState,n.dispatch]}function wi(e){var t=bi(),n=t.queue;if(null===n)throw Error(r(311));n.lastRenderedReducer=e;var a=n.dispatch,s=n.pending,i=t.memoizedState;if(null!==s){n.pending=null;var o=s=s.next;do{i=e(i,o.action),o=o.next}while(o!==s);oa(i,t.memoizedState)||(xo=!0),t.memoizedState=i,null===t.baseQueue&&(t.baseState=i),n.lastRenderedState=i}return[i,a]}function ki(){}function Si(e,t){var n=ii,a=bi(),s=t(),i=!oa(a.memoizedState,s);if(i&&(a.memoizedState=s,xo=!0),a=a.queue,Oi(Ni.bind(null,n,a,e),[e]),a.getSnapshot!==t||i||null!==ci&&1&ci.memoizedState.tag){if(n.flags|=2048,_i(9,Ii.bind(null,n,a,s,t),void 0,null),null===Ec)throw Error(r(349));0!==(30&ri)||Ci(n,t,s)}return s}function Ci(e,t,n){e.flags|=16384,e={getSnapshot:t,value:n},null===(t=ii.updateQueue)?(t={lastEffect:null,stores:null},ii.updateQueue=t,t.stores=[e]):null===(n=t.stores)?t.stores=[e]:n.push(e)}function Ii(e,t,n,a){t.value=n,t.getSnapshot=a,Ti(t)&&Ei(e)}function Ni(e,t,n){return n(function(){Ti(t)&&Ei(e)})}function Ti(e){var t=e.getSnapshot;e=e.value;try{var n=t();return!oa(e,n)}catch(a){return!0}}function Ei(e){var t=Dr(e,1);null!==t&&tl(t,e,1,-1)}function Ri(e){var t=yi();return"function"===typeof e&&(e=e()),t.memoizedState=t.baseState=e,e={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:xi,lastRenderedState:e},t.queue=e,e=e.dispatch=Ki.bind(null,ii,e),[t.memoizedState,e]}function _i(e,t,n,a){return e={tag:e,create:t,destroy:n,deps:a,next:null},null===(t=ii.updateQueue)?(t={lastEffect:null,stores:null},ii.updateQueue=t,t.lastEffect=e.next=e):null===(n=t.lastEffect)?t.lastEffect=e.next=e:(a=n.next,n.next=e,e.next=a,t.lastEffect=e),e}function Ai(){return bi().memoizedState}function Mi(e,t,n,a){var s=yi();ii.flags|=e,s.memoizedState=_i(1|t,n,void 0,void 0===a?null:a)}function Pi(e,t,n,a){var s=bi();a=void 0===a?null:a;var r=void 0;if(null!==oi){var i=oi.memoizedState;if(r=i.destroy,null!==a&&fi(a,i.deps))return void(s.memoizedState=_i(t,n,r,a))}ii.flags|=e,s.memoizedState=_i(1|t,n,r,a)}function Di(e,t){return Mi(8390656,8,e,t)}function Oi(e,t){return Pi(2048,8,e,t)}function Fi(e,t){return Pi(4,2,e,t)}function Li(e,t){return Pi(4,4,e,t)}function zi(e,t){return"function"===typeof t?(e=e(),t(e),function(){t(null)}):null!==t&&void 0!==t?(e=e(),t.current=e,function(){t.current=null}):void 0}function Bi(e,t,n){return n=null!==n&&void 0!==n?n.concat([e]):null,Pi(4,4,zi.bind(null,t,e),n)}function ji(){}function Wi(e,t){var n=bi();t=void 0===t?null:t;var a=n.memoizedState;return null!==a&&null!==t&&fi(t,a[1])?a[0]:(n.memoizedState=[e,t],e)}function Vi(e,t){var n=bi();t=void 0===t?null:t;var a=n.memoizedState;return null!==a&&null!==t&&fi(t,a[1])?a[0]:(e=e(),n.memoizedState=[e,t],e)}function Ui(e,t,n){return 0===(21&ri)?(e.baseState&&(e.baseState=!1,xo=!0),e.memoizedState=n):(oa(n,t)||(n=mt(),ii.lanes|=n,Oc|=n,e.baseState=!0),t)}function Hi(e,t){var n=xt;xt=0!==n&&4>n?n:4,e(!0);var a=si.transition;si.transition={};try{e(!1),t()}finally{xt=n,si.transition=a}}function Gi(){return bi().memoizedState}function qi(e,t,n){var a=el(e);if(n={lane:a,action:n,hasEagerState:!1,eagerState:null,next:null},Xi(e))Yi(t,n);else if(null!==(n=Pr(e,t,n,a))){tl(n,e,a,$c()),Qi(n,t,a)}}function Ki(e,t,n){var a=el(e),s={lane:a,action:n,hasEagerState:!1,eagerState:null,next:null};if(Xi(e))Yi(t,s);else{var r=e.alternate;if(0===e.lanes&&(null===r||0===r.lanes)&&null!==(r=t.lastRenderedReducer))try{var i=t.lastRenderedState,o=r(i,n);if(s.hasEagerState=!0,s.eagerState=o,oa(o,i)){var c=t.interleaved;return null===c?(s.next=s,Mr(t)):(s.next=c.next,c.next=s),void(t.interleaved=s)}}catch(l){}null!==(n=Pr(e,t,s,a))&&(tl(n,e,a,s=$c()),Qi(n,t,a))}}function Xi(e){var t=e.alternate;return e===ii||null!==t&&t===ii}function Yi(e,t){ui=li=!0;var n=e.pending;null===n?t.next=t:(t.next=n.next,n.next=t),e.pending=t}function Qi(e,t,n){if(0!==(4194240&n)){var a=t.lanes;n|=a&=e.pendingLanes,t.lanes=n,bt(e,n)}}var Zi={readContext:_r,useCallback:pi,useContext:pi,useEffect:pi,useImperativeHandle:pi,useInsertionEffect:pi,useLayoutEffect:pi,useMemo:pi,useReducer:pi,useRef:pi,useState:pi,useDebugValue:pi,useDeferredValue:pi,useTransition:pi,useMutableSource:pi,useSyncExternalStore:pi,useId:pi,unstable_isNewReconciler:!1},Ji={readContext:_r,useCallback:function(e,t){return yi().memoizedState=[e,void 0===t?null:t],e},useContext:_r,useEffect:Di,useImperativeHandle:function(e,t,n){return n=null!==n&&void 0!==n?n.concat([e]):null,Mi(4194308,4,zi.bind(null,t,e),n)},useLayoutEffect:function(e,t){return Mi(4194308,4,e,t)},useInsertionEffect:function(e,t){return Mi(4,2,e,t)},useMemo:function(e,t){var n=yi();return t=void 0===t?null:t,e=e(),n.memoizedState=[e,t],e},useReducer:function(e,t,n){var a=yi();return t=void 0!==n?n(t):t,a.memoizedState=a.baseState=t,e={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:e,lastRenderedState:t},a.queue=e,e=e.dispatch=qi.bind(null,ii,e),[a.memoizedState,e]},useRef:function(e){return e={current:e},yi().memoizedState=e},useState:Ri,useDebugValue:ji,useDeferredValue:function(e){return yi().memoizedState=e},useTransition:function(){var e=Ri(!1),t=e[0];return e=Hi.bind(null,e[1]),yi().memoizedState=e,[t,e]},useMutableSource:function(){},useSyncExternalStore:function(e,t,n){var a=ii,s=yi();if(sr){if(void 0===n)throw Error(r(407));n=n()}else{if(n=t(),null===Ec)throw Error(r(349));0!==(30&ri)||Ci(a,t,n)}s.memoizedState=n;var i={value:n,getSnapshot:t};return s.queue=i,Di(Ni.bind(null,a,i,e),[e]),a.flags|=2048,_i(9,Ii.bind(null,a,i,n,t),void 0,null),n},useId:function(){var e=yi(),t=Ec.identifierPrefix;if(sr){var n=Zs;t=":"+t+"R"+(n=(Qs&~(1<<32-it(Qs)-1)).toString(32)+n),0<(n=hi++)&&(t+="H"+n.toString(32)),t+=":"}else t=":"+t+"r"+(n=di++).toString(32)+":";return e.memoizedState=t},unstable_isNewReconciler:!1},$i={readContext:_r,useCallback:Wi,useContext:_r,useEffect:Oi,useImperativeHandle:Bi,useInsertionEffect:Fi,useLayoutEffect:Li,useMemo:Vi,useReducer:vi,useRef:Ai,useState:function(){return vi(xi)},useDebugValue:ji,useDeferredValue:function(e){return Ui(bi(),oi.memoizedState,e)},useTransition:function(){return[vi(xi)[0],bi().memoizedState]},useMutableSource:ki,useSyncExternalStore:Si,useId:Gi,unstable_isNewReconciler:!1},eo={readContext:_r,useCallback:Wi,useContext:_r,useEffect:Oi,useImperativeHandle:Bi,useInsertionEffect:Fi,useLayoutEffect:Li,useMemo:Vi,useReducer:wi,useRef:Ai,useState:function(){return wi(xi)},useDebugValue:ji,useDeferredValue:function(e){var t=bi();return null===oi?t.memoizedState=e:Ui(t,oi.memoizedState,e)},useTransition:function(){return[wi(xi)[0],bi().memoizedState]},useMutableSource:ki,useSyncExternalStore:Si,useId:Gi,unstable_isNewReconciler:!1};function to(e,t){if(e&&e.defaultProps){for(var n in t=L({},t),e=e.defaultProps)void 0===t[n]&&(t[n]=e[n]);return t}return t}function no(e,t,n,a){n=null===(n=n(a,t=e.memoizedState))||void 0===n?t:L({},t,n),e.memoizedState=n,0===e.lanes&&(e.updateQueue.baseState=n)}var ao={isMounted:function(e){return!!(e=e._reactInternals)&&Ve(e)===e},enqueueSetState:function(e,t,n){e=e._reactInternals;var a=$c(),s=el(e),r=zr(a,s);r.payload=t,void 0!==n&&null!==n&&(r.callback=n),null!==(t=Br(e,r,s))&&(tl(t,e,s,a),jr(t,e,s))},enqueueReplaceState:function(e,t,n){e=e._reactInternals;var a=$c(),s=el(e),r=zr(a,s);r.tag=1,r.payload=t,void 0!==n&&null!==n&&(r.callback=n),null!==(t=Br(e,r,s))&&(tl(t,e,s,a),jr(t,e,s))},enqueueForceUpdate:function(e,t){e=e._reactInternals;var n=$c(),a=el(e),s=zr(n,a);s.tag=2,void 0!==t&&null!==t&&(s.callback=t),null!==(t=Br(e,s,a))&&(tl(t,e,a,n),jr(t,e,a))}};function so(e,t,n,a,s,r,i){return"function"===typeof(e=e.stateNode).shouldComponentUpdate?e.shouldComponentUpdate(a,r,i):!t.prototype||!t.prototype.isPureReactComponent||(!ca(n,a)||!ca(s,r))}function ro(e,t,n){var a=!1,s=Ts,r=t.contextType;return"object"===typeof r&&null!==r?r=_r(r):(s=Ms(t)?_s:Es.current,r=(a=null!==(a=t.contextTypes)&&void 0!==a)?As(e,s):Ts),t=new t(n,r),e.memoizedState=null!==t.state&&void 0!==t.state?t.state:null,t.updater=ao,e.stateNode=t,t._reactInternals=e,a&&((e=e.stateNode).__reactInternalMemoizedUnmaskedChildContext=s,e.__reactInternalMemoizedMaskedChildContext=r),t}function io(e,t,n,a){e=t.state,"function"===typeof t.componentWillReceiveProps&&t.componentWillReceiveProps(n,a),"function"===typeof t.UNSAFE_componentWillReceiveProps&&t.UNSAFE_componentWillReceiveProps(n,a),t.state!==e&&ao.enqueueReplaceState(t,t.state,null)}function oo(e,t,n,a){var s=e.stateNode;s.props=n,s.state=e.memoizedState,s.refs={},Fr(e);var r=t.contextType;"object"===typeof r&&null!==r?s.context=_r(r):(r=Ms(t)?_s:Es.current,s.context=As(e,r)),s.state=e.memoizedState,"function"===typeof(r=t.getDerivedStateFromProps)&&(no(e,t,r,n),s.state=e.memoizedState),"function"===typeof t.getDerivedStateFromProps||"function"===typeof s.getSnapshotBeforeUpdate||"function"!==typeof s.UNSAFE_componentWillMount&&"function"!==typeof s.componentWillMount||(t=s.state,"function"===typeof s.componentWillMount&&s.componentWillMount(),"function"===typeof s.UNSAFE_componentWillMount&&s.UNSAFE_componentWillMount(),t!==s.state&&ao.enqueueReplaceState(s,s.state,null),Vr(e,n,s,a),s.state=e.memoizedState),"function"===typeof s.componentDidMount&&(e.flags|=4194308)}function co(e,t){try{var n="",a=t;do{n+=W(a),a=a.return}while(a);var s=n}catch(r){s="\nError generating stack: "+r.message+"\n"+r.stack}return{value:e,source:t,stack:s,digest:null}}function lo(e,t,n){return{value:e,source:null,stack:null!=n?n:null,digest:null!=t?t:null}}function uo(e,t){try{console.error(t.value)}catch(n){setTimeout(function(){throw n})}}var ho="function"===typeof WeakMap?WeakMap:Map;function po(e,t,n){(n=zr(-1,n)).tag=3,n.payload={element:null};var a=t.value;return n.callback=function(){Uc||(Uc=!0,Hc=a),uo(0,t)},n}function fo(e,t,n){(n=zr(-1,n)).tag=3;var a=e.type.getDerivedStateFromError;if("function"===typeof a){var s=t.value;n.payload=function(){return a(s)},n.callback=function(){uo(0,t)}}var r=e.stateNode;return null!==r&&"function"===typeof r.componentDidCatch&&(n.callback=function(){uo(0,t),"function"!==typeof a&&(null===Gc?Gc=new Set([this]):Gc.add(this));var e=t.stack;this.componentDidCatch(t.value,{componentStack:null!==e?e:""})}),n}function mo(e,t,n){var a=e.pingCache;if(null===a){a=e.pingCache=new ho;var s=new Set;a.set(t,s)}else void 0===(s=a.get(t))&&(s=new Set,a.set(t,s));s.has(n)||(s.add(n),e=Cl.bind(null,e,t,n),t.then(e,e))}function go(e){do{var t;if((t=13===e.tag)&&(t=null===(t=e.memoizedState)||null!==t.dehydrated),t)return e;e=e.return}while(null!==e);return null}function yo(e,t,n,a,s){return 0===(1&e.mode)?(e===t?e.flags|=65536:(e.flags|=128,n.flags|=131072,n.flags&=-52805,1===n.tag&&(null===n.alternate?n.tag=17:((t=zr(-1,1)).tag=2,Br(n,t,1))),n.lanes|=1),e):(e.flags|=65536,e.lanes=s,e)}var bo=v.ReactCurrentOwner,xo=!1;function vo(e,t,n,a){t.child=null===e?wr(t,null,n,a):vr(t,e.child,n,a)}function wo(e,t,n,a,s){n=n.render;var r=t.ref;return Rr(t,s),a=mi(e,t,n,a,r,s),n=gi(),null===e||xo?(sr&&n&&er(t),t.flags|=1,vo(e,t,a,s),t.child):(t.updateQueue=e.updateQueue,t.flags&=-2053,e.lanes&=~s,Uo(e,t,s))}function ko(e,t,n,a,s){if(null===e){var r=n.type;return"function"!==typeof r||Al(r)||void 0!==r.defaultProps||null!==n.compare||void 0!==n.defaultProps?((e=Pl(n.type,null,a,t,t.mode,s)).ref=t.ref,e.return=t,t.child=e):(t.tag=15,t.type=r,So(e,t,r,a,s))}if(r=e.child,0===(e.lanes&s)){var i=r.memoizedProps;if((n=null!==(n=n.compare)?n:ca)(i,a)&&e.ref===t.ref)return Uo(e,t,s)}return t.flags|=1,(e=Ml(r,a)).ref=t.ref,e.return=t,t.child=e}function So(e,t,n,a,s){if(null!==e){var r=e.memoizedProps;if(ca(r,a)&&e.ref===t.ref){if(xo=!1,t.pendingProps=a=r,0===(e.lanes&s))return t.lanes=e.lanes,Uo(e,t,s);0!==(131072&e.flags)&&(xo=!0)}}return No(e,t,n,a,s)}function Co(e,t,n){var a=t.pendingProps,s=a.children,r=null!==e?e.memoizedState:null;if("hidden"===a.mode)if(0===(1&t.mode))t.memoizedState={baseLanes:0,cachePool:null,transitions:null},Ns(Mc,Ac),Ac|=n;else{if(0===(1073741824&n))return e=null!==r?r.baseLanes|n:n,t.lanes=t.childLanes=1073741824,t.memoizedState={baseLanes:e,cachePool:null,transitions:null},t.updateQueue=null,Ns(Mc,Ac),Ac|=e,null;t.memoizedState={baseLanes:0,cachePool:null,transitions:null},a=null!==r?r.baseLanes:n,Ns(Mc,Ac),Ac|=a}else null!==r?(a=r.baseLanes|n,t.memoizedState=null):a=n,Ns(Mc,Ac),Ac|=a;return vo(e,t,s,n),t.child}function Io(e,t){var n=t.ref;(null===e&&null!==n||null!==e&&e.ref!==n)&&(t.flags|=512,t.flags|=2097152)}function No(e,t,n,a,s){var r=Ms(n)?_s:Es.current;return r=As(t,r),Rr(t,s),n=mi(e,t,n,a,r,s),a=gi(),null===e||xo?(sr&&a&&er(t),t.flags|=1,vo(e,t,n,s),t.child):(t.updateQueue=e.updateQueue,t.flags&=-2053,e.lanes&=~s,Uo(e,t,s))}function To(e,t,n,a,s){if(Ms(n)){var r=!0;Fs(t)}else r=!1;if(Rr(t,s),null===t.stateNode)Vo(e,t),ro(t,n,a),oo(t,n,a,s),a=!0;else if(null===e){var i=t.stateNode,o=t.memoizedProps;i.props=o;var c=i.context,l=n.contextType;"object"===typeof l&&null!==l?l=_r(l):l=As(t,l=Ms(n)?_s:Es.current);var u=n.getDerivedStateFromProps,h="function"===typeof u||"function"===typeof i.getSnapshotBeforeUpdate;h||"function"!==typeof i.UNSAFE_componentWillReceiveProps&&"function"!==typeof i.componentWillReceiveProps||(o!==a||c!==l)&&io(t,i,a,l),Or=!1;var d=t.memoizedState;i.state=d,Vr(t,a,i,s),c=t.memoizedState,o!==a||d!==c||Rs.current||Or?("function"===typeof u&&(no(t,n,u,a),c=t.memoizedState),(o=Or||so(t,n,o,a,d,c,l))?(h||"function"!==typeof i.UNSAFE_componentWillMount&&"function"!==typeof i.componentWillMount||("function"===typeof i.componentWillMount&&i.componentWillMount(),"function"===typeof i.UNSAFE_componentWillMount&&i.UNSAFE_componentWillMount()),"function"===typeof i.componentDidMount&&(t.flags|=4194308)):("function"===typeof i.componentDidMount&&(t.flags|=4194308),t.memoizedProps=a,t.memoizedState=c),i.props=a,i.state=c,i.context=l,a=o):("function"===typeof i.componentDidMount&&(t.flags|=4194308),a=!1)}else{i=t.stateNode,Lr(e,t),o=t.memoizedProps,l=t.type===t.elementType?o:to(t.type,o),i.props=l,h=t.pendingProps,d=i.context,"object"===typeof(c=n.contextType)&&null!==c?c=_r(c):c=As(t,c=Ms(n)?_s:Es.current);var p=n.getDerivedStateFromProps;(u="function"===typeof p||"function"===typeof i.getSnapshotBeforeUpdate)||"function"!==typeof i.UNSAFE_componentWillReceiveProps&&"function"!==typeof i.componentWillReceiveProps||(o!==h||d!==c)&&io(t,i,a,c),Or=!1,d=t.memoizedState,i.state=d,Vr(t,a,i,s);var f=t.memoizedState;o!==h||d!==f||Rs.current||Or?("function"===typeof p&&(no(t,n,p,a),f=t.memoizedState),(l=Or||so(t,n,l,a,d,f,c)||!1)?(u||"function"!==typeof i.UNSAFE_componentWillUpdate&&"function"!==typeof i.componentWillUpdate||("function"===typeof i.componentWillUpdate&&i.componentWillUpdate(a,f,c),"function"===typeof i.UNSAFE_componentWillUpdate&&i.UNSAFE_componentWillUpdate(a,f,c)),"function"===typeof i.componentDidUpdate&&(t.flags|=4),"function"===typeof i.getSnapshotBeforeUpdate&&(t.flags|=1024)):("function"!==typeof i.componentDidUpdate||o===e.memoizedProps&&d===e.memoizedState||(t.flags|=4),"function"!==typeof i.getSnapshotBeforeUpdate||o===e.memoizedProps&&d===e.memoizedState||(t.flags|=1024),t.memoizedProps=a,t.memoizedState=f),i.props=a,i.state=f,i.context=c,a=l):("function"!==typeof i.componentDidUpdate||o===e.memoizedProps&&d===e.memoizedState||(t.flags|=4),"function"!==typeof i.getSnapshotBeforeUpdate||o===e.memoizedProps&&d===e.memoizedState||(t.flags|=1024),a=!1)}return Eo(e,t,n,a,r,s)}function Eo(e,t,n,a,s,r){Io(e,t);var i=0!==(128&t.flags);if(!a&&!i)return s&&Ls(t,n,!1),Uo(e,t,r);a=t.stateNode,bo.current=t;var o=i&&"function"!==typeof n.getDerivedStateFromError?null:a.render();return t.flags|=1,null!==e&&i?(t.child=vr(t,e.child,null,r),t.child=vr(t,null,o,r)):vo(e,t,o,r),t.memoizedState=a.state,s&&Ls(t,n,!0),t.child}function Ro(e){var t=e.stateNode;t.pendingContext?Ds(0,t.pendingContext,t.pendingContext!==t.context):t.context&&Ds(0,t.context,!1),Yr(e,t.containerInfo)}function _o(e,t,n,a,s){return pr(),fr(s),t.flags|=256,vo(e,t,n,a),t.child}var Ao,Mo,Po,Do={dehydrated:null,treeContext:null,retryLane:0};function Oo(e){return{baseLanes:e,cachePool:null,transitions:null}}function Fo(e,t,n){var a,s=t.pendingProps,i=$r.current,o=!1,c=0!==(128&t.flags);if((a=c)||(a=(null===e||null!==e.memoizedState)&&0!==(2&i)),a?(o=!0,t.flags&=-129):null!==e&&null===e.memoizedState||(i|=1),Ns($r,1&i),null===e)return lr(t),null!==(e=t.memoizedState)&&null!==(e=e.dehydrated)?(0===(1&t.mode)?t.lanes=1:"$!"===e.data?t.lanes=8:t.lanes=1073741824,null):(c=s.children,e=s.fallback,o?(s=t.mode,o=t.child,c={mode:"hidden",children:c},0===(1&s)&&null!==o?(o.childLanes=0,o.pendingProps=c):o=Ol(c,s,0,null),e=Dl(e,s,n,null),o.return=t,e.return=t,o.sibling=e,t.child=o,t.child.memoizedState=Oo(n),t.memoizedState=Do,e):Lo(t,c));if(null!==(i=e.memoizedState)&&null!==(a=i.dehydrated))return function(e,t,n,a,s,i,o){if(n)return 256&t.flags?(t.flags&=-257,zo(e,t,o,a=lo(Error(r(422))))):null!==t.memoizedState?(t.child=e.child,t.flags|=128,null):(i=a.fallback,s=t.mode,a=Ol({mode:"visible",children:a.children},s,0,null),(i=Dl(i,s,o,null)).flags|=2,a.return=t,i.return=t,a.sibling=i,t.child=a,0!==(1&t.mode)&&vr(t,e.child,null,o),t.child.memoizedState=Oo(o),t.memoizedState=Do,i);if(0===(1&t.mode))return zo(e,t,o,null);if("$!"===s.data){if(a=s.nextSibling&&s.nextSibling.dataset)var c=a.dgst;return a=c,zo(e,t,o,a=lo(i=Error(r(419)),a,void 0))}if(c=0!==(o&e.childLanes),xo||c){if(null!==(a=Ec)){switch(o&-o){case 4:s=2;break;case 16:s=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:s=32;break;case 536870912:s=268435456;break;default:s=0}0!==(s=0!==(s&(a.suspendedLanes|o))?0:s)&&s!==i.retryLane&&(i.retryLane=s,Dr(e,s),tl(a,e,s,-1))}return fl(),zo(e,t,o,a=lo(Error(r(421))))}return"$?"===s.data?(t.flags|=128,t.child=e.child,t=Nl.bind(null,e),s._reactRetry=t,null):(e=i.treeContext,ar=ls(s.nextSibling),nr=t,sr=!0,rr=null,null!==e&&(Ks[Xs++]=Qs,Ks[Xs++]=Zs,Ks[Xs++]=Ys,Qs=e.id,Zs=e.overflow,Ys=t),t=Lo(t,a.children),t.flags|=4096,t)}(e,t,c,s,a,i,n);if(o){o=s.fallback,c=t.mode,a=(i=e.child).sibling;var l={mode:"hidden",children:s.children};return 0===(1&c)&&t.child!==i?((s=t.child).childLanes=0,s.pendingProps=l,t.deletions=null):(s=Ml(i,l)).subtreeFlags=14680064&i.subtreeFlags,null!==a?o=Ml(a,o):(o=Dl(o,c,n,null)).flags|=2,o.return=t,s.return=t,s.sibling=o,t.child=s,s=o,o=t.child,c=null===(c=e.child.memoizedState)?Oo(n):{baseLanes:c.baseLanes|n,cachePool:null,transitions:c.transitions},o.memoizedState=c,o.childLanes=e.childLanes&~n,t.memoizedState=Do,s}return e=(o=e.child).sibling,s=Ml(o,{mode:"visible",children:s.children}),0===(1&t.mode)&&(s.lanes=n),s.return=t,s.sibling=null,null!==e&&(null===(n=t.deletions)?(t.deletions=[e],t.flags|=16):n.push(e)),t.child=s,t.memoizedState=null,s}function Lo(e,t){return(t=Ol({mode:"visible",children:t},e.mode,0,null)).return=e,e.child=t}function zo(e,t,n,a){return null!==a&&fr(a),vr(t,e.child,null,n),(e=Lo(t,t.pendingProps.children)).flags|=2,t.memoizedState=null,e}function Bo(e,t,n){e.lanes|=t;var a=e.alternate;null!==a&&(a.lanes|=t),Er(e.return,t,n)}function jo(e,t,n,a,s){var r=e.memoizedState;null===r?e.memoizedState={isBackwards:t,rendering:null,renderingStartTime:0,last:a,tail:n,tailMode:s}:(r.isBackwards=t,r.rendering=null,r.renderingStartTime=0,r.last=a,r.tail=n,r.tailMode=s)}function Wo(e,t,n){var a=t.pendingProps,s=a.revealOrder,r=a.tail;if(vo(e,t,a.children,n),0!==(2&(a=$r.current)))a=1&a|2,t.flags|=128;else{if(null!==e&&0!==(128&e.flags))e:for(e=t.child;null!==e;){if(13===e.tag)null!==e.memoizedState&&Bo(e,n,t);else if(19===e.tag)Bo(e,n,t);else if(null!==e.child){e.child.return=e,e=e.child;continue}if(e===t)break e;for(;null===e.sibling;){if(null===e.return||e.return===t)break e;e=e.return}e.sibling.return=e.return,e=e.sibling}a&=1}if(Ns($r,a),0===(1&t.mode))t.memoizedState=null;else switch(s){case"forwards":for(n=t.child,s=null;null!==n;)null!==(e=n.alternate)&&null===ei(e)&&(s=n),n=n.sibling;null===(n=s)?(s=t.child,t.child=null):(s=n.sibling,n.sibling=null),jo(t,!1,s,n,r);break;case"backwards":for(n=null,s=t.child,t.child=null;null!==s;){if(null!==(e=s.alternate)&&null===ei(e)){t.child=s;break}e=s.sibling,s.sibling=n,n=s,s=e}jo(t,!0,n,null,r);break;case"together":jo(t,!1,null,null,void 0);break;default:t.memoizedState=null}return t.child}function Vo(e,t){0===(1&t.mode)&&null!==e&&(e.alternate=null,t.alternate=null,t.flags|=2)}function Uo(e,t,n){if(null!==e&&(t.dependencies=e.dependencies),Oc|=t.lanes,0===(n&t.childLanes))return null;if(null!==e&&t.child!==e.child)throw Error(r(153));if(null!==t.child){for(n=Ml(e=t.child,e.pendingProps),t.child=n,n.return=t;null!==e.sibling;)e=e.sibling,(n=n.sibling=Ml(e,e.pendingProps)).return=t;n.sibling=null}return t.child}function Ho(e,t){if(!sr)switch(e.tailMode){case"hidden":t=e.tail;for(var n=null;null!==t;)null!==t.alternate&&(n=t),t=t.sibling;null===n?e.tail=null:n.sibling=null;break;case"collapsed":n=e.tail;for(var a=null;null!==n;)null!==n.alternate&&(a=n),n=n.sibling;null===a?t||null===e.tail?e.tail=null:e.tail.sibling=null:a.sibling=null}}function Go(e){var t=null!==e.alternate&&e.alternate.child===e.child,n=0,a=0;if(t)for(var s=e.child;null!==s;)n|=s.lanes|s.childLanes,a|=14680064&s.subtreeFlags,a|=14680064&s.flags,s.return=e,s=s.sibling;else for(s=e.child;null!==s;)n|=s.lanes|s.childLanes,a|=s.subtreeFlags,a|=s.flags,s.return=e,s=s.sibling;return e.subtreeFlags|=a,e.childLanes=n,t}function qo(e,t,n){var a=t.pendingProps;switch(tr(t),t.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return Go(t),null;case 1:case 17:return Ms(t.type)&&Ps(),Go(t),null;case 3:return a=t.stateNode,Qr(),Is(Rs),Is(Es),ni(),a.pendingContext&&(a.context=a.pendingContext,a.pendingContext=null),null!==e&&null!==e.child||(hr(t)?t.flags|=4:null===e||e.memoizedState.isDehydrated&&0===(256&t.flags)||(t.flags|=1024,null!==rr&&(rl(rr),rr=null))),Go(t),null;case 5:Jr(t);var s=Xr(Kr.current);if(n=t.type,null!==e&&null!=t.stateNode)Mo(e,t,n,a),e.ref!==t.ref&&(t.flags|=512,t.flags|=2097152);else{if(!a){if(null===t.stateNode)throw Error(r(166));return Go(t),null}if(e=Xr(Gr.current),hr(t)){a=t.stateNode,n=t.type;var i=t.memoizedProps;switch(a[ds]=t,a[ps]=i,e=0!==(1&t.mode),n){case"dialog":Ba("cancel",a),Ba("close",a);break;case"iframe":case"object":case"embed":Ba("load",a);break;case"video":case"audio":for(s=0;s<Oa.length;s++)Ba(Oa[s],a);break;case"source":Ba("error",a);break;case"img":case"image":case"link":Ba("error",a),Ba("load",a);break;case"details":Ba("toggle",a);break;case"input":Q(a,i),Ba("invalid",a);break;case"select":a._wrapperState={wasMultiple:!!i.multiple},Ba("invalid",a);break;case"textarea":se(a,i),Ba("invalid",a)}for(var c in be(n,i),s=null,i)if(i.hasOwnProperty(c)){var l=i[c];"children"===c?"string"===typeof l?a.textContent!==l&&(!0!==i.suppressHydrationWarning&&Ja(a.textContent,l,e),s=["children",l]):"number"===typeof l&&a.textContent!==""+l&&(!0!==i.suppressHydrationWarning&&Ja(a.textContent,l,e),s=["children",""+l]):o.hasOwnProperty(c)&&null!=l&&"onScroll"===c&&Ba("scroll",a)}switch(n){case"input":q(a),$(a,i,!0);break;case"textarea":q(a),ie(a);break;case"select":case"option":break;default:"function"===typeof i.onClick&&(a.onclick=$a)}a=s,t.updateQueue=a,null!==a&&(t.flags|=4)}else{c=9===s.nodeType?s:s.ownerDocument,"http://www.w3.org/1999/xhtml"===e&&(e=oe(n)),"http://www.w3.org/1999/xhtml"===e?"script"===n?((e=c.createElement("div")).innerHTML="<script><\/script>",e=e.removeChild(e.firstChild)):"string"===typeof a.is?e=c.createElement(n,{is:a.is}):(e=c.createElement(n),"select"===n&&(c=e,a.multiple?c.multiple=!0:a.size&&(c.size=a.size))):e=c.createElementNS(e,n),e[ds]=t,e[ps]=a,Ao(e,t),t.stateNode=e;e:{switch(c=xe(n,a),n){case"dialog":Ba("cancel",e),Ba("close",e),s=a;break;case"iframe":case"object":case"embed":Ba("load",e),s=a;break;case"video":case"audio":for(s=0;s<Oa.length;s++)Ba(Oa[s],e);s=a;break;case"source":Ba("error",e),s=a;break;case"img":case"image":case"link":Ba("error",e),Ba("load",e),s=a;break;case"details":Ba("toggle",e),s=a;break;case"input":Q(e,a),s=Y(e,a),Ba("invalid",e);break;case"option":default:s=a;break;case"select":e._wrapperState={wasMultiple:!!a.multiple},s=L({},a,{value:void 0}),Ba("invalid",e);break;case"textarea":se(e,a),s=ae(e,a),Ba("invalid",e)}for(i in be(n,s),l=s)if(l.hasOwnProperty(i)){var u=l[i];"style"===i?ge(e,u):"dangerouslySetInnerHTML"===i?null!=(u=u?u.__html:void 0)&&he(e,u):"children"===i?"string"===typeof u?("textarea"!==n||""!==u)&&de(e,u):"number"===typeof u&&de(e,""+u):"suppressContentEditableWarning"!==i&&"suppressHydrationWarning"!==i&&"autoFocus"!==i&&(o.hasOwnProperty(i)?null!=u&&"onScroll"===i&&Ba("scroll",e):null!=u&&x(e,i,u,c))}switch(n){case"input":q(e),$(e,a,!1);break;case"textarea":q(e),ie(e);break;case"option":null!=a.value&&e.setAttribute("value",""+H(a.value));break;case"select":e.multiple=!!a.multiple,null!=(i=a.value)?ne(e,!!a.multiple,i,!1):null!=a.defaultValue&&ne(e,!!a.multiple,a.defaultValue,!0);break;default:"function"===typeof s.onClick&&(e.onclick=$a)}switch(n){case"button":case"input":case"select":case"textarea":a=!!a.autoFocus;break e;case"img":a=!0;break e;default:a=!1}}a&&(t.flags|=4)}null!==t.ref&&(t.flags|=512,t.flags|=2097152)}return Go(t),null;case 6:if(e&&null!=t.stateNode)Po(0,t,e.memoizedProps,a);else{if("string"!==typeof a&&null===t.stateNode)throw Error(r(166));if(n=Xr(Kr.current),Xr(Gr.current),hr(t)){if(a=t.stateNode,n=t.memoizedProps,a[ds]=t,(i=a.nodeValue!==n)&&null!==(e=nr))switch(e.tag){case 3:Ja(a.nodeValue,n,0!==(1&e.mode));break;case 5:!0!==e.memoizedProps.suppressHydrationWarning&&Ja(a.nodeValue,n,0!==(1&e.mode))}i&&(t.flags|=4)}else(a=(9===n.nodeType?n:n.ownerDocument).createTextNode(a))[ds]=t,t.stateNode=a}return Go(t),null;case 13:if(Is($r),a=t.memoizedState,null===e||null!==e.memoizedState&&null!==e.memoizedState.dehydrated){if(sr&&null!==ar&&0!==(1&t.mode)&&0===(128&t.flags))dr(),pr(),t.flags|=98560,i=!1;else if(i=hr(t),null!==a&&null!==a.dehydrated){if(null===e){if(!i)throw Error(r(318));if(!(i=null!==(i=t.memoizedState)?i.dehydrated:null))throw Error(r(317));i[ds]=t}else pr(),0===(128&t.flags)&&(t.memoizedState=null),t.flags|=4;Go(t),i=!1}else null!==rr&&(rl(rr),rr=null),i=!0;if(!i)return 65536&t.flags?t:null}return 0!==(128&t.flags)?(t.lanes=n,t):((a=null!==a)!==(null!==e&&null!==e.memoizedState)&&a&&(t.child.flags|=8192,0!==(1&t.mode)&&(null===e||0!==(1&$r.current)?0===Pc&&(Pc=3):fl())),null!==t.updateQueue&&(t.flags|=4),Go(t),null);case 4:return Qr(),null===e&&Va(t.stateNode.containerInfo),Go(t),null;case 10:return Tr(t.type._context),Go(t),null;case 19:if(Is($r),null===(i=t.memoizedState))return Go(t),null;if(a=0!==(128&t.flags),null===(c=i.rendering))if(a)Ho(i,!1);else{if(0!==Pc||null!==e&&0!==(128&e.flags))for(e=t.child;null!==e;){if(null!==(c=ei(e))){for(t.flags|=128,Ho(i,!1),null!==(a=c.updateQueue)&&(t.updateQueue=a,t.flags|=4),t.subtreeFlags=0,a=n,n=t.child;null!==n;)e=a,(i=n).flags&=14680066,null===(c=i.alternate)?(i.childLanes=0,i.lanes=e,i.child=null,i.subtreeFlags=0,i.memoizedProps=null,i.memoizedState=null,i.updateQueue=null,i.dependencies=null,i.stateNode=null):(i.childLanes=c.childLanes,i.lanes=c.lanes,i.child=c.child,i.subtreeFlags=0,i.deletions=null,i.memoizedProps=c.memoizedProps,i.memoizedState=c.memoizedState,i.updateQueue=c.updateQueue,i.type=c.type,e=c.dependencies,i.dependencies=null===e?null:{lanes:e.lanes,firstContext:e.firstContext}),n=n.sibling;return Ns($r,1&$r.current|2),t.child}e=e.sibling}null!==i.tail&&Ze()>Wc&&(t.flags|=128,a=!0,Ho(i,!1),t.lanes=4194304)}else{if(!a)if(null!==(e=ei(c))){if(t.flags|=128,a=!0,null!==(n=e.updateQueue)&&(t.updateQueue=n,t.flags|=4),Ho(i,!0),null===i.tail&&"hidden"===i.tailMode&&!c.alternate&&!sr)return Go(t),null}else 2*Ze()-i.renderingStartTime>Wc&&1073741824!==n&&(t.flags|=128,a=!0,Ho(i,!1),t.lanes=4194304);i.isBackwards?(c.sibling=t.child,t.child=c):(null!==(n=i.last)?n.sibling=c:t.child=c,i.last=c)}return null!==i.tail?(t=i.tail,i.rendering=t,i.tail=t.sibling,i.renderingStartTime=Ze(),t.sibling=null,n=$r.current,Ns($r,a?1&n|2:1&n),t):(Go(t),null);case 22:case 23:return ul(),a=null!==t.memoizedState,null!==e&&null!==e.memoizedState!==a&&(t.flags|=8192),a&&0!==(1&t.mode)?0!==(1073741824&Ac)&&(Go(t),6&t.subtreeFlags&&(t.flags|=8192)):Go(t),null;case 24:case 25:return null}throw Error(r(156,t.tag))}function Ko(e,t){switch(tr(t),t.tag){case 1:return Ms(t.type)&&Ps(),65536&(e=t.flags)?(t.flags=-65537&e|128,t):null;case 3:return Qr(),Is(Rs),Is(Es),ni(),0!==(65536&(e=t.flags))&&0===(128&e)?(t.flags=-65537&e|128,t):null;case 5:return Jr(t),null;case 13:if(Is($r),null!==(e=t.memoizedState)&&null!==e.dehydrated){if(null===t.alternate)throw Error(r(340));pr()}return 65536&(e=t.flags)?(t.flags=-65537&e|128,t):null;case 19:return Is($r),null;case 4:return Qr(),null;case 10:return Tr(t.type._context),null;case 22:case 23:return ul(),null;default:return null}}Ao=function(e,t){for(var n=t.child;null!==n;){if(5===n.tag||6===n.tag)e.appendChild(n.stateNode);else if(4!==n.tag&&null!==n.child){n.child.return=n,n=n.child;continue}if(n===t)break;for(;null===n.sibling;){if(null===n.return||n.return===t)return;n=n.return}n.sibling.return=n.return,n=n.sibling}},Mo=function(e,t,n,a){var s=e.memoizedProps;if(s!==a){e=t.stateNode,Xr(Gr.current);var r,i=null;switch(n){case"input":s=Y(e,s),a=Y(e,a),i=[];break;case"select":s=L({},s,{value:void 0}),a=L({},a,{value:void 0}),i=[];break;case"textarea":s=ae(e,s),a=ae(e,a),i=[];break;default:"function"!==typeof s.onClick&&"function"===typeof a.onClick&&(e.onclick=$a)}for(u in be(n,a),n=null,s)if(!a.hasOwnProperty(u)&&s.hasOwnProperty(u)&&null!=s[u])if("style"===u){var c=s[u];for(r in c)c.hasOwnProperty(r)&&(n||(n={}),n[r]="")}else"dangerouslySetInnerHTML"!==u&&"children"!==u&&"suppressContentEditableWarning"!==u&&"suppressHydrationWarning"!==u&&"autoFocus"!==u&&(o.hasOwnProperty(u)?i||(i=[]):(i=i||[]).push(u,null));for(u in a){var l=a[u];if(c=null!=s?s[u]:void 0,a.hasOwnProperty(u)&&l!==c&&(null!=l||null!=c))if("style"===u)if(c){for(r in c)!c.hasOwnProperty(r)||l&&l.hasOwnProperty(r)||(n||(n={}),n[r]="");for(r in l)l.hasOwnProperty(r)&&c[r]!==l[r]&&(n||(n={}),n[r]=l[r])}else n||(i||(i=[]),i.push(u,n)),n=l;else"dangerouslySetInnerHTML"===u?(l=l?l.__html:void 0,c=c?c.__html:void 0,null!=l&&c!==l&&(i=i||[]).push(u,l)):"children"===u?"string"!==typeof l&&"number"!==typeof l||(i=i||[]).push(u,""+l):"suppressContentEditableWarning"!==u&&"suppressHydrationWarning"!==u&&(o.hasOwnProperty(u)?(null!=l&&"onScroll"===u&&Ba("scroll",e),i||c===l||(i=[])):(i=i||[]).push(u,l))}n&&(i=i||[]).push("style",n);var u=i;(t.updateQueue=u)&&(t.flags|=4)}},Po=function(e,t,n,a){n!==a&&(t.flags|=4)};var Xo=!1,Yo=!1,Qo="function"===typeof WeakSet?WeakSet:Set,Zo=null;function Jo(e,t){var n=e.ref;if(null!==n)if("function"===typeof n)try{n(null)}catch(a){Sl(e,t,a)}else n.current=null}function $o(e,t,n){try{n()}catch(a){Sl(e,t,a)}}var ec=!1;function tc(e,t,n){var a=t.updateQueue;if(null!==(a=null!==a?a.lastEffect:null)){var s=a=a.next;do{if((s.tag&e)===e){var r=s.destroy;s.destroy=void 0,void 0!==r&&$o(t,n,r)}s=s.next}while(s!==a)}}function nc(e,t){if(null!==(t=null!==(t=t.updateQueue)?t.lastEffect:null)){var n=t=t.next;do{if((n.tag&e)===e){var a=n.create;n.destroy=a()}n=n.next}while(n!==t)}}function ac(e){var t=e.ref;if(null!==t){var n=e.stateNode;e.tag,e=n,"function"===typeof t?t(e):t.current=e}}function sc(e){var t=e.alternate;null!==t&&(e.alternate=null,sc(t)),e.child=null,e.deletions=null,e.sibling=null,5===e.tag&&(null!==(t=e.stateNode)&&(delete t[ds],delete t[ps],delete t[ms],delete t[gs],delete t[ys])),e.stateNode=null,e.return=null,e.dependencies=null,e.memoizedProps=null,e.memoizedState=null,e.pendingProps=null,e.stateNode=null,e.updateQueue=null}function rc(e){return 5===e.tag||3===e.tag||4===e.tag}function ic(e){e:for(;;){for(;null===e.sibling;){if(null===e.return||rc(e.return))return null;e=e.return}for(e.sibling.return=e.return,e=e.sibling;5!==e.tag&&6!==e.tag&&18!==e.tag;){if(2&e.flags)continue e;if(null===e.child||4===e.tag)continue e;e.child.return=e,e=e.child}if(!(2&e.flags))return e.stateNode}}function oc(e,t,n){var a=e.tag;if(5===a||6===a)e=e.stateNode,t?8===n.nodeType?n.parentNode.insertBefore(e,t):n.insertBefore(e,t):(8===n.nodeType?(t=n.parentNode).insertBefore(e,n):(t=n).appendChild(e),null!==(n=n._reactRootContainer)&&void 0!==n||null!==t.onclick||(t.onclick=$a));else if(4!==a&&null!==(e=e.child))for(oc(e,t,n),e=e.sibling;null!==e;)oc(e,t,n),e=e.sibling}function cc(e,t,n){var a=e.tag;if(5===a||6===a)e=e.stateNode,t?n.insertBefore(e,t):n.appendChild(e);else if(4!==a&&null!==(e=e.child))for(cc(e,t,n),e=e.sibling;null!==e;)cc(e,t,n),e=e.sibling}var lc=null,uc=!1;function hc(e,t,n){for(n=n.child;null!==n;)dc(e,t,n),n=n.sibling}function dc(e,t,n){if(rt&&"function"===typeof rt.onCommitFiberUnmount)try{rt.onCommitFiberUnmount(st,n)}catch(o){}switch(n.tag){case 5:Yo||Jo(n,t);case 6:var a=lc,s=uc;lc=null,hc(e,t,n),uc=s,null!==(lc=a)&&(uc?(e=lc,n=n.stateNode,8===e.nodeType?e.parentNode.removeChild(n):e.removeChild(n)):lc.removeChild(n.stateNode));break;case 18:null!==lc&&(uc?(e=lc,n=n.stateNode,8===e.nodeType?cs(e.parentNode,n):1===e.nodeType&&cs(e,n),Vt(e)):cs(lc,n.stateNode));break;case 4:a=lc,s=uc,lc=n.stateNode.containerInfo,uc=!0,hc(e,t,n),lc=a,uc=s;break;case 0:case 11:case 14:case 15:if(!Yo&&(null!==(a=n.updateQueue)&&null!==(a=a.lastEffect))){s=a=a.next;do{var r=s,i=r.destroy;r=r.tag,void 0!==i&&(0!==(2&r)||0!==(4&r))&&$o(n,t,i),s=s.next}while(s!==a)}hc(e,t,n);break;case 1:if(!Yo&&(Jo(n,t),"function"===typeof(a=n.stateNode).componentWillUnmount))try{a.props=n.memoizedProps,a.state=n.memoizedState,a.componentWillUnmount()}catch(o){Sl(n,t,o)}hc(e,t,n);break;case 21:hc(e,t,n);break;case 22:1&n.mode?(Yo=(a=Yo)||null!==n.memoizedState,hc(e,t,n),Yo=a):hc(e,t,n);break;default:hc(e,t,n)}}function pc(e){var t=e.updateQueue;if(null!==t){e.updateQueue=null;var n=e.stateNode;null===n&&(n=e.stateNode=new Qo),t.forEach(function(t){var a=Tl.bind(null,e,t);n.has(t)||(n.add(t),t.then(a,a))})}}function fc(e,t){var n=t.deletions;if(null!==n)for(var a=0;a<n.length;a++){var s=n[a];try{var i=e,o=t,c=o;e:for(;null!==c;){switch(c.tag){case 5:lc=c.stateNode,uc=!1;break e;case 3:case 4:lc=c.stateNode.containerInfo,uc=!0;break e}c=c.return}if(null===lc)throw Error(r(160));dc(i,o,s),lc=null,uc=!1;var l=s.alternate;null!==l&&(l.return=null),s.return=null}catch(u){Sl(s,t,u)}}if(12854&t.subtreeFlags)for(t=t.child;null!==t;)mc(t,e),t=t.sibling}function mc(e,t){var n=e.alternate,a=e.flags;switch(e.tag){case 0:case 11:case 14:case 15:if(fc(t,e),gc(e),4&a){try{tc(3,e,e.return),nc(3,e)}catch(g){Sl(e,e.return,g)}try{tc(5,e,e.return)}catch(g){Sl(e,e.return,g)}}break;case 1:fc(t,e),gc(e),512&a&&null!==n&&Jo(n,n.return);break;case 5:if(fc(t,e),gc(e),512&a&&null!==n&&Jo(n,n.return),32&e.flags){var s=e.stateNode;try{de(s,"")}catch(g){Sl(e,e.return,g)}}if(4&a&&null!=(s=e.stateNode)){var i=e.memoizedProps,o=null!==n?n.memoizedProps:i,c=e.type,l=e.updateQueue;if(e.updateQueue=null,null!==l)try{"input"===c&&"radio"===i.type&&null!=i.name&&Z(s,i),xe(c,o);var u=xe(c,i);for(o=0;o<l.length;o+=2){var h=l[o],d=l[o+1];"style"===h?ge(s,d):"dangerouslySetInnerHTML"===h?he(s,d):"children"===h?de(s,d):x(s,h,d,u)}switch(c){case"input":J(s,i);break;case"textarea":re(s,i);break;case"select":var p=s._wrapperState.wasMultiple;s._wrapperState.wasMultiple=!!i.multiple;var f=i.value;null!=f?ne(s,!!i.multiple,f,!1):p!==!!i.multiple&&(null!=i.defaultValue?ne(s,!!i.multiple,i.defaultValue,!0):ne(s,!!i.multiple,i.multiple?[]:"",!1))}s[ps]=i}catch(g){Sl(e,e.return,g)}}break;case 6:if(fc(t,e),gc(e),4&a){if(null===e.stateNode)throw Error(r(162));s=e.stateNode,i=e.memoizedProps;try{s.nodeValue=i}catch(g){Sl(e,e.return,g)}}break;case 3:if(fc(t,e),gc(e),4&a&&null!==n&&n.memoizedState.isDehydrated)try{Vt(t.containerInfo)}catch(g){Sl(e,e.return,g)}break;case 4:default:fc(t,e),gc(e);break;case 13:fc(t,e),gc(e),8192&(s=e.child).flags&&(i=null!==s.memoizedState,s.stateNode.isHidden=i,!i||null!==s.alternate&&null!==s.alternate.memoizedState||(jc=Ze())),4&a&&pc(e);break;case 22:if(h=null!==n&&null!==n.memoizedState,1&e.mode?(Yo=(u=Yo)||h,fc(t,e),Yo=u):fc(t,e),gc(e),8192&a){if(u=null!==e.memoizedState,(e.stateNode.isHidden=u)&&!h&&0!==(1&e.mode))for(Zo=e,h=e.child;null!==h;){for(d=Zo=h;null!==Zo;){switch(f=(p=Zo).child,p.tag){case 0:case 11:case 14:case 15:tc(4,p,p.return);break;case 1:Jo(p,p.return);var m=p.stateNode;if("function"===typeof m.componentWillUnmount){a=p,n=p.return;try{t=a,m.props=t.memoizedProps,m.state=t.memoizedState,m.componentWillUnmount()}catch(g){Sl(a,n,g)}}break;case 5:Jo(p,p.return);break;case 22:if(null!==p.memoizedState){vc(d);continue}}null!==f?(f.return=p,Zo=f):vc(d)}h=h.sibling}e:for(h=null,d=e;;){if(5===d.tag){if(null===h){h=d;try{s=d.stateNode,u?"function"===typeof(i=s.style).setProperty?i.setProperty("display","none","important"):i.display="none":(c=d.stateNode,o=void 0!==(l=d.memoizedProps.style)&&null!==l&&l.hasOwnProperty("display")?l.display:null,c.style.display=me("display",o))}catch(g){Sl(e,e.return,g)}}}else if(6===d.tag){if(null===h)try{d.stateNode.nodeValue=u?"":d.memoizedProps}catch(g){Sl(e,e.return,g)}}else if((22!==d.tag&&23!==d.tag||null===d.memoizedState||d===e)&&null!==d.child){d.child.return=d,d=d.child;continue}if(d===e)break e;for(;null===d.sibling;){if(null===d.return||d.return===e)break e;h===d&&(h=null),d=d.return}h===d&&(h=null),d.sibling.return=d.return,d=d.sibling}}break;case 19:fc(t,e),gc(e),4&a&&pc(e);case 21:}}function gc(e){var t=e.flags;if(2&t){try{e:{for(var n=e.return;null!==n;){if(rc(n)){var a=n;break e}n=n.return}throw Error(r(160))}switch(a.tag){case 5:var s=a.stateNode;32&a.flags&&(de(s,""),a.flags&=-33),cc(e,ic(e),s);break;case 3:case 4:var i=a.stateNode.containerInfo;oc(e,ic(e),i);break;default:throw Error(r(161))}}catch(o){Sl(e,e.return,o)}e.flags&=-3}4096&t&&(e.flags&=-4097)}function yc(e,t,n){Zo=e,bc(e,t,n)}function bc(e,t,n){for(var a=0!==(1&e.mode);null!==Zo;){var s=Zo,r=s.child;if(22===s.tag&&a){var i=null!==s.memoizedState||Xo;if(!i){var o=s.alternate,c=null!==o&&null!==o.memoizedState||Yo;o=Xo;var l=Yo;if(Xo=i,(Yo=c)&&!l)for(Zo=s;null!==Zo;)c=(i=Zo).child,22===i.tag&&null!==i.memoizedState?wc(s):null!==c?(c.return=i,Zo=c):wc(s);for(;null!==r;)Zo=r,bc(r,t,n),r=r.sibling;Zo=s,Xo=o,Yo=l}xc(e)}else 0!==(8772&s.subtreeFlags)&&null!==r?(r.return=s,Zo=r):xc(e)}}function xc(e){for(;null!==Zo;){var t=Zo;if(0!==(8772&t.flags)){var n=t.alternate;try{if(0!==(8772&t.flags))switch(t.tag){case 0:case 11:case 15:Yo||nc(5,t);break;case 1:var a=t.stateNode;if(4&t.flags&&!Yo)if(null===n)a.componentDidMount();else{var s=t.elementType===t.type?n.memoizedProps:to(t.type,n.memoizedProps);a.componentDidUpdate(s,n.memoizedState,a.__reactInternalSnapshotBeforeUpdate)}var i=t.updateQueue;null!==i&&Ur(t,i,a);break;case 3:var o=t.updateQueue;if(null!==o){if(n=null,null!==t.child)switch(t.child.tag){case 5:case 1:n=t.child.stateNode}Ur(t,o,n)}break;case 5:var c=t.stateNode;if(null===n&&4&t.flags){n=c;var l=t.memoizedProps;switch(t.type){case"button":case"input":case"select":case"textarea":l.autoFocus&&n.focus();break;case"img":l.src&&(n.src=l.src)}}break;case 6:case 4:case 12:case 19:case 17:case 21:case 22:case 23:case 25:break;case 13:if(null===t.memoizedState){var u=t.alternate;if(null!==u){var h=u.memoizedState;if(null!==h){var d=h.dehydrated;null!==d&&Vt(d)}}}break;default:throw Error(r(163))}Yo||512&t.flags&&ac(t)}catch(p){Sl(t,t.return,p)}}if(t===e){Zo=null;break}if(null!==(n=t.sibling)){n.return=t.return,Zo=n;break}Zo=t.return}}function vc(e){for(;null!==Zo;){var t=Zo;if(t===e){Zo=null;break}var n=t.sibling;if(null!==n){n.return=t.return,Zo=n;break}Zo=t.return}}function wc(e){for(;null!==Zo;){var t=Zo;try{switch(t.tag){case 0:case 11:case 15:var n=t.return;try{nc(4,t)}catch(c){Sl(t,n,c)}break;case 1:var a=t.stateNode;if("function"===typeof a.componentDidMount){var s=t.return;try{a.componentDidMount()}catch(c){Sl(t,s,c)}}var r=t.return;try{ac(t)}catch(c){Sl(t,r,c)}break;case 5:var i=t.return;try{ac(t)}catch(c){Sl(t,i,c)}}}catch(c){Sl(t,t.return,c)}if(t===e){Zo=null;break}var o=t.sibling;if(null!==o){o.return=t.return,Zo=o;break}Zo=t.return}}var kc,Sc=Math.ceil,Cc=v.ReactCurrentDispatcher,Ic=v.ReactCurrentOwner,Nc=v.ReactCurrentBatchConfig,Tc=0,Ec=null,Rc=null,_c=0,Ac=0,Mc=Cs(0),Pc=0,Dc=null,Oc=0,Fc=0,Lc=0,zc=null,Bc=null,jc=0,Wc=1/0,Vc=null,Uc=!1,Hc=null,Gc=null,qc=!1,Kc=null,Xc=0,Yc=0,Qc=null,Zc=-1,Jc=0;function $c(){return 0!==(6&Tc)?Ze():-1!==Zc?Zc:Zc=Ze()}function el(e){return 0===(1&e.mode)?1:0!==(2&Tc)&&0!==_c?_c&-_c:null!==mr.transition?(0===Jc&&(Jc=mt()),Jc):0!==(e=xt)?e:e=void 0===(e=window.event)?16:Qt(e.type)}function tl(e,t,n,a){if(50<Yc)throw Yc=0,Qc=null,Error(r(185));yt(e,n,a),0!==(2&Tc)&&e===Ec||(e===Ec&&(0===(2&Tc)&&(Fc|=n),4===Pc&&il(e,_c)),nl(e,a),1===n&&0===Tc&&0===(1&t.mode)&&(Wc=Ze()+500,Bs&&Vs()))}function nl(e,t){var n=e.callbackNode;!function(e,t){for(var n=e.suspendedLanes,a=e.pingedLanes,s=e.expirationTimes,r=e.pendingLanes;0<r;){var i=31-it(r),o=1<<i,c=s[i];-1===c?0!==(o&n)&&0===(o&a)||(s[i]=pt(o,t)):c<=t&&(e.expiredLanes|=o),r&=~o}}(e,t);var a=dt(e,e===Ec?_c:0);if(0===a)null!==n&&Xe(n),e.callbackNode=null,e.callbackPriority=0;else if(t=a&-a,e.callbackPriority!==t){if(null!=n&&Xe(n),1===t)0===e.tag?function(e){Bs=!0,Ws(e)}(ol.bind(null,e)):Ws(ol.bind(null,e)),is(function(){0===(6&Tc)&&Vs()}),n=null;else{switch(vt(a)){case 1:n=$e;break;case 4:n=et;break;case 16:default:n=tt;break;case 536870912:n=at}n=El(n,al.bind(null,e))}e.callbackPriority=t,e.callbackNode=n}}function al(e,t){if(Zc=-1,Jc=0,0!==(6&Tc))throw Error(r(327));var n=e.callbackNode;if(wl()&&e.callbackNode!==n)return null;var a=dt(e,e===Ec?_c:0);if(0===a)return null;if(0!==(30&a)||0!==(a&e.expiredLanes)||t)t=ml(e,a);else{t=a;var s=Tc;Tc|=2;var i=pl();for(Ec===e&&_c===t||(Vc=null,Wc=Ze()+500,hl(e,t));;)try{yl();break}catch(c){dl(e,c)}Nr(),Cc.current=i,Tc=s,null!==Rc?t=0:(Ec=null,_c=0,t=Pc)}if(0!==t){if(2===t&&(0!==(s=ft(e))&&(a=s,t=sl(e,s))),1===t)throw n=Dc,hl(e,0),il(e,a),nl(e,Ze()),n;if(6===t)il(e,a);else{if(s=e.current.alternate,0===(30&a)&&!function(e){for(var t=e;;){if(16384&t.flags){var n=t.updateQueue;if(null!==n&&null!==(n=n.stores))for(var a=0;a<n.length;a++){var s=n[a],r=s.getSnapshot;s=s.value;try{if(!oa(r(),s))return!1}catch(o){return!1}}}if(n=t.child,16384&t.subtreeFlags&&null!==n)n.return=t,t=n;else{if(t===e)break;for(;null===t.sibling;){if(null===t.return||t.return===e)return!0;t=t.return}t.sibling.return=t.return,t=t.sibling}}return!0}(s)&&(2===(t=ml(e,a))&&(0!==(i=ft(e))&&(a=i,t=sl(e,i))),1===t))throw n=Dc,hl(e,0),il(e,a),nl(e,Ze()),n;switch(e.finishedWork=s,e.finishedLanes=a,t){case 0:case 1:throw Error(r(345));case 2:case 5:vl(e,Bc,Vc);break;case 3:if(il(e,a),(130023424&a)===a&&10<(t=jc+500-Ze())){if(0!==dt(e,0))break;if(((s=e.suspendedLanes)&a)!==a){$c(),e.pingedLanes|=e.suspendedLanes&s;break}e.timeoutHandle=as(vl.bind(null,e,Bc,Vc),t);break}vl(e,Bc,Vc);break;case 4:if(il(e,a),(4194240&a)===a)break;for(t=e.eventTimes,s=-1;0<a;){var o=31-it(a);i=1<<o,(o=t[o])>s&&(s=o),a&=~i}if(a=s,10<(a=(120>(a=Ze()-a)?120:480>a?480:1080>a?1080:1920>a?1920:3e3>a?3e3:4320>a?4320:1960*Sc(a/1960))-a)){e.timeoutHandle=as(vl.bind(null,e,Bc,Vc),a);break}vl(e,Bc,Vc);break;default:throw Error(r(329))}}}return nl(e,Ze()),e.callbackNode===n?al.bind(null,e):null}function sl(e,t){var n=zc;return e.current.memoizedState.isDehydrated&&(hl(e,t).flags|=256),2!==(e=ml(e,t))&&(t=Bc,Bc=n,null!==t&&rl(t)),e}function rl(e){null===Bc?Bc=e:Bc.push.apply(Bc,e)}function il(e,t){for(t&=~Lc,t&=~Fc,e.suspendedLanes|=t,e.pingedLanes&=~t,e=e.expirationTimes;0<t;){var n=31-it(t),a=1<<n;e[n]=-1,t&=~a}}function ol(e){if(0!==(6&Tc))throw Error(r(327));wl();var t=dt(e,0);if(0===(1&t))return nl(e,Ze()),null;var n=ml(e,t);if(0!==e.tag&&2===n){var a=ft(e);0!==a&&(t=a,n=sl(e,a))}if(1===n)throw n=Dc,hl(e,0),il(e,t),nl(e,Ze()),n;if(6===n)throw Error(r(345));return e.finishedWork=e.current.alternate,e.finishedLanes=t,vl(e,Bc,Vc),nl(e,Ze()),null}function cl(e,t){var n=Tc;Tc|=1;try{return e(t)}finally{0===(Tc=n)&&(Wc=Ze()+500,Bs&&Vs())}}function ll(e){null!==Kc&&0===Kc.tag&&0===(6&Tc)&&wl();var t=Tc;Tc|=1;var n=Nc.transition,a=xt;try{if(Nc.transition=null,xt=1,e)return e()}finally{xt=a,Nc.transition=n,0===(6&(Tc=t))&&Vs()}}function ul(){Ac=Mc.current,Is(Mc)}function hl(e,t){e.finishedWork=null,e.finishedLanes=0;var n=e.timeoutHandle;if(-1!==n&&(e.timeoutHandle=-1,ss(n)),null!==Rc)for(n=Rc.return;null!==n;){var a=n;switch(tr(a),a.tag){case 1:null!==(a=a.type.childContextTypes)&&void 0!==a&&Ps();break;case 3:Qr(),Is(Rs),Is(Es),ni();break;case 5:Jr(a);break;case 4:Qr();break;case 13:case 19:Is($r);break;case 10:Tr(a.type._context);break;case 22:case 23:ul()}n=n.return}if(Ec=e,Rc=e=Ml(e.current,null),_c=Ac=t,Pc=0,Dc=null,Lc=Fc=Oc=0,Bc=zc=null,null!==Ar){for(t=0;t<Ar.length;t++)if(null!==(a=(n=Ar[t]).interleaved)){n.interleaved=null;var s=a.next,r=n.pending;if(null!==r){var i=r.next;r.next=s,a.next=i}n.pending=a}Ar=null}return e}function dl(e,t){for(;;){var n=Rc;try{if(Nr(),ai.current=Zi,li){for(var a=ii.memoizedState;null!==a;){var s=a.queue;null!==s&&(s.pending=null),a=a.next}li=!1}if(ri=0,ci=oi=ii=null,ui=!1,hi=0,Ic.current=null,null===n||null===n.return){Pc=1,Dc=t,Rc=null;break}e:{var i=e,o=n.return,c=n,l=t;if(t=_c,c.flags|=32768,null!==l&&"object"===typeof l&&"function"===typeof l.then){var u=l,h=c,d=h.tag;if(0===(1&h.mode)&&(0===d||11===d||15===d)){var p=h.alternate;p?(h.updateQueue=p.updateQueue,h.memoizedState=p.memoizedState,h.lanes=p.lanes):(h.updateQueue=null,h.memoizedState=null)}var f=go(o);if(null!==f){f.flags&=-257,yo(f,o,c,0,t),1&f.mode&&mo(i,u,t),l=u;var m=(t=f).updateQueue;if(null===m){var g=new Set;g.add(l),t.updateQueue=g}else m.add(l);break e}if(0===(1&t)){mo(i,u,t),fl();break e}l=Error(r(426))}else if(sr&&1&c.mode){var y=go(o);if(null!==y){0===(65536&y.flags)&&(y.flags|=256),yo(y,o,c,0,t),fr(co(l,c));break e}}i=l=co(l,c),4!==Pc&&(Pc=2),null===zc?zc=[i]:zc.push(i),i=o;do{switch(i.tag){case 3:i.flags|=65536,t&=-t,i.lanes|=t,Wr(i,po(0,l,t));break e;case 1:c=l;var b=i.type,x=i.stateNode;if(0===(128&i.flags)&&("function"===typeof b.getDerivedStateFromError||null!==x&&"function"===typeof x.componentDidCatch&&(null===Gc||!Gc.has(x)))){i.flags|=65536,t&=-t,i.lanes|=t,Wr(i,fo(i,c,t));break e}}i=i.return}while(null!==i)}xl(n)}catch(v){t=v,Rc===n&&null!==n&&(Rc=n=n.return);continue}break}}function pl(){var e=Cc.current;return Cc.current=Zi,null===e?Zi:e}function fl(){0!==Pc&&3!==Pc&&2!==Pc||(Pc=4),null===Ec||0===(268435455&Oc)&&0===(268435455&Fc)||il(Ec,_c)}function ml(e,t){var n=Tc;Tc|=2;var a=pl();for(Ec===e&&_c===t||(Vc=null,hl(e,t));;)try{gl();break}catch(s){dl(e,s)}if(Nr(),Tc=n,Cc.current=a,null!==Rc)throw Error(r(261));return Ec=null,_c=0,Pc}function gl(){for(;null!==Rc;)bl(Rc)}function yl(){for(;null!==Rc&&!Ye();)bl(Rc)}function bl(e){var t=kc(e.alternate,e,Ac);e.memoizedProps=e.pendingProps,null===t?xl(e):Rc=t,Ic.current=null}function xl(e){var t=e;do{var n=t.alternate;if(e=t.return,0===(32768&t.flags)){if(null!==(n=qo(n,t,Ac)))return void(Rc=n)}else{if(null!==(n=Ko(n,t)))return n.flags&=32767,void(Rc=n);if(null===e)return Pc=6,void(Rc=null);e.flags|=32768,e.subtreeFlags=0,e.deletions=null}if(null!==(t=t.sibling))return void(Rc=t);Rc=t=e}while(null!==t);0===Pc&&(Pc=5)}function vl(e,t,n){var a=xt,s=Nc.transition;try{Nc.transition=null,xt=1,function(e,t,n,a){do{wl()}while(null!==Kc);if(0!==(6&Tc))throw Error(r(327));n=e.finishedWork;var s=e.finishedLanes;if(null===n)return null;if(e.finishedWork=null,e.finishedLanes=0,n===e.current)throw Error(r(177));e.callbackNode=null,e.callbackPriority=0;var i=n.lanes|n.childLanes;if(function(e,t){var n=e.pendingLanes&~t;e.pendingLanes=t,e.suspendedLanes=0,e.pingedLanes=0,e.expiredLanes&=t,e.mutableReadLanes&=t,e.entangledLanes&=t,t=e.entanglements;var a=e.eventTimes;for(e=e.expirationTimes;0<n;){var s=31-it(n),r=1<<s;t[s]=0,a[s]=-1,e[s]=-1,n&=~r}}(e,i),e===Ec&&(Rc=Ec=null,_c=0),0===(2064&n.subtreeFlags)&&0===(2064&n.flags)||qc||(qc=!0,El(tt,function(){return wl(),null})),i=0!==(15990&n.flags),0!==(15990&n.subtreeFlags)||i){i=Nc.transition,Nc.transition=null;var o=xt;xt=1;var c=Tc;Tc|=4,Ic.current=null,function(e,t){if(es=Ht,pa(e=da())){if("selectionStart"in e)var n={start:e.selectionStart,end:e.selectionEnd};else e:{var a=(n=(n=e.ownerDocument)&&n.defaultView||window).getSelection&&n.getSelection();if(a&&0!==a.rangeCount){n=a.anchorNode;var s=a.anchorOffset,i=a.focusNode;a=a.focusOffset;try{n.nodeType,i.nodeType}catch(w){n=null;break e}var o=0,c=-1,l=-1,u=0,h=0,d=e,p=null;t:for(;;){for(var f;d!==n||0!==s&&3!==d.nodeType||(c=o+s),d!==i||0!==a&&3!==d.nodeType||(l=o+a),3===d.nodeType&&(o+=d.nodeValue.length),null!==(f=d.firstChild);)p=d,d=f;for(;;){if(d===e)break t;if(p===n&&++u===s&&(c=o),p===i&&++h===a&&(l=o),null!==(f=d.nextSibling))break;p=(d=p).parentNode}d=f}n=-1===c||-1===l?null:{start:c,end:l}}else n=null}n=n||{start:0,end:0}}else n=null;for(ts={focusedElem:e,selectionRange:n},Ht=!1,Zo=t;null!==Zo;)if(e=(t=Zo).child,0!==(1028&t.subtreeFlags)&&null!==e)e.return=t,Zo=e;else for(;null!==Zo;){t=Zo;try{var m=t.alternate;if(0!==(1024&t.flags))switch(t.tag){case 0:case 11:case 15:case 5:case 6:case 4:case 17:break;case 1:if(null!==m){var g=m.memoizedProps,y=m.memoizedState,b=t.stateNode,x=b.getSnapshotBeforeUpdate(t.elementType===t.type?g:to(t.type,g),y);b.__reactInternalSnapshotBeforeUpdate=x}break;case 3:var v=t.stateNode.containerInfo;1===v.nodeType?v.textContent="":9===v.nodeType&&v.documentElement&&v.removeChild(v.documentElement);break;default:throw Error(r(163))}}catch(w){Sl(t,t.return,w)}if(null!==(e=t.sibling)){e.return=t.return,Zo=e;break}Zo=t.return}m=ec,ec=!1}(e,n),mc(n,e),fa(ts),Ht=!!es,ts=es=null,e.current=n,yc(n,e,s),Qe(),Tc=c,xt=o,Nc.transition=i}else e.current=n;if(qc&&(qc=!1,Kc=e,Xc=s),i=e.pendingLanes,0===i&&(Gc=null),function(e){if(rt&&"function"===typeof rt.onCommitFiberRoot)try{rt.onCommitFiberRoot(st,e,void 0,128===(128&e.current.flags))}catch(t){}}(n.stateNode),nl(e,Ze()),null!==t)for(a=e.onRecoverableError,n=0;n<t.length;n++)s=t[n],a(s.value,{componentStack:s.stack,digest:s.digest});if(Uc)throw Uc=!1,e=Hc,Hc=null,e;0!==(1&Xc)&&0!==e.tag&&wl(),i=e.pendingLanes,0!==(1&i)?e===Qc?Yc++:(Yc=0,Qc=e):Yc=0,Vs()}(e,t,n,a)}finally{Nc.transition=s,xt=a}return null}function wl(){if(null!==Kc){var e=vt(Xc),t=Nc.transition,n=xt;try{if(Nc.transition=null,xt=16>e?16:e,null===Kc)var a=!1;else{if(e=Kc,Kc=null,Xc=0,0!==(6&Tc))throw Error(r(331));var s=Tc;for(Tc|=4,Zo=e.current;null!==Zo;){var i=Zo,o=i.child;if(0!==(16&Zo.flags)){var c=i.deletions;if(null!==c){for(var l=0;l<c.length;l++){var u=c[l];for(Zo=u;null!==Zo;){var h=Zo;switch(h.tag){case 0:case 11:case 15:tc(8,h,i)}var d=h.child;if(null!==d)d.return=h,Zo=d;else for(;null!==Zo;){var p=(h=Zo).sibling,f=h.return;if(sc(h),h===u){Zo=null;break}if(null!==p){p.return=f,Zo=p;break}Zo=f}}}var m=i.alternate;if(null!==m){var g=m.child;if(null!==g){m.child=null;do{var y=g.sibling;g.sibling=null,g=y}while(null!==g)}}Zo=i}}if(0!==(2064&i.subtreeFlags)&&null!==o)o.return=i,Zo=o;else e:for(;null!==Zo;){if(0!==(2048&(i=Zo).flags))switch(i.tag){case 0:case 11:case 15:tc(9,i,i.return)}var b=i.sibling;if(null!==b){b.return=i.return,Zo=b;break e}Zo=i.return}}var x=e.current;for(Zo=x;null!==Zo;){var v=(o=Zo).child;if(0!==(2064&o.subtreeFlags)&&null!==v)v.return=o,Zo=v;else e:for(o=x;null!==Zo;){if(0!==(2048&(c=Zo).flags))try{switch(c.tag){case 0:case 11:case 15:nc(9,c)}}catch(k){Sl(c,c.return,k)}if(c===o){Zo=null;break e}var w=c.sibling;if(null!==w){w.return=c.return,Zo=w;break e}Zo=c.return}}if(Tc=s,Vs(),rt&&"function"===typeof rt.onPostCommitFiberRoot)try{rt.onPostCommitFiberRoot(st,e)}catch(k){}a=!0}return a}finally{xt=n,Nc.transition=t}}return!1}function kl(e,t,n){e=Br(e,t=po(0,t=co(n,t),1),1),t=$c(),null!==e&&(yt(e,1,t),nl(e,t))}function Sl(e,t,n){if(3===e.tag)kl(e,e,n);else for(;null!==t;){if(3===t.tag){kl(t,e,n);break}if(1===t.tag){var a=t.stateNode;if("function"===typeof t.type.getDerivedStateFromError||"function"===typeof a.componentDidCatch&&(null===Gc||!Gc.has(a))){t=Br(t,e=fo(t,e=co(n,e),1),1),e=$c(),null!==t&&(yt(t,1,e),nl(t,e));break}}t=t.return}}function Cl(e,t,n){var a=e.pingCache;null!==a&&a.delete(t),t=$c(),e.pingedLanes|=e.suspendedLanes&n,Ec===e&&(_c&n)===n&&(4===Pc||3===Pc&&(130023424&_c)===_c&&500>Ze()-jc?hl(e,0):Lc|=n),nl(e,t)}function Il(e,t){0===t&&(0===(1&e.mode)?t=1:(t=ut,0===(130023424&(ut<<=1))&&(ut=4194304)));var n=$c();null!==(e=Dr(e,t))&&(yt(e,t,n),nl(e,n))}function Nl(e){var t=e.memoizedState,n=0;null!==t&&(n=t.retryLane),Il(e,n)}function Tl(e,t){var n=0;switch(e.tag){case 13:var a=e.stateNode,s=e.memoizedState;null!==s&&(n=s.retryLane);break;case 19:a=e.stateNode;break;default:throw Error(r(314))}null!==a&&a.delete(t),Il(e,n)}function El(e,t){return Ke(e,t)}function Rl(e,t,n,a){this.tag=e,this.key=n,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=t,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=a,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function _l(e,t,n,a){return new Rl(e,t,n,a)}function Al(e){return!(!(e=e.prototype)||!e.isReactComponent)}function Ml(e,t){var n=e.alternate;return null===n?((n=_l(e.tag,t,e.key,e.mode)).elementType=e.elementType,n.type=e.type,n.stateNode=e.stateNode,n.alternate=e,e.alternate=n):(n.pendingProps=t,n.type=e.type,n.flags=0,n.subtreeFlags=0,n.deletions=null),n.flags=14680064&e.flags,n.childLanes=e.childLanes,n.lanes=e.lanes,n.child=e.child,n.memoizedProps=e.memoizedProps,n.memoizedState=e.memoizedState,n.updateQueue=e.updateQueue,t=e.dependencies,n.dependencies=null===t?null:{lanes:t.lanes,firstContext:t.firstContext},n.sibling=e.sibling,n.index=e.index,n.ref=e.ref,n}function Pl(e,t,n,a,s,i){var o=2;if(a=e,"function"===typeof e)Al(e)&&(o=1);else if("string"===typeof e)o=5;else e:switch(e){case S:return Dl(n.children,s,i,t);case C:o=8,s|=8;break;case I:return(e=_l(12,n,t,2|s)).elementType=I,e.lanes=i,e;case R:return(e=_l(13,n,t,s)).elementType=R,e.lanes=i,e;case _:return(e=_l(19,n,t,s)).elementType=_,e.lanes=i,e;case P:return Ol(n,s,i,t);default:if("object"===typeof e&&null!==e)switch(e.$$typeof){case N:o=10;break e;case T:o=9;break e;case E:o=11;break e;case A:o=14;break e;case M:o=16,a=null;break e}throw Error(r(130,null==e?e:typeof e,""))}return(t=_l(o,n,t,s)).elementType=e,t.type=a,t.lanes=i,t}function Dl(e,t,n,a){return(e=_l(7,e,a,t)).lanes=n,e}function Ol(e,t,n,a){return(e=_l(22,e,a,t)).elementType=P,e.lanes=n,e.stateNode={isHidden:!1},e}function Fl(e,t,n){return(e=_l(6,e,null,t)).lanes=n,e}function Ll(e,t,n){return(t=_l(4,null!==e.children?e.children:[],e.key,t)).lanes=n,t.stateNode={containerInfo:e.containerInfo,pendingChildren:null,implementation:e.implementation},t}function zl(e,t,n,a,s){this.tag=t,this.containerInfo=e,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=gt(0),this.expirationTimes=gt(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=gt(0),this.identifierPrefix=a,this.onRecoverableError=s,this.mutableSourceEagerHydrationData=null}function Bl(e,t,n,a,s,r,i,o,c){return e=new zl(e,t,n,o,c),1===t?(t=1,!0===r&&(t|=8)):t=0,r=_l(3,null,null,t),e.current=r,r.stateNode=e,r.memoizedState={element:a,isDehydrated:n,cache:null,transitions:null,pendingSuspenseBoundaries:null},Fr(r),e}function jl(e){if(!e)return Ts;e:{if(Ve(e=e._reactInternals)!==e||1!==e.tag)throw Error(r(170));var t=e;do{switch(t.tag){case 3:t=t.stateNode.context;break e;case 1:if(Ms(t.type)){t=t.stateNode.__reactInternalMemoizedMergedChildContext;break e}}t=t.return}while(null!==t);throw Error(r(171))}if(1===e.tag){var n=e.type;if(Ms(n))return Os(e,n,t)}return t}function Wl(e,t,n,a,s,r,i,o,c){return(e=Bl(n,a,!0,e,0,r,0,o,c)).context=jl(null),n=e.current,(r=zr(a=$c(),s=el(n))).callback=void 0!==t&&null!==t?t:null,Br(n,r,s),e.current.lanes=s,yt(e,s,a),nl(e,a),e}function Vl(e,t,n,a){var s=t.current,r=$c(),i=el(s);return n=jl(n),null===t.context?t.context=n:t.pendingContext=n,(t=zr(r,i)).payload={element:e},null!==(a=void 0===a?null:a)&&(t.callback=a),null!==(e=Br(s,t,i))&&(tl(e,s,i,r),jr(e,s,i)),i}function Ul(e){return(e=e.current).child?(e.child.tag,e.child.stateNode):null}function Hl(e,t){if(null!==(e=e.memoizedState)&&null!==e.dehydrated){var n=e.retryLane;e.retryLane=0!==n&&n<t?n:t}}function Gl(e,t){Hl(e,t),(e=e.alternate)&&Hl(e,t)}kc=function(e,t,n){if(null!==e)if(e.memoizedProps!==t.pendingProps||Rs.current)xo=!0;else{if(0===(e.lanes&n)&&0===(128&t.flags))return xo=!1,function(e,t,n){switch(t.tag){case 3:Ro(t),pr();break;case 5:Zr(t);break;case 1:Ms(t.type)&&Fs(t);break;case 4:Yr(t,t.stateNode.containerInfo);break;case 10:var a=t.type._context,s=t.memoizedProps.value;Ns(kr,a._currentValue),a._currentValue=s;break;case 13:if(null!==(a=t.memoizedState))return null!==a.dehydrated?(Ns($r,1&$r.current),t.flags|=128,null):0!==(n&t.child.childLanes)?Fo(e,t,n):(Ns($r,1&$r.current),null!==(e=Uo(e,t,n))?e.sibling:null);Ns($r,1&$r.current);break;case 19:if(a=0!==(n&t.childLanes),0!==(128&e.flags)){if(a)return Wo(e,t,n);t.flags|=128}if(null!==(s=t.memoizedState)&&(s.rendering=null,s.tail=null,s.lastEffect=null),Ns($r,$r.current),a)break;return null;case 22:case 23:return t.lanes=0,Co(e,t,n)}return Uo(e,t,n)}(e,t,n);xo=0!==(131072&e.flags)}else xo=!1,sr&&0!==(1048576&t.flags)&&$s(t,qs,t.index);switch(t.lanes=0,t.tag){case 2:var a=t.type;Vo(e,t),e=t.pendingProps;var s=As(t,Es.current);Rr(t,n),s=mi(null,t,a,e,s,n);var i=gi();return t.flags|=1,"object"===typeof s&&null!==s&&"function"===typeof s.render&&void 0===s.$$typeof?(t.tag=1,t.memoizedState=null,t.updateQueue=null,Ms(a)?(i=!0,Fs(t)):i=!1,t.memoizedState=null!==s.state&&void 0!==s.state?s.state:null,Fr(t),s.updater=ao,t.stateNode=s,s._reactInternals=t,oo(t,a,e,n),t=Eo(null,t,a,!0,i,n)):(t.tag=0,sr&&i&&er(t),vo(null,t,s,n),t=t.child),t;case 16:a=t.elementType;e:{switch(Vo(e,t),e=t.pendingProps,a=(s=a._init)(a._payload),t.type=a,s=t.tag=function(e){if("function"===typeof e)return Al(e)?1:0;if(void 0!==e&&null!==e){if((e=e.$$typeof)===E)return 11;if(e===A)return 14}return 2}(a),e=to(a,e),s){case 0:t=No(null,t,a,e,n);break e;case 1:t=To(null,t,a,e,n);break e;case 11:t=wo(null,t,a,e,n);break e;case 14:t=ko(null,t,a,to(a.type,e),n);break e}throw Error(r(306,a,""))}return t;case 0:return a=t.type,s=t.pendingProps,No(e,t,a,s=t.elementType===a?s:to(a,s),n);case 1:return a=t.type,s=t.pendingProps,To(e,t,a,s=t.elementType===a?s:to(a,s),n);case 3:e:{if(Ro(t),null===e)throw Error(r(387));a=t.pendingProps,s=(i=t.memoizedState).element,Lr(e,t),Vr(t,a,null,n);var o=t.memoizedState;if(a=o.element,i.isDehydrated){if(i={element:a,isDehydrated:!1,cache:o.cache,pendingSuspenseBoundaries:o.pendingSuspenseBoundaries,transitions:o.transitions},t.updateQueue.baseState=i,t.memoizedState=i,256&t.flags){t=_o(e,t,a,n,s=co(Error(r(423)),t));break e}if(a!==s){t=_o(e,t,a,n,s=co(Error(r(424)),t));break e}for(ar=ls(t.stateNode.containerInfo.firstChild),nr=t,sr=!0,rr=null,n=wr(t,null,a,n),t.child=n;n;)n.flags=-3&n.flags|4096,n=n.sibling}else{if(pr(),a===s){t=Uo(e,t,n);break e}vo(e,t,a,n)}t=t.child}return t;case 5:return Zr(t),null===e&&lr(t),a=t.type,s=t.pendingProps,i=null!==e?e.memoizedProps:null,o=s.children,ns(a,s)?o=null:null!==i&&ns(a,i)&&(t.flags|=32),Io(e,t),vo(e,t,o,n),t.child;case 6:return null===e&&lr(t),null;case 13:return Fo(e,t,n);case 4:return Yr(t,t.stateNode.containerInfo),a=t.pendingProps,null===e?t.child=vr(t,null,a,n):vo(e,t,a,n),t.child;case 11:return a=t.type,s=t.pendingProps,wo(e,t,a,s=t.elementType===a?s:to(a,s),n);case 7:return vo(e,t,t.pendingProps,n),t.child;case 8:case 12:return vo(e,t,t.pendingProps.children,n),t.child;case 10:e:{if(a=t.type._context,s=t.pendingProps,i=t.memoizedProps,o=s.value,Ns(kr,a._currentValue),a._currentValue=o,null!==i)if(oa(i.value,o)){if(i.children===s.children&&!Rs.current){t=Uo(e,t,n);break e}}else for(null!==(i=t.child)&&(i.return=t);null!==i;){var c=i.dependencies;if(null!==c){o=i.child;for(var l=c.firstContext;null!==l;){if(l.context===a){if(1===i.tag){(l=zr(-1,n&-n)).tag=2;var u=i.updateQueue;if(null!==u){var h=(u=u.shared).pending;null===h?l.next=l:(l.next=h.next,h.next=l),u.pending=l}}i.lanes|=n,null!==(l=i.alternate)&&(l.lanes|=n),Er(i.return,n,t),c.lanes|=n;break}l=l.next}}else if(10===i.tag)o=i.type===t.type?null:i.child;else if(18===i.tag){if(null===(o=i.return))throw Error(r(341));o.lanes|=n,null!==(c=o.alternate)&&(c.lanes|=n),Er(o,n,t),o=i.sibling}else o=i.child;if(null!==o)o.return=i;else for(o=i;null!==o;){if(o===t){o=null;break}if(null!==(i=o.sibling)){i.return=o.return,o=i;break}o=o.return}i=o}vo(e,t,s.children,n),t=t.child}return t;case 9:return s=t.type,a=t.pendingProps.children,Rr(t,n),a=a(s=_r(s)),t.flags|=1,vo(e,t,a,n),t.child;case 14:return s=to(a=t.type,t.pendingProps),ko(e,t,a,s=to(a.type,s),n);case 15:return So(e,t,t.type,t.pendingProps,n);case 17:return a=t.type,s=t.pendingProps,s=t.elementType===a?s:to(a,s),Vo(e,t),t.tag=1,Ms(a)?(e=!0,Fs(t)):e=!1,Rr(t,n),ro(t,a,s),oo(t,a,s,n),Eo(null,t,a,!0,e,n);case 19:return Wo(e,t,n);case 22:return Co(e,t,n)}throw Error(r(156,t.tag))};var ql="function"===typeof reportError?reportError:function(e){console.error(e)};function Kl(e){this._internalRoot=e}function Xl(e){this._internalRoot=e}function Yl(e){return!(!e||1!==e.nodeType&&9!==e.nodeType&&11!==e.nodeType)}function Ql(e){return!(!e||1!==e.nodeType&&9!==e.nodeType&&11!==e.nodeType&&(8!==e.nodeType||" react-mount-point-unstable "!==e.nodeValue))}function Zl(){}function Jl(e,t,n,a,s){var r=n._reactRootContainer;if(r){var i=r;if("function"===typeof s){var o=s;s=function(){var e=Ul(i);o.call(e)}}Vl(t,i,e,s)}else i=function(e,t,n,a,s){if(s){if("function"===typeof a){var r=a;a=function(){var e=Ul(i);r.call(e)}}var i=Wl(t,a,e,0,null,!1,0,"",Zl);return e._reactRootContainer=i,e[fs]=i.current,Va(8===e.nodeType?e.parentNode:e),ll(),i}for(;s=e.lastChild;)e.removeChild(s);if("function"===typeof a){var o=a;a=function(){var e=Ul(c);o.call(e)}}var c=Bl(e,0,!1,null,0,!1,0,"",Zl);return e._reactRootContainer=c,e[fs]=c.current,Va(8===e.nodeType?e.parentNode:e),ll(function(){Vl(t,c,n,a)}),c}(n,t,e,s,a);return Ul(i)}Xl.prototype.render=Kl.prototype.render=function(e){var t=this._internalRoot;if(null===t)throw Error(r(409));Vl(e,t,null,null)},Xl.prototype.unmount=Kl.prototype.unmount=function(){var e=this._internalRoot;if(null!==e){this._internalRoot=null;var t=e.containerInfo;ll(function(){Vl(null,e,null,null)}),t[fs]=null}},Xl.prototype.unstable_scheduleHydration=function(e){if(e){var t=Ct();e={blockedOn:null,target:e,priority:t};for(var n=0;n<Pt.length&&0!==t&&t<Pt[n].priority;n++);Pt.splice(n,0,e),0===n&&Lt(e)}},wt=function(e){switch(e.tag){case 3:var t=e.stateNode;if(t.current.memoizedState.isDehydrated){var n=ht(t.pendingLanes);0!==n&&(bt(t,1|n),nl(t,Ze()),0===(6&Tc)&&(Wc=Ze()+500,Vs()))}break;case 13:ll(function(){var t=Dr(e,1);if(null!==t){var n=$c();tl(t,e,1,n)}}),Gl(e,1)}},kt=function(e){if(13===e.tag){var t=Dr(e,134217728);if(null!==t)tl(t,e,134217728,$c());Gl(e,134217728)}},St=function(e){if(13===e.tag){var t=el(e),n=Dr(e,t);if(null!==n)tl(n,e,t,$c());Gl(e,t)}},Ct=function(){return xt},It=function(e,t){var n=xt;try{return xt=e,t()}finally{xt=n}},ke=function(e,t,n){switch(t){case"input":if(J(e,n),t=n.name,"radio"===n.type&&null!=t){for(n=e;n.parentNode;)n=n.parentNode;for(n=n.querySelectorAll("input[name="+JSON.stringify(""+t)+'][type="radio"]'),t=0;t<n.length;t++){var a=n[t];if(a!==e&&a.form===e.form){var s=ws(a);if(!s)throw Error(r(90));K(a),J(a,s)}}}break;case"textarea":re(e,n);break;case"select":null!=(t=n.value)&&ne(e,!!n.multiple,t,!1)}},Ee=cl,Re=ll;var $l={usingClientEntryPoint:!1,Events:[xs,vs,ws,Ne,Te,cl]},eu={findFiberByHostInstance:bs,bundleType:0,version:"18.3.1",rendererPackageName:"react-dom"},tu={bundleType:eu.bundleType,version:eu.version,rendererPackageName:eu.rendererPackageName,rendererConfig:eu.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:v.ReactCurrentDispatcher,findHostInstanceByFiber:function(e){return null===(e=Ge(e))?null:e.stateNode},findFiberByHostInstance:eu.findFiberByHostInstance||function(){return null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.3.1-next-f1338f8080-20240426"};if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__){var nu=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!nu.isDisabled&&nu.supportsFiber)try{st=nu.inject(tu),rt=nu}catch(ue){}}t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=$l,t.createPortal=function(e,t){var n=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;if(!Yl(t))throw Error(r(200));return function(e,t,n){var a=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:k,key:null==a?null:""+a,children:e,containerInfo:t,implementation:n}}(e,t,null,n)},t.createRoot=function(e,t){if(!Yl(e))throw Error(r(299));var n=!1,a="",s=ql;return null!==t&&void 0!==t&&(!0===t.unstable_strictMode&&(n=!0),void 0!==t.identifierPrefix&&(a=t.identifierPrefix),void 0!==t.onRecoverableError&&(s=t.onRecoverableError)),t=Bl(e,1,!1,null,0,n,0,a,s),e[fs]=t.current,Va(8===e.nodeType?e.parentNode:e),new Kl(t)},t.findDOMNode=function(e){if(null==e)return null;if(1===e.nodeType)return e;var t=e._reactInternals;if(void 0===t){if("function"===typeof e.render)throw Error(r(188));throw e=Object.keys(e).join(","),Error(r(268,e))}return e=null===(e=Ge(t))?null:e.stateNode},t.flushSync=function(e){return ll(e)},t.hydrate=function(e,t,n){if(!Ql(t))throw Error(r(200));return Jl(null,e,t,!0,n)},t.hydrateRoot=function(e,t,n){if(!Yl(e))throw Error(r(405));var a=null!=n&&n.hydratedSources||null,s=!1,i="",o=ql;if(null!==n&&void 0!==n&&(!0===n.unstable_strictMode&&(s=!0),void 0!==n.identifierPrefix&&(i=n.identifierPrefix),void 0!==n.onRecoverableError&&(o=n.onRecoverableError)),t=Wl(t,null,e,1,null!=n?n:null,s,0,i,o),e[fs]=t.current,Va(e),a)for(e=0;e<a.length;e++)s=(s=(n=a[e])._getVersion)(n._source),null==t.mutableSourceEagerHydrationData?t.mutableSourceEagerHydrationData=[n,s]:t.mutableSourceEagerHydrationData.push(n,s);return new Xl(t)},t.render=function(e,t,n){if(!Ql(t))throw Error(r(200));return Jl(null,e,t,!1,n)},t.unmountComponentAtNode=function(e){if(!Ql(e))throw Error(r(40));return!!e._reactRootContainer&&(ll(function(){Jl(null,null,e,!1,function(){e._reactRootContainer=null,e[fs]=null})}),!0)},t.unstable_batchedUpdates=cl,t.unstable_renderSubtreeIntoContainer=function(e,t,n,a){if(!Ql(n))throw Error(r(200));if(null==e||void 0===e._reactInternals)throw Error(r(38));return Jl(e,t,n,!1,a)},t.version="18.3.1-next-f1338f8080-20240426"},817(){},853(e,t,n){"use strict";e.exports=n(234)},879(e,t,n){(function(){"use strict";var e;function t(e){var t=0;return function(){return t<e.length?{done:!1,value:e[t++]}:{done:!0}}}var a="function"==typeof Object.defineProperties?Object.defineProperty:function(e,t,n){return e==Array.prototype||e==Object.prototype||(e[t]=n.value),e};var s=function(e){e=["object"==typeof globalThis&&globalThis,e,"object"==typeof window&&window,"object"==typeof self&&self,"object"==typeof n.g&&n.g];for(var t=0;t<e.length;++t){var a=e[t];if(a&&a.Math==Math)return a}throw Error("Cannot find global object")}(this);function r(e,t){if(t)e:{var n=s;e=e.split(".");for(var r=0;r<e.length-1;r++){var i=e[r];if(!(i in n))break e;n=n[i]}(t=t(r=n[e=e[e.length-1]]))!=r&&null!=t&&a(n,e,{configurable:!0,writable:!0,value:t})}}function i(e){return(e={next:e})[Symbol.iterator]=function(){return this},e}function o(e){var n="undefined"!=typeof Symbol&&Symbol.iterator&&e[Symbol.iterator];return n?n.call(e):{next:t(e)}}function c(e){if(!(e instanceof Array)){e=o(e);for(var t,n=[];!(t=e.next()).done;)n.push(t.value);e=n}return e}r("Symbol",function(e){function t(e,t){this.h=e,a(this,"description",{configurable:!0,writable:!0,value:t})}if(e)return e;t.prototype.toString=function(){return this.h};var n="jscomp_symbol_"+(1e9*Math.random()>>>0)+"_",s=0;return function e(a){if(this instanceof e)throw new TypeError("Symbol is not a constructor");return new t(n+(a||"")+"_"+s++,a)}}),r("Symbol.iterator",function(e){if(e)return e;e=Symbol("Symbol.iterator");for(var n="Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "),r=0;r<n.length;r++){var o=s[n[r]];"function"===typeof o&&"function"!=typeof o.prototype[e]&&a(o.prototype,e,{configurable:!0,writable:!0,value:function(){return i(t(this))}})}return e});var l="function"==typeof Object.assign?Object.assign:function(e,t){for(var n=1;n<arguments.length;n++){var a=arguments[n];if(a)for(var s in a)Object.prototype.hasOwnProperty.call(a,s)&&(e[s]=a[s])}return e};r("Object.assign",function(e){return e||l});var u,h="function"==typeof Object.create?Object.create:function(e){function t(){}return t.prototype=e,new t};if("function"==typeof Object.setPrototypeOf)u=Object.setPrototypeOf;else{var d;e:{var p={};try{p.__proto__={a:!0},d=p.a;break e}catch(vn){}d=!1}u=d?function(e,t){if(e.__proto__=t,e.__proto__!==t)throw new TypeError(e+" is not extensible");return e}:null}var f=u;function m(e,t){if(e.prototype=h(t.prototype),e.prototype.constructor=e,f)f(e,t);else for(var n in t)if("prototype"!=n)if(Object.defineProperties){var a=Object.getOwnPropertyDescriptor(t,n);a&&Object.defineProperty(e,n,a)}else e[n]=t[n];e.za=t.prototype}function g(){this.m=!1,this.j=null,this.i=void 0,this.h=1,this.v=this.s=0,this.l=null}function y(e){if(e.m)throw new TypeError("Generator is already running");e.m=!0}function b(e,t){e.l={ma:t,na:!0},e.h=e.s||e.v}function x(e,t,n){return e.h=n,{value:t}}function v(e){this.h=new g,this.i=e}function w(e,t,n,a){try{var s=t.call(e.h.j,n);if(!(s instanceof Object))throw new TypeError("Iterator result "+s+" is not an object");if(!s.done)return e.h.m=!1,s;var r=s.value}catch(i){return e.h.j=null,b(e.h,i),k(e)}return e.h.j=null,a.call(e.h,r),k(e)}function k(e){for(;e.h.h;)try{var t=e.i(e.h);if(t)return e.h.m=!1,{value:t.value,done:!1}}catch(n){e.h.i=void 0,b(e.h,n)}if(e.h.m=!1,e.h.l){if(t=e.h.l,e.h.l=null,t.na)throw t.ma;return{value:t.return,done:!0}}return{value:void 0,done:!0}}function S(e){this.next=function(t){return y(e.h),e.h.j?t=w(e,e.h.j.next,t,e.h.u):(e.h.u(t),t=k(e)),t},this.throw=function(t){return y(e.h),e.h.j?t=w(e,e.h.j.throw,t,e.h.u):(b(e.h,t),t=k(e)),t},this.return=function(t){return function(e,t){y(e.h);var n=e.h.j;return n?w(e,"return"in n?n.return:function(e){return{value:e,done:!0}},t,e.h.return):(e.h.return(t),k(e))}(e,t)},this[Symbol.iterator]=function(){return this}}function C(e){return function(e){function t(t){return e.next(t)}function n(t){return e.throw(t)}return new Promise(function(a,s){!function e(r){r.done?a(r.value):Promise.resolve(r.value).then(t,n).then(e,s)}(e.next())})}(new S(new v(e)))}function I(e){return e||Array.prototype.fill}g.prototype.u=function(e){this.i=e},g.prototype.return=function(e){this.l={return:e},this.h=this.v},r("Promise",function(e){function t(e){this.i=0,this.j=void 0,this.h=[],this.u=!1;var t=this.l();try{e(t.resolve,t.reject)}catch(n){t.reject(n)}}function n(){this.h=null}function a(e){return e instanceof t?e:new t(function(t){t(e)})}if(e)return e;n.prototype.i=function(e){if(null==this.h){this.h=[];var t=this;this.j(function(){t.m()})}this.h.push(e)};var r=s.setTimeout;n.prototype.j=function(e){r(e,0)},n.prototype.m=function(){for(;this.h&&this.h.length;){var e=this.h;this.h=[];for(var t=0;t<e.length;++t){var n=e[t];e[t]=null;try{n()}catch(a){this.l(a)}}}this.h=null},n.prototype.l=function(e){this.j(function(){throw e})},t.prototype.l=function(){function e(e){return function(a){n||(n=!0,e.call(t,a))}}var t=this,n=!1;return{resolve:e(this.I),reject:e(this.m)}},t.prototype.I=function(e){if(e===this)this.m(new TypeError("A Promise cannot resolve to itself"));else if(e instanceof t)this.L(e);else{e:switch(typeof e){case"object":var n=null!=e;break e;case"function":n=!0;break e;default:n=!1}n?this.F(e):this.s(e)}},t.prototype.F=function(e){var t=void 0;try{t=e.then}catch(n){return void this.m(n)}"function"==typeof t?this.M(t,e):this.s(e)},t.prototype.m=function(e){this.v(2,e)},t.prototype.s=function(e){this.v(1,e)},t.prototype.v=function(e,t){if(0!=this.i)throw Error("Cannot settle("+e+", "+t+"): Promise already settled in state"+this.i);this.i=e,this.j=t,2===this.i&&this.K(),this.H()},t.prototype.K=function(){var e=this;r(function(){if(e.D()){var t=s.console;"undefined"!==typeof t&&t.error(e.j)}},1)},t.prototype.D=function(){if(this.u)return!1;var e=s.CustomEvent,t=s.Event,n=s.dispatchEvent;return"undefined"===typeof n||("function"===typeof e?e=new e("unhandledrejection",{cancelable:!0}):"function"===typeof t?e=new t("unhandledrejection",{cancelable:!0}):(e=s.document.createEvent("CustomEvent")).initCustomEvent("unhandledrejection",!1,!0,e),e.promise=this,e.reason=this.j,n(e))},t.prototype.H=function(){if(null!=this.h){for(var e=0;e<this.h.length;++e)i.i(this.h[e]);this.h=null}};var i=new n;return t.prototype.L=function(e){var t=this.l();e.T(t.resolve,t.reject)},t.prototype.M=function(e,t){var n=this.l();try{e.call(t,n.resolve,n.reject)}catch(a){n.reject(a)}},t.prototype.then=function(e,n){function a(e,t){return"function"==typeof e?function(t){try{s(e(t))}catch(n){r(n)}}:t}var s,r,i=new t(function(e,t){s=e,r=t});return this.T(a(e,s),a(n,r)),i},t.prototype.catch=function(e){return this.then(void 0,e)},t.prototype.T=function(e,t){function n(){switch(a.i){case 1:e(a.j);break;case 2:t(a.j);break;default:throw Error("Unexpected state: "+a.i)}}var a=this;null==this.h?i.i(n):this.h.push(n),this.u=!0},t.resolve=a,t.reject=function(e){return new t(function(t,n){n(e)})},t.race=function(e){return new t(function(t,n){for(var s=o(e),r=s.next();!r.done;r=s.next())a(r.value).T(t,n)})},t.all=function(e){var n=o(e),s=n.next();return s.done?a([]):new t(function(e,t){function r(t){return function(n){i[t]=n,0==--o&&e(i)}}var i=[],o=0;do{i.push(void 0),o++,a(s.value).T(r(i.length-1),t),s=n.next()}while(!s.done)})},t}),r("Array.prototype.keys",function(e){return e||function(){return function(e,t){e instanceof String&&(e+="");var n=0,a=!1,s={next:function(){if(!a&&n<e.length){var s=n++;return{value:t(s,e[s]),done:!1}}return a=!0,{done:!0,value:void 0}}};return s[Symbol.iterator]=function(){return s},s}(this,function(e){return e})}}),r("Array.prototype.fill",function(e){return e||function(e,t,n){var a=this.length||0;for(0>t&&(t=Math.max(0,a+t)),(null==n||n>a)&&(n=a),0>(n=Number(n))&&(n=Math.max(0,a+n)),t=Number(t||0);t<n;t++)this[t]=e;return this}}),r("Int8Array.prototype.fill",I),r("Uint8Array.prototype.fill",I),r("Uint8ClampedArray.prototype.fill",I),r("Int16Array.prototype.fill",I),r("Uint16Array.prototype.fill",I),r("Int32Array.prototype.fill",I),r("Uint32Array.prototype.fill",I),r("Float32Array.prototype.fill",I),r("Float64Array.prototype.fill",I),r("Object.is",function(e){return e||function(e,t){return e===t?0!==e||1/e===1/t:e!==e&&t!==t}}),r("Array.prototype.includes",function(e){return e||function(e,t){var n=this;n instanceof String&&(n=String(n));var a=n.length;for(0>(t=t||0)&&(t=Math.max(t+a,0));t<a;t++){var s=n[t];if(s===e||Object.is(s,e))return!0}return!1}}),r("String.prototype.includes",function(e){return e||function(e,t){if(null==this)throw new TypeError("The 'this' value for String.prototype.includes must not be null or undefined");if(e instanceof RegExp)throw new TypeError("First argument to String.prototype.includes must not be a regular expression");return-1!==this.indexOf(e,t||0)}});var N=this||self;function T(e,t){e=e.split(".");var n,a=N;e[0]in a||"undefined"==typeof a.execScript||a.execScript("var "+e[0]);for(;e.length&&(n=e.shift());)e.length||void 0===t?a=a[n]&&a[n]!==Object.prototype[n]?a[n]:a[n]={}:a[n]=t}function E(e){var t;return(t=N.navigator)&&(t=t.userAgent)||(t=""),-1!=t.indexOf(e)}var R=Array.prototype.map?function(e,t){return Array.prototype.map.call(e,t,void 0)}:function(e,t){for(var n=e.length,a=Array(n),s="string"===typeof e?e.split(""):e,r=0;r<n;r++)r in s&&(a[r]=t.call(void 0,s[r],r,e));return a},_={},A=null;function M(e){var t=e.length,n=3*t/4;n%3?n=Math.floor(n):-1!="=.".indexOf(e[t-1])&&(n=-1!="=.".indexOf(e[t-2])?n-2:n-1);var a=new Uint8Array(n),s=0;return function(e,t){function n(t){for(;a<e.length;){var n=e.charAt(a++),s=A[n];if(null!=s)return s;if(!/^[\s\xa0]*$/.test(n))throw Error("Unknown base64 encoding at char: "+n)}return t}P();for(var a=0;;){var s=n(-1),r=n(0),i=n(64),o=n(64);if(64===o&&-1===s)break;t(s<<2|r>>4),64!=i&&(t(r<<4&240|i>>2),64!=o&&t(i<<6&192|o))}}(e,function(e){a[s++]=e}),s!==n?a.subarray(0,s):a}function P(){if(!A){A={};for(var e="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""),t=["+/=","+/","-_=","-_.","-_"],n=0;5>n;n++){var a=e.concat(t[n].split(""));_[n]=a;for(var s=0;s<a.length;s++){var r=a[s];void 0===A[r]&&(A[r]=s)}}}}var D="undefined"!==typeof Uint8Array,O=!(E("Trident")||E("MSIE"))&&"function"===typeof N.btoa;function F(e){if(!O){var t;void 0===t&&(t=0),P(),t=_[t];for(var n=Array(Math.floor(e.length/3)),a=t[64]||"",s=0,r=0;s<e.length-2;s+=3){var i=e[s],o=e[s+1],c=e[s+2],l=t[i>>2];i=t[(3&i)<<4|o>>4],o=t[(15&o)<<2|c>>6],c=t[63&c],n[r++]=l+i+o+c}switch(l=0,c=a,e.length-s){case 2:c=t[(15&(l=e[s+1]))<<2]||a;case 1:e=e[s],n[r]=t[e>>2]+t[(3&e)<<4|l>>4]+c+a}return n.join("")}for(t="";10240<e.length;)t+=String.fromCharCode.apply(null,e.subarray(0,10240)),e=e.subarray(10240);return t+=String.fromCharCode.apply(null,e),btoa(t)}var L,z=RegExp("[-_.]","g");function B(e){switch(e){case"-":return"+";case"_":return"/";case".":return"=";default:return""}}function j(e){if(!O)return M(e);z.test(e)&&(e=e.replace(z,B)),e=atob(e);for(var t=new Uint8Array(e.length),n=0;n<e.length;n++)t[n]=e.charCodeAt(n);return t}function W(){return L||(L=new Uint8Array(0))}var V={},U="function"===typeof Uint8Array.prototype.slice,H=0,G=0;function q(e){var t=0>e,n=(e=Math.abs(e))>>>0;e=Math.floor((e-n)/4294967296),t&&(t=(n=o(Y(n,e))).next().value,e=n.next().value,n=t),H=n>>>0,G=e>>>0}var K,X="function"===typeof BigInt;function Y(e,t){return t=~t,e?e=1+~e:t+=1,[e,t]}function Q(e,t){this.i=e>>>0,this.h=t>>>0}function Z(e){if(!e)return K||(K=new Q(0,0));if(!/^-?\d+$/.test(e))return null;if(16>e.length)q(Number(e));else if(X)e=BigInt(e),H=Number(e&BigInt(4294967295))>>>0,G=Number(e>>BigInt(32)&BigInt(4294967295));else{var t=+("-"===e[0]);G=H=0;for(var n=e.length,a=t,s=(n-t)%6+t;s<=n;a=s,s+=6)a=Number(e.slice(a,s)),G*=1e6,4294967296<=(H=1e6*H+a)&&(G+=H/4294967296|0,H%=4294967296);t&&(e=(t=o(Y(H,G))).next().value,t=t.next().value,H=e,G=t)}return new Q(H,G)}function J(e,t){return Error("Invalid wire type: "+e+" (at position "+t+")")}function $(){return Error("Failed to read varint, encoding is invalid.")}function ee(e,t){return Error("Tried to read past the end of the data "+t+" > "+e)}function te(){throw Error("Invalid UTF8")}function ne(e,t){return t=String.fromCharCode.apply(null,t),null==e?t:e+t}var ae,se,re,ie=void 0,oe="undefined"!==typeof TextDecoder,ce="undefined"!==typeof TextEncoder;function le(e){if(e!==V)throw Error("illegal external caller")}function ue(e,t){if(le(t),this.V=e,null!=e&&0===e.length)throw Error("ByteString should be constructed with non-empty values")}function he(){return re||(re=new ue(null,V))}function de(e){le(V);var t=e.V;return null==(t=null==t||D&&null!=t&&t instanceof Uint8Array?t:"string"===typeof t?j(t):null)?t:e.V=t}function pe(e,t){this.i=null,this.m=!1,this.h=this.j=this.l=0,fe(this,e,t)}function fe(e,t,n){n=void 0===n?{}:n,e.S=void 0!==n.S&&n.S,t&&(t=function(e){if("string"===typeof e)return{buffer:j(e),C:!1};if(Array.isArray(e))return{buffer:new Uint8Array(e),C:!1};if(e.constructor===Uint8Array)return{buffer:e,C:!1};if(e.constructor===ArrayBuffer)return{buffer:new Uint8Array(e),C:!1};if(e.constructor===ue)return{buffer:de(e)||W(),C:!0};if(e instanceof Uint8Array)return{buffer:new Uint8Array(e.buffer,e.byteOffset,e.byteLength),C:!1};throw Error("Type not convertible to a Uint8Array, expected a Uint8Array, an ArrayBuffer, a base64 encoded string, a ByteString or an Array of numbers")}(t),e.i=t.buffer,e.m=t.C,e.l=0,e.j=e.i.length,e.h=e.l)}function me(e,t){if(e.h=t,t>e.j)throw ee(e.j,t)}function ge(e){var t=e.i,n=e.h,a=t[n++],s=127&a;if(128&a&&(s|=(127&(a=t[n++]))<<7,128&a&&(s|=(127&(a=t[n++]))<<14,128&a&&(s|=(127&(a=t[n++]))<<21,128&a&&(s|=(a=t[n++])<<28,128&a&&128&t[n++]&&128&t[n++]&&128&t[n++]&&128&t[n++]&&128&t[n++])))))throw $();return me(e,n),s}function ye(e,t){if(0>t)throw Error("Tried to read a negative byte length: "+t);var n=e.h,a=n+t;if(a>e.j)throw ee(t,e.j-n);return e.h=a,n}pe.prototype.reset=function(){this.h=this.l};var be=[];function xe(){this.h=[]}function ve(e,t,n){for(;0<n||127<t;)e.h.push(127&t|128),t=(t>>>7|n<<25)>>>0,n>>>=7;e.h.push(t)}function we(e,t){for(;127<t;)e.h.push(127&t|128),t>>>=7;e.h.push(t)}function ke(e,t){if(be.length){var n=be.pop();fe(n,e,t),e=n}else e=new pe(e,t);this.h=e,this.j=this.h.h,this.i=this.l=-1,this.setOptions(t)}function Se(e){var t=e.h;if(t.h==t.j)return!1;e.j=e.h.h;var n=ge(e.h)>>>0;if(t=n>>>3,!(0<=(n&=7)&&5>=n))throw J(n,e.j);if(1>t)throw Error("Invalid field number: "+t+" (at position "+e.j+")");return e.l=t,e.i=n,!0}function Ce(e){switch(e.i){case 0:if(0!=e.i)Ce(e);else e:{for(var t=(e=e.h).h,n=t+10,a=e.i;t<n;)if(0===(128&a[t++])){me(e,t);break e}throw $()}break;case 1:me(e=e.h,e.h+8);break;case 2:2!=e.i?Ce(e):(t=ge(e.h)>>>0,me(e=e.h,e.h+t));break;case 5:me(e=e.h,e.h+4);break;case 3:for(t=e.l;;){if(!Se(e))throw Error("Unmatched start-group tag: stream EOF");if(4==e.i){if(e.l!=t)throw Error("Unmatched end-group tag");break}Ce(e)}break;default:throw J(e.i,e.j)}}xe.prototype.length=function(){return this.h.length},xe.prototype.end=function(){var e=this.h;return this.h=[],e},ke.prototype.setOptions=function(e){e=void 0===e?{}:e,this.ca=void 0!==e.ca&&e.ca},ke.prototype.reset=function(){this.h.reset(),this.j=this.h.h,this.i=this.l=-1};var Ie=[];function Ne(){this.j=[],this.i=0,this.h=new xe}function Te(e,t){0!==t.length&&(e.j.push(t),e.i+=t.length)}var Ee="function"===typeof Symbol&&"symbol"===typeof Symbol()?Symbol():void 0;function Re(e,t){return Ee?e[Ee]|=t:void 0!==e.A?e.A|=t:(Object.defineProperties(e,{A:{value:t,configurable:!0,writable:!0,enumerable:!1}}),t)}function _e(e,t){Ee?e[Ee]&&(e[Ee]&=~t):void 0!==e.A&&(e.A&=~t)}function Ae(e){var t;return null==(t=Ee?e[Ee]:e.A)?0:t}function Me(e,t){Ee?e[Ee]=t:void 0!==e.A?e.A=t:Object.defineProperties(e,{A:{value:t,configurable:!0,writable:!0,enumerable:!1}})}function Pe(e){return Re(e,1),e}function De(e,t){Me(t,-51&e)}function Oe(e,t){Me(t,-41&e|18)}var Fe={};function Le(e){return null!==e&&"object"===typeof e&&!Array.isArray(e)&&e.constructor===Object}var ze,Be,je=[];function We(e){if(2&Ae(e.o))throw Error("Cannot mutate an immutable Message")}function Ve(e){var t=e.length;(t=t?e[t-1]:void 0)&&Le(t)?t.g=1:(t={},e.push((t.g=1,t)))}function Ue(e){var t=e.i+e.G;return e.B||(e.B=e.o[t]={})}function He(e,t){return-1===t?null:t>=e.i?e.B?e.B[t]:void 0:e.o[t+e.G]}function Ge(e,t,n,a){We(e),qe(e,t,n,a)}function qe(e,t,n,a){e.j&&(e.j=void 0),t>=e.i||a?Ue(e)[t]=n:(e.o[t+e.G]=n,(e=e.B)&&t in e&&delete e[t])}function Ke(e,t,n,a){var s=He(e,t);Array.isArray(s)||(s=ze);var r=Ae(s);if(1&r||Pe(s),a)2&r||Re(s,2),1&n||Object.freeze(s);else{a=!(2&n);var i=2&r;1&n||!i?a&&16&r&&!i&&_e(s,16):qe(e,t,s=Pe(Array.prototype.slice.call(s)))}return s}function Xe(e,t){var n=He(e,t),a=null==n?n:"number"===typeof n||"NaN"===n||"Infinity"===n||"-Infinity"===n?Number(n):void 0;return null!=a&&a!==n&&qe(e,t,a),a}function Ye(e,t,n,a,s){e.h||(e.h={});var r=e.h[n],i=Ke(e,n,3,s);if(!r){var o=i;r=[];var c=!!(16&Ae(e.o));i=!!(2&Ae(o));var l=o;!s&&i&&(o=Array.prototype.slice.call(o));for(var u=i,h=0;h<o.length;h++){var d=o[h],p=t,f=!1;if(f=void 0!==f&&f,void 0!==(d=Array.isArray(d)?new p(d):f?new p:void 0)){var m=f=Ae(p=d.o);i&&(m|=2),c&&(m|=16),m!=f&&Me(p,m),p=m,u=u||!!(2&p),r.push(d)}}return e.h[n]=r,t=33|(c=Ae(o)),c!=(t=u?-9&t:8|t)&&(u=o,Object.isFrozen(u)&&(u=Array.prototype.slice.call(u)),Me(u,t),o=u),l!==o&&qe(e,n,o),(s||a&&i)&&Re(r,2),a&&Object.freeze(r),r}return s||(s=Object.isFrozen(r),a&&!s?Object.freeze(r):!a&&s&&(r=Array.prototype.slice.call(r),e.h[n]=r)),r}function Qe(e,t,n){var a=!!(2&Ae(e.o));if(t=Ye(e,t,n,a,a),e=Ke(e,n,3,a),!(a||8&Ae(e))){for(a=0;a<t.length;a++){if(2&Ae((n=t[a]).o)){var s=ct(n,!1);s.j=n}else s=n;n!==s&&(t[a]=s,e[a]=s.o)}Re(e,8)}return t}function Ze(e,t,n){if(null!=n&&"number"!==typeof n)throw Error("Value of float/double field must be a number|null|undefined, found "+typeof n+": "+n);Ge(e,t,n)}function Je(e,t,n,a,s){We(e);var r=Ye(e,n,t,!1,!1);return n=null!=a?a:new n,e=Ke(e,t,2,!1),void 0!=s?(r.splice(s,0,n),e.splice(s,0,n.o)):(r.push(n),e.push(n.o)),n.C()&&_e(e,8),n}function $e(e,t){return null==e?t:e}function et(e,t,n){return n=void 0===n?0:n,$e(Xe(e,t),n)}function tt(e,t,n,a){if(null!=e){if(Array.isArray(e))e=nt(e,t,n,void 0!==a);else if(Le(e)){var s,r={};for(s in e)r[s]=tt(e[s],t,n,a);e=r}else e=t(e,a);return e}}function nt(e,t,n,a){var s=Ae(e);a=a?!!(16&s):void 0,e=Array.prototype.slice.call(e);for(var r=0;r<e.length;r++)e[r]=tt(e[r],t,n,a);return n(s,e),e}function at(e){return e.ja===Fe?e.toJSON():function(e){switch(typeof e){case"number":return isFinite(e)?e:String(e);case"object":if(e)if(Array.isArray(e)){if(0!==(128&Ae(e)))return Ve(e=Array.prototype.slice.call(e)),e}else{if(D&&null!=e&&e instanceof Uint8Array)return F(e);if(e instanceof ue){var t=e.V;return null==t?"":"string"===typeof t?t:e.V=F(t)}}}return e}(e)}function st(e,t){128&e&&Ve(t)}function rt(e,t,n){if(n=void 0===n?Oe:n,null!=e){if(D&&e instanceof Uint8Array)return e.length?new ue(new Uint8Array(e),V):he();if(Array.isArray(e)){var a=Ae(e);return 2&a?e:!t||32&a||!(16&a||0===a)?(4&(t=Ae(e=nt(e,rt,4&a?Oe:n,!0)))&&2&t&&Object.freeze(e),e):(Me(e,2|a),e)}return e.ja===Fe?ot(e):e}}function it(e,t,n,a,s,r,i){if(e=e.h&&e.h[n]){if(2&(a=Ae(e))?a=e:(Oe(a,r=R(e,ot)),Object.freeze(r),a=r),We(t),i=null==a?ze:Pe([]),null!=a){for(r=!!a.length,e=0;e<a.length;e++){var o=a[e];r=r&&!(2&Ae(o.o)),i[e]=o.o}r=1|(r?8:0),((e=Ae(i))&r)!==r&&(Object.isFrozen(i)&&(i=Array.prototype.slice.call(i)),Me(i,e|r)),t.h||(t.h={}),t.h[n]=a}else t.h&&(t.h[n]=void 0);qe(t,n,i,s)}else Ge(t,n,rt(a,r,i),s)}function ot(e){return 2&Ae(e.o)||Re((e=ct(e,!0)).o,2),e}function ct(e,t){var n=e.o,a=[];Re(a,16);var s=e.constructor.h;if(s&&a.push(s),s=e.B){a.length=n.length,a.fill(void 0,a.length,n.length);var r={};a[a.length-1]=r}0!==(128&Ae(n))&&Ve(a),t=t||e.C()?Oe:De,r=e.constructor,Be=a,a=new r(a),Be=void 0,e.R&&(a.R=e.R.slice()),r=!!(16&Ae(n));for(var i=s?n.length-1:n.length,o=0;o<i;o++)it(e,a,o-e.G,n[o],!1,r,t);if(s)for(var c in s)it(e,a,+c,s[c],!0,r,t);return a}function lt(e,t,n){null==e&&(e=Be),Be=void 0;var a,s=this.constructor.i||0,r=0<s,i=this.constructor.h,o=!1;if(null==e){var c=48,l=!0;r&&(s=0,c|=128),Me(e=i?[i]:[],c)}else{if(!Array.isArray(e))throw Error();if(i&&i!==e[0])throw Error();var u=c=Re(e,0);if((l=0!==(16&u))&&((o=0!==(32&u))||(u|=32)),r){if(128&u)s=0;else if(0<e.length){var h=e[e.length-1];if(Le(h)&&"g"in h){s=0,u|=128,delete h.g;var d,p=!0;for(d in h){p=!1;break}p&&e.pop()}}}else if(128&u)throw Error();c!==u&&Me(e,u)}if(this.G=(i?0:-1)-s,this.h=void 0,this.o=e,s=(i=this.o.length)-1,i&&Le(i=this.o[s])?(this.B=i,this.i=s-this.G):void 0!==t&&-1<t?(this.i=Math.max(t,s+1-this.G),this.B=void 0):this.i=Number.MAX_VALUE,!r&&this.B&&"g"in this.B)throw Error('Unexpected "g" flag in sparse object of message that is not a group type.');if(n)for(t=l&&!o&&!0,r=this.i,l=0;l<n.length;l++)(o=n[l])<r?(s=e[o+=this.G])?ut(s,t):e[o]=ze:(a||(a=Ue(this)),(s=a[o])?ut(s,t):a[o]=ze)}function ut(e,t){if(Array.isArray(e)){var n=Ae(e),a=1;!t||2&n||(a|=16),(n&a)!==a&&Me(e,n|a)}}function ht(e,t,n){if(n){var a,s={};for(a in n){var r=n[a],i=r.ra;i||(s.J=r.xa||r.oa.W,r.ia?(s.aa=xt(r.ia),i=function(e){return function(t,n,a){return e.J(t,n,a,e.aa)}}(s)):r.ka?(s.Z=vt(r.da.P,r.ka),i=function(e){return function(t,n,a){return e.J(t,n,a,e.Z)}}(s)):i=s.J,r.ra=i),i(t,e,r.da),s={J:s.J,aa:s.aa,Z:s.Z}}}!function(e,t){if(t=t.R){Te(e,e.h.end());for(var n=0;n<t.length;n++)Te(e,de(t[n])||W())}}(t,e)}Me(je,23),ze=Object.freeze(je),lt.prototype.toJSON=function(){return nt(this.o,at,st)},lt.prototype.C=function(){return!!(2&Ae(this.o))},lt.prototype.ja=Fe,lt.prototype.toString=function(){return this.o.toString()};var dt=Symbol();function pt(e,t,n){return e[dt]||(e[dt]=function(e,a){return t(e,a,n)})}function ft(e){var t=e[dt];if(!t){var n=Mt(e);t=function(e,t){return Pt(e,t,n)},e[dt]=t}return t}function mt(e){var t=function(e){var t=e.ia;return t?ft(t):(t=e.wa)?pt(e.da.P,t,e.ka):void 0}(e),n=e.da,a=e.oa.U;return t?function(e,s){return a(e,s,n,t)}:function(e,t){return a(e,t,n)}}function gt(e,t){var n=e[t];return"function"==typeof n&&0===n.length&&(n=n(),e[t]=n),Array.isArray(n)&&(Tt in n||wt in n||0<n.length&&"function"==typeof n[0])?n:void 0}function yt(e,t,n,a,s,r){t.P=e[0];var i=1;if(e.length>i&&"number"!==typeof e[i]){var o=e[i++];n(t,o)}for(;i<e.length;){n=e[i++];for(var c=i+1;c<e.length&&"number"!==typeof e[c];)c++;switch(o=e[i++],c-=i){case 0:a(t,n,o);break;case 1:(c=gt(e,i))?(i++,s(t,n,o,c)):a(t,n,o,e[i++]);break;case 2:s(t,n,o,c=gt(e,c=i++),e[i++]);break;case 3:r(t,n,o,e[i++],e[i++],e[i++]);break;case 4:r(t,n,o,e[i++],e[i++],e[i++],e[i++]);break;default:throw Error("unexpected number of binary field arguments: "+c)}}return t}var bt=Symbol();function xt(e){var t=e[bt];if(!t){var n=Nt(e);t=function(e,t){return Dt(e,t,n)},e[bt]=t}return t}function vt(e,t){var n=e[bt];return n||(n=function(e,n){return ht(e,n,t)},e[bt]=n),n}var wt=Symbol();function kt(e,t){e.push(t)}function St(e,t,n){e.push(t,n.W)}function Ct(e,t,n,a){var s=xt(a),r=Nt(a).P,i=n.W;e.push(t,function(e,t,n){return i(e,t,n,r,s)})}function It(e,t,n,a,s,r){var i=vt(a,r),o=n.W;e.push(t,function(e,t,n){return o(e,t,n,a,i)})}function Nt(e){var t=e[wt];return t||(t=yt(e,e[wt]=[],kt,St,Ct,It),Tt in e&&wt in e&&(e.length=0),t)}var Tt=Symbol();function Et(e,t){e[0]=t}function Rt(e,t,n,a){var s=n.U;e[t]=a?function(e,t,n){return s(e,t,n,a)}:s}function _t(e,t,n,a,s){var r=n.U,i=ft(a),o=Mt(a).P;e[t]=function(e,t,n){return r(e,t,n,o,i,s)}}function At(e,t,n,a,s,r,i){var o=n.U,c=pt(a,s,r);e[t]=function(e,t,n){return o(e,t,n,a,c,i)}}function Mt(e){var t=e[Tt];return t||(t=yt(e,e[Tt]={},Et,Rt,_t,At),Tt in e&&wt in e&&(e.length=0),t)}function Pt(e,t,n){for(;Se(t)&&4!=t.i;){var a=t.l,s=n[a];if(!s){var r=n[0];r&&(r=r[a])&&(s=n[a]=mt(r))}if(!s||!s(t,e,a)){a=e,r=(s=t).j,Ce(s);var i=s;if(!i.ca){if(s=i.h.h-r,i.h.h=r,i=i.h,0==s)s=he();else{if(r=ye(i,s),i.S&&i.m)s=i.i.subarray(r,r+s);else{i=i.i;var o=r;s=o===(s=r+s)?W():U?i.slice(o,s):new Uint8Array(i.subarray(o,s))}s=0==s.length?he():new ue(s,V)}(r=a.R)?r.push(s):a.R=[s]}}}return e}function Dt(e,t,n){for(var a=n.length,s=1==a%2,r=s?1:0;r<a;r+=2)(0,n[r+1])(t,e,n[r]);ht(e,t,s?n[0]:void 0)}function Ot(e,t){return{U:e,W:t}}var Ft=Ot(function(e,t,n){if(5!==e.i)return!1;var a=(e=e.h).i,s=e.h,r=a[s],i=a[s+1],o=a[s+2];return a=a[s+3],me(e,e.h+4),e=2*((i=(r|i<<8|o<<16|a<<24)>>>0)>>31)+1,r=i>>>23&255,i&=8388607,Ge(t,n,255==r?i?NaN:1/0*e:0==r?e*Math.pow(2,-149)*i:e*Math.pow(2,r-150)*(i+Math.pow(2,23))),!0},function(e,t,n){if(null!=(t=Xe(t,n))){we(e.h,8*n+5),e=e.h;var a=+t;0===a?0<1/a?H=G=0:(G=0,H=2147483648):isNaN(a)?(G=0,H=2147483647):34028234663852886e22<(a=(n=0>a?-2147483648:0)?-a:a)?(G=0,H=(2139095040|n)>>>0):11754943508222875e-54>a?(a=Math.round(a/Math.pow(2,-149)),G=0,H=(n|a)>>>0):(t=Math.floor(Math.log(a)/Math.LN2),a*=Math.pow(2,-t),16777216<=(a=Math.round(8388608*a))&&++t,G=0,H=(n|t+127<<23|8388607&a)>>>0),n=H,e.h.push(n>>>0&255),e.h.push(n>>>8&255),e.h.push(n>>>16&255),e.h.push(n>>>24&255)}}),Lt=Ot(function(e,t,n){if(0!==e.i)return!1;var a=e.h,s=0,r=e=0,i=a.i,o=a.h;do{var c=i[o++];s|=(127&c)<<r,r+=7}while(32>r&&128&c);for(32<r&&(e|=(127&c)>>4),r=3;32>r&&128&c;r+=7)e|=(127&(c=i[o++]))<<r;if(me(a,o),!(128>c))throw $();return a=s>>>0,(e=2147483648&(c=e>>>0))&&(c=~c>>>0,0==(a=1+~a>>>0)&&(c=c+1>>>0)),a=4294967296*c+(a>>>0),Ge(t,n,e?-a:a),!0},function(e,t,n){null!=(t=He(t,n))&&("string"===typeof t&&Z(t),null!=t&&(we(e.h,8*n),"number"===typeof t?(e=e.h,q(t),ve(e,H,G)):(n=Z(t),ve(e.h,n.i,n.h))))}),zt=Ot(function(e,t,n){return 0===e.i&&(Ge(t,n,ge(e.h)),!0)},function(e,t,n){if(null!=(t=He(t,n))&&null!=t)if(we(e.h,8*n),e=e.h,0<=(n=t))we(e,n);else{for(t=0;9>t;t++)e.h.push(127&n|128),n>>=7;e.h.push(1)}}),Bt=Ot(function(e,t,n){if(2!==e.i)return!1;var a=ge(e.h)>>>0,s=ye(e=e.h,a);if(e=e.i,oe){var r,i=e;(r=ae)||(r=ae=new TextDecoder("utf-8",{fatal:!0})),e=s+a,i=0===s&&e===i.length?i:i.subarray(s,e);try{var o=r.decode(i)}catch(h){if(void 0===ie){try{r.decode(new Uint8Array([128]))}catch(d){}try{r.decode(new Uint8Array([97])),ie=!0}catch(d){ie=!1}}throw!ie&&(ae=void 0),h}}else{a=(o=s)+a,s=[];for(var c,l,u=null;o<a;)128>(c=e[o++])?s.push(c):224>c?o>=a?te():(l=e[o++],194>c||128!==(192&l)?(o--,te()):s.push((31&c)<<6|63&l)):240>c?o>=a-1?te():128!==(192&(l=e[o++]))||224===c&&160>l||237===c&&160<=l||128!==(192&(i=e[o++]))?(o--,te()):s.push((15&c)<<12|(63&l)<<6|63&i):244>=c?o>=a-2?te():128!==(192&(l=e[o++]))||0!==l-144+(c<<28)>>30||128!==(192&(i=e[o++]))||128!==(192&(r=e[o++]))?(o--,te()):(c=(7&c)<<18|(63&l)<<12|(63&i)<<6|63&r,c-=65536,s.push(55296+(c>>10&1023),56320+(1023&c))):te(),8192<=s.length&&(u=ne(u,s),s.length=0);o=ne(u,s)}return Ge(t,n,o),!0},function(e,t,n){if(null!=(t=He(t,n))){var a=!1;if(a=void 0!==a&&a,ce){if(a&&/(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])/.test(t))throw Error("Found an unpaired surrogate");t=(se||(se=new TextEncoder)).encode(t)}else{for(var s=0,r=new Uint8Array(3*t.length),i=0;i<t.length;i++){var o=t.charCodeAt(i);if(128>o)r[s++]=o;else{if(2048>o)r[s++]=o>>6|192;else{if(55296<=o&&57343>=o){if(56319>=o&&i<t.length){var c=t.charCodeAt(++i);if(56320<=c&&57343>=c){o=1024*(o-55296)+c-56320+65536,r[s++]=o>>18|240,r[s++]=o>>12&63|128,r[s++]=o>>6&63|128,r[s++]=63&o|128;continue}i--}if(a)throw Error("Found an unpaired surrogate");o=65533}r[s++]=o>>12|224,r[s++]=o>>6&63|128}r[s++]=63&o|128}}t=s===r.length?r:r.subarray(0,s)}we(e.h,8*n+2),we(e.h,t.length),Te(e,e.h.end()),Te(e,t)}}),jt=Ot(function(e,t,n,a,s){if(2!==e.i)return!1;t=Je(t,n,a),n=e.h.j,a=ge(e.h)>>>0;var r=e.h.h+a,i=r-n;if(0>=i&&(e.h.j=r,s(t,e,void 0,void 0,void 0),i=r-e.h.h),i)throw Error("Message parsing ended unexpectedly. Expected to read "+a+" bytes, instead read "+(a-i)+" bytes, either the data ended unexpectedly or the message misreported its own length");return e.h.h=r,e.h.j=n,!0},function(e,t,n,a,s){if(null!=(t=Qe(t,a,n)))for(a=0;a<t.length;a++){var r=e;we(r.h,8*n+2);var i=r.h.end();Te(r,i),i.push(r.i),r=i,s(t[a],e),i=e;var o=r.pop();for(o=i.i+i.h.length()-o;127<o;)r.push(127&o|128),o>>>=7,i.i++;r.push(o),i.i++}});function Wt(e){return function(t,n){e:{if(Ie.length){var a=Ie.pop();a.setOptions(n),fe(a.h,t,n),t=a}else t=new ke(t,n);try{var s=Mt(e),r=Pt(new s.P,t,s);break e}finally{(s=t.h).i=null,s.m=!1,s.l=0,s.j=0,s.h=0,s.S=!1,t.l=-1,t.i=-1,100>Ie.length&&Ie.push(t)}r=void 0}return r}}function Vt(e){return function(){var t=new Ne;Dt(this,t,Nt(e)),Te(t,t.h.end());for(var n=new Uint8Array(t.i),a=t.j,s=a.length,r=0,i=0;i<s;i++){var o=a[i];n.set(o,r),r+=o.length}return t.j=[n],n}}function Ut(e){lt.call(this,e)}m(Ut,lt);var Ht=[Ut,1,zt,2,Ft,3,Bt,4,Bt];function Gt(e){lt.call(this,e,-1,qt)}Ut.prototype.l=Vt(Ht),m(Gt,lt),Gt.prototype.addClassification=function(e,t){return Je(this,1,Ut,e,t),this};var qt=[1],Kt=Wt([Gt,1,jt,Ht]);function Xt(e){lt.call(this,e)}m(Xt,lt);var Yt=[Xt,1,Ft,2,Ft,3,Ft,4,Ft,5,Ft];function Qt(e){lt.call(this,e,-1,Zt)}Xt.prototype.l=Vt(Yt),m(Qt,lt);var Zt=[1],Jt=Wt([Qt,1,jt,Yt]);function $t(e){lt.call(this,e)}m($t,lt);var en=[$t,1,Ft,2,Ft,3,Ft,4,Ft,5,Ft,6,Lt],tn=Wt(en);function nn(e,t,n){if(n=e.createShader(0===n?e.VERTEX_SHADER:e.FRAGMENT_SHADER),e.shaderSource(n,t),e.compileShader(n),!e.getShaderParameter(n,e.COMPILE_STATUS))throw Error("Could not compile WebGL shader.\n\n"+e.getShaderInfoLog(n));return n}function an(e){return Qe(e,Ut,1).map(function(e){var t=He(e,1);return{index:null==t?0:t,qa:et(e,2),label:null!=He(e,3)?$e(He(e,3),""):void 0,displayName:null!=He(e,4)?$e(He(e,4),""):void 0}})}function sn(e){return{x:et(e,1),y:et(e,2),z:et(e,3),visibility:null!=Xe(e,4)?et(e,4):void 0}}function rn(e){return Qe(Jt(e),Xt,1).map(sn)}function on(e,t){this.i=e,this.h=t,this.m=0}function cn(e,t,n){return function(e,t){var n=e.h;if(void 0===e.s){var a=nn(n,"\n  attribute vec2 aVertex;\n  attribute vec2 aTex;\n  varying vec2 vTex;\n  void main(void) {\n    gl_Position = vec4(aVertex, 0.0, 1.0);\n    vTex = aTex;\n  }",0),s=nn(n,"\n  precision mediump float;\n  varying vec2 vTex;\n  uniform sampler2D sampler0;\n  void main(){\n    gl_FragColor = texture2D(sampler0, vTex);\n  }",1),r=n.createProgram();if(n.attachShader(r,a),n.attachShader(r,s),n.linkProgram(r),!n.getProgramParameter(r,n.LINK_STATUS))throw Error("Could not compile WebGL program.\n\n"+n.getProgramInfoLog(r));a=e.s=r,n.useProgram(a),s=n.getUniformLocation(a,"sampler0"),e.l={O:n.getAttribLocation(a,"aVertex"),N:n.getAttribLocation(a,"aTex"),ya:s},e.v=n.createBuffer(),n.bindBuffer(n.ARRAY_BUFFER,e.v),n.enableVertexAttribArray(e.l.O),n.vertexAttribPointer(e.l.O,2,n.FLOAT,!1,0,0),n.bufferData(n.ARRAY_BUFFER,new Float32Array([-1,-1,-1,1,1,1,1,-1]),n.STATIC_DRAW),n.bindBuffer(n.ARRAY_BUFFER,null),e.u=n.createBuffer(),n.bindBuffer(n.ARRAY_BUFFER,e.u),n.enableVertexAttribArray(e.l.N),n.vertexAttribPointer(e.l.N,2,n.FLOAT,!1,0,0),n.bufferData(n.ARRAY_BUFFER,new Float32Array([0,1,0,0,1,0,1,1]),n.STATIC_DRAW),n.bindBuffer(n.ARRAY_BUFFER,null),n.uniform1i(s,0)}a=e.l,n.useProgram(e.s),n.canvas.width=t.width,n.canvas.height=t.height,n.viewport(0,0,t.width,t.height),n.activeTexture(n.TEXTURE0),e.i.bindTexture2d(t.glName),n.enableVertexAttribArray(a.O),n.bindBuffer(n.ARRAY_BUFFER,e.v),n.vertexAttribPointer(a.O,2,n.FLOAT,!1,0,0),n.enableVertexAttribArray(a.N),n.bindBuffer(n.ARRAY_BUFFER,e.u),n.vertexAttribPointer(a.N,2,n.FLOAT,!1,0,0),n.bindFramebuffer(n.DRAW_FRAMEBUFFER?n.DRAW_FRAMEBUFFER:n.FRAMEBUFFER,null),n.clearColor(0,0,0,0),n.clear(n.COLOR_BUFFER_BIT),n.colorMask(!0,!0,!0,!0),n.drawArrays(n.TRIANGLE_FAN,0,4),n.disableVertexAttribArray(a.O),n.disableVertexAttribArray(a.N),n.bindBuffer(n.ARRAY_BUFFER,null),e.i.bindTexture2d(0)}(e,t),"function"===typeof e.h.canvas.transferToImageBitmap?Promise.resolve(e.h.canvas.transferToImageBitmap()):n?Promise.resolve(e.h.canvas):"function"===typeof createImageBitmap?createImageBitmap(e.h.canvas):(void 0===e.j&&(e.j=document.createElement("canvas")),new Promise(function(t){e.j.height=e.h.canvas.height,e.j.width=e.h.canvas.width,e.j.getContext("2d",{}).drawImage(e.h.canvas,0,0,e.h.canvas.width,e.h.canvas.height),t(e.j)}))}function ln(e){this.h=e}$t.prototype.l=Vt(en);var un=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]);function hn(e,t){return t+e}function dn(e,t){window[e]=t}function pn(e){if(this.h=e,this.listeners={},this.l={},this.L={},this.s={},this.v={},this.M=this.u=this.ga=!0,this.I=Promise.resolve(),this.fa="",this.D={},this.locateFile=e&&e.locateFile||hn,"object"===typeof window)var t=window.location.pathname.toString().substring(0,window.location.pathname.toString().lastIndexOf("/"))+"/";else{if("undefined"===typeof location)throw Error("solutions can only be loaded on a web page or in a web worker");t=location.pathname.toString().substring(0,location.pathname.toString().lastIndexOf("/"))+"/"}if(this.ha=t,e.options)for(var n=(t=o(Object.keys(e.options))).next();!n.done;n=t.next()){n=n.value;var a=e.options[n].default;void 0!==a&&(this.l[n]="function"===typeof a?a():a)}}function fn(e){var t,n,a,s,r,i,o,l,u,h,d;return C(function(p){switch(p.h){case 1:return e.ga?(t=void 0===e.h.files?[]:"function"===typeof e.h.files?e.h.files(e.l):e.h.files,x(p,C(function(e){switch(e.h){case 1:return e.s=2,x(e,WebAssembly.instantiate(un),4);case 4:e.h=3,e.s=0;break;case 2:return e.s=0,e.l=null,e.return(!1);case 3:return e.return(!0)}}),2)):p.return();case 2:if(n=p.i,"object"===typeof window)return dn("createMediapipeSolutionsWasm",{locateFile:e.locateFile}),dn("createMediapipeSolutionsPackedAssets",{locateFile:e.locateFile}),i=t.filter(function(e){return void 0!==e.data}),o=t.filter(function(e){return void 0===e.data}),l=Promise.all(i.map(function(t){var n=mn(e,t.url);if(void 0!==t.path){var a=t.path;n=n.then(function(t){return e.overrideFile(a,t),Promise.resolve(t)})}return n})),u=Promise.all(o.map(function(t){return void 0===t.simd||t.simd&&n||!t.simd&&!n?function(e){var t=document.createElement("script");return t.setAttribute("src",e),t.setAttribute("crossorigin","anonymous"),new Promise(function(e){t.addEventListener("load",function(){e()},!1),t.addEventListener("error",function(){e()},!1),document.body.appendChild(t)})}(e.locateFile(t.url,e.ha)):Promise.resolve()})).then(function(){var t,n,a;return C(function(s){if(1==s.h)return t=window.createMediapipeSolutionsWasm,n=window.createMediapipeSolutionsPackedAssets,a=e,x(s,t(n),2);a.i=s.i,s.h=0})}),h=C(function(t){return e.h.graph&&e.h.graph.url?t=x(t,mn(e,e.h.graph.url),0):(t.h=0,t=void 0),t}),x(p,Promise.all([u,l,h]),7);if("function"!==typeof importScripts)throw Error("solutions can only be loaded on a web page or in a web worker");return a=t.filter(function(e){return void 0===e.simd||e.simd&&n||!e.simd&&!n}).map(function(t){return e.locateFile(t.url,e.ha)}),importScripts.apply(null,c(a)),s=e,x(p,createMediapipeSolutionsWasm(Module),6);case 6:s.i=p.i,e.m=new OffscreenCanvas(1,1),e.i.canvas=e.m,r=e.i.GL.createContext(e.m,{antialias:!1,alpha:!1,va:"undefined"!==typeof WebGL2RenderingContext?2:1}),e.i.GL.makeContextCurrent(r),p.h=4;break;case 7:if(e.m=document.createElement("canvas"),!(d=e.m.getContext("webgl2",{}))&&!(d=e.m.getContext("webgl",{})))return alert("Failed to create WebGL canvas context when passing video frame."),p.return();e.K=d,e.i.canvas=e.m,e.i.createContext(e.m,!0,!0,{});case 4:e.j=new e.i.SolutionWasm,e.ga=!1,p.h=0}})}function mn(e,t){var n,a;return C(function(s){return t in e.L?s.return(e.L[t]):(n=e.locateFile(t,""),a=fetch(n).then(function(e){return e.arrayBuffer()}),e.L[t]=a,s.return(a))})}function gn(e,t,n){var a,s,r,i,c,l,u,h,d,p,f,m,g,y;return C(function(b){switch(b.h){case 1:if(!n)return b.return(t);for(a={},s=0,r=o(Object.keys(n)),i=r.next();!i.done;i=r.next())c=i.value,"string"!==typeof(l=n[c])&&"texture"===l.type&&void 0!==t[l.stream]&&++s;1<s&&(e.M=!1),u=o(Object.keys(n)),i=u.next();case 2:if(i.done){b.h=4;break}if(h=i.value,"string"===typeof(d=n[h]))return g=a,y=h,x(b,function(e,t,n){var a;return C(function(s){return"number"===typeof n||n instanceof Uint8Array||n instanceof e.i.Uint8BlobList?s.return(n):n instanceof e.i.Texture2dDataOut?((a=e.v[t])||(a=new on(e.i,e.K),e.v[t]=a),s.return(cn(a,n,e.M))):s.return(void 0)})}(e,h,t[d]),14);if(p=t[d.stream],"detection_list"===d.type){if(p){for(var v=p.getRectList(),w=p.getLandmarksList(),k=p.getClassificationsList(),S=[],I=0;I<v.size();++I){var N=tn(v.get(I)),T=void 0;T=void 0===T?0:T,N={la:{sa:et(N,1),ta:et(N,2),height:et(N,3),width:et(N,4),rotation:et(N,5,0),pa:$e(He(N,6),T)},ea:rn(w.get(I)),ba:an(Kt(k.get(I)))},S.push(N)}v=S}else v=[];a[h]=v,b.h=7;break}if("proto_list"===d.type){if(p){for(v=Array(p.size()),w=0;w<p.size();w++)v[w]=p.get(w);p.delete()}else v=[];a[h]=v,b.h=7;break}if(void 0===p){b.h=3;break}if("float_list"===d.type){a[h]=p,b.h=7;break}if("proto"===d.type){a[h]=p,b.h=7;break}if("texture"!==d.type)throw Error("Unknown output config type: '"+d.type+"'");return(f=e.v[h])||(f=new on(e.i,e.K),e.v[h]=f),x(b,cn(f,p,e.M),13);case 13:m=b.i,a[h]=m;case 7:d.transform&&a[h]&&(a[h]=d.transform(a[h])),b.h=3;break;case 14:g[y]=b.i;case 3:i=u.next(),b.h=2;break;case 4:return b.return(a)}})}function yn(e,t){for(var n=t.name||"$",a=[].concat(c(t.wants)),s=new e.i.StringList,r=o(t.wants),i=r.next();!i.done;i=r.next())s.push_back(i.value);r=e.i.PacketListener.implement({onResults:function(s){for(var r={},i=0;i<t.wants.length;++i)r[a[i]]=s.get(i);var o=e.listeners[n];o&&(e.I=gn(e,r,t.outs).then(function(n){n=o(n);for(var s=0;s<t.wants.length;++s){var i=r[a[s]];"object"===typeof i&&i.hasOwnProperty&&i.hasOwnProperty("delete")&&i.delete()}n&&(e.I=n)}))}}),e.j.attachMultiListener(s,r),s.delete()}function bn(e){switch(void 0===e&&(e=0),e){case 1:return"pose_landmark_full.tflite";case 2:return"pose_landmark_heavy.tflite";default:return"pose_landmark_lite.tflite"}}function xn(e){var t=this;e=e||{},this.h=new pn({locateFile:e.locateFile,files:function(e){return[{url:"pose_solution_packed_assets_loader.js"},{simd:!1,url:"pose_solution_wasm_bin.js"},{simd:!0,url:"pose_solution_simd_wasm_bin.js"},{data:!0,url:bn(e.modelComplexity)}]},graph:{url:"pose_web.binarypb"},listeners:[{wants:["pose_landmarks","world_landmarks","segmentation_mask","image_transformed"],outs:{image:{type:"texture",stream:"image_transformed"},poseLandmarks:{type:"proto",stream:"pose_landmarks",transform:rn},poseWorldLandmarks:{type:"proto",stream:"world_landmarks",transform:rn},segmentationMask:{type:"texture",stream:"segmentation_mask"}}}],inputs:{image:{type:"video",stream:"input_frames_gpu"}},options:{useCpuInference:{type:0,graphOptionXref:{calculatorType:"InferenceCalculator",fieldName:"use_cpu_inference"},default:"object"===typeof window&&void 0!==window.navigator&&("iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform)||navigator.userAgent.includes("Mac")&&"ontouchend"in document)},selfieMode:{type:0,graphOptionXref:{calculatorType:"GlScalerCalculator",calculatorIndex:1,fieldName:"flip_horizontal"}},modelComplexity:{type:1,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorModelComplexity",fieldName:"int_value"},onChange:function(e){var n,a,s;return C(function(r){return 1==r.h?(n=bn(e),a="third_party/mediapipe/modules/pose_landmark/"+n,x(r,mn(t.h,n),2)):(s=r.i,t.h.overrideFile(a,s),r.return(!0))})}},smoothLandmarks:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothLandmarks",fieldName:"bool_value"}},enableSegmentation:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorEnableSegmentation",fieldName:"bool_value"}},smoothSegmentation:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothSegmentation",fieldName:"bool_value"}},minDetectionConfidence:{type:1,graphOptionXref:{calculatorType:"TensorsToDetectionsCalculator",calculatorName:"poselandmarkgpu__posedetectiongpu__TensorsToDetectionsCalculator",fieldName:"min_score_thresh"}},minTrackingConfidence:{type:1,graphOptionXref:{calculatorType:"ThresholdingCalculator",calculatorName:"poselandmarkgpu__poselandmarkbyroigpu__tensorstoposelandmarksandsegmentation__ThresholdingCalculator",fieldName:"threshold"}}}})}(e=pn.prototype).close=function(){return this.j&&this.j.delete(),Promise.resolve()},e.reset=function(){var e=this;return C(function(t){e.j&&(e.j.reset(),e.s={},e.v={}),t.h=0})},e.setOptions=function(e,t){var n=this;if(t=t||this.h.options){for(var a=[],s=[],r={},i=o(Object.keys(e)),c=i.next();!c.done;r={X:r.X,Y:r.Y},c=i.next())if(!((c=c.value)in this.l)||this.l[c]!==e[c]){this.l[c]=e[c];var l=t[c];void 0!==l&&(l.onChange&&(r.X=l.onChange,r.Y=e[c],a.push(function(e){return function(){return C(function(t){if(1==t.h)return x(t,e.X(e.Y),2);!0===t.i&&(n.u=!0),t.h=0})}}(r))),l.graphOptionXref&&(c=Object.assign({},{calculatorName:"",calculatorIndex:0},l.graphOptionXref,{valueNumber:1===l.type?e[c]:0,valueBoolean:0===l.type&&e[c],valueString:2===l.type?e[c]:""}),s.push(c)))}0===a.length&&0===s.length||(this.u=!0,this.H=(void 0===this.H?[]:this.H).concat(s),this.F=(void 0===this.F?[]:this.F).concat(a))}},e.initialize=function(){var e=this;return C(function(t){return 1==t.h?x(t,fn(e),2):3!=t.h?x(t,function(e){var t,n,a,s,r,i,c,l;return C(function(u){if(1==u.h)return e.h.graph&&e.h.graph.url&&e.fa===e.h.graph.url?u.return():(e.u=!0,e.h.graph&&e.h.graph.url?(e.fa=e.h.graph.url,x(u,mn(e,e.h.graph.url),3)):void(u.h=2));for(2!=u.h&&(t=u.i,e.j.loadGraph(t)),n=o(Object.keys(e.D)),a=n.next();!a.done;a=n.next())s=a.value,e.j.overrideFile(s,e.D[s]);if(e.D={},e.h.listeners)for(r=o(e.h.listeners),i=r.next();!i.done;i=r.next())c=i.value,yn(e,c);l=e.l,e.l={},e.setOptions(l),u.h=0})}(e),3):x(t,function(e){var t,n,a,s,r,i;return C(function(c){switch(c.h){case 1:if(!e.u)return c.return();if(!e.F){c.h=2;break}t=o(e.F),n=t.next();case 3:if(n.done){c.h=5;break}return x(c,(0,n.value)(),4);case 4:n=t.next(),c.h=3;break;case 5:e.F=void 0;case 2:if(e.H){for(a=new e.i.GraphOptionChangeRequestList,s=o(e.H),r=s.next();!r.done;r=s.next())i=r.value,a.push_back(i);e.j.changeOptions(a),a.delete(),e.H=void 0}e.u=!1,c.h=0}})}(e),0)})},e.overrideFile=function(e,t){this.j?this.j.overrideFile(e,t):this.D[e]=t},e.clearOverriddenFiles=function(){this.D={},this.j&&this.j.clearOverriddenFiles()},e.send=function(e,t){var n,a,s,r,i,c,l,u,h,d=this;return C(function(p){switch(p.h){case 1:return d.h.inputs?(n=1e3*(void 0===t||null===t?performance.now():t),x(p,d.I,2)):p.return();case 2:return x(p,d.initialize(),3);case 3:for(a=new d.i.PacketDataList,s=o(Object.keys(e)),r=s.next();!r.done;r=s.next())if(i=r.value,c=d.h.inputs[i]){e:{var f=e[i];switch(c.type){case"video":var m=d.s[c.stream];if(m||(m=new on(d.i,d.K),d.s[c.stream]=m),0===m.m&&(m.m=m.i.createTexture()),"undefined"!==typeof HTMLVideoElement&&f instanceof HTMLVideoElement)var g=f.videoWidth,y=f.videoHeight;else"undefined"!==typeof HTMLImageElement&&f instanceof HTMLImageElement?(g=f.naturalWidth,y=f.naturalHeight):(g=f.width,y=f.height);y={glName:m.m,width:g,height:y},(g=m.h).canvas.width=y.width,g.canvas.height=y.height,g.activeTexture(g.TEXTURE0),m.i.bindTexture2d(m.m),g.texImage2D(g.TEXTURE_2D,0,g.RGBA,g.RGBA,g.UNSIGNED_BYTE,f),m.i.bindTexture2d(0),m=y;break e;case"detections":for((m=d.s[c.stream])||(m=new ln(d.i),d.s[c.stream]=m),m.data||(m.data=new m.h.DetectionListData),m.data.reset(f.length),y=0;y<f.length;++y){g=f[y];var b=m.data,v=b.setBoundingBox,w=y,k=g.la,S=new $t;if(Ze(S,1,k.sa),Ze(S,2,k.ta),Ze(S,3,k.height),Ze(S,4,k.width),Ze(S,5,k.rotation),Ge(S,6,k.pa),k=S.l(),v.call(b,w,k),g.ea)for(b=0;b<g.ea.length;++b){S=g.ea[b],w=(v=m.data).addNormalizedLandmark,k=y,S=Object.assign({},S,{visibility:S.visibility?S.visibility:0});var C=new Xt;Ze(C,1,S.x),Ze(C,2,S.y),Ze(C,3,S.z),S.visibility&&Ze(C,4,S.visibility),S=C.l(),w.call(v,k,S)}if(g.ba)for(b=0;b<g.ba.length;++b)w=(v=m.data).addClassification,k=y,S=g.ba[b],Ze(C=new Ut,2,S.qa),S.index&&Ge(C,1,S.index),S.label&&Ge(C,3,S.label),S.displayName&&Ge(C,4,S.displayName),S=C.l(),w.call(v,k,S)}m=m.data;break e;default:m={}}}switch(l=m,u=c.stream,c.type){case"video":a.pushTexture2d(Object.assign({},l,{stream:u,timestamp:n}));break;case"detections":(h=l).stream=u,h.timestamp=n,a.pushDetectionList(h);break;default:throw Error("Unknown input config type: '"+c.type+"'")}}return d.j.send(a),x(p,d.I,4);case 4:a.delete(),p.h=0}})},e.onResults=function(e,t){this.listeners[t||"$"]=e},T("Solution",pn),T("OptionType",{BOOL:0,NUMBER:1,ua:2,0:"BOOL",1:"NUMBER",2:"STRING"}),(e=xn.prototype).reset=function(){this.h.reset()},e.close=function(){return this.h.close(),Promise.resolve()},e.onResults=function(e){this.h.onResults(e)},e.initialize=function(){var e=this;return C(function(t){return x(t,e.h.initialize(),0)})},e.send=function(e,t){var n=this;return C(function(a){return x(a,n.h.send(e,t),0)})},e.setOptions=function(e){this.h.setOptions(e)},T("Pose",xn),T("POSE_CONNECTIONS",[[0,1],[1,2],[2,3],[3,7],[0,4],[4,5],[5,6],[6,8],[9,10],[11,12],[11,13],[13,15],[15,17],[15,19],[15,21],[17,19],[12,14],[14,16],[16,18],[16,20],[16,22],[18,20],[11,23],[12,24],[23,24],[23,25],[24,26],[25,27],[26,28],[27,29],[28,30],[29,31],[30,32],[27,31],[28,32]]),T("POSE_LANDMARKS",{NOSE:0,LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,LEFT_EAR:7,RIGHT_EAR:8,LEFT_RIGHT:9,RIGHT_LEFT:10,LEFT_SHOULDER:11,RIGHT_SHOULDER:12,LEFT_ELBOW:13,RIGHT_ELBOW:14,LEFT_WRIST:15,RIGHT_WRIST:16,LEFT_PINKY:17,RIGHT_PINKY:18,LEFT_INDEX:19,RIGHT_INDEX:20,LEFT_THUMB:21,RIGHT_THUMB:22,LEFT_HIP:23,RIGHT_HIP:24,LEFT_KNEE:25,RIGHT_KNEE:26,LEFT_ANKLE:27,RIGHT_ANKLE:28,LEFT_HEEL:29,RIGHT_HEEL:30,LEFT_FOOT_INDEX:31,RIGHT_FOOT_INDEX:32}),T("POSE_LANDMARKS_LEFT",{LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,LEFT_EAR:7,LEFT_RIGHT:9,LEFT_SHOULDER:11,LEFT_ELBOW:13,LEFT_WRIST:15,LEFT_PINKY:17,LEFT_INDEX:19,LEFT_THUMB:21,LEFT_HIP:23,LEFT_KNEE:25,LEFT_ANKLE:27,LEFT_HEEL:29,LEFT_FOOT_INDEX:31}),T("POSE_LANDMARKS_RIGHT",{RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,RIGHT_EAR:8,RIGHT_LEFT:10,RIGHT_SHOULDER:12,RIGHT_ELBOW:14,RIGHT_WRIST:16,RIGHT_PINKY:18,RIGHT_INDEX:20,RIGHT_THUMB:22,RIGHT_HIP:24,RIGHT_KNEE:26,RIGHT_ANKLE:28,RIGHT_HEEL:30,RIGHT_FOOT_INDEX:32}),T("POSE_LANDMARKS_NEUTRAL",{NOSE:0}),T("VERSION","0.5.1675469404")}).call(this)},950(e,t,n){"use strict";!function e(){if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__&&"function"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE)try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)}catch(t){console.error(t)}}(),e.exports=n(730)},996(){}},t={};function n(a){var s=t[a];if(void 0!==s)return s.exports;var r=t[a]={id:a,loaded:!1,exports:{}};return e[a].call(r.exports,r,r.exports,n),r.loaded=!0,r.exports}n.amdD=function(){throw new Error("define cannot be used indirect")},n.amdO={},n.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return n.d(t,{a:t}),t},(()=>{var e,t=Object.getPrototypeOf?e=>Object.getPrototypeOf(e):e=>e.__proto__;n.t=function(a,s){if(1&s&&(a=this(a)),8&s)return a;if("object"===typeof a&&a){if(4&s&&a.__esModule)return a;if(16&s&&"function"===typeof a.then)return a}var r=Object.create(null);n.r(r);var i={};e=e||[null,t({}),t([]),t(t)];for(var o=2&s&&a;("object"==typeof o||"function"==typeof o)&&!~e.indexOf(o);o=t(o))Object.getOwnPropertyNames(o).forEach(e=>i[e]=()=>a[e]);return i.default=()=>a,n.d(r,i),r}})(),n.d=(e,t)=>{for(var a in t)n.o(t,a)&&!n.o(e,a)&&Object.defineProperty(e,a,{enumerable:!0,get:t[a]})},n.g=function(){if("object"===typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"===typeof window)return window}}(),n.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),n.r=e=>{"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.nmd=e=>(e.paths=[],e.children||(e.children=[]),e),(()=>{"use strict";var e={};n.r(e),n.d(e,{CompositeArrayBuffer:()=>Gm,browserFiles:()=>jy,browserHTTPRequest:()=>Yy,concatenateArrayBuffers:()=>hg,copyModel:()=>Qg,decodeWeights:()=>ng,decodeWeightsStream:()=>og,encodeWeights:()=>tg,fromMemory:()=>$y,fromMemorySync:()=>eb,getLoadHandlers:()=>kg,getModelArtifactsForJSON:()=>mg,getModelArtifactsForJSONSync:()=>fg,getModelArtifactsInfoForJSON:()=>gg,getSaveHandlers:()=>wg,getWeightSpecs:()=>yg,http:()=>Xy,isHTTPScheme:()=>qy,listModels:()=>Xg,loadWeights:()=>Uy,moveModel:()=>Zg,registerLoadRouter:()=>vg,registerSaveRouter:()=>xg,removeModel:()=>Yg,weightsLoaderFactory:()=>Hy,withSaveHandler:()=>tb,withSaveHandlerSync:()=>nb});var t={};n.r(t),n.d(t,{assertParamsValid:()=>db,computeFlatOffset:()=>Ib,computeOutShape:()=>fb,getNormalizedAxes:()=>bb,isSliceContinous:()=>Cb,maskToAxes:()=>pb,parseSliceParams:()=>Nb,sliceInfo:()=>Tb,startForAxis:()=>kb,startIndicesWithElidedDims:()=>xb,stopForAxis:()=>Sb,stopIndicesWithElidedDims:()=>vb,stridesForAxis:()=>wb,stridesWithElidedDims:()=>mb});var a={};n.r(a),n.d(a,{conv2d:()=>jk,depthwiseConv2d:()=>Uk,matMul:()=>Hk});var s={};n.r(s),n.d(s,{collectGatherOpShapeInfo:()=>tI,computeOutShape:()=>eI,segOpComputeOptimalWindowSize:()=>$C});var r={};n.r(r),n.d(r,{ERF_A1:()=>yC,ERF_A2:()=>bC,ERF_A3:()=>xC,ERF_A4:()=>vC,ERF_A5:()=>wC,ERF_P:()=>gC,PARALLELIZE_THRESHOLD:()=>rC,RowPartitionType:()=>eC,SELU_SCALE:()=>mC,SELU_SCALEALPHA:()=>fC,applyActivation:()=>zk,assertAndGetBroadcastShape:()=>_y,assertAxesAreInnerMostDims:()=>ev,assertParamsConsistent:()=>JS,assignToTypedArray:()=>TC,axesAreInnerMostDims:()=>Qx,calculateShapes:()=>fk,checkEinsumDimSizes:()=>FC,checkPadOnDimRoundingMode:()=>tx,combineLocations:()=>Zx,combineRaggedTensorToTensorShapes:()=>tC,complexWithEvenIndex:()=>CC,complexWithOddIndex:()=>IC,computeConv2DInfo:()=>Hb,computeConv3DInfo:()=>Gb,computeDefaultPad:()=>qb,computeDilation2DInfo:()=>Wb,computeOptimalWindowSize:()=>iC,computeOutAndReduceShapes:()=>Jx,computeOutShape:()=>$S,computePool2DInfo:()=>Vb,computePool3DInfo:()=>Ub,convertConv2DDataFormat:()=>ex,decodeEinsumEquation:()=>DC,eitherStridesOrDilationsAreOne:()=>Jb,expandShapeToKeepDim:()=>$x,exponent:()=>RC,exponents:()=>EC,fromStringArrayToUint8:()=>aI,fromUint8ToStringArray:()=>nI,getAxesPermutation:()=>tv,getBroadcastDims:()=>Ey,getComplexWithIndex:()=>NC,getEinsumComputePath:()=>LC,getEinsumPermutation:()=>OC,getFusedBiasGradient:()=>Lk,getFusedDyActivation:()=>Fk,getImageCenter:()=>oC,getInnerMostAxes:()=>av,getPermuted:()=>lC,getRaggedRank:()=>aC,getReductionAxes:()=>Ry,getReshaped:()=>cC,getReshapedPermuted:()=>uC,getRowPartitionTypesHelper:()=>nC,getSliceBeginCoords:()=>hC,getSliceSize:()=>dC,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>WC,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>VC,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>UC,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>qC,getSparseReshapeInputOutputMismatchErrorMessage:()=>XC,getSparseReshapeInputOutputMultipleErrorMessage:()=>KC,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>HC,getSparseReshapeNegativeOutputDimErrorMessage:()=>GC,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>JC,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>YC,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>QC,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>ZC,getUndoAxesPermutation:()=>nv,isIdentityPermutation:()=>zC,log:()=>bf,mergeRealAndImagArrays:()=>kC,prepareAndValidate:()=>pC,prepareSplitSize:()=>jC,segment_util:()=>s,shouldFuse:()=>Bk,slice_util:()=>t,splitRealAndImagArrays:()=>SC,stridesOrDilationsArePositive:()=>$b,tupleValuesAreOne:()=>Zb,upcastType:()=>gm,validateDefaultValueShape:()=>sC,validateInput:()=>pk,validateUpdateShape:()=>dk,warn:()=>yf});var i={};n.r(i),n.d(i,{json:()=>EM});var o={};n.r(o),n.d(o,{json:()=>RM});var c={};n.r(c),n.d(c,{json:()=>_M});var l={};n.r(l),n.d(l,{json:()=>AM});var u={};n.r(u),n.d(u,{json:()=>MM});var h={};n.r(h),n.d(h,{json:()=>PM});var d={};n.r(d),n.d(d,{json:()=>DM});var p={};n.r(p),n.d(p,{json:()=>OM});var f={};n.r(f),n.d(f,{json:()=>FM});var m={};n.r(m),n.d(m,{json:()=>LM});var g={};n.r(g),n.d(g,{json:()=>zM});var y={};n.r(y),n.d(y,{json:()=>BM});var b={};n.r(b),n.d(b,{json:()=>jM});var x={};n.r(x),n.d(x,{json:()=>WM});var v={};n.r(v),n.d(v,{json:()=>VM});var w={};n.r(w),n.d(w,{json:()=>UM});var k={};n.r(k),n.d(k,{json:()=>HM});var S={};n.r(S),n.d(S,{json:()=>GM});var C={};n.r(C),n.d(C,{json:()=>qM});var I={};n.r(I),n.d(I,{OP_SCOPE_SUFFIX:()=>Bm,abs:()=>Ty,acos:()=>Rb,acosh:()=>_b,add:()=>iy,addN:()=>Ab,all:()=>Mb,any:()=>Pb,argMax:()=>Db,argMin:()=>Ob,asin:()=>Fb,asinh:()=>Lb,atan:()=>zb,atan2:()=>Bb,atanh:()=>jb,avgPool:()=>ax,avgPool3d:()=>sx,basicLSTMCell:()=>ux,batchNorm:()=>dx,batchNorm2d:()=>px,batchNorm3d:()=>fx,batchNorm4d:()=>mx,batchToSpaceND:()=>hx,bincount:()=>gx,bitwiseAnd:()=>yx,booleanMaskAsync:()=>Ik,broadcastArgs:()=>bx,broadcastTo:()=>xx,buffer:()=>ny,cast:()=>ay,ceil:()=>vx,clipByValue:()=>wx,clone:()=>sy,complex:()=>Wm,concat:()=>rx,concat1d:()=>kx,concat2d:()=>Sx,concat3d:()=>Cx,concat4d:()=>Ix,conv1d:()=>Tx,conv2d:()=>Nx,conv2dTranspose:()=>Rx,conv3d:()=>_x,conv3dTranspose:()=>Mx,cos:()=>Px,cosh:()=>Dx,cosineWindow:()=>Pk,cumprod:()=>Ox,cumsum:()=>Fx,denseBincount:()=>Lx,depthToSpace:()=>zx,depthwiseConv2d:()=>Bx,diag:()=>jx,dilation2d:()=>Wx,div:()=>cy,divNoNan:()=>Hx,dot:()=>Gx,dropout:()=>Ak,einsum:()=>qx,elu:()=>Kx,enclosingPowerOfTwo:()=>Mk,ensureShape:()=>Xx,equal:()=>Vx,erf:()=>Yx,euclideanNorm:()=>lv,exp:()=>uv,expandDims:()=>hv,expm1:()=>dv,eye:()=>fv,fft:()=>Qw,fill:()=>ky,floor:()=>mv,floorDiv:()=>oy,fused:()=>a,gather:()=>gv,gatherND:()=>_k,greater:()=>yv,greaterEqual:()=>bv,ifft:()=>Zw,imag:()=>xv,image:()=>HS,inTopKAsync:()=>Dk,irfft:()=>Jw,isFinite:()=>vv,isInf:()=>wv,isNaN:()=>kv,leakyRelu:()=>Sv,less:()=>Cv,lessEqual:()=>Iv,linalg:()=>GS,linspace:()=>Nv,localResponseNormalization:()=>Tv,log:()=>Ev,log1p:()=>Rv,logSigmoid:()=>Mv,logSoftmax:()=>Pv,logSumExp:()=>Dv,logicalAnd:()=>Ov,logicalNot:()=>Fv,logicalOr:()=>Lv,logicalXor:()=>zv,losses:()=>qS,lowerBound:()=>Wv,matMul:()=>ix,max:()=>sv,maxPool:()=>Vv,maxPool3d:()=>Uv,maxPoolWithArgmax:()=>Hv,maximum:()=>Ay,mean:()=>Gv,meshgrid:()=>Xv,min:()=>rv,minimum:()=>Yv,mirrorPad:()=>Qv,mod:()=>Zv,moments:()=>Jv,movingAverage:()=>Tk,mul:()=>ly,multiRNNCell:()=>$v,multinomial:()=>ew,neg:()=>_v,norm:()=>cv,notEqual:()=>tw,oneHot:()=>nw,ones:()=>Kv,onesLike:()=>aw,op:()=>jm,outerProduct:()=>sw,pad:()=>rw,pad1d:()=>iw,pad2d:()=>ow,pad3d:()=>cw,pad4d:()=>lw,pool:()=>hw,pow:()=>Cy,prelu:()=>dw,print:()=>ry,prod:()=>pw,raggedGather:()=>fw,raggedRange:()=>mw,raggedTensorToTensor:()=>gw,rand:()=>yw,randomGamma:()=>kw,randomNormal:()=>Sw,randomStandardNormal:()=>Cw,randomUniform:()=>Iw,randomUniformInt:()=>Nw,range:()=>Tw,real:()=>Ew,reciprocal:()=>Rw,relu:()=>_w,relu6:()=>Aw,reshape:()=>nx,reverse:()=>Mw,reverse1d:()=>Pw,reverse2d:()=>Dw,reverse3d:()=>Ow,reverse4d:()=>Fw,rfft:()=>ek,round:()=>Lw,rsqrt:()=>zw,scalar:()=>fy,scatterND:()=>Ek,searchSorted:()=>jv,selu:()=>Bw,separableConv2d:()=>jw,setdiff1dAsync:()=>Ww,sigmoid:()=>ox,sign:()=>Vw,signal:()=>US,sin:()=>Uw,sinh:()=>Hw,slice:()=>cx,slice1d:()=>Gw,slice2d:()=>qw,slice3d:()=>Kw,slice4d:()=>Xw,softmax:()=>Yw,softplus:()=>Av,spaceToBatchND:()=>uw,sparse:()=>KS,sparseToDense:()=>Rk,spectral:()=>VS,split:()=>$w,sqrt:()=>uy,square:()=>hy,squaredDifference:()=>tk,squeeze:()=>nk,stack:()=>ak,step:()=>sk,stridedSlice:()=>rk,string:()=>XS,sub:()=>Iy,sum:()=>iv,tan:()=>ik,tanh:()=>lx,tensor:()=>Um,tensor1d:()=>ok,tensor2d:()=>ck,tensor3d:()=>ab,tensor4d:()=>lk,tensor5d:()=>uk,tensor6d:()=>hk,tensorScatterUpdate:()=>mk,tile:()=>pv,topk:()=>gk,transpose:()=>Nk,truncatedNormal:()=>yk,unique:()=>bk,unsortedSegmentSum:()=>xk,unstack:()=>vk,upperBound:()=>wk,variable:()=>kk,where:()=>Ux,whereAsync:()=>Ck,zeros:()=>qv,zerosLike:()=>dy});var N={};n.r(N),n.d(N,{mx:()=>KD,XI:()=>BO,Nk:()=>jO,f6:()=>VO,ct:()=>VD,YG:()=>qO,hH:()=>JO,z3:()=>FF,sG:()=>KF,uM:()=>JF,C1:()=>bL,vS:()=>mL,qB:()=>SL,GG:()=>IL,lg:()=>_L,rq:()=>TL,cu:()=>UL,WR:()=>jL,GE:()=>qL,px:()=>XL,jC:()=>lz,He:()=>dz,hE:()=>kz,BF:()=>EF,Dk:()=>Mz,cl:()=>jz,_B:()=>$z,ub:()=>sB,_f:()=>oB,Ku:()=>pB,qy:()=>mB,Zy:()=>TB,bu:()=>_B,zv:()=>PD,dH:()=>nO,HS:()=>OO,yH:()=>QB,l3:()=>JB,z9:()=>ej,x6:()=>rj,_m:()=>dj,eW:()=>yj,GK:()=>vj,SP:()=>Sj,yr:()=>Ij,dl:()=>sL,Dw:()=>Aj,xT:()=>Oj,_X:()=>lO,wz:()=>Vj});var T,E=n(43),R=n.t(E,2),_=n(391),A=n(950),M=n.t(A,2);function P(){return P=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},P.apply(this,arguments)}!function(e){e.Pop="POP",e.Push="PUSH",e.Replace="REPLACE"}(T||(T={}));const D="popstate";function O(e,t){if(!1===e||null===e||"undefined"===typeof e)throw new Error(t)}function F(e,t){if(!e){"undefined"!==typeof console&&console.warn(t);try{throw new Error(t)}catch(n){}}}function L(e,t){return{usr:e.state,key:e.key,idx:t}}function z(e,t,n,a){return void 0===n&&(n=null),P({pathname:"string"===typeof e?e:e.pathname,search:"",hash:""},"string"===typeof t?j(t):t,{state:n,key:t&&t.key||a||Math.random().toString(36).substr(2,8)})}function B(e){let{pathname:t="/",search:n="",hash:a=""}=e;return n&&"?"!==n&&(t+="?"===n.charAt(0)?n:"?"+n),a&&"#"!==a&&(t+="#"===a.charAt(0)?a:"#"+a),t}function j(e){let t={};if(e){let n=e.indexOf("#");n>=0&&(t.hash=e.substr(n),e=e.substr(0,n));let a=e.indexOf("?");a>=0&&(t.search=e.substr(a),e=e.substr(0,a)),e&&(t.pathname=e)}return t}function W(e,t,n,a){void 0===a&&(a={});let{window:s=document.defaultView,v5Compat:r=!1}=a,i=s.history,o=T.Pop,c=null,l=u();function u(){return(i.state||{idx:null}).idx}function h(){o=T.Pop;let e=u(),t=null==e?null:e-l;l=e,c&&c({action:o,location:p.location,delta:t})}function d(e){let t="null"!==s.location.origin?s.location.origin:s.location.href,n="string"===typeof e?e:B(e);return n=n.replace(/ $/,"%20"),O(t,"No window.location.(origin|href) available to create URL for href: "+n),new URL(n,t)}null==l&&(l=0,i.replaceState(P({},i.state,{idx:l}),""));let p={get action(){return o},get location(){return e(s,i)},listen(e){if(c)throw new Error("A history only accepts one active listener");return s.addEventListener(D,h),c=e,()=>{s.removeEventListener(D,h),c=null}},createHref:e=>t(s,e),createURL:d,encodeLocation(e){let t=d(e);return{pathname:t.pathname,search:t.search,hash:t.hash}},push:function(e,t){o=T.Push;let a=z(p.location,e,t);n&&n(a,e),l=u()+1;let h=L(a,l),d=p.createHref(a);try{i.pushState(h,"",d)}catch(f){if(f instanceof DOMException&&"DataCloneError"===f.name)throw f;s.location.assign(d)}r&&c&&c({action:o,location:p.location,delta:1})},replace:function(e,t){o=T.Replace;let a=z(p.location,e,t);n&&n(a,e),l=u();let s=L(a,l),h=p.createHref(a);i.replaceState(s,"",h),r&&c&&c({action:o,location:p.location,delta:0})},go:e=>i.go(e)};return p}var V;!function(e){e.data="data",e.deferred="deferred",e.redirect="redirect",e.error="error"}(V||(V={}));new Set(["lazy","caseSensitive","path","id","index","children"]);function U(e,t,n){return void 0===n&&(n="/"),H(e,t,n,!1)}function H(e,t,n,a){let s=se(("string"===typeof t?j(t):t).pathname||"/",n);if(null==s)return null;let r=G(e);!function(e){e.sort((e,t)=>e.score!==t.score?t.score-e.score:function(e,t){let n=e.length===t.length&&e.slice(0,-1).every((e,n)=>e===t[n]);return n?e[e.length-1]-t[t.length-1]:0}(e.routesMeta.map(e=>e.childrenIndex),t.routesMeta.map(e=>e.childrenIndex)))}(r);let i=null;for(let o=0;null==i&&o<r.length;++o){let e=ae(s);i=te(r[o],e,a)}return i}function G(e,t,n,a){void 0===t&&(t=[]),void 0===n&&(n=[]),void 0===a&&(a="");let s=(e,s,r)=>{let i={relativePath:void 0===r?e.path||"":r,caseSensitive:!0===e.caseSensitive,childrenIndex:s,route:e};i.relativePath.startsWith("/")&&(O(i.relativePath.startsWith(a),'Absolute route path "'+i.relativePath+'" nested under path "'+a+'" is not valid. An absolute child route path must start with the combined path of all its parent routes.'),i.relativePath=i.relativePath.slice(a.length));let o=de([a,i.relativePath]),c=n.concat(i);e.children&&e.children.length>0&&(O(!0!==e.index,'Index routes must not have child routes. Please remove all child routes from route path "'+o+'".'),G(e.children,t,c,o)),(null!=e.path||e.index)&&t.push({path:o,score:ee(o,e.index),routesMeta:c})};return e.forEach((e,t)=>{var n;if(""!==e.path&&null!=(n=e.path)&&n.includes("?"))for(let a of q(e.path))s(e,t,a);else s(e,t)}),t}function q(e){let t=e.split("/");if(0===t.length)return[];let[n,...a]=t,s=n.endsWith("?"),r=n.replace(/\?$/,"");if(0===a.length)return s?[r,""]:[r];let i=q(a.join("/")),o=[];return o.push(...i.map(e=>""===e?r:[r,e].join("/"))),s&&o.push(...i),o.map(t=>e.startsWith("/")&&""===t?"/":t)}const K=/^:[\w-]+$/,X=3,Y=2,Q=1,Z=10,J=-2,$=e=>"*"===e;function ee(e,t){let n=e.split("/"),a=n.length;return n.some($)&&(a+=J),t&&(a+=Y),n.filter(e=>!$(e)).reduce((e,t)=>e+(K.test(t)?X:""===t?Q:Z),a)}function te(e,t,n){void 0===n&&(n=!1);let{routesMeta:a}=e,s={},r="/",i=[];for(let o=0;o<a.length;++o){let e=a[o],c=o===a.length-1,l="/"===r?t:t.slice(r.length)||"/",u=ne({path:e.relativePath,caseSensitive:e.caseSensitive,end:c},l),h=e.route;if(!u&&c&&n&&!a[a.length-1].route.index&&(u=ne({path:e.relativePath,caseSensitive:e.caseSensitive,end:!1},l)),!u)return null;Object.assign(s,u.params),i.push({params:s,pathname:de([r,u.pathname]),pathnameBase:pe(de([r,u.pathnameBase])),route:h}),"/"!==u.pathnameBase&&(r=de([r,u.pathnameBase]))}return i}function ne(e,t){"string"===typeof e&&(e={path:e,caseSensitive:!1,end:!0});let[n,a]=function(e,t,n){void 0===t&&(t=!1);void 0===n&&(n=!0);F("*"===e||!e.endsWith("*")||e.endsWith("/*"),'Route path "'+e+'" will be treated as if it were "'+e.replace(/\*$/,"/*")+'" because the `*` character must always follow a `/` in the pattern. To get rid of this warning, please change the route path to "'+e.replace(/\*$/,"/*")+'".');let a=[],s="^"+e.replace(/\/*\*?$/,"").replace(/^\/*/,"/").replace(/[\\.*+^${}|()[\]]/g,"\\$&").replace(/\/:([\w-]+)(\?)?/g,(e,t,n)=>(a.push({paramName:t,isOptional:null!=n}),n?"/?([^\\/]+)?":"/([^\\/]+)"));e.endsWith("*")?(a.push({paramName:"*"}),s+="*"===e||"/*"===e?"(.*)$":"(?:\\/(.+)|\\/*)$"):n?s+="\\/*$":""!==e&&"/"!==e&&(s+="(?:(?=\\/|$))");let r=new RegExp(s,t?void 0:"i");return[r,a]}(e.path,e.caseSensitive,e.end),s=t.match(n);if(!s)return null;let r=s[0],i=r.replace(/(.)\/+$/,"$1"),o=s.slice(1),c=a.reduce((e,t,n)=>{let{paramName:a,isOptional:s}=t;if("*"===a){let e=o[n]||"";i=r.slice(0,r.length-e.length).replace(/(.)\/+$/,"$1")}const c=o[n];return e[a]=s&&!c?void 0:(c||"").replace(/%2F/g,"/"),e},{});return{params:c,pathname:r,pathnameBase:i,pattern:e}}function ae(e){try{return e.split("/").map(e=>decodeURIComponent(e).replace(/\//g,"%2F")).join("/")}catch(t){return F(!1,'The URL path "'+e+'" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent encoding ('+t+")."),e}}function se(e,t){if("/"===t)return e;if(!e.toLowerCase().startsWith(t.toLowerCase()))return null;let n=t.endsWith("/")?t.length-1:t.length,a=e.charAt(n);return a&&"/"!==a?null:e.slice(n)||"/"}const re=/^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;function ie(e,t){void 0===t&&(t="/");let n,{pathname:a,search:s="",hash:r=""}="string"===typeof e?j(e):e;if(a)if(i=a,re.test(i))n=a;else{if(a.includes("//")){let e=a;a=a.replace(/\/\/+/g,"/"),F(!1,"Pathnames cannot have embedded double slashes - normalizing "+e+" -> "+a)}n=a.startsWith("/")?oe(a.substring(1),"/"):oe(a,t)}else n=t;var i;return{pathname:n,search:fe(s),hash:me(r)}}function oe(e,t){let n=t.replace(/\/+$/,"").split("/");return e.split("/").forEach(e=>{".."===e?n.length>1&&n.pop():"."!==e&&n.push(e)}),n.length>1?n.join("/"):"/"}function ce(e,t,n,a){return"Cannot include a '"+e+"' character in a manually specified `to."+t+"` field ["+JSON.stringify(a)+"].  Please separate it out to the `to."+n+'` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.'}function le(e){return e.filter((e,t)=>0===t||e.route.path&&e.route.path.length>0)}function ue(e,t){let n=le(e);return t?n.map((e,t)=>t===n.length-1?e.pathname:e.pathnameBase):n.map(e=>e.pathnameBase)}function he(e,t,n,a){let s;void 0===a&&(a=!1),"string"===typeof e?s=j(e):(s=P({},e),O(!s.pathname||!s.pathname.includes("?"),ce("?","pathname","search",s)),O(!s.pathname||!s.pathname.includes("#"),ce("#","pathname","hash",s)),O(!s.search||!s.search.includes("#"),ce("#","search","hash",s)));let r,i=""===e||""===s.pathname,o=i?"/":s.pathname;if(null==o)r=n;else{let e=t.length-1;if(!a&&o.startsWith("..")){let t=o.split("/");for(;".."===t[0];)t.shift(),e-=1;s.pathname=t.join("/")}r=e>=0?t[e]:"/"}let c=ie(s,r),l=o&&"/"!==o&&o.endsWith("/"),u=(i||"."===o)&&n.endsWith("/");return c.pathname.endsWith("/")||!l&&!u||(c.pathname+="/"),c}const de=e=>e.join("/").replace(/\/\/+/g,"/"),pe=e=>e.replace(/\/+$/,"").replace(/^\/*/,"/"),fe=e=>e&&"?"!==e?e.startsWith("?")?e:"?"+e:"",me=e=>e&&"#"!==e?e.startsWith("#")?e:"#"+e:"";Error;function ge(e){return null!=e&&"number"===typeof e.status&&"string"===typeof e.statusText&&"boolean"===typeof e.internal&&"data"in e}const ye=["post","put","patch","delete"],be=(new Set(ye),["get",...ye]);new Set(be),new Set([301,302,303,307,308]),new Set([307,308]);Symbol("deferred");function xe(){return xe=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},xe.apply(this,arguments)}const ve=E.createContext(null);const we=E.createContext(null);const ke=E.createContext(null);const Se=E.createContext(null);const Ce=E.createContext({outlet:null,matches:[],isDataRoute:!1});const Ie=E.createContext(null);function Ne(){return null!=E.useContext(Se)}function Te(){return Ne()||O(!1),E.useContext(Se).location}function Ee(e){E.useContext(ke).static||E.useLayoutEffect(e)}function Re(){let{isDataRoute:e}=E.useContext(Ce);return e?function(){let{router:e}=je(ze.UseNavigateStable),t=Ve(Be.UseNavigateStable),n=E.useRef(!1);Ee(()=>{n.current=!0});let a=E.useCallback(function(a,s){void 0===s&&(s={}),n.current&&("number"===typeof a?e.navigate(a):e.navigate(a,xe({fromRouteId:t},s)))},[e,t]);return a}():function(){Ne()||O(!1);let e=E.useContext(ve),{basename:t,future:n,navigator:a}=E.useContext(ke),{matches:s}=E.useContext(Ce),{pathname:r}=Te(),i=JSON.stringify(ue(s,n.v7_relativeSplatPath)),o=E.useRef(!1);Ee(()=>{o.current=!0});let c=E.useCallback(function(n,s){if(void 0===s&&(s={}),!o.current)return;if("number"===typeof n)return void a.go(n);let c=he(n,JSON.parse(i),r,"path"===s.relative);null==e&&"/"!==t&&(c.pathname="/"===c.pathname?t:de([t,c.pathname])),(s.replace?a.replace:a.push)(c,s.state,s)},[t,a,i,r,e]);return c}()}function _e(){let{matches:e}=E.useContext(Ce),t=e[e.length-1];return t?t.params:{}}function Ae(e,t){let{relative:n}=void 0===t?{}:t,{future:a}=E.useContext(ke),{matches:s}=E.useContext(Ce),{pathname:r}=Te(),i=JSON.stringify(ue(s,a.v7_relativeSplatPath));return E.useMemo(()=>he(e,JSON.parse(i),r,"path"===n),[e,i,r,n])}function Me(e,t,n,a){Ne()||O(!1);let{navigator:s}=E.useContext(ke),{matches:r}=E.useContext(Ce),i=r[r.length-1],o=i?i.params:{},c=(i&&i.pathname,i?i.pathnameBase:"/");i&&i.route;let l,u=Te();if(t){var h;let e="string"===typeof t?j(t):t;"/"===c||(null==(h=e.pathname)?void 0:h.startsWith(c))||O(!1),l=e}else l=u;let d=l.pathname||"/",p=d;if("/"!==c){let e=c.replace(/^\//,"").split("/");p="/"+d.replace(/^\//,"").split("/").slice(e.length).join("/")}let f=U(e,{pathname:p});let m=Le(f&&f.map(e=>Object.assign({},e,{params:Object.assign({},o,e.params),pathname:de([c,s.encodeLocation?s.encodeLocation(e.pathname).pathname:e.pathname]),pathnameBase:"/"===e.pathnameBase?c:de([c,s.encodeLocation?s.encodeLocation(e.pathnameBase).pathname:e.pathnameBase])})),r,n,a);return t&&m?E.createElement(Se.Provider,{value:{location:xe({pathname:"/",search:"",hash:"",state:null,key:"default"},l),navigationType:T.Pop}},m):m}function Pe(){let e=function(){var e;let t=E.useContext(Ie),n=We(Be.UseRouteError),a=Ve(Be.UseRouteError);if(void 0!==t)return t;return null==(e=n.errors)?void 0:e[a]}(),t=ge(e)?e.status+" "+e.statusText:e instanceof Error?e.message:JSON.stringify(e),n=e instanceof Error?e.stack:null,a="rgba(200,200,200, 0.5)",s={padding:"0.5rem",backgroundColor:a};return E.createElement(E.Fragment,null,E.createElement("h2",null,"Unexpected Application Error!"),E.createElement("h3",{style:{fontStyle:"italic"}},t),n?E.createElement("pre",{style:s},n):null,null)}const De=E.createElement(Pe,null);class Oe extends E.Component{constructor(e){super(e),this.state={location:e.location,revalidation:e.revalidation,error:e.error}}static getDerivedStateFromError(e){return{error:e}}static getDerivedStateFromProps(e,t){return t.location!==e.location||"idle"!==t.revalidation&&"idle"===e.revalidation?{error:e.error,location:e.location,revalidation:e.revalidation}:{error:void 0!==e.error?e.error:t.error,location:t.location,revalidation:e.revalidation||t.revalidation}}componentDidCatch(e,t){console.error("React Router caught the following error during render",e,t)}render(){return void 0!==this.state.error?E.createElement(Ce.Provider,{value:this.props.routeContext},E.createElement(Ie.Provider,{value:this.state.error,children:this.props.component})):this.props.children}}function Fe(e){let{routeContext:t,match:n,children:a}=e,s=E.useContext(ve);return s&&s.static&&s.staticContext&&(n.route.errorElement||n.route.ErrorBoundary)&&(s.staticContext._deepestRenderedBoundaryId=n.route.id),E.createElement(Ce.Provider,{value:t},a)}function Le(e,t,n,a){var s;if(void 0===t&&(t=[]),void 0===n&&(n=null),void 0===a&&(a=null),null==e){var r;if(!n)return null;if(n.errors)e=n.matches;else{if(!(null!=(r=a)&&r.v7_partialHydration&&0===t.length&&!n.initialized&&n.matches.length>0))return null;e=n.matches}}let i=e,o=null==(s=n)?void 0:s.errors;if(null!=o){let e=i.findIndex(e=>e.route.id&&void 0!==(null==o?void 0:o[e.route.id]));e>=0||O(!1),i=i.slice(0,Math.min(i.length,e+1))}let c=!1,l=-1;if(n&&a&&a.v7_partialHydration)for(let u=0;u<i.length;u++){let e=i[u];if((e.route.HydrateFallback||e.route.hydrateFallbackElement)&&(l=u),e.route.id){let{loaderData:t,errors:a}=n,s=e.route.loader&&void 0===t[e.route.id]&&(!a||void 0===a[e.route.id]);if(e.route.lazy||s){c=!0,i=l>=0?i.slice(0,l+1):[i[0]];break}}}return i.reduceRight((e,a,s)=>{let r,u=!1,h=null,d=null;var p;n&&(r=o&&a.route.id?o[a.route.id]:void 0,h=a.route.errorElement||De,c&&(l<0&&0===s?(p="route-fallback",!1||Ue[p]||(Ue[p]=!0),u=!0,d=null):l===s&&(u=!0,d=a.route.hydrateFallbackElement||null)));let f=t.concat(i.slice(0,s+1)),m=()=>{let t;return t=r?h:u?d:a.route.Component?E.createElement(a.route.Component,null):a.route.element?a.route.element:e,E.createElement(Fe,{match:a,routeContext:{outlet:e,matches:f,isDataRoute:null!=n},children:t})};return n&&(a.route.ErrorBoundary||a.route.errorElement||0===s)?E.createElement(Oe,{location:n.location,revalidation:n.revalidation,component:h,error:r,children:m(),routeContext:{outlet:null,matches:f,isDataRoute:!0}}):m()},null)}var ze=function(e){return e.UseBlocker="useBlocker",e.UseRevalidator="useRevalidator",e.UseNavigateStable="useNavigate",e}(ze||{}),Be=function(e){return e.UseBlocker="useBlocker",e.UseLoaderData="useLoaderData",e.UseActionData="useActionData",e.UseRouteError="useRouteError",e.UseNavigation="useNavigation",e.UseRouteLoaderData="useRouteLoaderData",e.UseMatches="useMatches",e.UseRevalidator="useRevalidator",e.UseNavigateStable="useNavigate",e.UseRouteId="useRouteId",e}(Be||{});function je(e){let t=E.useContext(ve);return t||O(!1),t}function We(e){let t=E.useContext(we);return t||O(!1),t}function Ve(e){let t=function(){let e=E.useContext(Ce);return e||O(!1),e}(),n=t.matches[t.matches.length-1];return n.route.id||O(!1),n.route.id}const Ue={};function He(e,t){null==e||e.v7_startTransition,void 0===(null==e?void 0:e.v7_relativeSplatPath)&&(!t||t.v7_relativeSplatPath),t&&(t.v7_fetcherPersist,t.v7_normalizeFormMethod,t.v7_partialHydration,t.v7_skipActionErrorRevalidation)}R.startTransition;function Ge(e){O(!1)}function qe(e){let{basename:t="/",children:n=null,location:a,navigationType:s=T.Pop,navigator:r,static:i=!1,future:o}=e;Ne()&&O(!1);let c=t.replace(/^\/*/,"/"),l=E.useMemo(()=>({basename:c,navigator:r,static:i,future:xe({v7_relativeSplatPath:!1},o)}),[c,o,r,i]);"string"===typeof a&&(a=j(a));let{pathname:u="/",search:h="",hash:d="",state:p=null,key:f="default"}=a,m=E.useMemo(()=>{let e=se(u,c);return null==e?null:{location:{pathname:e,search:h,hash:d,state:p,key:f},navigationType:s}},[c,u,h,d,p,f,s]);return null==m?null:E.createElement(ke.Provider,{value:l},E.createElement(Se.Provider,{children:n,value:m}))}function Ke(e){let{children:t,location:n}=e;return Me(Xe(t),n)}new Promise(()=>{});E.Component;function Xe(e,t){void 0===t&&(t=[]);let n=[];return E.Children.forEach(e,(e,a)=>{if(!E.isValidElement(e))return;let s=[...t,a];if(e.type===E.Fragment)return void n.push.apply(n,Xe(e.props.children,s));e.type!==Ge&&O(!1),e.props.index&&e.props.children&&O(!1);let r={id:e.props.id||s.join("-"),caseSensitive:e.props.caseSensitive,element:e.props.element,Component:e.props.Component,index:e.props.index,path:e.props.path,loader:e.props.loader,action:e.props.action,errorElement:e.props.errorElement,ErrorBoundary:e.props.ErrorBoundary,hasErrorBoundary:null!=e.props.ErrorBoundary||null!=e.props.errorElement,shouldRevalidate:e.props.shouldRevalidate,handle:e.props.handle,lazy:e.props.lazy};e.props.children&&(r.children=Xe(e.props.children,s)),n.push(r)}),n}function Ye(){return Ye=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},Ye.apply(this,arguments)}function Qe(e,t){if(null==e)return{};var n,a,s={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(s[n]=e[n]);return s}new Set(["application/x-www-form-urlencoded","multipart/form-data","text/plain"]);const Ze=["onClick","relative","reloadDocument","replace","state","target","to","preventScrollReset","viewTransition"];try{window.__reactRouterVersion="6"}catch(q5){}new Map;const Je=R.startTransition;M.flushSync,R.useId;function $e(e){let{basename:t,children:n,future:a,window:s}=e,r=E.useRef();var i;null==r.current&&(r.current=(void 0===(i={window:s,v5Compat:!0})&&(i={}),W(function(e,t){let{pathname:n,search:a,hash:s}=e.location;return z("",{pathname:n,search:a,hash:s},t.state&&t.state.usr||null,t.state&&t.state.key||"default")},function(e,t){return"string"===typeof t?t:B(t)},null,i)));let o=r.current,[c,l]=E.useState({action:o.action,location:o.location}),{v7_startTransition:u}=a||{},h=E.useCallback(e=>{u&&Je?Je(()=>l(e)):l(e)},[l,u]);return E.useLayoutEffect(()=>o.listen(h),[o,h]),E.useEffect(()=>He(a),[a]),E.createElement(qe,{basename:t,children:n,location:c.location,navigationType:c.action,navigator:o,future:a})}const et="undefined"!==typeof window&&"undefined"!==typeof window.document&&"undefined"!==typeof window.document.createElement,tt=/^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,nt=E.forwardRef(function(e,t){let n,{onClick:a,relative:s,reloadDocument:r,replace:i,state:o,target:c,to:l,preventScrollReset:u,viewTransition:h}=e,d=Qe(e,Ze),{basename:p}=E.useContext(ke),f=!1;if("string"===typeof l&&tt.test(l)&&(n=l,et))try{let e=new URL(window.location.href),t=l.startsWith("//")?new URL(e.protocol+l):new URL(l),n=se(t.pathname,p);t.origin===e.origin&&null!=n?l=n+t.search+t.hash:f=!0}catch(q5){}let m=function(e,t){let{relative:n}=void 0===t?{}:t;Ne()||O(!1);let{basename:a,navigator:s}=E.useContext(ke),{hash:r,pathname:i,search:o}=Ae(e,{relative:n}),c=i;return"/"!==a&&(c="/"===i?a:de([a,i])),s.createHref({pathname:c,search:o,hash:r})}(l,{relative:s}),g=function(e,t){let{target:n,replace:a,state:s,preventScrollReset:r,relative:i,viewTransition:o}=void 0===t?{}:t,c=Re(),l=Te(),u=Ae(e,{relative:i});return E.useCallback(t=>{if(function(e,t){return 0===e.button&&(!t||"_self"===t)&&!function(e){return!!(e.metaKey||e.altKey||e.ctrlKey||e.shiftKey)}(e)}(t,n)){t.preventDefault();let n=void 0!==a?a:B(l)===B(u);c(e,{replace:n,state:s,preventScrollReset:r,relative:i,viewTransition:o})}},[l,c,u,a,s,n,e,r,i,o])}(l,{replace:i,state:o,target:c,preventScrollReset:u,relative:s,viewTransition:h});return E.createElement("a",Ye({},d,{href:n||m,onClick:f||r?a:function(e){a&&a(e),e.defaultPrevented||g(e)},ref:t,target:c}))});var at,st;(function(e){e.UseScrollRestoration="useScrollRestoration",e.UseSubmit="useSubmit",e.UseSubmitFetcher="useSubmitFetcher",e.UseFetcher="useFetcher",e.useViewTransitionState="useViewTransitionState"})(at||(at={})),function(e){e.UseFetcher="useFetcher",e.UseFetchers="useFetchers",e.UseScrollRestoration="useScrollRestoration"}(st||(st={}));var rt={color:void 0,size:void 0,className:void 0,style:void 0,attr:void 0},it=E.createContext&&E.createContext(rt),ot=function(){return ot=Object.assign||function(e){for(var t,n=1,a=arguments.length;n<a;n++)for(var s in t=arguments[n])Object.prototype.hasOwnProperty.call(t,s)&&(e[s]=t[s]);return e},ot.apply(this,arguments)},ct=function(e,t){var n={};for(var a in e)Object.prototype.hasOwnProperty.call(e,a)&&t.indexOf(a)<0&&(n[a]=e[a]);if(null!=e&&"function"===typeof Object.getOwnPropertySymbols){var s=0;for(a=Object.getOwnPropertySymbols(e);s<a.length;s++)t.indexOf(a[s])<0&&Object.prototype.propertyIsEnumerable.call(e,a[s])&&(n[a[s]]=e[a[s]])}return n};function lt(e){return e&&e.map(function(e,t){return E.createElement(e.tag,ot({key:t},e.attr),lt(e.child))})}function ut(e){return function(t){return E.createElement(ht,ot({attr:ot({},e.attr)},t),lt(e.child))}}function ht(e){var t=function(t){var n,a=e.attr,s=e.size,r=e.title,i=ct(e,["attr","size","title"]),o=s||t.size||"1em";return t.className&&(n=t.className),e.className&&(n=(n?n+" ":"")+e.className),E.createElement("svg",ot({stroke:"currentColor",fill:"currentColor",strokeWidth:"0"},t.attr,a,i,{className:n,style:ot(ot({color:e.color||t.color},t.style),e.style),height:o,width:o,xmlns:"http://www.w3.org/2000/svg"}),r&&E.createElement("title",null,r),e.children)};return void 0!==it?E.createElement(it.Consumer,null,function(e){return t(e)}):t(rt)}function dt(e){return ut({tag:"svg",attr:{viewBox:"0 0 384 512"},child:[{tag:"path",attr:{d:"M0 32l34.9 395.8L192 480l157.1-52.2L384 32H0zm313.1 80l-4.8 47.3L193 208.6l-.3.1h111.5l-12.8 146.6-98.2 28.7-98.8-29.2-6.4-73.9h48.9l3.2 38.3 52.6 13.3 54.7-15.4 3.7-61.6-166.3-.5v-.1l-.2.1-3.6-46.3L193.1 162l6.5-2.7H76.7L70.9 112h242.2z"}}]})(e)}function pt(e){return ut({tag:"svg",attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{d:"M504 256C504 119 393 8 256 8S8 119 8 256c0 123.78 90.69 226.38 209.25 245V327.69h-63V256h63v-54.64c0-62.15 37-96.48 93.67-96.48 27.14 0 55.52 4.84 55.52 4.84v61h-31.28c-30.8 0-40.41 19.12-40.41 38.73V256h68.78l-11 71.69h-57.78V501C413.31 482.38 504 379.78 504 256z"}}]})(e)}function ft(e){return ut({tag:"svg",attr:{viewBox:"0 0 496 512"},child:[{tag:"path",attr:{d:"M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"}}]})(e)}function mt(e){return ut({tag:"svg",attr:{viewBox:"0 0 488 512"},child:[{tag:"path",attr:{d:"M488 261.8C488 403.3 391.1 504 248 504 110.8 504 0 393.2 0 256S110.8 8 248 8c66.8 0 123 24.5 166.3 64.9l-67.5 64.9C258.5 52.6 94.3 116.6 94.3 256c0 86.5 69.1 156.6 153.7 156.6 98.2 0 135-70.4 140.8-106.9H248v-85.3h236.1c2.3 12.7 3.9 24.9 3.9 41.4z"}}]})(e)}function gt(e){return ut({tag:"svg",attr:{viewBox:"0 0 384 512"},child:[{tag:"path",attr:{d:"M0 32l34.9 395.8L191.5 480l157.6-52.2L384 32H0zm308.2 127.9H124.4l4.1 49.4h175.6l-13.6 148.4-97.9 27v.3h-1.1l-98.7-27.3-6-75.8h47.7L138 320l53.5 14.5 53.7-14.5 6-62.2H84.3L71.5 112.2h241.1l-4.4 47.7z"}}]})(e)}function yt(e){return ut({tag:"svg",attr:{viewBox:"0 0 448 512"},child:[{tag:"path",attr:{d:"M224.1 141c-63.6 0-114.9 51.3-114.9 114.9s51.3 114.9 114.9 114.9S339 319.5 339 255.9 287.7 141 224.1 141zm0 189.6c-41.1 0-74.7-33.5-74.7-74.7s33.5-74.7 74.7-74.7 74.7 33.5 74.7 74.7-33.6 74.7-74.7 74.7zm146.4-194.3c0 14.9-12 26.8-26.8 26.8-14.9 0-26.8-12-26.8-26.8s12-26.8 26.8-26.8 26.8 12 26.8 26.8zm76.1 27.2c-1.7-35.9-9.9-67.7-36.2-93.9-26.2-26.2-58-34.4-93.9-36.2-37-2.1-147.9-2.1-184.9 0-35.8 1.7-67.6 9.9-93.9 36.1s-34.4 58-36.2 93.9c-2.1 37-2.1 147.9 0 184.9 1.7 35.9 9.9 67.7 36.2 93.9s58 34.4 93.9 36.2c37 2.1 147.9 2.1 184.9 0 35.9-1.7 67.7-9.9 93.9-36.2 26.2-26.2 34.4-58 36.2-93.9 2.1-37 2.1-147.8 0-184.8zM398.8 388c-7.8 19.6-22.9 34.7-42.6 42.6-29.5 11.7-99.5 9-132.1 9s-102.7 2.6-132.1-9c-19.6-7.8-34.7-22.9-42.6-42.6-11.7-29.5-9-99.5-9-132.1s-2.6-102.7 9-132.1c7.8-19.6 22.9-34.7 42.6-42.6 29.5-11.7 99.5-9 132.1-9s102.7-2.6 132.1 9c19.6 7.8 34.7 22.9 42.6 42.6 11.7 29.5 9 99.5 9 132.1s2.7 102.7-9 132.1z"}}]})(e)}function bt(e){return ut({tag:"svg",attr:{viewBox:"0 0 448 512"},child:[{tag:"path",attr:{d:"M0 32v448h448V32H0zm243.8 349.4c0 43.6-25.6 63.5-62.9 63.5-33.7 0-53.2-17.4-63.2-38.5l34.3-20.7c6.6 11.7 12.6 21.6 27.1 21.6 13.8 0 22.6-5.4 22.6-26.5V237.7h42.1v143.7zm99.6 63.5c-39.1 0-64.4-18.6-76.7-43l34.3-19.8c9 14.7 20.8 25.6 41.5 25.6 17.4 0 28.6-8.7 28.6-20.8 0-14.4-11.4-19.5-30.7-28l-10.5-4.5c-30.4-12.9-50.5-29.2-50.5-63.5 0-31.6 24.1-55.6 61.6-55.6 26.8 0 46 9.3 59.8 33.7L368 290c-7.2-12.9-15-18-27.1-18-12.3 0-20.1 7.8-20.1 18 0 12.6 7.8 17.7 25.9 25.6l10.5 4.5c35.8 15.3 55.9 31 55.9 66.2 0 37.8-29.8 58.6-69.7 58.6z"}}]})(e)}function xt(e){return ut({tag:"svg",attr:{viewBox:"0 0 448 512"},child:[{tag:"path",attr:{d:"M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"}}]})(e)}function vt(e){return ut({tag:"svg",attr:{viewBox:"0 0 448 512"},child:[{tag:"path",attr:{d:"M224 508c-6.7 0-13.5-1.8-19.4-5.2l-61.7-36.5c-9.2-5.2-4.7-7-1.7-8 12.3-4.3 14.8-5.2 27.9-12.7 1.4-.8 3.2-.5 4.6.4l47.4 28.1c1.7 1 4.1 1 5.7 0l184.7-106.6c1.7-1 2.8-3 2.8-5V149.3c0-2.1-1.1-4-2.9-5.1L226.8 37.7c-1.7-1-4-1-5.7 0L36.6 144.3c-1.8 1-2.9 3-2.9 5.1v213.1c0 2 1.1 4 2.9 4.9l50.6 29.2c27.5 13.7 44.3-2.4 44.3-18.7V167.5c0-3 2.4-5.3 5.4-5.3h23.4c2.9 0 5.4 2.3 5.4 5.3V378c0 36.6-20 57.6-54.7 57.6-10.7 0-19.1 0-42.5-11.6l-48.4-27.9C8.1 389.2.7 376.3.7 362.4V149.3c0-13.8 7.4-26.8 19.4-33.7L204.6 9c11.7-6.6 27.2-6.6 38.8 0l184.7 106.7c12 6.9 19.4 19.8 19.4 33.7v213.1c0 13.8-7.4 26.7-19.4 33.7L243.4 502.8c-5.9 3.4-12.6 5.2-19.4 5.2zm149.1-210.1c0-39.9-27-50.5-83.7-58-57.4-7.6-63.2-11.5-63.2-24.9 0-11.1 4.9-25.9 47.4-25.9 37.9 0 51.9 8.2 57.7 33.8.5 2.4 2.7 4.2 5.2 4.2h24c1.5 0 2.9-.6 3.9-1.7s1.5-2.6 1.4-4.1c-3.7-44.1-33-64.6-92.2-64.6-52.7 0-84.1 22.2-84.1 59.5 0 40.4 31.3 51.6 81.8 56.6 60.5 5.9 65.2 14.8 65.2 26.7 0 20.6-16.6 29.4-55.5 29.4-48.9 0-59.6-12.3-63.2-36.6-.4-2.6-2.6-4.5-5.3-4.5h-23.9c-3 0-5.3 2.4-5.3 5.3 0 31.1 16.9 68.2 97.8 68.2 58.4-.1 92-23.2 92-63.4z"}}]})(e)}function wt(e){return ut({tag:"svg",attr:{viewBox:"0 0 448 512"},child:[{tag:"path",attr:{d:"M439.8 200.5c-7.7-30.9-22.3-54.2-53.4-54.2h-40.1v47.4c0 36.8-31.2 67.8-66.8 67.8H172.7c-29.2 0-53.4 25-53.4 54.3v101.8c0 29 25.2 46 53.4 54.3 33.8 9.9 66.3 11.7 106.8 0 26.9-7.8 53.4-23.5 53.4-54.3v-40.7H226.2v-13.6h160.2c31.1 0 42.6-21.7 53.4-54.2 11.2-33.5 10.7-65.7 0-108.6zM286.2 404c11.1 0 20.1 9.1 20.1 20.3 0 11.3-9 20.4-20.1 20.4-11 0-20.1-9.2-20.1-20.4.1-11.3 9.1-20.3 20.1-20.3zM167.8 248.1h106.8c29.7 0 53.4-24.5 53.4-54.3V91.9c0-29-24.4-50.7-53.4-55.6-35.8-5.9-74.7-5.6-106.8.1-45.2 8-53.4 24.7-53.4 55.6v40.7h106.9v13.6h-147c-31.1 0-58.3 18.7-66.8 54.2-9.8 40.7-10.2 66.1 0 108.6 7.6 31.6 25.7 54.2 56.8 54.2H101v-48.8c0-35.3 30.5-66.4 66.8-66.4zm-6.7-142.6c-11.1 0-20.1-9.1-20.1-20.3.1-11.3 9-20.4 20.1-20.4 11 0 20.1 9.2 20.1 20.4s-9 20.3-20.1 20.3z"}}]})(e)}function kt(e){return ut({tag:"svg",attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{d:"M418.2 177.2c-5.4-1.8-10.8-3.5-16.2-5.1.9-3.7 1.7-7.4 2.5-11.1 12.3-59.6 4.2-107.5-23.1-123.3-26.3-15.1-69.2.6-112.6 38.4-4.3 3.7-8.5 7.6-12.5 11.5-2.7-2.6-5.5-5.2-8.3-7.7-45.5-40.4-91.1-57.4-118.4-41.5-26.2 15.2-34 60.3-23 116.7 1.1 5.6 2.3 11.1 3.7 16.7-6.4 1.8-12.7 3.8-18.6 5.9C38.3 196.2 0 225.4 0 255.6c0 31.2 40.8 62.5 96.3 81.5 4.5 1.5 9 3 13.6 4.3-1.5 6-2.8 11.9-4 18-10.5 55.5-2.3 99.5 23.9 114.6 27 15.6 72.4-.4 116.6-39.1 3.5-3.1 7-6.3 10.5-9.7 4.4 4.3 9 8.4 13.6 12.4 42.8 36.8 85.1 51.7 111.2 36.6 27-15.6 35.8-62.9 24.4-120.5-.9-4.4-1.9-8.9-3-13.5 3.2-.9 6.3-1.9 9.4-2.9 57.7-19.1 99.5-50 99.5-81.7 0-30.3-39.4-59.7-93.8-78.4zM282.9 92.3c37.2-32.4 71.9-45.1 87.7-36 16.9 9.7 23.4 48.9 12.8 100.4-.7 3.4-1.4 6.7-2.3 10-22.2-5-44.7-8.6-67.3-10.6-13-18.6-27.2-36.4-42.6-53.1 3.9-3.7 7.7-7.2 11.7-10.7zM167.2 307.5c5.1 8.7 10.3 17.4 15.8 25.9-15.6-1.7-31.1-4.2-46.4-7.5 4.4-14.4 9.9-29.3 16.3-44.5 4.6 8.8 9.3 17.5 14.3 26.1zm-30.3-120.3c14.4-3.2 29.7-5.8 45.6-7.8-5.3 8.3-10.5 16.8-15.4 25.4-4.9 8.5-9.7 17.2-14.2 26-6.3-14.9-11.6-29.5-16-43.6zm27.4 68.9c6.6-13.8 13.8-27.3 21.4-40.6s15.8-26.2 24.4-38.9c15-1.1 30.3-1.7 45.9-1.7s31 .6 45.9 1.7c8.5 12.6 16.6 25.5 24.3 38.7s14.9 26.7 21.7 40.4c-6.7 13.8-13.9 27.4-21.6 40.8-7.6 13.3-15.7 26.2-24.2 39-14.9 1.1-30.4 1.6-46.1 1.6s-30.9-.5-45.6-1.4c-8.7-12.7-16.9-25.7-24.6-39s-14.8-26.8-21.5-40.6zm180.6 51.2c5.1-8.8 9.9-17.7 14.6-26.7 6.4 14.5 12 29.2 16.9 44.3-15.5 3.5-31.2 6.2-47 8 5.4-8.4 10.5-17 15.5-25.6zm14.4-76.5c-4.7-8.8-9.5-17.6-14.5-26.2-4.9-8.5-10-16.9-15.3-25.2 16.1 2 31.5 4.7 45.9 8-4.6 14.8-10 29.2-16.1 43.4zM256.2 118.3c10.5 11.4 20.4 23.4 29.6 35.8-19.8-.9-39.7-.9-59.5 0 9.8-12.9 19.9-24.9 29.9-35.8zM140.2 57c16.8-9.8 54.1 4.2 93.4 39 2.5 2.2 5 4.6 7.6 7-15.5 16.7-29.8 34.5-42.9 53.1-22.6 2-45 5.5-67.2 10.4-1.3-5.1-2.4-10.3-3.5-15.5-9.4-48.4-3.2-84.9 12.6-94zm-24.5 263.6c-4.2-1.2-8.3-2.5-12.4-3.9-21.3-6.7-45.5-17.3-63-31.2-10.1-7-16.9-17.8-18.8-29.9 0-18.3 31.6-41.7 77.2-57.6 5.7-2 11.5-3.8 17.3-5.5 6.8 21.7 15 43 24.5 63.6-9.6 20.9-17.9 42.5-24.8 64.5zm116.6 98c-16.5 15.1-35.6 27.1-56.4 35.3-11.1 5.3-23.9 5.8-35.3 1.3-15.9-9.2-22.5-44.5-13.5-92 1.1-5.6 2.3-11.2 3.7-16.7 22.4 4.8 45 8.1 67.9 9.8 13.2 18.7 27.7 36.6 43.2 53.4-3.2 3.1-6.4 6.1-9.6 8.9zm24.5-24.3c-10.2-11-20.4-23.2-30.3-36.3 9.6.4 19.5.6 29.5.6 10.3 0 20.4-.2 30.4-.7-9.2 12.7-19.1 24.8-29.6 36.4zm130.7 30c-.9 12.2-6.9 23.6-16.5 31.3-15.9 9.2-49.8-2.8-86.4-34.2-4.2-3.6-8.4-7.5-12.7-11.5 15.3-16.9 29.4-34.8 42.2-53.6 22.9-1.9 45.7-5.4 68.2-10.5 1 4.1 1.9 8.2 2.7 12.2 4.9 21.6 5.7 44.1 2.5 66.3zm18.2-107.5c-2.8.9-5.6 1.8-8.5 2.6-7-21.8-15.6-43.1-25.5-63.8 9.6-20.4 17.7-41.4 24.5-62.9 5.2 1.5 10.2 3.1 15 4.7 46.6 16 79.3 39.8 79.3 58 0 19.6-34.9 44.9-84.8 61.4zm-149.7-15c25.3 0 45.8-20.5 45.8-45.8s-20.5-45.8-45.8-45.8c-25.3 0-45.8 20.5-45.8 45.8s20.5 45.8 45.8 45.8z"}}]})(e)}function St(e){return ut({tag:"svg",attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{d:"M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"}}]})(e)}function Ct(e){return ut({tag:"svg",attr:{viewBox:"0 0 448 512"},child:[{tag:"path",attr:{d:"M380.9 97.1C339 55.1 283.2 32 223.9 32c-122.4 0-222 99.6-222 222 0 39.1 10.2 77.3 29.6 111L0 480l117.7-30.9c32.4 17.7 68.9 27 106.1 27h.1c122.3 0 224.1-99.6 224.1-222 0-59.3-25.2-115-67.1-157zm-157 341.6c-33.2 0-65.7-8.9-94-25.7l-6.7-4-69.8 18.3L72 359.2l-4.4-7c-18.5-29.4-28.2-63.3-28.2-98.2 0-101.7 82.8-184.5 184.6-184.5 49.3 0 95.6 19.2 130.4 54.1 34.8 34.9 56.2 81.2 56.1 130.5 0 101.8-84.9 184.6-186.6 184.6zm101.2-138.2c-5.5-2.8-32.8-16.2-37.9-18-5.1-1.9-8.8-2.8-12.5 2.8-3.7 5.6-14.3 18-17.6 21.8-3.2 3.7-6.5 4.2-12 1.4-32.6-16.3-54-29.1-75.5-66-5.7-9.8 5.7-9.1 16.3-30.3 1.8-3.7.9-6.9-.5-9.7-1.4-2.8-12.5-30.1-17.1-41.2-4.5-10.8-9.1-9.3-12.5-9.5-3.2-.2-6.9-.2-10.6-.2-3.7 0-9.7 1.4-14.8 6.9-5.1 5.6-19.4 19-19.4 46.3 0 27.3 19.9 53.7 22.6 57.4 2.8 3.7 39.1 59.7 94.8 83.8 35.2 15.2 49 16.5 66.6 13.9 10.7-1.6 32.8-13.4 37.4-26.4 4.6-13 4.6-24.1 3.2-26.4-1.3-2.5-5-3.9-10.5-6.6z"}}]})(e)}function It(e){return ut({tag:"svg",attr:{viewBox:"0 0 448 512"},child:[{tag:"path",attr:{d:"M257.5 445.1l-22.2 22.2c-9.4 9.4-24.6 9.4-33.9 0L7 273c-9.4-9.4-9.4-24.6 0-33.9L201.4 44.7c9.4-9.4 24.6-9.4 33.9 0l22.2 22.2c9.5 9.5 9.3 25-.4 34.3L136.6 216H424c13.3 0 24 10.7 24 24v32c0 13.3-10.7 24-24 24H136.6l120.5 114.8c9.8 9.3 10 24.8.4 34.3z"}}]})(e)}function Nt(e){return ut({tag:"svg",attr:{viewBox:"0 0 448 512"},child:[{tag:"path",attr:{d:"M190.5 66.9l22.2-22.2c9.4-9.4 24.6-9.4 33.9 0L441 239c9.4 9.4 9.4 24.6 0 33.9L246.6 467.3c-9.4 9.4-24.6 9.4-33.9 0l-22.2-22.2c-9.5-9.5-9.3-25 .4-34.3L311.4 296H24c-13.3 0-24-10.7-24-24v-32c0-13.3 10.7-24 24-24h287.4L190.9 101.2c-9.8-9.3-10-24.8-.4-34.3z"}}]})(e)}function Tt(e){return ut({tag:"svg",attr:{viewBox:"0 0 640 512"},child:[{tag:"path",attr:{d:"M256 336h-.02c0-16.18 1.34-8.73-85.05-181.51-17.65-35.29-68.19-35.36-85.87 0C-2.06 328.75.02 320.33.02 336H0c0 44.18 57.31 80 128 80s128-35.82 128-80zM128 176l72 144H56l72-144zm511.98 160c0-16.18 1.34-8.73-85.05-181.51-17.65-35.29-68.19-35.36-85.87 0-87.12 174.26-85.04 165.84-85.04 181.51H384c0 44.18 57.31 80 128 80s128-35.82 128-80h-.02zM440 320l72-144 72 144H440zm88 128H352V153.25c23.51-10.29 41.16-31.48 46.39-57.25H528c8.84 0 16-7.16 16-16V48c0-8.84-7.16-16-16-16H383.64C369.04 12.68 346.09 0 320 0s-49.04 12.68-63.64 32H112c-8.84 0-16 7.16-16 16v32c0 8.84 7.16 16 16 16h129.61c5.23 25.76 22.87 46.96 46.39 57.25V448H112c-8.84 0-16 7.16-16 16v32c0 8.84 7.16 16 16 16h416c8.84 0 16-7.16 16-16v-32c0-8.84-7.16-16-16-16z"}}]})(e)}function Et(e){return ut({tag:"svg",attr:{viewBox:"0 0 448 512"},child:[{tag:"path",attr:{d:"M16 132h416c8.837 0 16-7.163 16-16V76c0-8.837-7.163-16-16-16H16C7.163 60 0 67.163 0 76v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16z"}}]})(e)}function Rt(e){return ut({tag:"svg",attr:{viewBox:"0 0 576 512"},child:[{tag:"path",attr:{d:"M208 0c-29.9 0-54.7 20.5-61.8 48.2-.8 0-1.4-.2-2.2-.2-35.3 0-64 28.7-64 64 0 4.8.6 9.5 1.7 14C52.5 138 32 166.6 32 200c0 12.6 3.2 24.3 8.3 34.9C16.3 248.7 0 274.3 0 304c0 33.3 20.4 61.9 49.4 73.9-.9 4.6-1.4 9.3-1.4 14.1 0 39.8 32.2 72 72 72 4.1 0 8.1-.5 12-1.2 9.6 28.5 36.2 49.2 68 49.2 39.8 0 72-32.2 72-72V64c0-35.3-28.7-64-64-64zm368 304c0-29.7-16.3-55.3-40.3-69.1 5.2-10.6 8.3-22.3 8.3-34.9 0-33.4-20.5-62-49.7-74 1-4.5 1.7-9.2 1.7-14 0-35.3-28.7-64-64-64-.8 0-1.5.2-2.2.2C422.7 20.5 397.9 0 368 0c-35.3 0-64 28.6-64 64v376c0 39.8 32.2 72 72 72 31.8 0 58.4-20.7 68-49.2 3.9.7 7.9 1.2 12 1.2 39.8 0 72-32.2 72-72 0-4.8-.5-9.5-1.4-14.1 29-12 49.4-40.6 49.4-73.9z"}}]})(e)}function _t(e){return ut({tag:"svg",attr:{viewBox:"0 0 448 512"},child:[{tag:"path",attr:{d:"M12 192h424c6.6 0 12 5.4 12 12v260c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V204c0-6.6 5.4-12 12-12zm436-44v-36c0-26.5-21.5-48-48-48h-48V12c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v52H160V12c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v52H48C21.5 64 0 85.5 0 112v36c0 6.6 5.4 12 12 12h424c6.6 0 12-5.4 12-12z"}}]})(e)}function At(e){return ut({tag:"svg",attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{d:"M512 144v288c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V144c0-26.5 21.5-48 48-48h88l12.3-32.9c7-18.7 24.9-31.1 44.9-31.1h125.5c20 0 37.9 12.4 44.9 31.1L376 96h88c26.5 0 48 21.5 48 48zM376 288c0-66.2-53.8-120-120-120s-120 53.8-120 120 53.8 120 120 120 120-53.8 120-120zm-32 0c0 48.5-39.5 88-88 88s-88-39.5-88-88 39.5-88 88-88 88 39.5 88 88z"}}]})(e)}function Mt(e){return ut({tag:"svg",attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{d:"M332.8 320h38.4c6.4 0 12.8-6.4 12.8-12.8V172.8c0-6.4-6.4-12.8-12.8-12.8h-38.4c-6.4 0-12.8 6.4-12.8 12.8v134.4c0 6.4 6.4 12.8 12.8 12.8zm96 0h38.4c6.4 0 12.8-6.4 12.8-12.8V76.8c0-6.4-6.4-12.8-12.8-12.8h-38.4c-6.4 0-12.8 6.4-12.8 12.8v230.4c0 6.4 6.4 12.8 12.8 12.8zm-288 0h38.4c6.4 0 12.8-6.4 12.8-12.8v-70.4c0-6.4-6.4-12.8-12.8-12.8h-38.4c-6.4 0-12.8 6.4-12.8 12.8v70.4c0 6.4 6.4 12.8 12.8 12.8zm96 0h38.4c6.4 0 12.8-6.4 12.8-12.8V108.8c0-6.4-6.4-12.8-12.8-12.8h-38.4c-6.4 0-12.8 6.4-12.8 12.8v198.4c0 6.4 6.4 12.8 12.8 12.8zM496 384H64V80c0-8.84-7.16-16-16-16H16C7.16 64 0 71.16 0 80v336c0 17.67 14.33 32 32 32h464c8.84 0 16-7.16 16-16v-32c0-8.84-7.16-16-16-16z"}}]})(e)}function Pt(e){return ut({tag:"svg",attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{d:"M496 384H64V80c0-8.84-7.16-16-16-16H16C7.16 64 0 71.16 0 80v336c0 17.67 14.33 32 32 32h464c8.84 0 16-7.16 16-16v-32c0-8.84-7.16-16-16-16zM464 96H345.94c-21.38 0-32.09 25.85-16.97 40.97l32.4 32.4L288 242.75l-73.37-73.37c-12.5-12.5-32.76-12.5-45.25 0l-68.69 68.69c-6.25 6.25-6.25 16.38 0 22.63l22.62 22.62c6.25 6.25 16.38 6.25 22.63 0L192 237.25l73.37 73.37c12.5 12.5 32.76 12.5 45.25 0l96-96 32.4 32.4c15.12 15.12 40.97 4.41 40.97-16.97V112c.01-8.84-7.15-16-15.99-16z"}}]})(e)}function Dt(e){return ut({tag:"svg",attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{d:"M504 256c0 136.967-111.033 248-248 248S8 392.967 8 256 119.033 8 256 8s248 111.033 248 248zM227.314 387.314l184-184c6.248-6.248 6.248-16.379 0-22.627l-22.627-22.627c-6.248-6.249-16.379-6.249-22.628 0L216 308.118l-70.059-70.059c-6.248-6.248-16.379-6.248-22.628 0l-22.627 22.627c-6.248 6.248-6.248 16.379 0 22.627l104 104c6.249 6.249 16.379 6.249 22.628.001z"}}]})(e)}function Ot(e){return ut({tag:"svg",attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{d:"M505 174.8l-39.6-39.6c-9.4-9.4-24.6-9.4-33.9 0L192 374.7 80.6 263.2c-9.4-9.4-24.6-9.4-33.9 0L7 302.9c-9.4 9.4-9.4 24.6 0 34L175 505c9.4 9.4 24.6 9.4 33.9 0l296-296.2c9.4-9.5 9.4-24.7.1-34zm-324.3 106c6.2 6.3 16.4 6.3 22.6 0l208-208.2c6.2-6.3 6.2-16.4 0-22.6L366.1 4.7c-6.2-6.3-16.4-6.3-22.6 0L192 156.2l-55.4-55.5c-6.2-6.3-16.4-6.3-22.6 0L68.7 146c-6.2 6.3-6.2 16.4 0 22.6l112 112.2z"}}]})(e)}function Ft(e){return ut({tag:"svg",attr:{viewBox:"0 0 448 512"},child:[{tag:"path",attr:{d:"M207.029 381.476L12.686 187.132c-9.373-9.373-9.373-24.569 0-33.941l22.667-22.667c9.357-9.357 24.522-9.375 33.901-.04L224 284.505l154.745-154.021c9.379-9.335 24.544-9.317 33.901.04l22.667 22.667c9.373 9.373 9.373 24.569 0 33.941L240.971 381.476c-9.373 9.372-24.569 9.372-33.942 0z"}}]})(e)}function Lt(e){return ut({tag:"svg",attr:{viewBox:"0 0 640 512"},child:[{tag:"path",attr:{d:"M278.9 511.5l-61-17.7c-6.4-1.8-10-8.5-8.2-14.9L346.2 8.7c1.8-6.4 8.5-10 14.9-8.2l61 17.7c6.4 1.8 10 8.5 8.2 14.9L293.8 503.3c-1.9 6.4-8.5 10.1-14.9 8.2zm-114-112.2l43.5-46.4c4.6-4.9 4.3-12.7-.8-17.2L117 256l90.6-79.7c5.1-4.5 5.5-12.3.8-17.2l-43.5-46.4c-4.5-4.8-12.1-5.1-17-.5L3.8 247.2c-5.1 4.7-5.1 12.8 0 17.5l144.1 135.1c4.9 4.6 12.5 4.4 17-.5zm327.2.6l144.1-135.1c5.1-4.7 5.1-12.8 0-17.5L492.1 112.1c-4.8-4.5-12.4-4.3-17 .5L431.6 159c-4.6 4.9-4.3 12.7.8 17.2L523 256l-90.6 79.7c-5.1 4.5-5.5 12.3-.8 17.2l43.5 46.4c4.5 4.9 12.1 5.1 17 .6z"}}]})(e)}function zt(e){return ut({tag:"svg",attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{d:"M487.4 315.7l-42.6-24.6c4.3-23.2 4.3-47 0-70.2l42.6-24.6c4.9-2.8 7.1-8.6 5.5-14-11.1-35.6-30-67.8-54.7-94.6-3.8-4.1-10-5.1-14.8-2.3L380.8 110c-17.9-15.4-38.5-27.3-60.8-35.1V25.8c0-5.6-3.9-10.5-9.4-11.7-36.7-8.2-74.3-7.8-109.2 0-5.5 1.2-9.4 6.1-9.4 11.7V75c-22.2 7.9-42.8 19.8-60.8 35.1L88.7 85.5c-4.9-2.8-11-1.9-14.8 2.3-24.7 26.7-43.6 58.9-54.7 94.6-1.7 5.4.6 11.2 5.5 14L67.3 221c-4.3 23.2-4.3 47 0 70.2l-42.6 24.6c-4.9 2.8-7.1 8.6-5.5 14 11.1 35.6 30 67.8 54.7 94.6 3.8 4.1 10 5.1 14.8 2.3l42.6-24.6c17.9 15.4 38.5 27.3 60.8 35.1v49.2c0 5.6 3.9 10.5 9.4 11.7 36.7 8.2 74.3 7.8 109.2 0 5.5-1.2 9.4-6.1 9.4-11.7v-49.2c22.2-7.9 42.8-19.8 60.8-35.1l42.6 24.6c4.9 2.8 11 1.9 14.8-2.3 24.7-26.7 43.6-58.9 54.7-94.6 1.5-5.5-.7-11.3-5.6-14.1zM256 336c-44.1 0-80-35.9-80-80s35.9-80 80-80 80 35.9 80 80-35.9 80-80 80z"}}]})(e)}function Bt(e){return ut({tag:"svg",attr:{viewBox:"0 0 640 512"},child:[{tag:"path",attr:{d:"M512.1 191l-8.2 14.3c-3 5.3-9.4 7.5-15.1 5.4-11.8-4.4-22.6-10.7-32.1-18.6-4.6-3.8-5.8-10.5-2.8-15.7l8.2-14.3c-6.9-8-12.3-17.3-15.9-27.4h-16.5c-6 0-11.2-4.3-12.2-10.3-2-12-2.1-24.6 0-37.1 1-6 6.2-10.4 12.2-10.4h16.5c3.6-10.1 9-19.4 15.9-27.4l-8.2-14.3c-3-5.2-1.9-11.9 2.8-15.7 9.5-7.9 20.4-14.2 32.1-18.6 5.7-2.1 12.1.1 15.1 5.4l8.2 14.3c10.5-1.9 21.2-1.9 31.7 0L552 6.3c3-5.3 9.4-7.5 15.1-5.4 11.8 4.4 22.6 10.7 32.1 18.6 4.6 3.8 5.8 10.5 2.8 15.7l-8.2 14.3c6.9 8 12.3 17.3 15.9 27.4h16.5c6 0 11.2 4.3 12.2 10.3 2 12 2.1 24.6 0 37.1-1 6-6.2 10.4-12.2 10.4h-16.5c-3.6 10.1-9 19.4-15.9 27.4l8.2 14.3c3 5.2 1.9 11.9-2.8 15.7-9.5 7.9-20.4 14.2-32.1 18.6-5.7 2.1-12.1-.1-15.1-5.4l-8.2-14.3c-10.4 1.9-21.2 1.9-31.7 0zm-10.5-58.8c38.5 29.6 82.4-14.3 52.8-52.8-38.5-29.7-82.4 14.3-52.8 52.8zM386.3 286.1l33.7 16.8c10.1 5.8 14.5 18.1 10.5 29.1-8.9 24.2-26.4 46.4-42.6 65.8-7.4 8.9-20.2 11.1-30.3 5.3l-29.1-16.8c-16 13.7-34.6 24.6-54.9 31.7v33.6c0 11.6-8.3 21.6-19.7 23.6-24.6 4.2-50.4 4.4-75.9 0-11.5-2-20-11.9-20-23.6V418c-20.3-7.2-38.9-18-54.9-31.7L74 403c-10 5.8-22.9 3.6-30.3-5.3-16.2-19.4-33.3-41.6-42.2-65.7-4-10.9.4-23.2 10.5-29.1l33.3-16.8c-3.9-20.9-3.9-42.4 0-63.4L12 205.8c-10.1-5.8-14.6-18.1-10.5-29 8.9-24.2 26-46.4 42.2-65.8 7.4-8.9 20.2-11.1 30.3-5.3l29.1 16.8c16-13.7 34.6-24.6 54.9-31.7V57.1c0-11.5 8.2-21.5 19.6-23.5 24.6-4.2 50.5-4.4 76-.1 11.5 2 20 11.9 20 23.6v33.6c20.3 7.2 38.9 18 54.9 31.7l29.1-16.8c10-5.8 22.9-3.6 30.3 5.3 16.2 19.4 33.2 41.6 42.1 65.8 4 10.9.1 23.2-10 29.1l-33.7 16.8c3.9 21 3.9 42.5 0 63.5zm-117.6 21.1c59.2-77-28.7-164.9-105.7-105.7-59.2 77 28.7 164.9 105.7 105.7zm243.4 182.7l-8.2 14.3c-3 5.3-9.4 7.5-15.1 5.4-11.8-4.4-22.6-10.7-32.1-18.6-4.6-3.8-5.8-10.5-2.8-15.7l8.2-14.3c-6.9-8-12.3-17.3-15.9-27.4h-16.5c-6 0-11.2-4.3-12.2-10.3-2-12-2.1-24.6 0-37.1 1-6 6.2-10.4 12.2-10.4h16.5c3.6-10.1 9-19.4 15.9-27.4l-8.2-14.3c-3-5.2-1.9-11.9 2.8-15.7 9.5-7.9 20.4-14.2 32.1-18.6 5.7-2.1 12.1.1 15.1 5.4l8.2 14.3c10.5-1.9 21.2-1.9 31.7 0l8.2-14.3c3-5.3 9.4-7.5 15.1-5.4 11.8 4.4 22.6 10.7 32.1 18.6 4.6 3.8 5.8 10.5 2.8 15.7l-8.2 14.3c6.9 8 12.3 17.3 15.9 27.4h16.5c6 0 11.2 4.3 12.2 10.3 2 12 2.1 24.6 0 37.1-1 6-6.2 10.4-12.2 10.4h-16.5c-3.6 10.1-9 19.4-15.9 27.4l8.2 14.3c3 5.2 1.9 11.9-2.8 15.7-9.5 7.9-20.4 14.2-32.1 18.6-5.7 2.1-12.1-.1-15.1-5.4l-8.2-14.3c-10.4 1.9-21.2 1.9-31.7 0zM501.6 431c38.5 29.6 82.4-14.3 52.8-52.8-38.5-29.6-82.4 14.3-52.8 52.8z"}}]})(e)}function jt(e){return ut({tag:"svg",attr:{viewBox:"0 0 576 512"},child:[{tag:"path",attr:{d:"M416 192c0-88.4-93.1-160-208-160S0 103.6 0 192c0 34.3 14.1 65.9 38 92-13.4 30.2-35.5 54.2-35.8 54.5-2.2 2.3-2.8 5.7-1.5 8.7S4.8 352 8 352c36.6 0 66.9-12.3 88.7-25 32.2 15.7 70.3 25 111.3 25 114.9 0 208-71.6 208-160zm122 220c23.9-26 38-57.7 38-92 0-66.9-53.5-124.2-129.3-148.1.9 6.6 1.3 13.3 1.3 20.1 0 105.9-107.7 192-240 192-10.8 0-21.3-.8-31.7-1.9C207.8 439.6 281.8 480 368 480c41 0 79.1-9.2 111.3-25 21.8 12.7 52.1 25 88.7 25 3.2 0 6.1-1.9 7.3-4.8 1.3-2.9.7-6.3-1.5-8.7-.3-.3-22.4-24.2-35.8-54.5z"}}]})(e)}function Wt(e){return ut({tag:"svg",attr:{viewBox:"0 0 448 512"},child:[{tag:"path",attr:{d:"M448 73.143v45.714C448 159.143 347.667 192 224 192S0 159.143 0 118.857V73.143C0 32.857 100.333 0 224 0s224 32.857 224 73.143zM448 176v102.857C448 319.143 347.667 352 224 352S0 319.143 0 278.857V176c48.125 33.143 136.208 48.572 224 48.572S399.874 209.143 448 176zm0 160v102.857C448 479.143 347.667 512 224 512S0 479.143 0 438.857V336c48.125 33.143 136.208 48.572 224 48.572S399.874 369.143 448 336z"}}]})(e)}function Vt(e){return ut({tag:"svg",attr:{viewBox:"0 0 576 512"},child:[{tag:"path",attr:{d:"M528 0H48C21.5 0 0 21.5 0 48v320c0 26.5 21.5 48 48 48h192l-16 48h-72c-13.3 0-24 10.7-24 24s10.7 24 24 24h272c13.3 0 24-10.7 24-24s-10.7-24-24-24h-72l-16-48h192c26.5 0 48-21.5 48-48V48c0-26.5-21.5-48-48-48zm-16 352H64V64h448v288z"}}]})(e)}function Ut(e){return ut({tag:"svg",attr:{viewBox:"0 0 640 512"},child:[{tag:"path",attr:{d:"M104 96H56c-13.3 0-24 10.7-24 24v104H8c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8h24v104c0 13.3 10.7 24 24 24h48c13.3 0 24-10.7 24-24V120c0-13.3-10.7-24-24-24zm528 128h-24V120c0-13.3-10.7-24-24-24h-48c-13.3 0-24 10.7-24 24v272c0 13.3 10.7 24 24 24h48c13.3 0 24-10.7 24-24V288h24c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8zM456 32h-48c-13.3 0-24 10.7-24 24v168H256V56c0-13.3-10.7-24-24-24h-48c-13.3 0-24 10.7-24 24v400c0 13.3 10.7 24 24 24h48c13.3 0 24-10.7 24-24V288h128v168c0 13.3 10.7 24 24 24h48c13.3 0 24-10.7 24-24V56c0-13.3-10.7-24-24-24z"}}]})(e)}function Ht(e){return ut({tag:"svg",attr:{viewBox:"0 0 576 512"},child:[{tag:"path",attr:{d:"M402.6 83.2l90.2 90.2c3.8 3.8 3.8 10 0 13.8L274.4 405.6l-92.8 10.3c-12.4 1.4-22.9-9.1-21.5-21.5l10.3-92.8L388.8 83.2c3.8-3.8 10-3.8 13.8 0zm162-22.9l-48.8-48.8c-15.2-15.2-39.9-15.2-55.2 0l-35.4 35.4c-3.8 3.8-3.8 10 0 13.8l90.2 90.2c3.8 3.8 10 3.8 13.8 0l35.4-35.4c15.2-15.3 15.2-40 0-55.2zM384 346.2V448H64V128h229.8c3.2 0 6.2-1.3 8.5-3.5l40-40c7.6-7.6 2.2-20.5-8.5-20.5H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V306.2c0-10.7-12.9-16-20.5-8.5l-40 40c-2.2 2.3-3.5 5.3-3.5 8.5z"}}]})(e)}function Gt(e){return ut({tag:"svg",attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{d:"M502.3 190.8c3.9-3.1 9.7-.2 9.7 4.7V400c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V195.6c0-5 5.7-7.8 9.7-4.7 22.4 17.4 52.1 39.5 154.1 113.6 21.1 15.4 56.7 47.8 92.2 47.6 35.7.3 72-32.8 92.3-47.6 102-74.1 131.6-96.3 154-113.7zM256 320c23.2.4 56.6-29.2 73.4-41.4 132.7-96.3 142.8-104.7 173.4-128.7 5.8-4.5 9.2-11.5 9.2-18.9v-19c0-26.5-21.5-48-48-48H48C21.5 64 0 85.5 0 112v19c0 7.4 3.4 14.3 9.2 18.9 30.6 23.9 40.7 32.4 173.4 128.7 16.8 12.2 50.2 41.8 73.4 41.4z"}}]})(e)}function qt(e){return ut({tag:"svg",attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{d:"M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zm-248 50c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"}}]})(e)}function Kt(e){return ut({tag:"svg",attr:{viewBox:"0 0 576 512"},child:[{tag:"path",attr:{d:"M569.517 440.013C587.975 472.007 564.806 512 527.94 512H48.054c-36.937 0-59.999-40.055-41.577-71.987L246.423 23.985c18.467-32.009 64.72-31.951 83.154 0l239.94 416.028zM288 354c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"}}]})(e)}function Xt(e){return ut({tag:"svg",attr:{viewBox:"0 0 640 512"},child:[{tag:"path",attr:{d:"M320 400c-75.85 0-137.25-58.71-142.9-133.11L72.2 185.82c-13.79 17.3-26.48 35.59-36.72 55.59a32.35 32.35 0 0 0 0 29.19C89.71 376.41 197.07 448 320 448c26.91 0 52.87-4 77.89-10.46L346 397.39a144.13 144.13 0 0 1-26 2.61zm313.82 58.1l-110.55-85.44a331.25 331.25 0 0 0 81.25-102.07 32.35 32.35 0 0 0 0-29.19C550.29 135.59 442.93 64 320 64a308.15 308.15 0 0 0-147.32 37.7L45.46 3.37A16 16 0 0 0 23 6.18L3.37 31.45A16 16 0 0 0 6.18 53.9l588.36 454.73a16 16 0 0 0 22.46-2.81l19.64-25.27a16 16 0 0 0-2.82-22.45zm-183.72-142l-39.3-30.38A94.75 94.75 0 0 0 416 256a94.76 94.76 0 0 0-121.31-92.21A47.65 47.65 0 0 1 304 192a46.64 46.64 0 0 1-1.54 10l-73.61-56.89A142.31 142.31 0 0 1 320 112a143.92 143.92 0 0 1 144 144c0 21.63-5.29 41.79-13.9 60.11z"}}]})(e)}function Yt(e){return ut({tag:"svg",attr:{viewBox:"0 0 576 512"},child:[{tag:"path",attr:{d:"M572.52 241.4C518.29 135.59 410.93 64 288 64S57.68 135.64 3.48 241.41a32.35 32.35 0 0 0 0 29.19C57.71 376.41 165.07 448 288 448s230.32-71.64 284.52-177.41a32.35 32.35 0 0 0 0-29.19zM288 400a144 144 0 1 1 144-144 143.93 143.93 0 0 1-144 144zm0-240a95.31 95.31 0 0 0-25.31 3.79 47.85 47.85 0 0 1-66.9 66.9A95.78 95.78 0 1 0 288 160z"}}]})(e)}function Qt(e){return ut({tag:"svg",attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{d:"M462.3 62.6C407.5 15.9 326 24.3 275.7 76.2L256 96.5l-19.7-20.3C186.1 24.3 104.5 15.9 49.7 62.6c-62.8 53.6-66.1 149.8-9.9 207.9l193.5 199.8c12.5 12.9 32.8 12.9 45.3 0l193.5-199.8c56.3-58.1 53-154.3-9.8-207.9z"}}]})(e)}function Zt(e){return ut({tag:"svg",attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{d:"M320.2 243.8l-49.7 99.4c-6 12.1-23.4 11.7-28.9-.6l-56.9-126.3-30 71.7H60.6l182.5 186.5c7.1 7.3 18.6 7.3 25.7 0L451.4 288H342.3l-22.1-44.2zM473.7 73.9l-2.4-2.5c-51.5-52.6-135.8-52.6-187.4 0L256 100l-27.9-28.5c-51.5-52.7-135.9-52.7-187.4 0l-2.4 2.4C-10.4 123.7-12.5 203 31 256h102.4l35.9-86.2c5.4-12.9 23.6-13.2 29.4-.4l58.2 129.3 49-97.9c5.9-11.8 22.7-11.8 28.6 0l27.6 55.2H481c43.5-53 41.4-132.3-7.3-182.1z"}}]})(e)}function Jt(e){return ut({tag:"svg",attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{d:"M256 8C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8zm0 110c23.196 0 42 18.804 42 42s-18.804 42-42 42-42-18.804-42-42 18.804-42 42-42zm56 254c0 6.627-5.373 12-12 12h-88c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h12v-64h-12c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h64c6.627 0 12 5.373 12 12v100h12c6.627 0 12 5.373 12 12v24z"}}]})(e)}function $t(e){return ut({tag:"svg",attr:{viewBox:"0 0 640 512"},child:[{tag:"path",attr:{d:"M255.03 261.65c6.25 6.25 16.38 6.25 22.63 0l11.31-11.31c6.25-6.25 6.25-16.38 0-22.63L253.25 192l35.71-35.72c6.25-6.25 6.25-16.38 0-22.63l-11.31-11.31c-6.25-6.25-16.38-6.25-22.63 0l-58.34 58.34c-6.25 6.25-6.25 16.38 0 22.63l58.35 58.34zm96.01-11.3l11.31 11.31c6.25 6.25 16.38 6.25 22.63 0l58.34-58.34c6.25-6.25 6.25-16.38 0-22.63l-58.34-58.34c-6.25-6.25-16.38-6.25-22.63 0l-11.31 11.31c-6.25 6.25-6.25 16.38 0 22.63L386.75 192l-35.71 35.72c-6.25 6.25-6.25 16.38 0 22.63zM624 416H381.54c-.74 19.81-14.71 32-32.74 32H288c-18.69 0-33.02-17.47-32.77-32H16c-8.8 0-16 7.2-16 16v16c0 35.2 28.8 64 64 64h512c35.2 0 64-28.8 64-64v-16c0-8.8-7.2-16-16-16zM576 48c0-26.4-21.6-48-48-48H112C85.6 0 64 21.6 64 48v336h512V48zm-64 272H128V64h384v256z"}}]})(e)}function en(e){return ut({tag:"svg",attr:{viewBox:"0 0 576 512"},child:[{tag:"path",attr:{d:"M546.2 9.7c-5.6-12.5-21.6-13-28.3-1.2C486.9 62.4 431.4 96 368 96h-80C182 96 96 182 96 288c0 7 .8 13.7 1.5 20.5C161.3 262.8 253.4 224 384 224c8.8 0 16 7.2 16 16s-7.2 16-16 16C132.6 256 26 410.1 2.4 468c-6.6 16.3 1.2 34.9 17.5 41.6 16.4 6.8 35-1.1 41.8-17.3 1.5-3.6 20.9-47.9 71.9-90.6 32.4 43.9 94 85.8 174.9 77.2C465.5 467.5 576 326.7 576 154.3c0-50.2-10.8-102.2-29.8-144.6z"}}]})(e)}function tn(e){return ut({tag:"svg",attr:{viewBox:"0 0 352 512"},child:[{tag:"path",attr:{d:"M96.06 454.35c.01 6.29 1.87 12.45 5.36 17.69l17.09 25.69a31.99 31.99 0 0 0 26.64 14.28h61.71a31.99 31.99 0 0 0 26.64-14.28l17.09-25.69a31.989 31.989 0 0 0 5.36-17.69l.04-38.35H96.01l.05 38.35zM0 176c0 44.37 16.45 84.85 43.56 115.78 16.52 18.85 42.36 58.23 52.21 91.45.04.26.07.52.11.78h160.24c.04-.26.07-.51.11-.78 9.85-33.22 35.69-72.6 52.21-91.45C335.55 260.85 352 220.37 352 176 352 78.61 272.91-.3 175.45 0 73.44.31 0 82.97 0 176zm176-80c-44.11 0-80 35.89-80 80 0 8.84-7.16 16-16 16s-16-7.16-16-16c0-61.76 50.24-112 112-112 8.84 0 16 7.16 16 16s-7.16 16-16 16z"}}]})(e)}function nn(e){return ut({tag:"svg",attr:{viewBox:"0 0 448 512"},child:[{tag:"path",attr:{d:"M400 224h-24v-72C376 68.2 307.8 0 224 0S72 68.2 72 152v72H48c-26.5 0-48 21.5-48 48v192c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V272c0-26.5-21.5-48-48-48zm-104 0H152v-72c0-39.7 32.3-72 72-72s72 32.3 72 72v72z"}}]})(e)}function an(e){return ut({tag:"svg",attr:{viewBox:"0 0 384 512"},child:[{tag:"path",attr:{d:"M172.268 501.67C26.97 291.031 0 269.413 0 192 0 85.961 85.961 0 192 0s192 85.961 192 192c0 77.413-26.97 99.031-172.268 309.67-9.535 13.774-29.93 13.773-39.464 0zM192 272c44.183 0 80-35.817 80-80s-35.817-80-80-80-80 35.817-80 80 35.817 80 80 80z"}}]})(e)}function sn(e){return ut({tag:"svg",attr:{viewBox:"0 0 320 512"},child:[{tag:"path",attr:{d:"M272 0H48C21.5 0 0 21.5 0 48v416c0 26.5 21.5 48 48 48h224c26.5 0 48-21.5 48-48V48c0-26.5-21.5-48-48-48zM160 480c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32zm112-108c0 6.6-5.4 12-12 12H60c-6.6 0-12-5.4-12-12V60c0-6.6 5.4-12 12-12h200c6.6 0 12 5.4 12 12v312z"}}]})(e)}function rn(e){return ut({tag:"svg",attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{d:"M476 3.2L12.5 270.6c-18.1 10.4-15.8 35.6 2.2 43.2L121 358.4l287.3-253.2c5.5-4.9 13.3 2.6 8.6 8.3L176 407v80.5c0 23.6 28.5 32.9 42.5 15.8L282 426l124.6 52.2c14.2 6 30.4-2.9 33-18.2l72-432C515 7.8 493.3-6.8 476 3.2z"}}]})(e)}function on(e){return ut({tag:"svg",attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{d:"M493.4 24.6l-104-24c-11.3-2.6-22.9 3.3-27.5 13.9l-48 112c-4.2 9.8-1.4 21.3 6.9 28l60.6 49.6c-36 76.7-98.9 140.5-177.2 177.2l-49.6-60.6c-6.8-8.3-18.2-11.1-28-6.9l-112 48C3.9 366.5-2 378.1.6 389.4l24 104C27.1 504.2 36.7 512 48 512c256.1 0 464-207.5 464-464 0-11.2-7.7-20.9-18.6-23.4z"}}]})(e)}function cn(e){return ut({tag:"svg",attr:{viewBox:"0 0 448 512"},child:[{tag:"path",attr:{d:"M424.4 214.7L72.4 6.6C43.8-10.3 0 6.1 0 47.9V464c0 37.5 40.7 60.1 72.4 41.3l352-208c31.4-18.5 31.5-64.1 0-82.6z"}}]})(e)}function ln(e){return ut({tag:"svg",attr:{viewBox:"0 0 640 512"},child:[{tag:"path",attr:{d:"M384 320H256c-17.67 0-32 14.33-32 32v128c0 17.67 14.33 32 32 32h128c17.67 0 32-14.33 32-32V352c0-17.67-14.33-32-32-32zM192 32c0-17.67-14.33-32-32-32H32C14.33 0 0 14.33 0 32v128c0 17.67 14.33 32 32 32h95.72l73.16 128.04C211.98 300.98 232.4 288 256 288h.28L192 175.51V128h224V64H192V32zM608 0H480c-17.67 0-32 14.33-32 32v128c0 17.67 14.33 32 32 32h128c17.67 0 32-14.33 32-32V32c0-17.67-14.33-32-32-32z"}}]})(e)}function un(e){return ut({tag:"svg",attr:{viewBox:"0 0 640 512"},child:[{tag:"path",attr:{d:"M32,224H64V416H32A31.96166,31.96166,0,0,1,0,384V256A31.96166,31.96166,0,0,1,32,224Zm512-48V448a64.06328,64.06328,0,0,1-64,64H160a64.06328,64.06328,0,0,1-64-64V176a79.974,79.974,0,0,1,80-80H288V32a32,32,0,0,1,64,0V96H464A79.974,79.974,0,0,1,544,176ZM264,256a40,40,0,1,0-40,40A39.997,39.997,0,0,0,264,256Zm-8,128H192v32h64Zm96,0H288v32h64ZM456,256a40,40,0,1,0-40,40A39.997,39.997,0,0,0,456,256Zm-8,128H384v32h64ZM640,256V384a31.96166,31.96166,0,0,1-32,32H576V224h32A31.96166,31.96166,0,0,1,640,256Z"}}]})(e)}function hn(e){return ut({tag:"svg",attr:{viewBox:"0 0 448 512"},child:[{tag:"path",attr:{d:"M433.941 129.941l-83.882-83.882A48 48 0 0 0 316.118 32H48C21.49 32 0 53.49 0 80v352c0 26.51 21.49 48 48 48h352c26.51 0 48-21.49 48-48V163.882a48 48 0 0 0-14.059-33.941zM224 416c-35.346 0-64-28.654-64-64 0-35.346 28.654-64 64-64s64 28.654 64 64c0 35.346-28.654 64-64 64zm96-304.52V212c0 6.627-5.373 12-12 12H76c-6.627 0-12-5.373-12-12V108c0-6.627 5.373-12 12-12h228.52c3.183 0 6.235 1.264 8.485 3.515l3.48 3.48A11.996 11.996 0 0 1 320 111.48z"}}]})(e)}function dn(e){return ut({tag:"svg",attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{d:"M466.5 83.7l-192-80a48.15 48.15 0 0 0-36.9 0l-192 80C27.7 91.1 16 108.6 16 128c0 198.5 114.5 335.7 221.5 380.3 11.8 4.9 25.1 4.9 36.9 0C360.1 472.6 496 349.3 496 128c0-19.4-11.7-36.9-29.5-44.3zM256.1 446.3l-.1-381 175.9 73.3c-3.3 151.4-82.1 261.1-175.8 307.7z"}}]})(e)}function pn(e){return ut({tag:"svg",attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{d:"M497 273L329 441c-15 15-41 4.5-41-17v-96H152c-13.3 0-24-10.7-24-24v-96c0-13.3 10.7-24 24-24h136V88c0-21.4 25.9-32 41-17l168 168c9.3 9.4 9.3 24.6 0 34zM192 436v-40c0-6.6-5.4-12-12-12H96c-17.7 0-32-14.3-32-32V160c0-17.7 14.3-32 32-32h84c6.6 0 12-5.4 12-12V76c0-6.6-5.4-12-12-12H96c-53 0-96 43-96 96v192c0 53 43 96 96 96h84c6.6 0 12-5.4 12-12z"}}]})(e)}function fn(e){return ut({tag:"svg",attr:{viewBox:"0 0 448 512"},child:[{tag:"path",attr:{d:"M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48z"}}]})(e)}function mn(e){return ut({tag:"svg",attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{d:"M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm121.6 313.1c4.7 4.7 4.7 12.3 0 17L338 377.6c-4.7 4.7-12.3 4.7-17 0L256 312l-65.1 65.6c-4.7 4.7-12.3 4.7-17 0L134.4 338c-4.7-4.7-4.7-12.3 0-17l65.6-65-65.6-65.1c-4.7-4.7-4.7-12.3 0-17l39.6-39.6c4.7-4.7 12.3-4.7 17 0l65 65.7 65.1-65.6c4.7-4.7 12.3-4.7 17 0l39.6 39.6c4.7 4.7 4.7 12.3 0 17L312 256l65.6 65.1z"}}]})(e)}function gn(e){return ut({tag:"svg",attr:{viewBox:"0 0 352 512"},child:[{tag:"path",attr:{d:"M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"}}]})(e)}function yn(e){return ut({tag:"svg",attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{d:"M256 288c79.5 0 144-64.5 144-144S335.5 0 256 0 112 64.5 112 144s64.5 144 144 144zm128 32h-55.1c-22.2 10.2-46.9 16-72.9 16s-50.6-5.8-72.9-16H128C57.3 320 0 377.3 0 448v16c0 26.5 21.5 48 48 48h416c26.5 0 48-21.5 48-48v-16c0-70.7-57.3-128-128-128z"}}]})(e)}function bn(e){return ut({tag:"svg",attr:{viewBox:"0 0 640 512"},child:[{tag:"path",attr:{d:"M224 256c70.7 0 128-57.3 128-128S294.7 0 224 0 96 57.3 96 128s57.3 128 128 128zm89.6 32h-16.7c-22.2 10.2-46.9 16-72.9 16s-50.6-5.8-72.9-16h-16.7C60.2 288 0 348.2 0 422.4V464c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48v-41.6c0-74.2-60.2-134.4-134.4-134.4zm323-128.4l-27.8-28.1c-4.6-4.7-12.1-4.7-16.8-.1l-104.8 104-45.5-45.8c-4.6-4.7-12.1-4.7-16.8-.1l-28.1 27.9c-4.7 4.6-4.7 12.1-.1 16.8l81.7 82.3c4.6 4.7 12.1 4.7 16.8.1l141.3-140.2c4.6-4.7 4.7-12.2.1-16.8z"}}]})(e)}function xn(e){return ut({tag:"svg",attr:{viewBox:"0 0 448 512"},child:[{tag:"path",attr:{d:"M224 256c70.7 0 128-57.3 128-128S294.7 0 224 0 96 57.3 96 128s57.3 128 128 128zm89.6 32h-16.7c-22.2 10.2-46.9 16-72.9 16s-50.6-5.8-72.9-16h-16.7C60.2 288 0 348.2 0 422.4V464c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48v-41.6c0-74.2-60.2-134.4-134.4-134.4z"}}]})(e)}function vn(e){return ut({tag:"svg",attr:{viewBox:"0 0 576 512"},child:[{tag:"path",attr:{d:"M336.2 64H47.8C21.4 64 0 85.4 0 111.8v288.4C0 426.6 21.4 448 47.8 448h288.4c26.4 0 47.8-21.4 47.8-47.8V111.8c0-26.4-21.4-47.8-47.8-47.8zm189.4 37.7L416 177.3v157.4l109.6 75.5c21.2 14.6 50.4-.3 50.4-25.8V127.5c0-25.4-29.1-40.4-50.4-25.8z"}}]})(e)}var wn=n(579);const kn=()=>{const[e,t]=(0,E.useState)(!1),[n,a]=(0,E.useState)(!1),[s,r]=(0,E.useState)(!1),[i,o]=(0,E.useState)(null),c=Te(),l=Re();(0,E.useEffect)(()=>{const e=()=>{a(window.scrollY>50)};return window.addEventListener("scroll",e),()=>window.removeEventListener("scroll",e)},[]),(0,E.useEffect)(()=>{t(!1)},[c]),(0,E.useEffect)(()=>{const e=localStorage.getItem("token"),t=localStorage.getItem("user");if(e&&t)try{o(JSON.parse(t)),r(!0)}catch(n){console.error("Error parsing user data:",n),r(!1)}else r(!1),o(null)},[c]);return(0,wn.jsx)("nav",{className:"navbar ".concat(n?"scrolled":""),children:(0,wn.jsxs)("div",{className:"navbar-container",children:[(0,wn.jsxs)(nt,{to:"/",className:"navbar-logo",children:[(0,wn.jsx)("img",{src:"/yogaguru-icon-final.svg",alt:"YogaGuru Logo",className:"logo-icon"}),(0,wn.jsx)("span",{className:"logo-text",children:"YogaGuru"})]}),(0,wn.jsxs)("div",{className:"navbar-menu ".concat(e?"active":""),children:[(0,wn.jsx)("ul",{className:"navbar-links",children:[{path:"/",label:"Home"},{path:"/about",label:"About"},{path:"/features",label:"Features"},{path:"/how-it-works",label:"How It Works"},{path:"/pose-detection",label:"Pose Detection"},{path:"/tech-stack",label:"Tech Stack"},{path:"/results",label:"Results"},{path:"/team",label:"Team"},{path:"/contact",label:"Contact"}].map(e=>(0,wn.jsx)("li",{children:(0,wn.jsx)(nt,{to:e.path,className:c.pathname===e.path?"active":"",children:e.label})},e.path))}),(0,wn.jsxs)("div",{className:"navbar-mobile-footer",children:[(0,wn.jsxs)("div",{className:"mobile-contact",children:[(0,wn.jsx)("p",{children:"Contact for more information"}),(0,wn.jsx)("a",{href:"tel:+919265300000",children:"+91 92653***"})]}),(0,wn.jsxs)("div",{className:"mobile-social",children:[(0,wn.jsx)("a",{href:"https://github.com",target:"_blank",rel:"noopener noreferrer",children:(0,wn.jsx)(ft,{})}),(0,wn.jsx)("a",{href:"https://linkedin.com",target:"_blank",rel:"noopener noreferrer",children:(0,wn.jsx)(xt,{})}),(0,wn.jsx)("a",{href:"https://wa.me/919265300000",target:"_blank",rel:"noopener noreferrer",children:(0,wn.jsx)(Ct,{})}),(0,wn.jsx)("a",{href:"https://instagram.com",target:"_blank",rel:"noopener noreferrer",children:(0,wn.jsx)(yt,{})})]})]})]}),(0,wn.jsxs)("div",{className:"navbar-actions",children:[s?(0,wn.jsxs)(wn.Fragment,{children:[(0,wn.jsxs)(nt,{to:"/profile",className:"btn btn-profile",children:[(0,wn.jsx)(xn,{})," ",(null===i||void 0===i?void 0:i.name)||"Profile"]}),(0,wn.jsxs)("button",{className:"btn btn-logout-nav",onClick:()=>{localStorage.removeItem("token"),localStorage.removeItem("user"),r(!1),o(null),l("/"),window.location.reload()},children:[(0,wn.jsx)(pn,{})," Logout"]})]}):(0,wn.jsx)(nt,{to:"/login",className:"btn btn-secondary",children:"Login"}),(0,wn.jsx)("button",{className:"navbar-toggle",onClick:()=>t(!e),"aria-label":"Toggle navigation",children:e?(0,wn.jsx)(gn,{}):(0,wn.jsx)(Et,{})})]})]})})},Sn=()=>{const e=(new Date).getFullYear();return(0,wn.jsx)("footer",{className:"footer",children:(0,wn.jsxs)("div",{className:"footer-container",children:[(0,wn.jsxs)("div",{className:"footer-grid",children:[(0,wn.jsxs)("div",{className:"footer-brand",children:[(0,wn.jsxs)(nt,{to:"/",className:"footer-logo",children:[(0,wn.jsx)("img",{src:"/yogaguru-icon-final.svg",alt:"YogaGuru Logo",className:"footer-logo-icon"}),(0,wn.jsx)("span",{children:"YogaGuru"})]}),(0,wn.jsx)("p",{children:"AI-powered yoga pose detection platform helping you practice yoga correctly with real-time feedback and posture correction."}),(0,wn.jsxs)("div",{className:"footer-social",children:[(0,wn.jsx)("a",{href:"https://github.com",target:"_blank",rel:"noopener noreferrer","aria-label":"GitHub",children:(0,wn.jsx)(ft,{})}),(0,wn.jsx)("a",{href:"https://linkedin.com",target:"_blank",rel:"noopener noreferrer","aria-label":"LinkedIn",children:(0,wn.jsx)(xt,{})}),(0,wn.jsx)("a",{href:"https://twitter.com",target:"_blank",rel:"noopener noreferrer","aria-label":"Twitter",children:(0,wn.jsx)(St,{})}),(0,wn.jsx)("a",{href:"https://instagram.com",target:"_blank",rel:"noopener noreferrer","aria-label":"Instagram",children:(0,wn.jsx)(yt,{})})]})]}),(0,wn.jsxs)("div",{className:"footer-links",children:[(0,wn.jsx)("h4",{children:"Quick Links"}),(0,wn.jsxs)("ul",{children:[(0,wn.jsx)("li",{children:(0,wn.jsx)(nt,{to:"/",children:"Home"})}),(0,wn.jsx)("li",{children:(0,wn.jsx)(nt,{to:"/about",children:"About Yoga"})}),(0,wn.jsx)("li",{children:(0,wn.jsx)(nt,{to:"/features",children:"Features"})}),(0,wn.jsx)("li",{children:(0,wn.jsx)(nt,{to:"/pose-detection",children:"Pose Detection"})})]})]}),(0,wn.jsxs)("div",{className:"footer-links",children:[(0,wn.jsx)("h4",{children:"Resources"}),(0,wn.jsxs)("ul",{children:[(0,wn.jsx)("li",{children:(0,wn.jsx)(nt,{to:"/how-it-works",children:"How It Works"})}),(0,wn.jsx)("li",{children:(0,wn.jsx)(nt,{to:"/tech-stack",children:"Technology"})}),(0,wn.jsx)("li",{children:(0,wn.jsx)(nt,{to:"/results",children:"Results"})}),(0,wn.jsx)("li",{children:(0,wn.jsx)(nt,{to:"/team",children:"Our Team"})})]})]}),(0,wn.jsxs)("div",{className:"footer-contact",children:[(0,wn.jsx)("h4",{children:"Contact"}),(0,wn.jsxs)("ul",{children:[(0,wn.jsxs)("li",{children:[(0,wn.jsx)("span",{children:"Email:"}),(0,wn.jsx)("a",{href:"mailto:contact@yogaguru.com",children:"contact@yogaguru.com"})]}),(0,wn.jsxs)("li",{children:[(0,wn.jsx)("span",{children:"Phone:"}),(0,wn.jsx)("a",{href:"tel:+919265300000",children:"+91 92653 00000"})]}),(0,wn.jsxs)("li",{children:[(0,wn.jsx)("span",{children:"Address:"}),(0,wn.jsx)("p",{children:"Your College Name, City, State"})]})]})]})]}),(0,wn.jsxs)("div",{className:"footer-bottom",children:[(0,wn.jsxs)("p",{children:["\xa9 ",e," Created with ",(0,wn.jsx)(Qt,{className:"heart-icon"})," by YogaGuru Team"]}),(0,wn.jsx)("p",{className:"footer-tagline",children:"All rights reserved."})]})]})})},Cn=()=>{const e=[{icon:(0,wn.jsx)(Zt,{}),title:"Improve Posture",description:"Get real-time feedback to correct your yoga poses and maintain proper alignment."},{icon:(0,wn.jsx)(dn,{}),title:"Reduce Injuries",description:"AI-powered detection helps prevent injuries by identifying incorrect poses early."},{icon:(0,wn.jsx)(Rt,{}),title:"Reduce Stress",description:"Practice yoga with confidence, reducing anxiety and promoting mental wellness."},{icon:(0,wn.jsx)(Ut,{}),title:"Increase Strength",description:"Build flexibility and strength with guided yoga practice and proper form."}],t=[{category:"Wellness Tips",items:[{title:"Gratitude",text:"This can help you shift your focus from negative thoughts to positive ones and improve your mental health."},{title:"Be Consistent",text:"Practice yoga consistently to see the best results."},{title:"Practice on Light Stomach",text:"Practicing yoga on a light stomach helps prevent discomfort and allows for better movement."}]},{category:"Science Behind Yoga",items:[{title:"Stress Relief",text:"Reduces cortisol levels for mental peace."},{title:"Brain Boost",text:"Enhances focus and memory through blood circulation."},{title:"Heart Health",text:"Improves cardiovascular efficiency through relaxation."}]},{category:"Yoga Insights",items:[{title:"Active Meditation",text:"A practice that involves being mindful while performing daily activities."},{title:"Face Yoga",text:"A series of facial exercises to tone muscles and improve skin health."},{title:"Chair Yoga",text:"A gentle practice using a chair for support, ideal for seniors."}]},{category:"Myths & Truths",items:[{title:"Myth: Yoga is not a workout",text:"Truth: The physical aspect of yoga was created to exhaust the body and mind."},{title:"Myth: Yoga is just for women",text:"Truth: Around 25% to 35% of yoga practitioners are men."},{title:"Myth: Yoga is purely physical",text:"Truth: It integrates mind, body, and soul."}]}],n=["Halasana","Sarvangasana","Padmasana","Mudrasana","Chakrasana","Bhujangasana","Tadasana","Dhanurasana","Vajrasana","Garudasana"],[a,s]=E.useState(0),[r,i]=E.useState(0);return(0,wn.jsxs)("div",{className:"home-page",children:[(0,wn.jsxs)("section",{className:"hero",children:[(0,wn.jsx)("div",{className:"hero-bg",children:(0,wn.jsxs)("div",{className:"bubble-container",children:[(0,wn.jsx)("div",{className:"bubble bubble-1"}),(0,wn.jsx)("div",{className:"bubble bubble-2"}),(0,wn.jsx)("div",{className:"bubble bubble-3"})]})}),(0,wn.jsxs)("div",{className:"container",children:[(0,wn.jsxs)("div",{className:"hero-content",children:[(0,wn.jsxs)("h1",{className:"animate-fadeInUp",children:[(0,wn.jsx)("span",{children:"YogaGuru"}),(0,wn.jsx)("br",{}),(0,wn.jsx)("span",{className:"hero-subtitle",children:"Your Path To Wellness Starts Here"})]}),(0,wn.jsx)("p",{className:"hero-tagline animate-fadeInUp",style:{animationDelay:"0.2s"},children:'"Balance, Breathe, Strengthen, Thrive"'}),(0,wn.jsxs)("div",{className:"hero-buttons animate-fadeInUp",style:{animationDelay:"0.4s"},children:[(0,wn.jsx)(nt,{to:"/pose-detection",className:"btn btn-primary",children:"Start Pose Detection"}),(0,wn.jsx)(nt,{to:"/about",className:"btn btn-outline",children:"Learn More"})]})]}),(0,wn.jsxs)("div",{className:"hero-visual animate-fadeInUp",style:{animationDelay:"0.6s"},children:[(0,wn.jsx)("div",{className:"laptop-mockup",children:(0,wn.jsx)("div",{className:"laptop-screen",children:(0,wn.jsxs)("div",{className:"insights-selector",children:[(0,wn.jsx)("h3",{children:"Insights, Science, and Myths"}),(0,wn.jsx)("div",{className:"insight-cards",children:t.map((e,t)=>(0,wn.jsxs)("button",{className:"insight-card ".concat(a===t?"active":""),onClick:()=>s(t),children:[(0,wn.jsx)("span",{children:e.category}),0===t&&(0,wn.jsx)(tn,{}),1===t&&(0,wn.jsx)(Rt,{}),2===t&&(0,wn.jsx)(Pt,{}),3===t&&(0,wn.jsx)(bn,{})]},t))}),(0,wn.jsx)("div",{className:"insight-content",children:t[a].items.map((e,t)=>(0,wn.jsxs)("div",{className:"insight-item",children:[(0,wn.jsx)("h4",{children:e.title}),(0,wn.jsx)("p",{children:e.text})]},t))})]})})}),(0,wn.jsx)("div",{className:"yoga-person",children:(0,wn.jsxs)("svg",{viewBox:"0 0 275 494",fill:"none",xmlns:"http://www.w3.org/2000/svg",children:[(0,wn.jsx)("path",{d:"M192.631 259.732C192.717 257.924 193.198 256.157 194.04 254.555C194.883 252.953 196.066 251.556 197.507 250.461C198.949 249.366 200.612 248.6 202.381 248.217C204.15 247.835 205.982 247.845 207.746 248.247L224.118 225.174L240.566 231.704L216.988 263.962C216.117 266.882 214.204 269.381 211.613 270.985C209.023 272.589 205.933 273.187 202.931 272.666C199.929 272.144 197.222 270.54 195.324 268.156C193.425 265.772 192.467 262.775 192.631 259.732L192.631 259.732Z",fill:"#A0616A"}),(0,wn.jsx)("path",{d:"M149.887 449.434H133.701L126 387L149.89 387.001L149.887 449.434Z",fill:"#F7D6C3"}),(0,wn.jsx)("path",{d:"M117.887 445.768H153.872V465.423H103V460.655C103 456.707 104.568 452.92 107.36 450.128C110.152 447.337 113.939 445.768 117.887 445.768Z",fill:"#2F2E41"}),(0,wn.jsx)("path",{d:"M220.784 478.297H204.597L196.897 415.863L220.786 415.864L220.784 478.297Z",fill:"#F7D6C3"}),(0,wn.jsx)("path",{d:"M188.267 473.672H224.252V493.327H173.38V488.558C173.38 484.61 174.949 480.824 177.74 478.032C180.532 475.24 184.319 473.672 188.267 473.672V473.672Z",fill:"#2F2E41"}),(0,wn.jsx)("path",{d:"M226.54 250.407L225.22 342.828L223.9 464.295L194.853 461.654L179.5 294.5L175.5 292L145.5 336L152 432L124.5 427.5L104.5 324.5L139.401 250.407H226.54Z",fill:"#2F2E41"}),(0,wn.jsx)("path",{d:"M136.506 256.252L130 254.5L152.635 142.834L144.219 108.61C143.781 106.83 144.012 104.951 144.868 103.329C145.724 101.707 147.144 100.456 148.861 99.8116L164.003 94.1339L169.352 79.4225L211.558 83.9705L212.596 95.4678C217.17 96.9346 254.833 109.478 252.234 123.77C249.67 137.877 234.525 182.259 233.756 184.508L231.104 248.157L230.778 248.32C230.385 248.516 201.294 262.821 169.689 262.818C158.56 262.818 147.112 261.043 136.506 256.252Z",fill:"#3F3D56"}),(0,wn.jsxs)("g",{className:"turning-head",children:[(0,wn.jsx)("path",{d:"M215.466 56.3296C223.516 41.603 218.104 23.1388 203.378 15.0885C188.651 7.03825 170.187 12.4505 162.136 27.177C154.086 41.9036 159.498 60.3678 174.225 68.4181C188.952 76.4683 207.416 71.0562 215.466 56.3296Z",fill:"#F7D6C3"}),(0,wn.jsx)("path",{d:"M213.416 71.1705C207.625 77.3396 196.869 74.0279 196.115 65.6001C196.055 64.9457 196.06 64.2872 196.127 63.6337C196.517 59.9006 198.674 56.5113 198.157 52.5696C198.04 51.5886 197.675 50.6537 197.095 49.8535C192.48 43.6736 181.647 52.6176 177.292 47.0232C174.621 43.5928 177.76 38.1918 175.711 34.3577C173.006 29.2974 164.994 31.7937 159.97 29.0224C154.38 25.939 154.714 17.3622 158.394 12.1453C162.881 5.78305 170.75 2.38819 178.52 1.89892C186.29 1.40965 194.007 3.51014 201.261 6.33722C209.504 9.54935 217.677 13.9885 222.749 21.2361C228.918 30.0498 229.511 41.899 226.426 52.205C224.55 58.4743 218.145 66.1328 213.416 71.1705Z",fill:"#2F2E41"})]}),(0,wn.jsxs)("g",{className:"waving-arm",children:[(0,wn.jsx)("path",{d:"M12.4471 106.262C14.1354 105.61 15.9462 105.336 17.7519 105.459C19.5576 105.582 21.3144 106.099 22.8985 106.975C24.4826 107.85 25.8554 109.063 26.9203 110.526C27.9852 111.99 28.7163 113.669 29.0621 115.445L56.7836 121.095L57.4593 138.778L18.4233 130.251C15.4002 130.634 12.3417 129.894 9.8272 128.173C7.31275 126.452 5.51707 123.868 4.78044 120.911C4.0438 117.954 4.41739 114.83 5.83041 112.13C7.24343 109.43 9.5977 107.342 12.4471 106.262Z",fill:"#F7D6C3"}),(0,wn.jsx)("path",{d:"M42.7306 117.07L104.711 120.57L151 100.5L172 123L164 134.5L104.711 149.783L34.7306 135.787L42.7306 117.07Z",fill:"#3F3D56"})]})]})})]})]}),(0,wn.jsx)("div",{className:"scroll-indicator",children:(0,wn.jsx)(Ft,{})})]}),(0,wn.jsx)("section",{className:"yoga-marquee",children:(0,wn.jsx)("div",{className:"marquee-content",children:(0,wn.jsxs)("div",{className:"marquee-inner",children:[n.map((e,t)=>(0,wn.jsx)("span",{children:e},t)),n.map((e,t)=>(0,wn.jsx)("span",{children:e},"dup-".concat(t)))]})})}),(0,wn.jsx)("section",{className:"section about-home gradient-bg-light",children:(0,wn.jsx)("div",{className:"container",children:(0,wn.jsxs)("div",{className:"about-grid",children:[(0,wn.jsx)("div",{className:"about-image",children:(0,wn.jsx)("img",{src:"https://i.pinimg.com/originals/56/42/db/5642dbe39105d8cfd0d90fc5be597eb8.jpg",alt:"Yoga Practice"})}),(0,wn.jsxs)("div",{className:"about-content",children:[(0,wn.jsx)("span",{children:"About Us"}),(0,wn.jsx)("h2",{children:"YogaGuru"}),(0,wn.jsx)("p",{children:"At YogaGuru, our mission is to integrate technology with wellness, empowering people to enhance their yoga practice through personalized, data-driven insights. We aim to make yoga accessible and effective for everyone, ensuring correct posture and alignment in every session."}),(0,wn.jsx)("p",{children:"We specialize in AI-powered yoga pose detection to provide real-time feedback to users on their yoga practice. Our platform helps users achieve accurate poses, avoid injuries, and deepen their yoga journey through technology-driven solutions."}),(0,wn.jsx)(nt,{to:"/about",className:"btn btn-primary",children:"Learn More About Yoga"})]})]})})}),(0,wn.jsx)("section",{className:"section benefits",children:(0,wn.jsxs)("div",{className:"container",children:[(0,wn.jsxs)("div",{className:"section-title",children:[(0,wn.jsx)("span",{children:"Why Choose YogaGuru"}),(0,wn.jsx)("h2",{children:"Benefits of AI-Powered Yoga"})]}),(0,wn.jsx)("div",{className:"benefits-grid",children:e.map((e,t)=>(0,wn.jsxs)("div",{className:"benefit-card card",children:[(0,wn.jsx)("div",{className:"icon-box",children:e.icon}),(0,wn.jsx)("h3",{children:e.title}),(0,wn.jsx)("p",{children:e.description})]},t))})]})}),(0,wn.jsx)("section",{className:"cta-section",children:(0,wn.jsx)("div",{className:"container",children:(0,wn.jsxs)("div",{className:"cta-content",children:[(0,wn.jsxs)("div",{className:"cta-text",children:[(0,wn.jsx)("h2",{children:"Ready to Start Your Yoga Journey?"}),(0,wn.jsx)("p",{children:"Experience AI-powered pose detection and get real-time feedback on your practice."})]}),(0,wn.jsx)("div",{className:"cta-buttons",children:(0,wn.jsxs)(nt,{to:"/pose-detection",className:"btn btn-primary",children:[(0,wn.jsx)(At,{})," Start Pose Detection"]})})]})})}),(0,wn.jsx)("section",{className:"section faq-section",children:(0,wn.jsxs)("div",{className:"container",children:[(0,wn.jsxs)("div",{className:"section-title",children:[(0,wn.jsx)("span",{children:"Common Questions"}),(0,wn.jsx)("h2",{children:"Frequently Asked Questions"})]}),(0,wn.jsx)("div",{className:"accordion",children:[{q:"Can anyone do yoga?",a:"Yes! Yoga is suitable for people of all ages and fitness levels. Modifications and beginner-friendly classes are available."},{q:"How often should I practice yoga?",a:"Practicing 2-3 times a week is a great start. For maximum benefits, try to incorporate yoga into your daily routine."},{q:"What is the best time to practice yoga?",a:"Early morning or evening is ideal, but you can practice anytime that fits your schedule."},{q:"Do I need special equipment for yoga?",a:"A yoga mat is essential. Optional props like blocks, straps, and bolsters can provide additional support."},{q:"Is yoga pose detection suitable for beginners?",a:"Yes! It can provide real-time feedback to help beginners learn proper form and avoid injuries."}].map((e,t)=>(0,wn.jsxs)("div",{className:"accordion-item ".concat(r===t?"active":""),children:[(0,wn.jsxs)("div",{className:"accordion-header",onClick:()=>i(r===t?-1:t),children:[(0,wn.jsx)("span",{children:e.q}),(0,wn.jsx)(Ft,{className:"icon"})]}),(0,wn.jsx)("div",{className:"accordion-content",children:(0,wn.jsx)("p",{children:e.a})})]},t))})]})}),(0,wn.jsx)("section",{className:"quote-section",children:(0,wn.jsx)("div",{className:"container",children:(0,wn.jsx)("blockquote",{children:'"Yoga for Every Body, Every Journey."'})})})]})},In=()=>{const e=[{icon:(0,wn.jsx)(Qt,{}),title:"Physical Health",description:"Improves flexibility, strength, and cardiovascular health through regular practice."},{icon:(0,wn.jsx)(en,{}),title:"Mental Wellness",description:"Reduces stress, anxiety, and promotes mental clarity through mindful breathing."},{icon:(0,wn.jsx)(Tt,{}),title:"Balance & Harmony",description:"Creates balance between body, mind, and spirit for holistic well-being."},{icon:(0,wn.jsx)(Rt,{}),title:"Cognitive Benefits",description:"Enhances focus, memory, and cognitive function through meditation practices."}];return(0,wn.jsxs)("div",{className:"about-page",children:[(0,wn.jsx)("section",{className:"page-hero",children:(0,wn.jsxs)("div",{className:"container",children:[(0,wn.jsx)("span",{className:"page-label",children:"Learn About"}),(0,wn.jsx)("h1",{children:"What is Yoga?"}),(0,wn.jsx)("p",{children:"Discover the ancient practice that has transformed millions of lives and how AI technology can enhance your yoga journey."})]})}),(0,wn.jsx)("section",{className:"section",children:(0,wn.jsx)("div",{className:"container",children:(0,wn.jsxs)("div",{className:"content-grid",children:[(0,wn.jsx)("div",{className:"content-image",children:(0,wn.jsx)("img",{src:"https://images.unsplash.com/photo-1544367567-0f2fcb009e0b?w=600",alt:"Yoga Practice"})}),(0,wn.jsxs)("div",{className:"content-text",children:[(0,wn.jsx)("h2",{children:"The Art of Yoga"}),(0,wn.jsx)("p",{children:"Yoga is an ancient practice that originated in India over 5,000 years ago. It encompasses physical postures (asanas), breathing techniques (pranayama), and meditation (dhyana) to achieve harmony between body, mind, and spirit."}),(0,wn.jsx)("p",{children:'The word "Yoga" comes from the Sanskrit word "Yuj," meaning to unite or join. It represents the union of individual consciousness with universal consciousness, leading to a state of complete harmony and inner peace.'}),(0,wn.jsx)("p",{children:"Today, yoga has evolved into various styles including Hatha, Vinyasa, Ashtanga, Bikram, and many more, each offering unique benefits and approaches to this transformative practice."})]})]})})}),(0,wn.jsx)("section",{className:"section benefits-section gradient-bg-light",children:(0,wn.jsxs)("div",{className:"container",children:[(0,wn.jsxs)("div",{className:"section-title",children:[(0,wn.jsx)("span",{children:"Why Practice Yoga"}),(0,wn.jsx)("h2",{children:"Benefits of Regular Practice"})]}),(0,wn.jsx)("div",{className:"benefits-grid",children:e.map((e,t)=>(0,wn.jsxs)("div",{className:"benefit-card card",children:[(0,wn.jsx)("div",{className:"icon-box",children:e.icon}),(0,wn.jsx)("h3",{children:e.title}),(0,wn.jsx)("p",{children:e.description})]},t))})]})}),(0,wn.jsx)("section",{className:"section",children:(0,wn.jsx)("div",{className:"container",children:(0,wn.jsxs)("div",{className:"content-grid reverse",children:[(0,wn.jsxs)("div",{className:"content-text",children:[(0,wn.jsx)("h2",{children:"Importance of Correct Posture"}),(0,wn.jsx)("p",{children:"Proper alignment in yoga poses is crucial for maximizing benefits and preventing injuries. When poses are performed correctly, energy flows freely through the body, muscles are engaged appropriately, and the practice becomes both safe and effective."}),(0,wn.jsx)("p",{children:"Correct posture ensures that you're targeting the right muscle groups, maintaining proper breathing patterns, and building strength in a balanced way. It's the foundation of a sustainable yoga practice."}),(0,wn.jsxs)("div",{className:"highlight-box",children:[(0,wn.jsx)(Dt,{}),(0,wn.jsx)("span",{children:"Proper alignment can increase the effectiveness of your practice by up to 40%"})]})]}),(0,wn.jsx)("div",{className:"content-image",children:(0,wn.jsx)("img",{src:"https://images.unsplash.com/photo-1506126613408-eca07ce68773?w=600",alt:"Correct Yoga Posture"})})]})})}),(0,wn.jsx)("section",{className:"section problems-section",children:(0,wn.jsxs)("div",{className:"container",children:[(0,wn.jsxs)("div",{className:"section-title",children:[(0,wn.jsx)("span",{children:"Understanding the Risks"}),(0,wn.jsx)("h2",{children:"Problems with Incorrect Yoga Practice"})]}),(0,wn.jsxs)("div",{className:"problems-content",children:[(0,wn.jsx)("div",{className:"problems-image",children:(0,wn.jsx)(Kt,{className:"warning-icon"})}),(0,wn.jsxs)("div",{className:"problems-list",children:[(0,wn.jsx)("p",{children:"Practicing yoga with incorrect form can lead to various issues that may hinder your progress and cause long-term damage:"}),(0,wn.jsx)("ul",{children:["Muscle strain and chronic pain","Joint injuries and inflammation","Reduced flexibility over time","Poor breathing patterns","Decreased benefits from practice","Long-term spinal issues"].map((e,t)=>(0,wn.jsxs)("li",{children:[(0,wn.jsx)("span",{className:"bullet"}),e]},t))}),(0,wn.jsx)("p",{className:"note",children:"This is why proper guidance and feedback are essential, especially for beginners who are still learning the correct forms."})]})]})]})}),(0,wn.jsx)("section",{className:"section ai-section gradient-bg-light",children:(0,wn.jsx)("div",{className:"container",children:(0,wn.jsxs)("div",{className:"content-grid",children:[(0,wn.jsxs)("div",{className:"content-text",children:[(0,wn.jsx)("span",{className:"section-label",children:"Technology Meets Tradition"}),(0,wn.jsx)("h2",{children:"How AI Helps in Yoga Training"}),(0,wn.jsx)("p",{children:"Artificial Intelligence has revolutionized how we approach yoga practice. By using computer vision and machine learning, AI can analyze your poses in real-time and provide instant feedback, just like having a personal yoga instructor available 24/7."}),(0,wn.jsx)("ul",{className:"ai-benefits-list",children:["Real-time pose detection and correction","Personalized feedback based on your body","Tracking progress over time","Preventing injuries before they happen","Making yoga accessible to beginners","Providing consistent guidance 24/7"].map((e,t)=>(0,wn.jsxs)("li",{children:[(0,wn.jsx)(un,{}),(0,wn.jsx)("span",{children:e})]},t))})]}),(0,wn.jsx)("div",{className:"content-visual",children:(0,wn.jsxs)("div",{className:"ai-visual-card",children:[(0,wn.jsx)("div",{className:"ai-icon",children:(0,wn.jsx)(un,{})}),(0,wn.jsx)("h3",{children:"AI-Powered Detection"}),(0,wn.jsx)("p",{children:"Our system uses advanced pose estimation algorithms to detect 33 body keypoints and analyze your posture with 95%+ accuracy."})]})})]})})}),(0,wn.jsx)("section",{className:"cta-section",children:(0,wn.jsxs)("div",{className:"container",children:[(0,wn.jsx)("h2",{children:"Ready to Transform Your Practice?"}),(0,wn.jsx)("p",{children:"Start your AI-guided yoga journey today and experience the difference."}),(0,wn.jsxs)("div",{className:"cta-buttons",children:[(0,wn.jsx)(nt,{to:"/pose-detection",className:"btn btn-primary",children:"Try Pose Detection"}),(0,wn.jsx)(nt,{to:"/features",className:"btn btn-outline",children:"Explore Features"})]})]})})]})},Nn=()=>{const e=[{icon:(0,wn.jsx)(vn,{}),title:"Real-time Pose Detection",description:"Our AI system analyzes your yoga poses in real-time using your webcam, providing instant feedback on your form and alignment.",color:"#a177b4"},{icon:(0,wn.jsx)(ln,{}),title:"Skeleton Keypoint Tracking",description:"Advanced pose estimation tracks 33 body keypoints to create a precise skeleton overlay, ensuring accurate pose analysis.",color:"#9fc5a7"},{icon:(0,wn.jsx)(jt,{}),title:"Posture Correction Feedback",description:"Receive detailed instructions on how to correct your posture, with specific guidance for each body part.",color:"#f39c12"},{icon:(0,wn.jsx)(sn,{}),title:"Beginner-Friendly UI",description:"Clean and intuitive interface designed for users of all skill levels, making yoga practice accessible to everyone.",color:"#3498db"},{icon:(0,wn.jsx)(At,{}),title:"Camera-based Practice",description:"Simply use your device camera to practice yoga anywhere - no special equipment or sensors required.",color:"#e74c3c"},{icon:(0,wn.jsx)(Mt,{}),title:"ML-powered Accuracy",description:"Our machine learning models continuously improve, providing increasingly accurate pose detection over time.",color:"#2ecc71"}],t=[{icon:(0,wn.jsx)(zt,{}),title:"Customizable Settings",description:"Adjust sensitivity, camera preferences, and feedback options to match your needs."},{icon:(0,wn.jsx)(dn,{}),title:"Privacy First",description:"All processing happens locally - your video never leaves your device."}];return(0,wn.jsxs)("div",{className:"features-page",children:[(0,wn.jsx)("section",{className:"page-hero",children:(0,wn.jsxs)("div",{className:"container",children:[(0,wn.jsx)("span",{className:"page-label",children:"Discover"}),(0,wn.jsx)("h1",{children:"Platform Features"}),(0,wn.jsx)("p",{children:"Explore the powerful features that make YogaGuru the ultimate AI-powered yoga practice companion."})]})}),(0,wn.jsx)("section",{className:"section",children:(0,wn.jsx)("div",{className:"container",children:(0,wn.jsx)("div",{className:"features-grid",children:e.map((e,t)=>(0,wn.jsxs)("div",{className:"feature-item card",children:[(0,wn.jsx)("div",{className:"feature-icon",style:{backgroundColor:"".concat(e.color,"20"),color:e.color},children:e.icon}),(0,wn.jsx)("h3",{children:e.title}),(0,wn.jsx)("p",{children:e.description})]},t))})})}),(0,wn.jsx)("section",{className:"section highlight-section gradient-bg-light",children:(0,wn.jsx)("div",{className:"container",children:(0,wn.jsxs)("div",{className:"highlight-grid",children:[(0,wn.jsxs)("div",{className:"highlight-content",children:[(0,wn.jsx)("span",{className:"section-label",children:"Core Technology"}),(0,wn.jsx)("h2",{children:"Advanced Pose Estimation"}),(0,wn.jsx)("p",{children:"Our system uses state-of-the-art TensorFlow.js and MediaPipe Pose models to detect and track body keypoints with exceptional accuracy. The AI analyzes your posture in real-time, comparing it against ideal yoga poses to provide actionable feedback."}),(0,wn.jsxs)("ul",{className:"highlight-list",children:[(0,wn.jsx)("li",{children:"33 body keypoints tracked simultaneously"}),(0,wn.jsx)("li",{children:"Real-time processing at 30+ FPS"}),(0,wn.jsx)("li",{children:"Works with any standard webcam"}),(0,wn.jsx)("li",{children:"Browser-based - no installation required"})]}),(0,wn.jsx)(nt,{to:"/pose-detection",className:"btn btn-primary",children:"Try It Now"})]}),(0,wn.jsx)("div",{className:"highlight-visual",children:(0,wn.jsxs)("div",{className:"pose-demo",children:[(0,wn.jsx)("div",{className:"skeleton-preview",children:(0,wn.jsxs)("svg",{viewBox:"0 0 200 300",fill:"none",children:[(0,wn.jsx)("circle",{cx:"100",cy:"30",r:"20",stroke:"#a177b4",strokeWidth:"3"}),(0,wn.jsx)("line",{x1:"100",y1:"50",x2:"100",y2:"120",stroke:"#a177b4",strokeWidth:"3"}),(0,wn.jsx)("line",{x1:"100",y1:"70",x2:"50",y2:"100",stroke:"#a177b4",strokeWidth:"3"}),(0,wn.jsx)("line",{x1:"100",y1:"70",x2:"150",y2:"100",stroke:"#a177b4",strokeWidth:"3"}),(0,wn.jsx)("line",{x1:"100",y1:"120",x2:"60",y2:"200",stroke:"#a177b4",strokeWidth:"3"}),(0,wn.jsx)("line",{x1:"100",y1:"120",x2:"140",y2:"200",stroke:"#a177b4",strokeWidth:"3"}),(0,wn.jsx)("line",{x1:"60",y1:"200",x2:"50",y2:"280",stroke:"#a177b4",strokeWidth:"3"}),(0,wn.jsx)("line",{x1:"140",y1:"200",x2:"150",y2:"280",stroke:"#a177b4",strokeWidth:"3"}),(0,wn.jsx)("circle",{cx:"100",cy:"30",r:"5",fill:"#a177b4"}),(0,wn.jsx)("circle",{cx:"100",cy:"70",r:"5",fill:"#a177b4"}),(0,wn.jsx)("circle",{cx:"50",cy:"100",r:"5",fill:"#a177b4"}),(0,wn.jsx)("circle",{cx:"150",cy:"100",r:"5",fill:"#a177b4"}),(0,wn.jsx)("circle",{cx:"100",cy:"120",r:"5",fill:"#a177b4"}),(0,wn.jsx)("circle",{cx:"60",cy:"200",r:"5",fill:"#a177b4"}),(0,wn.jsx)("circle",{cx:"140",cy:"200",r:"5",fill:"#a177b4"}),(0,wn.jsx)("circle",{cx:"50",cy:"280",r:"5",fill:"#a177b4"}),(0,wn.jsx)("circle",{cx:"150",cy:"280",r:"5",fill:"#a177b4"})]})}),(0,wn.jsxs)("div",{className:"demo-labels",children:[(0,wn.jsx)("span",{className:"label label-1",children:"Head Position"}),(0,wn.jsx)("span",{className:"label label-2",children:"Shoulder Alignment"}),(0,wn.jsx)("span",{className:"label label-3",children:"Hip Angle"})]})]})})]})})}),(0,wn.jsx)("section",{className:"section",children:(0,wn.jsxs)("div",{className:"container",children:[(0,wn.jsxs)("div",{className:"section-title",children:[(0,wn.jsx)("span",{children:"More Features"}),(0,wn.jsx)("h2",{children:"Designed for Your Practice"})]}),(0,wn.jsx)("div",{className:"additional-grid",children:t.map((e,t)=>(0,wn.jsxs)("div",{className:"additional-card",children:[(0,wn.jsx)("div",{className:"icon-box",children:e.icon}),(0,wn.jsxs)("div",{className:"additional-content",children:[(0,wn.jsx)("h3",{children:e.title}),(0,wn.jsx)("p",{children:e.description})]})]},t))})]})}),(0,wn.jsx)("section",{className:"cta-section",children:(0,wn.jsxs)("div",{className:"container",children:[(0,wn.jsx)("h2",{children:"Experience All Features"}),(0,wn.jsx)("p",{children:"Start your AI-guided yoga practice and discover the full potential of YogaGuru."}),(0,wn.jsx)(nt,{to:"/pose-detection",className:"btn btn-primary",children:"Start Pose Detection"})]})})]})},Tn=()=>{const e=[{number:"01",icon:(0,wn.jsx)(At,{}),title:"Open Camera",description:"Grant camera access and position yourself in front of your device. Make sure you have enough space to perform yoga poses and good lighting for accurate detection.",tips:["Stand 6-8 feet from camera","Ensure good lighting","Wear fitted clothing"]},{number:"02",icon:(0,wn.jsx)(yn,{}),title:"Body Keypoint Detection",description:"Our AI system automatically detects 33 key points on your body including joints, extremities, and facial landmarks to create a precise skeleton model.",tips:["Stay within camera frame","Face the camera directly","Keep full body visible"]},{number:"03",icon:(0,wn.jsx)(Rt,{}),title:"AI Pose Analysis",description:"The machine learning model analyzes the angles and positions of your keypoints, comparing them against our database of correct yoga poses.",tips:["Hold poses steadily","Follow on-screen guidance","Move slowly for best detection"]},{number:"04",icon:(0,wn.jsx)(Ot,{}),title:"Pose Classification",description:"Your pose is classified and matched against known yoga asanas. The system determines which pose you're attempting and evaluates your accuracy.",tips:["Start with basic poses","Practice one pose at a time","Be patient with learning"]},{number:"05",icon:(0,wn.jsx)(Vt,{}),title:"Real-time Feedback",description:"Receive instant visual and text feedback on your screen showing your accuracy percentage, corrections needed, and tips for improvement.",tips:["Follow correction suggestions","Track your progress","Practice regularly"]}];return(0,wn.jsxs)("div",{className:"how-it-works-page",children:[(0,wn.jsx)("section",{className:"page-hero",children:(0,wn.jsxs)("div",{className:"container",children:[(0,wn.jsx)("span",{className:"page-label",children:"Step by Step"}),(0,wn.jsx)("h1",{children:"How It Works"}),(0,wn.jsx)("p",{children:"Follow these simple steps to start practicing yoga with AI-powered pose detection and real-time feedback."})]})}),(0,wn.jsx)("section",{className:"section steps-section",children:(0,wn.jsx)("div",{className:"container",children:(0,wn.jsx)("div",{className:"steps-container",children:e.map((t,n)=>(0,wn.jsxs)("div",{className:"step-item ".concat(n%2===1?"reverse":""),children:[(0,wn.jsxs)("div",{className:"step-visual",children:[(0,wn.jsx)("div",{className:"step-number",children:t.number}),(0,wn.jsx)("div",{className:"step-icon-container",children:(0,wn.jsx)("div",{className:"step-icon",children:t.icon})})]}),(0,wn.jsxs)("div",{className:"step-content",children:[(0,wn.jsx)("h3",{children:t.title}),(0,wn.jsx)("p",{children:t.description}),(0,wn.jsxs)("div",{className:"step-tips",children:[(0,wn.jsx)("h4",{children:"Tips:"}),(0,wn.jsx)("ul",{children:t.tips.map((e,t)=>(0,wn.jsx)("li",{children:e},t))})]})]}),n<e.length-1&&(0,wn.jsx)("div",{className:"step-connector",children:(0,wn.jsx)(Nt,{})})]},n))})})}),(0,wn.jsx)("section",{className:"section flow-section gradient-bg-light",children:(0,wn.jsxs)("div",{className:"container",children:[(0,wn.jsxs)("div",{className:"section-title",children:[(0,wn.jsx)("span",{children:"Visual Overview"}),(0,wn.jsx)("h2",{children:"The Detection Flow"})]}),(0,wn.jsxs)("div",{className:"flow-diagram",children:[(0,wn.jsxs)("div",{className:"flow-item",children:[(0,wn.jsx)("div",{className:"flow-icon",children:(0,wn.jsx)(At,{})}),(0,wn.jsx)("span",{children:"Camera Input"})]}),(0,wn.jsx)("div",{className:"flow-arrow",children:"\u2192"}),(0,wn.jsxs)("div",{className:"flow-item",children:[(0,wn.jsx)("div",{className:"flow-icon",children:(0,wn.jsx)(yn,{})}),(0,wn.jsx)("span",{children:"Keypoint Detection"})]}),(0,wn.jsx)("div",{className:"flow-arrow",children:"\u2192"}),(0,wn.jsxs)("div",{className:"flow-item",children:[(0,wn.jsx)("div",{className:"flow-icon",children:(0,wn.jsx)(Rt,{})}),(0,wn.jsx)("span",{children:"ML Processing"})]}),(0,wn.jsx)("div",{className:"flow-arrow",children:"\u2192"}),(0,wn.jsxs)("div",{className:"flow-item",children:[(0,wn.jsx)("div",{className:"flow-icon",children:(0,wn.jsx)(Ot,{})}),(0,wn.jsx)("span",{children:"Classification"})]}),(0,wn.jsx)("div",{className:"flow-arrow",children:"\u2192"}),(0,wn.jsxs)("div",{className:"flow-item",children:[(0,wn.jsx)("div",{className:"flow-icon",children:(0,wn.jsx)(Vt,{})}),(0,wn.jsx)("span",{children:"Feedback Display"})]})]})]})}),(0,wn.jsx)("section",{className:"section requirements-section",children:(0,wn.jsxs)("div",{className:"container",children:[(0,wn.jsxs)("div",{className:"section-title",children:[(0,wn.jsx)("span",{children:"Before You Start"}),(0,wn.jsx)("h2",{children:"Requirements"})]}),(0,wn.jsxs)("div",{className:"requirements-grid",children:[(0,wn.jsxs)("div",{className:"requirement-card",children:[(0,wn.jsx)("h3",{children:"Device"}),(0,wn.jsxs)("ul",{children:[(0,wn.jsx)("li",{children:"Computer, tablet, or smartphone"}),(0,wn.jsx)("li",{children:"Working webcam or front camera"}),(0,wn.jsx)("li",{children:"Modern web browser (Chrome, Firefox, Safari)"})]})]}),(0,wn.jsxs)("div",{className:"requirement-card",children:[(0,wn.jsx)("h3",{children:"Environment"}),(0,wn.jsxs)("ul",{children:[(0,wn.jsx)("li",{children:"Well-lit room"}),(0,wn.jsx)("li",{children:"Plain background preferred"}),(0,wn.jsx)("li",{children:"Enough space to move freely"})]})]}),(0,wn.jsxs)("div",{className:"requirement-card",children:[(0,wn.jsx)("h3",{children:"Attire"}),(0,wn.jsxs)("ul",{children:[(0,wn.jsx)("li",{children:"Comfortable, fitted clothing"}),(0,wn.jsx)("li",{children:"Avoid baggy clothes"}),(0,wn.jsx)("li",{children:"Contrasting colors to background"})]})]})]})]})}),(0,wn.jsx)("section",{className:"cta-section",children:(0,wn.jsxs)("div",{className:"container",children:[(0,wn.jsx)("h2",{children:"Ready to Begin?"}),(0,wn.jsx)("p",{children:"Start practicing yoga with real-time AI guidance now."}),(0,wn.jsx)(nt,{to:"/pose-detection",className:"btn btn-primary",children:"Start Pose Detection"})]})})]})},En=()=>{const e=Re(),[t,n]=(0,E.useState)([]),[a,s]=(0,E.useState)(""),[r,i]=(0,E.useState)("all"),o=(e,t)=>{var n,a,s;const r={Tadasana:"https://images.unsplash.com/photo-1545389336-cf090694435e?w=600&h=400&fit=crop&auto=format&q=80",Vrikshasana:"https://images.unsplash.com/photo-1758274525911-402f99afec14?w=600&h=400&fit=crop&auto=format&q=80",Bhujangasana:"https://images.unsplash.com/photo-1717821552922-61e18814a44a?w=600&h=400&fit=crop&auto=format&q=80","Setu Bandhasana":"https://images.unsplash.com/photo-1767611086180-6b1176976371?w=600&h=400&fit=crop&auto=format&q=80",Virabhadrasana:"https://images.unsplash.com/photo-1758599878236-47f6a918aed2?w=600&h=400&fit=crop&auto=format&q=80",Anjaneyasana:"https://images.unsplash.com/photo-1506126613408-eca07ce68773?w=600&h=400&fit=crop&auto=format&q=80",Paschimottanasana:"https://images.unsplash.com/photo-1506126613408-eca07ce68773?w=600&h=400&fit=crop&auto=format&q=80","Ardha Matsyendrasana":"https://images.unsplash.com/photo-1506126613408-eca07ce68773?w=600&h=400&fit=crop&auto=format&q=80",Gomukhasana:"https://images.unsplash.com/photo-1506126613408-eca07ce68773?w=600&h=400&fit=crop&auto=format&q=80",Garudasana:"https://images.unsplash.com/photo-1506126613408-eca07ce68773?w=600&h=400&fit=crop&auto=format&q=80","Supta Padangusthasana":"https://images.unsplash.com/photo-1506126613408-eca07ce68773?w=600&h=400&fit=crop&auto=format&q=80",Marjariasana:"https://images.unsplash.com/photo-1758599881262-7b79a56ac284?w=600&h=400&fit=crop&auto=format&q=80",Pavanamuktasana:"https://images.unsplash.com/photo-1506126613408-eca07ce68773?w=600&h=400&fit=crop&auto=format&q=80",Uttanasana:"https://images.unsplash.com/photo-1506126613408-eca07ce68773?w=600&h=400&fit=crop&auto=format&q=80","Viparita Karani":"https://images.unsplash.com/photo-1506126613408-eca07ce68773?w=600&h=400&fit=crop&auto=format&q=80",Trikonasana:"https://images.unsplash.com/photo-1767611090899-163209a4ead1?w=600&h=400&fit=crop&auto=format&q=80","Adho Mukha Svanasana":"https://images.unsplash.com/photo-1767611121194-3cb554c9a9ec?w=600&h=400&fit=crop&auto=format&q=80","Surya Namaskar":"https://images.unsplash.com/photo-1606663368493-131f4f97c095?w=600&h=400&fit=crop&auto=format&q=80",Balasana:"https://images.unsplash.com/photo-1767611118672-d3887038786c?w=600&h=400&fit=crop&auto=format&q=80",Padmasana:"https://images.unsplash.com/photo-1577344718665-3e7c0c1ecf6b?w=600&h=400&fit=crop&auto=format&q=80",Vajrasana:"https://images.unsplash.com/photo-1697274834392-04ff3b76ef20?w=600&h=400&fit=crop&auto=format&q=80"};if(r[t])return r[t];const i=((null===(n=t.split("(")[1])||void 0===n||null===(a=n.split(")")[0])||void 0===a?void 0:a.trim())||(null===(s=t.split("-")[1])||void 0===s?void 0:s.trim())||"yoga pose").toLowerCase().replace(/\s+/g,"%20").replace(/[^a-z0-9%]/g,"");return"https://source.unsplash.com/600x400/?yoga%20".concat(i,"&sig=").concat(e)};(0,E.useEffect)(()=>{const e=[{id:1,name:"\u0aad\u0ac1\u0a9c\u0a82\u0a97\u0abe\u0ab8\u0aa8 (Bhujangasana) - Cobra Pose",image:o(1,"Bhujangasana"),description:"A gentle backbend that strengthens the spine and opens the chest. This pose helps relieve back pain by stretching the front body and strengthening the back muscles.",difficulty:"Beginner",duration:"30-60 seconds",category:"Pain Relief"},{id:2,name:"\u0ab5\u0ac0\u0ab0\u0aad\u0aa6\u0acd\u0ab0\u0abe\u0ab8\u0aa8 II (Virabhadrasana II) - Warrior II",image:"https://images.unsplash.com/photo-1758599878236-47f6a918aed2?w=600&h=400&fit=crop&auto=format&q=80",description:"A powerful standing pose that strengthens the legs and opens the hips.",difficulty:"Intermediate",duration:"30-60 seconds",category:"Pain Relief"},{id:3,name:"\u0aae\u0abe\u0ab0\u0acd\u0a9c\u0ab0\u0ac0\u0a86\u0ab8\u0aa8 (Marjariasana) - Cat-Cow Pose",image:o(3,"Marjariasana"),description:"A gentle flowing movement that warms up the spine.",difficulty:"Beginner",duration:"1-2 minutes",category:"Pain Relief"},{id:4,name:"\u0ab8\u0ac7\u0aa4\u0ac1 \u0aac\u0a82\u0aa7\u0abe\u0ab8\u0aa8 (Setu Bandhasana) - Bridge Pose",image:o(4,"Setu Bandhasana"),description:"A gentle backbend that strengthens the back muscles.",difficulty:"Beginner",duration:"30-60 seconds",category:"Pain Relief"},{id:5,name:"\u0aa4\u0acd\u0ab0\u0abf\u0a95\u0acb\u0aa3\u0abe\u0ab8\u0aa8 (Trikonasana) - Triangle Pose",image:o(14,"Trikonasana"),description:"A standing pose that strengthens legs and relieves back pain.",difficulty:"Intermediate",duration:"30-60 seconds",category:"Pain Relief"},{id:6,name:"\u0aa4\u0abe\u0aa1\u0abe\u0ab8\u0aa8 (Tadasana) - Mountain Pose",image:o(63,"Tadasana"),description:"A foundational standing pose that improves posture.",difficulty:"Beginner",duration:"30-60 seconds",category:"Age Groups"},{id:7,name:"\u0ab5\u0ac3\u0a95\u0acd\u0ab7\u0abe\u0ab8\u0aa8 (Vrikshasana) - Tree Pose",image:o(64,"Vrikshasana"),description:"A balancing pose that strengthens legs and improves focus.",difficulty:"Beginner",duration:"30-60 seconds",category:"Age Groups"},{id:8,name:"\u0a85\u0aa7\u0acb \u0aae\u0ac1\u0a96 \u0ab6\u0acd\u0ab5\u0abe\u0aa8\u0abe\u0ab8\u0aa8 (Adho Mukha Svanasana) - Downward-Facing Dog",image:o(15,"Adho Mukha Svanasana"),description:"An inversion that strengthens the entire body.",difficulty:"Beginner",duration:"30-60 seconds",category:"Pain Relief"},{id:9,name:"\u0ab8\u0ac2\u0ab0\u0acd\u0aaf \u0aa8\u0aae\u0ab8\u0acd\u0a95\u0abe\u0ab0 (Surya Namaskar) - Sun Salutation",image:o(16,"Surya Namaskar"),description:"A complete sequence of 12 poses for full-body workout.",difficulty:"Intermediate",duration:"5-10 minutes",category:"Disease-Specific"},{id:10,name:"\u0aac\u0abe\u0ab2\u0abe\u0ab8\u0aa8 (Balasana) - Child's Pose",image:o(48,"Balasana"),description:"A restorative pose that calms the mind and stretches the back.",difficulty:"Beginner",duration:"1-3 minutes",category:"Disease-Specific"},{id:11,name:"\u0aaa\u0aa6\u0acd\u0aae\u0abe\u0ab8\u0aa8 (Padmasana) - Lotus Pose",image:o(34,"Padmasana"),description:"A seated meditation pose that promotes calmness.",difficulty:"Intermediate",duration:"5-30 minutes",category:"Meditation"},{id:12,name:"\u0ab5\u0a9c\u0acd\u0ab0\u0abe\u0ab8\u0aa8 (Vajrasana) - Thunderbolt Pose",image:o(23,"Vajrasana"),description:"A seated pose that aids digestion and meditation.",difficulty:"Beginner",duration:"5-30 minutes",category:"Disease-Specific"}];n(e)},[]);const c=t.filter(e=>{const t=e.name.toLowerCase().includes(a.toLowerCase())||e.description.toLowerCase().includes(a.toLowerCase()),n="all"===r||e.difficulty.toLowerCase()===r.toLowerCase();return t&&n});return(0,wn.jsxs)("div",{className:"pose-detection-page",children:[(0,wn.jsx)("section",{className:"page-hero compact",children:(0,wn.jsxs)("div",{className:"container",children:[(0,wn.jsx)("h1",{children:"Yoga Pose Library"}),(0,wn.jsx)("p",{children:"Explore and practice yoga poses with real-time AI feedback"})]})}),(0,wn.jsx)("section",{className:"section filter-section",children:(0,wn.jsxs)("div",{className:"container",children:[(0,wn.jsxs)("div",{className:"search-filter-container",children:[(0,wn.jsx)("div",{className:"search-box",children:(0,wn.jsx)("input",{type:"text",placeholder:"Search poses...",value:a,onChange:e=>s(e.target.value),className:"search-input"})}),(0,wn.jsx)("div",{className:"filter-box",children:(0,wn.jsxs)("select",{value:r,onChange:e=>i(e.target.value),className:"filter-select",children:[(0,wn.jsx)("option",{value:"all",children:"All Difficulties"}),(0,wn.jsx)("option",{value:"beginner",children:"Beginner"}),(0,wn.jsx)("option",{value:"intermediate",children:"Intermediate"}),(0,wn.jsx)("option",{value:"advanced",children:"Advanced"})]})})]}),(0,wn.jsxs)("p",{className:"results-count",children:[c.length," pose",1!==c.length?"s":""," found"]})]})}),(0,wn.jsx)("section",{className:"section poses-grid-section",children:(0,wn.jsxs)("div",{className:"container",children:[(0,wn.jsx)("div",{className:"poses-grid",children:c.map(t=>(0,wn.jsxs)("div",{className:"pose-card-clickable",onClick:()=>(t=>{e("/pose/".concat(t.id),{state:{pose:t}})})(t),children:[(0,wn.jsxs)("div",{className:"pose-image-container",children:[(0,wn.jsx)("img",{src:t.image,alt:t.name,className:"pose-image",loading:"lazy",onError:e=>{const n="https://source.unsplash.com/400x300/?yoga&sig=".concat(t.id);e.target.src=n}}),(0,wn.jsx)("span",{className:"pose-difficulty-badge ".concat(t.difficulty.toLowerCase()),children:t.difficulty})]}),(0,wn.jsxs)("div",{className:"pose-content",children:[(0,wn.jsx)("h3",{className:"pose-name",children:t.name}),(0,wn.jsx)("p",{className:"pose-description",children:t.description}),(0,wn.jsxs)("div",{className:"pose-meta",children:[(0,wn.jsxs)("span",{className:"pose-duration",children:["\u23f1 ",t.duration]}),(0,wn.jsx)("span",{className:"pose-category",children:t.category})]}),(0,wn.jsx)("div",{className:"pose-action",children:(0,wn.jsxs)("span",{children:["View Details ",(0,wn.jsx)(Nt,{})]})})]})]},t.id))}),0===c.length&&(0,wn.jsx)("div",{className:"no-poses-found",children:(0,wn.jsx)("p",{children:"No poses found matching your search criteria."})})]})}),(0,wn.jsx)("section",{className:"section tips-section gradient-bg-light",children:(0,wn.jsxs)("div",{className:"container",children:[(0,wn.jsx)("div",{className:"section-title",children:(0,wn.jsx)("h2",{children:"Tips for Best Results"})}),(0,wn.jsxs)("div",{className:"tips-grid",children:[(0,wn.jsxs)("div",{className:"tip-card",children:[(0,wn.jsx)("div",{className:"tip-number",children:"1"}),(0,wn.jsx)("h4",{children:"Proper Lighting"}),(0,wn.jsx)("p",{children:"Ensure you have adequate lighting. Natural light works best for accurate detection."})]}),(0,wn.jsxs)("div",{className:"tip-card",children:[(0,wn.jsx)("div",{className:"tip-number",children:"2"}),(0,wn.jsx)("h4",{children:"Clear Background"}),(0,wn.jsx)("p",{children:"A plain background helps the AI distinguish your body more accurately."})]}),(0,wn.jsxs)("div",{className:"tip-card",children:[(0,wn.jsx)("div",{className:"tip-number",children:"3"}),(0,wn.jsx)("h4",{children:"Full Body View"}),(0,wn.jsx)("p",{children:"Position yourself so your entire body is visible in the camera frame."})]}),(0,wn.jsxs)("div",{className:"tip-card",children:[(0,wn.jsx)("div",{className:"tip-number",children:"4"}),(0,wn.jsx)("h4",{children:"Slow Movements"}),(0,wn.jsx)("p",{children:"Move slowly into poses to allow the system to track your movements accurately."})]})]})]})})]})};function Rn(e){return ut({tag:"svg",attr:{role:"img",viewBox:"0 0 24 24"},child:[{tag:"title",attr:{},child:[]},{tag:"path",attr:{d:"M7.157 22.201A1.784 1.799 0 0 1 5.374 24a1.784 1.799 0 0 1-1.784-1.799 1.784 1.799 0 0 1 1.784-1.799 1.784 1.799 0 0 1 1.783 1.799zM20.582 1.427a1.415 1.427 0 0 1-1.415 1.428 1.415 1.427 0 0 1-1.416-1.428A1.415 1.427 0 0 1 19.167 0a1.415 1.427 0 0 1 1.415 1.427zM4.992 3.336A1.047 1.056 0 0 1 3.946 4.39a1.047 1.056 0 0 1-1.047-1.055A1.047 1.056 0 0 1 3.946 2.28a1.047 1.056 0 0 1 1.046 1.056zm7.336 1.517c3.769 0 7.06 1.38 8.768 3.424a9.363 9.363 0 0 0-3.393-4.547 9.238 9.238 0 0 0-5.377-1.728A9.238 9.238 0 0 0 6.95 3.73a9.363 9.363 0 0 0-3.394 4.547c1.713-2.04 5.004-3.424 8.772-3.424zm.001 13.295c-3.768 0-7.06-1.381-8.768-3.425a9.363 9.363 0 0 0 3.394 4.547A9.238 9.238 0 0 0 12.33 21a9.238 9.238 0 0 0 5.377-1.729 9.363 9.363 0 0 0 3.393-4.547c-1.712 2.044-5.003 3.425-8.772 3.425Z"}}]})(e)}function _n(e){return ut({tag:"svg",attr:{role:"img",viewBox:"0 0 24 24"},child:[{tag:"title",attr:{},child:[]},{tag:"path",attr:{d:"M11.8992.8525C8.735.8525 6.17 3.4175 6.17 6.5817c0 2.102 1.1321 3.9398 2.8198 4.9366l1.6412-2.7849c.0411-.0699.0176-.1593-.0495-.2048-.6233-.4227-1.0328-1.137-1.0328-1.947 0-1.298 1.0524-2.3504 2.3505-2.3504 1.2981 0 2.3505 1.0524 2.3505 2.3505 0 .8098-.4095 1.5242-1.0328 1.947-.0671.0454-.0907.1348-.0495.2047l1.6414 2.785c1.6878-.9969 2.8199-2.8346 2.8199-4.9367 0-3.1642-2.5653-5.7292-5.7295-5.7292zm-6.17 10.8366C2.565 11.6891 0 14.2541 0 17.4183c0 3.1642 2.565 5.7292 5.7292 5.7292 3.1798 0 5.8074-2.6995 5.7275-5.8762H8.2313c-.0847 0-.1513.0717-.1519.1564-.0082 1.266-1.0644 2.3411-2.3502 2.3411-1.2981 0-2.3505-1.0524-2.3505-2.3505 0-1.2982 1.0524-2.3505 2.3505-2.3505.34 0 .663.0724.9547.2022.0713.0318.1566.0077.1962-.0595l1.6464-2.7935c-.8273-.4636-1.7815-.7279-2.7973-.7279zm15.4424.7614l-1.6366 2.7878c-.041.07-.0172.1594.05.2048.624.4217 1.0348 1.1354 1.0363 1.9452.0022 1.298-1.0483 2.352-2.3465 2.3542-1.298.0023-2.3523-1.0482-2.3545-2.3462-.0015-.8098.4068-1.5248 1.0294-1.9486.067-.0457.0905-.1353.0492-.2051l-1.6464-2.7818c-1.6859.9998-2.8146 2.8394-2.811 4.9415.0056 3.1641 2.575 5.7248 5.7393 5.7192 3.1641-.0054 5.7246-2.575 5.7192-5.7392-.0037-2.1022-1.139-3.938-2.8284-4.9318z"}}]})(e)}function An(e){return ut({tag:"svg",attr:{role:"img",viewBox:"0 0 24 24"},child:[{tag:"title",attr:{},child:[]},{tag:"path",attr:{d:"M1.292 5.856L11.54 0v24l-4.095-2.378V7.603l-6.168 3.564.015-5.31zm21.43 5.311l-.014-5.31L12.46 0v24l4.095-2.378V14.87l3.092 1.788-.018-4.618-3.074-1.756V7.603l6.168 3.564z"}}]})(e)}function Mn(e){return ut({tag:"svg",attr:{role:"img",viewBox:"0 0 24 24"},child:[{tag:"title",attr:{},child:[]},{tag:"path",attr:{d:"M23.15 2.587L18.21.21a1.494 1.494 0 0 0-1.705.29l-9.46 8.63-4.12-3.128a.999.999 0 0 0-1.276.057L.327 7.261A1 1 0 0 0 .326 8.74L3.899 12 .326 15.26a1 1 0 0 0 .001 1.479L1.65 17.94a.999.999 0 0 0 1.276.057l4.12-3.128 9.46 8.63a1.492 1.492 0 0 0 1.704.29l4.942-2.377A1.5 1.5 0 0 0 24 20.06V3.939a1.5 1.5 0 0 0-.85-1.352zm-5.146 14.861L10.826 12l7.178-5.448v10.896z"}}]})(e)}const Pn=()=>{const e=[{title:"Frontend Technologies",icon:(0,wn.jsx)($t,{}),color:"#61dafb",technologies:[{name:"HTML5",icon:(0,wn.jsx)(gt,{}),color:"#e34f26"},{name:"CSS3",icon:(0,wn.jsx)(dt,{}),color:"#1572b6"},{name:"JavaScript",icon:(0,wn.jsx)(bt,{}),color:"#f7df1e"},{name:"ReactJS",icon:(0,wn.jsx)(kt,{}),color:"#61dafb"}]},{title:"Backend Technologies",icon:(0,wn.jsx)(Bt,{}),color:"#68a063",technologies:[{name:"Python",icon:(0,wn.jsx)(wt,{}),color:"#3776ab"},{name:"Node.js",icon:(0,wn.jsx)(vt,{}),color:"#68a063"},{name:"OpenCV",icon:(0,wn.jsx)(_n,{}),color:"#5c3ee8"},{name:"TensorFlow",icon:(0,wn.jsx)(An,{}),color:"#ff6f00"}]},{title:"Database",icon:(0,wn.jsx)(Wt,{}),color:"#336791",technologies:[{name:"SQL Database",icon:(0,wn.jsx)(Wt,{}),color:"#336791"}]},{title:"Development Tools",icon:(0,wn.jsx)(Lt,{}),color:"#007acc",technologies:[{name:"VS Code",icon:(0,wn.jsx)(Mn,{}),color:"#007acc"},{name:"Jupyter Notebook",icon:(0,wn.jsx)(Rn,{}),color:"#f37626"}]}];return(0,wn.jsxs)("div",{className:"tech-stack-page",children:[(0,wn.jsx)("section",{className:"page-hero",children:(0,wn.jsxs)("div",{className:"container",children:[(0,wn.jsx)("span",{className:"page-label",children:"Under the Hood"}),(0,wn.jsx)("h1",{children:"Technology Stack"}),(0,wn.jsx)("p",{children:"Explore the cutting-edge technologies powering YogaGuru's AI-based yoga pose detection platform."})]})}),(0,wn.jsx)("section",{className:"section",children:(0,wn.jsx)("div",{className:"container",children:(0,wn.jsx)("div",{className:"tech-categories",children:e.map((e,t)=>(0,wn.jsxs)("div",{className:"tech-category",children:[(0,wn.jsxs)("div",{className:"category-header",children:[(0,wn.jsx)("div",{className:"category-icon",style:{backgroundColor:"".concat(e.color,"20"),color:e.color},children:e.icon}),(0,wn.jsx)("h2",{children:e.title})]}),(0,wn.jsx)("div",{className:"tech-grid",children:e.technologies.map((e,t)=>(0,wn.jsxs)("div",{className:"tech-card",children:[(0,wn.jsx)("div",{className:"tech-icon",style:{color:e.color},children:e.icon}),(0,wn.jsx)("span",{children:e.name})]},t))})]},t))})})}),(0,wn.jsx)("section",{className:"section architecture-section gradient-bg-light",children:(0,wn.jsxs)("div",{className:"container",children:[(0,wn.jsxs)("div",{className:"section-title",children:[(0,wn.jsx)("span",{children:"System Design"}),(0,wn.jsx)("h2",{children:"Architecture Overview"})]}),(0,wn.jsx)("div",{className:"architecture-grid",children:[{layer:"Presentation Layer",description:"React-based user interface with responsive design",technologies:["React","CSS3","HTML5"]},{layer:"Application Layer",description:"Business logic and API endpoints",technologies:["Node.js","Python Flask"]},{layer:"ML Processing Layer",description:"Pose estimation and classification models",technologies:["TensorFlow.js","MediaPipe","OpenCV"]},{layer:"Data Layer",description:"User data and pose training datasets",technologies:["SQL Database","JSON"]}].map((e,t)=>(0,wn.jsxs)("div",{className:"layer-card",children:[(0,wn.jsx)("div",{className:"layer-number",children:t+1}),(0,wn.jsx)("h3",{children:e.layer}),(0,wn.jsx)("p",{children:e.description}),(0,wn.jsx)("div",{className:"layer-tech",children:e.technologies.map((e,t)=>(0,wn.jsx)("span",{className:"tech-tag",children:e},t))})]},t))})]})}),(0,wn.jsx)("section",{className:"section ml-section",children:(0,wn.jsx)("div",{className:"container",children:(0,wn.jsxs)("div",{className:"ml-content",children:[(0,wn.jsxs)("div",{className:"ml-text",children:[(0,wn.jsx)("span",{className:"section-label",children:"Core Technology"}),(0,wn.jsx)("h2",{children:"Machine Learning Models"}),(0,wn.jsx)("p",{children:"Our pose detection system uses state-of-the-art machine learning models to accurately identify and analyze yoga poses. The system combines multiple AI technologies to provide real-time feedback."}),(0,wn.jsxs)("div",{className:"ml-features",children:[(0,wn.jsxs)("div",{className:"ml-feature",children:[(0,wn.jsx)("h4",{children:"MediaPipe Pose"}),(0,wn.jsx)("p",{children:"Google's ML solution for high-fidelity body pose tracking"})]}),(0,wn.jsxs)("div",{className:"ml-feature",children:[(0,wn.jsx)("h4",{children:"TensorFlow.js"}),(0,wn.jsx)("p",{children:"Browser-based machine learning for real-time processing"})]}),(0,wn.jsxs)("div",{className:"ml-feature",children:[(0,wn.jsx)("h4",{children:"Custom Classifiers"}),(0,wn.jsx)("p",{children:"Trained models for yoga pose classification and scoring"})]})]})]}),(0,wn.jsx)("div",{className:"ml-visual",children:(0,wn.jsxs)("div",{className:"model-diagram",children:[(0,wn.jsx)("div",{className:"diagram-node input",children:(0,wn.jsx)("span",{children:"Camera Input"})}),(0,wn.jsx)("div",{className:"diagram-arrow",children:"\u2193"}),(0,wn.jsx)("div",{className:"diagram-node process",children:(0,wn.jsx)("span",{children:"Pose Estimation"})}),(0,wn.jsx)("div",{className:"diagram-arrow",children:"\u2193"}),(0,wn.jsx)("div",{className:"diagram-node process",children:(0,wn.jsx)("span",{children:"Keypoint Extraction"})}),(0,wn.jsx)("div",{className:"diagram-arrow",children:"\u2193"}),(0,wn.jsx)("div",{className:"diagram-node process",children:(0,wn.jsx)("span",{children:"Classification"})}),(0,wn.jsx)("div",{className:"diagram-arrow",children:"\u2193"}),(0,wn.jsx)("div",{className:"diagram-node output",children:(0,wn.jsx)("span",{children:"Feedback Output"})})]})})]})})}),(0,wn.jsx)("section",{className:"section stats-section",children:(0,wn.jsx)("div",{className:"container",children:(0,wn.jsxs)("div",{className:"stats-grid",children:[(0,wn.jsxs)("div",{className:"stat-item",children:[(0,wn.jsx)("h3",{children:"33"}),(0,wn.jsx)("p",{children:"Body Keypoints Tracked"})]}),(0,wn.jsxs)("div",{className:"stat-item",children:[(0,wn.jsx)("h3",{children:"30+"}),(0,wn.jsx)("p",{children:"FPS Real-time Processing"})]}),(0,wn.jsxs)("div",{className:"stat-item",children:[(0,wn.jsx)("h3",{children:"95%"}),(0,wn.jsx)("p",{children:"Detection Accuracy"})]}),(0,wn.jsxs)("div",{className:"stat-item",children:[(0,wn.jsx)("h3",{children:"10+"}),(0,wn.jsx)("p",{children:"Yoga Poses Supported"})]})]})})})]})};function Dn(e){return Dn="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},Dn(e)}function On(e){var t=function(e,t){if("object"!=Dn(e)||!e)return e;var n=e[Symbol.toPrimitive];if(void 0!==n){var a=n.call(e,t||"default");if("object"!=Dn(a))return a;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===t?String:Number)(e)}(e,"string");return"symbol"==Dn(t)?t:t+""}function Fn(e,t,n){return(t=On(t))in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function Ln(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter(function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable})),n.push.apply(n,a)}return n}function zn(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?Ln(Object(n),!0).forEach(function(t){Fn(e,t,n[t])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):Ln(Object(n)).forEach(function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))})}return e}function Bn(e){return e+.5|0}const jn=(e,t,n)=>Math.max(Math.min(e,n),t);function Wn(e){return jn(Bn(2.55*e),0,255)}function Vn(e){return jn(Bn(255*e),0,255)}function Un(e){return jn(Bn(e/2.55)/100,0,1)}function Hn(e){return jn(Bn(100*e),0,100)}const Gn={0:0,1:1,2:2,3:3,4:4,5:5,6:6,7:7,8:8,9:9,A:10,B:11,C:12,D:13,E:14,F:15,a:10,b:11,c:12,d:13,e:14,f:15},qn=[..."0123456789ABCDEF"],Kn=e=>qn[15&e],Xn=e=>qn[(240&e)>>4]+qn[15&e],Yn=e=>(240&e)>>4===(15&e);function Qn(e){var t=(e=>Yn(e.r)&&Yn(e.g)&&Yn(e.b)&&Yn(e.a))(e)?Kn:Xn;return e?"#"+t(e.r)+t(e.g)+t(e.b)+((e,t)=>e<255?t(e):"")(e.a,t):void 0}const Zn=/^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;function Jn(e,t,n){const a=t*Math.min(n,1-n),s=function(t){let s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:(t+e/30)%12;return n-a*Math.max(Math.min(s-3,9-s,1),-1)};return[s(0),s(8),s(4)]}function $n(e,t,n){const a=function(a){let s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:(a+e/60)%6;return n-n*t*Math.max(Math.min(s,4-s,1),0)};return[a(5),a(3),a(1)]}function ea(e,t,n){const a=Jn(e,1,.5);let s;for(t+n>1&&(s=1/(t+n),t*=s,n*=s),s=0;s<3;s++)a[s]*=1-t-n,a[s]+=t;return a}function ta(e){const t=e.r/255,n=e.g/255,a=e.b/255,s=Math.max(t,n,a),r=Math.min(t,n,a),i=(s+r)/2;let o,c,l;return s!==r&&(l=s-r,c=i>.5?l/(2-s-r):l/(s+r),o=function(e,t,n,a,s){return e===s?(t-n)/a+(t<n?6:0):t===s?(n-e)/a+2:(e-t)/a+4}(t,n,a,l,s),o=60*o+.5),[0|o,c||0,i]}function na(e,t,n,a){return(Array.isArray(t)?e(t[0],t[1],t[2]):e(t,n,a)).map(Vn)}function aa(e,t,n){return na(Jn,e,t,n)}function sa(e){return(e%360+360)%360}function ra(e){const t=Zn.exec(e);let n,a=255;if(!t)return;t[5]!==n&&(a=t[6]?Wn(+t[5]):Vn(+t[5]));const s=sa(+t[2]),r=+t[3]/100,i=+t[4]/100;return n="hwb"===t[1]?function(e,t,n){return na(ea,e,t,n)}(s,r,i):"hsv"===t[1]?function(e,t,n){return na($n,e,t,n)}(s,r,i):aa(s,r,i),{r:n[0],g:n[1],b:n[2],a:a}}const ia={x:"dark",Z:"light",Y:"re",X:"blu",W:"gr",V:"medium",U:"slate",A:"ee",T:"ol",S:"or",B:"ra",C:"lateg",D:"ights",R:"in",Q:"turquois",E:"hi",P:"ro",O:"al",N:"le",M:"de",L:"yello",F:"en",K:"ch",G:"arks",H:"ea",I:"ightg",J:"wh"},oa={OiceXe:"f0f8ff",antiquewEte:"faebd7",aqua:"ffff",aquamarRe:"7fffd4",azuY:"f0ffff",beige:"f5f5dc",bisque:"ffe4c4",black:"0",blanKedOmond:"ffebcd",Xe:"ff",XeviTet:"8a2be2",bPwn:"a52a2a",burlywood:"deb887",caMtXe:"5f9ea0",KartYuse:"7fff00",KocTate:"d2691e",cSO:"ff7f50",cSnflowerXe:"6495ed",cSnsilk:"fff8dc",crimson:"dc143c",cyan:"ffff",xXe:"8b",xcyan:"8b8b",xgTMnPd:"b8860b",xWay:"a9a9a9",xgYF:"6400",xgYy:"a9a9a9",xkhaki:"bdb76b",xmagFta:"8b008b",xTivegYF:"556b2f",xSange:"ff8c00",xScEd:"9932cc",xYd:"8b0000",xsOmon:"e9967a",xsHgYF:"8fbc8f",xUXe:"483d8b",xUWay:"2f4f4f",xUgYy:"2f4f4f",xQe:"ced1",xviTet:"9400d3",dAppRk:"ff1493",dApskyXe:"bfff",dimWay:"696969",dimgYy:"696969",dodgerXe:"1e90ff",fiYbrick:"b22222",flSOwEte:"fffaf0",foYstWAn:"228b22",fuKsia:"ff00ff",gaRsbSo:"dcdcdc",ghostwEte:"f8f8ff",gTd:"ffd700",gTMnPd:"daa520",Way:"808080",gYF:"8000",gYFLw:"adff2f",gYy:"808080",honeyMw:"f0fff0",hotpRk:"ff69b4",RdianYd:"cd5c5c",Rdigo:"4b0082",ivSy:"fffff0",khaki:"f0e68c",lavFMr:"e6e6fa",lavFMrXsh:"fff0f5",lawngYF:"7cfc00",NmoncEffon:"fffacd",ZXe:"add8e6",ZcSO:"f08080",Zcyan:"e0ffff",ZgTMnPdLw:"fafad2",ZWay:"d3d3d3",ZgYF:"90ee90",ZgYy:"d3d3d3",ZpRk:"ffb6c1",ZsOmon:"ffa07a",ZsHgYF:"20b2aa",ZskyXe:"87cefa",ZUWay:"778899",ZUgYy:"778899",ZstAlXe:"b0c4de",ZLw:"ffffe0",lime:"ff00",limegYF:"32cd32",lRF:"faf0e6",magFta:"ff00ff",maPon:"800000",VaquamarRe:"66cdaa",VXe:"cd",VScEd:"ba55d3",VpurpN:"9370db",VsHgYF:"3cb371",VUXe:"7b68ee",VsprRggYF:"fa9a",VQe:"48d1cc",VviTetYd:"c71585",midnightXe:"191970",mRtcYam:"f5fffa",mistyPse:"ffe4e1",moccasR:"ffe4b5",navajowEte:"ffdead",navy:"80",Tdlace:"fdf5e6",Tive:"808000",TivedBb:"6b8e23",Sange:"ffa500",SangeYd:"ff4500",ScEd:"da70d6",pOegTMnPd:"eee8aa",pOegYF:"98fb98",pOeQe:"afeeee",pOeviTetYd:"db7093",papayawEp:"ffefd5",pHKpuff:"ffdab9",peru:"cd853f",pRk:"ffc0cb",plum:"dda0dd",powMrXe:"b0e0e6",purpN:"800080",YbeccapurpN:"663399",Yd:"ff0000",Psybrown:"bc8f8f",PyOXe:"4169e1",saddNbPwn:"8b4513",sOmon:"fa8072",sandybPwn:"f4a460",sHgYF:"2e8b57",sHshell:"fff5ee",siFna:"a0522d",silver:"c0c0c0",skyXe:"87ceeb",UXe:"6a5acd",UWay:"708090",UgYy:"708090",snow:"fffafa",sprRggYF:"ff7f",stAlXe:"4682b4",tan:"d2b48c",teO:"8080",tEstN:"d8bfd8",tomato:"ff6347",Qe:"40e0d0",viTet:"ee82ee",JHt:"f5deb3",wEte:"ffffff",wEtesmoke:"f5f5f5",Lw:"ffff00",LwgYF:"9acd32"};let ca;function la(e){ca||(ca=function(){const e={},t=Object.keys(oa),n=Object.keys(ia);let a,s,r,i,o;for(a=0;a<t.length;a++){for(i=o=t[a],s=0;s<n.length;s++)r=n[s],o=o.replace(r,ia[r]);r=parseInt(oa[i],16),e[o]=[r>>16&255,r>>8&255,255&r]}return e}(),ca.transparent=[0,0,0,0]);const t=ca[e.toLowerCase()];return t&&{r:t[0],g:t[1],b:t[2],a:4===t.length?t[3]:255}}const ua=/^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;const ha=e=>e<=.0031308?12.92*e:1.055*Math.pow(e,1/2.4)-.055,da=e=>e<=.04045?e/12.92:Math.pow((e+.055)/1.055,2.4);function pa(e,t,n){if(e){let a=ta(e);a[t]=Math.max(0,Math.min(a[t]+a[t]*n,0===t?360:1)),a=aa(a),e.r=a[0],e.g=a[1],e.b=a[2]}}function fa(e,t){return e?Object.assign(t||{},e):e}function ma(e){var t={r:0,g:0,b:0,a:255};return Array.isArray(e)?e.length>=3&&(t={r:e[0],g:e[1],b:e[2],a:255},e.length>3&&(t.a=Vn(e[3]))):(t=fa(e,{r:0,g:0,b:0,a:1})).a=Vn(t.a),t}function ga(e){return"r"===e.charAt(0)?function(e){const t=ua.exec(e);let n,a,s,r=255;if(t){if(t[7]!==n){const e=+t[7];r=t[8]?Wn(e):jn(255*e,0,255)}return n=+t[1],a=+t[3],s=+t[5],n=255&(t[2]?Wn(n):jn(n,0,255)),a=255&(t[4]?Wn(a):jn(a,0,255)),s=255&(t[6]?Wn(s):jn(s,0,255)),{r:n,g:a,b:s,a:r}}}(e):ra(e)}class ya{constructor(e){if(e instanceof ya)return e;const t=typeof e;let n;"object"===t?n=ma(e):"string"===t&&(n=function(e){var t,n=e.length;return"#"===e[0]&&(4===n||5===n?t={r:255&17*Gn[e[1]],g:255&17*Gn[e[2]],b:255&17*Gn[e[3]],a:5===n?17*Gn[e[4]]:255}:7!==n&&9!==n||(t={r:Gn[e[1]]<<4|Gn[e[2]],g:Gn[e[3]]<<4|Gn[e[4]],b:Gn[e[5]]<<4|Gn[e[6]],a:9===n?Gn[e[7]]<<4|Gn[e[8]]:255})),t}(e)||la(e)||ga(e)),this._rgb=n,this._valid=!!n}get valid(){return this._valid}get rgb(){var e=fa(this._rgb);return e&&(e.a=Un(e.a)),e}set rgb(e){this._rgb=ma(e)}rgbString(){return this._valid?(e=this._rgb)&&(e.a<255?"rgba(".concat(e.r,", ").concat(e.g,", ").concat(e.b,", ").concat(Un(e.a),")"):"rgb(".concat(e.r,", ").concat(e.g,", ").concat(e.b,")")):void 0;var e}hexString(){return this._valid?Qn(this._rgb):void 0}hslString(){return this._valid?function(e){if(!e)return;const t=ta(e),n=t[0],a=Hn(t[1]),s=Hn(t[2]);return e.a<255?"hsla(".concat(n,", ").concat(a,"%, ").concat(s,"%, ").concat(Un(e.a),")"):"hsl(".concat(n,", ").concat(a,"%, ").concat(s,"%)")}(this._rgb):void 0}mix(e,t){if(e){const n=this.rgb,a=e.rgb;let s;const r=t===s?.5:t,i=2*r-1,o=n.a-a.a,c=((i*o===-1?i:(i+o)/(1+i*o))+1)/2;s=1-c,n.r=255&c*n.r+s*a.r+.5,n.g=255&c*n.g+s*a.g+.5,n.b=255&c*n.b+s*a.b+.5,n.a=r*n.a+(1-r)*a.a,this.rgb=n}return this}interpolate(e,t){return e&&(this._rgb=function(e,t,n){const a=da(Un(e.r)),s=da(Un(e.g)),r=da(Un(e.b));return{r:Vn(ha(a+n*(da(Un(t.r))-a))),g:Vn(ha(s+n*(da(Un(t.g))-s))),b:Vn(ha(r+n*(da(Un(t.b))-r))),a:e.a+n*(t.a-e.a)}}(this._rgb,e._rgb,t)),this}clone(){return new ya(this.rgb)}alpha(e){return this._rgb.a=Vn(e),this}clearer(e){return this._rgb.a*=1-e,this}greyscale(){const e=this._rgb,t=Bn(.3*e.r+.59*e.g+.11*e.b);return e.r=e.g=e.b=t,this}opaquer(e){return this._rgb.a*=1+e,this}negate(){const e=this._rgb;return e.r=255-e.r,e.g=255-e.g,e.b=255-e.b,this}lighten(e){return pa(this._rgb,2,e),this}darken(e){return pa(this._rgb,2,-e),this}saturate(e){return pa(this._rgb,1,e),this}desaturate(e){return pa(this._rgb,1,-e),this}rotate(e){return function(e,t){var n=ta(e);n[0]=sa(n[0]+t),n=aa(n),e.r=n[0],e.g=n[1],e.b=n[2]}(this._rgb,e),this}}function ba(){}const xa=(()=>{let e=0;return()=>e++})();function va(e){return null===e||void 0===e}function wa(e){if(Array.isArray&&Array.isArray(e))return!0;const t=Object.prototype.toString.call(e);return"[object"===t.slice(0,7)&&"Array]"===t.slice(-6)}function ka(e){return null!==e&&"[object Object]"===Object.prototype.toString.call(e)}function Sa(e){return("number"===typeof e||e instanceof Number)&&isFinite(+e)}function Ca(e,t){return Sa(e)?e:t}function Ia(e,t){return"undefined"===typeof e?t:e}const Na=(e,t)=>"string"===typeof e&&e.endsWith("%")?parseFloat(e)/100*t:+e;function Ta(e,t,n){if(e&&"function"===typeof e.call)return e.apply(n,t)}function Ea(e,t,n,a){let s,r,i;if(wa(e))if(r=e.length,a)for(s=r-1;s>=0;s--)t.call(n,e[s],s);else for(s=0;s<r;s++)t.call(n,e[s],s);else if(ka(e))for(i=Object.keys(e),r=i.length,s=0;s<r;s++)t.call(n,e[i[s]],i[s])}function Ra(e,t){let n,a,s,r;if(!e||!t||e.length!==t.length)return!1;for(n=0,a=e.length;n<a;++n)if(s=e[n],r=t[n],s.datasetIndex!==r.datasetIndex||s.index!==r.index)return!1;return!0}function _a(e){if(wa(e))return e.map(_a);if(ka(e)){const t=Object.create(null),n=Object.keys(e),a=n.length;let s=0;for(;s<a;++s)t[n[s]]=_a(e[n[s]]);return t}return e}function Aa(e){return-1===["__proto__","prototype","constructor"].indexOf(e)}function Ma(e,t,n,a){if(!Aa(e))return;const s=t[e],r=n[e];ka(s)&&ka(r)?Pa(s,r,a):t[e]=_a(r)}function Pa(e,t,n){const a=wa(t)?t:[t],s=a.length;if(!ka(e))return e;const r=(n=n||{}).merger||Ma;let i;for(let o=0;o<s;++o){if(i=a[o],!ka(i))continue;const t=Object.keys(i);for(let a=0,s=t.length;a<s;++a)r(t[a],e,i,n)}return e}function Da(e,t){return Pa(e,t,{merger:Oa})}function Oa(e,t,n){if(!Aa(e))return;const a=t[e],s=n[e];ka(a)&&ka(s)?Da(a,s):Object.prototype.hasOwnProperty.call(t,e)||(t[e]=_a(s))}const Fa={"":e=>e,x:e=>e.x,y:e=>e.y};function La(e,t){const n=Fa[t]||(Fa[t]=function(e){const t=function(e){const t=e.split("."),n=[];let a="";for(const s of t)a+=s,a.endsWith("\\")?a=a.slice(0,-1)+".":(n.push(a),a="");return n}(e);return e=>{for(const n of t){if(""===n)break;e=e&&e[n]}return e}}(t));return n(e)}function za(e){return e.charAt(0).toUpperCase()+e.slice(1)}const Ba=e=>"undefined"!==typeof e,ja=e=>"function"===typeof e,Wa=(e,t)=>{if(e.size!==t.size)return!1;for(const n of e)if(!t.has(n))return!1;return!0};const Va=Math.PI,Ua=2*Va,Ha=Ua+Va,Ga=Number.POSITIVE_INFINITY,qa=Va/180,Ka=Va/2,Xa=Va/4,Ya=2*Va/3,Qa=Math.log10,Za=Math.sign;function Ja(e,t,n){return Math.abs(e-t)<n}function $a(e){const t=Math.round(e);e=Ja(e,t,e/1e3)?t:e;const n=Math.pow(10,Math.floor(Qa(e))),a=e/n;return(a<=1?1:a<=2?2:a<=5?5:10)*n}function es(e){return!function(e){return"symbol"===typeof e||"object"===typeof e&&null!==e&&!(Symbol.toPrimitive in e||"toString"in e||"valueOf"in e)}(e)&&!isNaN(parseFloat(e))&&isFinite(e)}function ts(e,t,n){let a,s,r;for(a=0,s=e.length;a<s;a++)r=e[a][n],isNaN(r)||(t.min=Math.min(t.min,r),t.max=Math.max(t.max,r))}function ns(e){return e*(Va/180)}function as(e){return e*(180/Va)}function ss(e){if(!Sa(e))return;let t=1,n=0;for(;Math.round(e*t)/t!==e;)t*=10,n++;return n}function rs(e,t){const n=t.x-e.x,a=t.y-e.y,s=Math.sqrt(n*n+a*a);let r=Math.atan2(a,n);return r<-.5*Va&&(r+=Ua),{angle:r,distance:s}}function is(e,t){return Math.sqrt(Math.pow(t.x-e.x,2)+Math.pow(t.y-e.y,2))}function os(e,t){return(e-t+Ha)%Ua-Va}function cs(e){return(e%Ua+Ua)%Ua}function ls(e,t,n,a){const s=cs(e),r=cs(t),i=cs(n),o=cs(r-s),c=cs(i-s),l=cs(s-r),u=cs(s-i);return s===r||s===i||a&&r===i||o>c&&l<u}function us(e,t,n){return Math.max(t,Math.min(n,e))}function hs(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1e-6;return e>=Math.min(t,n)-a&&e<=Math.max(t,n)+a}function ds(e,t,n){n=n||(n=>e[n]<t);let a,s=e.length-1,r=0;for(;s-r>1;)a=r+s>>1,n(a)?r=a:s=a;return{lo:r,hi:s}}const ps=(e,t,n,a)=>ds(e,n,a?a=>{const s=e[a][t];return s<n||s===n&&e[a+1][t]===n}:a=>e[a][t]<n),fs=(e,t,n)=>ds(e,n,a=>e[a][t]>=n);const ms=["push","pop","shift","splice","unshift"];function gs(e,t){const n=e._chartjs;if(!n)return;const a=n.listeners,s=a.indexOf(t);-1!==s&&a.splice(s,1),a.length>0||(ms.forEach(t=>{delete e[t]}),delete e._chartjs)}function ys(e){const t=new Set(e);return t.size===e.length?e:Array.from(t)}const bs="undefined"===typeof window?function(e){return e()}:window.requestAnimationFrame;function xs(e,t){let n=[],a=!1;return function(){for(var s=arguments.length,r=new Array(s),i=0;i<s;i++)r[i]=arguments[i];n=r,a||(a=!0,bs.call(window,()=>{a=!1,e.apply(t,n)}))}}const vs=e=>"start"===e?"left":"end"===e?"right":"center",ws=(e,t,n)=>"start"===e?t:"end"===e?n:(t+n)/2;function ks(e,t,n){const a=t.length;let s=0,r=a;if(e._sorted){const{iScale:i,vScale:o,_parsed:c}=e,l=e.dataset&&e.dataset.options?e.dataset.options.spanGaps:null,u=i.axis,{min:h,max:d,minDefined:p,maxDefined:f}=i.getUserBounds();if(p){if(s=Math.min(ps(c,u,h).lo,n?a:ps(t,u,i.getPixelForValue(h)).lo),l){const e=c.slice(0,s+1).reverse().findIndex(e=>!va(e[o.axis]));s-=Math.max(0,e)}s=us(s,0,a-1)}if(f){let e=Math.max(ps(c,i.axis,d,!0).hi+1,n?0:ps(t,u,i.getPixelForValue(d),!0).hi+1);if(l){const t=c.slice(e-1).findIndex(e=>!va(e[o.axis]));e+=Math.max(0,t)}r=us(e,s,a)-s}else r=a-s}return{start:s,count:r}}function Ss(e){const{xScale:t,yScale:n,_scaleRanges:a}=e,s={xmin:t.min,xmax:t.max,ymin:n.min,ymax:n.max};if(!a)return e._scaleRanges=s,!0;const r=a.xmin!==t.min||a.xmax!==t.max||a.ymin!==n.min||a.ymax!==n.max;return Object.assign(a,s),r}const Cs=e=>0===e||1===e,Is=(e,t,n)=>-Math.pow(2,10*(e-=1))*Math.sin((e-t)*Ua/n),Ns=(e,t,n)=>Math.pow(2,-10*e)*Math.sin((e-t)*Ua/n)+1,Ts={linear:e=>e,easeInQuad:e=>e*e,easeOutQuad:e=>-e*(e-2),easeInOutQuad:e=>(e/=.5)<1?.5*e*e:-.5*(--e*(e-2)-1),easeInCubic:e=>e*e*e,easeOutCubic:e=>(e-=1)*e*e+1,easeInOutCubic:e=>(e/=.5)<1?.5*e*e*e:.5*((e-=2)*e*e+2),easeInQuart:e=>e*e*e*e,easeOutQuart:e=>-((e-=1)*e*e*e-1),easeInOutQuart:e=>(e/=.5)<1?.5*e*e*e*e:-.5*((e-=2)*e*e*e-2),easeInQuint:e=>e*e*e*e*e,easeOutQuint:e=>(e-=1)*e*e*e*e+1,easeInOutQuint:e=>(e/=.5)<1?.5*e*e*e*e*e:.5*((e-=2)*e*e*e*e+2),easeInSine:e=>1-Math.cos(e*Ka),easeOutSine:e=>Math.sin(e*Ka),easeInOutSine:e=>-.5*(Math.cos(Va*e)-1),easeInExpo:e=>0===e?0:Math.pow(2,10*(e-1)),easeOutExpo:e=>1===e?1:1-Math.pow(2,-10*e),easeInOutExpo:e=>Cs(e)?e:e<.5?.5*Math.pow(2,10*(2*e-1)):.5*(2-Math.pow(2,-10*(2*e-1))),easeInCirc:e=>e>=1?e:-(Math.sqrt(1-e*e)-1),easeOutCirc:e=>Math.sqrt(1-(e-=1)*e),easeInOutCirc:e=>(e/=.5)<1?-.5*(Math.sqrt(1-e*e)-1):.5*(Math.sqrt(1-(e-=2)*e)+1),easeInElastic:e=>Cs(e)?e:Is(e,.075,.3),easeOutElastic:e=>Cs(e)?e:Ns(e,.075,.3),easeInOutElastic(e){const t=.1125;return Cs(e)?e:e<.5?.5*Is(2*e,t,.45):.5+.5*Ns(2*e-1,t,.45)},easeInBack(e){const t=1.70158;return e*e*((t+1)*e-t)},easeOutBack(e){const t=1.70158;return(e-=1)*e*((t+1)*e+t)+1},easeInOutBack(e){let t=1.70158;return(e/=.5)<1?e*e*((1+(t*=1.525))*e-t)*.5:.5*((e-=2)*e*((1+(t*=1.525))*e+t)+2)},easeInBounce:e=>1-Ts.easeOutBounce(1-e),easeOutBounce(e){const t=7.5625,n=2.75;return e<1/n?t*e*e:e<2/n?t*(e-=1.5/n)*e+.75:e<2.5/n?t*(e-=2.25/n)*e+.9375:t*(e-=2.625/n)*e+.984375},easeInOutBounce:e=>e<.5?.5*Ts.easeInBounce(2*e):.5*Ts.easeOutBounce(2*e-1)+.5};function Es(e){if(e&&"object"===typeof e){const t=e.toString();return"[object CanvasPattern]"===t||"[object CanvasGradient]"===t}return!1}function Rs(e){return Es(e)?e:new ya(e)}function _s(e){return Es(e)?e:new ya(e).saturate(.5).darken(.1).hexString()}const As=["x","y","borderWidth","radius","tension"],Ms=["color","borderColor","backgroundColor"];const Ps=new Map;function Ds(e,t,n){return function(e,t){t=t||{};const n=e+JSON.stringify(t);let a=Ps.get(n);return a||(a=new Intl.NumberFormat(e,t),Ps.set(n,a)),a}(t,n).format(e)}const Os={values:e=>wa(e)?e:""+e,numeric(e,t,n){if(0===e)return"0";const a=this.chart.options.locale;let s,r=e;if(n.length>1){const t=Math.max(Math.abs(n[0].value),Math.abs(n[n.length-1].value));(t<1e-4||t>1e15)&&(s="scientific"),r=function(e,t){let n=t.length>3?t[2].value-t[1].value:t[1].value-t[0].value;Math.abs(n)>=1&&e!==Math.floor(e)&&(n=e-Math.floor(e));return n}(e,n)}const i=Qa(Math.abs(r)),o=isNaN(i)?1:Math.max(Math.min(-1*Math.floor(i),20),0),c={notation:s,minimumFractionDigits:o,maximumFractionDigits:o};return Object.assign(c,this.options.ticks.format),Ds(e,a,c)},logarithmic(e,t,n){if(0===e)return"0";const a=n[t].significand||e/Math.pow(10,Math.floor(Qa(e)));return[1,2,3,5,10,15].includes(a)||t>.8*n.length?Os.numeric.call(this,e,t,n):""}};var Fs={formatters:Os};const Ls=Object.create(null),zs=Object.create(null);function Bs(e,t){if(!t)return e;const n=t.split(".");for(let a=0,s=n.length;a<s;++a){const t=n[a];e=e[t]||(e[t]=Object.create(null))}return e}function js(e,t,n){return"string"===typeof t?Pa(Bs(e,t),n):Pa(Bs(e,""),t)}class Ws{constructor(e,t){this.animation=void 0,this.backgroundColor="rgba(0,0,0,0.1)",this.borderColor="rgba(0,0,0,0.1)",this.color="#666",this.datasets={},this.devicePixelRatio=e=>e.chart.platform.getDevicePixelRatio(),this.elements={},this.events=["mousemove","mouseout","click","touchstart","touchmove"],this.font={family:"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",size:12,style:"normal",lineHeight:1.2,weight:null},this.hover={},this.hoverBackgroundColor=(e,t)=>_s(t.backgroundColor),this.hoverBorderColor=(e,t)=>_s(t.borderColor),this.hoverColor=(e,t)=>_s(t.color),this.indexAxis="x",this.interaction={mode:"nearest",intersect:!0,includeInvisible:!1},this.maintainAspectRatio=!0,this.onHover=null,this.onClick=null,this.parsing=!0,this.plugins={},this.responsive=!0,this.scale=void 0,this.scales={},this.showLine=!0,this.drawActiveElementsOnTop=!0,this.describe(e),this.apply(t)}set(e,t){return js(this,e,t)}get(e){return Bs(this,e)}describe(e,t){return js(zs,e,t)}override(e,t){return js(Ls,e,t)}route(e,t,n,a){const s=Bs(this,e),r=Bs(this,n),i="_"+t;Object.defineProperties(s,{[i]:{value:s[t],writable:!0},[t]:{enumerable:!0,get(){const e=this[i],t=r[a];return ka(e)?Object.assign({},t,e):Ia(e,t)},set(e){this[i]=e}}})}apply(e){e.forEach(e=>e(this))}}var Vs=new Ws({_scriptable:e=>!e.startsWith("on"),_indexable:e=>"events"!==e,hover:{_fallback:"interaction"},interaction:{_scriptable:!1,_indexable:!1}},[function(e){e.set("animation",{delay:void 0,duration:1e3,easing:"easeOutQuart",fn:void 0,from:void 0,loop:void 0,to:void 0,type:void 0}),e.describe("animation",{_fallback:!1,_indexable:!1,_scriptable:e=>"onProgress"!==e&&"onComplete"!==e&&"fn"!==e}),e.set("animations",{colors:{type:"color",properties:Ms},numbers:{type:"number",properties:As}}),e.describe("animations",{_fallback:"animation"}),e.set("transitions",{active:{animation:{duration:400}},resize:{animation:{duration:0}},show:{animations:{colors:{from:"transparent"},visible:{type:"boolean",duration:0}}},hide:{animations:{colors:{to:"transparent"},visible:{type:"boolean",easing:"linear",fn:e=>0|e}}}})},function(e){e.set("layout",{autoPadding:!0,padding:{top:0,right:0,bottom:0,left:0}})},function(e){e.set("scale",{display:!0,offset:!1,reverse:!1,beginAtZero:!1,bounds:"ticks",clip:!0,grace:0,grid:{display:!0,lineWidth:1,drawOnChartArea:!0,drawTicks:!0,tickLength:8,tickWidth:(e,t)=>t.lineWidth,tickColor:(e,t)=>t.color,offset:!1},border:{display:!0,dash:[],dashOffset:0,width:1},title:{display:!1,text:"",padding:{top:4,bottom:4}},ticks:{minRotation:0,maxRotation:50,mirror:!1,textStrokeWidth:0,textStrokeColor:"",padding:3,display:!0,autoSkip:!0,autoSkipPadding:3,labelOffset:0,callback:Fs.formatters.values,minor:{},major:{},align:"center",crossAlign:"near",showLabelBackdrop:!1,backdropColor:"rgba(255, 255, 255, 0.75)",backdropPadding:2}}),e.route("scale.ticks","color","","color"),e.route("scale.grid","color","","borderColor"),e.route("scale.border","color","","borderColor"),e.route("scale.title","color","","color"),e.describe("scale",{_fallback:!1,_scriptable:e=>!e.startsWith("before")&&!e.startsWith("after")&&"callback"!==e&&"parser"!==e,_indexable:e=>"borderDash"!==e&&"tickBorderDash"!==e&&"dash"!==e}),e.describe("scales",{_fallback:"scale"}),e.describe("scale.ticks",{_scriptable:e=>"backdropPadding"!==e&&"callback"!==e,_indexable:e=>"backdropPadding"!==e})}]);function Us(e,t,n,a,s){let r=t[s];return r||(r=t[s]=e.measureText(s).width,n.push(s)),r>a&&(a=r),a}function Hs(e,t,n,a){let s=(a=a||{}).data=a.data||{},r=a.garbageCollect=a.garbageCollect||[];a.font!==t&&(s=a.data={},r=a.garbageCollect=[],a.font=t),e.save(),e.font=t;let i=0;const o=n.length;let c,l,u,h,d;for(c=0;c<o;c++)if(h=n[c],void 0===h||null===h||wa(h)){if(wa(h))for(l=0,u=h.length;l<u;l++)d=h[l],void 0===d||null===d||wa(d)||(i=Us(e,s,r,i,d))}else i=Us(e,s,r,i,h);e.restore();const p=r.length/2;if(p>n.length){for(c=0;c<p;c++)delete s[r[c]];r.splice(0,p)}return i}function Gs(e,t,n){const a=e.currentDevicePixelRatio,s=0!==n?Math.max(n/2,.5):0;return Math.round((t-s)*a)/a+s}function qs(e,t){(t||e)&&((t=t||e.getContext("2d")).save(),t.resetTransform(),t.clearRect(0,0,e.width,e.height),t.restore())}function Ks(e,t,n,a){Xs(e,t,n,a,null)}function Xs(e,t,n,a,s){let r,i,o,c,l,u,h,d;const p=t.pointStyle,f=t.rotation,m=t.radius;let g=(f||0)*qa;if(p&&"object"===typeof p&&(r=p.toString(),"[object HTMLImageElement]"===r||"[object HTMLCanvasElement]"===r))return e.save(),e.translate(n,a),e.rotate(g),e.drawImage(p,-p.width/2,-p.height/2,p.width,p.height),void e.restore();if(!(isNaN(m)||m<=0)){switch(e.beginPath(),p){default:s?e.ellipse(n,a,s/2,m,0,0,Ua):e.arc(n,a,m,0,Ua),e.closePath();break;case"triangle":u=s?s/2:m,e.moveTo(n+Math.sin(g)*u,a-Math.cos(g)*m),g+=Ya,e.lineTo(n+Math.sin(g)*u,a-Math.cos(g)*m),g+=Ya,e.lineTo(n+Math.sin(g)*u,a-Math.cos(g)*m),e.closePath();break;case"rectRounded":l=.516*m,c=m-l,i=Math.cos(g+Xa)*c,h=Math.cos(g+Xa)*(s?s/2-l:c),o=Math.sin(g+Xa)*c,d=Math.sin(g+Xa)*(s?s/2-l:c),e.arc(n-h,a-o,l,g-Va,g-Ka),e.arc(n+d,a-i,l,g-Ka,g),e.arc(n+h,a+o,l,g,g+Ka),e.arc(n-d,a+i,l,g+Ka,g+Va),e.closePath();break;case"rect":if(!f){c=Math.SQRT1_2*m,u=s?s/2:c,e.rect(n-u,a-c,2*u,2*c);break}g+=Xa;case"rectRot":h=Math.cos(g)*(s?s/2:m),i=Math.cos(g)*m,o=Math.sin(g)*m,d=Math.sin(g)*(s?s/2:m),e.moveTo(n-h,a-o),e.lineTo(n+d,a-i),e.lineTo(n+h,a+o),e.lineTo(n-d,a+i),e.closePath();break;case"crossRot":g+=Xa;case"cross":h=Math.cos(g)*(s?s/2:m),i=Math.cos(g)*m,o=Math.sin(g)*m,d=Math.sin(g)*(s?s/2:m),e.moveTo(n-h,a-o),e.lineTo(n+h,a+o),e.moveTo(n+d,a-i),e.lineTo(n-d,a+i);break;case"star":h=Math.cos(g)*(s?s/2:m),i=Math.cos(g)*m,o=Math.sin(g)*m,d=Math.sin(g)*(s?s/2:m),e.moveTo(n-h,a-o),e.lineTo(n+h,a+o),e.moveTo(n+d,a-i),e.lineTo(n-d,a+i),g+=Xa,h=Math.cos(g)*(s?s/2:m),i=Math.cos(g)*m,o=Math.sin(g)*m,d=Math.sin(g)*(s?s/2:m),e.moveTo(n-h,a-o),e.lineTo(n+h,a+o),e.moveTo(n+d,a-i),e.lineTo(n-d,a+i);break;case"line":i=s?s/2:Math.cos(g)*m,o=Math.sin(g)*m,e.moveTo(n-i,a-o),e.lineTo(n+i,a+o);break;case"dash":e.moveTo(n,a),e.lineTo(n+Math.cos(g)*(s?s/2:m),a+Math.sin(g)*m);break;case!1:e.closePath()}e.fill(),t.borderWidth>0&&e.stroke()}}function Ys(e,t,n){return n=n||.5,!t||e&&e.x>t.left-n&&e.x<t.right+n&&e.y>t.top-n&&e.y<t.bottom+n}function Qs(e,t){e.save(),e.beginPath(),e.rect(t.left,t.top,t.right-t.left,t.bottom-t.top),e.clip()}function Zs(e){e.restore()}function Js(e,t,n,a,s){if(!t)return e.lineTo(n.x,n.y);if("middle"===s){const a=(t.x+n.x)/2;e.lineTo(a,t.y),e.lineTo(a,n.y)}else"after"===s!==!!a?e.lineTo(t.x,n.y):e.lineTo(n.x,t.y);e.lineTo(n.x,n.y)}function $s(e,t,n,a){if(!t)return e.lineTo(n.x,n.y);e.bezierCurveTo(a?t.cp1x:t.cp2x,a?t.cp1y:t.cp2y,a?n.cp2x:n.cp1x,a?n.cp2y:n.cp1y,n.x,n.y)}function er(e,t,n,a,s){if(s.strikethrough||s.underline){const r=e.measureText(a),i=t-r.actualBoundingBoxLeft,o=t+r.actualBoundingBoxRight,c=n-r.actualBoundingBoxAscent,l=n+r.actualBoundingBoxDescent,u=s.strikethrough?(c+l)/2:l;e.strokeStyle=e.fillStyle,e.beginPath(),e.lineWidth=s.decorationWidth||2,e.moveTo(i,u),e.lineTo(o,u),e.stroke()}}function tr(e,t){const n=e.fillStyle;e.fillStyle=t.color,e.fillRect(t.left,t.top,t.width,t.height),e.fillStyle=n}function nr(e,t,n,a,s){let r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:{};const i=wa(t)?t:[t],o=r.strokeWidth>0&&""!==r.strokeColor;let c,l;for(e.save(),e.font=s.string,function(e,t){t.translation&&e.translate(t.translation[0],t.translation[1]),va(t.rotation)||e.rotate(t.rotation),t.color&&(e.fillStyle=t.color),t.textAlign&&(e.textAlign=t.textAlign),t.textBaseline&&(e.textBaseline=t.textBaseline)}(e,r),c=0;c<i.length;++c)l=i[c],r.backdrop&&tr(e,r.backdrop),o&&(r.strokeColor&&(e.strokeStyle=r.strokeColor),va(r.strokeWidth)||(e.lineWidth=r.strokeWidth),e.strokeText(l,n,a,r.maxWidth)),e.fillText(l,n,a,r.maxWidth),er(e,n,a,l,r),a+=Number(s.lineHeight);e.restore()}function ar(e,t){const{x:n,y:a,w:s,h:r,radius:i}=t;e.arc(n+i.topLeft,a+i.topLeft,i.topLeft,1.5*Va,Va,!0),e.lineTo(n,a+r-i.bottomLeft),e.arc(n+i.bottomLeft,a+r-i.bottomLeft,i.bottomLeft,Va,Ka,!0),e.lineTo(n+s-i.bottomRight,a+r),e.arc(n+s-i.bottomRight,a+r-i.bottomRight,i.bottomRight,Ka,0,!0),e.lineTo(n+s,a+i.topRight),e.arc(n+s-i.topRight,a+i.topRight,i.topRight,0,-Ka,!0),e.lineTo(n+i.topLeft,a)}const sr=/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/,rr=/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;function ir(e,t){const n=(""+e).match(sr);if(!n||"normal"===n[1])return 1.2*t;switch(e=+n[2],n[3]){case"px":return e;case"%":e/=100}return t*e}const or=e=>+e||0;function cr(e,t){const n={},a=ka(t),s=a?Object.keys(t):t,r=ka(e)?a?n=>Ia(e[n],e[t[n]]):t=>e[t]:()=>e;for(const i of s)n[i]=or(r(i));return n}function lr(e){return cr(e,{top:"y",right:"x",bottom:"y",left:"x"})}function ur(e){return cr(e,["topLeft","topRight","bottomLeft","bottomRight"])}function hr(e){const t=lr(e);return t.width=t.left+t.right,t.height=t.top+t.bottom,t}function dr(e,t){e=e||{},t=t||Vs.font;let n=Ia(e.size,t.size);"string"===typeof n&&(n=parseInt(n,10));let a=Ia(e.style,t.style);a&&!(""+a).match(rr)&&(console.warn('Invalid font style specified: "'+a+'"'),a=void 0);const s={family:Ia(e.family,t.family),lineHeight:ir(Ia(e.lineHeight,t.lineHeight),n),size:n,style:a,weight:Ia(e.weight,t.weight),string:""};return s.string=function(e){return!e||va(e.size)||va(e.family)?null:(e.style?e.style+" ":"")+(e.weight?e.weight+" ":"")+e.size+"px "+e.family}(s),s}function pr(e,t,n,a){let s,r,i,o=!0;for(s=0,r=e.length;s<r;++s)if(i=e[s],void 0!==i&&(void 0!==t&&"function"===typeof i&&(i=i(t),o=!1),void 0!==n&&wa(i)&&(i=i[n%i.length],o=!1),void 0!==i))return a&&!o&&(a.cacheable=!1),i}function fr(e,t){return Object.assign(Object.create(e),t)}function mr(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[""],n=arguments.length>3?arguments[3]:void 0,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:()=>e[0];const s=(arguments.length>2?arguments[2]:void 0)||e;"undefined"===typeof n&&(n=Nr("_fallback",e));const r={[Symbol.toStringTag]:"Object",_cacheable:!0,_scopes:e,_rootScopes:s,_fallback:n,_getTarget:a,override:a=>mr([a,...e],t,s,n)};return new Proxy(r,{deleteProperty:(t,n)=>(delete t[n],delete t._keys,delete e[0][n],!0),get:(n,a)=>vr(n,a,()=>function(e,t,n,a){let s;for(const r of t)if(s=Nr(br(r,e),n),"undefined"!==typeof s)return xr(e,s)?Cr(n,a,e,s):s}(a,t,e,n)),getOwnPropertyDescriptor:(e,t)=>Reflect.getOwnPropertyDescriptor(e._scopes[0],t),getPrototypeOf:()=>Reflect.getPrototypeOf(e[0]),has:(e,t)=>Tr(e).includes(t),ownKeys:e=>Tr(e),set(e,t,n){const s=e._storage||(e._storage=a());return e[t]=s[t]=n,delete e._keys,!0}})}function gr(e,t,n,a){const s={_cacheable:!1,_proxy:e,_context:t,_subProxy:n,_stack:new Set,_descriptors:yr(e,a),setContext:t=>gr(e,t,n,a),override:s=>gr(e.override(s),t,n,a)};return new Proxy(s,{deleteProperty:(t,n)=>(delete t[n],delete e[n],!0),get:(e,t,n)=>vr(e,t,()=>function(e,t,n){const{_proxy:a,_context:s,_subProxy:r,_descriptors:i}=e;let o=a[t];ja(o)&&i.isScriptable(t)&&(o=function(e,t,n,a){const{_proxy:s,_context:r,_subProxy:i,_stack:o}=n;if(o.has(e))throw new Error("Recursion detected: "+Array.from(o).join("->")+"->"+e);o.add(e);let c=t(r,i||a);o.delete(e),xr(e,c)&&(c=Cr(s._scopes,s,e,c));return c}(t,o,e,n));wa(o)&&o.length&&(o=function(e,t,n,a){const{_proxy:s,_context:r,_subProxy:i,_descriptors:o}=n;if("undefined"!==typeof r.index&&a(e))return t[r.index%t.length];if(ka(t[0])){const n=t,a=s._scopes.filter(e=>e!==n);t=[];for(const c of n){const n=Cr(a,s,e,c);t.push(gr(n,r,i&&i[e],o))}}return t}(t,o,e,i.isIndexable));xr(t,o)&&(o=gr(o,s,r&&r[t],i));return o}(e,t,n)),getOwnPropertyDescriptor:(t,n)=>t._descriptors.allKeys?Reflect.has(e,n)?{enumerable:!0,configurable:!0}:void 0:Reflect.getOwnPropertyDescriptor(e,n),getPrototypeOf:()=>Reflect.getPrototypeOf(e),has:(t,n)=>Reflect.has(e,n),ownKeys:()=>Reflect.ownKeys(e),set:(t,n,a)=>(e[n]=a,delete t[n],!0)})}function yr(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{scriptable:!0,indexable:!0};const{_scriptable:n=t.scriptable,_indexable:a=t.indexable,_allKeys:s=t.allKeys}=e;return{allKeys:s,scriptable:n,indexable:a,isScriptable:ja(n)?n:()=>n,isIndexable:ja(a)?a:()=>a}}const br=(e,t)=>e?e+za(t):t,xr=(e,t)=>ka(t)&&"adapters"!==e&&(null===Object.getPrototypeOf(t)||t.constructor===Object);function vr(e,t,n){if(Object.prototype.hasOwnProperty.call(e,t)||"constructor"===t)return e[t];const a=n();return e[t]=a,a}function wr(e,t,n){return ja(e)?e(t,n):e}const kr=(e,t)=>!0===e?t:"string"===typeof e?La(t,e):void 0;function Sr(e,t,n,a,s){for(const r of t){const t=kr(n,r);if(t){e.add(t);const r=wr(t._fallback,n,s);if("undefined"!==typeof r&&r!==n&&r!==a)return r}else if(!1===t&&"undefined"!==typeof a&&n!==a)return null}return!1}function Cr(e,t,n,a){const s=t._rootScopes,r=wr(t._fallback,n,a),i=[...e,...s],o=new Set;o.add(a);let c=Ir(o,i,n,r||n,a);return null!==c&&(("undefined"===typeof r||r===n||(c=Ir(o,i,r,c,a),null!==c))&&mr(Array.from(o),[""],s,r,()=>function(e,t,n){const a=e._getTarget();t in a||(a[t]={});const s=a[t];if(wa(s)&&ka(n))return n;return s||{}}(t,n,a)))}function Ir(e,t,n,a,s){for(;n;)n=Sr(e,t,n,a,s);return n}function Nr(e,t){for(const n of t){if(!n)continue;const t=n[e];if("undefined"!==typeof t)return t}}function Tr(e){let t=e._keys;return t||(t=e._keys=function(e){const t=new Set;for(const n of e)for(const e of Object.keys(n).filter(e=>!e.startsWith("_")))t.add(e);return Array.from(t)}(e._scopes)),t}function Er(e,t,n,a){const{iScale:s}=e,{key:r="r"}=this._parsing,i=new Array(a);let o,c,l,u;for(o=0,c=a;o<c;++o)l=o+n,u=t[l],i[o]={r:s.parse(La(u,r),l)};return i}const Rr=Number.EPSILON||1e-14,_r=(e,t)=>t<e.length&&!e[t].skip&&e[t],Ar=e=>"x"===e?"y":"x";function Mr(e,t,n,a){const s=e.skip?t:e,r=t,i=n.skip?t:n,o=is(r,s),c=is(i,r);let l=o/(o+c),u=c/(o+c);l=isNaN(l)?0:l,u=isNaN(u)?0:u;const h=a*l,d=a*u;return{previous:{x:r.x-h*(i.x-s.x),y:r.y-h*(i.y-s.y)},next:{x:r.x+d*(i.x-s.x),y:r.y+d*(i.y-s.y)}}}function Pr(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"x";const n=Ar(t),a=e.length,s=Array(a).fill(0),r=Array(a);let i,o,c,l=_r(e,0);for(i=0;i<a;++i)if(o=c,c=l,l=_r(e,i+1),c){if(l){const e=l[t]-c[t];s[i]=0!==e?(l[n]-c[n])/e:0}r[i]=o?l?Za(s[i-1])!==Za(s[i])?0:(s[i-1]+s[i])/2:s[i-1]:s[i]}!function(e,t,n){const a=e.length;let s,r,i,o,c,l=_r(e,0);for(let u=0;u<a-1;++u)c=l,l=_r(e,u+1),c&&l&&(Ja(t[u],0,Rr)?n[u]=n[u+1]=0:(s=n[u]/t[u],r=n[u+1]/t[u],o=Math.pow(s,2)+Math.pow(r,2),o<=9||(i=3/Math.sqrt(o),n[u]=s*i*t[u],n[u+1]=r*i*t[u])))}(e,s,r),function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"x";const a=Ar(n),s=e.length;let r,i,o,c=_r(e,0);for(let l=0;l<s;++l){if(i=o,o=c,c=_r(e,l+1),!o)continue;const s=o[n],u=o[a];i&&(r=(s-i[n])/3,o["cp1".concat(n)]=s-r,o["cp1".concat(a)]=u-r*t[l]),c&&(r=(c[n]-s)/3,o["cp2".concat(n)]=s+r,o["cp2".concat(a)]=u+r*t[l])}}(e,r,t)}function Dr(e,t,n){return Math.max(Math.min(e,n),t)}function Or(e,t,n,a,s){let r,i,o,c;if(t.spanGaps&&(e=e.filter(e=>!e.skip)),"monotone"===t.cubicInterpolationMode)Pr(e,s);else{let n=a?e[e.length-1]:e[0];for(r=0,i=e.length;r<i;++r)o=e[r],c=Mr(n,o,e[Math.min(r+1,i-(a?0:1))%i],t.tension),o.cp1x=c.previous.x,o.cp1y=c.previous.y,o.cp2x=c.next.x,o.cp2y=c.next.y,n=o}t.capBezierPoints&&function(e,t){let n,a,s,r,i,o=Ys(e[0],t);for(n=0,a=e.length;n<a;++n)i=r,r=o,o=n<a-1&&Ys(e[n+1],t),r&&(s=e[n],i&&(s.cp1x=Dr(s.cp1x,t.left,t.right),s.cp1y=Dr(s.cp1y,t.top,t.bottom)),o&&(s.cp2x=Dr(s.cp2x,t.left,t.right),s.cp2y=Dr(s.cp2y,t.top,t.bottom)))}(e,n)}function Fr(){return"undefined"!==typeof window&&"undefined"!==typeof document}function Lr(e){let t=e.parentNode;return t&&"[object ShadowRoot]"===t.toString()&&(t=t.host),t}function zr(e,t,n){let a;return"string"===typeof e?(a=parseInt(e,10),-1!==e.indexOf("%")&&(a=a/100*t.parentNode[n])):a=e,a}const Br=e=>e.ownerDocument.defaultView.getComputedStyle(e,null);const jr=["top","right","bottom","left"];function Wr(e,t,n){const a={};n=n?"-"+n:"";for(let s=0;s<4;s++){const r=jr[s];a[r]=parseFloat(e[t+"-"+r+n])||0}return a.width=a.left+a.right,a.height=a.top+a.bottom,a}function Vr(e,t){if("native"in e)return e;const{canvas:n,currentDevicePixelRatio:a}=t,s=Br(n),r="border-box"===s.boxSizing,i=Wr(s,"padding"),o=Wr(s,"border","width"),{x:c,y:l,box:u}=function(e,t){const n=e.touches,a=n&&n.length?n[0]:e,{offsetX:s,offsetY:r}=a;let i,o,c=!1;if(((e,t,n)=>(e>0||t>0)&&(!n||!n.shadowRoot))(s,r,e.target))i=s,o=r;else{const e=t.getBoundingClientRect();i=a.clientX-e.left,o=a.clientY-e.top,c=!0}return{x:i,y:o,box:c}}(e,n),h=i.left+(u&&o.left),d=i.top+(u&&o.top);let{width:p,height:f}=t;return r&&(p-=i.width+o.width,f-=i.height+o.height),{x:Math.round((c-h)/p*n.width/a),y:Math.round((l-d)/f*n.height/a)}}const Ur=e=>Math.round(10*e)/10;function Hr(e,t,n,a){const s=Br(e),r=Wr(s,"margin"),i=zr(s.maxWidth,e,"clientWidth")||Ga,o=zr(s.maxHeight,e,"clientHeight")||Ga,c=function(e,t,n){let a,s;if(void 0===t||void 0===n){const r=e&&Lr(e);if(r){const e=r.getBoundingClientRect(),i=Br(r),o=Wr(i,"border","width"),c=Wr(i,"padding");t=e.width-c.width-o.width,n=e.height-c.height-o.height,a=zr(i.maxWidth,r,"clientWidth"),s=zr(i.maxHeight,r,"clientHeight")}else t=e.clientWidth,n=e.clientHeight}return{width:t,height:n,maxWidth:a||Ga,maxHeight:s||Ga}}(e,t,n);let{width:l,height:u}=c;if("content-box"===s.boxSizing){const e=Wr(s,"border","width"),t=Wr(s,"padding");l-=t.width+e.width,u-=t.height+e.height}l=Math.max(0,l-r.width),u=Math.max(0,a?l/a:u-r.height),l=Ur(Math.min(l,i,c.maxWidth)),u=Ur(Math.min(u,o,c.maxHeight)),l&&!u&&(u=Ur(l/2));return(void 0!==t||void 0!==n)&&a&&c.height&&u>c.height&&(u=c.height,l=Ur(Math.floor(u*a))),{width:l,height:u}}function Gr(e,t,n){const a=t||1,s=Ur(e.height*a),r=Ur(e.width*a);e.height=Ur(e.height),e.width=Ur(e.width);const i=e.canvas;return i.style&&(n||!i.style.height&&!i.style.width)&&(i.style.height="".concat(e.height,"px"),i.style.width="".concat(e.width,"px")),(e.currentDevicePixelRatio!==a||i.height!==s||i.width!==r)&&(e.currentDevicePixelRatio=a,i.height=s,i.width=r,e.ctx.setTransform(a,0,0,a,0,0),!0)}const qr=function(){let e=!1;try{const t={get passive(){return e=!0,!1}};Fr()&&(window.addEventListener("test",null,t),window.removeEventListener("test",null,t))}catch(q5){}return e}();function Kr(e,t){const n=function(e,t){return Br(e).getPropertyValue(t)}(e,t),a=n&&n.match(/^(\d+)(\.\d+)?px$/);return a?+a[1]:void 0}function Xr(e,t,n,a){return{x:e.x+n*(t.x-e.x),y:e.y+n*(t.y-e.y)}}function Yr(e,t,n,a){return{x:e.x+n*(t.x-e.x),y:"middle"===a?n<.5?e.y:t.y:"after"===a?n<1?e.y:t.y:n>0?t.y:e.y}}function Qr(e,t,n,a){const s={x:e.cp2x,y:e.cp2y},r={x:t.cp1x,y:t.cp1y},i=Xr(e,s,n),o=Xr(s,r,n),c=Xr(r,t,n),l=Xr(i,o,n),u=Xr(o,c,n);return Xr(l,u,n)}function Zr(e,t,n){return e?function(e,t){return{x:n=>e+e+t-n,setWidth(e){t=e},textAlign:e=>"center"===e?e:"right"===e?"left":"right",xPlus:(e,t)=>e-t,leftForLtr:(e,t)=>e-t}}(t,n):{x:e=>e,setWidth(e){},textAlign:e=>e,xPlus:(e,t)=>e+t,leftForLtr:(e,t)=>e}}function Jr(e,t){let n,a;"ltr"!==t&&"rtl"!==t||(n=e.canvas.style,a=[n.getPropertyValue("direction"),n.getPropertyPriority("direction")],n.setProperty("direction",t,"important"),e.prevTextDirection=a)}function $r(e,t){void 0!==t&&(delete e.prevTextDirection,e.canvas.style.setProperty("direction",t[0],t[1]))}function ei(e){return"angle"===e?{between:ls,compare:os,normalize:cs}:{between:hs,compare:(e,t)=>e-t,normalize:e=>e}}function ti(e){let{start:t,end:n,count:a,loop:s,style:r}=e;return{start:t%a,end:n%a,loop:s&&(n-t+1)%a===0,style:r}}function ni(e,t,n){if(!n)return[e];const{property:a,start:s,end:r}=n,i=t.length,{compare:o,between:c,normalize:l}=ei(a),{start:u,end:h,loop:d,style:p}=function(e,t,n){const{property:a,start:s,end:r}=n,{between:i,normalize:o}=ei(a),c=t.length;let l,u,{start:h,end:d,loop:p}=e;if(p){for(h+=c,d+=c,l=0,u=c;l<u&&i(o(t[h%c][a]),s,r);++l)h--,d--;h%=c,d%=c}return d<h&&(d+=c),{start:h,end:d,loop:p,style:e.style}}(e,t,n),f=[];let m,g,y,b=!1,x=null;const v=()=>b||c(s,y,m)&&0!==o(s,y),w=()=>!b||0===o(r,m)||c(r,y,m);for(let k=u,S=u;k<=h;++k)g=t[k%i],g.skip||(m=l(g[a]),m!==y&&(b=c(m,s,r),null===x&&v()&&(x=0===o(m,s)?k:S),null!==x&&w()&&(f.push(ti({start:x,end:k,loop:d,count:i,style:p})),x=null),S=k,y=m));return null!==x&&f.push(ti({start:x,end:h,loop:d,count:i,style:p})),f}function ai(e,t){const n=[],a=e.segments;for(let s=0;s<a.length;s++){const r=ni(a[s],e.points,t);r.length&&n.push(...r)}return n}function si(e,t,n,a){return a&&a.setContext&&n?function(e,t,n,a){const s=e._chart.getContext(),r=ri(e.options),{_datasetIndex:i,options:{spanGaps:o}}=e,c=n.length,l=[];let u=r,h=t[0].start,d=h;function p(e,t,a,s){const r=o?-1:1;if(e!==t){for(e+=c;n[e%c].skip;)e-=r;for(;n[t%c].skip;)t+=r;e%c!==t%c&&(l.push({start:e%c,end:t%c,loop:a,style:s}),u=s,h=t%c)}}for(const f of t){h=o?h:f.start;let e,t=n[h%c];for(d=h+1;d<=f.end;d++){const r=n[d%c];e=ri(a.setContext(fr(s,{type:"segment",p0:t,p1:r,p0DataIndex:(d-1)%c,p1DataIndex:d%c,datasetIndex:i}))),ii(e,u)&&p(h,d-1,f.loop,u),t=r,u=e}h<d-1&&p(h,d-1,f.loop,u)}return l}(e,t,n,a):t}function ri(e){return{backgroundColor:e.backgroundColor,borderCapStyle:e.borderCapStyle,borderDash:e.borderDash,borderDashOffset:e.borderDashOffset,borderJoinStyle:e.borderJoinStyle,borderWidth:e.borderWidth,borderColor:e.borderColor}}function ii(e,t){if(!t)return!1;const n=[],a=function(e,t){return Es(t)?(n.includes(t)||n.push(t),n.indexOf(t)):t};return JSON.stringify(e,a)!==JSON.stringify(t,a)}function oi(e,t,n){return e.options.clip?e[n]:t[n]}function ci(e,t){const n=t._clip;if(n.disabled)return!1;const a=function(e,t){const{xScale:n,yScale:a}=e;return n&&a?{left:oi(n,t,"left"),right:oi(n,t,"right"),top:oi(a,t,"top"),bottom:oi(a,t,"bottom")}:t}(t,e.chartArea);return{left:!1===n.left?0:a.left-(!0===n.left?0:n.left),right:!1===n.right?e.width:a.right+(!0===n.right?0:n.right),top:!1===n.top?0:a.top-(!0===n.top?0:n.top),bottom:!1===n.bottom?e.height:a.bottom+(!0===n.bottom?0:n.bottom)}}class li{constructor(){this._request=null,this._charts=new Map,this._running=!1,this._lastDate=void 0}_notify(e,t,n,a){const s=t.listeners[a],r=t.duration;s.forEach(a=>a({chart:e,initial:t.initial,numSteps:r,currentStep:Math.min(n-t.start,r)}))}_refresh(){this._request||(this._running=!0,this._request=bs.call(window,()=>{this._update(),this._request=null,this._running&&this._refresh()}))}_update(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Date.now(),t=0;this._charts.forEach((n,a)=>{if(!n.running||!n.items.length)return;const s=n.items;let r,i=s.length-1,o=!1;for(;i>=0;--i)r=s[i],r._active?(r._total>n.duration&&(n.duration=r._total),r.tick(e),o=!0):(s[i]=s[s.length-1],s.pop());o&&(a.draw(),this._notify(a,n,e,"progress")),s.length||(n.running=!1,this._notify(a,n,e,"complete"),n.initial=!1),t+=s.length}),this._lastDate=e,0===t&&(this._running=!1)}_getAnims(e){const t=this._charts;let n=t.get(e);return n||(n={running:!1,initial:!0,items:[],listeners:{complete:[],progress:[]}},t.set(e,n)),n}listen(e,t,n){this._getAnims(e).listeners[t].push(n)}add(e,t){t&&t.length&&this._getAnims(e).items.push(...t)}has(e){return this._getAnims(e).items.length>0}start(e){const t=this._charts.get(e);t&&(t.running=!0,t.start=Date.now(),t.duration=t.items.reduce((e,t)=>Math.max(e,t._duration),0),this._refresh())}running(e){if(!this._running)return!1;const t=this._charts.get(e);return!!(t&&t.running&&t.items.length)}stop(e){const t=this._charts.get(e);if(!t||!t.items.length)return;const n=t.items;let a=n.length-1;for(;a>=0;--a)n[a].cancel();t.items=[],this._notify(e,t,Date.now(),"complete")}remove(e){return this._charts.delete(e)}}var ui=new li;const hi="transparent",di={boolean:(e,t,n)=>n>.5?t:e,color(e,t,n){const a=Rs(e||hi),s=a.valid&&Rs(t||hi);return s&&s.valid?s.mix(a,n).hexString():t},number:(e,t,n)=>e+(t-e)*n};class pi{constructor(e,t,n,a){const s=t[n];a=pr([e.to,a,s,e.from]);const r=pr([e.from,s,a]);this._active=!0,this._fn=e.fn||di[e.type||typeof r],this._easing=Ts[e.easing]||Ts.linear,this._start=Math.floor(Date.now()+(e.delay||0)),this._duration=this._total=Math.floor(e.duration),this._loop=!!e.loop,this._target=t,this._prop=n,this._from=r,this._to=a,this._promises=void 0}active(){return this._active}update(e,t,n){if(this._active){this._notify(!1);const a=this._target[this._prop],s=n-this._start,r=this._duration-s;this._start=n,this._duration=Math.floor(Math.max(r,e.duration)),this._total+=s,this._loop=!!e.loop,this._to=pr([e.to,t,a,e.from]),this._from=pr([e.from,a,t])}}cancel(){this._active&&(this.tick(Date.now()),this._active=!1,this._notify(!1))}tick(e){const t=e-this._start,n=this._duration,a=this._prop,s=this._from,r=this._loop,i=this._to;let o;if(this._active=s!==i&&(r||t<n),!this._active)return this._target[a]=i,void this._notify(!0);t<0?this._target[a]=s:(o=t/n%2,o=r&&o>1?2-o:o,o=this._easing(Math.min(1,Math.max(0,o))),this._target[a]=this._fn(s,i,o))}wait(){const e=this._promises||(this._promises=[]);return new Promise((t,n)=>{e.push({res:t,rej:n})})}_notify(e){const t=e?"res":"rej",n=this._promises||[];for(let a=0;a<n.length;a++)n[a][t]()}}class fi{constructor(e,t){this._chart=e,this._properties=new Map,this.configure(t)}configure(e){if(!ka(e))return;const t=Object.keys(Vs.animation),n=this._properties;Object.getOwnPropertyNames(e).forEach(a=>{const s=e[a];if(!ka(s))return;const r={};for(const e of t)r[e]=s[e];(wa(s.properties)&&s.properties||[a]).forEach(e=>{e!==a&&n.has(e)||n.set(e,r)})})}_animateOptions(e,t){const n=t.options,a=function(e,t){if(!t)return;let n=e.options;if(!n)return void(e.options=t);n.$shared&&(e.options=n=Object.assign({},n,{$shared:!1,$animations:{}}));return n}(e,n);if(!a)return[];const s=this._createAnimations(a,n);return n.$shared&&function(e,t){const n=[],a=Object.keys(t);for(let s=0;s<a.length;s++){const t=e[a[s]];t&&t.active()&&n.push(t.wait())}return Promise.all(n)}(e.options.$animations,n).then(()=>{e.options=n},()=>{}),s}_createAnimations(e,t){const n=this._properties,a=[],s=e.$animations||(e.$animations={}),r=Object.keys(t),i=Date.now();let o;for(o=r.length-1;o>=0;--o){const c=r[o];if("$"===c.charAt(0))continue;if("options"===c){a.push(...this._animateOptions(e,t));continue}const l=t[c];let u=s[c];const h=n.get(c);if(u){if(h&&u.active()){u.update(h,l,i);continue}u.cancel()}h&&h.duration?(s[c]=u=new pi(h,e,c,l),a.push(u)):e[c]=l}return a}update(e,t){if(0===this._properties.size)return void Object.assign(e,t);const n=this._createAnimations(e,t);return n.length?(ui.add(this._chart,n),!0):void 0}}function mi(e,t){const n=e&&e.options||{},a=n.reverse,s=void 0===n.min?t:0,r=void 0===n.max?t:0;return{start:a?r:s,end:a?s:r}}function gi(e,t){const n=[],a=e._getSortedDatasetMetas(t);let s,r;for(s=0,r=a.length;s<r;++s)n.push(a[s].index);return n}function yi(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};const s=e.keys,r="single"===a.mode;let i,o,c,l;if(null===t)return;let u=!1;for(i=0,o=s.length;i<o;++i){if(c=+s[i],c===n){if(u=!0,a.all)continue;break}l=e.values[c],Sa(l)&&(r||0===t||Za(t)===Za(l))&&(t+=l)}return u||a.all?t:0}function bi(e,t){const n=e&&e.options.stacked;return n||void 0===n&&void 0!==t.stack}function xi(e,t,n){const a=e[t]||(e[t]={});return a[n]||(a[n]={})}function vi(e,t,n,a){for(const s of t.getMatchingVisibleMetas(a).reverse()){const t=e[s.index];if(n&&t>0||!n&&t<0)return s.index}return null}function wi(e,t){const{chart:n,_cachedMeta:a}=e,s=n._stacks||(n._stacks={}),{iScale:r,vScale:i,index:o}=a,c=r.axis,l=i.axis,u=function(e,t,n){return"".concat(e.id,".").concat(t.id,".").concat(n.stack||n.type)}(r,i,a),h=t.length;let d;for(let p=0;p<h;++p){const e=t[p],{[c]:n,[l]:r}=e;d=(e._stacks||(e._stacks={}))[l]=xi(s,u,n),d[o]=r,d._top=vi(d,i,!0,a.type),d._bottom=vi(d,i,!1,a.type);(d._visualValues||(d._visualValues={}))[o]=r}}function ki(e,t){const n=e.scales;return Object.keys(n).filter(e=>n[e].axis===t).shift()}function Si(e,t){const n=e.controller.index,a=e.vScale&&e.vScale.axis;if(a){t=t||e._parsed;for(const e of t){const t=e._stacks;if(!t||void 0===t[a]||void 0===t[a][n])return;delete t[a][n],void 0!==t[a]._visualValues&&void 0!==t[a]._visualValues[n]&&delete t[a]._visualValues[n]}}}const Ci=e=>"reset"===e||"none"===e,Ii=(e,t)=>t?e:Object.assign({},e);class Ni{constructor(e,t){this.chart=e,this._ctx=e.ctx,this.index=t,this._cachedDataOpts={},this._cachedMeta=this.getMeta(),this._type=this._cachedMeta.type,this.options=void 0,this._parsing=!1,this._data=void 0,this._objectData=void 0,this._sharedOptions=void 0,this._drawStart=void 0,this._drawCount=void 0,this.enableOptionSharing=!1,this.supportsDecimation=!1,this.$context=void 0,this._syncList=[],this.datasetElementType=new.target.datasetElementType,this.dataElementType=new.target.dataElementType,this.initialize()}initialize(){const e=this._cachedMeta;this.configure(),this.linkScales(),e._stacked=bi(e.vScale,e),this.addElements(),this.options.fill&&!this.chart.isPluginEnabled("filler")&&console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options")}updateIndex(e){this.index!==e&&Si(this._cachedMeta),this.index=e}linkScales(){const e=this.chart,t=this._cachedMeta,n=this.getDataset(),a=(e,t,n,a)=>"x"===e?t:"r"===e?a:n,s=t.xAxisID=Ia(n.xAxisID,ki(e,"x")),r=t.yAxisID=Ia(n.yAxisID,ki(e,"y")),i=t.rAxisID=Ia(n.rAxisID,ki(e,"r")),o=t.indexAxis,c=t.iAxisID=a(o,s,r,i),l=t.vAxisID=a(o,r,s,i);t.xScale=this.getScaleForId(s),t.yScale=this.getScaleForId(r),t.rScale=this.getScaleForId(i),t.iScale=this.getScaleForId(c),t.vScale=this.getScaleForId(l)}getDataset(){return this.chart.data.datasets[this.index]}getMeta(){return this.chart.getDatasetMeta(this.index)}getScaleForId(e){return this.chart.scales[e]}_getOtherScale(e){const t=this._cachedMeta;return e===t.iScale?t.vScale:t.iScale}reset(){this._update("reset")}_destroy(){const e=this._cachedMeta;this._data&&gs(this._data,this),e._stacked&&Si(e)}_dataCheck(){const e=this.getDataset(),t=e.data||(e.data=[]),n=this._data;if(ka(t)){const e=this._cachedMeta;this._data=function(e,t){const{iScale:n,vScale:a}=t,s="x"===n.axis?"x":"y",r="x"===a.axis?"x":"y",i=Object.keys(e),o=new Array(i.length);let c,l,u;for(c=0,l=i.length;c<l;++c)u=i[c],o[c]={[s]:u,[r]:e[u]};return o}(t,e)}else if(n!==t){if(n){gs(n,this);const e=this._cachedMeta;Si(e),e._parsed=[]}t&&Object.isExtensible(t)&&function(e,t){e._chartjs?e._chartjs.listeners.push(t):(Object.defineProperty(e,"_chartjs",{configurable:!0,enumerable:!1,value:{listeners:[t]}}),ms.forEach(t=>{const n="_onData"+za(t),a=e[t];Object.defineProperty(e,t,{configurable:!0,enumerable:!1,value(){for(var t=arguments.length,s=new Array(t),r=0;r<t;r++)s[r]=arguments[r];const i=a.apply(this,s);return e._chartjs.listeners.forEach(e=>{"function"===typeof e[n]&&e[n](...s)}),i}})}))}(t,this),this._syncList=[],this._data=t}}addElements(){const e=this._cachedMeta;this._dataCheck(),this.datasetElementType&&(e.dataset=new this.datasetElementType)}buildOrUpdateElements(e){const t=this._cachedMeta,n=this.getDataset();let a=!1;this._dataCheck();const s=t._stacked;t._stacked=bi(t.vScale,t),t.stack!==n.stack&&(a=!0,Si(t),t.stack=n.stack),this._resyncElements(e),(a||s!==t._stacked)&&(wi(this,t._parsed),t._stacked=bi(t.vScale,t))}configure(){const e=this.chart.config,t=e.datasetScopeKeys(this._type),n=e.getOptionScopes(this.getDataset(),t,!0);this.options=e.createResolver(n,this.getContext()),this._parsing=this.options.parsing,this._cachedDataOpts={}}parse(e,t){const{_cachedMeta:n,_data:a}=this,{iScale:s,_stacked:r}=n,i=s.axis;let o,c,l,u=0===e&&t===a.length||n._sorted,h=e>0&&n._parsed[e-1];if(!1===this._parsing)n._parsed=a,n._sorted=!0,l=a;else{l=wa(a[e])?this.parseArrayData(n,a,e,t):ka(a[e])?this.parseObjectData(n,a,e,t):this.parsePrimitiveData(n,a,e,t);const s=()=>null===c[i]||h&&c[i]<h[i];for(o=0;o<t;++o)n._parsed[o+e]=c=l[o],u&&(s()&&(u=!1),h=c);n._sorted=u}r&&wi(this,l)}parsePrimitiveData(e,t,n,a){const{iScale:s,vScale:r}=e,i=s.axis,o=r.axis,c=s.getLabels(),l=s===r,u=new Array(a);let h,d,p;for(h=0,d=a;h<d;++h)p=h+n,u[h]={[i]:l||s.parse(c[p],p),[o]:r.parse(t[p],p)};return u}parseArrayData(e,t,n,a){const{xScale:s,yScale:r}=e,i=new Array(a);let o,c,l,u;for(o=0,c=a;o<c;++o)l=o+n,u=t[l],i[o]={x:s.parse(u[0],l),y:r.parse(u[1],l)};return i}parseObjectData(e,t,n,a){const{xScale:s,yScale:r}=e,{xAxisKey:i="x",yAxisKey:o="y"}=this._parsing,c=new Array(a);let l,u,h,d;for(l=0,u=a;l<u;++l)h=l+n,d=t[h],c[l]={x:s.parse(La(d,i),h),y:r.parse(La(d,o),h)};return c}getParsed(e){return this._cachedMeta._parsed[e]}getDataElement(e){return this._cachedMeta.data[e]}applyStack(e,t,n){const a=this.chart,s=this._cachedMeta,r=t[e.axis];return yi({keys:gi(a,!0),values:t._stacks[e.axis]._visualValues},r,s.index,{mode:n})}updateRangeFromParsed(e,t,n,a){const s=n[t.axis];let r=null===s?NaN:s;const i=a&&n._stacks[t.axis];a&&i&&(a.values=i,r=yi(a,s,this._cachedMeta.index)),e.min=Math.min(e.min,r),e.max=Math.max(e.max,r)}getMinMax(e,t){const n=this._cachedMeta,a=n._parsed,s=n._sorted&&e===n.iScale,r=a.length,i=this._getOtherScale(e),o=((e,t,n)=>e&&!t.hidden&&t._stacked&&{keys:gi(n,!0),values:null})(t,n,this.chart),c={min:Number.POSITIVE_INFINITY,max:Number.NEGATIVE_INFINITY},{min:l,max:u}=function(e){const{min:t,max:n,minDefined:a,maxDefined:s}=e.getUserBounds();return{min:a?t:Number.NEGATIVE_INFINITY,max:s?n:Number.POSITIVE_INFINITY}}(i);let h,d;function p(){d=a[h];const t=d[i.axis];return!Sa(d[e.axis])||l>t||u<t}for(h=0;h<r&&(p()||(this.updateRangeFromParsed(c,e,d,o),!s));++h);if(s)for(h=r-1;h>=0;--h)if(!p()){this.updateRangeFromParsed(c,e,d,o);break}return c}getAllParsedValues(e){const t=this._cachedMeta._parsed,n=[];let a,s,r;for(a=0,s=t.length;a<s;++a)r=t[a][e.axis],Sa(r)&&n.push(r);return n}getMaxOverflow(){return!1}getLabelAndValue(e){const t=this._cachedMeta,n=t.iScale,a=t.vScale,s=this.getParsed(e);return{label:n?""+n.getLabelForValue(s[n.axis]):"",value:a?""+a.getLabelForValue(s[a.axis]):""}}_update(e){const t=this._cachedMeta;this.update(e||"default"),t._clip=function(e){let t,n,a,s;return ka(e)?(t=e.top,n=e.right,a=e.bottom,s=e.left):t=n=a=s=e,{top:t,right:n,bottom:a,left:s,disabled:!1===e}}(Ia(this.options.clip,function(e,t,n){if(!1===n)return!1;const a=mi(e,n),s=mi(t,n);return{top:s.end,right:a.end,bottom:s.start,left:a.start}}(t.xScale,t.yScale,this.getMaxOverflow())))}update(e){}draw(){const e=this._ctx,t=this.chart,n=this._cachedMeta,a=n.data||[],s=t.chartArea,r=[],i=this._drawStart||0,o=this._drawCount||a.length-i,c=this.options.drawActiveElementsOnTop;let l;for(n.dataset&&n.dataset.draw(e,s,i,o),l=i;l<i+o;++l){const t=a[l];t.hidden||(t.active&&c?r.push(t):t.draw(e,s))}for(l=0;l<r.length;++l)r[l].draw(e,s)}getStyle(e,t){const n=t?"active":"default";return void 0===e&&this._cachedMeta.dataset?this.resolveDatasetElementOptions(n):this.resolveDataElementOptions(e||0,n)}getContext(e,t,n){const a=this.getDataset();let s;if(e>=0&&e<this._cachedMeta.data.length){const t=this._cachedMeta.data[e];s=t.$context||(t.$context=function(e,t,n){return fr(e,{active:!1,dataIndex:t,parsed:void 0,raw:void 0,element:n,index:t,mode:"default",type:"data"})}(this.getContext(),e,t)),s.parsed=this.getParsed(e),s.raw=a.data[e],s.index=s.dataIndex=e}else s=this.$context||(this.$context=function(e,t){return fr(e,{active:!1,dataset:void 0,datasetIndex:t,index:t,mode:"default",type:"dataset"})}(this.chart.getContext(),this.index)),s.dataset=a,s.index=s.datasetIndex=this.index;return s.active=!!t,s.mode=n,s}resolveDatasetElementOptions(e){return this._resolveElementOptions(this.datasetElementType.id,e)}resolveDataElementOptions(e,t){return this._resolveElementOptions(this.dataElementType.id,t,e)}_resolveElementOptions(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"default",n=arguments.length>2?arguments[2]:void 0;const a="active"===t,s=this._cachedDataOpts,r=e+"-"+t,i=s[r],o=this.enableOptionSharing&&Ba(n);if(i)return Ii(i,o);const c=this.chart.config,l=c.datasetElementScopeKeys(this._type,e),u=a?["".concat(e,"Hover"),"hover",e,""]:[e,""],h=c.getOptionScopes(this.getDataset(),l),d=Object.keys(Vs.elements[e]),p=c.resolveNamedOptions(h,d,()=>this.getContext(n,a,t),u);return p.$shared&&(p.$shared=o,s[r]=Object.freeze(Ii(p,o))),p}_resolveAnimations(e,t,n){const a=this.chart,s=this._cachedDataOpts,r="animation-".concat(t),i=s[r];if(i)return i;let o;if(!1!==a.options.animation){const a=this.chart.config,s=a.datasetAnimationScopeKeys(this._type,t),r=a.getOptionScopes(this.getDataset(),s);o=a.createResolver(r,this.getContext(e,n,t))}const c=new fi(a,o&&o.animations);return o&&o._cacheable&&(s[r]=Object.freeze(c)),c}getSharedOptions(e){if(e.$shared)return this._sharedOptions||(this._sharedOptions=Object.assign({},e))}includeOptions(e,t){return!t||Ci(e)||this.chart._animationsDisabled}_getSharedOptions(e,t){const n=this.resolveDataElementOptions(e,t),a=this._sharedOptions,s=this.getSharedOptions(n),r=this.includeOptions(t,s)||s!==a;return this.updateSharedOptions(s,t,n),{sharedOptions:s,includeOptions:r}}updateElement(e,t,n,a){Ci(a)?Object.assign(e,n):this._resolveAnimations(t,a).update(e,n)}updateSharedOptions(e,t,n){e&&!Ci(t)&&this._resolveAnimations(void 0,t).update(e,n)}_setStyle(e,t,n,a){e.active=a;const s=this.getStyle(t,a);this._resolveAnimations(t,n,a).update(e,{options:!a&&this.getSharedOptions(s)||s})}removeHoverStyle(e,t,n){this._setStyle(e,n,"active",!1)}setHoverStyle(e,t,n){this._setStyle(e,n,"active",!0)}_removeDatasetHoverStyle(){const e=this._cachedMeta.dataset;e&&this._setStyle(e,void 0,"active",!1)}_setDatasetHoverStyle(){const e=this._cachedMeta.dataset;e&&this._setStyle(e,void 0,"active",!0)}_resyncElements(e){const t=this._data,n=this._cachedMeta.data;for(const[i,o,c]of this._syncList)this[i](o,c);this._syncList=[];const a=n.length,s=t.length,r=Math.min(s,a);r&&this.parse(0,r),s>a?this._insertElements(a,s-a,e):s<a&&this._removeElements(s,a-s)}_insertElements(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];const a=this._cachedMeta,s=a.data,r=e+t;let i;const o=e=>{for(e.length+=t,i=e.length-1;i>=r;i--)e[i]=e[i-t]};for(o(s),i=e;i<r;++i)s[i]=new this.dataElementType;this._parsing&&o(a._parsed),this.parse(e,t),n&&this.updateElements(s,e,t,"reset")}updateElements(e,t,n,a){}_removeElements(e,t){const n=this._cachedMeta;if(this._parsing){const a=n._parsed.splice(e,t);n._stacked&&Si(n,a)}n.data.splice(e,t)}_sync(e){if(this._parsing)this._syncList.push(e);else{const[t,n,a]=e;this[t](n,a)}this.chart._dataChanges.push([this.index,...e])}_onDataPush(){const e=arguments.length;this._sync(["_insertElements",this.getDataset().data.length-e,e])}_onDataPop(){this._sync(["_removeElements",this._cachedMeta.data.length-1,1])}_onDataShift(){this._sync(["_removeElements",0,1])}_onDataSplice(e,t){t&&this._sync(["_removeElements",e,t]);const n=arguments.length-2;n&&this._sync(["_insertElements",e,n])}_onDataUnshift(){this._sync(["_insertElements",0,arguments.length])}}function Ti(e){const t=e.iScale,n=function(e,t){if(!e._cache.$bar){const n=e.getMatchingVisibleMetas(t);let a=[];for(let t=0,s=n.length;t<s;t++)a=a.concat(n[t].controller.getAllParsedValues(e));e._cache.$bar=ys(a.sort((e,t)=>e-t))}return e._cache.$bar}(t,e.type);let a,s,r,i,o=t._length;const c=()=>{32767!==r&&-32768!==r&&(Ba(i)&&(o=Math.min(o,Math.abs(r-i)||o)),i=r)};for(a=0,s=n.length;a<s;++a)r=t.getPixelForValue(n[a]),c();for(i=void 0,a=0,s=t.ticks.length;a<s;++a)r=t.getPixelForTick(a),c();return o}function Ei(e,t,n,a){return wa(e)?function(e,t,n,a){const s=n.parse(e[0],a),r=n.parse(e[1],a),i=Math.min(s,r),o=Math.max(s,r);let c=i,l=o;Math.abs(i)>Math.abs(o)&&(c=o,l=i),t[n.axis]=l,t._custom={barStart:c,barEnd:l,start:s,end:r,min:i,max:o}}(e,t,n,a):t[n.axis]=n.parse(e,a),t}function Ri(e,t,n,a){const s=e.iScale,r=e.vScale,i=s.getLabels(),o=s===r,c=[];let l,u,h,d;for(l=n,u=n+a;l<u;++l)d=t[l],h={},h[s.axis]=o||s.parse(i[l],l),c.push(Ei(d,h,r,l));return c}function _i(e){return e&&void 0!==e.barStart&&void 0!==e.barEnd}function Ai(e,t,n,a){let s=t.borderSkipped;const r={};if(!s)return void(e.borderSkipped=r);if(!0===s)return void(e.borderSkipped={top:!0,right:!0,bottom:!0,left:!0});const{start:i,end:o,reverse:c,top:l,bottom:u}=function(e){let t,n,a,s,r;return e.horizontal?(t=e.base>e.x,n="left",a="right"):(t=e.base<e.y,n="bottom",a="top"),t?(s="end",r="start"):(s="start",r="end"),{start:n,end:a,reverse:t,top:s,bottom:r}}(e);"middle"===s&&n&&(e.enableBorderRadius=!0,(n._top||0)===a?s=l:(n._bottom||0)===a?s=u:(r[Mi(u,i,o,c)]=!0,s=l)),r[Mi(s,i,o,c)]=!0,e.borderSkipped=r}function Mi(e,t,n,a){var s,r,i;return a?(i=n,e=Pi(e=(s=e)===(r=t)?i:s===i?r:s,n,t)):e=Pi(e,t,n),e}function Pi(e,t,n){return"start"===e?t:"end"===e?n:e}function Di(e,t,n){let{inflateAmount:a}=t;e.inflateAmount="auto"===a?1===n?.33:0:a}Fn(Ni,"defaults",{}),Fn(Ni,"datasetElementType",null),Fn(Ni,"dataElementType",null);class Oi extends Ni{parsePrimitiveData(e,t,n,a){return Ri(e,t,n,a)}parseArrayData(e,t,n,a){return Ri(e,t,n,a)}parseObjectData(e,t,n,a){const{iScale:s,vScale:r}=e,{xAxisKey:i="x",yAxisKey:o="y"}=this._parsing,c="x"===s.axis?i:o,l="x"===r.axis?i:o,u=[];let h,d,p,f;for(h=n,d=n+a;h<d;++h)f=t[h],p={},p[s.axis]=s.parse(La(f,c),h),u.push(Ei(La(f,l),p,r,h));return u}updateRangeFromParsed(e,t,n,a){super.updateRangeFromParsed(e,t,n,a);const s=n._custom;s&&t===this._cachedMeta.vScale&&(e.min=Math.min(e.min,s.min),e.max=Math.max(e.max,s.max))}getMaxOverflow(){return 0}getLabelAndValue(e){const t=this._cachedMeta,{iScale:n,vScale:a}=t,s=this.getParsed(e),r=s._custom,i=_i(r)?"["+r.start+", "+r.end+"]":""+a.getLabelForValue(s[a.axis]);return{label:""+n.getLabelForValue(s[n.axis]),value:i}}initialize(){this.enableOptionSharing=!0,super.initialize();this._cachedMeta.stack=this.getDataset().stack}update(e){const t=this._cachedMeta;this.updateElements(t.data,0,t.data.length,e)}updateElements(e,t,n,a){const s="reset"===a,{index:r,_cachedMeta:{vScale:i}}=this,o=i.getBasePixel(),c=i.isHorizontal(),l=this._getRuler(),{sharedOptions:u,includeOptions:h}=this._getSharedOptions(t,a);for(let d=t;d<t+n;d++){const t=this.getParsed(d),n=s||va(t[i.axis])?{base:o,head:o}:this._calculateBarValuePixels(d),p=this._calculateBarIndexPixels(d,l),f=(t._stacks||{})[i.axis],m={horizontal:c,base:n.base,enableBorderRadius:!f||_i(t._custom)||r===f._top||r===f._bottom,x:c?n.head:p.center,y:c?p.center:n.head,height:c?p.size:Math.abs(n.size),width:c?Math.abs(n.size):p.size};h&&(m.options=u||this.resolveDataElementOptions(d,e[d].active?"active":a));const g=m.options||e[d].options;Ai(m,g,f,r),Di(m,g,l.ratio),this.updateElement(e[d],d,m,a)}}_getStacks(e,t){const{iScale:n}=this._cachedMeta,a=n.getMatchingVisibleMetas(this._type).filter(e=>e.controller.options.grouped),s=n.options.stacked,r=[],i=this._cachedMeta.controller.getParsed(t),o=i&&i[n.axis],c=e=>{const t=e._parsed.find(e=>e[n.axis]===o),a=t&&t[e.vScale.axis];if(va(a)||isNaN(a))return!0};for(const l of a)if((void 0===t||!c(l))&&((!1===s||-1===r.indexOf(l.stack)||void 0===s&&void 0===l.stack)&&r.push(l.stack),l.index===e))break;return r.length||r.push(void 0),r}_getStackCount(e){return this._getStacks(void 0,e).length}_getAxisCount(){return this._getAxis().length}getFirstScaleIdForIndexAxis(){const e=this.chart.scales,t=this.chart.options.indexAxis;return Object.keys(e).filter(n=>e[n].axis===t).shift()}_getAxis(){const e={},t=this.getFirstScaleIdForIndexAxis();for(const n of this.chart.data.datasets)e[Ia("x"===this.chart.options.indexAxis?n.xAxisID:n.yAxisID,t)]=!0;return Object.keys(e)}_getStackIndex(e,t,n){const a=this._getStacks(e,n),s=void 0!==t?a.indexOf(t):-1;return-1===s?a.length-1:s}_getRuler(){const e=this.options,t=this._cachedMeta,n=t.iScale,a=[];let s,r;for(s=0,r=t.data.length;s<r;++s)a.push(n.getPixelForValue(this.getParsed(s)[n.axis],s));const i=e.barThickness;return{min:i||Ti(t),pixels:a,start:n._startPixel,end:n._endPixel,stackCount:this._getStackCount(),scale:n,grouped:e.grouped,ratio:i?1:e.categoryPercentage*e.barPercentage}}_calculateBarValuePixels(e){const{_cachedMeta:{vScale:t,_stacked:n,index:a},options:{base:s,minBarLength:r}}=this,i=s||0,o=this.getParsed(e),c=o._custom,l=_i(c);let u,h,d=o[t.axis],p=0,f=n?this.applyStack(t,o,n):d;f!==d&&(p=f-d,f=d),l&&(d=c.barStart,f=c.barEnd-c.barStart,0!==d&&Za(d)!==Za(c.barEnd)&&(p=0),p+=d);const m=va(s)||l?p:s;let g=t.getPixelForValue(m);if(u=this.chart.getDataVisibility(e)?t.getPixelForValue(p+f):g,h=u-g,Math.abs(h)<r){h=function(e,t,n){return 0!==e?Za(e):(t.isHorizontal()?1:-1)*(t.min>=n?1:-1)}(h,t,i)*r,d===i&&(g-=h/2);const e=t.getPixelForDecimal(0),s=t.getPixelForDecimal(1),c=Math.min(e,s),p=Math.max(e,s);g=Math.max(Math.min(g,p),c),u=g+h,n&&!l&&(o._stacks[t.axis]._visualValues[a]=t.getValueForPixel(u)-t.getValueForPixel(g))}if(g===t.getPixelForValue(i)){const e=Za(h)*t.getLineWidthForValue(i)/2;g+=e,h-=e}return{size:h,base:g,head:u,center:u+h/2}}_calculateBarIndexPixels(e,t){const n=t.scale,a=this.options,s=a.skipNull,r=Ia(a.maxBarThickness,1/0);let i,o;const c=this._getAxisCount();if(t.grouped){const n=s?this._getStackCount(e):t.stackCount,l="flex"===a.barThickness?function(e,t,n,a){const s=t.pixels,r=s[e];let i=e>0?s[e-1]:null,o=e<s.length-1?s[e+1]:null;const c=n.categoryPercentage;null===i&&(i=r-(null===o?t.end-t.start:o-r)),null===o&&(o=r+r-i);const l=r-(r-Math.min(i,o))/2*c;return{chunk:Math.abs(o-i)/2*c/a,ratio:n.barPercentage,start:l}}(e,t,a,n*c):function(e,t,n,a){const s=n.barThickness;let r,i;return va(s)?(r=t.min*n.categoryPercentage,i=n.barPercentage):(r=s*a,i=1),{chunk:r/a,ratio:i,start:t.pixels[e]-r/2}}(e,t,a,n*c),u="x"===this.chart.options.indexAxis?this.getDataset().xAxisID:this.getDataset().yAxisID,h=this._getAxis().indexOf(Ia(u,this.getFirstScaleIdForIndexAxis())),d=this._getStackIndex(this.index,this._cachedMeta.stack,s?e:void 0)+h;i=l.start+l.chunk*d+l.chunk/2,o=Math.min(r,l.chunk*l.ratio)}else i=n.getPixelForValue(this.getParsed(e)[n.axis],e),o=Math.min(r,t.min*t.ratio);return{base:i-o/2,head:i+o/2,center:i,size:o}}draw(){const e=this._cachedMeta,t=e.vScale,n=e.data,a=n.length;let s=0;for(;s<a;++s)null===this.getParsed(s)[t.axis]||n[s].hidden||n[s].draw(this._ctx)}}Fn(Oi,"id","bar"),Fn(Oi,"defaults",{datasetElementType:!1,dataElementType:"bar",categoryPercentage:.8,barPercentage:.9,grouped:!0,animations:{numbers:{type:"number",properties:["x","y","base","width","height"]}}}),Fn(Oi,"overrides",{scales:{_index_:{type:"category",offset:!0,grid:{offset:!0}},_value_:{type:"linear",beginAtZero:!0}}});class Fi extends Ni{initialize(){this.enableOptionSharing=!0,super.initialize()}parsePrimitiveData(e,t,n,a){const s=super.parsePrimitiveData(e,t,n,a);for(let r=0;r<s.length;r++)s[r]._custom=this.resolveDataElementOptions(r+n).radius;return s}parseArrayData(e,t,n,a){const s=super.parseArrayData(e,t,n,a);for(let r=0;r<s.length;r++){const e=t[n+r];s[r]._custom=Ia(e[2],this.resolveDataElementOptions(r+n).radius)}return s}parseObjectData(e,t,n,a){const s=super.parseObjectData(e,t,n,a);for(let r=0;r<s.length;r++){const e=t[n+r];s[r]._custom=Ia(e&&e.r&&+e.r,this.resolveDataElementOptions(r+n).radius)}return s}getMaxOverflow(){const e=this._cachedMeta.data;let t=0;for(let n=e.length-1;n>=0;--n)t=Math.max(t,e[n].size(this.resolveDataElementOptions(n))/2);return t>0&&t}getLabelAndValue(e){const t=this._cachedMeta,n=this.chart.data.labels||[],{xScale:a,yScale:s}=t,r=this.getParsed(e),i=a.getLabelForValue(r.x),o=s.getLabelForValue(r.y),c=r._custom;return{label:n[e]||"",value:"("+i+", "+o+(c?", "+c:"")+")"}}update(e){const t=this._cachedMeta.data;this.updateElements(t,0,t.length,e)}updateElements(e,t,n,a){const s="reset"===a,{iScale:r,vScale:i}=this._cachedMeta,{sharedOptions:o,includeOptions:c}=this._getSharedOptions(t,a),l=r.axis,u=i.axis;for(let h=t;h<t+n;h++){const t=e[h],n=!s&&this.getParsed(h),d={},p=d[l]=s?r.getPixelForDecimal(.5):r.getPixelForValue(n[l]),f=d[u]=s?i.getBasePixel():i.getPixelForValue(n[u]);d.skip=isNaN(p)||isNaN(f),c&&(d.options=o||this.resolveDataElementOptions(h,t.active?"active":a),s&&(d.options.radius=0)),this.updateElement(t,h,d,a)}}resolveDataElementOptions(e,t){const n=this.getParsed(e);let a=super.resolveDataElementOptions(e,t);a.$shared&&(a=Object.assign({},a,{$shared:!1}));const s=a.radius;return"active"!==t&&(a.radius=0),a.radius+=Ia(n&&n._custom,s),a}}Fn(Fi,"id","bubble"),Fn(Fi,"defaults",{datasetElementType:!1,dataElementType:"point",animations:{numbers:{type:"number",properties:["x","y","borderWidth","radius"]}}}),Fn(Fi,"overrides",{scales:{x:{type:"linear"},y:{type:"linear"}}});class Li extends Ni{constructor(e,t){super(e,t),this.enableOptionSharing=!0,this.innerRadius=void 0,this.outerRadius=void 0,this.offsetX=void 0,this.offsetY=void 0}linkScales(){}parse(e,t){const n=this.getDataset().data,a=this._cachedMeta;if(!1===this._parsing)a._parsed=n;else{let s,r,i=e=>+n[e];if(ka(n[e])){const{key:e="value"}=this._parsing;i=t=>+La(n[t],e)}for(s=e,r=e+t;s<r;++s)a._parsed[s]=i(s)}}_getRotation(){return ns(this.options.rotation-90)}_getCircumference(){return ns(this.options.circumference)}_getRotationExtents(){let e=Ua,t=-Ua;for(let n=0;n<this.chart.data.datasets.length;++n)if(this.chart.isDatasetVisible(n)&&this.chart.getDatasetMeta(n).type===this._type){const a=this.chart.getDatasetMeta(n).controller,s=a._getRotation(),r=a._getCircumference();e=Math.min(e,s),t=Math.max(t,s+r)}return{rotation:e,circumference:t-e}}update(e){const t=this.chart,{chartArea:n}=t,a=this._cachedMeta,s=a.data,r=this.getMaxBorderWidth()+this.getMaxOffset(s)+this.options.spacing,i=Math.max((Math.min(n.width,n.height)-r)/2,0),o=Math.min((c=this.options.cutout,l=i,"string"===typeof c&&c.endsWith("%")?parseFloat(c)/100:+c/l),1);var c,l;const u=this._getRingWeight(this.index),{circumference:h,rotation:d}=this._getRotationExtents(),{ratioX:p,ratioY:f,offsetX:m,offsetY:g}=function(e,t,n){let a=1,s=1,r=0,i=0;if(t<Ua){const o=e,c=o+t,l=Math.cos(o),u=Math.sin(o),h=Math.cos(c),d=Math.sin(c),p=(e,t,a)=>ls(e,o,c,!0)?1:Math.max(t,t*n,a,a*n),f=(e,t,a)=>ls(e,o,c,!0)?-1:Math.min(t,t*n,a,a*n),m=p(0,l,h),g=p(Ka,u,d),y=f(Va,l,h),b=f(Va+Ka,u,d);a=(m-y)/2,s=(g-b)/2,r=-(m+y)/2,i=-(g+b)/2}return{ratioX:a,ratioY:s,offsetX:r,offsetY:i}}(d,h,o),y=(n.width-r)/p,b=(n.height-r)/f,x=Math.max(Math.min(y,b)/2,0),v=Na(this.options.radius,x),w=(v-Math.max(v*o,0))/this._getVisibleDatasetWeightTotal();this.offsetX=m*v,this.offsetY=g*v,a.total=this.calculateTotal(),this.outerRadius=v-w*this._getRingWeightOffset(this.index),this.innerRadius=Math.max(this.outerRadius-w*u,0),this.updateElements(s,0,s.length,e)}_circumference(e,t){const n=this.options,a=this._cachedMeta,s=this._getCircumference();return t&&n.animation.animateRotate||!this.chart.getDataVisibility(e)||null===a._parsed[e]||a.data[e].hidden?0:this.calculateCircumference(a._parsed[e]*s/Ua)}updateElements(e,t,n,a){const s="reset"===a,r=this.chart,i=r.chartArea,o=r.options.animation,c=(i.left+i.right)/2,l=(i.top+i.bottom)/2,u=s&&o.animateScale,h=u?0:this.innerRadius,d=u?0:this.outerRadius,{sharedOptions:p,includeOptions:f}=this._getSharedOptions(t,a);let m,g=this._getRotation();for(m=0;m<t;++m)g+=this._circumference(m,s);for(m=t;m<t+n;++m){const t=this._circumference(m,s),n=e[m],r={x:c+this.offsetX,y:l+this.offsetY,startAngle:g,endAngle:g+t,circumference:t,outerRadius:d,innerRadius:h};f&&(r.options=p||this.resolveDataElementOptions(m,n.active?"active":a)),g+=t,this.updateElement(n,m,r,a)}}calculateTotal(){const e=this._cachedMeta,t=e.data;let n,a=0;for(n=0;n<t.length;n++){const s=e._parsed[n];null===s||isNaN(s)||!this.chart.getDataVisibility(n)||t[n].hidden||(a+=Math.abs(s))}return a}calculateCircumference(e){const t=this._cachedMeta.total;return t>0&&!isNaN(e)?Ua*(Math.abs(e)/t):0}getLabelAndValue(e){const t=this._cachedMeta,n=this.chart,a=n.data.labels||[],s=Ds(t._parsed[e],n.options.locale);return{label:a[e]||"",value:s}}getMaxBorderWidth(e){let t=0;const n=this.chart;let a,s,r,i,o;if(!e)for(a=0,s=n.data.datasets.length;a<s;++a)if(n.isDatasetVisible(a)){r=n.getDatasetMeta(a),e=r.data,i=r.controller;break}if(!e)return 0;for(a=0,s=e.length;a<s;++a)o=i.resolveDataElementOptions(a),"inner"!==o.borderAlign&&(t=Math.max(t,o.borderWidth||0,o.hoverBorderWidth||0));return t}getMaxOffset(e){let t=0;for(let n=0,a=e.length;n<a;++n){const e=this.resolveDataElementOptions(n);t=Math.max(t,e.offset||0,e.hoverOffset||0)}return t}_getRingWeightOffset(e){let t=0;for(let n=0;n<e;++n)this.chart.isDatasetVisible(n)&&(t+=this._getRingWeight(n));return t}_getRingWeight(e){return Math.max(Ia(this.chart.data.datasets[e].weight,1),0)}_getVisibleDatasetWeightTotal(){return this._getRingWeightOffset(this.chart.data.datasets.length)||1}}Fn(Li,"id","doughnut"),Fn(Li,"defaults",{datasetElementType:!1,dataElementType:"arc",animation:{animateRotate:!0,animateScale:!1},animations:{numbers:{type:"number",properties:["circumference","endAngle","innerRadius","outerRadius","startAngle","x","y","offset","borderWidth","spacing"]}},cutout:"50%",rotation:0,circumference:360,radius:"100%",spacing:0,indexAxis:"r"}),Fn(Li,"descriptors",{_scriptable:e=>"spacing"!==e,_indexable:e=>"spacing"!==e&&!e.startsWith("borderDash")&&!e.startsWith("hoverBorderDash")}),Fn(Li,"overrides",{aspectRatio:1,plugins:{legend:{labels:{generateLabels(e){const t=e.data,{labels:{pointStyle:n,textAlign:a,color:s,useBorderRadius:r,borderRadius:i}}=e.legend.options;return t.labels.length&&t.datasets.length?t.labels.map((t,o)=>{const c=e.getDatasetMeta(0).controller.getStyle(o);return{text:t,fillStyle:c.backgroundColor,fontColor:s,hidden:!e.getDataVisibility(o),lineDash:c.borderDash,lineDashOffset:c.borderDashOffset,lineJoin:c.borderJoinStyle,lineWidth:c.borderWidth,strokeStyle:c.borderColor,textAlign:a,pointStyle:n,borderRadius:r&&(i||c.borderRadius),index:o}}):[]}},onClick(e,t,n){n.chart.toggleDataVisibility(t.index),n.chart.update()}}}});class zi extends Ni{initialize(){this.enableOptionSharing=!0,this.supportsDecimation=!0,super.initialize()}update(e){const t=this._cachedMeta,{dataset:n,data:a=[],_dataset:s}=t,r=this.chart._animationsDisabled;let{start:i,count:o}=ks(t,a,r);this._drawStart=i,this._drawCount=o,Ss(t)&&(i=0,o=a.length),n._chart=this.chart,n._datasetIndex=this.index,n._decimated=!!s._decimated,n.points=a;const c=this.resolveDatasetElementOptions(e);this.options.showLine||(c.borderWidth=0),c.segment=this.options.segment,this.updateElement(n,void 0,{animated:!r,options:c},e),this.updateElements(a,i,o,e)}updateElements(e,t,n,a){const s="reset"===a,{iScale:r,vScale:i,_stacked:o,_dataset:c}=this._cachedMeta,{sharedOptions:l,includeOptions:u}=this._getSharedOptions(t,a),h=r.axis,d=i.axis,{spanGaps:p,segment:f}=this.options,m=es(p)?p:Number.POSITIVE_INFINITY,g=this.chart._animationsDisabled||s||"none"===a,y=t+n,b=e.length;let x=t>0&&this.getParsed(t-1);for(let v=0;v<b;++v){const n=e[v],p=g?n:{};if(v<t||v>=y){p.skip=!0;continue}const b=this.getParsed(v),w=va(b[d]),k=p[h]=r.getPixelForValue(b[h],v),S=p[d]=s||w?i.getBasePixel():i.getPixelForValue(o?this.applyStack(i,b,o):b[d],v);p.skip=isNaN(k)||isNaN(S)||w,p.stop=v>0&&Math.abs(b[h]-x[h])>m,f&&(p.parsed=b,p.raw=c.data[v]),u&&(p.options=l||this.resolveDataElementOptions(v,n.active?"active":a)),g||this.updateElement(n,v,p,a),x=b}}getMaxOverflow(){const e=this._cachedMeta,t=e.dataset,n=t.options&&t.options.borderWidth||0,a=e.data||[];if(!a.length)return n;const s=a[0].size(this.resolveDataElementOptions(0)),r=a[a.length-1].size(this.resolveDataElementOptions(a.length-1));return Math.max(n,s,r)/2}draw(){const e=this._cachedMeta;e.dataset.updateControlPoints(this.chart.chartArea,e.iScale.axis),super.draw()}}Fn(zi,"id","line"),Fn(zi,"defaults",{datasetElementType:"line",dataElementType:"point",showLine:!0,spanGaps:!1}),Fn(zi,"overrides",{scales:{_index_:{type:"category"},_value_:{type:"linear"}}});class Bi extends Ni{constructor(e,t){super(e,t),this.innerRadius=void 0,this.outerRadius=void 0}getLabelAndValue(e){const t=this._cachedMeta,n=this.chart,a=n.data.labels||[],s=Ds(t._parsed[e].r,n.options.locale);return{label:a[e]||"",value:s}}parseObjectData(e,t,n,a){return Er.bind(this)(e,t,n,a)}update(e){const t=this._cachedMeta.data;this._updateRadius(),this.updateElements(t,0,t.length,e)}getMinMax(){const e=this._cachedMeta,t={min:Number.POSITIVE_INFINITY,max:Number.NEGATIVE_INFINITY};return e.data.forEach((e,n)=>{const a=this.getParsed(n).r;!isNaN(a)&&this.chart.getDataVisibility(n)&&(a<t.min&&(t.min=a),a>t.max&&(t.max=a))}),t}_updateRadius(){const e=this.chart,t=e.chartArea,n=e.options,a=Math.min(t.right-t.left,t.bottom-t.top),s=Math.max(a/2,0),r=(s-Math.max(n.cutoutPercentage?s/100*n.cutoutPercentage:1,0))/e.getVisibleDatasetCount();this.outerRadius=s-r*this.index,this.innerRadius=this.outerRadius-r}updateElements(e,t,n,a){const s="reset"===a,r=this.chart,i=r.options.animation,o=this._cachedMeta.rScale,c=o.xCenter,l=o.yCenter,u=o.getIndexAngle(0)-.5*Va;let h,d=u;const p=360/this.countVisibleElements();for(h=0;h<t;++h)d+=this._computeAngle(h,a,p);for(h=t;h<t+n;h++){const t=e[h];let n=d,f=d+this._computeAngle(h,a,p),m=r.getDataVisibility(h)?o.getDistanceFromCenterForValue(this.getParsed(h).r):0;d=f,s&&(i.animateScale&&(m=0),i.animateRotate&&(n=f=u));const g={x:c,y:l,innerRadius:0,outerRadius:m,startAngle:n,endAngle:f,options:this.resolveDataElementOptions(h,t.active?"active":a)};this.updateElement(t,h,g,a)}}countVisibleElements(){const e=this._cachedMeta;let t=0;return e.data.forEach((e,n)=>{!isNaN(this.getParsed(n).r)&&this.chart.getDataVisibility(n)&&t++}),t}_computeAngle(e,t,n){return this.chart.getDataVisibility(e)?ns(this.resolveDataElementOptions(e,t).angle||n):0}}Fn(Bi,"id","polarArea"),Fn(Bi,"defaults",{dataElementType:"arc",animation:{animateRotate:!0,animateScale:!0},animations:{numbers:{type:"number",properties:["x","y","startAngle","endAngle","innerRadius","outerRadius"]}},indexAxis:"r",startAngle:0}),Fn(Bi,"overrides",{aspectRatio:1,plugins:{legend:{labels:{generateLabels(e){const t=e.data;if(t.labels.length&&t.datasets.length){const{labels:{pointStyle:n,color:a}}=e.legend.options;return t.labels.map((t,s)=>{const r=e.getDatasetMeta(0).controller.getStyle(s);return{text:t,fillStyle:r.backgroundColor,strokeStyle:r.borderColor,fontColor:a,lineWidth:r.borderWidth,pointStyle:n,hidden:!e.getDataVisibility(s),index:s}})}return[]}},onClick(e,t,n){n.chart.toggleDataVisibility(t.index),n.chart.update()}}},scales:{r:{type:"radialLinear",angleLines:{display:!1},beginAtZero:!0,grid:{circular:!0},pointLabels:{display:!1},startAngle:0}}});class ji extends Li{}Fn(ji,"id","pie"),Fn(ji,"defaults",{cutout:0,rotation:0,circumference:360,radius:"100%"});class Wi extends Ni{getLabelAndValue(e){const t=this._cachedMeta.vScale,n=this.getParsed(e);return{label:t.getLabels()[e],value:""+t.getLabelForValue(n[t.axis])}}parseObjectData(e,t,n,a){return Er.bind(this)(e,t,n,a)}update(e){const t=this._cachedMeta,n=t.dataset,a=t.data||[],s=t.iScale.getLabels();if(n.points=a,"resize"!==e){const t=this.resolveDatasetElementOptions(e);this.options.showLine||(t.borderWidth=0);const r={_loop:!0,_fullLoop:s.length===a.length,options:t};this.updateElement(n,void 0,r,e)}this.updateElements(a,0,a.length,e)}updateElements(e,t,n,a){const s=this._cachedMeta.rScale,r="reset"===a;for(let i=t;i<t+n;i++){const t=e[i],n=this.resolveDataElementOptions(i,t.active?"active":a),o=s.getPointPositionForValue(i,this.getParsed(i).r),c=r?s.xCenter:o.x,l=r?s.yCenter:o.y,u={x:c,y:l,angle:o.angle,skip:isNaN(c)||isNaN(l),options:n};this.updateElement(t,i,u,a)}}}Fn(Wi,"id","radar"),Fn(Wi,"defaults",{datasetElementType:"line",dataElementType:"point",indexAxis:"r",showLine:!0,elements:{line:{fill:"start"}}}),Fn(Wi,"overrides",{aspectRatio:1,scales:{r:{type:"radialLinear"}}});class Vi extends Ni{getLabelAndValue(e){const t=this._cachedMeta,n=this.chart.data.labels||[],{xScale:a,yScale:s}=t,r=this.getParsed(e),i=a.getLabelForValue(r.x),o=s.getLabelForValue(r.y);return{label:n[e]||"",value:"("+i+", "+o+")"}}update(e){const t=this._cachedMeta,{data:n=[]}=t,a=this.chart._animationsDisabled;let{start:s,count:r}=ks(t,n,a);if(this._drawStart=s,this._drawCount=r,Ss(t)&&(s=0,r=n.length),this.options.showLine){this.datasetElementType||this.addElements();const{dataset:s,_dataset:r}=t;s._chart=this.chart,s._datasetIndex=this.index,s._decimated=!!r._decimated,s.points=n;const i=this.resolveDatasetElementOptions(e);i.segment=this.options.segment,this.updateElement(s,void 0,{animated:!a,options:i},e)}else this.datasetElementType&&(delete t.dataset,this.datasetElementType=!1);this.updateElements(n,s,r,e)}addElements(){const{showLine:e}=this.options;!this.datasetElementType&&e&&(this.datasetElementType=this.chart.registry.getElement("line")),super.addElements()}updateElements(e,t,n,a){const s="reset"===a,{iScale:r,vScale:i,_stacked:o,_dataset:c}=this._cachedMeta,l=this.resolveDataElementOptions(t,a),u=this.getSharedOptions(l),h=this.includeOptions(a,u),d=r.axis,p=i.axis,{spanGaps:f,segment:m}=this.options,g=es(f)?f:Number.POSITIVE_INFINITY,y=this.chart._animationsDisabled||s||"none"===a;let b=t>0&&this.getParsed(t-1);for(let x=t;x<t+n;++x){const t=e[x],n=this.getParsed(x),l=y?t:{},f=va(n[p]),v=l[d]=r.getPixelForValue(n[d],x),w=l[p]=s||f?i.getBasePixel():i.getPixelForValue(o?this.applyStack(i,n,o):n[p],x);l.skip=isNaN(v)||isNaN(w)||f,l.stop=x>0&&Math.abs(n[d]-b[d])>g,m&&(l.parsed=n,l.raw=c.data[x]),h&&(l.options=u||this.resolveDataElementOptions(x,t.active?"active":a)),y||this.updateElement(t,x,l,a),b=n}this.updateSharedOptions(u,a,l)}getMaxOverflow(){const e=this._cachedMeta,t=e.data||[];if(!this.options.showLine){let e=0;for(let n=t.length-1;n>=0;--n)e=Math.max(e,t[n].size(this.resolveDataElementOptions(n))/2);return e>0&&e}const n=e.dataset,a=n.options&&n.options.borderWidth||0;if(!t.length)return a;const s=t[0].size(this.resolveDataElementOptions(0)),r=t[t.length-1].size(this.resolveDataElementOptions(t.length-1));return Math.max(a,s,r)/2}}Fn(Vi,"id","scatter"),Fn(Vi,"defaults",{datasetElementType:!1,dataElementType:"point",showLine:!1,fill:!1}),Fn(Vi,"overrides",{interaction:{mode:"point"},scales:{x:{type:"linear"},y:{type:"linear"}}});function Ui(){throw new Error("This method is not implemented: Check that a complete date adapter is provided.")}class Hi{static override(e){Object.assign(Hi.prototype,e)}constructor(e){Fn(this,"options",void 0),this.options=e||{}}init(){}formats(){return Ui()}parse(){return Ui()}format(){return Ui()}add(){return Ui()}diff(){return Ui()}startOf(){return Ui()}endOf(){return Ui()}}var Gi=Hi;function qi(e,t,n,a){const{controller:s,data:r,_sorted:i}=e,o=s._cachedMeta.iScale,c=e.dataset&&e.dataset.options?e.dataset.options.spanGaps:null;if(o&&t===o.axis&&"r"!==t&&i&&r.length){const i=o._reversePixels?fs:ps;if(!a){const a=i(r,t,n);if(c){const{vScale:t}=s._cachedMeta,{_parsed:n}=e,r=n.slice(0,a.lo+1).reverse().findIndex(e=>!va(e[t.axis]));a.lo-=Math.max(0,r);const i=n.slice(a.hi).findIndex(e=>!va(e[t.axis]));a.hi+=Math.max(0,i)}return a}if(s._sharedOptions){const e=r[0],a="function"===typeof e.getRange&&e.getRange(t);if(a){const e=i(r,t,n-a),s=i(r,t,n+a);return{lo:e.lo,hi:s.hi}}}}return{lo:0,hi:r.length-1}}function Ki(e,t,n,a,s){const r=e.getSortedVisibleDatasetMetas(),i=n[t];for(let o=0,c=r.length;o<c;++o){const{index:e,data:n}=r[o],{lo:c,hi:l}=qi(r[o],t,i,s);for(let t=c;t<=l;++t){const s=n[t];s.skip||a(s,e,t)}}}function Xi(e,t,n,a,s){const r=[];if(!s&&!e.isPointInArea(t))return r;return Ki(e,n,t,function(n,i,o){(s||Ys(n,e.chartArea,0))&&n.inRange(t.x,t.y,a)&&r.push({element:n,datasetIndex:i,index:o})},!0),r}function Yi(e,t,n,a,s,r){let i=[];const o=function(e){const t=-1!==e.indexOf("x"),n=-1!==e.indexOf("y");return function(e,a){const s=t?Math.abs(e.x-a.x):0,r=n?Math.abs(e.y-a.y):0;return Math.sqrt(Math.pow(s,2)+Math.pow(r,2))}}(n);let c=Number.POSITIVE_INFINITY;return Ki(e,n,t,function(n,l,u){const h=n.inRange(t.x,t.y,s);if(a&&!h)return;const d=n.getCenterPoint(s);if(!(!!r||e.isPointInArea(d))&&!h)return;const p=o(t,d);p<c?(i=[{element:n,datasetIndex:l,index:u}],c=p):p===c&&i.push({element:n,datasetIndex:l,index:u})}),i}function Qi(e,t,n,a,s,r){return r||e.isPointInArea(t)?"r"!==n||a?Yi(e,t,n,a,s,r):function(e,t,n,a){let s=[];return Ki(e,n,t,function(e,n,r){const{startAngle:i,endAngle:o}=e.getProps(["startAngle","endAngle"],a),{angle:c}=rs(e,{x:t.x,y:t.y});ls(c,i,o)&&s.push({element:e,datasetIndex:n,index:r})}),s}(e,t,n,s):[]}function Zi(e,t,n,a,s){const r=[],i="x"===n?"inXRange":"inYRange";let o=!1;return Ki(e,n,t,(e,a,c)=>{e[i]&&e[i](t[n],s)&&(r.push({element:e,datasetIndex:a,index:c}),o=o||e.inRange(t.x,t.y,s))}),a&&!o?[]:r}var Ji={evaluateInteractionItems:Ki,modes:{index(e,t,n,a){const s=Vr(t,e),r=n.axis||"x",i=n.includeInvisible||!1,o=n.intersect?Xi(e,s,r,a,i):Qi(e,s,r,!1,a,i),c=[];return o.length?(e.getSortedVisibleDatasetMetas().forEach(e=>{const t=o[0].index,n=e.data[t];n&&!n.skip&&c.push({element:n,datasetIndex:e.index,index:t})}),c):[]},dataset(e,t,n,a){const s=Vr(t,e),r=n.axis||"xy",i=n.includeInvisible||!1;let o=n.intersect?Xi(e,s,r,a,i):Qi(e,s,r,!1,a,i);if(o.length>0){const t=o[0].datasetIndex,n=e.getDatasetMeta(t).data;o=[];for(let e=0;e<n.length;++e)o.push({element:n[e],datasetIndex:t,index:e})}return o},point:(e,t,n,a)=>Xi(e,Vr(t,e),n.axis||"xy",a,n.includeInvisible||!1),nearest(e,t,n,a){const s=Vr(t,e),r=n.axis||"xy",i=n.includeInvisible||!1;return Qi(e,s,r,n.intersect,a,i)},x:(e,t,n,a)=>Zi(e,Vr(t,e),"x",n.intersect,a),y:(e,t,n,a)=>Zi(e,Vr(t,e),"y",n.intersect,a)}};const $i=["left","top","right","bottom"];function eo(e,t){return e.filter(e=>e.pos===t)}function to(e,t){return e.filter(e=>-1===$i.indexOf(e.pos)&&e.box.axis===t)}function no(e,t){return e.sort((e,n)=>{const a=t?n:e,s=t?e:n;return a.weight===s.weight?a.index-s.index:a.weight-s.weight})}function ao(e,t){const n=function(e){const t={};for(const n of e){const{stack:e,pos:a,stackWeight:s}=n;if(!e||!$i.includes(a))continue;const r=t[e]||(t[e]={count:0,placed:0,weight:0,size:0});r.count++,r.weight+=s}return t}(e),{vBoxMaxWidth:a,hBoxMaxHeight:s}=t;let r,i,o;for(r=0,i=e.length;r<i;++r){o=e[r];const{fullSize:i}=o.box,c=n[o.stack],l=c&&o.stackWeight/c.weight;o.horizontal?(o.width=l?l*a:i&&t.availableWidth,o.height=s):(o.width=a,o.height=l?l*s:i&&t.availableHeight)}return n}function so(e,t,n,a){return Math.max(e[n],t[n])+Math.max(e[a],t[a])}function ro(e,t){e.top=Math.max(e.top,t.top),e.left=Math.max(e.left,t.left),e.bottom=Math.max(e.bottom,t.bottom),e.right=Math.max(e.right,t.right)}function io(e,t,n,a){const{pos:s,box:r}=n,i=e.maxPadding;if(!ka(s)){n.size&&(e[s]-=n.size);const t=a[n.stack]||{size:0,count:1};t.size=Math.max(t.size,n.horizontal?r.height:r.width),n.size=t.size/t.count,e[s]+=n.size}r.getPadding&&ro(i,r.getPadding());const o=Math.max(0,t.outerWidth-so(i,e,"left","right")),c=Math.max(0,t.outerHeight-so(i,e,"top","bottom")),l=o!==e.w,u=c!==e.h;return e.w=o,e.h=c,n.horizontal?{same:l,other:u}:{same:u,other:l}}function oo(e,t){const n=t.maxPadding;function a(e){const a={left:0,top:0,right:0,bottom:0};return e.forEach(e=>{a[e]=Math.max(t[e],n[e])}),a}return a(e?["left","right"]:["top","bottom"])}function co(e,t,n,a){const s=[];let r,i,o,c,l,u;for(r=0,i=e.length,l=0;r<i;++r){o=e[r],c=o.box,c.update(o.width||t.w,o.height||t.h,oo(o.horizontal,t));const{same:i,other:h}=io(t,n,o,a);l|=i&&s.length,u=u||h,c.fullSize||s.push(o)}return l&&co(s,t,n,a)||u}function lo(e,t,n,a,s){e.top=n,e.left=t,e.right=t+a,e.bottom=n+s,e.width=a,e.height=s}function uo(e,t,n,a){const s=n.padding;let{x:r,y:i}=t;for(const o of e){const e=o.box,c=a[o.stack]||{count:1,placed:0,weight:1},l=o.stackWeight/c.weight||1;if(o.horizontal){const a=t.w*l,r=c.size||e.height;Ba(c.start)&&(i=c.start),e.fullSize?lo(e,s.left,i,n.outerWidth-s.right-s.left,r):lo(e,t.left+c.placed,i,a,r),c.start=i,c.placed+=a,i=e.bottom}else{const a=t.h*l,i=c.size||e.width;Ba(c.start)&&(r=c.start),e.fullSize?lo(e,r,s.top,i,n.outerHeight-s.bottom-s.top):lo(e,r,t.top+c.placed,i,a),c.start=r,c.placed+=a,r=e.right}}t.x=r,t.y=i}var ho={addBox(e,t){e.boxes||(e.boxes=[]),t.fullSize=t.fullSize||!1,t.position=t.position||"top",t.weight=t.weight||0,t._layers=t._layers||function(){return[{z:0,draw(e){t.draw(e)}}]},e.boxes.push(t)},removeBox(e,t){const n=e.boxes?e.boxes.indexOf(t):-1;-1!==n&&e.boxes.splice(n,1)},configure(e,t,n){t.fullSize=n.fullSize,t.position=n.position,t.weight=n.weight},update(e,t,n,a){if(!e)return;const s=hr(e.options.layout.padding),r=Math.max(t-s.width,0),i=Math.max(n-s.height,0),o=function(e){const t=function(e){const t=[];let n,a,s,r,i,o;for(n=0,a=(e||[]).length;n<a;++n)s=e[n],({position:r,options:{stack:i,stackWeight:o=1}}=s),t.push({index:n,box:s,pos:r,horizontal:s.isHorizontal(),weight:s.weight,stack:i&&r+i,stackWeight:o});return t}(e),n=no(t.filter(e=>e.box.fullSize),!0),a=no(eo(t,"left"),!0),s=no(eo(t,"right")),r=no(eo(t,"top"),!0),i=no(eo(t,"bottom")),o=to(t,"x"),c=to(t,"y");return{fullSize:n,leftAndTop:a.concat(r),rightAndBottom:s.concat(c).concat(i).concat(o),chartArea:eo(t,"chartArea"),vertical:a.concat(s).concat(c),horizontal:r.concat(i).concat(o)}}(e.boxes),c=o.vertical,l=o.horizontal;Ea(e.boxes,e=>{"function"===typeof e.beforeLayout&&e.beforeLayout()});const u=c.reduce((e,t)=>t.box.options&&!1===t.box.options.display?e:e+1,0)||1,h=Object.freeze({outerWidth:t,outerHeight:n,padding:s,availableWidth:r,availableHeight:i,vBoxMaxWidth:r/2/u,hBoxMaxHeight:i/2}),d=Object.assign({},s);ro(d,hr(a));const p=Object.assign({maxPadding:d,w:r,h:i,x:s.left,y:s.top},s),f=ao(c.concat(l),h);co(o.fullSize,p,h,f),co(c,p,h,f),co(l,p,h,f)&&co(c,p,h,f),function(e){const t=e.maxPadding;function n(n){const a=Math.max(t[n]-e[n],0);return e[n]+=a,a}e.y+=n("top"),e.x+=n("left"),n("right"),n("bottom")}(p),uo(o.leftAndTop,p,h,f),p.x+=p.w,p.y+=p.h,uo(o.rightAndBottom,p,h,f),e.chartArea={left:p.left,top:p.top,right:p.left+p.w,bottom:p.top+p.h,height:p.h,width:p.w},Ea(o.chartArea,t=>{const n=t.box;Object.assign(n,e.chartArea),n.update(p.w,p.h,{left:0,top:0,right:0,bottom:0})})}};class po{acquireContext(e,t){}releaseContext(e){return!1}addEventListener(e,t,n){}removeEventListener(e,t,n){}getDevicePixelRatio(){return 1}getMaximumSize(e,t,n,a){return t=Math.max(0,t||e.width),n=n||e.height,{width:t,height:Math.max(0,a?Math.floor(t/a):n)}}isAttached(e){return!0}updateConfig(e){}}class fo extends po{acquireContext(e){return e&&e.getContext&&e.getContext("2d")||null}updateConfig(e){e.options.animation=!1}}const mo="$chartjs",go={touchstart:"mousedown",touchmove:"mousemove",touchend:"mouseup",pointerenter:"mouseenter",pointerdown:"mousedown",pointermove:"mousemove",pointerup:"mouseup",pointerleave:"mouseout",pointerout:"mouseout"},yo=e=>null===e||""===e;const bo=!!qr&&{passive:!0};function xo(e,t,n){e&&e.canvas&&e.canvas.removeEventListener(t,n,bo)}function vo(e,t){for(const n of e)if(n===t||n.contains(t))return!0}function wo(e,t,n){const a=e.canvas,s=new MutationObserver(e=>{let t=!1;for(const n of e)t=t||vo(n.addedNodes,a),t=t&&!vo(n.removedNodes,a);t&&n()});return s.observe(document,{childList:!0,subtree:!0}),s}function ko(e,t,n){const a=e.canvas,s=new MutationObserver(e=>{let t=!1;for(const n of e)t=t||vo(n.removedNodes,a),t=t&&!vo(n.addedNodes,a);t&&n()});return s.observe(document,{childList:!0,subtree:!0}),s}const So=new Map;let Co=0;function Io(){const e=window.devicePixelRatio;e!==Co&&(Co=e,So.forEach((t,n)=>{n.currentDevicePixelRatio!==e&&t()}))}function No(e,t,n){const a=e.canvas,s=a&&Lr(a);if(!s)return;const r=xs((e,t)=>{const a=s.clientWidth;n(e,t),a<s.clientWidth&&n()},window),i=new ResizeObserver(e=>{const t=e[0],n=t.contentRect.width,a=t.contentRect.height;0===n&&0===a||r(n,a)});return i.observe(s),function(e,t){So.size||window.addEventListener("resize",Io),So.set(e,t)}(e,r),i}function To(e,t,n){n&&n.disconnect(),"resize"===t&&function(e){So.delete(e),So.size||window.removeEventListener("resize",Io)}(e)}function Eo(e,t,n){const a=e.canvas,s=xs(t=>{null!==e.ctx&&n(function(e,t){const n=go[e.type]||e.type,{x:a,y:s}=Vr(e,t);return{type:n,chart:t,native:e,x:void 0!==a?a:null,y:void 0!==s?s:null}}(t,e))},e);return function(e,t,n){e&&e.addEventListener(t,n,bo)}(a,t,s),s}class Ro extends po{acquireContext(e,t){const n=e&&e.getContext&&e.getContext("2d");return n&&n.canvas===e?(function(e,t){const n=e.style,a=e.getAttribute("height"),s=e.getAttribute("width");if(e[mo]={initial:{height:a,width:s,style:{display:n.display,height:n.height,width:n.width}}},n.display=n.display||"block",n.boxSizing=n.boxSizing||"border-box",yo(s)){const t=Kr(e,"width");void 0!==t&&(e.width=t)}if(yo(a))if(""===e.style.height)e.height=e.width/(t||2);else{const t=Kr(e,"height");void 0!==t&&(e.height=t)}}(e,t),n):null}releaseContext(e){const t=e.canvas;if(!t[mo])return!1;const n=t[mo].initial;["height","width"].forEach(e=>{const a=n[e];va(a)?t.removeAttribute(e):t.setAttribute(e,a)});const a=n.style||{};return Object.keys(a).forEach(e=>{t.style[e]=a[e]}),t.width=t.width,delete t[mo],!0}addEventListener(e,t,n){this.removeEventListener(e,t);const a=e.$proxies||(e.$proxies={}),s={attach:wo,detach:ko,resize:No}[t]||Eo;a[t]=s(e,t,n)}removeEventListener(e,t){const n=e.$proxies||(e.$proxies={}),a=n[t];if(!a)return;({attach:To,detach:To,resize:To}[t]||xo)(e,t,a),n[t]=void 0}getDevicePixelRatio(){return window.devicePixelRatio}getMaximumSize(e,t,n,a){return Hr(e,t,n,a)}isAttached(e){const t=e&&Lr(e);return!(!t||!t.isConnected)}}class _o{constructor(){Fn(this,"x",void 0),Fn(this,"y",void 0),Fn(this,"active",!1),Fn(this,"options",void 0),Fn(this,"$animations",void 0)}tooltipPosition(e){const{x:t,y:n}=this.getProps(["x","y"],e);return{x:t,y:n}}hasValue(){return es(this.x)&&es(this.y)}getProps(e,t){const n=this.$animations;if(!t||!n)return this;const a={};return e.forEach(e=>{a[e]=n[e]&&n[e].active()?n[e]._to:this[e]}),a}}function Ao(e,t){const n=e.options.ticks,a=function(e){const t=e.options.offset,n=e._tickSize(),a=e._length/n+(t?0:1),s=e._maxLength/n;return Math.floor(Math.min(a,s))}(e),s=Math.min(n.maxTicksLimit||a,a),r=n.major.enabled?function(e){const t=[];let n,a;for(n=0,a=e.length;n<a;n++)e[n].major&&t.push(n);return t}(t):[],i=r.length,o=r[0],c=r[i-1],l=[];if(i>s)return function(e,t,n,a){let s,r=0,i=n[0];for(a=Math.ceil(a),s=0;s<e.length;s++)s===i&&(t.push(e[s]),r++,i=n[r*a])}(t,l,r,i/s),l;const u=function(e,t,n){const a=function(e){const t=e.length;let n,a;if(t<2)return!1;for(a=e[0],n=1;n<t;++n)if(e[n]-e[n-1]!==a)return!1;return a}(e),s=t.length/n;if(!a)return Math.max(s,1);const r=function(e){const t=[],n=Math.sqrt(e);let a;for(a=1;a<n;a++)e%a===0&&(t.push(a),t.push(e/a));return n===(0|n)&&t.push(n),t.sort((e,t)=>e-t).pop(),t}(a);for(let i=0,o=r.length-1;i<o;i++){const e=r[i];if(e>s)return e}return Math.max(s,1)}(r,t,s);if(i>0){let e,n;const a=i>1?Math.round((c-o)/(i-1)):null;for(Mo(t,l,u,va(a)?0:o-a,o),e=0,n=i-1;e<n;e++)Mo(t,l,u,r[e],r[e+1]);return Mo(t,l,u,c,va(a)?t.length:c+a),l}return Mo(t,l,u),l}function Mo(e,t,n,a,s){const r=Ia(a,0),i=Math.min(Ia(s,e.length),e.length);let o,c,l,u=0;for(n=Math.ceil(n),s&&(o=s-a,n=o/Math.floor(o/n)),l=r;l<0;)u++,l=Math.round(r+u*n);for(c=Math.max(r,0);c<i;c++)c===l&&(t.push(e[c]),u++,l=Math.round(r+u*n))}Fn(_o,"defaults",{}),Fn(_o,"defaultRoutes",void 0);const Po=(e,t,n)=>"top"===t||"left"===t?e[t]+n:e[t]-n,Do=(e,t)=>Math.min(t||e,e);function Oo(e,t){const n=[],a=e.length/t,s=e.length;let r=0;for(;r<s;r+=a)n.push(e[Math.floor(r)]);return n}function Fo(e,t,n){const a=e.ticks.length,s=Math.min(t,a-1),r=e._startPixel,i=e._endPixel,o=1e-6;let c,l=e.getPixelForTick(s);if(!(n&&(c=1===a?Math.max(l-r,i-l):0===t?(e.getPixelForTick(1)-l)/2:(l-e.getPixelForTick(s-1))/2,l+=s<t?c:-c,l<r-o||l>i+o)))return l}function Lo(e){return e.drawTicks?e.tickLength:0}function zo(e,t){if(!e.display)return 0;const n=dr(e.font,t),a=hr(e.padding);return(wa(e.text)?e.text.length:1)*n.lineHeight+a.height}function Bo(e,t,n){let a=vs(e);return(n&&"right"!==t||!n&&"right"===t)&&(a=(e=>"left"===e?"right":"right"===e?"left":e)(a)),a}class jo extends _o{constructor(e){super(),this.id=e.id,this.type=e.type,this.options=void 0,this.ctx=e.ctx,this.chart=e.chart,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.width=void 0,this.height=void 0,this._margins={left:0,right:0,top:0,bottom:0},this.maxWidth=void 0,this.maxHeight=void 0,this.paddingTop=void 0,this.paddingBottom=void 0,this.paddingLeft=void 0,this.paddingRight=void 0,this.axis=void 0,this.labelRotation=void 0,this.min=void 0,this.max=void 0,this._range=void 0,this.ticks=[],this._gridLineItems=null,this._labelItems=null,this._labelSizes=null,this._length=0,this._maxLength=0,this._longestTextCache={},this._startPixel=void 0,this._endPixel=void 0,this._reversePixels=!1,this._userMax=void 0,this._userMin=void 0,this._suggestedMax=void 0,this._suggestedMin=void 0,this._ticksLength=0,this._borderValue=0,this._cache={},this._dataLimitsCached=!1,this.$context=void 0}init(e){this.options=e.setContext(this.getContext()),this.axis=e.axis,this._userMin=this.parse(e.min),this._userMax=this.parse(e.max),this._suggestedMin=this.parse(e.suggestedMin),this._suggestedMax=this.parse(e.suggestedMax)}parse(e,t){return e}getUserBounds(){let{_userMin:e,_userMax:t,_suggestedMin:n,_suggestedMax:a}=this;return e=Ca(e,Number.POSITIVE_INFINITY),t=Ca(t,Number.NEGATIVE_INFINITY),n=Ca(n,Number.POSITIVE_INFINITY),a=Ca(a,Number.NEGATIVE_INFINITY),{min:Ca(e,n),max:Ca(t,a),minDefined:Sa(e),maxDefined:Sa(t)}}getMinMax(e){let t,{min:n,max:a,minDefined:s,maxDefined:r}=this.getUserBounds();if(s&&r)return{min:n,max:a};const i=this.getMatchingVisibleMetas();for(let o=0,c=i.length;o<c;++o)t=i[o].controller.getMinMax(this,e),s||(n=Math.min(n,t.min)),r||(a=Math.max(a,t.max));return n=r&&n>a?a:n,a=s&&n>a?n:a,{min:Ca(n,Ca(a,n)),max:Ca(a,Ca(n,a))}}getPadding(){return{left:this.paddingLeft||0,top:this.paddingTop||0,right:this.paddingRight||0,bottom:this.paddingBottom||0}}getTicks(){return this.ticks}getLabels(){const e=this.chart.data;return this.options.labels||(this.isHorizontal()?e.xLabels:e.yLabels)||e.labels||[]}getLabelItems(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.chart.chartArea;return this._labelItems||(this._labelItems=this._computeLabelItems(e))}beforeLayout(){this._cache={},this._dataLimitsCached=!1}beforeUpdate(){Ta(this.options.beforeUpdate,[this])}update(e,t,n){const{beginAtZero:a,grace:s,ticks:r}=this.options,i=r.sampleSize;this.beforeUpdate(),this.maxWidth=e,this.maxHeight=t,this._margins=n=Object.assign({left:0,right:0,top:0,bottom:0},n),this.ticks=null,this._labelSizes=null,this._gridLineItems=null,this._labelItems=null,this.beforeSetDimensions(),this.setDimensions(),this.afterSetDimensions(),this._maxLength=this.isHorizontal()?this.width+n.left+n.right:this.height+n.top+n.bottom,this._dataLimitsCached||(this.beforeDataLimits(),this.determineDataLimits(),this.afterDataLimits(),this._range=function(e,t,n){const{min:a,max:s}=e,r=Na(t,(s-a)/2),i=(e,t)=>n&&0===e?0:e+t;return{min:i(a,-Math.abs(r)),max:i(s,r)}}(this,s,a),this._dataLimitsCached=!0),this.beforeBuildTicks(),this.ticks=this.buildTicks()||[],this.afterBuildTicks();const o=i<this.ticks.length;this._convertTicksToLabels(o?Oo(this.ticks,i):this.ticks),this.configure(),this.beforeCalculateLabelRotation(),this.calculateLabelRotation(),this.afterCalculateLabelRotation(),r.display&&(r.autoSkip||"auto"===r.source)&&(this.ticks=Ao(this,this.ticks),this._labelSizes=null,this.afterAutoSkip()),o&&this._convertTicksToLabels(this.ticks),this.beforeFit(),this.fit(),this.afterFit(),this.afterUpdate()}configure(){let e,t,n=this.options.reverse;this.isHorizontal()?(e=this.left,t=this.right):(e=this.top,t=this.bottom,n=!n),this._startPixel=e,this._endPixel=t,this._reversePixels=n,this._length=t-e,this._alignToPixels=this.options.alignToPixels}afterUpdate(){Ta(this.options.afterUpdate,[this])}beforeSetDimensions(){Ta(this.options.beforeSetDimensions,[this])}setDimensions(){this.isHorizontal()?(this.width=this.maxWidth,this.left=0,this.right=this.width):(this.height=this.maxHeight,this.top=0,this.bottom=this.height),this.paddingLeft=0,this.paddingTop=0,this.paddingRight=0,this.paddingBottom=0}afterSetDimensions(){Ta(this.options.afterSetDimensions,[this])}_callHooks(e){this.chart.notifyPlugins(e,this.getContext()),Ta(this.options[e],[this])}beforeDataLimits(){this._callHooks("beforeDataLimits")}determineDataLimits(){}afterDataLimits(){this._callHooks("afterDataLimits")}beforeBuildTicks(){this._callHooks("beforeBuildTicks")}buildTicks(){return[]}afterBuildTicks(){this._callHooks("afterBuildTicks")}beforeTickToLabelConversion(){Ta(this.options.beforeTickToLabelConversion,[this])}generateTickLabels(e){const t=this.options.ticks;let n,a,s;for(n=0,a=e.length;n<a;n++)s=e[n],s.label=Ta(t.callback,[s.value,n,e],this)}afterTickToLabelConversion(){Ta(this.options.afterTickToLabelConversion,[this])}beforeCalculateLabelRotation(){Ta(this.options.beforeCalculateLabelRotation,[this])}calculateLabelRotation(){const e=this.options,t=e.ticks,n=Do(this.ticks.length,e.ticks.maxTicksLimit),a=t.minRotation||0,s=t.maxRotation;let r,i,o,c=a;if(!this._isVisible()||!t.display||a>=s||n<=1||!this.isHorizontal())return void(this.labelRotation=a);const l=this._getLabelSizes(),u=l.widest.width,h=l.highest.height,d=us(this.chart.width-u,0,this.maxWidth);r=e.offset?this.maxWidth/n:d/(n-1),u+6>r&&(r=d/(n-(e.offset?.5:1)),i=this.maxHeight-Lo(e.grid)-t.padding-zo(e.title,this.chart.options.font),o=Math.sqrt(u*u+h*h),c=as(Math.min(Math.asin(us((l.highest.height+6)/r,-1,1)),Math.asin(us(i/o,-1,1))-Math.asin(us(h/o,-1,1)))),c=Math.max(a,Math.min(s,c))),this.labelRotation=c}afterCalculateLabelRotation(){Ta(this.options.afterCalculateLabelRotation,[this])}afterAutoSkip(){}beforeFit(){Ta(this.options.beforeFit,[this])}fit(){const e={width:0,height:0},{chart:t,options:{ticks:n,title:a,grid:s}}=this,r=this._isVisible(),i=this.isHorizontal();if(r){const r=zo(a,t.options.font);if(i?(e.width=this.maxWidth,e.height=Lo(s)+r):(e.height=this.maxHeight,e.width=Lo(s)+r),n.display&&this.ticks.length){const{first:t,last:a,widest:s,highest:r}=this._getLabelSizes(),o=2*n.padding,c=ns(this.labelRotation),l=Math.cos(c),u=Math.sin(c);if(i){const t=n.mirror?0:u*s.width+l*r.height;e.height=Math.min(this.maxHeight,e.height+t+o)}else{const t=n.mirror?0:l*s.width+u*r.height;e.width=Math.min(this.maxWidth,e.width+t+o)}this._calculatePadding(t,a,u,l)}}this._handleMargins(),i?(this.width=this._length=t.width-this._margins.left-this._margins.right,this.height=e.height):(this.width=e.width,this.height=this._length=t.height-this._margins.top-this._margins.bottom)}_calculatePadding(e,t,n,a){const{ticks:{align:s,padding:r},position:i}=this.options,o=0!==this.labelRotation,c="top"!==i&&"x"===this.axis;if(this.isHorizontal()){const i=this.getPixelForTick(0)-this.left,l=this.right-this.getPixelForTick(this.ticks.length-1);let u=0,h=0;o?c?(u=a*e.width,h=n*t.height):(u=n*e.height,h=a*t.width):"start"===s?h=t.width:"end"===s?u=e.width:"inner"!==s&&(u=e.width/2,h=t.width/2),this.paddingLeft=Math.max((u-i+r)*this.width/(this.width-i),0),this.paddingRight=Math.max((h-l+r)*this.width/(this.width-l),0)}else{let n=t.height/2,a=e.height/2;"start"===s?(n=0,a=e.height):"end"===s&&(n=t.height,a=0),this.paddingTop=n+r,this.paddingBottom=a+r}}_handleMargins(){this._margins&&(this._margins.left=Math.max(this.paddingLeft,this._margins.left),this._margins.top=Math.max(this.paddingTop,this._margins.top),this._margins.right=Math.max(this.paddingRight,this._margins.right),this._margins.bottom=Math.max(this.paddingBottom,this._margins.bottom))}afterFit(){Ta(this.options.afterFit,[this])}isHorizontal(){const{axis:e,position:t}=this.options;return"top"===t||"bottom"===t||"x"===e}isFullSize(){return this.options.fullSize}_convertTicksToLabels(e){let t,n;for(this.beforeTickToLabelConversion(),this.generateTickLabels(e),t=0,n=e.length;t<n;t++)va(e[t].label)&&(e.splice(t,1),n--,t--);this.afterTickToLabelConversion()}_getLabelSizes(){let e=this._labelSizes;if(!e){const t=this.options.ticks.sampleSize;let n=this.ticks;t<n.length&&(n=Oo(n,t)),this._labelSizes=e=this._computeLabelSizes(n,n.length,this.options.ticks.maxTicksLimit)}return e}_computeLabelSizes(e,t,n){const{ctx:a,_longestTextCache:s}=this,r=[],i=[],o=Math.floor(t/Do(t,n));let c,l,u,h,d,p,f,m,g,y,b,x=0,v=0;for(c=0;c<t;c+=o){if(h=e[c].label,d=this._resolveTickFontOptions(c),a.font=p=d.string,f=s[p]=s[p]||{data:{},gc:[]},m=d.lineHeight,g=y=0,va(h)||wa(h)){if(wa(h))for(l=0,u=h.length;l<u;++l)b=h[l],va(b)||wa(b)||(g=Us(a,f.data,f.gc,g,b),y+=m)}else g=Us(a,f.data,f.gc,g,h),y=m;r.push(g),i.push(y),x=Math.max(g,x),v=Math.max(y,v)}!function(e,t){Ea(e,e=>{const n=e.gc,a=n.length/2;let s;if(a>t){for(s=0;s<a;++s)delete e.data[n[s]];n.splice(0,a)}})}(s,t);const w=r.indexOf(x),k=i.indexOf(v),S=e=>({width:r[e]||0,height:i[e]||0});return{first:S(0),last:S(t-1),widest:S(w),highest:S(k),widths:r,heights:i}}getLabelForValue(e){return e}getPixelForValue(e,t){return NaN}getValueForPixel(e){}getPixelForTick(e){const t=this.ticks;return e<0||e>t.length-1?null:this.getPixelForValue(t[e].value)}getPixelForDecimal(e){this._reversePixels&&(e=1-e);const t=this._startPixel+e*this._length;return us(this._alignToPixels?Gs(this.chart,t,0):t,-32768,32767)}getDecimalForPixel(e){const t=(e-this._startPixel)/this._length;return this._reversePixels?1-t:t}getBasePixel(){return this.getPixelForValue(this.getBaseValue())}getBaseValue(){const{min:e,max:t}=this;return e<0&&t<0?t:e>0&&t>0?e:0}getContext(e){const t=this.ticks||[];if(e>=0&&e<t.length){const n=t[e];return n.$context||(n.$context=function(e,t,n){return fr(e,{tick:n,index:t,type:"tick"})}(this.getContext(),e,n))}return this.$context||(this.$context=function(e,t){return fr(e,{scale:t,type:"scale"})}(this.chart.getContext(),this))}_tickSize(){const e=this.options.ticks,t=ns(this.labelRotation),n=Math.abs(Math.cos(t)),a=Math.abs(Math.sin(t)),s=this._getLabelSizes(),r=e.autoSkipPadding||0,i=s?s.widest.width+r:0,o=s?s.highest.height+r:0;return this.isHorizontal()?o*n>i*a?i/n:o/a:o*a<i*n?o/n:i/a}_isVisible(){const e=this.options.display;return"auto"!==e?!!e:this.getMatchingVisibleMetas().length>0}_computeGridLineItems(e){const t=this.axis,n=this.chart,a=this.options,{grid:s,position:r,border:i}=a,o=s.offset,c=this.isHorizontal(),l=this.ticks.length+(o?1:0),u=Lo(s),h=[],d=i.setContext(this.getContext()),p=d.display?d.width:0,f=p/2,m=function(e){return Gs(n,e,p)};let g,y,b,x,v,w,k,S,C,I,N,T;if("top"===r)g=m(this.bottom),w=this.bottom-u,S=g-f,I=m(e.top)+f,T=e.bottom;else if("bottom"===r)g=m(this.top),I=e.top,T=m(e.bottom)-f,w=g+f,S=this.top+u;else if("left"===r)g=m(this.right),v=this.right-u,k=g-f,C=m(e.left)+f,N=e.right;else if("right"===r)g=m(this.left),C=e.left,N=m(e.right)-f,v=g+f,k=this.left+u;else if("x"===t){if("center"===r)g=m((e.top+e.bottom)/2+.5);else if(ka(r)){const e=Object.keys(r)[0],t=r[e];g=m(this.chart.scales[e].getPixelForValue(t))}I=e.top,T=e.bottom,w=g+f,S=w+u}else if("y"===t){if("center"===r)g=m((e.left+e.right)/2);else if(ka(r)){const e=Object.keys(r)[0],t=r[e];g=m(this.chart.scales[e].getPixelForValue(t))}v=g-f,k=v-u,C=e.left,N=e.right}const E=Ia(a.ticks.maxTicksLimit,l),R=Math.max(1,Math.ceil(l/E));for(y=0;y<l;y+=R){const e=this.getContext(y),t=s.setContext(e),a=i.setContext(e),r=t.lineWidth,l=t.color,u=a.dash||[],d=a.dashOffset,p=t.tickWidth,f=t.tickColor,m=t.tickBorderDash||[],g=t.tickBorderDashOffset;b=Fo(this,y,o),void 0!==b&&(x=Gs(n,b,r),c?v=k=C=N=x:w=S=I=T=x,h.push({tx1:v,ty1:w,tx2:k,ty2:S,x1:C,y1:I,x2:N,y2:T,width:r,color:l,borderDash:u,borderDashOffset:d,tickWidth:p,tickColor:f,tickBorderDash:m,tickBorderDashOffset:g}))}return this._ticksLength=l,this._borderValue=g,h}_computeLabelItems(e){const t=this.axis,n=this.options,{position:a,ticks:s}=n,r=this.isHorizontal(),i=this.ticks,{align:o,crossAlign:c,padding:l,mirror:u}=s,h=Lo(n.grid),d=h+l,p=u?-l:d,f=-ns(this.labelRotation),m=[];let g,y,b,x,v,w,k,S,C,I,N,T,E="middle";if("top"===a)w=this.bottom-p,k=this._getXAxisLabelAlignment();else if("bottom"===a)w=this.top+p,k=this._getXAxisLabelAlignment();else if("left"===a){const e=this._getYAxisLabelAlignment(h);k=e.textAlign,v=e.x}else if("right"===a){const e=this._getYAxisLabelAlignment(h);k=e.textAlign,v=e.x}else if("x"===t){if("center"===a)w=(e.top+e.bottom)/2+d;else if(ka(a)){const e=Object.keys(a)[0],t=a[e];w=this.chart.scales[e].getPixelForValue(t)+d}k=this._getXAxisLabelAlignment()}else if("y"===t){if("center"===a)v=(e.left+e.right)/2-d;else if(ka(a)){const e=Object.keys(a)[0],t=a[e];v=this.chart.scales[e].getPixelForValue(t)}k=this._getYAxisLabelAlignment(h).textAlign}"y"===t&&("start"===o?E="top":"end"===o&&(E="bottom"));const R=this._getLabelSizes();for(g=0,y=i.length;g<y;++g){b=i[g],x=b.label;const e=s.setContext(this.getContext(g));S=this.getPixelForTick(g)+s.labelOffset,C=this._resolveTickFontOptions(g),I=C.lineHeight,N=wa(x)?x.length:1;const t=N/2,n=e.color,o=e.textStrokeColor,l=e.textStrokeWidth;let h,d=k;if(r?(v=S,"inner"===k&&(d=g===y-1?this.options.reverse?"left":"right":0===g?this.options.reverse?"right":"left":"center"),T="top"===a?"near"===c||0!==f?-N*I+I/2:"center"===c?-R.highest.height/2-t*I+I:-R.highest.height+I/2:"near"===c||0!==f?I/2:"center"===c?R.highest.height/2-t*I:R.highest.height-N*I,u&&(T*=-1),0===f||e.showLabelBackdrop||(v+=I/2*Math.sin(f))):(w=S,T=(1-N)*I/2),e.showLabelBackdrop){const t=hr(e.backdropPadding),n=R.heights[g],a=R.widths[g];let s=T-t.top,r=0-t.left;switch(E){case"middle":s-=n/2;break;case"bottom":s-=n}switch(k){case"center":r-=a/2;break;case"right":r-=a;break;case"inner":g===y-1?r-=a:g>0&&(r-=a/2)}h={left:r,top:s,width:a+t.width,height:n+t.height,color:e.backdropColor}}m.push({label:x,font:C,textOffset:T,options:{rotation:f,color:n,strokeColor:o,strokeWidth:l,textAlign:d,textBaseline:E,translation:[v,w],backdrop:h}})}return m}_getXAxisLabelAlignment(){const{position:e,ticks:t}=this.options;if(-ns(this.labelRotation))return"top"===e?"left":"right";let n="center";return"start"===t.align?n="left":"end"===t.align?n="right":"inner"===t.align&&(n="inner"),n}_getYAxisLabelAlignment(e){const{position:t,ticks:{crossAlign:n,mirror:a,padding:s}}=this.options,r=e+s,i=this._getLabelSizes().widest.width;let o,c;return"left"===t?a?(c=this.right+s,"near"===n?o="left":"center"===n?(o="center",c+=i/2):(o="right",c+=i)):(c=this.right-r,"near"===n?o="right":"center"===n?(o="center",c-=i/2):(o="left",c=this.left)):"right"===t?a?(c=this.left+s,"near"===n?o="right":"center"===n?(o="center",c-=i/2):(o="left",c-=i)):(c=this.left+r,"near"===n?o="left":"center"===n?(o="center",c+=i/2):(o="right",c=this.right)):o="right",{textAlign:o,x:c}}_computeLabelArea(){if(this.options.ticks.mirror)return;const e=this.chart,t=this.options.position;return"left"===t||"right"===t?{top:0,left:this.left,bottom:e.height,right:this.right}:"top"===t||"bottom"===t?{top:this.top,left:0,bottom:this.bottom,right:e.width}:void 0}drawBackground(){const{ctx:e,options:{backgroundColor:t},left:n,top:a,width:s,height:r}=this;t&&(e.save(),e.fillStyle=t,e.fillRect(n,a,s,r),e.restore())}getLineWidthForValue(e){const t=this.options.grid;if(!this._isVisible()||!t.display)return 0;const n=this.ticks.findIndex(t=>t.value===e);if(n>=0){return t.setContext(this.getContext(n)).lineWidth}return 0}drawGrid(e){const t=this.options.grid,n=this.ctx,a=this._gridLineItems||(this._gridLineItems=this._computeGridLineItems(e));let s,r;const i=(e,t,a)=>{a.width&&a.color&&(n.save(),n.lineWidth=a.width,n.strokeStyle=a.color,n.setLineDash(a.borderDash||[]),n.lineDashOffset=a.borderDashOffset,n.beginPath(),n.moveTo(e.x,e.y),n.lineTo(t.x,t.y),n.stroke(),n.restore())};if(t.display)for(s=0,r=a.length;s<r;++s){const e=a[s];t.drawOnChartArea&&i({x:e.x1,y:e.y1},{x:e.x2,y:e.y2},e),t.drawTicks&&i({x:e.tx1,y:e.ty1},{x:e.tx2,y:e.ty2},{color:e.tickColor,width:e.tickWidth,borderDash:e.tickBorderDash,borderDashOffset:e.tickBorderDashOffset})}}drawBorder(){const{chart:e,ctx:t,options:{border:n,grid:a}}=this,s=n.setContext(this.getContext()),r=n.display?s.width:0;if(!r)return;const i=a.setContext(this.getContext(0)).lineWidth,o=this._borderValue;let c,l,u,h;this.isHorizontal()?(c=Gs(e,this.left,r)-r/2,l=Gs(e,this.right,i)+i/2,u=h=o):(u=Gs(e,this.top,r)-r/2,h=Gs(e,this.bottom,i)+i/2,c=l=o),t.save(),t.lineWidth=s.width,t.strokeStyle=s.color,t.beginPath(),t.moveTo(c,u),t.lineTo(l,h),t.stroke(),t.restore()}drawLabels(e){if(!this.options.ticks.display)return;const t=this.ctx,n=this._computeLabelArea();n&&Qs(t,n);const a=this.getLabelItems(e);for(const s of a){const e=s.options,n=s.font;nr(t,s.label,0,s.textOffset,n,e)}n&&Zs(t)}drawTitle(){const{ctx:e,options:{position:t,title:n,reverse:a}}=this;if(!n.display)return;const s=dr(n.font),r=hr(n.padding),i=n.align;let o=s.lineHeight/2;"bottom"===t||"center"===t||ka(t)?(o+=r.bottom,wa(n.text)&&(o+=s.lineHeight*(n.text.length-1))):o+=r.top;const{titleX:c,titleY:l,maxWidth:u,rotation:h}=function(e,t,n,a){const{top:s,left:r,bottom:i,right:o,chart:c}=e,{chartArea:l,scales:u}=c;let h,d,p,f=0;const m=i-s,g=o-r;if(e.isHorizontal()){if(d=ws(a,r,o),ka(n)){const e=Object.keys(n)[0],a=n[e];p=u[e].getPixelForValue(a)+m-t}else p="center"===n?(l.bottom+l.top)/2+m-t:Po(e,n,t);h=o-r}else{if(ka(n)){const e=Object.keys(n)[0],a=n[e];d=u[e].getPixelForValue(a)-g+t}else d="center"===n?(l.left+l.right)/2-g+t:Po(e,n,t);p=ws(a,i,s),f="left"===n?-Ka:Ka}return{titleX:d,titleY:p,maxWidth:h,rotation:f}}(this,o,t,i);nr(e,n.text,0,0,s,{color:n.color,maxWidth:u,rotation:h,textAlign:Bo(i,t,a),textBaseline:"middle",translation:[c,l]})}draw(e){this._isVisible()&&(this.drawBackground(),this.drawGrid(e),this.drawBorder(),this.drawTitle(),this.drawLabels(e))}_layers(){const e=this.options,t=e.ticks&&e.ticks.z||0,n=Ia(e.grid&&e.grid.z,-1),a=Ia(e.border&&e.border.z,0);return this._isVisible()&&this.draw===jo.prototype.draw?[{z:n,draw:e=>{this.drawBackground(),this.drawGrid(e),this.drawTitle()}},{z:a,draw:()=>{this.drawBorder()}},{z:t,draw:e=>{this.drawLabels(e)}}]:[{z:t,draw:e=>{this.draw(e)}}]}getMatchingVisibleMetas(e){const t=this.chart.getSortedVisibleDatasetMetas(),n=this.axis+"AxisID",a=[];let s,r;for(s=0,r=t.length;s<r;++s){const r=t[s];r[n]!==this.id||e&&r.type!==e||a.push(r)}return a}_resolveTickFontOptions(e){return dr(this.options.ticks.setContext(this.getContext(e)).font)}_maxDigits(){const e=this._resolveTickFontOptions(0).lineHeight;return(this.isHorizontal()?this.width:this.height)/e}}class Wo{constructor(e,t,n){this.type=e,this.scope=t,this.override=n,this.items=Object.create(null)}isForType(e){return Object.prototype.isPrototypeOf.call(this.type.prototype,e.prototype)}register(e){const t=Object.getPrototypeOf(e);let n;(function(e){return"id"in e&&"defaults"in e})(t)&&(n=this.register(t));const a=this.items,s=e.id,r=this.scope+"."+s;if(!s)throw new Error("class does not have id: "+e);return s in a||(a[s]=e,function(e,t,n){const a=Pa(Object.create(null),[n?Vs.get(n):{},Vs.get(t),e.defaults]);Vs.set(t,a),e.defaultRoutes&&function(e,t){Object.keys(t).forEach(n=>{const a=n.split("."),s=a.pop(),r=[e].concat(a).join("."),i=t[n].split("."),o=i.pop(),c=i.join(".");Vs.route(r,s,c,o)})}(t,e.defaultRoutes);e.descriptors&&Vs.describe(t,e.descriptors)}(e,r,n),this.override&&Vs.override(e.id,e.overrides)),r}get(e){return this.items[e]}unregister(e){const t=this.items,n=e.id,a=this.scope;n in t&&delete t[n],a&&n in Vs[a]&&(delete Vs[a][n],this.override&&delete Ls[n])}}class Vo{constructor(){this.controllers=new Wo(Ni,"datasets",!0),this.elements=new Wo(_o,"elements"),this.plugins=new Wo(Object,"plugins"),this.scales=new Wo(jo,"scales"),this._typedRegistries=[this.controllers,this.scales,this.elements]}add(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];this._each("register",t)}remove(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];this._each("unregister",t)}addControllers(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];this._each("register",t,this.controllers)}addElements(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];this._each("register",t,this.elements)}addPlugins(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];this._each("register",t,this.plugins)}addScales(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];this._each("register",t,this.scales)}getController(e){return this._get(e,this.controllers,"controller")}getElement(e){return this._get(e,this.elements,"element")}getPlugin(e){return this._get(e,this.plugins,"plugin")}getScale(e){return this._get(e,this.scales,"scale")}removeControllers(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];this._each("unregister",t,this.controllers)}removeElements(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];this._each("unregister",t,this.elements)}removePlugins(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];this._each("unregister",t,this.plugins)}removeScales(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];this._each("unregister",t,this.scales)}_each(e,t,n){[...t].forEach(t=>{const a=n||this._getRegistryForType(t);n||a.isForType(t)||a===this.plugins&&t.id?this._exec(e,a,t):Ea(t,t=>{const a=n||this._getRegistryForType(t);this._exec(e,a,t)})})}_exec(e,t,n){const a=za(e);Ta(n["before"+a],[],n),t[e](n),Ta(n["after"+a],[],n)}_getRegistryForType(e){for(let t=0;t<this._typedRegistries.length;t++){const n=this._typedRegistries[t];if(n.isForType(e))return n}return this.plugins}_get(e,t,n){const a=t.get(e);if(void 0===a)throw new Error('"'+e+'" is not a registered '+n+".");return a}}var Uo=new Vo;class Ho{constructor(){this._init=void 0}notify(e,t,n,a){if("beforeInit"===t&&(this._init=this._createDescriptors(e,!0),this._notify(this._init,e,"install")),void 0===this._init)return;const s=a?this._descriptors(e).filter(a):this._descriptors(e),r=this._notify(s,e,t,n);return"afterDestroy"===t&&(this._notify(s,e,"stop"),this._notify(this._init,e,"uninstall"),this._init=void 0),r}_notify(e,t,n,a){a=a||{};for(const s of e){const e=s.plugin;if(!1===Ta(e[n],[t,a,s.options],e)&&a.cancelable)return!1}return!0}invalidate(){va(this._cache)||(this._oldCache=this._cache,this._cache=void 0)}_descriptors(e){if(this._cache)return this._cache;const t=this._cache=this._createDescriptors(e);return this._notifyStateChanges(e),t}_createDescriptors(e,t){const n=e&&e.config,a=Ia(n.options&&n.options.plugins,{}),s=function(e){const t={},n=[],a=Object.keys(Uo.plugins.items);for(let r=0;r<a.length;r++)n.push(Uo.getPlugin(a[r]));const s=e.plugins||[];for(let r=0;r<s.length;r++){const e=s[r];-1===n.indexOf(e)&&(n.push(e),t[e.id]=!0)}return{plugins:n,localIds:t}}(n);return!1!==a||t?function(e,t,n,a){let{plugins:s,localIds:r}=t;const i=[],o=e.getContext();for(const c of s){const t=c.id,s=Go(n[t],a);null!==s&&i.push({plugin:c,options:qo(e.config,{plugin:c,local:r[t]},s,o)})}return i}(e,s,a,t):[]}_notifyStateChanges(e){const t=this._oldCache||[],n=this._cache,a=(e,t)=>e.filter(e=>!t.some(t=>e.plugin.id===t.plugin.id));this._notify(a(t,n),e,"stop"),this._notify(a(n,t),e,"start")}}function Go(e,t){return t||!1!==e?!0===e?{}:e:null}function qo(e,t,n,a){let{plugin:s,local:r}=t;const i=e.pluginScopeKeys(s),o=e.getOptionScopes(n,i);return r&&s.defaults&&o.push(s.defaults),e.createResolver(o,a,[""],{scriptable:!1,indexable:!1,allKeys:!0})}function Ko(e,t){const n=Vs.datasets[e]||{};return((t.datasets||{})[e]||{}).indexAxis||t.indexAxis||n.indexAxis||"x"}function Xo(e){if("x"===e||"y"===e||"r"===e)return e}function Yo(e){return"top"===e||"bottom"===e?"x":"left"===e||"right"===e?"y":void 0}function Qo(e){if(Xo(e))return e;for(var t=arguments.length,n=new Array(t>1?t-1:0),a=1;a<t;a++)n[a-1]=arguments[a];for(const s of n){const t=s.axis||Yo(s.position)||e.length>1&&Xo(e[0].toLowerCase());if(t)return t}throw new Error("Cannot determine type of '".concat(e,"' axis. Please provide 'axis' or 'position' option."))}function Zo(e,t,n){if(n[t+"AxisID"]===e)return{axis:t}}function Jo(e,t){const n=Ls[e.type]||{scales:{}},a=t.scales||{},s=Ko(e.type,t),r=Object.create(null);return Object.keys(a).forEach(t=>{const i=a[t];if(!ka(i))return console.error("Invalid scale configuration for scale: ".concat(t));if(i._proxy)return console.warn("Ignoring resolver passed as options for scale: ".concat(t));const o=Qo(t,i,function(e,t){if(t.data&&t.data.datasets){const n=t.data.datasets.filter(t=>t.xAxisID===e||t.yAxisID===e);if(n.length)return Zo(e,"x",n[0])||Zo(e,"y",n[0])}return{}}(t,e),Vs.scales[i.type]),c=function(e,t){return e===t?"_index_":"_value_"}(o,s),l=n.scales||{};r[t]=Da(Object.create(null),[{axis:o},i,l[o],l[c]])}),e.data.datasets.forEach(n=>{const s=n.type||e.type,i=n.indexAxis||Ko(s,t),o=(Ls[s]||{}).scales||{};Object.keys(o).forEach(e=>{const t=function(e,t){let n=e;return"_index_"===e?n=t:"_value_"===e&&(n="x"===t?"y":"x"),n}(e,i),s=n[t+"AxisID"]||t;r[s]=r[s]||Object.create(null),Da(r[s],[{axis:t},a[s],o[e]])})}),Object.keys(r).forEach(e=>{const t=r[e];Da(t,[Vs.scales[t.type],Vs.scale])}),r}function $o(e){const t=e.options||(e.options={});t.plugins=Ia(t.plugins,{}),t.scales=Jo(e,t)}function ec(e){return(e=e||{}).datasets=e.datasets||[],e.labels=e.labels||[],e}const tc=new Map,nc=new Set;function ac(e,t){let n=tc.get(e);return n||(n=t(),tc.set(e,n),nc.add(n)),n}const sc=(e,t,n)=>{const a=La(t,n);void 0!==a&&e.add(a)};class rc{constructor(e){this._config=function(e){return(e=e||{}).data=ec(e.data),$o(e),e}(e),this._scopeCache=new Map,this._resolverCache=new Map}get platform(){return this._config.platform}get type(){return this._config.type}set type(e){this._config.type=e}get data(){return this._config.data}set data(e){this._config.data=ec(e)}get options(){return this._config.options}set options(e){this._config.options=e}get plugins(){return this._config.plugins}update(){const e=this._config;this.clearCache(),$o(e)}clearCache(){this._scopeCache.clear(),this._resolverCache.clear()}datasetScopeKeys(e){return ac(e,()=>[["datasets.".concat(e),""]])}datasetAnimationScopeKeys(e,t){return ac("".concat(e,".transition.").concat(t),()=>[["datasets.".concat(e,".transitions.").concat(t),"transitions.".concat(t)],["datasets.".concat(e),""]])}datasetElementScopeKeys(e,t){return ac("".concat(e,"-").concat(t),()=>[["datasets.".concat(e,".elements.").concat(t),"datasets.".concat(e),"elements.".concat(t),""]])}pluginScopeKeys(e){const t=e.id,n=this.type;return ac("".concat(n,"-plugin-").concat(t),()=>[["plugins.".concat(t),...e.additionalOptionScopes||[]]])}_cachedScopes(e,t){const n=this._scopeCache;let a=n.get(e);return a&&!t||(a=new Map,n.set(e,a)),a}getOptionScopes(e,t,n){const{options:a,type:s}=this,r=this._cachedScopes(e,n),i=r.get(t);if(i)return i;const o=new Set;t.forEach(t=>{e&&(o.add(e),t.forEach(t=>sc(o,e,t))),t.forEach(e=>sc(o,a,e)),t.forEach(e=>sc(o,Ls[s]||{},e)),t.forEach(e=>sc(o,Vs,e)),t.forEach(e=>sc(o,zs,e))});const c=Array.from(o);return 0===c.length&&c.push(Object.create(null)),nc.has(t)&&r.set(t,c),c}chartOptionScopes(){const{options:e,type:t}=this;return[e,Ls[t]||{},Vs.datasets[t]||{},{type:t},Vs,zs]}resolveNamedOptions(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[""];const s={$shared:!0},{resolver:r,subPrefixes:i}=ic(this._resolverCache,e,a);let o=r;if(function(e,t){const{isScriptable:n,isIndexable:a}=yr(e);for(const s of t){const t=n(s),r=a(s),i=(r||t)&&e[s];if(t&&(ja(i)||oc(i))||r&&wa(i))return!0}return!1}(r,t)){s.$shared=!1;o=gr(r,n=ja(n)?n():n,this.createResolver(e,n,i))}for(const c of t)s[c]=o[c];return s}createResolver(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[""],a=arguments.length>3?arguments[3]:void 0;const{resolver:s}=ic(this._resolverCache,e,n);return ka(t)?gr(s,t,void 0,a):s}}function ic(e,t,n){let a=e.get(t);a||(a=new Map,e.set(t,a));const s=n.join();let r=a.get(s);if(!r){r={resolver:mr(t,n),subPrefixes:n.filter(e=>!e.toLowerCase().includes("hover"))},a.set(s,r)}return r}const oc=e=>ka(e)&&Object.getOwnPropertyNames(e).some(t=>ja(e[t]));const cc=["top","bottom","left","right","chartArea"];function lc(e,t){return"top"===e||"bottom"===e||-1===cc.indexOf(e)&&"x"===t}function uc(e,t){return function(n,a){return n[e]===a[e]?n[t]-a[t]:n[e]-a[e]}}function hc(e){const t=e.chart,n=t.options.animation;t.notifyPlugins("afterRender"),Ta(n&&n.onComplete,[e],t)}function dc(e){const t=e.chart,n=t.options.animation;Ta(n&&n.onProgress,[e],t)}function pc(e){return Fr()&&"string"===typeof e?e=document.getElementById(e):e&&e.length&&(e=e[0]),e&&e.canvas&&(e=e.canvas),e}const fc={},mc=e=>{const t=pc(e);return Object.values(fc).filter(e=>e.canvas===t).pop()};function gc(e,t,n){const a=Object.keys(e);for(const s of a){const a=+s;if(a>=t){const r=e[s];delete e[s],(n>0||a>t)&&(e[a+n]=r)}}}class yc{static register(){Uo.add(...arguments),bc()}static unregister(){Uo.remove(...arguments),bc()}constructor(e,t){const n=this.config=new rc(t),a=pc(e),s=mc(a);if(s)throw new Error("Canvas is already in use. Chart with ID '"+s.id+"' must be destroyed before the canvas with ID '"+s.canvas.id+"' can be reused.");const r=n.createResolver(n.chartOptionScopes(),this.getContext());this.platform=new(n.platform||function(e){return!Fr()||"undefined"!==typeof OffscreenCanvas&&e instanceof OffscreenCanvas?fo:Ro}(a)),this.platform.updateConfig(n);const i=this.platform.acquireContext(a,r.aspectRatio),o=i&&i.canvas,c=o&&o.height,l=o&&o.width;this.id=xa(),this.ctx=i,this.canvas=o,this.width=l,this.height=c,this._options=r,this._aspectRatio=this.aspectRatio,this._layers=[],this._metasets=[],this._stacks=void 0,this.boxes=[],this.currentDevicePixelRatio=void 0,this.chartArea=void 0,this._active=[],this._lastEvent=void 0,this._listeners={},this._responsiveListeners=void 0,this._sortedMetasets=[],this.scales={},this._plugins=new Ho,this.$proxies={},this._hiddenIndices={},this.attached=!1,this._animationsDisabled=void 0,this.$context=void 0,this._doResize=function(e,t){let n;return function(){for(var a=arguments.length,s=new Array(a),r=0;r<a;r++)s[r]=arguments[r];return t?(clearTimeout(n),n=setTimeout(e,t,s)):e.apply(this,s),t}}(e=>this.update(e),r.resizeDelay||0),this._dataChanges=[],fc[this.id]=this,i&&o?(ui.listen(this,"complete",hc),ui.listen(this,"progress",dc),this._initialize(),this.attached&&this.update()):console.error("Failed to create chart: can't acquire context from the given item")}get aspectRatio(){const{options:{aspectRatio:e,maintainAspectRatio:t},width:n,height:a,_aspectRatio:s}=this;return va(e)?t&&s?s:a?n/a:null:e}get data(){return this.config.data}set data(e){this.config.data=e}get options(){return this._options}set options(e){this.config.options=e}get registry(){return Uo}_initialize(){return this.notifyPlugins("beforeInit"),this.options.responsive?this.resize():Gr(this,this.options.devicePixelRatio),this.bindEvents(),this.notifyPlugins("afterInit"),this}clear(){return qs(this.canvas,this.ctx),this}stop(){return ui.stop(this),this}resize(e,t){ui.running(this)?this._resizeBeforeDraw={width:e,height:t}:this._resize(e,t)}_resize(e,t){const n=this.options,a=this.canvas,s=n.maintainAspectRatio&&this.aspectRatio,r=this.platform.getMaximumSize(a,e,t,s),i=n.devicePixelRatio||this.platform.getDevicePixelRatio(),o=this.width?"resize":"attach";this.width=r.width,this.height=r.height,this._aspectRatio=this.aspectRatio,Gr(this,i,!0)&&(this.notifyPlugins("resize",{size:r}),Ta(n.onResize,[this,r],this),this.attached&&this._doResize(o)&&this.render())}ensureScalesHaveIDs(){Ea(this.options.scales||{},(e,t)=>{e.id=t})}buildOrUpdateScales(){const e=this.options,t=e.scales,n=this.scales,a=Object.keys(n).reduce((e,t)=>(e[t]=!1,e),{});let s=[];t&&(s=s.concat(Object.keys(t).map(e=>{const n=t[e],a=Qo(e,n),s="r"===a,r="x"===a;return{options:n,dposition:s?"chartArea":r?"bottom":"left",dtype:s?"radialLinear":r?"category":"linear"}}))),Ea(s,t=>{const s=t.options,r=s.id,i=Qo(r,s),o=Ia(s.type,t.dtype);void 0!==s.position&&lc(s.position,i)===lc(t.dposition)||(s.position=t.dposition),a[r]=!0;let c=null;if(r in n&&n[r].type===o)c=n[r];else{c=new(Uo.getScale(o))({id:r,type:o,ctx:this.ctx,chart:this}),n[c.id]=c}c.init(s,e)}),Ea(a,(e,t)=>{e||delete n[t]}),Ea(n,e=>{ho.configure(this,e,e.options),ho.addBox(this,e)})}_updateMetasets(){const e=this._metasets,t=this.data.datasets.length,n=e.length;if(e.sort((e,t)=>e.index-t.index),n>t){for(let e=t;e<n;++e)this._destroyDatasetMeta(e);e.splice(t,n-t)}this._sortedMetasets=e.slice(0).sort(uc("order","index"))}_removeUnreferencedMetasets(){const{_metasets:e,data:{datasets:t}}=this;e.length>t.length&&delete this._stacks,e.forEach((e,n)=>{0===t.filter(t=>t===e._dataset).length&&this._destroyDatasetMeta(n)})}buildOrUpdateControllers(){const e=[],t=this.data.datasets;let n,a;for(this._removeUnreferencedMetasets(),n=0,a=t.length;n<a;n++){const a=t[n];let s=this.getDatasetMeta(n);const r=a.type||this.config.type;if(s.type&&s.type!==r&&(this._destroyDatasetMeta(n),s=this.getDatasetMeta(n)),s.type=r,s.indexAxis=a.indexAxis||Ko(r,this.options),s.order=a.order||0,s.index=n,s.label=""+a.label,s.visible=this.isDatasetVisible(n),s.controller)s.controller.updateIndex(n),s.controller.linkScales();else{const t=Uo.getController(r),{datasetElementType:a,dataElementType:i}=Vs.datasets[r];Object.assign(t,{dataElementType:Uo.getElement(i),datasetElementType:a&&Uo.getElement(a)}),s.controller=new t(this,n),e.push(s.controller)}}return this._updateMetasets(),e}_resetElements(){Ea(this.data.datasets,(e,t)=>{this.getDatasetMeta(t).controller.reset()},this)}reset(){this._resetElements(),this.notifyPlugins("reset")}update(e){const t=this.config;t.update();const n=this._options=t.createResolver(t.chartOptionScopes(),this.getContext()),a=this._animationsDisabled=!n.animation;if(this._updateScales(),this._checkEventBindings(),this._updateHiddenIndices(),this._plugins.invalidate(),!1===this.notifyPlugins("beforeUpdate",{mode:e,cancelable:!0}))return;const s=this.buildOrUpdateControllers();this.notifyPlugins("beforeElementsUpdate");let r=0;for(let c=0,l=this.data.datasets.length;c<l;c++){const{controller:e}=this.getDatasetMeta(c),t=!a&&-1===s.indexOf(e);e.buildOrUpdateElements(t),r=Math.max(+e.getMaxOverflow(),r)}r=this._minPadding=n.layout.autoPadding?r:0,this._updateLayout(r),a||Ea(s,e=>{e.reset()}),this._updateDatasets(e),this.notifyPlugins("afterUpdate",{mode:e}),this._layers.sort(uc("z","_idx"));const{_active:i,_lastEvent:o}=this;o?this._eventHandler(o,!0):i.length&&this._updateHoverStyles(i,i,!0),this.render()}_updateScales(){Ea(this.scales,e=>{ho.removeBox(this,e)}),this.ensureScalesHaveIDs(),this.buildOrUpdateScales()}_checkEventBindings(){const e=this.options,t=new Set(Object.keys(this._listeners)),n=new Set(e.events);Wa(t,n)&&!!this._responsiveListeners===e.responsive||(this.unbindEvents(),this.bindEvents())}_updateHiddenIndices(){const{_hiddenIndices:e}=this,t=this._getUniformDataChanges()||[];for(const{method:n,start:a,count:s}of t){gc(e,a,"_removeElements"===n?-s:s)}}_getUniformDataChanges(){const e=this._dataChanges;if(!e||!e.length)return;this._dataChanges=[];const t=this.data.datasets.length,n=t=>new Set(e.filter(e=>e[0]===t).map((e,t)=>t+","+e.splice(1).join(","))),a=n(0);for(let s=1;s<t;s++)if(!Wa(a,n(s)))return;return Array.from(a).map(e=>e.split(",")).map(e=>({method:e[1],start:+e[2],count:+e[3]}))}_updateLayout(e){if(!1===this.notifyPlugins("beforeLayout",{cancelable:!0}))return;ho.update(this,this.width,this.height,e);const t=this.chartArea,n=t.width<=0||t.height<=0;this._layers=[],Ea(this.boxes,e=>{n&&"chartArea"===e.position||(e.configure&&e.configure(),this._layers.push(...e._layers()))},this),this._layers.forEach((e,t)=>{e._idx=t}),this.notifyPlugins("afterLayout")}_updateDatasets(e){if(!1!==this.notifyPlugins("beforeDatasetsUpdate",{mode:e,cancelable:!0})){for(let e=0,t=this.data.datasets.length;e<t;++e)this.getDatasetMeta(e).controller.configure();for(let t=0,n=this.data.datasets.length;t<n;++t)this._updateDataset(t,ja(e)?e({datasetIndex:t}):e);this.notifyPlugins("afterDatasetsUpdate",{mode:e})}}_updateDataset(e,t){const n=this.getDatasetMeta(e),a={meta:n,index:e,mode:t,cancelable:!0};!1!==this.notifyPlugins("beforeDatasetUpdate",a)&&(n.controller._update(t),a.cancelable=!1,this.notifyPlugins("afterDatasetUpdate",a))}render(){!1!==this.notifyPlugins("beforeRender",{cancelable:!0})&&(ui.has(this)?this.attached&&!ui.running(this)&&ui.start(this):(this.draw(),hc({chart:this})))}draw(){let e;if(this._resizeBeforeDraw){const{width:e,height:t}=this._resizeBeforeDraw;this._resizeBeforeDraw=null,this._resize(e,t)}if(this.clear(),this.width<=0||this.height<=0)return;if(!1===this.notifyPlugins("beforeDraw",{cancelable:!0}))return;const t=this._layers;for(e=0;e<t.length&&t[e].z<=0;++e)t[e].draw(this.chartArea);for(this._drawDatasets();e<t.length;++e)t[e].draw(this.chartArea);this.notifyPlugins("afterDraw")}_getSortedDatasetMetas(e){const t=this._sortedMetasets,n=[];let a,s;for(a=0,s=t.length;a<s;++a){const s=t[a];e&&!s.visible||n.push(s)}return n}getSortedVisibleDatasetMetas(){return this._getSortedDatasetMetas(!0)}_drawDatasets(){if(!1===this.notifyPlugins("beforeDatasetsDraw",{cancelable:!0}))return;const e=this.getSortedVisibleDatasetMetas();for(let t=e.length-1;t>=0;--t)this._drawDataset(e[t]);this.notifyPlugins("afterDatasetsDraw")}_drawDataset(e){const t=this.ctx,n={meta:e,index:e.index,cancelable:!0},a=ci(this,e);!1!==this.notifyPlugins("beforeDatasetDraw",n)&&(a&&Qs(t,a),e.controller.draw(),a&&Zs(t),n.cancelable=!1,this.notifyPlugins("afterDatasetDraw",n))}isPointInArea(e){return Ys(e,this.chartArea,this._minPadding)}getElementsAtEventForMode(e,t,n,a){const s=Ji.modes[t];return"function"===typeof s?s(this,e,n,a):[]}getDatasetMeta(e){const t=this.data.datasets[e],n=this._metasets;let a=n.filter(e=>e&&e._dataset===t).pop();return a||(a={type:null,data:[],dataset:null,controller:null,hidden:null,xAxisID:null,yAxisID:null,order:t&&t.order||0,index:e,_dataset:t,_parsed:[],_sorted:!1},n.push(a)),a}getContext(){return this.$context||(this.$context=fr(null,{chart:this,type:"chart"}))}getVisibleDatasetCount(){return this.getSortedVisibleDatasetMetas().length}isDatasetVisible(e){const t=this.data.datasets[e];if(!t)return!1;const n=this.getDatasetMeta(e);return"boolean"===typeof n.hidden?!n.hidden:!t.hidden}setDatasetVisibility(e,t){this.getDatasetMeta(e).hidden=!t}toggleDataVisibility(e){this._hiddenIndices[e]=!this._hiddenIndices[e]}getDataVisibility(e){return!this._hiddenIndices[e]}_updateVisibility(e,t,n){const a=n?"show":"hide",s=this.getDatasetMeta(e),r=s.controller._resolveAnimations(void 0,a);Ba(t)?(s.data[t].hidden=!n,this.update()):(this.setDatasetVisibility(e,n),r.update(s,{visible:n}),this.update(t=>t.datasetIndex===e?a:void 0))}hide(e,t){this._updateVisibility(e,t,!1)}show(e,t){this._updateVisibility(e,t,!0)}_destroyDatasetMeta(e){const t=this._metasets[e];t&&t.controller&&t.controller._destroy(),delete this._metasets[e]}_stop(){let e,t;for(this.stop(),ui.remove(this),e=0,t=this.data.datasets.length;e<t;++e)this._destroyDatasetMeta(e)}destroy(){this.notifyPlugins("beforeDestroy");const{canvas:e,ctx:t}=this;this._stop(),this.config.clearCache(),e&&(this.unbindEvents(),qs(e,t),this.platform.releaseContext(t),this.canvas=null,this.ctx=null),delete fc[this.id],this.notifyPlugins("afterDestroy")}toBase64Image(){return this.canvas.toDataURL(...arguments)}bindEvents(){this.bindUserEvents(),this.options.responsive?this.bindResponsiveEvents():this.attached=!0}bindUserEvents(){const e=this._listeners,t=this.platform,n=(n,a)=>{t.addEventListener(this,n,a),e[n]=a},a=(e,t,n)=>{e.offsetX=t,e.offsetY=n,this._eventHandler(e)};Ea(this.options.events,e=>n(e,a))}bindResponsiveEvents(){this._responsiveListeners||(this._responsiveListeners={});const e=this._responsiveListeners,t=this.platform,n=(n,a)=>{t.addEventListener(this,n,a),e[n]=a},a=(n,a)=>{e[n]&&(t.removeEventListener(this,n,a),delete e[n])},s=(e,t)=>{this.canvas&&this.resize(e,t)};let r;const i=()=>{a("attach",i),this.attached=!0,this.resize(),n("resize",s),n("detach",r)};r=()=>{this.attached=!1,a("resize",s),this._stop(),this._resize(0,0),n("attach",i)},t.isAttached(this.canvas)?i():r()}unbindEvents(){Ea(this._listeners,(e,t)=>{this.platform.removeEventListener(this,t,e)}),this._listeners={},Ea(this._responsiveListeners,(e,t)=>{this.platform.removeEventListener(this,t,e)}),this._responsiveListeners=void 0}updateHoverStyle(e,t,n){const a=n?"set":"remove";let s,r,i,o;for("dataset"===t&&(s=this.getDatasetMeta(e[0].datasetIndex),s.controller["_"+a+"DatasetHoverStyle"]()),i=0,o=e.length;i<o;++i){r=e[i];const t=r&&this.getDatasetMeta(r.datasetIndex).controller;t&&t[a+"HoverStyle"](r.element,r.datasetIndex,r.index)}}getActiveElements(){return this._active||[]}setActiveElements(e){const t=this._active||[],n=e.map(e=>{let{datasetIndex:t,index:n}=e;const a=this.getDatasetMeta(t);if(!a)throw new Error("No dataset found at index "+t);return{datasetIndex:t,element:a.data[n],index:n}});!Ra(n,t)&&(this._active=n,this._lastEvent=null,this._updateHoverStyles(n,t))}notifyPlugins(e,t,n){return this._plugins.notify(this,e,t,n)}isPluginEnabled(e){return 1===this._plugins._cache.filter(t=>t.plugin.id===e).length}_updateHoverStyles(e,t,n){const a=this.options.hover,s=(e,t)=>e.filter(e=>!t.some(t=>e.datasetIndex===t.datasetIndex&&e.index===t.index)),r=s(t,e),i=n?e:s(e,t);r.length&&this.updateHoverStyle(r,a.mode,!1),i.length&&a.mode&&this.updateHoverStyle(i,a.mode,!0)}_eventHandler(e,t){const n={event:e,replay:t,cancelable:!0,inChartArea:this.isPointInArea(e)},a=t=>(t.options.events||this.options.events).includes(e.native.type);if(!1===this.notifyPlugins("beforeEvent",n,a))return;const s=this._handleEvent(e,t,n.inChartArea);return n.cancelable=!1,this.notifyPlugins("afterEvent",n,a),(s||n.changed)&&this.render(),this}_handleEvent(e,t,n){const{_active:a=[],options:s}=this,r=t,i=this._getActiveElements(e,a,n,r),o=function(e){return"mouseup"===e.type||"click"===e.type||"contextmenu"===e.type}(e),c=function(e,t,n,a){return n&&"mouseout"!==e.type?a?t:e:null}(e,this._lastEvent,n,o);n&&(this._lastEvent=null,Ta(s.onHover,[e,i,this],this),o&&Ta(s.onClick,[e,i,this],this));const l=!Ra(i,a);return(l||t)&&(this._active=i,this._updateHoverStyles(i,a,t)),this._lastEvent=c,l}_getActiveElements(e,t,n,a){if("mouseout"===e.type)return[];if(!n)return t;const s=this.options.hover;return this.getElementsAtEventForMode(e,s.mode,s,a)}}function bc(){return Ea(yc.instances,e=>e._plugins.invalidate())}function xc(e,t,n,a){const s=cr(e.options.borderRadius,["outerStart","outerEnd","innerStart","innerEnd"]);const r=(n-t)/2,i=Math.min(r,a*t/2),o=e=>{const t=(n-Math.min(r,e))*a/2;return us(e,0,Math.min(r,t))};return{outerStart:o(s.outerStart),outerEnd:o(s.outerEnd),innerStart:us(s.innerStart,0,i),innerEnd:us(s.innerEnd,0,i)}}function vc(e,t,n,a){return{x:n+e*Math.cos(t),y:a+e*Math.sin(t)}}function wc(e,t,n,a,s,r){const{x:i,y:o,startAngle:c,pixelMargin:l,innerRadius:u}=t,h=Math.max(t.outerRadius+a+n-l,0),d=u>0?u+a+n+l:0;let p=0;const f=s-c;if(a){const e=((u>0?u-a:0)+(h>0?h-a:0))/2;p=(f-(0!==e?f*e/(e+a):f))/2}const m=(f-Math.max(.001,f*h-n/Va)/h)/2,g=c+m+p,y=s-m-p,{outerStart:b,outerEnd:x,innerStart:v,innerEnd:w}=xc(t,d,h,y-g),k=h-b,S=h-x,C=g+b/k,I=y-x/S,N=d+v,T=d+w,E=g+v/N,R=y-w/T;if(e.beginPath(),r){const t=(C+I)/2;if(e.arc(i,o,h,C,t),e.arc(i,o,h,t,I),x>0){const t=vc(S,I,i,o);e.arc(t.x,t.y,x,I,y+Ka)}const n=vc(T,y,i,o);if(e.lineTo(n.x,n.y),w>0){const t=vc(T,R,i,o);e.arc(t.x,t.y,w,y+Ka,R+Math.PI)}const a=(y-w/d+(g+v/d))/2;if(e.arc(i,o,d,y-w/d,a,!0),e.arc(i,o,d,a,g+v/d,!0),v>0){const t=vc(N,E,i,o);e.arc(t.x,t.y,v,E+Math.PI,g-Ka)}const s=vc(k,g,i,o);if(e.lineTo(s.x,s.y),b>0){const t=vc(k,C,i,o);e.arc(t.x,t.y,b,g-Ka,C)}}else{e.moveTo(i,o);const t=Math.cos(C)*h+i,n=Math.sin(C)*h+o;e.lineTo(t,n);const a=Math.cos(I)*h+i,s=Math.sin(I)*h+o;e.lineTo(a,s)}e.closePath()}function kc(e,t,n,a,s){const{fullCircles:r,startAngle:i,circumference:o,options:c}=t,{borderWidth:l,borderJoinStyle:u,borderDash:h,borderDashOffset:d,borderRadius:p}=c,f="inner"===c.borderAlign;if(!l)return;e.setLineDash(h||[]),e.lineDashOffset=d,f?(e.lineWidth=2*l,e.lineJoin=u||"round"):(e.lineWidth=l,e.lineJoin=u||"bevel");let m=t.endAngle;if(r){wc(e,t,n,a,m,s);for(let t=0;t<r;++t)e.stroke();isNaN(o)||(m=i+(o%Ua||Ua))}f&&function(e,t,n){const{startAngle:a,pixelMargin:s,x:r,y:i,outerRadius:o,innerRadius:c}=t;let l=s/o;e.beginPath(),e.arc(r,i,o,a-l,n+l),c>s?(l=s/c,e.arc(r,i,c,n+l,a-l,!0)):e.arc(r,i,s,n+Ka,a-Ka),e.closePath(),e.clip()}(e,t,m),c.selfJoin&&m-i>=Va&&0===p&&"miter"!==u&&function(e,t,n){const{startAngle:a,x:s,y:r,outerRadius:i,innerRadius:o,options:c}=t,{borderWidth:l,borderJoinStyle:u}=c,h=Math.min(l/i,cs(a-n));if(e.beginPath(),e.arc(s,r,i-l/2,a+h/2,n-h/2),o>0){const t=Math.min(l/o,cs(a-n));e.arc(s,r,o+l/2,n-t/2,a+t/2,!0)}else{const t=Math.min(l/2,i*cs(a-n));if("round"===u)e.arc(s,r,t,n-Va/2,a+Va/2,!0);else if("bevel"===u){const i=2*t*t,o=-i*Math.cos(n+Va/2)+s,c=-i*Math.sin(n+Va/2)+r,l=i*Math.cos(a+Va/2)+s,u=i*Math.sin(a+Va/2)+r;e.lineTo(o,c),e.lineTo(l,u)}}e.closePath(),e.moveTo(0,0),e.rect(0,0,e.canvas.width,e.canvas.height),e.clip("evenodd")}(e,t,m),r||(wc(e,t,n,a,m,s),e.stroke())}Fn(yc,"defaults",Vs),Fn(yc,"instances",fc),Fn(yc,"overrides",Ls),Fn(yc,"registry",Uo),Fn(yc,"version","4.5.1"),Fn(yc,"getChart",mc);class Sc extends _o{constructor(e){super(),Fn(this,"circumference",void 0),Fn(this,"endAngle",void 0),Fn(this,"fullCircles",void 0),Fn(this,"innerRadius",void 0),Fn(this,"outerRadius",void 0),Fn(this,"pixelMargin",void 0),Fn(this,"startAngle",void 0),this.options=void 0,this.circumference=void 0,this.startAngle=void 0,this.endAngle=void 0,this.innerRadius=void 0,this.outerRadius=void 0,this.pixelMargin=0,this.fullCircles=0,e&&Object.assign(this,e)}inRange(e,t,n){const a=this.getProps(["x","y"],n),{angle:s,distance:r}=rs(a,{x:e,y:t}),{startAngle:i,endAngle:o,innerRadius:c,outerRadius:l,circumference:u}=this.getProps(["startAngle","endAngle","innerRadius","outerRadius","circumference"],n),h=(this.options.spacing+this.options.borderWidth)/2,d=Ia(u,o-i),p=ls(s,i,o)&&i!==o,f=d>=Ua||p,m=hs(r,c+h,l+h);return f&&m}getCenterPoint(e){const{x:t,y:n,startAngle:a,endAngle:s,innerRadius:r,outerRadius:i}=this.getProps(["x","y","startAngle","endAngle","innerRadius","outerRadius"],e),{offset:o,spacing:c}=this.options,l=(a+s)/2,u=(r+i+c+o)/2;return{x:t+Math.cos(l)*u,y:n+Math.sin(l)*u}}tooltipPosition(e){return this.getCenterPoint(e)}draw(e){const{options:t,circumference:n}=this,a=(t.offset||0)/4,s=(t.spacing||0)/2,r=t.circular;if(this.pixelMargin="inner"===t.borderAlign?.33:0,this.fullCircles=n>Ua?Math.floor(n/Ua):0,0===n||this.innerRadius<0||this.outerRadius<0)return;e.save();const i=(this.startAngle+this.endAngle)/2;e.translate(Math.cos(i)*a,Math.sin(i)*a);const o=a*(1-Math.sin(Math.min(Va,n||0)));e.fillStyle=t.backgroundColor,e.strokeStyle=t.borderColor,function(e,t,n,a,s){const{fullCircles:r,startAngle:i,circumference:o}=t;let c=t.endAngle;if(r){wc(e,t,n,a,c,s);for(let t=0;t<r;++t)e.fill();isNaN(o)||(c=i+(o%Ua||Ua))}wc(e,t,n,a,c,s),e.fill()}(e,this,o,s,r),kc(e,this,o,s,r),e.restore()}}function Cc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:t;e.lineCap=Ia(n.borderCapStyle,t.borderCapStyle),e.setLineDash(Ia(n.borderDash,t.borderDash)),e.lineDashOffset=Ia(n.borderDashOffset,t.borderDashOffset),e.lineJoin=Ia(n.borderJoinStyle,t.borderJoinStyle),e.lineWidth=Ia(n.borderWidth,t.borderWidth),e.strokeStyle=Ia(n.borderColor,t.borderColor)}function Ic(e,t,n){e.lineTo(n.x,n.y)}function Nc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const a=e.length,{start:s=0,end:r=a-1}=n,{start:i,end:o}=t,c=Math.max(s,i),l=Math.min(r,o),u=s<i&&r<i||s>o&&r>o;return{count:a,start:c,loop:t.loop,ilen:l<c&&!u?a+l-c:l-c}}function Tc(e,t,n,a){const{points:s,options:r}=t,{count:i,start:o,loop:c,ilen:l}=Nc(s,n,a),u=function(e){return e.stepped?Js:e.tension||"monotone"===e.cubicInterpolationMode?$s:Ic}(r);let h,d,p,{move:f=!0,reverse:m}=a||{};for(h=0;h<=l;++h)d=s[(o+(m?l-h:h))%i],d.skip||(f?(e.moveTo(d.x,d.y),f=!1):u(e,p,d,m,r.stepped),p=d);return c&&(d=s[(o+(m?l:0))%i],u(e,p,d,m,r.stepped)),!!c}function Ec(e,t,n,a){const s=t.points,{count:r,start:i,ilen:o}=Nc(s,n,a),{move:c=!0,reverse:l}=a||{};let u,h,d,p,f,m,g=0,y=0;const b=e=>(i+(l?o-e:e))%r,x=()=>{p!==f&&(e.lineTo(g,f),e.lineTo(g,p),e.lineTo(g,m))};for(c&&(h=s[b(0)],e.moveTo(h.x,h.y)),u=0;u<=o;++u){if(h=s[b(u)],h.skip)continue;const t=h.x,n=h.y,a=0|t;a===d?(n<p?p=n:n>f&&(f=n),g=(y*g+t)/++y):(x(),e.lineTo(t,n),d=a,y=0,p=f=n),m=n}x()}function Rc(e){const t=e.options,n=t.borderDash&&t.borderDash.length;return!e._decimated&&!e._loop&&!t.tension&&"monotone"!==t.cubicInterpolationMode&&!t.stepped&&!n?Ec:Tc}Fn(Sc,"id","arc"),Fn(Sc,"defaults",{borderAlign:"center",borderColor:"#fff",borderDash:[],borderDashOffset:0,borderJoinStyle:void 0,borderRadius:0,borderWidth:2,offset:0,spacing:0,angle:void 0,circular:!0,selfJoin:!1}),Fn(Sc,"defaultRoutes",{backgroundColor:"backgroundColor"}),Fn(Sc,"descriptors",{_scriptable:!0,_indexable:e=>"borderDash"!==e});const _c="function"===typeof Path2D;function Ac(e,t,n,a){_c&&!t.options.segment?function(e,t,n,a){let s=t._path;s||(s=t._path=new Path2D,t.path(s,n,a)&&s.closePath()),Cc(e,t.options),e.stroke(s)}(e,t,n,a):function(e,t,n,a){const{segments:s,options:r}=t,i=Rc(t);for(const o of s)Cc(e,r,o.style),e.beginPath(),i(e,t,o,{start:n,end:n+a-1})&&e.closePath(),e.stroke()}(e,t,n,a)}class Mc extends _o{constructor(e){super(),this.animated=!0,this.options=void 0,this._chart=void 0,this._loop=void 0,this._fullLoop=void 0,this._path=void 0,this._points=void 0,this._segments=void 0,this._decimated=!1,this._pointsUpdated=!1,this._datasetIndex=void 0,e&&Object.assign(this,e)}updateControlPoints(e,t){const n=this.options;if((n.tension||"monotone"===n.cubicInterpolationMode)&&!n.stepped&&!this._pointsUpdated){const a=n.spanGaps?this._loop:this._fullLoop;Or(this._points,n,e,a,t),this._pointsUpdated=!0}}set points(e){this._points=e,delete this._segments,delete this._path,this._pointsUpdated=!1}get points(){return this._points}get segments(){return this._segments||(this._segments=function(e,t){const n=e.points,a=e.options.spanGaps,s=n.length;if(!s)return[];const r=!!e._loop,{start:i,end:o}=function(e,t,n,a){let s=0,r=t-1;if(n&&!a)for(;s<t&&!e[s].skip;)s++;for(;s<t&&e[s].skip;)s++;for(s%=t,n&&(r+=s);r>s&&e[r%t].skip;)r--;return r%=t,{start:s,end:r}}(n,s,r,a);return si(e,!0===a?[{start:i,end:o,loop:r}]:function(e,t,n,a){const s=e.length,r=[];let i,o=t,c=e[t];for(i=t+1;i<=n;++i){const n=e[i%s];n.skip||n.stop?c.skip||(a=!1,r.push({start:t%s,end:(i-1)%s,loop:a}),t=o=n.stop?i:null):(o=i,c.skip&&(t=i)),c=n}return null!==o&&r.push({start:t%s,end:o%s,loop:a}),r}(n,i,o<i?o+s:o,!!e._fullLoop&&0===i&&o===s-1),n,t)}(this,this.options.segment))}first(){const e=this.segments,t=this.points;return e.length&&t[e[0].start]}last(){const e=this.segments,t=this.points,n=e.length;return n&&t[e[n-1].end]}interpolate(e,t){const n=this.options,a=e[t],s=this.points,r=ai(this,{property:t,start:a,end:a});if(!r.length)return;const i=[],o=function(e){return e.stepped?Yr:e.tension||"monotone"===e.cubicInterpolationMode?Qr:Xr}(n);let c,l;for(c=0,l=r.length;c<l;++c){const{start:l,end:u}=r[c],h=s[l],d=s[u];if(h===d){i.push(h);continue}const p=o(h,d,Math.abs((a-h[t])/(d[t]-h[t])),n.stepped);p[t]=e[t],i.push(p)}return 1===i.length?i[0]:i}pathSegment(e,t,n){return Rc(this)(e,this,t,n)}path(e,t,n){const a=this.segments,s=Rc(this);let r=this._loop;t=t||0,n=n||this.points.length-t;for(const i of a)r&=s(e,this,i,{start:t,end:t+n-1});return!!r}draw(e,t,n,a){const s=this.options||{};(this.points||[]).length&&s.borderWidth&&(e.save(),Ac(e,this,n,a),e.restore()),this.animated&&(this._pointsUpdated=!1,this._path=void 0)}}function Pc(e,t,n,a){const s=e.options,{[n]:r}=e.getProps([n],a);return Math.abs(t-r)<s.radius+s.hitRadius}Fn(Mc,"id","line"),Fn(Mc,"defaults",{borderCapStyle:"butt",borderDash:[],borderDashOffset:0,borderJoinStyle:"miter",borderWidth:3,capBezierPoints:!0,cubicInterpolationMode:"default",fill:!1,spanGaps:!1,stepped:!1,tension:0}),Fn(Mc,"defaultRoutes",{backgroundColor:"backgroundColor",borderColor:"borderColor"}),Fn(Mc,"descriptors",{_scriptable:!0,_indexable:e=>"borderDash"!==e&&"fill"!==e});class Dc extends _o{constructor(e){super(),Fn(this,"parsed",void 0),Fn(this,"skip",void 0),Fn(this,"stop",void 0),this.options=void 0,this.parsed=void 0,this.skip=void 0,this.stop=void 0,e&&Object.assign(this,e)}inRange(e,t,n){const a=this.options,{x:s,y:r}=this.getProps(["x","y"],n);return Math.pow(e-s,2)+Math.pow(t-r,2)<Math.pow(a.hitRadius+a.radius,2)}inXRange(e,t){return Pc(this,e,"x",t)}inYRange(e,t){return Pc(this,e,"y",t)}getCenterPoint(e){const{x:t,y:n}=this.getProps(["x","y"],e);return{x:t,y:n}}size(e){let t=(e=e||this.options||{}).radius||0;t=Math.max(t,t&&e.hoverRadius||0);return 2*(t+(t&&e.borderWidth||0))}draw(e,t){const n=this.options;this.skip||n.radius<.1||!Ys(this,t,this.size(n)/2)||(e.strokeStyle=n.borderColor,e.lineWidth=n.borderWidth,e.fillStyle=n.backgroundColor,Ks(e,n,this.x,this.y))}getRange(){const e=this.options||{};return e.radius+e.hitRadius}}function Oc(e,t){const{x:n,y:a,base:s,width:r,height:i}=e.getProps(["x","y","base","width","height"],t);let o,c,l,u,h;return e.horizontal?(h=i/2,o=Math.min(n,s),c=Math.max(n,s),l=a-h,u=a+h):(h=r/2,o=n-h,c=n+h,l=Math.min(a,s),u=Math.max(a,s)),{left:o,top:l,right:c,bottom:u}}function Fc(e,t,n,a){return e?0:us(t,n,a)}function Lc(e){const t=Oc(e),n=t.right-t.left,a=t.bottom-t.top,s=function(e,t,n){const a=e.options.borderWidth,s=e.borderSkipped,r=lr(a);return{t:Fc(s.top,r.top,0,n),r:Fc(s.right,r.right,0,t),b:Fc(s.bottom,r.bottom,0,n),l:Fc(s.left,r.left,0,t)}}(e,n/2,a/2),r=function(e,t,n){const{enableBorderRadius:a}=e.getProps(["enableBorderRadius"]),s=e.options.borderRadius,r=ur(s),i=Math.min(t,n),o=e.borderSkipped,c=a||ka(s);return{topLeft:Fc(!c||o.top||o.left,r.topLeft,0,i),topRight:Fc(!c||o.top||o.right,r.topRight,0,i),bottomLeft:Fc(!c||o.bottom||o.left,r.bottomLeft,0,i),bottomRight:Fc(!c||o.bottom||o.right,r.bottomRight,0,i)}}(e,n/2,a/2);return{outer:{x:t.left,y:t.top,w:n,h:a,radius:r},inner:{x:t.left+s.l,y:t.top+s.t,w:n-s.l-s.r,h:a-s.t-s.b,radius:{topLeft:Math.max(0,r.topLeft-Math.max(s.t,s.l)),topRight:Math.max(0,r.topRight-Math.max(s.t,s.r)),bottomLeft:Math.max(0,r.bottomLeft-Math.max(s.b,s.l)),bottomRight:Math.max(0,r.bottomRight-Math.max(s.b,s.r))}}}}function zc(e,t,n,a){const s=null===t,r=null===n,i=e&&!(s&&r)&&Oc(e,a);return i&&(s||hs(t,i.left,i.right))&&(r||hs(n,i.top,i.bottom))}function Bc(e,t){e.rect(t.x,t.y,t.w,t.h)}function jc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const a=e.x!==n.x?-t:0,s=e.y!==n.y?-t:0,r=(e.x+e.w!==n.x+n.w?t:0)-a,i=(e.y+e.h!==n.y+n.h?t:0)-s;return{x:e.x+a,y:e.y+s,w:e.w+r,h:e.h+i,radius:e.radius}}Fn(Dc,"id","point"),Fn(Dc,"defaults",{borderWidth:1,hitRadius:1,hoverBorderWidth:1,hoverRadius:4,pointStyle:"circle",radius:3,rotation:0}),Fn(Dc,"defaultRoutes",{backgroundColor:"backgroundColor",borderColor:"borderColor"});class Wc extends _o{constructor(e){super(),this.options=void 0,this.horizontal=void 0,this.base=void 0,this.width=void 0,this.height=void 0,this.inflateAmount=void 0,e&&Object.assign(this,e)}draw(e){const{inflateAmount:t,options:{borderColor:n,backgroundColor:a}}=this,{inner:s,outer:r}=Lc(this),i=(o=r.radius).topLeft||o.topRight||o.bottomLeft||o.bottomRight?ar:Bc;var o;e.save(),r.w===s.w&&r.h===s.h||(e.beginPath(),i(e,jc(r,t,s)),e.clip(),i(e,jc(s,-t,r)),e.fillStyle=n,e.fill("evenodd")),e.beginPath(),i(e,jc(s,t)),e.fillStyle=a,e.fill(),e.restore()}inRange(e,t,n){return zc(this,e,t,n)}inXRange(e,t){return zc(this,e,null,t)}inYRange(e,t){return zc(this,null,e,t)}getCenterPoint(e){const{x:t,y:n,base:a,horizontal:s}=this.getProps(["x","y","base","horizontal"],e);return{x:s?(t+a)/2:t,y:s?n:(n+a)/2}}getRange(e){return"x"===e?this.width/2:this.height/2}}Fn(Wc,"id","bar"),Fn(Wc,"defaults",{borderSkipped:"start",borderWidth:0,borderRadius:0,inflateAmount:"auto",pointStyle:void 0}),Fn(Wc,"defaultRoutes",{backgroundColor:"backgroundColor",borderColor:"borderColor"});const Vc=(e,t)=>{let{boxHeight:n=t,boxWidth:a=t}=e;return e.usePointStyle&&(n=Math.min(n,t),a=e.pointStyleWidth||Math.min(a,t)),{boxWidth:a,boxHeight:n,itemHeight:Math.max(t,n)}};class Uc extends _o{constructor(e){super(),this._added=!1,this.legendHitBoxes=[],this._hoveredItem=null,this.doughnutMode=!1,this.chart=e.chart,this.options=e.options,this.ctx=e.ctx,this.legendItems=void 0,this.columnSizes=void 0,this.lineWidths=void 0,this.maxHeight=void 0,this.maxWidth=void 0,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.height=void 0,this.width=void 0,this._margins=void 0,this.position=void 0,this.weight=void 0,this.fullSize=void 0}update(e,t,n){this.maxWidth=e,this.maxHeight=t,this._margins=n,this.setDimensions(),this.buildLabels(),this.fit()}setDimensions(){this.isHorizontal()?(this.width=this.maxWidth,this.left=this._margins.left,this.right=this.width):(this.height=this.maxHeight,this.top=this._margins.top,this.bottom=this.height)}buildLabels(){const e=this.options.labels||{};let t=Ta(e.generateLabels,[this.chart],this)||[];e.filter&&(t=t.filter(t=>e.filter(t,this.chart.data))),e.sort&&(t=t.sort((t,n)=>e.sort(t,n,this.chart.data))),this.options.reverse&&t.reverse(),this.legendItems=t}fit(){const{options:e,ctx:t}=this;if(!e.display)return void(this.width=this.height=0);const n=e.labels,a=dr(n.font),s=a.size,r=this._computeTitleHeight(),{boxWidth:i,itemHeight:o}=Vc(n,s);let c,l;t.font=a.string,this.isHorizontal()?(c=this.maxWidth,l=this._fitRows(r,s,i,o)+10):(l=this.maxHeight,c=this._fitCols(r,a,i,o)+10),this.width=Math.min(c,e.maxWidth||this.maxWidth),this.height=Math.min(l,e.maxHeight||this.maxHeight)}_fitRows(e,t,n,a){const{ctx:s,maxWidth:r,options:{labels:{padding:i}}}=this,o=this.legendHitBoxes=[],c=this.lineWidths=[0],l=a+i;let u=e;s.textAlign="left",s.textBaseline="middle";let h=-1,d=-l;return this.legendItems.forEach((e,p)=>{const f=n+t/2+s.measureText(e.text).width;(0===p||c[c.length-1]+f+2*i>r)&&(u+=l,c[c.length-(p>0?0:1)]=0,d+=l,h++),o[p]={left:0,top:d,row:h,width:f,height:a},c[c.length-1]+=f+i}),u}_fitCols(e,t,n,a){const{ctx:s,maxHeight:r,options:{labels:{padding:i}}}=this,o=this.legendHitBoxes=[],c=this.columnSizes=[],l=r-e;let u=i,h=0,d=0,p=0,f=0;return this.legendItems.forEach((e,r)=>{const{itemWidth:m,itemHeight:g}=function(e,t,n,a,s){const r=function(e,t,n,a){let s=e.text;s&&"string"!==typeof s&&(s=s.reduce((e,t)=>e.length>t.length?e:t));return t+n.size/2+a.measureText(s).width}(a,e,t,n),i=function(e,t,n){let a=e;"string"!==typeof t.text&&(a=Hc(t,n));return a}(s,a,t.lineHeight);return{itemWidth:r,itemHeight:i}}(n,t,s,e,a);r>0&&d+g+2*i>l&&(u+=h+i,c.push({width:h,height:d}),p+=h+i,f++,h=d=0),o[r]={left:p,top:d,col:f,width:m,height:g},h=Math.max(h,m),d+=g+i}),u+=h,c.push({width:h,height:d}),u}adjustHitBoxes(){if(!this.options.display)return;const e=this._computeTitleHeight(),{legendHitBoxes:t,options:{align:n,labels:{padding:a},rtl:s}}=this,r=Zr(s,this.left,this.width);if(this.isHorizontal()){let s=0,i=ws(n,this.left+a,this.right-this.lineWidths[s]);for(const o of t)s!==o.row&&(s=o.row,i=ws(n,this.left+a,this.right-this.lineWidths[s])),o.top+=this.top+e+a,o.left=r.leftForLtr(r.x(i),o.width),i+=o.width+a}else{let s=0,i=ws(n,this.top+e+a,this.bottom-this.columnSizes[s].height);for(const o of t)o.col!==s&&(s=o.col,i=ws(n,this.top+e+a,this.bottom-this.columnSizes[s].height)),o.top=i,o.left+=this.left+a,o.left=r.leftForLtr(r.x(o.left),o.width),i+=o.height+a}}isHorizontal(){return"top"===this.options.position||"bottom"===this.options.position}draw(){if(this.options.display){const e=this.ctx;Qs(e,this),this._draw(),Zs(e)}}_draw(){const{options:e,columnSizes:t,lineWidths:n,ctx:a}=this,{align:s,labels:r}=e,i=Vs.color,o=Zr(e.rtl,this.left,this.width),c=dr(r.font),{padding:l}=r,u=c.size,h=u/2;let d;this.drawTitle(),a.textAlign=o.textAlign("left"),a.textBaseline="middle",a.lineWidth=.5,a.font=c.string;const{boxWidth:p,boxHeight:f,itemHeight:m}=Vc(r,u),g=this.isHorizontal(),y=this._computeTitleHeight();d=g?{x:ws(s,this.left+l,this.right-n[0]),y:this.top+l+y,line:0}:{x:this.left+l,y:ws(s,this.top+y+l,this.bottom-t[0].height),line:0},Jr(this.ctx,e.textDirection);const b=m+l;this.legendItems.forEach((x,v)=>{a.strokeStyle=x.fontColor,a.fillStyle=x.fontColor;const w=a.measureText(x.text).width,k=o.textAlign(x.textAlign||(x.textAlign=r.textAlign)),S=p+h+w;let C=d.x,I=d.y;o.setWidth(this.width),g?v>0&&C+S+l>this.right&&(I=d.y+=b,d.line++,C=d.x=ws(s,this.left+l,this.right-n[d.line])):v>0&&I+b>this.bottom&&(C=d.x=C+t[d.line].width+l,d.line++,I=d.y=ws(s,this.top+y+l,this.bottom-t[d.line].height));if(function(e,t,n){if(isNaN(p)||p<=0||isNaN(f)||f<0)return;a.save();const s=Ia(n.lineWidth,1);if(a.fillStyle=Ia(n.fillStyle,i),a.lineCap=Ia(n.lineCap,"butt"),a.lineDashOffset=Ia(n.lineDashOffset,0),a.lineJoin=Ia(n.lineJoin,"miter"),a.lineWidth=s,a.strokeStyle=Ia(n.strokeStyle,i),a.setLineDash(Ia(n.lineDash,[])),r.usePointStyle){const i={radius:f*Math.SQRT2/2,pointStyle:n.pointStyle,rotation:n.rotation,borderWidth:s},c=o.xPlus(e,p/2);Xs(a,i,c,t+h,r.pointStyleWidth&&p)}else{const r=t+Math.max((u-f)/2,0),i=o.leftForLtr(e,p),c=ur(n.borderRadius);a.beginPath(),Object.values(c).some(e=>0!==e)?ar(a,{x:i,y:r,w:p,h:f,radius:c}):a.rect(i,r,p,f),a.fill(),0!==s&&a.stroke()}a.restore()}(o.x(C),I,x),C=((e,t,n,a)=>e===(a?"left":"right")?n:"center"===e?(t+n)/2:t)(k,C+p+h,g?C+S:this.right,e.rtl),function(e,t,n){nr(a,n.text,e,t+m/2,c,{strikethrough:n.hidden,textAlign:o.textAlign(n.textAlign)})}(o.x(C),I,x),g)d.x+=S+l;else if("string"!==typeof x.text){const e=c.lineHeight;d.y+=Hc(x,e)+l}else d.y+=b}),$r(this.ctx,e.textDirection)}drawTitle(){const e=this.options,t=e.title,n=dr(t.font),a=hr(t.padding);if(!t.display)return;const s=Zr(e.rtl,this.left,this.width),r=this.ctx,i=t.position,o=n.size/2,c=a.top+o;let l,u=this.left,h=this.width;if(this.isHorizontal())h=Math.max(...this.lineWidths),l=this.top+c,u=ws(e.align,u,this.right-h);else{const t=this.columnSizes.reduce((e,t)=>Math.max(e,t.height),0);l=c+ws(e.align,this.top,this.bottom-t-e.labels.padding-this._computeTitleHeight())}const d=ws(i,u,u+h);r.textAlign=s.textAlign(vs(i)),r.textBaseline="middle",r.strokeStyle=t.color,r.fillStyle=t.color,r.font=n.string,nr(r,t.text,d,l,n)}_computeTitleHeight(){const e=this.options.title,t=dr(e.font),n=hr(e.padding);return e.display?t.lineHeight+n.height:0}_getLegendItemAt(e,t){let n,a,s;if(hs(e,this.left,this.right)&&hs(t,this.top,this.bottom))for(s=this.legendHitBoxes,n=0;n<s.length;++n)if(a=s[n],hs(e,a.left,a.left+a.width)&&hs(t,a.top,a.top+a.height))return this.legendItems[n];return null}handleEvent(e){const t=this.options;if(!function(e,t){if(("mousemove"===e||"mouseout"===e)&&(t.onHover||t.onLeave))return!0;if(t.onClick&&("click"===e||"mouseup"===e))return!0;return!1}(e.type,t))return;const n=this._getLegendItemAt(e.x,e.y);if("mousemove"===e.type||"mouseout"===e.type){const r=this._hoveredItem,i=(s=n,null!==(a=r)&&null!==s&&a.datasetIndex===s.datasetIndex&&a.index===s.index);r&&!i&&Ta(t.onLeave,[e,r,this],this),this._hoveredItem=n,n&&!i&&Ta(t.onHover,[e,n,this],this)}else n&&Ta(t.onClick,[e,n,this],this);var a,s}}function Hc(e,t){return t*(e.text?e.text.length:0)}var Gc={id:"legend",_element:Uc,start(e,t,n){const a=e.legend=new Uc({ctx:e.ctx,options:n,chart:e});ho.configure(e,a,n),ho.addBox(e,a)},stop(e){ho.removeBox(e,e.legend),delete e.legend},beforeUpdate(e,t,n){const a=e.legend;ho.configure(e,a,n),a.options=n},afterUpdate(e){const t=e.legend;t.buildLabels(),t.adjustHitBoxes()},afterEvent(e,t){t.replay||e.legend.handleEvent(t.event)},defaults:{display:!0,position:"top",align:"center",fullSize:!0,reverse:!1,weight:1e3,onClick(e,t,n){const a=t.datasetIndex,s=n.chart;s.isDatasetVisible(a)?(s.hide(a),t.hidden=!0):(s.show(a),t.hidden=!1)},onHover:null,onLeave:null,labels:{color:e=>e.chart.options.color,boxWidth:40,padding:10,generateLabels(e){const t=e.data.datasets,{labels:{usePointStyle:n,pointStyle:a,textAlign:s,color:r,useBorderRadius:i,borderRadius:o}}=e.legend.options;return e._getSortedDatasetMetas().map(e=>{const c=e.controller.getStyle(n?0:void 0),l=hr(c.borderWidth);return{text:t[e.index].label,fillStyle:c.backgroundColor,fontColor:r,hidden:!e.visible,lineCap:c.borderCapStyle,lineDash:c.borderDash,lineDashOffset:c.borderDashOffset,lineJoin:c.borderJoinStyle,lineWidth:(l.width+l.height)/4,strokeStyle:c.borderColor,pointStyle:a||c.pointStyle,rotation:c.rotation,textAlign:s||c.textAlign,borderRadius:i&&(o||c.borderRadius),datasetIndex:e.index}},this)}},title:{color:e=>e.chart.options.color,display:!1,position:"center",text:""}},descriptors:{_scriptable:e=>!e.startsWith("on"),labels:{_scriptable:e=>!["generateLabels","filter","sort"].includes(e)}}};class qc extends _o{constructor(e){super(),this.chart=e.chart,this.options=e.options,this.ctx=e.ctx,this._padding=void 0,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.width=void 0,this.height=void 0,this.position=void 0,this.weight=void 0,this.fullSize=void 0}update(e,t){const n=this.options;if(this.left=0,this.top=0,!n.display)return void(this.width=this.height=this.right=this.bottom=0);this.width=this.right=e,this.height=this.bottom=t;const a=wa(n.text)?n.text.length:1;this._padding=hr(n.padding);const s=a*dr(n.font).lineHeight+this._padding.height;this.isHorizontal()?this.height=s:this.width=s}isHorizontal(){const e=this.options.position;return"top"===e||"bottom"===e}_drawArgs(e){const{top:t,left:n,bottom:a,right:s,options:r}=this,i=r.align;let o,c,l,u=0;return this.isHorizontal()?(c=ws(i,n,s),l=t+e,o=s-n):("left"===r.position?(c=n+e,l=ws(i,a,t),u=-.5*Va):(c=s-e,l=ws(i,t,a),u=.5*Va),o=a-t),{titleX:c,titleY:l,maxWidth:o,rotation:u}}draw(){const e=this.ctx,t=this.options;if(!t.display)return;const n=dr(t.font),a=n.lineHeight/2+this._padding.top,{titleX:s,titleY:r,maxWidth:i,rotation:o}=this._drawArgs(a);nr(e,t.text,0,0,n,{color:t.color,maxWidth:i,rotation:o,textAlign:vs(t.align),textBaseline:"middle",translation:[s,r]})}}var Kc={id:"title",_element:qc,start(e,t,n){!function(e,t){const n=new qc({ctx:e.ctx,options:t,chart:e});ho.configure(e,n,t),ho.addBox(e,n),e.titleBlock=n}(e,n)},stop(e){const t=e.titleBlock;ho.removeBox(e,t),delete e.titleBlock},beforeUpdate(e,t,n){const a=e.titleBlock;ho.configure(e,a,n),a.options=n},defaults:{align:"center",display:!1,font:{weight:"bold"},fullSize:!0,padding:10,position:"top",text:"",weight:2e3},defaultRoutes:{color:"color"},descriptors:{_scriptable:!0,_indexable:!1}};new WeakMap;const Xc={average(e){if(!e.length)return!1;let t,n,a=new Set,s=0,r=0;for(t=0,n=e.length;t<n;++t){const n=e[t].element;if(n&&n.hasValue()){const e=n.tooltipPosition();a.add(e.x),s+=e.y,++r}}if(0===r||0===a.size)return!1;return{x:[...a].reduce((e,t)=>e+t)/a.size,y:s/r}},nearest(e,t){if(!e.length)return!1;let n,a,s,r=t.x,i=t.y,o=Number.POSITIVE_INFINITY;for(n=0,a=e.length;n<a;++n){const a=e[n].element;if(a&&a.hasValue()){const e=is(t,a.getCenterPoint());e<o&&(o=e,s=a)}}if(s){const e=s.tooltipPosition();r=e.x,i=e.y}return{x:r,y:i}}};function Yc(e,t){return t&&(wa(t)?Array.prototype.push.apply(e,t):e.push(t)),e}function Qc(e){return("string"===typeof e||e instanceof String)&&e.indexOf("\n")>-1?e.split("\n"):e}function Zc(e,t){const{element:n,datasetIndex:a,index:s}=t,r=e.getDatasetMeta(a).controller,{label:i,value:o}=r.getLabelAndValue(s);return{chart:e,label:i,parsed:r.getParsed(s),raw:e.data.datasets[a].data[s],formattedValue:o,dataset:r.getDataset(),dataIndex:s,datasetIndex:a,element:n}}function Jc(e,t){const n=e.chart.ctx,{body:a,footer:s,title:r}=e,{boxWidth:i,boxHeight:o}=t,c=dr(t.bodyFont),l=dr(t.titleFont),u=dr(t.footerFont),h=r.length,d=s.length,p=a.length,f=hr(t.padding);let m=f.height,g=0,y=a.reduce((e,t)=>e+t.before.length+t.lines.length+t.after.length,0);if(y+=e.beforeBody.length+e.afterBody.length,h&&(m+=h*l.lineHeight+(h-1)*t.titleSpacing+t.titleMarginBottom),y){m+=p*(t.displayColors?Math.max(o,c.lineHeight):c.lineHeight)+(y-p)*c.lineHeight+(y-1)*t.bodySpacing}d&&(m+=t.footerMarginTop+d*u.lineHeight+(d-1)*t.footerSpacing);let b=0;const x=function(e){g=Math.max(g,n.measureText(e).width+b)};return n.save(),n.font=l.string,Ea(e.title,x),n.font=c.string,Ea(e.beforeBody.concat(e.afterBody),x),b=t.displayColors?i+2+t.boxPadding:0,Ea(a,e=>{Ea(e.before,x),Ea(e.lines,x),Ea(e.after,x)}),b=0,n.font=u.string,Ea(e.footer,x),n.restore(),g+=f.width,{width:g,height:m}}function $c(e,t,n,a){const{x:s,width:r}=n,{width:i,chartArea:{left:o,right:c}}=e;let l="center";return"center"===a?l=s<=(o+c)/2?"left":"right":s<=r/2?l="left":s>=i-r/2&&(l="right"),function(e,t,n,a){const{x:s,width:r}=a,i=n.caretSize+n.caretPadding;return"left"===e&&s+r+i>t.width||"right"===e&&s-r-i<0||void 0}(l,e,t,n)&&(l="center"),l}function el(e,t,n){const a=n.yAlign||t.yAlign||function(e,t){const{y:n,height:a}=t;return n<a/2?"top":n>e.height-a/2?"bottom":"center"}(e,n);return{xAlign:n.xAlign||t.xAlign||$c(e,t,n,a),yAlign:a}}function tl(e,t,n,a){const{caretSize:s,caretPadding:r,cornerRadius:i}=e,{xAlign:o,yAlign:c}=n,l=s+r,{topLeft:u,topRight:h,bottomLeft:d,bottomRight:p}=ur(i);let f=function(e,t){let{x:n,width:a}=e;return"right"===t?n-=a:"center"===t&&(n-=a/2),n}(t,o);const m=function(e,t,n){let{y:a,height:s}=e;return"top"===t?a+=n:a-="bottom"===t?s+n:s/2,a}(t,c,l);return"center"===c?"left"===o?f+=l:"right"===o&&(f-=l):"left"===o?f-=Math.max(u,d)+s:"right"===o&&(f+=Math.max(h,p)+s),{x:us(f,0,a.width-t.width),y:us(m,0,a.height-t.height)}}function nl(e,t,n){const a=hr(n.padding);return"center"===t?e.x+e.width/2:"right"===t?e.x+e.width-a.right:e.x+a.left}function al(e){return Yc([],Qc(e))}function sl(e,t){const n=t&&t.dataset&&t.dataset.tooltip&&t.dataset.tooltip.callbacks;return n?e.override(n):e}const rl={beforeTitle:ba,title(e){if(e.length>0){const t=e[0],n=t.chart.data.labels,a=n?n.length:0;if(this&&this.options&&"dataset"===this.options.mode)return t.dataset.label||"";if(t.label)return t.label;if(a>0&&t.dataIndex<a)return n[t.dataIndex]}return""},afterTitle:ba,beforeBody:ba,beforeLabel:ba,label(e){if(this&&this.options&&"dataset"===this.options.mode)return e.label+": "+e.formattedValue||e.formattedValue;let t=e.dataset.label||"";t&&(t+=": ");const n=e.formattedValue;return va(n)||(t+=n),t},labelColor(e){const t=e.chart.getDatasetMeta(e.datasetIndex).controller.getStyle(e.dataIndex);return{borderColor:t.borderColor,backgroundColor:t.backgroundColor,borderWidth:t.borderWidth,borderDash:t.borderDash,borderDashOffset:t.borderDashOffset,borderRadius:0}},labelTextColor(){return this.options.bodyColor},labelPointStyle(e){const t=e.chart.getDatasetMeta(e.datasetIndex).controller.getStyle(e.dataIndex);return{pointStyle:t.pointStyle,rotation:t.rotation}},afterLabel:ba,afterBody:ba,beforeFooter:ba,footer:ba,afterFooter:ba};function il(e,t,n,a){const s=e[t].call(n,a);return"undefined"===typeof s?rl[t].call(n,a):s}class ol extends _o{constructor(e){super(),this.opacity=0,this._active=[],this._eventPosition=void 0,this._size=void 0,this._cachedAnimations=void 0,this._tooltipItems=[],this.$animations=void 0,this.$context=void 0,this.chart=e.chart,this.options=e.options,this.dataPoints=void 0,this.title=void 0,this.beforeBody=void 0,this.body=void 0,this.afterBody=void 0,this.footer=void 0,this.xAlign=void 0,this.yAlign=void 0,this.x=void 0,this.y=void 0,this.height=void 0,this.width=void 0,this.caretX=void 0,this.caretY=void 0,this.labelColors=void 0,this.labelPointStyles=void 0,this.labelTextColors=void 0}initialize(e){this.options=e,this._cachedAnimations=void 0,this.$context=void 0}_resolveAnimations(){const e=this._cachedAnimations;if(e)return e;const t=this.chart,n=this.options.setContext(this.getContext()),a=n.enabled&&t.options.animation&&n.animations,s=new fi(this.chart,a);return a._cacheable&&(this._cachedAnimations=Object.freeze(s)),s}getContext(){return this.$context||(this.$context=(e=this.chart.getContext(),t=this,n=this._tooltipItems,fr(e,{tooltip:t,tooltipItems:n,type:"tooltip"})));var e,t,n}getTitle(e,t){const{callbacks:n}=t,a=il(n,"beforeTitle",this,e),s=il(n,"title",this,e),r=il(n,"afterTitle",this,e);let i=[];return i=Yc(i,Qc(a)),i=Yc(i,Qc(s)),i=Yc(i,Qc(r)),i}getBeforeBody(e,t){return al(il(t.callbacks,"beforeBody",this,e))}getBody(e,t){const{callbacks:n}=t,a=[];return Ea(e,e=>{const t={before:[],lines:[],after:[]},s=sl(n,e);Yc(t.before,Qc(il(s,"beforeLabel",this,e))),Yc(t.lines,il(s,"label",this,e)),Yc(t.after,Qc(il(s,"afterLabel",this,e))),a.push(t)}),a}getAfterBody(e,t){return al(il(t.callbacks,"afterBody",this,e))}getFooter(e,t){const{callbacks:n}=t,a=il(n,"beforeFooter",this,e),s=il(n,"footer",this,e),r=il(n,"afterFooter",this,e);let i=[];return i=Yc(i,Qc(a)),i=Yc(i,Qc(s)),i=Yc(i,Qc(r)),i}_createItems(e){const t=this._active,n=this.chart.data,a=[],s=[],r=[];let i,o,c=[];for(i=0,o=t.length;i<o;++i)c.push(Zc(this.chart,t[i]));return e.filter&&(c=c.filter((t,a,s)=>e.filter(t,a,s,n))),e.itemSort&&(c=c.sort((t,a)=>e.itemSort(t,a,n))),Ea(c,t=>{const n=sl(e.callbacks,t);a.push(il(n,"labelColor",this,t)),s.push(il(n,"labelPointStyle",this,t)),r.push(il(n,"labelTextColor",this,t))}),this.labelColors=a,this.labelPointStyles=s,this.labelTextColors=r,this.dataPoints=c,c}update(e,t){const n=this.options.setContext(this.getContext()),a=this._active;let s,r=[];if(a.length){const e=Xc[n.position].call(this,a,this._eventPosition);r=this._createItems(n),this.title=this.getTitle(r,n),this.beforeBody=this.getBeforeBody(r,n),this.body=this.getBody(r,n),this.afterBody=this.getAfterBody(r,n),this.footer=this.getFooter(r,n);const t=this._size=Jc(this,n),i=Object.assign({},e,t),o=el(this.chart,n,i),c=tl(n,i,o,this.chart);this.xAlign=o.xAlign,this.yAlign=o.yAlign,s={opacity:1,x:c.x,y:c.y,width:t.width,height:t.height,caretX:e.x,caretY:e.y}}else 0!==this.opacity&&(s={opacity:0});this._tooltipItems=r,this.$context=void 0,s&&this._resolveAnimations().update(this,s),e&&n.external&&n.external.call(this,{chart:this.chart,tooltip:this,replay:t})}drawCaret(e,t,n,a){const s=this.getCaretPosition(e,n,a);t.lineTo(s.x1,s.y1),t.lineTo(s.x2,s.y2),t.lineTo(s.x3,s.y3)}getCaretPosition(e,t,n){const{xAlign:a,yAlign:s}=this,{caretSize:r,cornerRadius:i}=n,{topLeft:o,topRight:c,bottomLeft:l,bottomRight:u}=ur(i),{x:h,y:d}=e,{width:p,height:f}=t;let m,g,y,b,x,v;return"center"===s?(x=d+f/2,"left"===a?(m=h,g=m-r,b=x+r,v=x-r):(m=h+p,g=m+r,b=x-r,v=x+r),y=m):(g="left"===a?h+Math.max(o,l)+r:"right"===a?h+p-Math.max(c,u)-r:this.caretX,"top"===s?(b=d,x=b-r,m=g-r,y=g+r):(b=d+f,x=b+r,m=g+r,y=g-r),v=b),{x1:m,x2:g,x3:y,y1:b,y2:x,y3:v}}drawTitle(e,t,n){const a=this.title,s=a.length;let r,i,o;if(s){const c=Zr(n.rtl,this.x,this.width);for(e.x=nl(this,n.titleAlign,n),t.textAlign=c.textAlign(n.titleAlign),t.textBaseline="middle",r=dr(n.titleFont),i=n.titleSpacing,t.fillStyle=n.titleColor,t.font=r.string,o=0;o<s;++o)t.fillText(a[o],c.x(e.x),e.y+r.lineHeight/2),e.y+=r.lineHeight+i,o+1===s&&(e.y+=n.titleMarginBottom-i)}}_drawColorBox(e,t,n,a,s){const r=this.labelColors[n],i=this.labelPointStyles[n],{boxHeight:o,boxWidth:c}=s,l=dr(s.bodyFont),u=nl(this,"left",s),h=a.x(u),d=o<l.lineHeight?(l.lineHeight-o)/2:0,p=t.y+d;if(s.usePointStyle){const t={radius:Math.min(c,o)/2,pointStyle:i.pointStyle,rotation:i.rotation,borderWidth:1},n=a.leftForLtr(h,c)+c/2,l=p+o/2;e.strokeStyle=s.multiKeyBackground,e.fillStyle=s.multiKeyBackground,Ks(e,t,n,l),e.strokeStyle=r.borderColor,e.fillStyle=r.backgroundColor,Ks(e,t,n,l)}else{e.lineWidth=ka(r.borderWidth)?Math.max(...Object.values(r.borderWidth)):r.borderWidth||1,e.strokeStyle=r.borderColor,e.setLineDash(r.borderDash||[]),e.lineDashOffset=r.borderDashOffset||0;const t=a.leftForLtr(h,c),n=a.leftForLtr(a.xPlus(h,1),c-2),i=ur(r.borderRadius);Object.values(i).some(e=>0!==e)?(e.beginPath(),e.fillStyle=s.multiKeyBackground,ar(e,{x:t,y:p,w:c,h:o,radius:i}),e.fill(),e.stroke(),e.fillStyle=r.backgroundColor,e.beginPath(),ar(e,{x:n,y:p+1,w:c-2,h:o-2,radius:i}),e.fill()):(e.fillStyle=s.multiKeyBackground,e.fillRect(t,p,c,o),e.strokeRect(t,p,c,o),e.fillStyle=r.backgroundColor,e.fillRect(n,p+1,c-2,o-2))}e.fillStyle=this.labelTextColors[n]}drawBody(e,t,n){const{body:a}=this,{bodySpacing:s,bodyAlign:r,displayColors:i,boxHeight:o,boxWidth:c,boxPadding:l}=n,u=dr(n.bodyFont);let h=u.lineHeight,d=0;const p=Zr(n.rtl,this.x,this.width),f=function(n){t.fillText(n,p.x(e.x+d),e.y+h/2),e.y+=h+s},m=p.textAlign(r);let g,y,b,x,v,w,k;for(t.textAlign=r,t.textBaseline="middle",t.font=u.string,e.x=nl(this,m,n),t.fillStyle=n.bodyColor,Ea(this.beforeBody,f),d=i&&"right"!==m?"center"===r?c/2+l:c+2+l:0,x=0,w=a.length;x<w;++x){for(g=a[x],y=this.labelTextColors[x],t.fillStyle=y,Ea(g.before,f),b=g.lines,i&&b.length&&(this._drawColorBox(t,e,x,p,n),h=Math.max(u.lineHeight,o)),v=0,k=b.length;v<k;++v)f(b[v]),h=u.lineHeight;Ea(g.after,f)}d=0,h=u.lineHeight,Ea(this.afterBody,f),e.y-=s}drawFooter(e,t,n){const a=this.footer,s=a.length;let r,i;if(s){const o=Zr(n.rtl,this.x,this.width);for(e.x=nl(this,n.footerAlign,n),e.y+=n.footerMarginTop,t.textAlign=o.textAlign(n.footerAlign),t.textBaseline="middle",r=dr(n.footerFont),t.fillStyle=n.footerColor,t.font=r.string,i=0;i<s;++i)t.fillText(a[i],o.x(e.x),e.y+r.lineHeight/2),e.y+=r.lineHeight+n.footerSpacing}}drawBackground(e,t,n,a){const{xAlign:s,yAlign:r}=this,{x:i,y:o}=e,{width:c,height:l}=n,{topLeft:u,topRight:h,bottomLeft:d,bottomRight:p}=ur(a.cornerRadius);t.fillStyle=a.backgroundColor,t.strokeStyle=a.borderColor,t.lineWidth=a.borderWidth,t.beginPath(),t.moveTo(i+u,o),"top"===r&&this.drawCaret(e,t,n,a),t.lineTo(i+c-h,o),t.quadraticCurveTo(i+c,o,i+c,o+h),"center"===r&&"right"===s&&this.drawCaret(e,t,n,a),t.lineTo(i+c,o+l-p),t.quadraticCurveTo(i+c,o+l,i+c-p,o+l),"bottom"===r&&this.drawCaret(e,t,n,a),t.lineTo(i+d,o+l),t.quadraticCurveTo(i,o+l,i,o+l-d),"center"===r&&"left"===s&&this.drawCaret(e,t,n,a),t.lineTo(i,o+u),t.quadraticCurveTo(i,o,i+u,o),t.closePath(),t.fill(),a.borderWidth>0&&t.stroke()}_updateAnimationTarget(e){const t=this.chart,n=this.$animations,a=n&&n.x,s=n&&n.y;if(a||s){const n=Xc[e.position].call(this,this._active,this._eventPosition);if(!n)return;const r=this._size=Jc(this,e),i=Object.assign({},n,this._size),o=el(t,e,i),c=tl(e,i,o,t);a._to===c.x&&s._to===c.y||(this.xAlign=o.xAlign,this.yAlign=o.yAlign,this.width=r.width,this.height=r.height,this.caretX=n.x,this.caretY=n.y,this._resolveAnimations().update(this,c))}}_willRender(){return!!this.opacity}draw(e){const t=this.options.setContext(this.getContext());let n=this.opacity;if(!n)return;this._updateAnimationTarget(t);const a={width:this.width,height:this.height},s={x:this.x,y:this.y};n=Math.abs(n)<.001?0:n;const r=hr(t.padding),i=this.title.length||this.beforeBody.length||this.body.length||this.afterBody.length||this.footer.length;t.enabled&&i&&(e.save(),e.globalAlpha=n,this.drawBackground(s,e,a,t),Jr(e,t.textDirection),s.y+=r.top,this.drawTitle(s,e,t),this.drawBody(s,e,t),this.drawFooter(s,e,t),$r(e,t.textDirection),e.restore())}getActiveElements(){return this._active||[]}setActiveElements(e,t){const n=this._active,a=e.map(e=>{let{datasetIndex:t,index:n}=e;const a=this.chart.getDatasetMeta(t);if(!a)throw new Error("Cannot find a dataset at index "+t);return{datasetIndex:t,element:a.data[n],index:n}}),s=!Ra(n,a),r=this._positionChanged(a,t);(s||r)&&(this._active=a,this._eventPosition=t,this._ignoreReplayEvents=!0,this.update(!0))}handleEvent(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(t&&this._ignoreReplayEvents)return!1;this._ignoreReplayEvents=!1;const a=this.options,s=this._active||[],r=this._getActiveElements(e,s,t,n),i=this._positionChanged(r,e),o=t||!Ra(r,s)||i;return o&&(this._active=r,(a.enabled||a.external)&&(this._eventPosition={x:e.x,y:e.y},this.update(!0,t))),o}_getActiveElements(e,t,n,a){const s=this.options;if("mouseout"===e.type)return[];if(!a)return t.filter(e=>this.chart.data.datasets[e.datasetIndex]&&void 0!==this.chart.getDatasetMeta(e.datasetIndex).controller.getParsed(e.index));const r=this.chart.getElementsAtEventForMode(e,s.mode,s,n);return s.reverse&&r.reverse(),r}_positionChanged(e,t){const{caretX:n,caretY:a,options:s}=this,r=Xc[s.position].call(this,e,t);return!1!==r&&(n!==r.x||a!==r.y)}}Fn(ol,"positioners",Xc);var cl={id:"tooltip",_element:ol,positioners:Xc,afterInit(e,t,n){n&&(e.tooltip=new ol({chart:e,options:n}))},beforeUpdate(e,t,n){e.tooltip&&e.tooltip.initialize(n)},reset(e,t,n){e.tooltip&&e.tooltip.initialize(n)},afterDraw(e){const t=e.tooltip;if(t&&t._willRender()){const n={tooltip:t};if(!1===e.notifyPlugins("beforeTooltipDraw",zn(zn({},n),{},{cancelable:!0})))return;t.draw(e.ctx),e.notifyPlugins("afterTooltipDraw",n)}},afterEvent(e,t){if(e.tooltip){const n=t.replay;e.tooltip.handleEvent(t.event,n,t.inChartArea)&&(t.changed=!0)}},defaults:{enabled:!0,external:null,position:"average",backgroundColor:"rgba(0,0,0,0.8)",titleColor:"#fff",titleFont:{weight:"bold"},titleSpacing:2,titleMarginBottom:6,titleAlign:"left",bodyColor:"#fff",bodySpacing:2,bodyFont:{},bodyAlign:"left",footerColor:"#fff",footerSpacing:2,footerMarginTop:6,footerFont:{weight:"bold"},footerAlign:"left",padding:6,caretPadding:2,caretSize:5,cornerRadius:6,boxHeight:(e,t)=>t.bodyFont.size,boxWidth:(e,t)=>t.bodyFont.size,multiKeyBackground:"#fff",displayColors:!0,boxPadding:0,borderColor:"rgba(0,0,0,0)",borderWidth:0,animation:{duration:400,easing:"easeOutQuart"},animations:{numbers:{type:"number",properties:["x","y","width","height","caretX","caretY"]},opacity:{easing:"linear",duration:200}},callbacks:rl},defaultRoutes:{bodyFont:"font",footerFont:"font",titleFont:"font"},descriptors:{_scriptable:e=>"filter"!==e&&"itemSort"!==e&&"external"!==e,_indexable:!1,callbacks:{_scriptable:!1,_indexable:!1},animation:{_fallback:!1},animations:{_fallback:"animation"}},additionalOptionScopes:["interaction"]};function ll(e,t,n,a){const s=e.indexOf(t);if(-1===s)return((e,t,n,a)=>("string"===typeof t?(n=e.push(t)-1,a.unshift({index:n,label:t})):isNaN(t)&&(n=null),n))(e,t,n,a);return s!==e.lastIndexOf(t)?n:s}function ul(e){const t=this.getLabels();return e>=0&&e<t.length?t[e]:e}class hl extends jo{constructor(e){super(e),this._startValue=void 0,this._valueRange=0,this._addedLabels=[]}init(e){const t=this._addedLabels;if(t.length){const e=this.getLabels();for(const{index:n,label:a}of t)e[n]===a&&e.splice(n,1);this._addedLabels=[]}super.init(e)}parse(e,t){if(va(e))return null;const n=this.getLabels();return((e,t)=>null===e?null:us(Math.round(e),0,t))(t=isFinite(t)&&n[t]===e?t:ll(n,e,Ia(t,e),this._addedLabels),n.length-1)}determineDataLimits(){const{minDefined:e,maxDefined:t}=this.getUserBounds();let{min:n,max:a}=this.getMinMax(!0);"ticks"===this.options.bounds&&(e||(n=0),t||(a=this.getLabels().length-1)),this.min=n,this.max=a}buildTicks(){const e=this.min,t=this.max,n=this.options.offset,a=[];let s=this.getLabels();s=0===e&&t===s.length-1?s:s.slice(e,t+1),this._valueRange=Math.max(s.length-(n?0:1),1),this._startValue=this.min-(n?.5:0);for(let r=e;r<=t;r++)a.push({value:r});return a}getLabelForValue(e){return ul.call(this,e)}configure(){super.configure(),this.isHorizontal()||(this._reversePixels=!this._reversePixels)}getPixelForValue(e){return"number"!==typeof e&&(e=this.parse(e)),null===e?NaN:this.getPixelForDecimal((e-this._startValue)/this._valueRange)}getPixelForTick(e){const t=this.ticks;return e<0||e>t.length-1?null:this.getPixelForValue(t[e].value)}getValueForPixel(e){return Math.round(this._startValue+this.getDecimalForPixel(e)*this._valueRange)}getBasePixel(){return this.bottom}}function dl(e,t){const n=[],{bounds:a,step:s,min:r,max:i,precision:o,count:c,maxTicks:l,maxDigits:u,includeBounds:h}=e,d=s||1,p=l-1,{min:f,max:m}=t,g=!va(r),y=!va(i),b=!va(c),x=(m-f)/(u+1);let v,w,k,S,C=$a((m-f)/p/d)*d;if(C<1e-14&&!g&&!y)return[{value:f},{value:m}];S=Math.ceil(m/C)-Math.floor(f/C),S>p&&(C=$a(S*C/p/d)*d),va(o)||(v=Math.pow(10,o),C=Math.ceil(C*v)/v),"ticks"===a?(w=Math.floor(f/C)*C,k=Math.ceil(m/C)*C):(w=f,k=m),g&&y&&s&&function(e,t){const n=Math.round(e);return n-t<=e&&n+t>=e}((i-r)/s,C/1e3)?(S=Math.round(Math.min((i-r)/C,l)),C=(i-r)/S,w=r,k=i):b?(w=g?r:w,k=y?i:k,S=c-1,C=(k-w)/S):(S=(k-w)/C,S=Ja(S,Math.round(S),C/1e3)?Math.round(S):Math.ceil(S));const I=Math.max(ss(C),ss(w));v=Math.pow(10,va(o)?I:o),w=Math.round(w*v)/v,k=Math.round(k*v)/v;let N=0;for(g&&(h&&w!==r?(n.push({value:r}),w<r&&N++,Ja(Math.round((w+N*C)*v)/v,r,pl(r,x,e))&&N++):w<r&&N++);N<S;++N){const e=Math.round((w+N*C)*v)/v;if(y&&e>i)break;n.push({value:e})}return y&&h&&k!==i?n.length&&Ja(n[n.length-1].value,i,pl(i,x,e))?n[n.length-1].value=i:n.push({value:i}):y&&k!==i||n.push({value:k}),n}function pl(e,t,n){let{horizontal:a,minRotation:s}=n;const r=ns(s),i=(a?Math.sin(r):Math.cos(r))||.001,o=.75*t*(""+e).length;return Math.min(t/i,o)}Fn(hl,"id","category"),Fn(hl,"defaults",{ticks:{callback:ul}});class fl extends jo{constructor(e){super(e),this.start=void 0,this.end=void 0,this._startValue=void 0,this._endValue=void 0,this._valueRange=0}parse(e,t){return va(e)||("number"===typeof e||e instanceof Number)&&!isFinite(+e)?null:+e}handleTickRangeOptions(){const{beginAtZero:e}=this.options,{minDefined:t,maxDefined:n}=this.getUserBounds();let{min:a,max:s}=this;const r=e=>a=t?a:e,i=e=>s=n?s:e;if(e){const e=Za(a),t=Za(s);e<0&&t<0?i(0):e>0&&t>0&&r(0)}if(a===s){let t=0===s?1:Math.abs(.05*s);i(s+t),e||r(a-t)}this.min=a,this.max=s}getTickLimit(){const e=this.options.ticks;let t,{maxTicksLimit:n,stepSize:a}=e;return a?(t=Math.ceil(this.max/a)-Math.floor(this.min/a)+1,t>1e3&&(console.warn("scales.".concat(this.id,".ticks.stepSize: ").concat(a," would result generating up to ").concat(t," ticks. Limiting to 1000.")),t=1e3)):(t=this.computeTickLimit(),n=n||11),n&&(t=Math.min(n,t)),t}computeTickLimit(){return Number.POSITIVE_INFINITY}buildTicks(){const e=this.options,t=e.ticks;let n=this.getTickLimit();n=Math.max(2,n);const a=dl({maxTicks:n,bounds:e.bounds,min:e.min,max:e.max,precision:t.precision,step:t.stepSize,count:t.count,maxDigits:this._maxDigits(),horizontal:this.isHorizontal(),minRotation:t.minRotation||0,includeBounds:!1!==t.includeBounds},this._range||this);return"ticks"===e.bounds&&ts(a,this,"value"),e.reverse?(a.reverse(),this.start=this.max,this.end=this.min):(this.start=this.min,this.end=this.max),a}configure(){const e=this.ticks;let t=this.min,n=this.max;if(super.configure(),this.options.offset&&e.length){const a=(n-t)/Math.max(e.length-1,1)/2;t-=a,n+=a}this._startValue=t,this._endValue=n,this._valueRange=n-t}getLabelForValue(e){return Ds(e,this.chart.options.locale,this.options.ticks.format)}}class ml extends fl{determineDataLimits(){const{min:e,max:t}=this.getMinMax(!0);this.min=Sa(e)?e:0,this.max=Sa(t)?t:1,this.handleTickRangeOptions()}computeTickLimit(){const e=this.isHorizontal(),t=e?this.width:this.height,n=ns(this.options.ticks.minRotation),a=(e?Math.sin(n):Math.cos(n))||.001,s=this._resolveTickFontOptions(0);return Math.ceil(t/Math.min(40,s.lineHeight/a))}getPixelForValue(e){return null===e?NaN:this.getPixelForDecimal((e-this._startValue)/this._valueRange)}getValueForPixel(e){return this._startValue+this.getDecimalForPixel(e)*this._valueRange}}Fn(ml,"id","linear"),Fn(ml,"defaults",{ticks:{callback:Fs.formatters.numeric}});const gl=e=>Math.floor(Qa(e)),yl=(e,t)=>Math.pow(10,gl(e)+t);function bl(e){return 1===e/Math.pow(10,gl(e))}function xl(e,t,n){const a=Math.pow(10,n),s=Math.floor(e/a);return Math.ceil(t/a)-s}function vl(e,t){let{min:n,max:a}=t;n=Ca(e.min,n);const s=[],r=gl(n);let i=function(e,t){let n=gl(t-e);for(;xl(e,t,n)>10;)n++;for(;xl(e,t,n)<10;)n--;return Math.min(n,gl(e))}(n,a),o=i<0?Math.pow(10,Math.abs(i)):1;const c=Math.pow(10,i),l=r>i?Math.pow(10,r):0,u=Math.round((n-l)*o)/o,h=Math.floor((n-l)/c/10)*c*10;let d=Math.floor((u-h)/Math.pow(10,i)),p=Ca(e.min,Math.round((l+h+d*Math.pow(10,i))*o)/o);for(;p<a;)s.push({value:p,major:bl(p),significand:d}),d>=10?d=d<15?15:20:d++,d>=20&&(i++,d=2,o=i>=0?1:o),p=Math.round((l+h+d*Math.pow(10,i))*o)/o;const f=Ca(e.max,p);return s.push({value:f,major:bl(f),significand:d}),s}class wl extends jo{constructor(e){super(e),this.start=void 0,this.end=void 0,this._startValue=void 0,this._valueRange=0}parse(e,t){const n=fl.prototype.parse.apply(this,[e,t]);if(0!==n)return Sa(n)&&n>0?n:null;this._zero=!0}determineDataLimits(){const{min:e,max:t}=this.getMinMax(!0);this.min=Sa(e)?Math.max(0,e):null,this.max=Sa(t)?Math.max(0,t):null,this.options.beginAtZero&&(this._zero=!0),this._zero&&this.min!==this._suggestedMin&&!Sa(this._userMin)&&(this.min=e===yl(this.min,0)?yl(this.min,-1):yl(this.min,0)),this.handleTickRangeOptions()}handleTickRangeOptions(){const{minDefined:e,maxDefined:t}=this.getUserBounds();let n=this.min,a=this.max;const s=t=>n=e?n:t,r=e=>a=t?a:e;n===a&&(n<=0?(s(1),r(10)):(s(yl(n,-1)),r(yl(a,1)))),n<=0&&s(yl(a,-1)),a<=0&&r(yl(n,1)),this.min=n,this.max=a}buildTicks(){const e=this.options,t=vl({min:this._userMin,max:this._userMax},this);return"ticks"===e.bounds&&ts(t,this,"value"),e.reverse?(t.reverse(),this.start=this.max,this.end=this.min):(this.start=this.min,this.end=this.max),t}getLabelForValue(e){return void 0===e?"0":Ds(e,this.chart.options.locale,this.options.ticks.format)}configure(){const e=this.min;super.configure(),this._startValue=Qa(e),this._valueRange=Qa(this.max)-Qa(e)}getPixelForValue(e){return void 0!==e&&0!==e||(e=this.min),null===e||isNaN(e)?NaN:this.getPixelForDecimal(e===this.min?0:(Qa(e)-this._startValue)/this._valueRange)}getValueForPixel(e){const t=this.getDecimalForPixel(e);return Math.pow(10,this._startValue+t*this._valueRange)}}function kl(e){const t=e.ticks;if(t.display&&e.display){const e=hr(t.backdropPadding);return Ia(t.font&&t.font.size,Vs.font.size)+e.height}return 0}function Sl(e,t,n){return n=wa(n)?n:[n],{w:Hs(e,t.string,n),h:n.length*t.lineHeight}}function Cl(e,t,n,a,s){return e===a||e===s?{start:t-n/2,end:t+n/2}:e<a||e>s?{start:t-n,end:t}:{start:t,end:t+n}}function Il(e){const t={l:e.left+e._padding.left,r:e.right-e._padding.right,t:e.top+e._padding.top,b:e.bottom-e._padding.bottom},n=Object.assign({},t),a=[],s=[],r=e._pointLabels.length,i=e.options.pointLabels,o=i.centerPointLabels?Va/r:0;for(let c=0;c<r;c++){const r=i.setContext(e.getPointLabelContext(c));s[c]=r.padding;const l=e.getPointPosition(c,e.drawingArea+s[c],o),u=dr(r.font),h=Sl(e.ctx,u,e._pointLabels[c]);a[c]=h;const d=cs(e.getIndexAngle(c)+o),p=Math.round(as(d));Nl(n,t,d,Cl(p,l.x,h.w,0,180),Cl(p,l.y,h.h,90,270))}e.setCenterPoint(t.l-n.l,n.r-t.r,t.t-n.t,n.b-t.b),e._pointLabelItems=function(e,t,n){const a=[],s=e._pointLabels.length,r=e.options,{centerPointLabels:i,display:o}=r.pointLabels,c={extra:kl(r)/2,additionalAngle:i?Va/s:0};let l;for(let u=0;u<s;u++){c.padding=n[u],c.size=t[u];const s=Tl(e,u,c);a.push(s),"auto"===o&&(s.visible=El(s,l),s.visible&&(l=s))}return a}(e,a,s)}function Nl(e,t,n,a,s){const r=Math.abs(Math.sin(n)),i=Math.abs(Math.cos(n));let o=0,c=0;a.start<t.l?(o=(t.l-a.start)/r,e.l=Math.min(e.l,t.l-o)):a.end>t.r&&(o=(a.end-t.r)/r,e.r=Math.max(e.r,t.r+o)),s.start<t.t?(c=(t.t-s.start)/i,e.t=Math.min(e.t,t.t-c)):s.end>t.b&&(c=(s.end-t.b)/i,e.b=Math.max(e.b,t.b+c))}function Tl(e,t,n){const a=e.drawingArea,{extra:s,additionalAngle:r,padding:i,size:o}=n,c=e.getPointPosition(t,a+s+i,r),l=Math.round(as(cs(c.angle+Ka))),u=function(e,t,n){90===n||270===n?e-=t/2:(n>270||n<90)&&(e-=t);return e}(c.y,o.h,l),h=function(e){if(0===e||180===e)return"center";if(e<180)return"left";return"right"}(l),d=function(e,t,n){"right"===n?e-=t:"center"===n&&(e-=t/2);return e}(c.x,o.w,h);return{visible:!0,x:c.x,y:u,textAlign:h,left:d,top:u,right:d+o.w,bottom:u+o.h}}function El(e,t){if(!t)return!0;const{left:n,top:a,right:s,bottom:r}=e;return!(Ys({x:n,y:a},t)||Ys({x:n,y:r},t)||Ys({x:s,y:a},t)||Ys({x:s,y:r},t))}function Rl(e,t,n){const{left:a,top:s,right:r,bottom:i}=n,{backdropColor:o}=t;if(!va(o)){const n=ur(t.borderRadius),c=hr(t.backdropPadding);e.fillStyle=o;const l=a-c.left,u=s-c.top,h=r-a+c.width,d=i-s+c.height;Object.values(n).some(e=>0!==e)?(e.beginPath(),ar(e,{x:l,y:u,w:h,h:d,radius:n}),e.fill()):e.fillRect(l,u,h,d)}}function _l(e,t,n,a){const{ctx:s}=e;if(n)s.arc(e.xCenter,e.yCenter,t,0,Ua);else{let n=e.getPointPosition(0,t);s.moveTo(n.x,n.y);for(let r=1;r<a;r++)n=e.getPointPosition(r,t),s.lineTo(n.x,n.y)}}Fn(wl,"id","logarithmic"),Fn(wl,"defaults",{ticks:{callback:Fs.formatters.logarithmic,major:{enabled:!0}}});class Al extends fl{constructor(e){super(e),this.xCenter=void 0,this.yCenter=void 0,this.drawingArea=void 0,this._pointLabels=[],this._pointLabelItems=[]}setDimensions(){const e=this._padding=hr(kl(this.options)/2),t=this.width=this.maxWidth-e.width,n=this.height=this.maxHeight-e.height;this.xCenter=Math.floor(this.left+t/2+e.left),this.yCenter=Math.floor(this.top+n/2+e.top),this.drawingArea=Math.floor(Math.min(t,n)/2)}determineDataLimits(){const{min:e,max:t}=this.getMinMax(!1);this.min=Sa(e)&&!isNaN(e)?e:0,this.max=Sa(t)&&!isNaN(t)?t:0,this.handleTickRangeOptions()}computeTickLimit(){return Math.ceil(this.drawingArea/kl(this.options))}generateTickLabels(e){fl.prototype.generateTickLabels.call(this,e),this._pointLabels=this.getLabels().map((e,t)=>{const n=Ta(this.options.pointLabels.callback,[e,t],this);return n||0===n?n:""}).filter((e,t)=>this.chart.getDataVisibility(t))}fit(){const e=this.options;e.display&&e.pointLabels.display?Il(this):this.setCenterPoint(0,0,0,0)}setCenterPoint(e,t,n,a){this.xCenter+=Math.floor((e-t)/2),this.yCenter+=Math.floor((n-a)/2),this.drawingArea-=Math.min(this.drawingArea/2,Math.max(e,t,n,a))}getIndexAngle(e){return cs(e*(Ua/(this._pointLabels.length||1))+ns(this.options.startAngle||0))}getDistanceFromCenterForValue(e){if(va(e))return NaN;const t=this.drawingArea/(this.max-this.min);return this.options.reverse?(this.max-e)*t:(e-this.min)*t}getValueForDistanceFromCenter(e){if(va(e))return NaN;const t=e/(this.drawingArea/(this.max-this.min));return this.options.reverse?this.max-t:this.min+t}getPointLabelContext(e){const t=this._pointLabels||[];if(e>=0&&e<t.length){const n=t[e];return function(e,t,n){return fr(e,{label:n,index:t,type:"pointLabel"})}(this.getContext(),e,n)}}getPointPosition(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const a=this.getIndexAngle(e)-Ka+n;return{x:Math.cos(a)*t+this.xCenter,y:Math.sin(a)*t+this.yCenter,angle:a}}getPointPositionForValue(e,t){return this.getPointPosition(e,this.getDistanceFromCenterForValue(t))}getBasePosition(e){return this.getPointPositionForValue(e||0,this.getBaseValue())}getPointLabelPosition(e){const{left:t,top:n,right:a,bottom:s}=this._pointLabelItems[e];return{left:t,top:n,right:a,bottom:s}}drawBackground(){const{backgroundColor:e,grid:{circular:t}}=this.options;if(e){const n=this.ctx;n.save(),n.beginPath(),_l(this,this.getDistanceFromCenterForValue(this._endValue),t,this._pointLabels.length),n.closePath(),n.fillStyle=e,n.fill(),n.restore()}}drawGrid(){const e=this.ctx,t=this.options,{angleLines:n,grid:a,border:s}=t,r=this._pointLabels.length;let i,o,c;if(t.pointLabels.display&&function(e,t){const{ctx:n,options:{pointLabels:a}}=e;for(let s=t-1;s>=0;s--){const t=e._pointLabelItems[s];if(!t.visible)continue;const r=a.setContext(e.getPointLabelContext(s));Rl(n,r,t);const i=dr(r.font),{x:o,y:c,textAlign:l}=t;nr(n,e._pointLabels[s],o,c+i.lineHeight/2,i,{color:r.color,textAlign:l,textBaseline:"middle"})}}(this,r),a.display&&this.ticks.forEach((e,t)=>{if(0!==t||0===t&&this.min<0){o=this.getDistanceFromCenterForValue(e.value);const n=this.getContext(t),i=a.setContext(n),c=s.setContext(n);!function(e,t,n,a,s){const r=e.ctx,i=t.circular,{color:o,lineWidth:c}=t;!i&&!a||!o||!c||n<0||(r.save(),r.strokeStyle=o,r.lineWidth=c,r.setLineDash(s.dash||[]),r.lineDashOffset=s.dashOffset,r.beginPath(),_l(e,n,i,a),r.closePath(),r.stroke(),r.restore())}(this,i,o,r,c)}}),n.display){for(e.save(),i=r-1;i>=0;i--){const a=n.setContext(this.getPointLabelContext(i)),{color:s,lineWidth:r}=a;r&&s&&(e.lineWidth=r,e.strokeStyle=s,e.setLineDash(a.borderDash),e.lineDashOffset=a.borderDashOffset,o=this.getDistanceFromCenterForValue(t.reverse?this.min:this.max),c=this.getPointPosition(i,o),e.beginPath(),e.moveTo(this.xCenter,this.yCenter),e.lineTo(c.x,c.y),e.stroke())}e.restore()}}drawBorder(){}drawLabels(){const e=this.ctx,t=this.options,n=t.ticks;if(!n.display)return;const a=this.getIndexAngle(0);let s,r;e.save(),e.translate(this.xCenter,this.yCenter),e.rotate(a),e.textAlign="center",e.textBaseline="middle",this.ticks.forEach((a,i)=>{if(0===i&&this.min>=0&&!t.reverse)return;const o=n.setContext(this.getContext(i)),c=dr(o.font);if(s=this.getDistanceFromCenterForValue(this.ticks[i].value),o.showLabelBackdrop){e.font=c.string,r=e.measureText(a.label).width,e.fillStyle=o.backdropColor;const t=hr(o.backdropPadding);e.fillRect(-r/2-t.left,-s-c.size/2-t.top,r+t.width,c.size+t.height)}nr(e,a.label,0,-s,c,{color:o.color,strokeColor:o.textStrokeColor,strokeWidth:o.textStrokeWidth})}),e.restore()}drawTitle(){}}Fn(Al,"id","radialLinear"),Fn(Al,"defaults",{display:!0,animate:!0,position:"chartArea",angleLines:{display:!0,lineWidth:1,borderDash:[],borderDashOffset:0},grid:{circular:!1},startAngle:0,ticks:{showLabelBackdrop:!0,callback:Fs.formatters.numeric},pointLabels:{backdropColor:void 0,backdropPadding:2,display:!0,font:{size:10},callback:e=>e,padding:5,centerPointLabels:!1}}),Fn(Al,"defaultRoutes",{"angleLines.color":"borderColor","pointLabels.color":"color","ticks.color":"color"}),Fn(Al,"descriptors",{angleLines:{_fallback:"grid"}});const Ml={millisecond:{common:!0,size:1,steps:1e3},second:{common:!0,size:1e3,steps:60},minute:{common:!0,size:6e4,steps:60},hour:{common:!0,size:36e5,steps:24},day:{common:!0,size:864e5,steps:30},week:{common:!1,size:6048e5,steps:4},month:{common:!0,size:2628e6,steps:12},quarter:{common:!1,size:7884e6,steps:4},year:{common:!0,size:3154e7}},Pl=Object.keys(Ml);function Dl(e,t){return e-t}function Ol(e,t){if(va(t))return null;const n=e._adapter,{parser:a,round:s,isoWeekday:r}=e._parseOpts;let i=t;return"function"===typeof a&&(i=a(i)),Sa(i)||(i="string"===typeof a?n.parse(i,a):n.parse(i)),null===i?null:(s&&(i="week"!==s||!es(r)&&!0!==r?n.startOf(i,s):n.startOf(i,"isoWeek",r)),+i)}function Fl(e,t,n,a){const s=Pl.length;for(let r=Pl.indexOf(e);r<s-1;++r){const e=Ml[Pl[r]],s=e.steps?e.steps:Number.MAX_SAFE_INTEGER;if(e.common&&Math.ceil((n-t)/(s*e.size))<=a)return Pl[r]}return Pl[s-1]}function Ll(e,t,n){if(n){if(n.length){const{lo:a,hi:s}=ds(n,t);e[n[a]>=t?n[a]:n[s]]=!0}}else e[t]=!0}function zl(e,t,n){const a=[],s={},r=t.length;let i,o;for(i=0;i<r;++i)o=t[i],s[o]=i,a.push({value:o,major:!1});return 0!==r&&n?function(e,t,n,a){const s=e._adapter,r=+s.startOf(t[0].value,a),i=t[t.length-1].value;let o,c;for(o=r;o<=i;o=+s.add(o,1,a))c=n[o],c>=0&&(t[c].major=!0);return t}(e,a,s,n):a}class Bl extends jo{constructor(e){super(e),this._cache={data:[],labels:[],all:[]},this._unit="day",this._majorUnit=void 0,this._offsets={},this._normalized=!1,this._parseOpts=void 0}init(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=e.time||(e.time={}),a=this._adapter=new Gi(e.adapters.date);a.init(t),Da(n.displayFormats,a.formats()),this._parseOpts={parser:n.parser,round:n.round,isoWeekday:n.isoWeekday},super.init(e),this._normalized=t.normalized}parse(e,t){return void 0===e?null:Ol(this,e)}beforeLayout(){super.beforeLayout(),this._cache={data:[],labels:[],all:[]}}determineDataLimits(){const e=this.options,t=this._adapter,n=e.time.unit||"day";let{min:a,max:s,minDefined:r,maxDefined:i}=this.getUserBounds();function o(e){r||isNaN(e.min)||(a=Math.min(a,e.min)),i||isNaN(e.max)||(s=Math.max(s,e.max))}r&&i||(o(this._getLabelBounds()),"ticks"===e.bounds&&"labels"===e.ticks.source||o(this.getMinMax(!1))),a=Sa(a)&&!isNaN(a)?a:+t.startOf(Date.now(),n),s=Sa(s)&&!isNaN(s)?s:+t.endOf(Date.now(),n)+1,this.min=Math.min(a,s-1),this.max=Math.max(a+1,s)}_getLabelBounds(){const e=this.getLabelTimestamps();let t=Number.POSITIVE_INFINITY,n=Number.NEGATIVE_INFINITY;return e.length&&(t=e[0],n=e[e.length-1]),{min:t,max:n}}buildTicks(){const e=this.options,t=e.time,n=e.ticks,a="labels"===n.source?this.getLabelTimestamps():this._generate();"ticks"===e.bounds&&a.length&&(this.min=this._userMin||a[0],this.max=this._userMax||a[a.length-1]);const s=this.min,r=function(e,t,n){let a=0,s=e.length;for(;a<s&&e[a]<t;)a++;for(;s>a&&e[s-1]>n;)s--;return a>0||s<e.length?e.slice(a,s):e}(a,s,this.max);return this._unit=t.unit||(n.autoSkip?Fl(t.minUnit,this.min,this.max,this._getLabelCapacity(s)):function(e,t,n,a,s){for(let r=Pl.length-1;r>=Pl.indexOf(n);r--){const n=Pl[r];if(Ml[n].common&&e._adapter.diff(s,a,n)>=t-1)return n}return Pl[n?Pl.indexOf(n):0]}(this,r.length,t.minUnit,this.min,this.max)),this._majorUnit=n.major.enabled&&"year"!==this._unit?function(e){for(let t=Pl.indexOf(e)+1,n=Pl.length;t<n;++t)if(Ml[Pl[t]].common)return Pl[t]}(this._unit):void 0,this.initOffsets(a),e.reverse&&r.reverse(),zl(this,r,this._majorUnit)}afterAutoSkip(){this.options.offsetAfterAutoskip&&this.initOffsets(this.ticks.map(e=>+e.value))}initOffsets(){let e,t,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],a=0,s=0;this.options.offset&&n.length&&(e=this.getDecimalForValue(n[0]),a=1===n.length?1-e:(this.getDecimalForValue(n[1])-e)/2,t=this.getDecimalForValue(n[n.length-1]),s=1===n.length?t:(t-this.getDecimalForValue(n[n.length-2]))/2);const r=n.length<3?.5:.25;a=us(a,0,r),s=us(s,0,r),this._offsets={start:a,end:s,factor:1/(a+1+s)}}_generate(){const e=this._adapter,t=this.min,n=this.max,a=this.options,s=a.time,r=s.unit||Fl(s.minUnit,t,n,this._getLabelCapacity(t)),i=Ia(a.ticks.stepSize,1),o="week"===r&&s.isoWeekday,c=es(o)||!0===o,l={};let u,h,d=t;if(c&&(d=+e.startOf(d,"isoWeek",o)),d=+e.startOf(d,c?"day":r),e.diff(n,t,r)>1e5*i)throw new Error(t+" and "+n+" are too far apart with stepSize of "+i+" "+r);const p="data"===a.ticks.source&&this.getDataTimestamps();for(u=d,h=0;u<n;u=+e.add(u,i,r),h++)Ll(l,u,p);return u!==n&&"ticks"!==a.bounds&&1!==h||Ll(l,u,p),Object.keys(l).sort(Dl).map(e=>+e)}getLabelForValue(e){const t=this._adapter,n=this.options.time;return n.tooltipFormat?t.format(e,n.tooltipFormat):t.format(e,n.displayFormats.datetime)}format(e,t){const n=this.options.time.displayFormats,a=this._unit,s=t||n[a];return this._adapter.format(e,s)}_tickFormatFunction(e,t,n,a){const s=this.options,r=s.ticks.callback;if(r)return Ta(r,[e,t,n],this);const i=s.time.displayFormats,o=this._unit,c=this._majorUnit,l=o&&i[o],u=c&&i[c],h=n[t],d=c&&u&&h&&h.major;return this._adapter.format(e,a||(d?u:l))}generateTickLabels(e){let t,n,a;for(t=0,n=e.length;t<n;++t)a=e[t],a.label=this._tickFormatFunction(a.value,t,e)}getDecimalForValue(e){return null===e?NaN:(e-this.min)/(this.max-this.min)}getPixelForValue(e){const t=this._offsets,n=this.getDecimalForValue(e);return this.getPixelForDecimal((t.start+n)*t.factor)}getValueForPixel(e){const t=this._offsets,n=this.getDecimalForPixel(e)/t.factor-t.end;return this.min+n*(this.max-this.min)}_getLabelSize(e){const t=this.options.ticks,n=this.ctx.measureText(e).width,a=ns(this.isHorizontal()?t.maxRotation:t.minRotation),s=Math.cos(a),r=Math.sin(a),i=this._resolveTickFontOptions(0).size;return{w:n*s+i*r,h:n*r+i*s}}_getLabelCapacity(e){const t=this.options.time,n=t.displayFormats,a=n[t.unit]||n.millisecond,s=this._tickFormatFunction(e,0,zl(this,[e],this._majorUnit),a),r=this._getLabelSize(s),i=Math.floor(this.isHorizontal()?this.width/r.w:this.height/r.h)-1;return i>0?i:1}getDataTimestamps(){let e,t,n=this._cache.data||[];if(n.length)return n;const a=this.getMatchingVisibleMetas();if(this._normalized&&a.length)return this._cache.data=a[0].controller.getAllParsedValues(this);for(e=0,t=a.length;e<t;++e)n=n.concat(a[e].controller.getAllParsedValues(this));return this._cache.data=this.normalize(n)}getLabelTimestamps(){const e=this._cache.labels||[];let t,n;if(e.length)return e;const a=this.getLabels();for(t=0,n=a.length;t<n;++t)e.push(Ol(this,a[t]));return this._cache.labels=this._normalized?e:this.normalize(e)}normalize(e){return ys(e.sort(Dl))}}function jl(e,t,n){let a,s,r,i,o=0,c=e.length-1;n?(t>=e[o].pos&&t<=e[c].pos&&({lo:o,hi:c}=ps(e,"pos",t)),({pos:a,time:r}=e[o]),({pos:s,time:i}=e[c])):(t>=e[o].time&&t<=e[c].time&&({lo:o,hi:c}=ps(e,"time",t)),({time:a,pos:r}=e[o]),({time:s,pos:i}=e[c]));const l=s-a;return l?r+(i-r)*(t-a)/l:r}Fn(Bl,"id","time"),Fn(Bl,"defaults",{bounds:"data",adapters:{},time:{parser:!1,unit:!1,round:!1,isoWeekday:!1,minUnit:"millisecond",displayFormats:{}},ticks:{source:"auto",callback:!1,major:{enabled:!1}}});class Wl extends Bl{constructor(e){super(e),this._table=[],this._minPos=void 0,this._tableRange=void 0}initOffsets(){const e=this._getTimestampsForTable(),t=this._table=this.buildLookupTable(e);this._minPos=jl(t,this.min),this._tableRange=jl(t,this.max)-this._minPos,super.initOffsets(e)}buildLookupTable(e){const{min:t,max:n}=this,a=[],s=[];let r,i,o,c,l;for(r=0,i=e.length;r<i;++r)c=e[r],c>=t&&c<=n&&a.push(c);if(a.length<2)return[{time:t,pos:0},{time:n,pos:1}];for(r=0,i=a.length;r<i;++r)l=a[r+1],o=a[r-1],c=a[r],Math.round((l+o)/2)!==c&&s.push({time:c,pos:r/(i-1)});return s}_generate(){const e=this.min,t=this.max;let n=super.getDataTimestamps();return n.includes(e)&&n.length||n.splice(0,0,e),n.includes(t)&&1!==n.length||n.push(t),n.sort((e,t)=>e-t)}_getTimestampsForTable(){let e=this._cache.all||[];if(e.length)return e;const t=this.getDataTimestamps(),n=this.getLabelTimestamps();return e=t.length&&n.length?this.normalize(t.concat(n)):t.length?t:n,e=this._cache.all=e,e}getDecimalForValue(e){return(jl(this._table,e)-this._minPos)/this._tableRange}getValueForPixel(e){const t=this._offsets,n=this.getDecimalForPixel(e)/t.factor-t.end;return jl(this._table,n*this._tableRange+this._minPos,!0)}}Fn(Wl,"id","timeseries"),Fn(Wl,"defaults",Bl.defaults);const Vl=["height","width","redraw","datasetIdKey","type","data","options","plugins","fallbackContent","updateMode"],Ul="label";function Hl(e,t){"function"===typeof e?e(t):e&&(e.current=t)}function Gl(e,t){e.labels=t}function ql(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Ul;const a=[];e.datasets=t.map(t=>{const s=e.datasets.find(e=>e[n]===t[n]);return s&&t.data&&!a.includes(s)?(a.push(s),Object.assign(s,t),s):zn({},t)})}function Kl(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Ul;const n={labels:[],datasets:[]};return Gl(n,e.labels),ql(n,e.datasets,t),n}function Xl(e,t){const{height:n=150,width:a=300,redraw:s=!1,datasetIdKey:r,type:i,data:o,options:c,plugins:l=[],fallbackContent:u,updateMode:h}=e,d=function(e,t){if(null==e)return{};var n,a,s=function(e,t){if(null==e)return{};var n={};for(var a in e)if({}.hasOwnProperty.call(e,a)){if(-1!==t.indexOf(a))continue;n[a]=e[a]}return n}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],-1===t.indexOf(n)&&{}.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}(e,Vl),p=(0,E.useRef)(null),f=(0,E.useRef)(null),m=()=>{p.current&&(f.current=new yc(p.current,{type:i,data:Kl(o,r),options:c&&zn({},c),plugins:l}),Hl(t,f.current))},g=()=>{Hl(t,null),f.current&&(f.current.destroy(),f.current=null)};return(0,E.useEffect)(()=>{!s&&f.current&&c&&function(e,t){const n=e.options;n&&t&&Object.assign(n,t)}(f.current,c)},[s,c]),(0,E.useEffect)(()=>{!s&&f.current&&Gl(f.current.config.data,o.labels)},[s,o.labels]),(0,E.useEffect)(()=>{!s&&f.current&&o.datasets&&ql(f.current.config.data,o.datasets,r)},[s,o.datasets]),(0,E.useEffect)(()=>{f.current&&(s?(g(),setTimeout(m)):f.current.update(h))},[s,c,o.labels,o.datasets,h]),(0,E.useEffect)(()=>{f.current&&(g(),setTimeout(m))},[i]),(0,E.useEffect)(()=>(m(),()=>g()),[]),(0,wn.jsx)("canvas",zn(zn({ref:p,role:"img",height:n,width:a},d),{},{children:u}))}const Yl=(0,E.forwardRef)(Xl);function Ql(e,t){return yc.register(t),(0,E.forwardRef)((t,n)=>(0,wn.jsx)(Yl,zn(zn({},t),{},{ref:n,type:e})))}const Zl=Ql("line",zi),Jl=Ql("bar",Oi),$l=Ql("doughnut",Li);yc.register(hl,ml,Wc,Mc,Dc,Sc,Kc,cl,Gc);const eu=()=>{const e={responsive:!0,maintainAspectRatio:!1,plugins:{legend:{position:"bottom"}}},t=[{type:"success",icon:(0,wn.jsx)(Dt,{}),title:"High Detection Accuracy",description:"The system achieves 90%+ accuracy for most standard yoga poses when proper lighting and positioning are maintained."},{type:"success",icon:(0,wn.jsx)(Dt,{}),title:"Real-time Processing",description:"Pose detection runs at 30+ FPS, providing smooth real-time feedback without noticeable lag."},{type:"warning",icon:(0,wn.jsx)(qt,{}),title:"Similar Pose Confusion",description:"Some poses with similar body positions may occasionally be confused, particularly intermediate poses."},{type:"success",icon:(0,wn.jsx)(Dt,{}),title:"Progressive Improvement",description:"Model accuracy improves with additional training data and user feedback integration."}];return(0,wn.jsxs)("div",{className:"results-page",children:[(0,wn.jsx)("section",{className:"page-hero",children:(0,wn.jsxs)("div",{className:"container",children:[(0,wn.jsx)("span",{className:"page-label",children:"Performance"}),(0,wn.jsx)("h1",{children:"Results & Analysis"}),(0,wn.jsx)("p",{children:"Detailed performance metrics and accuracy analysis of our AI-powered yoga pose detection system."})]})}),(0,wn.jsx)("section",{className:"section metrics-section",children:(0,wn.jsx)("div",{className:"container",children:(0,wn.jsx)("div",{className:"metrics-grid",children:[{label:"Overall Accuracy",value:"91.5%",color:"#a177b4"},{label:"Precision",value:"94%",color:"#9fc5a7"},{label:"Recall",value:"91%",color:"#f39c12"},{label:"F1-Score",value:"92.5%",color:"#3498db"}].map((e,t)=>(0,wn.jsxs)("div",{className:"metric-card",children:[(0,wn.jsx)("div",{className:"metric-value",style:{color:e.color},children:e.value}),(0,wn.jsx)("div",{className:"metric-label",children:e.label})]},t))})})}),(0,wn.jsx)("section",{className:"section charts-section gradient-bg-light",children:(0,wn.jsxs)("div",{className:"container",children:[(0,wn.jsxs)("div",{className:"section-title",children:[(0,wn.jsx)("span",{children:"Visual Analytics"}),(0,wn.jsx)("h2",{children:"Performance Charts"})]}),(0,wn.jsxs)("div",{className:"charts-grid",children:[(0,wn.jsxs)("div",{className:"chart-container",children:[(0,wn.jsx)("h3",{children:"Accuracy by Pose Type"}),(0,wn.jsx)("div",{className:"chart-wrapper",children:(0,wn.jsx)(Jl,{data:{labels:["Tadasana","Vrikshasana","Trikonasana","Bhujangasana","Vajrasana","Padmasana"],datasets:[{label:"Detection Accuracy (%)",data:[95,92,88,94,90,86],backgroundColor:"rgba(161, 119, 180, 0.6)",borderColor:"rgba(161, 119, 180, 1)",borderWidth:2,borderRadius:8}]},options:e})})]}),(0,wn.jsxs)("div",{className:"chart-container",children:[(0,wn.jsx)("h3",{children:"Model Performance Metrics"}),(0,wn.jsx)("div",{className:"chart-wrapper doughnut",children:(0,wn.jsx)($l,{data:{labels:["Precision","Recall","F1-Score"],datasets:[{data:[94,91,92.5],backgroundColor:["rgba(161, 119, 180, 0.8)","rgba(159, 197, 167, 0.8)","rgba(243, 156, 18, 0.8)"],borderWidth:0}]},options:e})})]})]}),(0,wn.jsxs)("div",{className:"chart-container full-width",children:[(0,wn.jsx)("h3",{children:"Accuracy Improvement Over Time"}),(0,wn.jsx)("div",{className:"chart-wrapper",children:(0,wn.jsx)(Zl,{data:{labels:["Week 1","Week 2","Week 3","Week 4","Week 5","Week 6"],datasets:[{label:"Average Accuracy",data:[75,80,85,88,91,93],borderColor:"rgba(161, 119, 180, 1)",backgroundColor:"rgba(161, 119, 180, 0.2)",tension:.4,fill:!0}]},options:e})})]})]})}),(0,wn.jsx)("section",{className:"section explanation-section",children:(0,wn.jsx)("div",{className:"container",children:(0,wn.jsxs)("div",{className:"explanation-grid",children:[(0,wn.jsxs)("div",{className:"explanation-card",children:[(0,wn.jsx)("h3",{children:"Precision"}),(0,wn.jsx)("p",{children:"Precision measures how many of the poses the system identified as correct were actually correct. Our 94% precision means that when the system says you're doing a pose correctly, it's right 94% of the time."}),(0,wn.jsx)("div",{className:"formula",children:"Precision = True Positives / (True Positives + False Positives)"})]}),(0,wn.jsxs)("div",{className:"explanation-card",children:[(0,wn.jsx)("h3",{children:"Recall"}),(0,wn.jsx)("p",{children:"Recall measures how many of the actual correct poses were successfully identified by the system. Our 91% recall means the system catches 91% of all correct pose attempts."}),(0,wn.jsx)("div",{className:"formula",children:"Recall = True Positives / (True Positives + False Negatives)"})]}),(0,wn.jsxs)("div",{className:"explanation-card",children:[(0,wn.jsx)("h3",{children:"F1-Score"}),(0,wn.jsx)("p",{children:"The F1-Score is the harmonic mean of precision and recall, providing a single metric that balances both. Our 92.5% F1-Score indicates excellent overall model performance."}),(0,wn.jsx)("div",{className:"formula",children:"F1 = 2 \xd7 (Precision \xd7 Recall) / (Precision + Recall)"})]})]})})}),(0,wn.jsx)("section",{className:"section observations-section",children:(0,wn.jsxs)("div",{className:"container",children:[(0,wn.jsxs)("div",{className:"section-title",children:[(0,wn.jsx)("span",{children:"Key Insights"}),(0,wn.jsx)("h2",{children:"Observations"})]}),(0,wn.jsx)("div",{className:"observations-grid",children:t.map((e,t)=>(0,wn.jsxs)("div",{className:"observation-card ".concat(e.type),children:[(0,wn.jsx)("div",{className:"observation-icon",children:e.icon}),(0,wn.jsxs)("div",{className:"observation-content",children:[(0,wn.jsx)("h4",{children:e.title}),(0,wn.jsx)("p",{children:e.description})]})]},t))})]})}),(0,wn.jsx)("section",{className:"section improvements-section gradient-bg-light",children:(0,wn.jsxs)("div",{className:"container",children:[(0,wn.jsxs)("div",{className:"section-title",children:[(0,wn.jsx)("span",{children:"Roadmap"}),(0,wn.jsx)("h2",{children:"Future Improvements"})]}),(0,wn.jsxs)("div",{className:"improvements-grid",children:[(0,wn.jsxs)("div",{className:"improvement-item",children:[(0,wn.jsx)(Pt,{}),(0,wn.jsx)("h4",{children:"More Poses"}),(0,wn.jsx)("p",{children:"Expanding the library to include 50+ yoga poses"})]}),(0,wn.jsxs)("div",{className:"improvement-item",children:[(0,wn.jsx)(Pt,{}),(0,wn.jsx)("h4",{children:"Better Accuracy"}),(0,wn.jsx)("p",{children:"Training on larger datasets for improved detection"})]}),(0,wn.jsxs)("div",{className:"improvement-item",children:[(0,wn.jsx)(Pt,{}),(0,wn.jsx)("h4",{children:"Voice Guidance"}),(0,wn.jsx)("p",{children:"Adding audio instructions and real-time voice feedback"})]}),(0,wn.jsxs)("div",{className:"improvement-item",children:[(0,wn.jsx)(Pt,{}),(0,wn.jsx)("h4",{children:"Progress Tracking"}),(0,wn.jsx)("p",{children:"Personal analytics and improvement tracking over time"})]})]})]})})]})},tu=()=>{const e="Your College Name",t="Department of Computer Science",n="College Address, City, State - PIN",a="2024-2025";return(0,wn.jsxs)("div",{className:"team-page",children:[(0,wn.jsx)("section",{className:"page-hero",children:(0,wn.jsxs)("div",{className:"container",children:[(0,wn.jsx)("span",{className:"page-label",children:"Meet Our"}),(0,wn.jsx)("h1",{children:"Development Team"}),(0,wn.jsx)("p",{children:"The talented individuals behind the YogaGuru AI-powered yoga pose detection platform."})]})}),(0,wn.jsx)("section",{className:"section team-section",children:(0,wn.jsxs)("div",{className:"container",children:[(0,wn.jsxs)("div",{className:"section-title",children:[(0,wn.jsx)("span",{children:"Students"}),(0,wn.jsx)("h2",{children:"Our Team"})]}),(0,wn.jsx)("div",{className:"team-grid",children:[{name:"Keraliya Kaushal",role:"Project Lead",department:"Computer Science",image:"/TeamImage/Kaushal.png",description:"Responsible for project management, system architecture, and frontend development.",links:{github:"https://github.com/Kaushal187-Patel",linkedin:"https://www.linkedin.com/in/keraliya-kaushal-2bb578273",email:"kaushal151131@email.com"}},{name:"Mankad Drashti",role:"ML Developer",department:"Computer Science",image:"/TeamImage/drashti.jpg",description:"Specialized in machine learning model development and pose estimation algorithms.",links:{github:"https://github.com",linkedin:"https://linkedin.com",email:"student2@email.com"}}].map((e,t)=>(0,wn.jsxs)("div",{className:"team-card",children:[(0,wn.jsx)("div",{className:"member-image",children:(0,wn.jsx)("img",{src:e.image,alt:e.name})}),(0,wn.jsxs)("div",{className:"member-info",children:[(0,wn.jsx)("h3",{children:e.name}),(0,wn.jsx)("span",{className:"role",children:e.role}),(0,wn.jsx)("span",{className:"department",children:e.department}),(0,wn.jsx)("p",{children:e.description}),(0,wn.jsxs)("div",{className:"member-links",children:[e.links.github&&(0,wn.jsx)("a",{href:e.links.github,target:"_blank",rel:"noopener noreferrer",children:(0,wn.jsx)(ft,{})}),e.links.linkedin&&(0,wn.jsx)("a",{href:e.links.linkedin,target:"_blank",rel:"noopener noreferrer",children:(0,wn.jsx)(xt,{})}),e.links.email&&(0,wn.jsx)("a",{href:"mailto:".concat(e.links.email),children:(0,wn.jsx)(Gt,{})})]})]})]},t))})]})}),(0,wn.jsx)("section",{className:"section college-section",children:(0,wn.jsx)("div",{className:"container",children:(0,wn.jsxs)("div",{className:"college-card",children:[(0,wn.jsx)("h2",{children:e}),(0,wn.jsx)("p",{className:"department",children:t}),(0,wn.jsx)("p",{className:"address",children:n}),(0,wn.jsxs)("p",{className:"year",children:["Academic Year: ",a]})]})})}),(0,wn.jsx)("section",{className:"section acknowledgments-section gradient-bg-light",children:(0,wn.jsxs)("div",{className:"container",children:[(0,wn.jsx)("div",{className:"section-title",children:(0,wn.jsx)("h2",{children:"Acknowledgments"})}),(0,wn.jsxs)("div",{className:"acknowledgment-content",children:[(0,wn.jsx)("p",{children:"We extend our sincere gratitude to our project guide for their invaluable guidance and support throughout the development of this project. We also thank our college and department for providing the necessary resources and infrastructure to bring this project to fruition."}),(0,wn.jsx)("p",{children:"Special thanks to the open-source community for their contributions to TensorFlow, MediaPipe, and other technologies that made this project possible."})]})]})})]})},nu=()=>{const[e,t]=(0,E.useState)({name:"",email:"",subject:"",message:""}),[n,a]=(0,E.useState)(!1),[s,r]=(0,E.useState)(!1),i=[{icon:(0,wn.jsx)(Gt,{}),title:"Email",details:"contact@yogaguru.com",link:"mailto:contact@yogaguru.com"},{icon:(0,wn.jsx)(on,{}),title:"Phone",details:"+91 92653 00000",link:"tel:+919265300000"},{icon:(0,wn.jsx)(an,{}),title:"Address",details:"Your College Name, City, State - PIN",link:null}],o=e=>{const{name:n,value:a}=e.target;t(e=>zn(zn({},e),{},{[n]:a}))};return(0,wn.jsxs)("div",{className:"contact-page",children:[(0,wn.jsx)("section",{className:"page-hero",children:(0,wn.jsxs)("div",{className:"container",children:[(0,wn.jsx)("span",{className:"page-label",children:"Get In Touch"}),(0,wn.jsx)("h1",{children:"Contact Us"}),(0,wn.jsx)("p",{children:"Have questions about YogaGuru? We'd love to hear from you. Send us a message and we'll respond as soon as possible."})]})}),(0,wn.jsx)("section",{className:"section contact-section",children:(0,wn.jsx)("div",{className:"container",children:(0,wn.jsxs)("div",{className:"contact-grid",children:[(0,wn.jsxs)("div",{className:"contact-form-wrapper",children:[(0,wn.jsx)("h2",{children:"Send us a Message"}),n?(0,wn.jsxs)("div",{className:"success-message",children:[(0,wn.jsx)(Dt,{}),(0,wn.jsx)("h3",{children:"Thank You!"}),(0,wn.jsx)("p",{children:"Your message has been sent successfully. We'll get back to you soon."})]}):(0,wn.jsxs)("form",{onSubmit:async e=>{e.preventDefault(),r(!0),await new Promise(e=>setTimeout(e,1500)),r(!1),a(!0),t({name:"",email:"",subject:"",message:""}),setTimeout(()=>a(!1),5e3)},className:"contact-form",children:[(0,wn.jsxs)("div",{className:"form-row",children:[(0,wn.jsxs)("div",{className:"form-group",children:[(0,wn.jsx)("label",{htmlFor:"name",children:"Your Name"}),(0,wn.jsx)("input",{type:"text",id:"name",name:"name",value:e.name,onChange:o,placeholder:"John Doe",required:!0})]}),(0,wn.jsxs)("div",{className:"form-group",children:[(0,wn.jsx)("label",{htmlFor:"email",children:"Email Address"}),(0,wn.jsx)("input",{type:"email",id:"email",name:"email",value:e.email,onChange:o,placeholder:"john@example.com",required:!0})]})]}),(0,wn.jsxs)("div",{className:"form-group",children:[(0,wn.jsx)("label",{htmlFor:"subject",children:"Subject"}),(0,wn.jsx)("input",{type:"text",id:"subject",name:"subject",value:e.subject,onChange:o,placeholder:"How can we help?",required:!0})]}),(0,wn.jsxs)("div",{className:"form-group",children:[(0,wn.jsx)("label",{htmlFor:"message",children:"Message"}),(0,wn.jsx)("textarea",{id:"message",name:"message",value:e.message,onChange:o,placeholder:"Tell us more about your inquiry...",rows:"5",required:!0})]}),(0,wn.jsx)("button",{type:"submit",className:"btn btn-primary submit-btn",disabled:s,children:s?"Sending...":(0,wn.jsxs)(wn.Fragment,{children:[(0,wn.jsx)(rn,{})," Send Message"]})})]})]}),(0,wn.jsxs)("div",{className:"contact-info-wrapper",children:[(0,wn.jsx)("h2",{children:"Contact Information"}),(0,wn.jsx)("p",{children:"Reach out to us through any of the following channels. We're here to help with any questions about our AI yoga pose detection platform."}),(0,wn.jsx)("div",{className:"contact-cards",children:i.map((e,t)=>(0,wn.jsxs)("div",{className:"contact-card",children:[(0,wn.jsx)("div",{className:"contact-icon",children:e.icon}),(0,wn.jsxs)("div",{className:"contact-details",children:[(0,wn.jsx)("h4",{children:e.title}),e.link?(0,wn.jsx)("a",{href:e.link,children:e.details}):(0,wn.jsx)("p",{children:e.details})]})]},t))}),(0,wn.jsx)("div",{className:"map-container",children:(0,wn.jsxs)("div",{className:"map-placeholder",children:[(0,wn.jsx)(an,{}),(0,wn.jsx)("p",{children:"Map View"}),(0,wn.jsx)("span",{children:"Your College Location"})]})})]})]})})}),(0,wn.jsx)("section",{className:"section faq-cta gradient-bg-light",children:(0,wn.jsxs)("div",{className:"container text-center",children:[(0,wn.jsx)("h2",{children:"Frequently Asked Questions"}),(0,wn.jsx)("p",{children:"Check out our FAQ section for quick answers to common questions."}),(0,wn.jsx)("a",{href:"/#faq",className:"btn btn-primary",children:"View FAQs"})]})})]})},au=e=>{let{isOpen:t,onClose:n,message:a,title:s="Success!"}=e;return t?(0,wn.jsx)("div",{className:"success-modal-overlay",onClick:n,children:(0,wn.jsxs)("div",{className:"success-modal-content",onClick:e=>e.stopPropagation(),children:[(0,wn.jsx)("button",{className:"success-modal-close",onClick:n,children:(0,wn.jsx)(gn,{})}),(0,wn.jsx)("div",{className:"success-modal-icon",children:(0,wn.jsx)(Dt,{})}),(0,wn.jsx)("h2",{className:"success-modal-title",children:s}),(0,wn.jsx)("p",{className:"success-modal-message",children:a})]})}):null},su={NODE_ENV:"production",PUBLIC_URL:"",WDS_SOCKET_HOST:void 0,WDS_SOCKET_PATH:void 0,WDS_SOCKET_PORT:void 0,FAST_REFRESH:!0}.REACT_APP_API_URL||"http://localhost:5000/api",ru=()=>{const e=Re(),[t,n]=(0,E.useState)(!0),[a,s]=(0,E.useState)(!1),[r,i]=(0,E.useState)(!1),[o,c]=(0,E.useState)(""),[l,u]=(0,E.useState)(!1),[h,d]=(0,E.useState)(""),[p,f]=(0,E.useState)({name:"",email:"",password:"",confirmPassword:""}),[m,g]=(0,E.useState)({}),y=e=>{const{name:t,value:n}=e.target;f(e=>zn(zn({},e),{},{[t]:n})),m[t]&&g(e=>zn(zn({},e),{},{[t]:""}))},b=()=>{n(!t),f({name:"",email:"",password:"",confirmPassword:""}),g({})};return(0,wn.jsxs)("div",{className:"auth-page",children:[(0,wn.jsx)("div",{className:"auth-container",children:(0,wn.jsxs)("div",{className:"auth-card",children:[(0,wn.jsxs)("div",{className:"auth-header",children:[(0,wn.jsx)(nt,{to:"/",className:"auth-logo",children:"YogaGuru"}),(0,wn.jsx)("h1",{children:t?"Welcome Back":"Create Account"}),(0,wn.jsx)("p",{children:t?"Sign in to continue your yoga journey":"Start your AI-powered yoga practice today"})]}),(0,wn.jsxs)("div",{className:"auth-tabs",children:[(0,wn.jsx)("button",{className:"auth-tab ".concat(t?"active":""),onClick:()=>b(),children:"Login"}),(0,wn.jsx)("button",{className:"auth-tab ".concat(t?"":"active"),onClick:()=>b(),children:"Sign Up"})]}),(0,wn.jsxs)("form",{onSubmit:async n=>{if(n.preventDefault(),c(""),(()=>{const e={};return t||p.name.trim()||(e.name="Name is required"),p.email.trim()?/\S+@\S+\.\S+/.test(p.email)||(e.email="Invalid email format"):e.email="Email is required",p.password?p.password.length<6&&(e.password="Password must be at least 6 characters"):e.password="Password is required",t||p.password===p.confirmPassword||(e.confirmPassword="Passwords do not match"),g(e),0===Object.keys(e).length})()){i(!0);try{const n=t?"/auth/login":"/auth/register",a=t?{email:p.email,password:p.password}:{name:p.name,email:p.email,password:p.password},s=await fetch("".concat(su).concat(n),{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(a)}),r=await s.json();if(!s.ok)throw new Error(r.error||"Something went wrong");r.token&&(localStorage.setItem("token",r.token),localStorage.setItem("user",JSON.stringify(r.user))),f({name:"",email:"",password:"",confirmPassword:""}),g({}),t?(alert("Login successful! Welcome back!"),setTimeout(()=>{e("/"),window.location.reload()},500)):(d("Congratulations ".concat(r.user.name,"! Your account has been created successfully. You are now logged in.")),u(!0),setTimeout(()=>{u(!1),e("/profile"),window.location.reload()},3e3))}catch(a){console.error("Auth error:",a),c(a.message||"An error occurred. Please try again.")}finally{i(!1)}}},className:"auth-form",children:[!t&&(0,wn.jsxs)("div",{className:"form-group",children:[(0,wn.jsx)("label",{htmlFor:"name",children:"Full Name"}),(0,wn.jsxs)("div",{className:"input-wrapper",children:[(0,wn.jsx)(xn,{className:"input-icon"}),(0,wn.jsx)("input",{type:"text",id:"name",name:"name",value:p.name,onChange:y,placeholder:"John Doe",className:m.name?"error":""})]}),m.name&&(0,wn.jsx)("span",{className:"error-text",children:m.name})]}),(0,wn.jsxs)("div",{className:"form-group",children:[(0,wn.jsx)("label",{htmlFor:"email",children:"Email Address"}),(0,wn.jsxs)("div",{className:"input-wrapper",children:[(0,wn.jsx)(Gt,{className:"input-icon"}),(0,wn.jsx)("input",{type:"email",id:"email",name:"email",value:p.email,onChange:y,placeholder:"john@example.com",className:m.email?"error":""})]}),m.email&&(0,wn.jsx)("span",{className:"error-text",children:m.email})]}),(0,wn.jsxs)("div",{className:"form-group",children:[(0,wn.jsx)("label",{htmlFor:"password",children:"Password"}),(0,wn.jsxs)("div",{className:"input-wrapper",children:[(0,wn.jsx)(nn,{className:"input-icon"}),(0,wn.jsx)("input",{type:a?"text":"password",id:"password",name:"password",value:p.password,onChange:y,placeholder:"\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022",className:m.password?"error":""}),(0,wn.jsx)("button",{type:"button",className:"toggle-password",onClick:()=>s(!a),children:a?(0,wn.jsx)(Xt,{}):(0,wn.jsx)(Yt,{})})]}),m.password&&(0,wn.jsx)("span",{className:"error-text",children:m.password})]}),!t&&(0,wn.jsxs)("div",{className:"form-group",children:[(0,wn.jsx)("label",{htmlFor:"confirmPassword",children:"Confirm Password"}),(0,wn.jsxs)("div",{className:"input-wrapper",children:[(0,wn.jsx)(nn,{className:"input-icon"}),(0,wn.jsx)("input",{type:a?"text":"password",id:"confirmPassword",name:"confirmPassword",value:p.confirmPassword,onChange:y,placeholder:"\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022",className:m.confirmPassword?"error":""})]}),m.confirmPassword&&(0,wn.jsx)("span",{className:"error-text",children:m.confirmPassword})]}),t&&(0,wn.jsxs)("div",{className:"form-options",children:[(0,wn.jsxs)("label",{className:"remember-me",children:[(0,wn.jsx)("input",{type:"checkbox"}),(0,wn.jsx)("span",{children:"Remember me"})]}),(0,wn.jsx)("a",{href:"#forgot",className:"forgot-password",children:"Forgot Password?"})]}),o&&(0,wn.jsx)("div",{className:"server-error",style:{color:"#e74c3c",marginBottom:"1rem",padding:"0.75rem",backgroundColor:"#fee",borderRadius:"4px",fontSize:"0.9rem"},children:o}),(0,wn.jsx)("button",{type:"submit",className:"btn btn-primary submit-btn",disabled:r,children:r?t?"Signing In...":"Creating Account...":t?"Sign In":"Create Account"})]}),(0,wn.jsx)("div",{className:"auth-divider",children:(0,wn.jsx)("span",{children:"or continue with"})}),(0,wn.jsxs)("div",{className:"social-auth",children:[(0,wn.jsxs)("button",{className:"social-btn google",children:[(0,wn.jsx)(mt,{})," Google"]}),(0,wn.jsxs)("button",{className:"social-btn facebook",children:[(0,wn.jsx)(pt,{})," Facebook"]})]}),(0,wn.jsxs)("p",{className:"auth-footer",children:[t?"Don't have an account? ":"Already have an account? ",(0,wn.jsx)("button",{type:"button",onClick:b,className:"switch-mode",children:t?"Sign Up":"Sign In"})]})]})}),(0,wn.jsx)(au,{isOpen:l,onClose:()=>{u(!1),e("/profile"),window.location.reload()},title:"\ud83c\udf89 Account Created Successfully!",message:h})]})},iu=()=>{const e=Re(),[t,n]=(0,E.useState)(null),[a,s]=(0,E.useState)(!1),[r,i]=(0,E.useState)(""),[o,c]=(0,E.useState)(!1),[l,u]=(0,E.useState)("");(0,E.useEffect)(()=>{const t=localStorage.getItem("user");if(localStorage.getItem("token")&&t)try{const e=JSON.parse(t);n(e),i(e.name)}catch(l){console.error("Error parsing user data:",l),e("/login")}else e("/login")},[e]);if(!t)return(0,wn.jsx)("div",{className:"profile-page",children:(0,wn.jsx)("div",{className:"profile-loading",children:"Loading..."})});return(0,wn.jsx)("div",{className:"profile-page",children:(0,wn.jsxs)("div",{className:"profile-container",children:[(0,wn.jsxs)("div",{className:"profile-header",children:[(0,wn.jsx)("div",{className:"profile-avatar",children:(0,wn.jsx)(xn,{})}),(0,wn.jsx)("h1",{children:"My Profile"})]}),(0,wn.jsxs)("div",{className:"profile-content",children:[(0,wn.jsxs)("div",{className:"profile-card",children:[(0,wn.jsxs)("div",{className:"profile-card-header",children:[(0,wn.jsx)("h2",{children:"Personal Information"}),a?(0,wn.jsxs)("div",{className:"edit-actions",children:[(0,wn.jsxs)("button",{className:"btn-save",onClick:async()=>{if(r.trim()){c(!0),u("");try{const e=localStorage.getItem("token"),a=await fetch("".concat(su,"/users/profile"),{method:"PUT",headers:{"Content-Type":"application/json",Authorization:"Bearer ".concat(e)},body:JSON.stringify({name:r})}),i=await a.json();if(!a.ok)throw new Error(i.error||"Failed to update profile");const o=zn(zn({},t),{},{name:r});localStorage.setItem("user",JSON.stringify(o)),n(o),s(!1),alert("Profile updated successfully!")}catch(l){console.error("Update error:",l),u(l.message||"Failed to update profile")}finally{c(!1)}}else u("Name cannot be empty")},disabled:o,children:[(0,wn.jsx)(hn,{})," ",o?"Saving...":"Save"]}),(0,wn.jsxs)("button",{className:"btn-cancel",onClick:()=>{s(!1),i(t.name),u("")},children:[(0,wn.jsx)(gn,{})," Cancel"]})]}):(0,wn.jsxs)("button",{className:"btn-edit",onClick:()=>s(!0),children:[(0,wn.jsx)(Ht,{})," Edit"]})]}),l&&(0,wn.jsx)("div",{className:"profile-error",children:l}),(0,wn.jsxs)("div",{className:"profile-info",children:[(0,wn.jsxs)("div",{className:"info-item",children:[(0,wn.jsxs)("label",{children:[(0,wn.jsx)(xn,{})," Full Name"]}),a?(0,wn.jsx)("input",{type:"text",value:r,onChange:e=>i(e.target.value),className:"profile-input"}):(0,wn.jsx)("span",{children:t.name})]}),(0,wn.jsxs)("div",{className:"info-item",children:[(0,wn.jsxs)("label",{children:[(0,wn.jsx)(Gt,{})," Email Address"]}),(0,wn.jsx)("span",{children:t.email})]}),(0,wn.jsxs)("div",{className:"info-item",children:[(0,wn.jsxs)("label",{children:[(0,wn.jsx)(_t,{})," Member Since"]}),(0,wn.jsx)("span",{children:(e=>{if(!e)return"N/A";return new Date(e).toLocaleDateString("en-US",{year:"numeric",month:"long",day:"numeric"})})(t.created_at||t.createdAt)})]})]})]}),(0,wn.jsx)("div",{className:"profile-actions",children:(0,wn.jsxs)("button",{className:"btn-logout",onClick:()=>{localStorage.removeItem("token"),localStorage.removeItem("user"),e("/"),window.location.reload()},children:[(0,wn.jsx)(pn,{})," Logout"]})})]})]})})},ou=()=>{const{categoryId:e}=_e(),t=Te(),n=Re(),[a,s]=(0,E.useState)(null),[r,i]=(0,E.useState)(null),o=(e,t)=>{var n,a,s;const r="/pose-images/pose-".concat(e,".jpg"),i={Tadasana:"https://images.unsplash.com/photo-1545389336-cf090694435e?w=400&h=300&fit=crop&auto=format",Vrikshasana:"https://images.unsplash.com/photo-1758274525911-402f99afec14?w=600&h=400&fit=crop&auto=format&q=80",Trikonasana:"https://images.unsplash.com/photo-1767611090899-163209a4ead1?w=600&h=400&fit=crop&auto=format&q=80",Bhujangasana:"https://images.unsplash.com/photo-1717821552922-61e18814a44a?w=600&h=400&fit=crop&auto=format&q=80","Setu Bandhasana":"https://images.unsplash.com/photo-1767611086180-6b1176976371?w=600&h=400&fit=crop&auto=format&q=80",Virabhadrasana:r,Anjaneyasana:r,Paschimottanasana:r,"Ardha Matsyendrasana":r,Gomukhasana:r,Garudasana:r,"Supta Padangusthasana":r,Marjariasana:"https://images.unsplash.com/photo-1758599881262-7b79a56ac284?w=600&h=400&fit=crop&auto=format&q=80","Adho Mukha Svanasana":"https://images.unsplash.com/photo-1767611121194-3cb554c9a9ec?w=600&h=400&fit=crop&auto=format&q=80","Surya Namaskar":"https://images.unsplash.com/photo-1606663368493-131f4f97c095?w=600&h=400&fit=crop&auto=format&q=80",Balasana:"https://images.unsplash.com/photo-1767611118672-d3887038786c?w=600&h=400&fit=crop&auto=format&q=80",Padmasana:"https://images.unsplash.com/photo-1577344718665-3e7c0c1ecf6b?w=600&h=400&fit=crop&auto=format&q=80",Vajrasana:"https://images.unsplash.com/photo-1697274834392-04ff3b76ef20?w=600&h=400&fit=crop&auto=format&q=80",Pavanamuktasana:"https://images.unsplash.com/photo-1506126613408-eca07ce68773?w=400&h=300&fit=crop&auto=format",Uttanasana:"https://images.unsplash.com/photo-1506126613408-eca07ce68773?w=400&h=300&fit=crop&auto=format","Viparita Karani":"https://images.unsplash.com/photo-1506126613408-eca07ce68773?w=400&h=300&fit=crop&auto=format"};if(i[t])return i[t];const o=((null===(n=t.split("(")[1])||void 0===n||null===(a=n.split(")")[0])||void 0===a?void 0:a.trim())||(null===(s=t.split("-")[1])||void 0===s?void 0:s.trim())||"yoga pose").toLowerCase().replace(/\s+/g,"%20").replace(/[^a-z0-9%]/g,"");return"https://source.unsplash.com/400x300/?yoga%20".concat(o,"&sig=").concat(e)},c={"pain-relief":[{id:1,name:"\u0aad\u0ac1\u0a9c\u0a82\u0a97\u0abe\u0ab8\u0aa8 (Bhujangasana) - Cobra Pose",image:o(1,"Bhujangasana"),description:"A gentle backbend that strengthens the spine and opens the chest. This pose helps relieve back pain by stretching the front body and strengthening the back muscles.",advantages:["Relieves lower back pain","Strengthens the spine","Opens the chest and shoulders","Improves posture","Stretches abdominal muscles","Stimulates abdominal organs"],disadvantages:["Not suitable for severe back injuries","Avoid during pregnancy","May cause strain if done incorrectly","Can worsen carpal tunnel syndrome"],difficulty:"Beginner",duration:"30-60 seconds",subCategories:["Back Pain","Spine Health"]},{id:2,name:"\u0ab5\u0ac0\u0ab0\u0aad\u0aa6\u0acd\u0ab0\u0abe\u0ab8\u0aa8 II (Virabhadrasana II) - Warrior II",image:o(2,"Virabhadrasana"),description:"A powerful standing pose that strengthens the legs, opens the hips, and improves balance. Excellent for knee and hip joint health.",advantages:["Strengthens legs and ankles","Stretches hips and groin","Improves balance and stability","Opens the chest","Builds stamina","Relieves knee pain"],disadvantages:["Avoid with knee injuries","May strain hip flexors if overdone","Not recommended for high blood pressure","Can cause dizziness if held too long"],difficulty:"Intermediate",duration:"30-60 seconds",subCategories:["Knee Pain","Hip Pain"]},{id:3,name:"\u0aae\u0abe\u0ab0\u0acd\u0a9c\u0ab0\u0ac0\u0a86\u0ab8\u0aa8 (Marjariasana) - Cat-Cow Pose",image:o(3,"Marjariasana"),description:"A gentle flowing movement that warms up the spine and relieves tension in the back and neck. Perfect for office workers.",advantages:["Relieves neck and back tension","Improves spinal flexibility","Massages abdominal organs","Reduces stress and fatigue","Improves posture","Safe for beginners"],disadvantages:["Avoid with severe neck injuries","May cause discomfort with wrist issues","Not suitable during late pregnancy","Can cause dizziness if done too fast"],difficulty:"Beginner",duration:"1-2 minutes",subCategories:["Neck Pain","Back Pain"]},{id:4,name:"\u0ab8\u0ac7\u0aa4\u0ac1 \u0aac\u0a82\u0aa7\u0abe\u0ab8\u0aa8 (Setu Bandhasana) - Bridge Pose",image:o(4,"Setu Bandhasana"),description:"A gentle backbend that strengthens the back muscles and opens the chest. Excellent for relieving lower back pain and improving spinal flexibility.",advantages:["Relieves lower back pain","Strengthens glutes and hamstrings","Opens the chest and shoulders","Improves spinal flexibility","Stimulates thyroid gland","Reduces anxiety and fatigue"],disadvantages:["Avoid with neck injuries","Not suitable for severe back problems","May strain knees if misaligned","Avoid during late pregnancy"],difficulty:"Beginner",duration:"30-60 seconds",subCategories:["Back Pain","Spine Health"]},{id:5,name:"\u0a85\u0ab0\u0acd\u0aa7 \u0aae\u0aa4\u0acd\u0ab8\u0acd\u0aaf\u0ac7\u0aa8\u0acd\u0aa6\u0acd\u0ab0\u0abe\u0ab8\u0aa8 (Ardha Matsyendrasana) - Half Lord of the Fishes Pose",image:o(5,"Ardha Matsyendrasana"),description:"A seated twist that improves spinal mobility and relieves back stiffness. Helps with sciatica and lower back tension.",advantages:["Relieves back stiffness","Improves spinal mobility","Stretches shoulders and hips","Stimulates digestive organs","Helps with sciatica","Reduces fatigue"],disadvantages:["Avoid with severe back injuries","Not suitable during pregnancy","May cause discomfort with knee issues","Can strain spine if forced"],difficulty:"Intermediate",duration:"30-60 seconds each side",subCategories:["Back Pain","Sciatica"]},{id:6,name:"\u0ab8\u0ac1\u0aaa\u0acd\u0aa4 \u0aaa\u0aa6\u0abe\u0a82\u0a97\u0ac1\u0ab7\u0acd\u0aa0\u0abe\u0ab8\u0aa8 (Supta Padangusthasana) - Reclining Hand-to-Big-Toe Pose",image:o(6,"Supta Padangusthasana"),description:"A supine pose that stretches the hamstrings and relieves lower back pain. Excellent for sciatica relief.",advantages:["Stretches hamstrings and calves","Relieves lower back pain","Helps with sciatica","Improves flexibility","Strengthens legs","Safe for beginners"],disadvantages:["Avoid with severe hamstring injuries","Not suitable with knee problems","May cause strain if overstretched","Avoid with high blood pressure"],difficulty:"Beginner",duration:"30-60 seconds each leg",subCategories:["Back Pain","Sciatica","Joint Pain"]},{id:7,name:"\u0a97\u0acb\u0aae\u0ac1\u0a96\u0abe\u0ab8\u0aa8 (Gomukhasana) - Cow Face Pose",image:o(7,"Gomukhasana"),description:"A seated pose that stretches shoulders, hips, and thighs. Excellent for shoulder and hip pain relief.",advantages:["Stretches shoulders and chest","Opens hips and thighs","Improves posture","Relieves shoulder tension","Stretches triceps","Improves flexibility"],disadvantages:["Avoid with shoulder injuries","Not suitable with knee problems","May cause discomfort with tight hips","Can strain if forced"],difficulty:"Intermediate",duration:"30-60 seconds each side",subCategories:["Shoulder Pain","Hip Pain","Joint Pain"]},{id:8,name:"\u0a97\u0ab0\u0ac1\u0aa1\u0abe\u0ab8\u0aa8 (Garudasana) - Eagle Pose",image:o(8,"Garudasana"),description:"A balancing pose that strengthens legs and improves joint mobility. Helps with joint pain and improves circulation.",advantages:["Strengthens legs and ankles","Improves balance","Stretches shoulders and upper back","Improves joint mobility","Enhances concentration","Relieves joint stiffness"],disadvantages:["Avoid with knee or ankle injuries","Not suitable for balance issues","May cause dizziness","Can strain if held too long"],difficulty:"Intermediate",duration:"20-40 seconds each side",subCategories:["Joint Pain","Knee Pain","Arthritis"]},{id:9,name:"\u0aaa\u0ab6\u0acd\u0a9a\u0abf\u0aae\u0acb\u0aa4\u0acd\u0aa4\u0abe\u0aa8\u0abe\u0ab8\u0aa8 (Paschimottanasana) - Seated Forward Bend",image:o(9,"Paschimottanasana"),description:"A forward fold that stretches the entire back body and relieves back pain. Calms the nervous system.",advantages:["Stretches entire back body","Relieves back pain","Calms the nervous system","Stimulates abdominal organs","Improves digestion","Reduces stress"],disadvantages:["Avoid with severe back injuries","Not suitable with disc problems","May cause strain if forced","Avoid during pregnancy"],difficulty:"Beginner",duration:"1-3 minutes",subCategories:["Back Pain","Muscle Tension"]},{id:10,name:"\u0a85\u0a82\u0a9c\u0aa8\u0ac7\u0aaf\u0abe\u0ab8\u0aa8 (Anjaneyasana) - Low Lunge",image:o(10,"Anjaneyasana"),description:"A lunge pose that stretches hip flexors and relieves hip and knee pain. Strengthens legs and improves flexibility.",advantages:["Stretches hip flexors","Strengthens legs","Opens the chest","Relieves hip pain","Improves balance","Stretches psoas muscle"],disadvantages:["Avoid with knee injuries","Not suitable with hip problems","May strain if overstretched","Can cause discomfort with ankle issues"],difficulty:"Beginner",duration:"30-60 seconds each side",subCategories:["Hip Pain","Knee Pain","Muscle Tension"]},{id:11,name:"\u0a89\u0aa4\u0acd\u0aa4\u0abe\u0aa8\u0abe\u0ab8\u0aa8 (Uttanasana) - Standing Forward Bend",image:o(11,"Uttanasana"),description:"A standing forward fold that relieves back and neck tension. Calms the mind and stretches the entire back body.",advantages:["Relieves back and neck tension","Stretches hamstrings and calves","Calms the mind","Improves circulation","Reduces stress","Stimulates abdominal organs"],disadvantages:["Avoid with severe back injuries","Not suitable with high blood pressure","May cause dizziness","Avoid during late pregnancy"],difficulty:"Beginner",duration:"30-60 seconds",subCategories:["Back Pain","Neck Pain","Muscle Tension"]},{id:12,name:"\u0ab5\u0abf\u0aaa\u0ab0\u0ac0\u0aa4 \u0a95\u0ab0\u0aa3\u0ac0 (Viparita Karani) - Legs-Up-the-Wall Pose",image:o(12,"Viparita Karani"),description:"A restorative inversion that relieves back pain and reduces swelling. Excellent for sciatica and lower back relief.",advantages:["Relieves lower back pain","Reduces leg swelling","Calms the nervous system","Improves circulation","Reduces stress","Helps with sciatica"],disadvantages:["Avoid with eye pressure issues","Not suitable with severe back problems","May cause discomfort with neck issues","Avoid during menstruation"],difficulty:"Beginner",duration:"5-15 minutes",subCategories:["Back Pain","Sciatica","Muscle Tension"]},{id:13,name:"\u0aaa\u0ab5\u0aa8\u0aae\u0ac1\u0a95\u0acd\u0aa4\u0abe\u0ab8\u0aa8 (Pavanamuktasana) - Wind-Relieving Pose",image:o(13,"Pavanamuktasana"),description:"A supine pose that relieves lower back pain and improves digestion. Excellent for joint pain and arthritis.",advantages:["Relieves lower back pain","Improves digestion","Stretches lower back","Relieves gas and bloating","Strengthens core","Helps with joint pain"],disadvantages:["Avoid with severe back injuries","Not suitable during pregnancy","May cause discomfort with knee issues","Avoid with high blood pressure"],difficulty:"Beginner",duration:"30-60 seconds",subCategories:["Back Pain","Joint Pain","Arthritis"]},{id:14,name:"\u0aa4\u0acd\u0ab0\u0abf\u0a95\u0acb\u0aa3\u0abe\u0ab8\u0aa8 (Trikonasana) - Triangle Pose",image:o(14,"Trikonasana"),description:"A standing pose that strengthens legs and relieves back pain. Improves flexibility and balance.",advantages:["Strengthens legs","Stretches hamstrings and hips","Relieves back pain","Improves balance","Opens the chest","Stimulates abdominal organs"],disadvantages:["Avoid with low blood pressure","Not suitable with neck injuries","May cause dizziness","Can strain if overstretched"],difficulty:"Intermediate",duration:"30-60 seconds each side",subCategories:["Back Pain","Hip Pain","Muscle Tension"]},{id:15,name:"\u0a85\u0aa7\u0acb \u0aae\u0ac1\u0a96 \u0ab6\u0acd\u0ab5\u0abe\u0aa8\u0abe\u0ab8\u0aa8 (Adho Mukha Svanasana) - Downward-Facing Dog",image:o(15,"Adho Mukha Svanasana"),description:"An inversion that strengthens the entire body and relieves back pain. Excellent for shoulder and neck tension.",advantages:["Strengthens arms and legs","Stretches hamstrings and calves","Relieves back pain","Improves circulation","Calms the mind","Relieves shoulder tension"],disadvantages:["Avoid with wrist injuries","Not suitable with high blood pressure","May cause strain with shoulder issues","Avoid during late pregnancy"],difficulty:"Beginner",duration:"30-60 seconds",subCategories:["Back Pain","Shoulder Pain","Neck Pain"]}],"disease-specific":[{id:16,name:"\u0ab8\u0ac2\u0ab0\u0acd\u0aaf \u0aa8\u0aae\u0ab8\u0acd\u0a95\u0abe\u0ab0 (Surya Namaskar) - Sun Salutation",image:o(16,"Surya Namaskar"),description:"A complete sequence of 12 poses that provides a full-body workout. Excellent for diabetes management and cardiovascular health.",advantages:["Helps control blood sugar levels","Improves cardiovascular health","Boosts metabolism","Enhances flexibility","Reduces stress","Improves circulation"],disadvantages:["Avoid with severe heart conditions","Not recommended during pregnancy","May cause fatigue if overdone","Requires good physical condition"],difficulty:"Intermediate",duration:"5-10 minutes",subCategories:["Diabetes","Heart Health"]},{id:17,name:"\u0ab8\u0ab0\u0acd\u0ab5\u0abe\u0a82\u0a97\u0abe\u0ab8\u0aa8 (Sarvangasana) - Shoulder Stand",image:o(17,"Sarvangasana"),description:"An inverted pose that stimulates the thyroid gland and improves blood circulation. Beneficial for thyroid disorders.",advantages:["Stimulates thyroid gland","Improves blood circulation","Relieves stress and anxiety","Strengthens shoulders and arms","Improves digestion","Calms the nervous system"],disadvantages:["Avoid with neck injuries","Not suitable for high blood pressure","Avoid during menstruation","Not recommended for glaucoma","Requires proper technique"],difficulty:"Advanced",duration:"1-3 minutes",subCategories:["Thyroid","Blood Pressure"]},{id:18,name:"\u0ab9\u0ab2\u0abe\u0ab8\u0aa8 (Halasana) - Plow Pose",image:o(18,"Halasana"),description:"An inverted pose that stimulates the thyroid gland and improves digestion. Beneficial for diabetes and thyroid disorders.",advantages:["Stimulates thyroid gland","Improves digestion","Stretches the spine","Calms the nervous system","Helps with diabetes","Reduces stress"],disadvantages:["Avoid with neck injuries","Not suitable during menstruation","Avoid with high blood pressure","Requires flexibility","Not for beginners"],difficulty:"Advanced",duration:"1-3 minutes",subCategories:["Thyroid","Diabetes","Digestive Issues"]},{id:19,name:"\u0aa7\u0aa8\u0ac1\u0ab0\u0abe\u0ab8\u0aa8 (Dhanurasana) - Bow Pose",image:o(19,"Dhanurasana"),description:"A backbend that stimulates abdominal organs and improves digestion. Excellent for diabetes and digestive issues.",advantages:["Stimulates abdominal organs","Improves digestion","Strengthens back muscles","Opens the chest","Helps with diabetes","Reduces belly fat"],disadvantages:["Avoid with severe back injuries","Not suitable during pregnancy","Avoid with high blood pressure","May strain neck if done incorrectly"],difficulty:"Intermediate",duration:"20-30 seconds",subCategories:["Diabetes","Digestive Issues"]},{id:20,name:"\u0aad\u0ab8\u0acd\u0aa4\u0acd\u0ab0\u0abf\u0a95\u0abe \u0aaa\u0acd\u0ab0\u0abe\u0aa3\u0abe\u0aaf\u0abe\u0aae (Bhastrika Pranayama) - Bellows Breath",image:o(20,"Bhastrika Pranayama"),description:"A powerful breathing technique that improves lung capacity and helps with asthma. Boosts energy and metabolism.",advantages:["Improves lung capacity","Helps with asthma","Boosts metabolism","Increases energy","Improves circulation","Strengthens respiratory system"],disadvantages:["Avoid with high blood pressure","Not suitable with heart conditions","May cause dizziness","Avoid during pregnancy","Not for beginners"],difficulty:"Intermediate",duration:"2-5 minutes",subCategories:["Asthma","Heart Health","Immune System"]},{id:21,name:"\u0a95\u0aaa\u0abe\u0ab2\u0aad\u0abe\u0aa4\u0abf \u0aaa\u0acd\u0ab0\u0abe\u0aa3\u0abe\u0aaf\u0abe\u0aae (Kapalbhati Pranayama) - Skull Shining Breath",image:o(21,"Kapalbhati Pranayama"),description:"A cleansing breathing technique that helps control diabetes and improves digestion. Strengthens abdominal muscles.",advantages:["Helps control diabetes","Improves digestion","Strengthens abdominal muscles","Cleanses respiratory system","Boosts metabolism","Improves focus"],disadvantages:["Avoid with high blood pressure","Not suitable with heart problems","Avoid during pregnancy","May cause dizziness","Not for beginners"],difficulty:"Intermediate",duration:"2-5 minutes",subCategories:["Diabetes","Digestive Issues","Immune System"]},{id:22,name:"\u0aae\u0aa4\u0acd\u0ab8\u0acd\u0aaf\u0abe\u0ab8\u0aa8 (Matsyasana) - Fish Pose",image:o(22,"Matsyasana"),description:"A backbend that opens the chest and improves breathing. Beneficial for asthma and respiratory issues.",advantages:["Opens the chest","Improves breathing","Stretches hip flexors","Stimulates thyroid","Helps with asthma","Relieves neck tension"],disadvantages:["Avoid with neck injuries","Not suitable with high blood pressure","Avoid during late pregnancy","May strain lower back"],difficulty:"Beginner",duration:"30-60 seconds",subCategories:["Asthma","Thyroid","Heart Health"]},{id:23,name:"\u0ab5\u0a9c\u0acd\u0ab0\u0abe\u0ab8\u0aa8 (Vajrasana) - Thunderbolt Pose",image:o(23,"Vajrasana"),description:"A seated pose that improves digestion and helps control diabetes. Excellent for meditation and pranayama.",advantages:["Improves digestion","Helps with diabetes","Strengthens thigh muscles","Calms the mind","Improves posture","Aids in meditation"],disadvantages:["Avoid with knee injuries","Not suitable with ankle problems","May cause discomfort initially","Can strain knees if held too long"],difficulty:"Beginner",duration:"5-30 minutes",subCategories:["Diabetes","Digestive Issues"]},{id:24,name:"\u0aaa\u0ab6\u0acd\u0a9a\u0abf\u0aae\u0acb\u0aa4\u0acd\u0aa4\u0abe\u0aa8\u0abe\u0ab8\u0aa8 (Paschimottanasana) - Seated Forward Bend",image:o(24,"Paschimottanasana"),description:"A forward fold that stimulates abdominal organs and helps with diabetes. Calms the nervous system.",advantages:["Stimulates abdominal organs","Helps with diabetes","Calms nervous system","Improves digestion","Stretches entire back","Reduces stress"],disadvantages:["Avoid with severe back injuries","Not suitable with disc problems","Avoid during pregnancy","May cause strain if forced"],difficulty:"Beginner",duration:"1-3 minutes",subCategories:["Diabetes","Digestive Issues","Heart Health"]},{id:25,name:"\u0a89\u0ab7\u0acd\u0a9f\u0acd\u0ab0\u0abe\u0ab8\u0aa8 (Ustrasana) - Camel Pose",image:o(25,"Ustrasana"),description:"A deep backbend that opens the chest and improves breathing. Beneficial for asthma and respiratory health.",advantages:["Opens the chest","Improves breathing","Stretches hip flexors","Strengthens back","Helps with asthma","Stimulates thyroid"],disadvantages:["Avoid with neck injuries","Not suitable with high blood pressure","Avoid during pregnancy","May strain lower back"],difficulty:"Intermediate",duration:"30-60 seconds",subCategories:["Asthma","Thyroid","Heart Health"]},{id:26,name:"\u0aa8\u0abe\u0aa1\u0ac0 \u0ab6\u0acb\u0aa7\u0aa8 \u0aaa\u0acd\u0ab0\u0abe\u0aa3\u0abe\u0aaf\u0abe\u0aae (Nadi Shodhana Pranayama) - Alternate Nostril Breathing",image:o(26,"Nadi Shodhana Pranayama"),description:"A balancing breathing technique that regulates blood pressure and calms the mind. Excellent for heart health.",advantages:["Regulates blood pressure","Calms the mind","Balances nervous system","Improves focus","Reduces stress","Benefits heart health"],disadvantages:["Avoid with blocked nostrils","Not suitable during illness","May cause dizziness if done incorrectly","Requires proper technique"],difficulty:"Beginner",duration:"5-10 minutes",subCategories:["Blood Pressure (BP)","Heart Health","Immune System"]},{id:27,name:"\u0ab8\u0ac1\u0aaa\u0acd\u0aa4 \u0aac\u0aa6\u0acd\u0aa7 \u0a95\u0acb\u0aa8\u0abe\u0ab8\u0aa8 (Supta Baddha Konasana) - Reclining Bound Angle Pose",image:o(27,"Supta Baddha Konasana"),description:"A restorative pose that helps with PCOS and hormonal balance. Calms the nervous system and reduces stress.",advantages:["Helps with PCOS","Improves hormonal balance","Stretches inner thighs","Calms nervous system","Reduces stress","Improves circulation"],disadvantages:["Avoid with knee injuries","Not suitable with groin injuries","May cause discomfort with tight hips","Use props if needed"],difficulty:"Beginner",duration:"3-10 minutes",subCategories:["PCOS","Hormonal Balance","Immune System"]},{id:28,name:"\u0aac\u0aa6\u0acd\u0aa7 \u0a95\u0acb\u0aa8\u0abe\u0ab8\u0aa8 (Baddha Konasana) - Butterfly Pose",image:o(28,"Baddha Konasana"),description:"A seated pose that helps with PCOS and improves reproductive health. Stretches inner thighs and groin.",advantages:["Helps with PCOS","Improves reproductive health","Stretches inner thighs","Stimulates abdominal organs","Improves flexibility","Calms the mind"],disadvantages:["Avoid with knee injuries","Not suitable with groin problems","May cause discomfort initially","Use props for support"],difficulty:"Beginner",duration:"1-5 minutes",subCategories:["PCOS","Hormonal Balance"]},{id:29,name:"\u0ab6\u0ab5\u0abe\u0ab8\u0aa8 (Shavasana) - Corpse Pose",image:o(29,"Shavasana"),description:"A restorative pose that reduces blood pressure and calms the entire system. Essential for heart health.",advantages:["Reduces blood pressure","Calms entire system","Reduces stress","Improves heart health","Promotes relaxation","Enhances recovery"],disadvantages:["May cause sleepiness","Not suitable if feeling unwell","Keep warm during practice","Avoid if very tired"],difficulty:"Beginner",duration:"5-20 minutes",subCategories:["Blood Pressure (BP)","Heart Health","Immune System"]},{id:30,name:"\u0ab5\u0abf\u0aaa\u0ab0\u0ac0\u0aa4 \u0a95\u0ab0\u0aa3\u0ac0 (Viparita Karani) - Legs-Up-the-Wall Pose",image:o(30,"Viparita Karani"),description:"A gentle inversion that improves circulation and helps with blood pressure. Calms the nervous system.",advantages:["Improves circulation","Helps with blood pressure","Reduces leg swelling","Calms nervous system","Relieves stress","Benefits heart health"],disadvantages:["Avoid with eye pressure issues","Not suitable during menstruation","May cause discomfort with neck issues","Avoid if feeling dizzy"],difficulty:"Beginner",duration:"5-15 minutes",subCategories:["Blood Pressure (BP)","Heart Health","Immune System"]},{id:31,name:"\u0a85\u0ab0\u0acd\u0aa7 \u0a9a\u0a82\u0aa6\u0acd\u0ab0\u0abe\u0ab8\u0aa8 (Ardha Chandrasana) - Half Moon Pose",image:o(31,"Ardha Chandrasana"),description:"A balancing pose that improves circulation and strengthens the immune system. Enhances coordination and focus.",advantages:["Improves circulation","Strengthens immune system","Improves balance","Strengthens legs","Stretches hamstrings","Enhances focus"],disadvantages:["Avoid with low blood pressure","Not suitable with balance issues","May cause dizziness","Requires good flexibility"],difficulty:"Intermediate",duration:"30-60 seconds each side",subCategories:["Immune System","Heart Health"]},{id:32,name:"\u0a89\u0aa4\u0acd\u0a95\u0a9f\u0abe\u0ab8\u0aa8 (Utkatasana) - Chair Pose",image:o(32,"Utkatasana"),description:"A strengthening pose that improves metabolism and helps with diabetes. Builds endurance and strength.",advantages:["Improves metabolism","Helps with diabetes","Strengthens legs","Builds endurance","Tones muscles","Improves balance"],disadvantages:["Avoid with knee injuries","Not suitable with low blood pressure","May cause strain if held too long","Can be challenging for beginners"],difficulty:"Intermediate",duration:"30-60 seconds",subCategories:["Diabetes","Heart Health","Immune System"]}],"mental-health":[{id:33,name:"\u0aac\u0abe\u0ab2\u0abe\u0ab8\u0aa8 (Balasana) - Child's Pose",image:o(33,"Balasana"),description:"A restorative pose that calms the mind and relieves stress. Perfect for anxiety and stress management.",advantages:["Reduces stress and anxiety","Calms the mind","Stretches hips and thighs","Relieves back pain","Promotes relaxation","Improves sleep quality"],disadvantages:["Avoid with knee injuries","Not suitable during pregnancy","May cause discomfort with ankle issues","Can be difficult with tight hips"],difficulty:"Beginner",duration:"1-3 minutes",subCategories:["Stress Relief","Anxiety Management"]},{id:34,name:"\u0aaa\u0aa6\u0acd\u0aae\u0abe\u0ab8\u0aa8 (Padmasana) - Lotus Pose",image:o(34,"Padmasana"),description:"The classic meditation pose that promotes mental clarity and focus. Ideal for meditation and concentration practices.",advantages:["Improves focus and concentration","Calms the mind","Opens hips","Improves posture","Reduces anxiety","Enhances meditation practice"],disadvantages:["Requires flexible hips","Can strain knees if forced","Not suitable for knee injuries","May cause ankle discomfort","Difficult for beginners"],difficulty:"Intermediate",duration:"5-30 minutes",subCategories:["Focus & Concentration","Meditation"]},{id:35,name:"\u0ab6\u0ab5\u0abe\u0ab8\u0aa8 (Shavasana) - Corpse Pose",image:o(35,"Shavasana"),description:"The ultimate relaxation pose that calms the mind and reduces stress. Essential for mental health and sleep quality.",advantages:["Reduces stress and anxiety","Calms the mind","Improves sleep quality","Promotes deep relaxation","Reduces blood pressure","Enhances recovery"],disadvantages:["May cause sleepiness","Keep warm during practice","Not suitable if feeling unwell","Avoid if very tired"],difficulty:"Beginner",duration:"5-20 minutes",subCategories:["Stress Relief","Sleep Disorders","Emotional Balance"]},{id:36,name:"\u0ab5\u0abf\u0aaa\u0ab0\u0ac0\u0aa4 \u0a95\u0ab0\u0aa3\u0ac0 (Viparita Karani) - Legs-Up-the-Wall Pose",image:o(36,"Viparita Karani"),description:"A restorative inversion that calms the nervous system and reduces anxiety. Excellent for stress relief and sleep.",advantages:["Reduces anxiety","Calms nervous system","Improves sleep","Reduces stress","Relieves fatigue","Promotes relaxation"],disadvantages:["Avoid with eye pressure issues","Not suitable during menstruation","May cause discomfort with neck issues","Avoid if feeling dizzy"],difficulty:"Beginner",duration:"5-15 minutes",subCategories:["Stress Relief","Anxiety Management","Sleep Disorders"]},{id:37,name:"\u0a85\u0aa8\u0ac1\u0ab2\u0acb\u0aae \u0ab5\u0abf\u0ab2\u0acb\u0aae \u0aaa\u0acd\u0ab0\u0abe\u0aa3\u0abe\u0aaf\u0abe\u0aae (Anulom Vilom Pranayama) - Alternate Nostril Breathing",image:o(37,"Anulom Vilom Pranayama"),description:"A balancing breathing technique that calms the mind and reduces stress. Excellent for anxiety and emotional balance.",advantages:["Reduces stress and anxiety","Calms the mind","Balances emotions","Improves focus","Reduces depression symptoms","Enhances mental clarity"],disadvantages:["Avoid with blocked nostrils","Not suitable during illness","May cause dizziness if done incorrectly","Requires proper technique"],difficulty:"Beginner",duration:"5-10 minutes",subCategories:["Stress Relief","Anxiety Management","Depression Support","Emotional Balance"]},{id:38,name:"\u0aad\u0acd\u0ab0\u0aae\u0ab0\u0ac0 \u0aaa\u0acd\u0ab0\u0abe\u0aa3\u0abe\u0aaf\u0abe\u0aae (Bhramari Pranayama) - Bee Breath",image:o(38,"Bhramari Pranayama"),description:"A calming breathing technique that reduces anxiety and promotes sleep. Excellent for stress relief and emotional balance.",advantages:["Reduces anxiety","Promotes sleep","Calms the mind","Reduces stress","Improves focus","Balances emotions"],disadvantages:["Avoid with ear infections","Not suitable with severe sinus issues","May cause discomfort initially","Practice in quiet environment"],difficulty:"Beginner",duration:"5-10 minutes",subCategories:["Anxiety Management","Sleep Disorders","Stress Relief","Emotional Balance"]},{id:39,name:"\u0ab8\u0ac1\u0a96\u0abe\u0ab8\u0aa8 (Sukhasana) - Easy Pose",image:o(39,"Sukhasana"),description:"A comfortable seated pose for meditation that calms the mind and improves focus. Perfect for beginners.",advantages:["Calms the mind","Improves focus","Reduces stress","Improves posture","Easy for beginners","Enhances meditation"],disadvantages:["May cause discomfort with tight hips","Use props for support","Avoid with knee injuries","Keep spine straight"],difficulty:"Beginner",duration:"5-30 minutes",subCategories:["Focus & Concentration","Meditation","Stress Relief"]},{id:40,name:"\u0ab5\u0ac0\u0ab0\u0abe\u0ab8\u0aa8 (Virasana) - Hero Pose",image:o(40,"Virasana"),description:"A seated pose that calms the mind and improves focus. Excellent for meditation and concentration practices.",advantages:["Calms the mind","Improves focus","Stretches thighs","Improves digestion","Reduces stress","Enhances meditation"],disadvantages:["Avoid with knee injuries","Not suitable with ankle problems","May cause discomfort initially","Use props if needed"],difficulty:"Beginner",duration:"5-30 minutes",subCategories:["Focus & Concentration","Meditation","Stress Relief"]},{id:41,name:"\u0a89\u0a9c\u0acd\u0a9c\u0abe\u0aaf\u0ac0 \u0aaa\u0acd\u0ab0\u0abe\u0aa3\u0abe\u0aaf\u0abe\u0aae (Ujjayi Pranayama) - Victorious Breath",image:o(41,"Ujjayi Pranayama"),description:"A calming breathing technique that reduces stress and improves focus. Excellent for anxiety management.",advantages:["Reduces stress","Improves focus","Calms the mind","Reduces anxiety","Enhances concentration","Balances emotions"],disadvantages:["Avoid with high blood pressure","Not suitable with heart conditions","May cause dizziness","Requires proper technique"],difficulty:"Beginner",duration:"5-10 minutes",subCategories:["Stress Relief","Anxiety Management","Focus & Concentration"]},{id:42,name:"\u0ab8\u0ac1\u0aaa\u0acd\u0aa4 \u0aae\u0aa4\u0acd\u0ab8\u0acd\u0aaf\u0ac7\u0aa8\u0acd\u0aa6\u0acd\u0ab0\u0abe\u0ab8\u0aa8 (Supta Matsyendrasana) - Supine Spinal Twist",image:o(42,"Supta Matsyendrasana"),description:"A gentle twist that calms the nervous system and reduces stress. Excellent for sleep and relaxation.",advantages:["Calms nervous system","Reduces stress","Improves sleep","Stretches spine","Relieves tension","Promotes relaxation"],disadvantages:["Avoid with severe back injuries","Not suitable during pregnancy","May cause discomfort with knee issues","Keep shoulders on ground"],difficulty:"Beginner",duration:"30-60 seconds each side",subCategories:["Stress Relief","Sleep Disorders","Emotional Balance"]},{id:43,name:"\u0aae\u0aa4\u0acd\u0ab8\u0acd\u0aaf\u0abe\u0ab8\u0aa8 (Matsyasana) - Fish Pose",image:o(43,"Matsyasana"),description:"A backbend that opens the heart and reduces depression. Calms the mind and improves emotional balance.",advantages:["Reduces depression","Opens the heart","Calms the mind","Improves emotional balance","Stretches chest","Reduces stress"],disadvantages:["Avoid with neck injuries","Not suitable with high blood pressure","Avoid during late pregnancy","May strain lower back"],difficulty:"Beginner",duration:"30-60 seconds",subCategories:["Depression Support","Emotional Balance","Stress Relief"]},{id:44,name:"\u0ab8\u0ac7\u0aa4\u0ac1 \u0aac\u0a82\u0aa7\u0abe\u0ab8\u0aa8 (Setu Bandhasana) - Bridge Pose",image:o(44,"Setu Bandhasana"),description:"A gentle backbend that calms the mind and reduces anxiety. Excellent for stress relief and sleep.",advantages:["Reduces anxiety","Calms the mind","Improves sleep","Reduces stress","Opens the chest","Promotes relaxation"],disadvantages:["Avoid with neck injuries","Not suitable with severe back problems","Avoid during late pregnancy","May strain knees if misaligned"],difficulty:"Beginner",duration:"30-60 seconds",subCategories:["Anxiety Management","Sleep Disorders","Stress Relief"]},{id:45,name:"\u0aa8\u0abe\u0aa1\u0ac0 \u0ab6\u0acb\u0aa7\u0aa8 (Nadi Shodhana) - Alternate Nostril Breathing",image:o(45,"Nadi Shodhana"),description:"A balancing breathing technique that reduces stress and improves emotional balance. Excellent for depression support.",advantages:["Reduces stress","Improves emotional balance","Reduces depression symptoms","Calms the mind","Enhances focus","Balances nervous system"],disadvantages:["Avoid with blocked nostrils","Not suitable during illness","May cause dizziness if done incorrectly","Requires proper technique"],difficulty:"Beginner",duration:"5-10 minutes",subCategories:["Depression Support","Emotional Balance","Stress Relief"]},{id:46,name:"\u0ab6\u0ac0\u0aa4\u0ab2\u0ac0 \u0aaa\u0acd\u0ab0\u0abe\u0aa3\u0abe\u0aaf\u0abe\u0aae (Shitali Pranayama) - Cooling Breath",image:o(46,"Shitali Pranayama"),description:"A cooling breathing technique that calms the mind and reduces stress. Excellent for anxiety and emotional balance.",advantages:["Calms the mind","Reduces stress","Reduces anxiety","Cools the body","Improves focus","Balances emotions"],disadvantages:["Avoid in cold weather","Not suitable with respiratory issues","May cause discomfort initially","Practice in comfortable temperature"],difficulty:"Beginner",duration:"5-10 minutes",subCategories:["Anxiety Management","Stress Relief","Emotional Balance"]},{id:47,name:"\u0aaf\u0acb\u0a97 \u0aa8\u0abf\u0aa6\u0acd\u0ab0\u0abe (Yoga Nidra) - Yogic Sleep",image:o(47,"Yoga Nidra"),description:"A deep relaxation practice that reduces stress and improves sleep. Excellent for depression and anxiety management.",advantages:["Reduces stress","Improves sleep quality","Reduces anxiety","Helps with depression","Promotes deep relaxation","Enhances recovery"],disadvantages:["May cause deep sleep","Practice in quiet environment","Not suitable if very tired","Keep warm during practice"],difficulty:"Beginner",duration:"20-45 minutes",subCategories:["Sleep Disorders","Depression Support","Stress Relief","Anxiety Management"]}],"fitness-goals":[{id:48,name:"\u0a9a\u0aa4\u0ac1\u0ab0\u0a82\u0a97 \u0aa6\u0a82\u0aa1\u0abe\u0ab8\u0aa8 (Chaturanga Dandasana) - Four-Limbed Staff Pose",image:o(48,"Chaturanga Dandasana"),description:"A challenging arm balance that builds upper body strength and core stability. Excellent for weight loss and muscle toning.",advantages:["Builds upper body strength","Strengthens core muscles","Tones arms and shoulders","Improves balance","Burns calories","Builds endurance"],disadvantages:["Requires significant upper body strength","Can strain wrists","Not suitable for shoulder injuries","May cause lower back strain","Difficult for beginners"],difficulty:"Advanced",duration:"10-30 seconds",subCategories:["Strength Building","Weight Loss"]},{id:49,name:"\u0ab8\u0ac2\u0ab0\u0acd\u0aaf \u0aa8\u0aae\u0ab8\u0acd\u0a95\u0abe\u0ab0 (Surya Namaskar) - Sun Salutation",image:o(49,"Surya Namaskar"),description:"A complete sequence of 12 poses that provides a full-body workout. Excellent for weight loss and cardio fitness.",advantages:["Burns calories","Improves cardio fitness","Enhances flexibility","Strengthens entire body","Boosts metabolism","Improves circulation"],disadvantages:["Avoid with severe heart conditions","Not recommended during pregnancy","May cause fatigue if overdone","Requires good physical condition"],difficulty:"Intermediate",duration:"5-10 minutes",subCategories:["Weight Loss","Cardio Fitness","Body Sculpting"]},{id:50,name:"\u0a89\u0aa4\u0acd\u0a95\u0a9f\u0abe\u0ab8\u0aa8 (Utkatasana) - Chair Pose",image:o(50,"Utkatasana"),description:"A strengthening pose that builds leg and core strength. Excellent for weight loss and muscle toning.",advantages:["Burns calories","Strengthens legs","Tones muscles","Builds endurance","Improves balance","Strengthens core"],disadvantages:["Avoid with knee injuries","Not suitable with low blood pressure","May cause strain if held too long","Can be challenging for beginners"],difficulty:"Intermediate",duration:"30-60 seconds",subCategories:["Weight Loss","Strength Building","Muscle Tone"]},{id:51,name:"\u0aa8\u0abe\u0ab5\u0abe\u0ab8\u0aa8 (Navasana) - Boat Pose",image:o(51,"Navasana"),description:"A core strengthening pose that tones abdominal muscles. Excellent for weight loss and core strength.",advantages:["Strengthens core","Tones abdominal muscles","Burns calories","Improves balance","Strengthens hip flexors","Improves digestion"],disadvantages:["Avoid with lower back injuries","Not suitable during pregnancy","May cause strain if forced","Requires core strength"],difficulty:"Intermediate",duration:"20-40 seconds",subCategories:["Core Strength","Weight Loss","Body Sculpting"]},{id:52,name:"\u0aab\u0ab2\u0a95\u0abe\u0ab8\u0aa8 (Phalakasana) - Plank Pose",image:o(52,"Phalakasana"),description:"A full-body strengthening pose that builds core and upper body strength. Excellent for muscle toning.",advantages:["Strengthens entire body","Builds core strength","Tones arms and shoulders","Burns calories","Improves posture","Builds endurance"],disadvantages:["Avoid with wrist injuries","Not suitable with shoulder problems","May cause strain if held too long","Requires upper body strength"],difficulty:"Intermediate",duration:"20-60 seconds",subCategories:["Core Strength","Strength Building","Muscle Tone"]},{id:53,name:"\u0ab5\u0ac0\u0ab0\u0aad\u0aa6\u0acd\u0ab0\u0abe\u0ab8\u0aa8 I (Virabhadrasana I) - Warrior I",image:o(53,"Virabhadrasana I"),description:"A powerful standing pose that builds strength and stamina. Excellent for weight loss and muscle building.",advantages:["Strengthens legs","Builds stamina","Tones muscles","Burns calories","Improves balance","Opens hips"],disadvantages:["Avoid with knee injuries","Not suitable with high blood pressure","May cause strain if overdone","Can be challenging"],difficulty:"Intermediate",duration:"30-60 seconds each side",subCategories:["Strength Building","Weight Loss","Muscle Tone"]},{id:54,name:"\u0ab9\u0aa8\u0ac1\u0aae\u0abe\u0aa8\u0abe\u0ab8\u0aa8 (Hanumanasana) - Monkey Pose/Splits",image:o(54,"Hanumanasana"),description:"An advanced flexibility pose that stretches hamstrings and hip flexors. Excellent for flexibility training.",advantages:["Improves flexibility","Stretches hamstrings","Opens hip flexors","Strengthens legs","Improves balance","Enhances range of motion"],disadvantages:["Requires significant flexibility","Avoid with hamstring injuries","Not suitable with hip problems","Very challenging for beginners"],difficulty:"Advanced",duration:"30-60 seconds each side",subCategories:["Flexibility","Body Sculpting"]},{id:55,name:"\u0a8f\u0a95 \u0aaa\u0aa6 \u0ab0\u0abe\u0a9c\u0a95\u0aaa\u0acb\u0aa4\u0abe\u0ab8\u0aa8 (Eka Pada Rajakapotasana) - Pigeon Pose",image:o(55,"Eka Pada Rajakapotasana"),description:"A deep hip opener that improves flexibility. Excellent for flexibility and body sculpting.",advantages:["Opens hips","Improves flexibility","Stretches hip flexors","Relieves tension","Improves posture","Enhances range of motion"],disadvantages:["Avoid with knee injuries","Not suitable with hip problems","May cause discomfort initially","Use props for support"],difficulty:"Intermediate",duration:"1-3 minutes each side",subCategories:["Flexibility","Body Sculpting"]},{id:56,name:"\u0aa7\u0aa8\u0ac1\u0ab0\u0abe\u0ab8\u0aa8 (Dhanurasana) - Bow Pose",image:o(56,"Dhanurasana"),description:"A backbend that strengthens back muscles and improves flexibility. Excellent for strength and flexibility.",advantages:["Strengthens back","Improves flexibility","Tones muscles","Opens chest","Stimulates organs","Builds strength"],disadvantages:["Avoid with severe back injuries","Not suitable during pregnancy","Avoid with high blood pressure","May strain neck if done incorrectly"],difficulty:"Intermediate",duration:"20-30 seconds",subCategories:["Strength Building","Flexibility","Body Sculpting"]},{id:57,name:"\u0a85\u0aa7\u0acb \u0aae\u0ac1\u0a96 \u0ab5\u0ac3\u0a95\u0acd\u0ab7\u0abe\u0ab8\u0aa8 (Adho Mukha Vrksasana) - Handstand",image:o(57,"Adho Mukha Vrksasana"),description:"An advanced inversion that builds upper body and core strength. Excellent for strength building and body sculpting.",advantages:["Builds upper body strength","Strengthens core","Improves balance","Tones entire body","Builds confidence","Enhances coordination"],disadvantages:["Requires significant strength","Avoid with wrist injuries","Not suitable with high blood pressure","Very challenging","Requires proper technique"],difficulty:"Advanced",duration:"10-30 seconds",subCategories:["Strength Building","Body Sculpting"]},{id:58,name:"\u0aac\u0a95\u0abe\u0ab8\u0aa8 (Bakasana) - Crow Pose",image:o(58,"Bakasana"),description:"An arm balance that builds upper body and core strength. Excellent for strength building and muscle toning.",advantages:["Builds upper body strength","Strengthens core","Improves balance","Tones arms","Builds confidence","Enhances coordination"],disadvantages:["Requires upper body strength","Avoid with wrist injuries","Not suitable with shoulder problems","Challenging for beginners"],difficulty:"Intermediate",duration:"10-30 seconds",subCategories:["Strength Building","Muscle Tone","Core Strength"]},{id:59,name:"\u0a8a\u0ab0\u0acd\u0aa7\u0acd\u0ab5 \u0aa7\u0aa8\u0ac1\u0ab0\u0abe\u0ab8\u0aa8 (Urdhva Dhanurasana) - Wheel Pose",image:o(59,"Urdhva Dhanurasana"),description:"An advanced backbend that builds strength and flexibility. Excellent for body sculpting and flexibility.",advantages:["Builds strength","Improves flexibility","Opens chest","Strengthens arms and legs","Tones entire body","Enhances energy"],disadvantages:["Requires significant flexibility","Avoid with back injuries","Not suitable with high blood pressure","Very challenging","Requires proper technique"],difficulty:"Advanced",duration:"10-30 seconds",subCategories:["Flexibility","Strength Building","Body Sculpting"]},{id:60,name:"\u0aa4\u0acd\u0ab0\u0abf\u0a95\u0acb\u0aa3\u0abe\u0ab8\u0aa8 (Trikonasana) - Triangle Pose",image:o(60,"Trikonasana"),description:"A standing pose that improves flexibility and strengthens legs. Excellent for flexibility and muscle toning.",advantages:["Improves flexibility","Strengthens legs","Stretches hamstrings","Tones muscles","Improves balance","Opens hips"],disadvantages:["Avoid with low blood pressure","Not suitable with neck injuries","May cause dizziness","Can strain if overstretched"],difficulty:"Intermediate",duration:"30-60 seconds each side",subCategories:["Flexibility","Muscle Tone","Body Sculpting"]},{id:61,name:"\u0aaa\u0ab0\u0abf\u0ab5\u0ac3\u0aa4\u0acd\u0aa4 \u0aa4\u0acd\u0ab0\u0abf\u0a95\u0acb\u0aa3\u0abe\u0ab8\u0aa8 (Parivrtta Trikonasana) - Revolved Triangle Pose",image:o(61,"Parivrtta Trikonasana"),description:"A twisting pose that improves flexibility and strengthens core. Excellent for flexibility and core strength.",advantages:["Improves flexibility","Strengthens core","Stretches hamstrings","Tones muscles","Improves balance","Stimulates organs"],disadvantages:["Avoid with low blood pressure","Not suitable with back injuries","May cause dizziness","Requires good flexibility"],difficulty:"Intermediate",duration:"30-60 seconds each side",subCategories:["Flexibility","Core Strength","Body Sculpting"]},{id:62,name:"\u0ab5\u0ab8\u0abf\u0ab7\u0acd\u0aa0\u0abe\u0ab8\u0aa8 (Vasisthasana) - Side Plank Pose",image:o(62,"Vasisthasana"),description:"A side plank that builds core and arm strength. Excellent for core strength and muscle toning.",advantages:["Strengthens core","Builds arm strength","Tones muscles","Improves balance","Strengthens obliques","Burns calories"],disadvantages:["Avoid with wrist injuries","Not suitable with shoulder problems","May cause strain if held too long","Requires core strength"],difficulty:"Intermediate",duration:"20-40 seconds each side",subCategories:["Core Strength","Muscle Tone","Strength Building"]}],"age-groups":[{id:58,name:"\u0aa4\u0abe\u0aa1\u0abe\u0ab8\u0aa8 (Tadasana) - Mountain Pose",image:o(58,"Tadasana"),description:"A foundational standing pose perfect for all ages. Improves posture and balance. Safe for kids, teens, adults, and seniors.",advantages:["Improves posture","Strengthens thighs","Promotes balance","Safe for all ages","Easy to learn","Builds body awareness"],disadvantages:["May seem too simple","Requires focus","Keep feet grounded","Maintain alignment"],difficulty:"Beginner",duration:"30-60 seconds",subCategories:["Kids Yoga (5-12 years)","Teens Yoga (13-19 years)","Adults (20-50 years)","Seniors (50+ years)"]},{id:59,name:"\u0ab5\u0ac3\u0a95\u0acd\u0ab7\u0abe\u0ab8\u0aa8 (Vrikshasana) - Tree Pose",image:o(59,"Vrikshasana"),description:"A fun balancing pose perfect for kids and teens. Improves focus and balance. Can be modified for seniors.",advantages:["Improves balance","Strengthens legs","Enhances focus","Fun for kids","Builds confidence","Opens hips"],disadvantages:["Avoid with balance issues","Not suitable with knee injuries","May cause falls","Use wall support if needed"],difficulty:"Beginner",duration:"20-40 seconds each side",subCategories:["Kids Yoga (5-12 years)","Teens Yoga (13-19 years)","Adults (20-50 years)"]},{id:60,name:"\u0aac\u0abe\u0ab2\u0abe\u0ab8\u0aa8 (Balasana) - Child's Pose",image:o(60,"Balasana"),description:"A gentle resting pose suitable for all ages. Calms the mind and stretches the back. Perfect for kids and seniors.",advantages:["Calms the mind","Stretches back","Safe for all ages","Easy to do","Promotes relaxation","Reduces stress"],disadvantages:["Avoid with knee injuries","Not suitable during pregnancy","May cause discomfort with tight hips","Use props if needed"],difficulty:"Beginner",duration:"1-3 minutes",subCategories:["Kids Yoga (5-12 years)","Teens Yoga (13-19 years)","Adults (20-50 years)","Seniors (50+ years)"]},{id:61,name:"\u0aae\u0abe\u0ab0\u0acd\u0a9c\u0ab0\u0ac0\u0a86\u0ab8\u0aa8 (Marjariasana) - Cat-Cow Pose",image:o(61,"Marjariasana"),description:"A fun flowing movement perfect for kids. Warms up the spine and improves flexibility. Safe for all ages.",advantages:["Warms up spine","Improves flexibility","Fun for kids","Safe for all ages","Reduces stress","Easy to learn"],disadvantages:["Avoid with severe neck injuries","May cause discomfort with wrist issues","Not suitable during late pregnancy","Move slowly"],difficulty:"Beginner",duration:"1-2 minutes",subCategories:["Kids Yoga (5-12 years)","Teens Yoga (13-19 years)","Adults (20-50 years)","Seniors (50+ years)"]},{id:62,name:"\u0aad\u0ac1\u0a9c\u0a82\u0a97\u0abe\u0ab8\u0aa8 (Bhujangasana) - Cobra Pose",image:o(62,"Bhujangasana"),description:"A gentle backbend suitable for teens and adults. Strengthens the spine and opens the chest. Can be modified for seniors.",advantages:["Strengthens spine","Opens chest","Improves posture","Suitable for teens and adults","Stretches front body","Builds strength"],disadvantages:["Avoid with severe back injuries","Not suitable during pregnancy","May cause strain if done incorrectly","Keep it gentle for seniors"],difficulty:"Beginner",duration:"30-60 seconds",subCategories:["Teens Yoga (13-19 years)","Adults (20-50 years)","Seniors (50+ years)"]},{id:63,name:"\u0ab5\u0ac0\u0ab0\u0aad\u0aa6\u0acd\u0ab0\u0abe\u0ab8\u0aa8 II (Virabhadrasana II) - Warrior II",image:o(63,"Virabhadrasana II"),description:"A powerful standing pose perfect for teens and adults. Builds strength and stamina. Can be modified for seniors.",advantages:["Strengthens legs","Builds stamina","Improves balance","Suitable for teens and adults","Opens hips","Builds confidence"],disadvantages:["Avoid with knee injuries","Not suitable with high blood pressure","May cause strain if overdone","Use props for seniors"],difficulty:"Intermediate",duration:"30-60 seconds",subCategories:["Teens Yoga (13-19 years)","Adults (20-50 years)"]},{id:64,name:"\u0ab8\u0ac1\u0a96\u0abe\u0ab8\u0aa8 (Sukhasana) - Easy Pose",image:o(64,"Sukhasana"),description:"A comfortable seated pose perfect for all ages. Excellent for meditation and breathing exercises. Safe for kids and seniors.",advantages:["Comfortable for all ages","Easy to do","Improves posture","Calms the mind","Safe for kids and seniors","Enhances meditation"],disadvantages:["May cause discomfort with tight hips","Use props for support","Avoid with knee injuries","Keep spine straight"],difficulty:"Beginner",duration:"5-30 minutes",subCategories:["Kids Yoga (5-12 years)","Teens Yoga (13-19 years)","Adults (20-50 years)","Seniors (50+ years)"]},{id:65,name:"\u0a85\u0aa7\u0acb \u0aae\u0ac1\u0a96 \u0ab6\u0acd\u0ab5\u0abe\u0aa8\u0abe\u0ab8\u0aa8 (Adho Mukha Svanasana) - Downward-Facing Dog",image:o(65,"Adho Mukha Svanasana"),description:"An inversion suitable for teens and adults. Strengthens the entire body. Can be modified for seniors with props.",advantages:["Strengthens entire body","Stretches hamstrings","Suitable for teens and adults","Improves circulation","Calms the mind","Builds strength"],disadvantages:["Avoid with wrist injuries","Not suitable with high blood pressure","May cause strain with shoulder issues","Use props for seniors"],difficulty:"Beginner",duration:"30-60 seconds",subCategories:["Teens Yoga (13-19 years)","Adults (20-50 years)"]},{id:66,name:"\u0ab5\u0abf\u0aaa\u0ab0\u0ac0\u0aa4 \u0a95\u0ab0\u0aa3\u0ac0 (Viparita Karani) - Legs-Up-the-Wall Pose",image:o(66,"Viparita Karani"),description:"A gentle restorative pose perfect for seniors. Relieves fatigue and improves circulation. Safe and comfortable.",advantages:["Gentle and safe","Perfect for seniors","Relieves fatigue","Improves circulation","Reduces stress","No strain on joints"],disadvantages:["Avoid with eye pressure issues","Not suitable during menstruation","May cause discomfort with neck issues","Keep warm"],difficulty:"Beginner",duration:"5-15 minutes",subCategories:["Adults (20-50 years)","Seniors (50+ years)"]},{id:67,name:"\u0ab8\u0ac7\u0aa4\u0ac1 \u0aac\u0a82\u0aa7\u0abe\u0ab8\u0aa8 (Setu Bandhasana) - Bridge Pose",image:o(67,"Setu Bandhasana"),description:"A gentle backbend suitable for adults and seniors. Strengthens the back and opens the chest. Can be modified easily.",advantages:["Gentle backbend","Suitable for adults and seniors","Strengthens back","Opens chest","Improves flexibility","Can be modified"],disadvantages:["Avoid with neck injuries","Not suitable with severe back problems","Avoid during late pregnancy","Use props if needed"],difficulty:"Beginner",duration:"30-60 seconds",subCategories:["Adults (20-50 years)","Seniors (50+ years)"]},{id:68,name:"\u0aa4\u0acd\u0ab0\u0abf\u0a95\u0acb\u0aa3\u0abe\u0ab8\u0aa8 (Trikonasana) - Triangle Pose",image:o(68,"Trikonasana"),description:"A standing pose suitable for teens and adults. Improves flexibility and strength. Can be modified for seniors.",advantages:["Improves flexibility","Strengthens legs","Suitable for teens and adults","Opens hips","Improves balance","Can be modified"],disadvantages:["Avoid with low blood pressure","Not suitable with neck injuries","May cause dizziness","Use props for seniors"],difficulty:"Intermediate",duration:"30-60 seconds each side",subCategories:["Teens Yoga (13-19 years)","Adults (20-50 years)"]},{id:69,name:"\u0ab6\u0ab5\u0abe\u0ab8\u0aa8 (Shavasana) - Corpse Pose",image:o(69,"Shavasana"),description:"The ultimate relaxation pose perfect for all ages. Essential for recovery and relaxation. Safe for everyone.",advantages:["Perfect for all ages","Promotes relaxation","Reduces stress","Essential for recovery","Safe and comfortable","No physical strain"],disadvantages:["May cause sleepiness","Keep warm","Not suitable if feeling unwell","Practice in quiet environment"],difficulty:"Beginner",duration:"5-20 minutes",subCategories:["Kids Yoga (5-12 years)","Teens Yoga (13-19 years)","Adults (20-50 years)","Seniors (50+ years)"]},{id:70,name:"\u0ab8\u0ac2\u0ab0\u0acd\u0aaf \u0aa8\u0aae\u0ab8\u0acd\u0a95\u0abe\u0ab0 (Surya Namaskar) - Sun Salutation",image:o(70,"Surya Namaskar"),description:"A complete sequence perfect for teens and adults. Provides full-body workout. Can be simplified for seniors.",advantages:["Full-body workout","Suitable for teens and adults","Improves flexibility","Builds strength","Boosts energy","Can be modified"],disadvantages:["Avoid with severe heart conditions","Not recommended during pregnancy","May cause fatigue if overdone","Simplify for seniors"],difficulty:"Intermediate",duration:"5-10 minutes",subCategories:["Teens Yoga (13-19 years)","Adults (20-50 years)"]},{id:71,name:"\u0ab5\u0a9c\u0acd\u0ab0\u0abe\u0ab8\u0aa8 (Vajrasana) - Thunderbolt Pose",image:o(71,"Vajrasana"),description:"A seated pose suitable for all ages. Excellent for digestion and meditation. Safe and comfortable.",advantages:["Suitable for all ages","Improves digestion","Calms the mind","Safe and comfortable","Easy to maintain","Enhances meditation"],disadvantages:["Avoid with knee injuries","Not suitable with ankle problems","May cause discomfort initially","Use props if needed"],difficulty:"Beginner",duration:"5-30 minutes",subCategories:["Kids Yoga (5-12 years)","Teens Yoga (13-19 years)","Adults (20-50 years)","Seniors (50+ years)"]},{id:72,name:"\u0a85\u0a82\u0a9c\u0aa8\u0ac7\u0aaf\u0abe\u0ab8\u0aa8 (Anjaneyasana) - Low Lunge",image:o(72,"Anjaneyasana"),description:"A lunge pose suitable for teens and adults. Stretches hip flexors and strengthens legs. Can be modified for seniors.",advantages:["Stretches hip flexors","Strengthens legs","Suitable for teens and adults","Opens chest","Improves flexibility","Can be modified"],disadvantages:["Avoid with knee injuries","Not suitable with hip problems","May strain if overstretched","Use props for seniors"],difficulty:"Beginner",duration:"30-60 seconds each side",subCategories:["Teens Yoga (13-19 years)","Adults (20-50 years)"]}],women:[{id:73,name:"Baddha Konasana (Baddha Konasana) - Butterfly Pose",image:o(73,"Baddha Konasana"),description:"A seated pose that helps with PCOS and menstrual health. Stretches inner thighs and improves reproductive health.",advantages:["Helps with PCOS","Improves menstrual health","Stretches inner thighs","Stimulates reproductive organs","Improves flexibility","Calms the mind"],disadvantages:["Avoid with knee injuries","Not suitable with groin problems","May cause discomfort initially","Use props for support"],difficulty:"Beginner",duration:"1-5 minutes",subCategories:["PCOS","Menstrual Health","Hormonal Balance","Pelvic Health"]},{id:74,name:"Supta Baddha Konasana (Supta Baddha Konasana) - Reclining Bound Angle Pose",image:o(74,"Supta Baddha Konasana"),description:"A restorative pose that helps with PCOS and hormonal balance. Calms the nervous system and reduces stress.",advantages:["Helps with PCOS","Improves hormonal balance","Stretches inner thighs","Calms nervous system","Reduces stress","Improves circulation"],disadvantages:["Avoid with knee injuries","Not suitable with groin injuries","May cause discomfort with tight hips","Use props if needed"],difficulty:"Beginner",duration:"3-10 minutes",subCategories:["PCOS","Hormonal Balance","Menstrual Health","Pelvic Health"]},{id:75,name:"\u0ab5\u0abf\u0aaa\u0ab0\u0ac0\u0aa4 \u0a95\u0ab0\u0aa3\u0ac0 (Viparita Karani) - Legs-Up-the-Wall Pose",image:o(75,"Viparita Karani"),description:"A gentle inversion that helps with menstrual cramps and reduces stress. Excellent for pregnancy and postnatal recovery.",advantages:["Relieves menstrual cramps","Reduces stress","Gentle and safe","Improves circulation","Calms nervous system","Suitable for pregnancy (with modifications)"],disadvantages:["Avoid with eye pressure issues","Not suitable during active menstruation","May cause discomfort with neck issues","Avoid if feeling dizzy"],difficulty:"Beginner",duration:"5-15 minutes",subCategories:["Menstrual Health","Pregnancy Yoga","Postnatal Yoga","Hormonal Balance"]},{id:76,name:"\u0aae\u0abe\u0ab2\u0abe\u0ab8\u0aa8 (Malasana) - Garland Pose",image:o(76,"Malasana"),description:"A squatting pose that strengthens pelvic floor and helps with pregnancy. Excellent for pelvic health and hormonal balance.",advantages:["Strengthens pelvic floor","Helps with pregnancy","Opens hips","Improves pelvic health","Stretches groin","Aids in delivery preparation"],disadvantages:["Avoid with knee injuries","Not suitable with ankle problems","May cause discomfort with tight hips","Use props for support"],difficulty:"Beginner",duration:"30-60 seconds",subCategories:["Pregnancy Yoga","Pelvic Health","Hormonal Balance"]},{id:77,name:"Cat-Cow Pose (Cat-Cow Pose) - Marjariasana-Bitilasana",image:o(77,"Cat-Cow Pose"),description:"A gentle flowing movement safe for pregnancy. Relieves back pain and improves spinal flexibility. Perfect for all stages.",advantages:["Safe for pregnancy","Relieves back pain","Improves spinal flexibility","Gentle and safe","Reduces stress","Can be done throughout pregnancy"],disadvantages:["Avoid with severe neck injuries","May cause discomfort with wrist issues","Move slowly","Stop if any discomfort"],difficulty:"Beginner",duration:"1-2 minutes",subCategories:["Pregnancy Yoga","Postnatal Yoga","Menstrual Health"]},{id:78,name:"\u0aac\u0abe\u0ab2\u0abe\u0ab8\u0aa8 (Balasana) - Child's Pose",image:o(78,"Balasana"),description:"A restorative pose that helps with menstrual cramps and reduces stress. Can be modified for pregnancy.",advantages:["Relieves menstrual cramps","Reduces stress","Calms the mind","Stretches back","Promotes relaxation","Can be modified for pregnancy"],disadvantages:["Avoid with knee injuries","Not suitable during active menstruation","May cause discomfort with tight hips","Use props if needed"],difficulty:"Beginner",duration:"1-3 minutes",subCategories:["Menstrual Health","Pregnancy Yoga","Hormonal Balance"]},{id:79,name:"\u0ab8\u0ac7\u0aa4\u0ac1 \u0aac\u0a82\u0aa7\u0abe\u0ab8\u0aa8 (Setu Bandhasana) - Bridge Pose",image:o(79,"Setu Bandhasana"),description:"A gentle backbend that helps with hormonal balance and reduces stress. Excellent for menopause symptoms.",advantages:["Helps with hormonal balance","Reduces stress","Opens chest","Strengthens back","Helps with menopause","Improves mood"],disadvantages:["Avoid with neck injuries","Not suitable with severe back problems","Avoid during late pregnancy","Keep it gentle"],difficulty:"Beginner",duration:"30-60 seconds",subCategories:["Menopause","Hormonal Balance","Postnatal Yoga"]},{id:80,name:"Supta Matsyendrasana (Supta Matsyendrasana) - Supine Spinal Twist",image:o(80,"Supta Matsyendrasana"),description:"A gentle twist that helps with menstrual discomfort and improves digestion. Safe for most stages.",advantages:["Relieves menstrual discomfort","Improves digestion","Stretches spine","Calms nervous system","Reduces stress","Safe and gentle"],disadvantages:["Avoid with severe back injuries","Not suitable during active pregnancy","May cause discomfort with knee issues","Keep shoulders on ground"],difficulty:"Beginner",duration:"30-60 seconds each side",subCategories:["Menstrual Health","Hormonal Balance","Postnatal Yoga"]},{id:81,name:"\u0ab5\u0abf\u0aaa\u0ab0\u0ac0\u0aa4 \u0a95\u0ab0\u0aa3\u0ac0 (Viparita Karani) - Legs-Up-the-Wall Pose",image:o(81,"Viparita Karani"),description:"A restorative pose perfect for postnatal recovery. Reduces swelling and promotes healing. Excellent for new mothers.",advantages:["Perfect for postnatal recovery","Reduces swelling","Promotes healing","Gentle and safe","Reduces stress","Improves circulation"],disadvantages:["Avoid with eye pressure issues","Not suitable during active bleeding","May cause discomfort with neck issues","Keep warm"],difficulty:"Beginner",duration:"5-15 minutes",subCategories:["Postnatal Yoga","Hormonal Balance","Pelvic Health"]},{id:82,name:"\u0a85\u0aa7\u0acb \u0aae\u0ac1\u0a96 \u0ab6\u0acd\u0ab5\u0abe\u0aa8\u0abe\u0ab8\u0aa8 (Adho Mukha Svanasana) - Downward-Facing Dog",image:o(82,"Adho Mukha Svanasana"),description:"An inversion that helps with hormonal balance and reduces stress. Can be modified for pregnancy and postnatal.",advantages:["Helps with hormonal balance","Reduces stress","Strengthens body","Improves circulation","Can be modified","Calms the mind"],disadvantages:["Avoid with wrist injuries","Not suitable with high blood pressure","Modify for pregnancy","Use props if needed"],difficulty:"Beginner",duration:"30-60 seconds",subCategories:["Hormonal Balance","Pregnancy Yoga","Postnatal Yoga"]},{id:83,name:"\u0ab8\u0ac1\u0a96\u0abe\u0ab8\u0aa8 (Sukhasana) - Easy Pose",image:o(83,"Sukhasana"),description:"A comfortable seated pose for meditation and breathing. Excellent for hormonal balance and stress relief.",advantages:["Comfortable and safe","Improves hormonal balance","Calms the mind","Reduces stress","Easy to maintain","Enhances meditation"],disadvantages:["May cause discomfort with tight hips","Use props for support","Avoid with knee injuries","Keep spine straight"],difficulty:"Beginner",duration:"5-30 minutes",subCategories:["Hormonal Balance","Menstrual Health","Menopause"]},{id:84,name:"\u0ab6\u0ab5\u0abe\u0ab8\u0aa8 (Shavasana) - Corpse Pose",image:o(84,"Shavasana"),description:"The ultimate relaxation pose essential for women's health. Reduces stress and promotes hormonal balance.",advantages:["Reduces stress","Promotes hormonal balance","Essential for recovery","Reduces anxiety","Improves sleep","Calms entire system"],disadvantages:["May cause sleepiness","Keep warm","Not suitable if feeling unwell","Practice in quiet environment"],difficulty:"Beginner",duration:"5-20 minutes",subCategories:["Hormonal Balance","Menstrual Health","Menopause","Postnatal Yoga"]},{id:85,name:"Uttanasana (Uttanasana) - Standing Forward Bend",image:o(85,"Uttanasana"),description:"A forward fold that helps with menstrual cramps and reduces stress. Can be modified for pregnancy.",advantages:["Relieves menstrual cramps","Reduces stress","Stretches back","Calms the mind","Can be modified","Improves circulation"],disadvantages:["Avoid with severe back injuries","Not suitable with high blood pressure","Modify for pregnancy","May cause dizziness"],difficulty:"Beginner",duration:"30-60 seconds",subCategories:["Menstrual Health","Hormonal Balance","Pregnancy Yoga"]},{id:86,name:"\u0ab5\u0ac0\u0ab0\u0abe\u0ab8\u0aa8 (Virasana) - Hero Pose",image:o(86,"Virasana"),description:"A seated pose that helps with pelvic health and improves digestion. Excellent for hormonal balance.",advantages:["Improves pelvic health","Helps with hormonal balance","Improves digestion","Stretches thighs","Calms the mind","Enhances meditation"],disadvantages:["Avoid with knee injuries","Not suitable with ankle problems","May cause discomfort initially","Use props if needed"],difficulty:"Beginner",duration:"5-30 minutes",subCategories:["Pelvic Health","Hormonal Balance","Menstrual Health"]},{id:87,name:"Anulom Vilom Pranayama (Anulom Vilom Pranayama) - Alternate Nostril Breathing",image:o(87,"Anulom Vilom Pranayama"),description:"A balancing breathing technique that helps with hormonal balance and reduces stress. Excellent for menopause.",advantages:["Helps with hormonal balance","Reduces stress","Balances emotions","Helps with menopause","Calms the mind","Improves focus"],disadvantages:["Avoid with blocked nostrils","Not suitable during illness","May cause dizziness if done incorrectly","Requires proper technique"],difficulty:"Beginner",duration:"5-10 minutes",subCategories:["Hormonal Balance","Menopause","Menstrual Health"]}],lifestyle:[{id:88,name:"Desk Yoga - Seated Cat-Cow (Desk Yoga - Seated Cat-Cow) - Desk Yoga - Seated Cat-Cow",image:o(88,"Desk Yoga - Seated Cat-Cow"),description:"A seated version of cat-cow perfect for office workers. Relieves back and neck tension from desk work.",advantages:["Perfect for office workers","Relieves back tension","Relieves neck pain","Can be done at desk","Quick and easy","Improves posture"],disadvantages:["May look unusual at office","Requires some space","Move slowly","Stop if any discomfort"],difficulty:"Beginner",duration:"1-2 minutes",subCategories:["Office Workers","Desk Yoga","Daily Routine","Quick Sessions"]},{id:89,name:"Desk Yoga - Seated Spinal Twist (Desk Yoga - Seated Spinal Twist) - Desk Yoga - Seated Spinal Twist",image:o(89,"Desk Yoga - Seated Spinal Twist"),description:"A seated twist perfect for office breaks. Relieves back stiffness and improves spinal mobility.",advantages:["Perfect for office","Relieves back stiffness","Improves spinal mobility","Quick to do","Can be done at desk","Reduces fatigue"],disadvantages:["Avoid with severe back injuries","Move slowly","Keep spine straight","Stop if any pain"],difficulty:"Beginner",duration:"30 seconds each side",subCategories:["Office Workers","Desk Yoga","Daily Routine","Quick Sessions"]},{id:90,name:"\u0ab8\u0ac2\u0ab0\u0acd\u0aaf \u0aa8\u0aae\u0ab8\u0acd\u0a95\u0abe\u0ab0 (Surya Namaskar) - Sun Salutation",image:o(90,"Surya Namaskar"),description:"A complete sequence perfect for morning routine. Energizes the body and prepares for the day. Excellent for athletes.",advantages:["Perfect for morning","Energizes body","Full-body workout","Excellent for athletes","Boosts energy","Improves flexibility"],disadvantages:["Avoid with severe heart conditions","Not recommended during pregnancy","May cause fatigue if overdone","Requires some space"],difficulty:"Intermediate",duration:"5-10 minutes",subCategories:["Morning Yoga","Athletes","Daily Routine"]},{id:91,name:"\u0ab5\u0abf\u0aaa\u0ab0\u0ac0\u0aa4 \u0a95\u0ab0\u0aa3\u0ac0 (Viparita Karani) - Legs-Up-the-Wall Pose",image:o(91,"Viparita Karani"),description:"A restorative pose perfect for evening routine. Relieves fatigue and promotes relaxation. Excellent after work.",advantages:["Perfect for evening","Relieves fatigue","Promotes relaxation","Reduces stress","Improves sleep","No physical strain"],disadvantages:["Avoid with eye pressure issues","Not suitable during menstruation","May cause discomfort with neck issues","Keep warm"],difficulty:"Beginner",duration:"5-15 minutes",subCategories:["Evening Yoga","Daily Routine","Office Workers"]},{id:92,name:"\u0aa4\u0abe\u0aa1\u0abe\u0ab8\u0aa8 (Tadasana) - Mountain Pose",image:o(92,"Tadasana"),description:"A foundational pose perfect for daily routine. Improves posture and body awareness. Can be done anywhere.",advantages:["Can be done anywhere","Improves posture","Quick and easy","Perfect for daily routine","Builds body awareness","No space required"],disadvantages:["May seem too simple","Requires focus","Keep feet grounded","Maintain alignment"],difficulty:"Beginner",duration:"30-60 seconds",subCategories:["Daily Routine","Quick Sessions","Office Workers","Travel Yoga"]},{id:93,name:"\u0aac\u0abe\u0ab2\u0abe\u0ab8\u0aa8 (Balasana) - Child's Pose",image:o(93,"Balasana"),description:"A restorative pose perfect for quick breaks. Calms the mind and relieves stress. Excellent for travel.",advantages:["Perfect for quick breaks","Calms the mind","Relieves stress","Can be done anywhere","Quick and easy","Excellent for travel"],disadvantages:["Avoid with knee injuries","Not suitable during pregnancy","May cause discomfort with tight hips","Use props if needed"],difficulty:"Beginner",duration:"1-3 minutes",subCategories:["Quick Sessions","Travel Yoga","Daily Routine","Office Workers"]},{id:94,name:"\u0a85\u0aa7\u0acb \u0aae\u0ac1\u0a96 \u0ab6\u0acd\u0ab5\u0abe\u0aa8\u0abe\u0ab8\u0aa8 (Adho Mukha Svanasana) - Downward-Facing Dog",image:o(94,"Adho Mukha Svanasana"),description:"An inversion perfect for athletes. Strengthens the entire body and improves flexibility. Excellent for warm-up.",advantages:["Perfect for athletes","Strengthens entire body","Improves flexibility","Excellent warm-up","Energizes body","Improves circulation"],disadvantages:["Avoid with wrist injuries","Not suitable with high blood pressure","May cause strain with shoulder issues","Requires some space"],difficulty:"Beginner",duration:"30-60 seconds",subCategories:["Athletes","Morning Yoga","Daily Routine"]},{id:95,name:"\u0ab5\u0ac0\u0ab0\u0aad\u0aa6\u0acd\u0ab0\u0abe\u0ab8\u0aa8 II (Virabhadrasana II) - Warrior II",image:o(95,"Virabhadrasana II"),description:"A powerful standing pose excellent for athletes. Builds strength and stamina. Perfect for training.",advantages:["Excellent for athletes","Builds strength","Builds stamina","Improves balance","Strengthens legs","Perfect for training"],disadvantages:["Avoid with knee injuries","Not suitable with high blood pressure","May cause strain if overdone","Requires good physical condition"],difficulty:"Intermediate",duration:"30-60 seconds",subCategories:["Athletes","Daily Routine","Morning Yoga"]},{id:96,name:"\u0ab6\u0ab5\u0abe\u0ab8\u0aa8 (Shavasana) - Corpse Pose",image:o(96,"Shavasana"),description:"The ultimate relaxation pose perfect for evening routine. Essential for recovery and rest. Excellent after work.",advantages:["Perfect for evening","Promotes relaxation","Essential for recovery","Reduces stress","Improves sleep","No physical effort"],disadvantages:["May cause sleepiness","Keep warm","Not suitable if feeling unwell","Practice in quiet environment"],difficulty:"Beginner",duration:"5-20 minutes",subCategories:["Evening Yoga","Daily Routine","Office Workers"]},{id:97,name:"\u0aae\u0abe\u0ab0\u0acd\u0a9c\u0ab0\u0ac0\u0a86\u0ab8\u0aa8 (Marjariasana) - Cat-Cow Pose",image:o(97,"Marjariasana"),description:"A gentle flowing movement perfect for morning routine. Warms up the spine and energizes the body.",advantages:["Perfect for morning","Warms up spine","Energizes body","Quick and easy","Improves flexibility","Reduces stiffness"],disadvantages:["Avoid with severe neck injuries","May cause discomfort with wrist issues","Move slowly","Stop if any discomfort"],difficulty:"Beginner",duration:"1-2 minutes",subCategories:["Morning Yoga","Daily Routine","Quick Sessions","Office Workers"]},{id:98,name:"\u0ab8\u0ac1\u0a96\u0abe\u0ab8\u0aa8 (Sukhasana) - Easy Pose",image:o(98,"Sukhasana"),description:"A comfortable seated pose perfect for travel. Can be done anywhere. Excellent for meditation and breathing.",advantages:["Perfect for travel","Can be done anywhere","Comfortable","Easy to maintain","Enhances meditation","No space required"],disadvantages:["May cause discomfort with tight hips","Use props for support","Avoid with knee injuries","Keep spine straight"],difficulty:"Beginner",duration:"5-30 minutes",subCategories:["Travel Yoga","Daily Routine","Quick Sessions"]},{id:99,name:"Anulom Vilom Pranayama (Anulom Vilom Pranayama) - Alternate Nostril Breathing",image:o(99,"Anulom Vilom Pranayama"),description:"A breathing technique perfect for quick sessions. Calms the mind and reduces stress. Can be done anywhere.",advantages:["Perfect for quick sessions","Calms the mind","Reduces stress","Can be done anywhere","Quick and effective","No space required"],disadvantages:["Avoid with blocked nostrils","Not suitable during illness","May cause dizziness if done incorrectly","Requires proper technique"],difficulty:"Beginner",duration:"5-10 minutes",subCategories:["Quick Sessions","Daily Routine","Travel Yoga","Office Workers"]},{id:100,name:"Utkatasana (Utkatasana) - Chair Pose",image:o(100,"Utkatasana"),description:"A strengthening pose perfect for athletes. Builds leg strength and endurance. Excellent for training.",advantages:["Perfect for athletes","Builds leg strength","Builds endurance","Improves balance","Tones muscles","Excellent for training"],disadvantages:["Avoid with knee injuries","Not suitable with low blood pressure","May cause strain if held too long","Can be challenging"],difficulty:"Intermediate",duration:"30-60 seconds",subCategories:["Athletes","Daily Routine","Morning Yoga"]},{id:101,name:"\u0aa4\u0acd\u0ab0\u0abf\u0a95\u0acb\u0aa3\u0abe\u0ab8\u0aa8 (Trikonasana) - Triangle Pose",image:o(101,"Trikonasana"),description:"A standing pose perfect for daily routine. Improves flexibility and strength. Can be done in small spaces.",advantages:["Perfect for daily routine","Improves flexibility","Strengthens legs","Can be done in small spaces","Improves balance","Opens hips"],disadvantages:["Avoid with low blood pressure","Not suitable with neck injuries","May cause dizziness","Requires some space"],difficulty:"Intermediate",duration:"30-60 seconds each side",subCategories:["Daily Routine","Morning Yoga","Athletes"]},{id:102,name:"\u0ab5\u0abf\u0aaa\u0ab0\u0ac0\u0aa4 \u0a95\u0ab0\u0aa3\u0ac0 (Viparita Karani) - Legs-Up-the-Wall Pose",image:o(102,"Viparita Karani"),description:"A restorative pose perfect for evening routine. Relieves fatigue and promotes sleep. Excellent after long day.",advantages:["Perfect for evening","Relieves fatigue","Promotes sleep","Reduces stress","No physical strain","Excellent after work"],disadvantages:["Avoid with eye pressure issues","Not suitable during menstruation","May cause discomfort with neck issues","Keep warm"],difficulty:"Beginner",duration:"5-15 minutes",subCategories:["Evening Yoga","Daily Routine","Office Workers"]}],meditation:[{id:103,name:"Padmasana (Padmasana) - Lotus Pose",image:o(103,"Padmasana"),description:"The classic meditation pose that promotes mental clarity and focus. Ideal for deep meditation practice.",advantages:["Perfect for meditation","Improves focus","Calms the mind","Opens hips","Improves posture","Enhances concentration"],disadvantages:["Requires flexible hips","Can strain knees if forced","Not suitable for knee injuries","May cause ankle discomfort","Difficult for beginners"],difficulty:"Intermediate",duration:"5-30 minutes",subCategories:["Meditation","Mindfulness","Focus & Concentration","Chakra Balancing"]},{id:104,name:"\u0ab8\u0ac1\u0a96\u0abe\u0ab8\u0aa8 (Sukhasana) - Easy Pose",image:o(104,"Sukhasana"),description:"A comfortable seated pose perfect for beginners. Excellent for meditation and breathing exercises.",advantages:["Perfect for beginners","Comfortable","Easy to maintain","Enhances meditation","Calms the mind","Improves focus"],disadvantages:["May cause discomfort with tight hips","Use props for support","Avoid with knee injuries","Keep spine straight"],difficulty:"Beginner",duration:"5-30 minutes",subCategories:["Meditation","Mindfulness","Breathing Exercises","Relaxation Techniques"]},{id:105,name:"\u0ab5\u0ac0\u0ab0\u0abe\u0ab8\u0aa8 (Virasana) - Hero Pose",image:o(105,"Virasana"),description:"A seated pose that calms the mind and improves focus. Excellent for meditation and pranayama practice.",advantages:["Calms the mind","Improves focus","Enhances meditation","Stretches thighs","Improves digestion","Reduces stress"],disadvantages:["Avoid with knee injuries","Not suitable with ankle problems","May cause discomfort initially","Use props if needed"],difficulty:"Beginner",duration:"5-30 minutes",subCategories:["Meditation","Mindfulness","Breathing Exercises","Chakra Balancing"]},{id:106,name:"Anulom Vilom Pranayama (Anulom Vilom Pranayama) - Alternate Nostril Breathing",image:o(106,"Anulom Vilom Pranayama"),description:"A balancing breathing technique that calms the mind and enhances meditation. Excellent for chakra balancing.",advantages:["Calms the mind","Enhances meditation","Balances chakras","Improves focus","Reduces stress","Balances nervous system"],disadvantages:["Avoid with blocked nostrils","Not suitable during illness","May cause dizziness if done incorrectly","Requires proper technique"],difficulty:"Beginner",duration:"5-10 minutes",subCategories:["Breathing Exercises","Chakra Balancing","Meditation","Mindfulness"]},{id:107,name:"Bhramari Pranayama (Bhramari Pranayama) - Bee Breath",image:o(107,"Bhramari Pranayama"),description:"A calming breathing technique that promotes deep relaxation. Excellent for meditation and energy healing.",advantages:["Promotes deep relaxation","Calms the mind","Enhances meditation","Reduces stress","Improves focus","Energy healing"],disadvantages:["Avoid with ear infections","Not suitable with severe sinus issues","May cause discomfort initially","Practice in quiet environment"],difficulty:"Beginner",duration:"5-10 minutes",subCategories:["Breathing Exercises","Meditation","Relaxation Techniques","Energy Healing"]},{id:108,name:"Ujjayi Pranayama (Ujjayi Pranayama) - Victorious Breath",image:o(108,"Ujjayi Pranayama"),description:"A calming breathing technique that enhances focus and meditation. Excellent for mindfulness practice.",advantages:["Enhances focus","Improves meditation","Calms the mind","Reduces stress","Enhances concentration","Mindfulness practice"],disadvantages:["Avoid with high blood pressure","Not suitable with heart conditions","May cause dizziness","Requires proper technique"],difficulty:"Beginner",duration:"5-10 minutes",subCategories:["Breathing Exercises","Mindfulness","Meditation","Focus & Concentration"]},{id:109,name:"\u0ab6\u0ab5\u0abe\u0ab8\u0aa8 (Shavasana) - Corpse Pose",image:o(109,"Shavasana"),description:"The ultimate relaxation pose essential for meditation practice. Promotes deep relaxation and energy healing.",advantages:["Essential for meditation","Promotes deep relaxation","Energy healing","Reduces stress","Calms entire system","Enhances recovery"],disadvantages:["May cause sleepiness","Keep warm","Not suitable if feeling unwell","Practice in quiet environment"],difficulty:"Beginner",duration:"5-20 minutes",subCategories:["Meditation","Relaxation Techniques","Energy Healing","Chakra Balancing"]},{id:110,name:"\u0ab5\u0abf\u0aaa\u0ab0\u0ac0\u0aa4 \u0a95\u0ab0\u0aa3\u0ac0 (Viparita Karani) - Legs-Up-the-Wall Pose",image:o(110,"Viparita Karani"),description:"A restorative pose that calms the nervous system. Excellent for meditation preparation and relaxation.",advantages:["Calms nervous system","Prepares for meditation","Promotes relaxation","Reduces stress","Improves focus","Energy healing"],disadvantages:["Avoid with eye pressure issues","Not suitable during menstruation","May cause discomfort with neck issues","Keep warm"],difficulty:"Beginner",duration:"5-15 minutes",subCategories:["Meditation","Relaxation Techniques","Energy Healing","Chakra Balancing"]},{id:111,name:"Yoga Nidra (Yoga Nidra) - Yogic Sleep",image:o(111,"Yoga Nidra"),description:"A deep relaxation practice that promotes meditation and energy healing. Excellent for chakra balancing.",advantages:["Deep relaxation","Promotes meditation","Energy healing","Chakra balancing","Reduces stress","Enhances recovery"],disadvantages:["May cause deep sleep","Practice in quiet environment","Not suitable if very tired","Keep warm"],difficulty:"Beginner",duration:"20-45 minutes",subCategories:["Meditation","Relaxation Techniques","Energy Healing","Chakra Balancing"]},{id:112,name:"Kapalbhati Pranayama (Kapalbhati Pranayama) - Skull Shining Breath",image:o(112,"Kapalbhati Pranayama"),description:"A cleansing breathing technique that enhances focus and meditation. Excellent for chakra balancing.",advantages:["Enhances focus","Improves meditation","Chakra balancing","Cleanses system","Boosts energy","Improves concentration"],disadvantages:["Avoid with high blood pressure","Not suitable with heart problems","Avoid during pregnancy","May cause dizziness","Not for beginners"],difficulty:"Intermediate",duration:"2-5 minutes",subCategories:["Breathing Exercises","Chakra Balancing","Meditation","Energy Healing"]},{id:113,name:"Nadi Shodhana (Nadi Shodhana) - Alternate Nostril Breathing",image:o(113,"Nadi Shodhana"),description:"A balancing breathing technique perfect for meditation. Balances chakras and enhances energy healing.",advantages:["Perfect for meditation","Balances chakras","Energy healing","Calms the mind","Enhances focus","Balances nervous system"],disadvantages:["Avoid with blocked nostrils","Not suitable during illness","May cause dizziness if done incorrectly","Requires proper technique"],difficulty:"Beginner",duration:"5-10 minutes",subCategories:["Breathing Exercises","Chakra Balancing","Meditation","Energy Healing"]},{id:114,name:"Sitali Pranayama (Sitali Pranayama) - Cooling Breath",image:o(114,"Sitali Pranayama"),description:"A cooling breathing technique that calms the mind and enhances meditation. Excellent for relaxation.",advantages:["Calms the mind","Enhances meditation","Promotes relaxation","Cools the body","Reduces stress","Improves focus"],disadvantages:["Avoid in cold weather","Not suitable with respiratory issues","May cause discomfort initially","Practice in comfortable temperature"],difficulty:"Beginner",duration:"5-10 minutes",subCategories:["Breathing Exercises","Relaxation Techniques","Meditation","Mindfulness"]},{id:115,name:"Bhastrika Pranayama (Bhastrika Pranayama) - Bellows Breath",image:o(115,"Bhastrika Pranayama"),description:"A powerful breathing technique that enhances energy and meditation. Excellent for chakra balancing.",advantages:["Enhances energy","Improves meditation","Chakra balancing","Boosts energy","Improves focus","Energy healing"],disadvantages:["Avoid with high blood pressure","Not suitable with heart conditions","May cause dizziness","Avoid during pregnancy","Not for beginners"],difficulty:"Intermediate",duration:"2-5 minutes",subCategories:["Breathing Exercises","Chakra Balancing","Energy Healing","Meditation"]},{id:116,name:"\u0ab5\u0a9c\u0acd\u0ab0\u0abe\u0ab8\u0aa8 (Vajrasana) - Thunderbolt Pose",image:o(116,"Vajrasana"),description:"A seated pose perfect for meditation and pranayama. Calms the mind and enhances focus.",advantages:["Perfect for meditation","Calms the mind","Enhances focus","Improves digestion","Strengthens thighs","Aids in pranayama"],disadvantages:["Avoid with knee injuries","Not suitable with ankle problems","May cause discomfort initially","Use props if needed"],difficulty:"Beginner",duration:"5-30 minutes",subCategories:["Meditation","Breathing Exercises","Mindfulness","Chakra Balancing"]},{id:117,name:"Ardha Padmasana (Ardha Padmasana) - Half Lotus Pose",image:o(117,"Ardha Padmasana"),description:"A modified lotus pose perfect for meditation. Easier than full lotus but still effective for practice.",advantages:["Perfect for meditation","Easier than full lotus","Improves focus","Opens hips","Improves posture","Enhances concentration"],disadvantages:["Requires some hip flexibility","Can strain knees if forced","Not suitable for knee injuries","May cause discomfort initially"],difficulty:"Intermediate",duration:"5-30 minutes",subCategories:["Meditation","Mindfulness","Focus & Concentration","Chakra Balancing"]}],programs:[{id:118,name:"\u0aa4\u0abe\u0aa1\u0abe\u0ab8\u0aa8 (Tadasana) - Mountain Pose",image:o(118,"Tadasana"),description:"A foundational pose perfect for beginner courses. Improves posture and body awareness. Essential for all programs.",advantages:["Perfect for beginners","Improves posture","Builds foundation","Essential for all programs","Easy to learn","Builds body awareness"],disadvantages:["May seem too simple","Requires focus","Keep feet grounded","Maintain alignment"],difficulty:"Beginner",duration:"30-60 seconds",subCategories:["Beginner Course","Online Programs","Offline Classes","7-Day Challenge"]},{id:119,name:"\u0ab8\u0ac2\u0ab0\u0acd\u0aaf \u0aa8\u0aae\u0ab8\u0acd\u0a95\u0abe\u0ab0 (Surya Namaskar) - Sun Salutation",image:o(119,"Surya Namaskar"),description:"A complete sequence perfect for 7-day and 30-day challenges. Provides full-body workout and transformation.",advantages:["Perfect for challenges","Full-body workout","Transformation program","Improves flexibility","Builds strength","Boosts energy"],disadvantages:["Avoid with severe heart conditions","Not recommended during pregnancy","May cause fatigue if overdone","Requires good physical condition"],difficulty:"Intermediate",duration:"5-10 minutes",subCategories:["7-Day Challenge","30-Day Transformation","Online Programs","Offline Classes"]},{id:120,name:"Virabhadrasana Series (Virabhadrasana Series) - Warrior Poses",image:o(120,"Virabhadrasana Series"),description:"A series of warrior poses perfect for advanced training. Builds strength and stamina. Excellent for transformation programs.",advantages:["Perfect for advanced training","Builds strength","Builds stamina","Transformation program","Improves balance","Strengthens entire body"],disadvantages:["Avoid with knee injuries","Not suitable with high blood pressure","May cause strain if overdone","Requires good physical condition"],difficulty:"Intermediate",duration:"30-60 seconds each",subCategories:["Advanced Training","30-Day Transformation","Offline Classes"]},{id:121,name:"\u0aac\u0abe\u0ab2\u0abe\u0ab8\u0aa8 (Balasana) - Child's Pose",image:o(121,"Balasana"),description:"A restorative pose essential for all programs. Promotes recovery and relaxation. Perfect for beginner courses.",advantages:["Essential for all programs","Perfect for beginners","Promotes recovery","Promotes relaxation","Calms the mind","Reduces stress"],disadvantages:["Avoid with knee injuries","Not suitable during pregnancy","May cause discomfort with tight hips","Use props if needed"],difficulty:"Beginner",duration:"1-3 minutes",subCategories:["Beginner Course","Online Programs","Offline Classes","7-Day Challenge"]},{id:122,name:"\u0a85\u0aa7\u0acb \u0aae\u0ac1\u0a96 \u0ab6\u0acd\u0ab5\u0abe\u0aa8\u0abe\u0ab8\u0aa8 (Adho Mukha Svanasana) - Downward-Facing Dog",image:o(122,"Adho Mukha Svanasana"),description:"An inversion perfect for online and offline programs. Strengthens entire body and improves flexibility.",advantages:["Perfect for programs","Strengthens entire body","Improves flexibility","Energizes body","Improves circulation","Calms the mind"],disadvantages:["Avoid with wrist injuries","Not suitable with high blood pressure","May cause strain with shoulder issues","Requires some space"],difficulty:"Beginner",duration:"30-60 seconds",subCategories:["Online Programs","Offline Classes","7-Day Challenge","30-Day Transformation"]},{id:123,name:"\u0aad\u0ac1\u0a9c\u0a82\u0a97\u0abe\u0ab8\u0aa8 (Bhujangasana) - Cobra Pose",image:o(123,"Bhujangasana"),description:"A gentle backbend perfect for beginner courses. Strengthens spine and opens chest. Essential foundation pose.",advantages:["Perfect for beginners","Essential foundation","Strengthens spine","Opens chest","Improves posture","Easy to learn"],disadvantages:["Avoid with severe back injuries","Not suitable during pregnancy","May cause strain if done incorrectly","Keep it gentle"],difficulty:"Beginner",duration:"30-60 seconds",subCategories:["Beginner Course","Online Programs","Offline Classes","7-Day Challenge"]},{id:124,name:"\u0aa4\u0acd\u0ab0\u0abf\u0a95\u0acb\u0aa3\u0abe\u0ab8\u0aa8 (Trikonasana) - Triangle Pose",image:o(124,"Trikonasana"),description:"A standing pose perfect for transformation programs. Improves flexibility and strength. Excellent for challenges.",advantages:["Perfect for transformation","Improves flexibility","Strengthens legs","Excellent for challenges","Improves balance","Opens hips"],disadvantages:["Avoid with low blood pressure","Not suitable with neck injuries","May cause dizziness","Requires some flexibility"],difficulty:"Intermediate",duration:"30-60 seconds each side",subCategories:["30-Day Transformation","Advanced Training","Offline Classes"]},{id:125,name:"Navasana (Navasana) - Boat Pose",image:o(125,"Navasana"),description:"A core strengthening pose perfect for advanced training. Tones abdominal muscles and builds strength.",advantages:["Perfect for advanced training","Strengthens core","Tones muscles","Builds strength","Improves balance","Transformation program"],disadvantages:["Avoid with lower back injuries","Not suitable during pregnancy","May cause strain if forced","Requires core strength"],difficulty:"Intermediate",duration:"20-40 seconds",subCategories:["Advanced Training","30-Day Transformation","Offline Classes"]},{id:126,name:"\u0ab6\u0ab5\u0abe\u0ab8\u0aa8 (Shavasana) - Corpse Pose",image:o(126,"Shavasana"),description:"The ultimate relaxation pose essential for all programs. Promotes recovery and deep relaxation.",advantages:["Essential for all programs","Promotes recovery","Deep relaxation","Reduces stress","Calms entire system","Enhances transformation"],disadvantages:["May cause sleepiness","Keep warm","Not suitable if feeling unwell","Practice in quiet environment"],difficulty:"Beginner",duration:"5-20 minutes",subCategories:["Online Programs","Offline Classes","7-Day Challenge","30-Day Transformation","Beginner Course","Advanced Training"]},{id:127,name:"\u0ab5\u0ac3\u0a95\u0acd\u0ab7\u0abe\u0ab8\u0aa8 (Vrikshasana) - Tree Pose",image:o(127,"Vrikshasana"),description:"A balancing pose perfect for beginner courses. Improves focus and balance. Fun and engaging.",advantages:["Perfect for beginners","Fun and engaging","Improves balance","Enhances focus","Builds confidence","Easy to learn"],disadvantages:["Avoid with balance issues","Not suitable with knee injuries","May cause falls","Use wall support if needed"],difficulty:"Beginner",duration:"20-40 seconds each side",subCategories:["Beginner Course","Online Programs","Offline Classes","7-Day Challenge"]},{id:128,name:"Chaturanga Dandasana (Chaturanga Dandasana) - Four-Limbed Staff Pose",image:o(128,"Chaturanga Dandasana"),description:"A challenging pose perfect for advanced training. Builds upper body and core strength. Excellent for transformation.",advantages:["Perfect for advanced training","Builds strength","Transformation program","Tones entire body","Builds endurance","Challenging and rewarding"],disadvantages:["Requires significant strength","Avoid with wrist injuries","Not suitable with shoulder problems","Very challenging","Not for beginners"],difficulty:"Advanced",duration:"10-30 seconds",subCategories:["Advanced Training","30-Day Transformation","Offline Classes"]},{id:129,name:"Utkatasana (Utkatasana) - Chair Pose",image:o(129,"Utkatasana"),description:"A strengthening pose perfect for challenges and transformation programs. Builds leg strength and endurance.",advantages:["Perfect for challenges","Builds strength","Transformation program","Improves balance","Tones muscles","Builds endurance"],disadvantages:["Avoid with knee injuries","Not suitable with low blood pressure","May cause strain if held too long","Can be challenging"],difficulty:"Intermediate",duration:"30-60 seconds",subCategories:["7-Day Challenge","30-Day Transformation","Online Programs","Offline Classes"]},{id:130,name:"\u0ab8\u0ac7\u0aa4\u0ac1 \u0aac\u0a82\u0aa7\u0abe\u0ab8\u0aa8 (Setu Bandhasana) - Bridge Pose",image:o(130,"Setu Bandhasana"),description:"A gentle backbend perfect for beginner courses and online programs. Strengthens back and opens chest.",advantages:["Perfect for beginners","Online program friendly","Strengthens back","Opens chest","Improves flexibility","Easy to learn"],disadvantages:["Avoid with neck injuries","Not suitable with severe back problems","Avoid during late pregnancy","Keep it gentle"],difficulty:"Beginner",duration:"30-60 seconds",subCategories:["Beginner Course","Online Programs","Offline Classes","7-Day Challenge"]},{id:131,name:"\u0aae\u0abe\u0ab0\u0acd\u0a9c\u0ab0\u0ac0\u0a86\u0ab8\u0aa8 (Marjariasana) - Cat-Cow Pose",image:o(131,"Marjariasana"),description:"A gentle flowing movement perfect for all programs. Warms up the spine and improves flexibility.",advantages:["Perfect for all programs","Warms up spine","Improves flexibility","Easy to learn","Reduces stiffness","Safe for everyone"],disadvantages:["Avoid with severe neck injuries","May cause discomfort with wrist issues","Move slowly","Stop if any discomfort"],difficulty:"Beginner",duration:"1-2 minutes",subCategories:["Beginner Course","Online Programs","Offline Classes","7-Day Challenge","30-Day Transformation"]},{id:132,name:"\u0ab5\u0abf\u0aaa\u0ab0\u0ac0\u0aa4 \u0a95\u0ab0\u0aa3\u0ac0 (Viparita Karani) - Legs-Up-the-Wall Pose",image:o(132,"Viparita Karani"),description:"A restorative pose essential for all programs. Promotes recovery and relaxation. Perfect for online programs.",advantages:["Essential for all programs","Perfect for online","Promotes recovery","Promotes relaxation","Reduces stress","No physical strain"],disadvantages:["Avoid with eye pressure issues","Not suitable during menstruation","May cause discomfort with neck issues","Keep warm"],difficulty:"Beginner",duration:"5-15 minutes",subCategories:["Online Programs","Offline Classes","7-Day Challenge","30-Day Transformation","Beginner Course"]}],levels:[{id:133,name:"\u0aa4\u0abe\u0aa1\u0abe\u0ab8\u0aa8 (Tadasana) - Mountain Pose",image:o(133,"Tadasana"),description:"The foundational pose for all beginners. Improves posture and body awareness. Essential starting point.",advantages:["Perfect for beginners","Essential foundation","Improves posture","Builds body awareness","Easy to learn","Safe for everyone"],disadvantages:["May seem too simple","Requires focus","Keep feet grounded","Maintain alignment"],difficulty:"Beginner",duration:"30-60 seconds",subCategories:["Beginner","Gentle Yoga","Therapeutic"]},{id:134,name:"\u0aac\u0abe\u0ab2\u0abe\u0ab8\u0aa8 (Balasana) - Child's Pose",image:o(134,"Balasana"),description:"A restorative pose perfect for beginners and gentle yoga. Calms the mind and promotes relaxation.",advantages:["Perfect for beginners","Gentle yoga","Calms the mind","Promotes relaxation","Safe and comfortable","Therapeutic"],disadvantages:["Avoid with knee injuries","Not suitable during pregnancy","May cause discomfort with tight hips","Use props if needed"],difficulty:"Beginner",duration:"1-3 minutes",subCategories:["Beginner","Gentle Yoga","Restorative","Therapeutic"]},{id:135,name:"\u0aad\u0ac1\u0a9c\u0a82\u0a97\u0abe\u0ab8\u0aa8 (Bhujangasana) - Cobra Pose",image:o(135,"Bhujangasana"),description:"A gentle backbend perfect for beginners. Strengthens spine and opens chest. Can progress to intermediate.",advantages:["Perfect for beginners","Strengthens spine","Opens chest","Improves posture","Can progress","Therapeutic"],disadvantages:["Avoid with severe back injuries","Not suitable during pregnancy","May cause strain if done incorrectly","Keep it gentle"],difficulty:"Beginner",duration:"30-60 seconds",subCategories:["Beginner","Gentle Yoga","Therapeutic"]},{id:136,name:"\u0ab5\u0ac0\u0ab0\u0aad\u0aa6\u0acd\u0ab0\u0abe\u0ab8\u0aa8 II (Virabhadrasana II) - Warrior II",image:o(136,"Virabhadrasana II"),description:"A powerful standing pose perfect for intermediate level. Builds strength and stamina. Progress from beginner.",advantages:["Perfect for intermediate","Builds strength","Builds stamina","Improves balance","Opens hips","Progress from beginner"],disadvantages:["Avoid with knee injuries","Not suitable with high blood pressure","May cause strain if overdone","Requires foundation"],difficulty:"Intermediate",duration:"30-60 seconds",subCategories:["Intermediate","Power Yoga"]},{id:137,name:"\u0aa4\u0acd\u0ab0\u0abf\u0a95\u0acb\u0aa3\u0abe\u0ab8\u0aa8 (Trikonasana) - Triangle Pose",image:o(137,"Trikonasana"),description:"A standing pose perfect for intermediate level. Improves flexibility and strength. Progress from beginner poses.",advantages:["Perfect for intermediate","Improves flexibility","Strengthens legs","Progress from beginner","Improves balance","Opens hips"],disadvantages:["Avoid with low blood pressure","Not suitable with neck injuries","May cause dizziness","Requires some flexibility"],difficulty:"Intermediate",duration:"30-60 seconds each side",subCategories:["Intermediate","Power Yoga"]},{id:138,name:"Navasana (Navasana) - Boat Pose",image:o(138,"Navasana"),description:"A core strengthening pose perfect for intermediate level. Builds core strength and improves balance.",advantages:["Perfect for intermediate","Strengthens core","Improves balance","Tones muscles","Builds strength","Progress from beginner"],disadvantages:["Avoid with lower back injuries","Not suitable during pregnancy","May cause strain if forced","Requires core strength"],difficulty:"Intermediate",duration:"20-40 seconds",subCategories:["Intermediate","Power Yoga"]},{id:139,name:"Chaturanga Dandasana (Chaturanga Dandasana) - Four-Limbed Staff Pose",image:o(139,"Chaturanga Dandasana"),description:"A challenging pose perfect for advanced level. Builds upper body and core strength. Requires significant strength.",advantages:["Perfect for advanced","Builds strength","Tones entire body","Builds endurance","Challenging","Requires skill"],disadvantages:["Requires significant strength","Avoid with wrist injuries","Not suitable with shoulder problems","Very challenging","Not for beginners"],difficulty:"Advanced",duration:"10-30 seconds",subCategories:["Advanced","Expert","Power Yoga"]},{id:140,name:"Adho Mukha Vrksasana (Adho Mukha Vrksasana) - Handstand",image:o(140,"Adho Mukha Vrksasana"),description:"An advanced inversion perfect for expert level. Builds upper body strength and improves balance. Very challenging.",advantages:["Perfect for expert","Builds upper body strength","Improves balance","Tones entire body","Builds confidence","Very challenging"],disadvantages:["Requires significant strength","Avoid with wrist injuries","Not suitable with high blood pressure","Very challenging","Requires proper technique","Not for beginners"],difficulty:"Expert",duration:"10-30 seconds",subCategories:["Expert","Advanced","Power Yoga"]},{id:141,name:"Urdhva Dhanurasana (Urdhva Dhanurasana) - Wheel Pose",image:o(141,"Urdhva Dhanurasana"),description:"An advanced backbend perfect for expert level. Requires significant flexibility and strength. Very challenging.",advantages:["Perfect for expert","Builds strength","Improves flexibility","Opens chest","Tones entire body","Very challenging"],disadvantages:["Requires significant flexibility","Avoid with back injuries","Not suitable with high blood pressure","Very challenging","Requires proper technique","Not for beginners"],difficulty:"Expert",duration:"10-30 seconds",subCategories:["Expert","Advanced","Power Yoga"]},{id:142,name:"\u0ab5\u0abf\u0aaa\u0ab0\u0ac0\u0aa4 \u0a95\u0ab0\u0aa3\u0ac0 (Viparita Karani) - Legs-Up-the-Wall Pose",image:o(142,"Viparita Karani"),description:"A restorative pose perfect for gentle and therapeutic yoga. Promotes relaxation and recovery. Safe for all levels.",advantages:["Perfect for gentle yoga","Therapeutic","Restorative","Promotes relaxation","Safe for all levels","No physical strain"],disadvantages:["Avoid with eye pressure issues","Not suitable during menstruation","May cause discomfort with neck issues","Keep warm"],difficulty:"Beginner",duration:"5-15 minutes",subCategories:["Gentle Yoga","Restorative","Therapeutic","Beginner"]},{id:143,name:"\u0ab6\u0ab5\u0abe\u0ab8\u0aa8 (Shavasana) - Corpse Pose",image:o(143,"Shavasana"),description:"The ultimate relaxation pose essential for all levels. Promotes deep relaxation and recovery.",advantages:["Essential for all levels","Promotes deep relaxation","Promotes recovery","Reduces stress","Calms entire system","Therapeutic"],disadvantages:["May cause sleepiness","Keep warm","Not suitable if feeling unwell","Practice in quiet environment"],difficulty:"Beginner",duration:"5-20 minutes",subCategories:["Beginner","Intermediate","Advanced","Expert","Gentle Yoga","Restorative","Therapeutic","Power Yoga"]},{id:144,name:"\u0ab8\u0ac2\u0ab0\u0acd\u0aaf \u0aa8\u0aae\u0ab8\u0acd\u0a95\u0abe\u0ab0 (Surya Namaskar) - Sun Salutation",image:o(144,"Surya Namaskar"),description:"A complete sequence perfect for intermediate to advanced levels. Provides full-body workout and builds strength.",advantages:["Perfect for intermediate/advanced","Full-body workout","Builds strength","Improves flexibility","Boosts energy","Power yoga"],disadvantages:["Avoid with severe heart conditions","Not recommended during pregnancy","May cause fatigue if overdone","Requires good physical condition"],difficulty:"Intermediate",duration:"5-10 minutes",subCategories:["Intermediate","Advanced","Power Yoga"]},{id:145,name:"Bakasana (Bakasana) - Crow Pose",image:o(145,"Bakasana"),description:"An arm balance perfect for advanced level. Builds upper body and core strength. Requires significant strength.",advantages:["Perfect for advanced","Builds upper body strength","Strengthens core","Improves balance","Tones arms","Requires skill"],disadvantages:["Requires upper body strength","Avoid with wrist injuries","Not suitable with shoulder problems","Challenging","Not for beginners"],difficulty:"Advanced",duration:"10-30 seconds",subCategories:["Advanced","Expert","Power Yoga"]},{id:146,name:"\u0ab8\u0ac7\u0aa4\u0ac1 \u0aac\u0a82\u0aa7\u0abe\u0ab8\u0aa8 (Setu Bandhasana) - Bridge Pose",image:o(146,"Setu Bandhasana"),description:"A gentle backbend perfect for beginners and gentle yoga. Strengthens back and opens chest. Therapeutic.",advantages:["Perfect for beginners","Gentle yoga","Therapeutic","Strengthens back","Opens chest","Safe and gentle"],disadvantages:["Avoid with neck injuries","Not suitable with severe back problems","Avoid during late pregnancy","Keep it gentle"],difficulty:"Beginner",duration:"30-60 seconds",subCategories:["Beginner","Gentle Yoga","Restorative","Therapeutic"]},{id:147,name:"Padmasana (Padmasana) - Lotus Pose",image:o(147,"Padmasana"),description:"The classic meditation pose perfect for intermediate to advanced levels. Requires flexibility and practice.",advantages:["Perfect for intermediate/advanced","Classic meditation pose","Improves focus","Opens hips","Improves posture","Enhances concentration"],disadvantages:["Requires flexible hips","Can strain knees if forced","Not suitable for knee injuries","May cause ankle discomfort","Difficult for beginners"],difficulty:"Intermediate",duration:"5-30 minutes",subCategories:["Intermediate","Advanced","Expert"]}]};(0,E.useEffect)(()=>{var n;if(null!==(n=t.state)&&void 0!==n&&n.category)s(t.state.category),i(t.state.subCategory);else{const t={"pain-relief":{id:"pain-relief",name:"Pain Relief Yoga",icon:"\ud83e\ude79",subCategories:["Back Pain","Knee Pain","Neck Pain","Shoulder Pain","Sciatica","Joint Pain","Arthritis","Muscle Tension"]},"disease-specific":{id:"disease-specific",name:"Disease-Specific Yoga",icon:"\ud83c\udfe5",subCategories:["Diabetes","Blood Pressure (BP)","Thyroid","PCOS","Asthma","Heart Health","Digestive Issues","Immune System"]},"age-groups":{id:"age-groups",name:"Yoga for Age Groups",icon:"\ud83d\udc65",subCategories:["Kids Yoga (5-12 years)","Teens Yoga (13-19 years)","Adults (20-50 years)","Seniors (50+ years)"]},women:{id:"women",name:"Yoga for Women",icon:"\ud83d\udc69",subCategories:["Pregnancy Yoga","Postnatal Yoga","Menstrual Health","Menopause","Hormonal Balance","Pelvic Health"]},"mental-health":{id:"mental-health",name:"Yoga for Mental Health",icon:"\ud83e\uddd8",subCategories:["Stress Relief","Anxiety Management","Depression Support","Sleep Disorders","Focus & Concentration","Emotional Balance"]},"fitness-goals":{id:"fitness-goals",name:"Fitness & Body Goals",icon:"\ud83d\udcaa",subCategories:["Weight Loss","Weight Gain","Flexibility","Strength Building","Muscle Tone","Core Strength","Cardio Fitness","Body Sculpting"]},lifestyle:{id:"lifestyle",name:"Lifestyle Yoga",icon:"\ud83c\udf31",subCategories:["Office Workers","Athletes","Daily Routine","Morning Yoga","Evening Yoga","Desk Yoga","Travel Yoga","Quick Sessions"]},meditation:{id:"meditation",name:"Meditation & Pranayama",icon:"\ud83d\udd49\ufe0f",subCategories:["Breathing Exercises","Mindfulness","Guided Meditation","Chakra Balancing","Energy Healing","Relaxation Techniques"]},programs:{id:"programs",name:"Yoga Programs",icon:"\ud83d\udcda",subCategories:["Online Programs","Offline Classes","7-Day Challenge","30-Day Transformation","Beginner Course","Advanced Training"]},levels:{id:"levels",name:"Yoga Levels",icon:"\ud83d\udcca",subCategories:["Beginner","Intermediate","Advanced","Expert","Therapeutic","Restorative","Power Yoga","Gentle Yoga"]}};s(t[e]||t["pain-relief"])}},[e,t.state]);const l=()=>c[e]||c["pain-relief"],u=r?l().filter(e=>{var t;return null===(t=e.subCategories)||void 0===t?void 0:t.some(e=>e.toLowerCase().includes(r.toLowerCase()))}):l();return(0,wn.jsx)("div",{className:"category-detail-page",children:(0,wn.jsxs)("div",{className:"container",children:[(0,wn.jsxs)("button",{className:"back-button",onClick:()=>n("/pose-detection"),children:[(0,wn.jsx)(It,{})," Back to Categories"]}),a&&(0,wn.jsxs)(wn.Fragment,{children:[(0,wn.jsxs)("div",{className:"category-header-detail",children:[(0,wn.jsx)("div",{className:"category-icon-large",children:a.icon}),(0,wn.jsx)("h1",{children:a.name}),(0,wn.jsx)("p",{children:"Explore yoga poses tailored for your specific needs"})]}),a.subCategories&&a.subCategories.length>0&&(0,wn.jsxs)("div",{className:"subcategory-filter",children:[(0,wn.jsx)("button",{className:"subcategory-filter-btn ".concat(r?"":"active"),onClick:()=>i(null),children:"All"}),a.subCategories.map((e,t)=>(0,wn.jsx)("button",{className:"subcategory-filter-btn ".concat(r===e?"active":""),onClick:()=>i(e),children:e},t))]}),(0,wn.jsx)("div",{className:"poses-grid",children:u.map(e=>(0,wn.jsxs)("div",{className:"pose-card",onClick:()=>n("/pose/".concat(e.id),{state:{pose:e}}),style:{cursor:"pointer"},children:[(0,wn.jsxs)("div",{className:"pose-image-container",children:[(0,wn.jsx)("img",{src:e.image,alt:e.name,className:"pose-image",loading:"lazy",onError:t=>{const n="https://source.unsplash.com/400x300/?yoga&sig=".concat(e.id);let a=0;t.target.onerror=()=>{a++,a>=2?t.target.style.display="none":t.target.src=n},t.target.src=n}}),(0,wn.jsx)("span",{className:"pose-difficulty-badge ".concat(e.difficulty.toLowerCase()),children:e.difficulty})]}),(0,wn.jsxs)("div",{className:"pose-content",children:[(0,wn.jsx)("h3",{className:"pose-name",children:e.name}),(0,wn.jsx)("p",{className:"pose-description",children:e.description}),(0,wn.jsxs)("div",{className:"pose-duration",children:[(0,wn.jsx)("strong",{children:"Duration:"})," ",e.duration]}),(0,wn.jsxs)("div",{className:"pose-advantages",children:[(0,wn.jsxs)("h4",{children:[(0,wn.jsx)(Dt,{className:"icon-advantage"}),"Advantages"]}),(0,wn.jsx)("ul",{children:e.advantages.map((e,t)=>(0,wn.jsx)("li",{children:e},t))})]}),(0,wn.jsxs)("div",{className:"pose-disadvantages",children:[(0,wn.jsxs)("h4",{children:[(0,wn.jsx)(mn,{className:"icon-disadvantage"}),"Disadvantages & Precautions"]}),(0,wn.jsx)("ul",{children:e.disadvantages.map((e,t)=>(0,wn.jsx)("li",{children:e},t))})]})]})]},e.id))})]})]})})};var cu=n(29),lu=n.n(cu);class uu{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class hu{refCount(e){return du("refCount")}incRef(e){return du("incRef")}timerAvailable(){return!0}time(e){return du("time")}read(e){return du("read")}readSync(e){return du("readSync")}readToGPU(e,t){return du("readToGPU")}numDataIds(){return du("numDataIds")}disposeData(e,t){return du("disposeData")}write(e,t,n){return du("write")}move(e,t,n,a,s){return du("move")}createTensorFromGPUData(e,t,n){return du("createTensorFromGPUData")}memory(){return du("memory")}floatPrecision(){return du("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return du("dispose")}}function du(e){throw new Error("'".concat(e,"' not yet implemented or not found in the registry. ")+"This kernel may not be supported by the tfjs backend you have chosen")}function pu(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,gu(e,t,n)}function fu(e,t,n){return Math.max(e,Math.min(t,n))}function mu(e){return e%2===0?e:e+1}function gu(e,t,n){const a=e[t];e[t]=e[n],e[n]=a}function yu(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}function bu(e,t){if(!e)throw new Error("string"===typeof t?t:t())}function xu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";bu(Su(e,t),()=>n+" Shapes ".concat(e," and ").concat(t," must match"))}function vu(e){bu(null!=e,()=>"The input to the tensor constructor must be a non-null value.")}function wu(e){if(0===e.length)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function ku(e){return 0===e.length}function Su(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function Cu(e){return e%1===0}function Iu(e){const t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function Nu(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function Tu(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e=>0,n=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0;return new Promise((s,r)=>{let i=0;const o=()=>{if(e())return void s();i++;const c=t(i);null!=n&&i>=n?r():null!=a?a(o,c):setTimeout(o,c)};o()})}function Eu(e,t){let n=1,a=-1;for(let r=0;r<e.length;++r)if(e[r]>=0)n*=e[r];else if(-1===e[r]){if(-1!==a)throw Error("Shapes can only have 1 implicit size. "+"Found -1 at dim ".concat(a," and dim ").concat(r));a=r}else if(e[r]<0)throw Error("Shapes can not be < 0. Found ".concat(e[r]," at dim ").concat(r));if(-1===a){if(t>0&&t!==n)throw Error("Size(".concat(t,") must match the product of shape ").concat(e));return e}if(0===n)throw Error("Cannot infer the missing size in [".concat(e,"] when ")+"there are 0 elements");if(t%n!==0)throw Error("The implicit shape can't be a fractional number. "+"Got ".concat(t," / ").concat(n));const s=e.slice();return s[a]=t/n,s}function Ru(e,t){const n=t.length;return bu((e=null==e?t.map((e,t)=>t):[].concat(e)).every(e=>e>=-n&&e<n),()=>"All values in axis param must be in range [-".concat(n,", ").concat(n,") but ")+"got axis ".concat(e)),bu(e.every(e=>Cu(e)),()=>"All values in axis param must be integers but "+"got axis ".concat(e)),e.map(e=>e<0?n+e:e)}function _u(e,t){const n=[],a=[],s=null!=t&&Array.isArray(t)&&0===t.length,r=null==t||s?null:Ru(t,e).sort();let i=0;for(let o=0;o<e.length;++o){if(null!=r){if(r[i]===o&&1!==e[o])throw new Error("Can't squeeze axis ".concat(o," since its dim '").concat(e[o],"' is not 1"));(null==r[i]||r[i]>o)&&1===e[o]&&(n.push(e[o]),a.push(o)),r[i]<=o&&i++}1!==e[o]&&(n.push(e[o]),a.push(o))}return{newShape:n,keptDims:a}}function Au(e,t){return Mu(e,t)}function Mu(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else if("bool"===e)n=new Uint8Array(t);else{if("string"!==e)throw new Error("Unknown data type ".concat(e));n=new Array(t)}return n}function Pu(e,t){return"complex64"!==t&&(("float32"!==t||"complex64"===e)&&(("int32"!==t||"float32"===e||"complex64"===e)&&("bool"!==t||"bool"!==e)))}function Du(e){if("float32"===e||"int32"===e)return 4;if("complex64"===e)return 8;if("bool"===e)return 1;throw new Error("Unknown dtype ".concat(e))}function Ou(e){return"string"===typeof e||e instanceof String}function Fu(e){return"number"===typeof e}function Lu(e){return Array.isArray(e)?Lu(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":Fu(e)?"float32":Ou(e)?"string":"boolean"===typeof e?"bool":"float32"}function zu(e){return!!(e&&e.constructor&&e.call&&e.apply)}function Bu(e,t){for(let n=t;n<e;++n)if(e%n===0)return n;return e}function ju(e){const t=e.length;if(t<2)return[];const n=new Array(t-1);n[t-2]=e[t-1];for(let a=t-3;a>=0;--a)n[a]=n[a+1]*e[a+1];return n}function Wu(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s=new Array;if(1===t.length){const r=t[0]*(a?2:1);for(let t=0;t<r;t++)s[t]=n[e+t]}else{const r=t[0],i=t.slice(1),o=i.reduce((e,t)=>e*t)*(a?2:1);for(let t=0;t<r;t++)s[t]=Wu(e+t*o,i,n,a)}return s}function Vu(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(0===e.length)return t[0];const a=e.reduce((e,t)=>e*t)*(n?2:1);if(0===a)return[];if(a!==t.length)throw new Error("[".concat(e,"] does not match the input size ").concat(t.length).concat(n?" for a complex tensor":"","."));return Wu(0,e,t,n)}function Uu(e,t){if(Array.isArray(e))return e;if("float32"===t)return e instanceof Float32Array?e:new Float32Array(e);if("int32"===t)return e instanceof Int32Array?e:new Int32Array(e);if("bool"===t||"string"===t)return Uint8Array.from(new Int32Array(e));throw new Error("Unknown dtype ".concat(t))}function Hu(e,t){const n=Gu(e,t);for(let a=0;a<n.length;a++)n[a]=1;return n}function Gu(e,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t)return new Uint8Array(e);throw new Error("Unknown data type ".concat(t))}function qu(e,t){const n=e.reduce((e,t)=>e*t,1);if(null==t||"float32"===t)return Vu(e,new Float32Array(n));if("int32"===t)return Vu(e,new Int32Array(n));if("bool"===t)return Vu(e,new Uint8Array(n));throw new Error("Unknown data type ".concat(t))}function Ku(e){e.forEach(t=>{bu(Number.isInteger(t)&&t>=0,()=>"Tensor must have a shape comprised of positive integers but got "+"shape [".concat(e,"]."))})}function Xu(e,t,n){if(0===t)return 0;if(1===t)return e[0];let a=e[e.length-1];for(let s=0;s<e.length-1;++s)a+=n[s]*e[s];return a}function Yu(e,t,n){if(0===t)return[];if(1===t)return[e];const a=new Array(t);for(let s=0;s<a.length-1;++s)a[s]=Math.floor(e/n[s]),e-=a[s]*n[s];return a[a.length-1]=e,a}function Qu(e){return e&&e.then&&"function"===typeof e.then}const Zu="tfjsflags";class Ju{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=$u,this.populateURLFlags()}setPlatform(e,t){null!=this.platform&&(eh().getBool("IS_TEST")||eh().getBool("PROD")||console.warn("Platform ".concat(this.platformName," has already been set. ")+"Overwriting the platform with ".concat(e,"."))),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},null!=this.urlFlags[e]){const t=this.urlFlags[e];eh().getBool("IS_TEST")||eh().getBool("PROD")||console.warn("Setting feature override from URL ".concat(e,": ").concat(t,".")),this.set(e,t)}}async getAsync(e){return e in this.flags||(this.flags[e]=await this.evaluateFlag(e)),this.flags[e]}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(Qu(t))throw new Error("Flag ".concat(e," cannot be synchronously evaluated. ")+"Please use getAsync() instead.");return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(null==this.flagRegistry[e])throw new Error("Cannot set flag ".concat(e," as it has not been registered."));this.flags[e]=t,null!=this.flagRegistry[e].setHook&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(null==this.flagRegistry[e])throw new Error("Cannot evaluate flag '".concat(e,"': no evaluation function found."));return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if("undefined"===typeof this.global||"undefined"===typeof this.global.location||"undefined"===typeof this.global.location.search)return;const e=this.getQueryParams(this.global.location.search);if(Zu in e){e[Zu].split(",").forEach(e=>{const[t,n]=e.split(":");this.urlFlags[t]=function(e,t){const n=t.toLowerCase();return"true"===n||"false"===n?"true"===n:"".concat(+n)===n?+n:t}(0,n)})}}}function $u(e){const t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,function(e){for(var n=arguments.length,a=new Array(n>1?n-1:0),s=1;s<n;s++)a[s-1]=arguments[s];return function(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}(t,a[0],a[1]),a.join("=")}),t}function eh(){return nh}let th,nh=null;function ah(){if(null==th){let e;if("undefined"!==typeof window)e=window;else if("undefined"!==typeof n.g)e=n.g;else if("undefined"!==typeof process)e=process;else{if("undefined"===typeof self)throw new Error("Could not find a global object");e=self}th=e}return th}function sh(e,t){const n=function(){const e=ah();return null==e._tfGlobals&&(e._tfGlobals=new Map),e._tfGlobals}();if(n.has(e))return n.get(e);{const a=t();return n.set(e,a),n.get(e)}}const rh="Abs",ih="Acos",oh="Acosh",ch="Add",lh="AddN",uh="All",hh="Any",dh="ArgMax",ph="ArgMin",fh="Asin",mh="Asinh",gh="Atan",yh="Atanh",bh="Atan2",xh="AvgPool",vh="AvgPoolGrad",wh="AvgPool3D",kh="AvgPool3DGrad",Sh="BatchMatMul",Ch="BatchToSpaceND",Ih="Bincount",Nh="BitwiseAnd",Th="BroadcastArgs",Eh="Cast",Rh="Ceil",_h="ClipByValue",Ah="Complex",Mh="ComplexAbs",Ph="Concat",Dh="Conv2D",Oh="Conv2DBackpropFilter",Fh="Conv2DBackpropInput",Lh="Conv3D",zh="Conv3DBackpropFilterV2",Bh="Conv3DBackpropInputV2",jh="Cos",Wh="Cosh",Vh="Cumprod",Uh="Cumsum",Hh="CropAndResize",Gh="DenseBincount",qh="DepthToSpace",Kh="DepthwiseConv2dNative",Xh="DepthwiseConv2dNativeBackpropFilter",Yh="DepthwiseConv2dNativeBackpropInput",Qh="Diag",Zh="Dilation2D",Jh="Dilation2DBackpropInput",$h="Dilation2DBackpropFilter",ed="Draw",td="RealDiv",nd="Einsum",ad="Elu",sd="EluGrad",rd="Erf",id="Equal",od="Exp",cd="ExpandDims",ld="Expm1",ud="FFT",hd="Fill",dd="FlipLeftRight",pd="Floor",fd="FloorDiv",md="FusedBatchNorm",gd="GatherV2",yd="GatherNd",bd="Greater",xd="GreaterEqual",vd="Identity",wd="IFFT",kd="Imag",Sd="IsFinite",Cd="IsInf",Id="IsNan",Nd="LeakyRelu",Td="Less",Ed="LessEqual",Rd="LinSpace",_d="Log",Ad="Log1p",Md="LogicalAnd",Pd="LogicalNot",Dd="LogicalOr",Od="LRN",Fd="LRNGrad",Ld="Max",zd="Maximum",Bd="MaxPool",jd="MaxPoolGrad",Wd="MaxPool3D",Vd="MaxPool3DGrad",Ud="MaxPoolWithArgmax",Hd="Mean",Gd="Min",qd="Minimum",Kd="MirrorPad",Xd="Mod",Yd="Multinomial",Qd="Multiply",Zd="Neg",Jd="NotEqual",$d="NonMaxSuppressionV3",ep="NonMaxSuppressionV4",tp="NonMaxSuppressionV5",np="OnesLike",ap="OneHot",sp="Pack",rp="PadV2",ip="Pow",op="Prelu",cp="Prod",lp="RaggedGather",up="RaggedRange",hp="RaggedTensorToTensor",dp="Range",pp="Real",fp="Reciprocal",mp="Relu",gp="Reshape",yp="ResizeNearestNeighbor",bp="ResizeNearestNeighborGrad",xp="ResizeBilinear",vp="ResizeBilinearGrad",wp="Relu6",kp="Reverse",Sp="Round",Cp="Rsqrt",Ip="ScatterNd",Np="TensorScatterUpdate",Tp="SearchSorted",Ep="Select",Rp="Selu",_p="Slice",Ap="Sin",Mp="Sinh",Pp="Sign",Dp="Sigmoid",Op="Softplus",Fp="Sqrt",Lp="Sum",zp="SpaceToBatchND",Bp="SplitV",jp="Softmax",Wp="SparseFillEmptyRows",Vp="SparseReshape",Up="SparseSegmentMean",Hp="SparseSegmentSum",Gp="SparseToDense",qp="SquaredDifference",Kp="Square",Xp="StaticRegexReplace",Yp="StridedSlice",Qp="StringNGrams",Zp="StringSplit",Jp="StringToHashBucketFast",$p="Sub",ef="Tan",tf="Tanh",nf="Tile",af="TopK",sf="Transform",rf="Transpose",of="Unique",cf="Unpack",lf="UnsortedSegmentSum",uf="ZerosLike",hf="Step",df="FromPixels",pf="RotateWithOffset",ff="_FusedMatMul",mf="FusedConv2D",gf="FusedDepthwiseConv2D";function yf(){eh().getBool("IS_TEST")||eh().getBool("PROD")||console.warn(...arguments)}function bf(){eh().getBool("IS_TEST")||eh().getBool("PROD")||console.log(...arguments)}const xf=sh("kernelRegistry",()=>new Map),vf=sh("gradRegistry",()=>new Map);function wf(e,t){const n=Nf(e,t);return xf.get(n)}function kf(e){return vf.get(e)}function Sf(e){const t=xf.entries(),n=[];for(;;){const{done:a,value:s}=t.next();if(a)break;const[r,i]=s,[o]=r.split("_");o===e&&n.push(i)}return n}function Cf(e){const{kernelName:t,backendName:n}=e,a=Nf(t,n);xf.has(a)&&yf("The kernel '".concat(t,"' for backend ")+"'".concat(n,"' is already registered")),xf.set(a,e)}function If(e){const{kernelName:t}=e;vf.has(t)&&eh().getBool("DEBUG")&&yf("Overriding the gradient for '".concat(t,"'")),vf.set(t,e)}function Nf(e,t){return"".concat(t,"_").concat(e)}function Tf(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}var Ef=n(353);const Rf=n.n(Ef)()||Ef;function _f(e){return Rf.fromString(e,!0,16)}const Af=_f("c3a5c85c97cb3127"),Mf=_f("b492b66fbe98f273"),Pf=_f("9ae16a3b2f90404f");function Df(e){return e.xor(e.shru(47))}function Of(e,t,n){const a=e.slice(t,t+n);return Rf.fromBytes(Array.from(a),!0,!0)}function Ff(e,t){return Of(e,t,8)}function Lf(e,t){return Of(e,t,4)}function zf(e,t){return 0===t?e:e.shru(t).or(e.shl(64-t))}function Bf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:_f("9ddfea08eb382d69"),a=e.xor(t).mul(n);a=a.xor(a.shru(47));let s=t.xor(a).mul(n);return s=s.xor(s.shru(47)),s=s.mul(n),s}function jf(e,t,n,a){return function(e,t,n,a,s,r){s=s.add(e),r=zf(r.add(s).add(a),21);const i=s;return s=(s=s.add(t)).add(n),r=r.add(zf(s,44)),[s.add(a),r.add(i)]}(Ff(e,t),Ff(e,t+8),Ff(e,t+16),Ff(e,t+24),n,a)}function Wf(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;const n=Rf.fromNumber(81,!0);if(t<=32)return t<=16?function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;if(t>=8){const n=Pf.add(2*t),a=Ff(e,0).add(Pf),s=Ff(e,t-8);return Bf(zf(s,37).mul(n).add(a),zf(a,25).add(s).mul(n),n)}if(t>=4){const n=Pf.add(2*t);return Bf(Lf(e,0).shl(3).add(t),Lf(e,t-4),n)}if(t>0){const n=e[0]+(e[t>>1]<<8),a=t+(e[t-1]<<2);return Df(Pf.mul(n).xor(Af.mul(a))).mul(Pf)}return Pf}(e,t):function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;const n=Pf.add(2*t),a=Ff(e,0).mul(Mf),s=Ff(e,8),r=Ff(e,t-8).mul(n),i=Ff(e,t-16).mul(Pf);return Bf(zf(a.add(s),43).add(zf(r,30)).add(i),a.add(zf(s.add(Pf),18)).add(r),n)}(e,t);if(t<=64)return function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;const n=Pf.add(2*t),a=Ff(e,0).mul(Pf),s=Ff(e,8),r=Ff(e,t-8).mul(n),i=Ff(e,t-16).mul(Pf),o=zf(a.add(s),43).add(zf(r,30)).add(i),c=Bf(o,a.add(zf(s.add(Pf),18)).add(r),n),l=Ff(e,16).mul(n),u=Ff(e,24),h=o.add(Ff(e,t-32)).mul(n),d=c.add(Ff(e,t-24)).mul(n);return Bf(zf(l.add(u),43).add(zf(h,30)).add(d),l.add(zf(u.add(a),18)).add(h),n)}(e,t);let a=n,s=n.mul(Mf).add(113),r=Df(s.mul(Pf).add(113)).mul(Pf),i=[Rf.UZERO,Rf.UZERO],o=[Rf.UZERO,Rf.UZERO];a=a.mul(Pf).add(Ff(e,0));let c=0;const l=64*(t-1>>6),u=l+(t-1&63)-63;do{a=zf(a.add(s).add(i[0]).add(Ff(e,c+8)),37).mul(Mf),s=zf(s.add(i[1]).add(Ff(e,c+48)),42).mul(Mf),a=a.xor(o[1]),s=s.add(i[0]).add(Ff(e,c+40)),r=zf(r.add(o[0]),33).mul(Mf),i=jf(e,c,i[1].mul(Mf),a.add(o[0])),o=jf(e,c+32,r.add(o[1]),s.add(Ff(e,c+16))),[r,a]=[a,r],c+=64}while(c!==l);const h=Mf.add(r.and(255).shl(1));return c=u,o[0]=o[0].add(t-1&63),i[0]=i[0].add(o[0]),o[0]=o[0].add(i[0]),a=zf(a.add(s).add(i[0]).add(Ff(e,c+8)),37).mul(h),s=zf(s.add(i[1]).add(Ff(e,c+48)),42).mul(h),a=a.xor(o[1].mul(9)),s=s.add(i[0].mul(9).add(Ff(e,c+40))),r=zf(r.add(o[0]),33).mul(h),i=jf(e,c,i[1].mul(h),a.add(o[0])),o=jf(e,c+32,r.add(o[1]),s.add(Ff(e,c+16))),[r,a]=[a,r],Bf(Bf(i[0],o[0],h).add(Df(s).mul(Af)).add(r),Bf(i[1],o[1],h).add(a),h)}function Vf(e,t){return"string"===t?Gf(e):Uf([e],t)}function Uf(e,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=Xf(e)),eh().getBool("DEBUG")&&function(e,t){for(let n=0;n<e.length;n++){const a=e[n];if(isNaN(a)||!isFinite(a))throw Error("A tensor of type ".concat(t," being uploaded contains ").concat(a,"."))}}(e,t),function(e,t){return e instanceof Float32Array&&"float32"===t||e instanceof Int32Array&&"int32"===t||e instanceof Uint8Array&&"bool"===t}(e,t))return e;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t){const t=new Uint8Array(e.length);for(let n=0;n<t.length;++n)0!==Math.round(e[n])&&(t[n]=1);return t}throw new Error("Unknown data type ".concat(t))}function Hf(){return eh().platform.now()}function Gf(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf-8";return t=t||"utf-8",eh().platform.encode(e,t)}function qf(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf-8";return t=t||"utf-8",eh().platform.decode(e,t)}function Kf(e){return null!=eh().platform.isTypedArray?eh().platform.isTypedArray(e):Tf(e)}function Xf(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(null==t&&(t=[]),"boolean"===typeof e||"number"===typeof e||"string"===typeof e||Qu(e)||null==e||Kf(e)&&n)t.push(e);else if(Array.isArray(e)||Kf(e))for(let a=0;a<e.length;++a)Xf(e[a],t,n);else{let a=-1;for(const t of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(t)&&(a=Math.max(a,Number(t)));for(let s=0;s<=a;s++)Xf(e[s],t,n)}return t}class Yf{constructor(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new Zf)}profileKernel(e,t,n){let a;const s=()=>{a=n()};let r;const i=Hf();if(this.backendTimer.timerAvailable())r=this.backendTimer.time(s);else{s();for(const e of a)e.dataSync();r=Promise.resolve({kernelMs:Hf()-i})}if(eh().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let o=0;o<a.length;o++){const t=a[o];t.data().then(n=>{Qf(n,t.dtype,e)})}return{kernelName:e,outputs:a,inputs:t,timeMs:r.then(e=>e.kernelMs),extraInfo:r.then(e=>null!=e.getExtraProfileInfo?e.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:t,outputs:n,timeMs:a,inputs:s,extraInfo:r}=e;n.forEach(e=>{Promise.all([e.data(),a,r]).then(n=>{this.logger.logKernelProfile(t,e,n[0],n[1],s,n[2])})})}}function Qf(e,t,n){if("float32"!==t)return!1;for(let a=0;a<e.length;a++){const t=e[a];if(isNaN(t)||!isFinite(t))return console.warn("Found ".concat(t," in the result of '").concat(n,"'")),!0}return!1}class Zf{logKernelProfile(e,t,n,a,s,r){const i="number"===typeof a?Nu("".concat(a,"ms"),9):a.error,o=Nu(e,25),c=t.rank,l=t.size,u=Nu(t.shape.toString(),14);let h="";for(const d in s){const e=s[d];if(null!=e){const n=e.shape||t.shape,a=n.length;h+="".concat(d,": ").concat(a,"D ").concat(a>0?n:""," ")}}console.log("%c".concat(o,"\t%c").concat(i,"\t%c").concat(c,"D ").concat(u,"\t%c").concat(l,"\t%c").concat(h,"\t%c").concat(r),"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function Jf(e,t,n,a){const s=ju(t),r=function(e,t,n,a){const s=wu(t),r=a[a.length-1],i=new Array(r).fill(0),o=t.length,c="complex64"===n?nm(e):e;if(o>1)for(let l=0;l<s/r;l++){const e=l*r;for(let t=0;t<r;t++)i[t]=Math.max(i[t],$f(c[e+t],0,n).length)}return i}(e,t,n,s),i=t.length,o=tm(e,t,n,s,r),c=["Tensor"];return a&&(c.push("  dtype: ".concat(n)),c.push("  rank: ".concat(i)),c.push("  shape: [".concat(t,"]")),c.push("  values:")),c.push(o.map(e=>"    "+e).join("\n")),c.join("\n")}function $f(e,t,n){let a;return a=Array.isArray(e)?"".concat(parseFloat(e[0].toFixed(7))," + ")+"".concat(parseFloat(e[1].toFixed(7)),"j"):Ou(e)?"'".concat(e,"'"):"bool"===n?em(e):parseFloat(e.toFixed(7)).toString(),Nu(a,t)}function em(e){return 0===e?"false":"true"}function tm(e,t,n,a,s){let r=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const i="complex64"===n?2:1,o=t[0],c=t.length;if(0===c){if("complex64"===n){return[$f(nm(e)[0],0,n)]}return"bool"===n?[em(e[0])]:[e[0].toString()]}if(1===c){if(o>20){const t=3*i;let a=Array.from(e.slice(0,t)),r=Array.from(e.slice((o-3)*i,o*i));return"complex64"===n&&(a=nm(a),r=nm(r)),["["+a.map((e,t)=>$f(e,s[t],n)).join(", ")+", ..., "+r.map((e,t)=>$f(e,s[o-3+t],n)).join(", ")+"]"]}return["["+("complex64"===n?nm(e):Array.from(e)).map((e,t)=>$f(e,s[t],n)).join(", ")+"]"]}const l=t.slice(1),u=a.slice(1),h=a[0]*i,d=[];if(o>20){for(let t=0;t<3;t++){const a=t*h,r=a+h;d.push(...tm(e.slice(a,r),l,n,u,s,!1))}d.push("...");for(let t=o-3;t<o;t++){const a=t*h,r=a+h;d.push(...tm(e.slice(a,r),l,n,u,s,t===o-1))}}else for(let m=0;m<o;m++){const t=m*h,a=t+h;d.push(...tm(e.slice(t,a),l,n,u,s,m===o-1))}const p=2===c?",":"";d[0]="["+(o>0?d[0]+p:"");for(let m=1;m<d.length-1;m++)d[m]=" "+d[m]+p;let f=",\n";for(let m=2;m<c;m++)f+="\n";return d[d.length-1]=" "+d[d.length-1]+"]"+(r?"":f),d}function nm(e){const t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}class am{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=wu(e),null!=n){const e=n.length;bu(e===this.size,()=>"Length of values '".concat(e,"' does not match the size ")+"inferred by the shape '".concat(this.size,"'."))}if("complex64"===t)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||Mu(t,this.size),this.strides=ju(e)}set(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),a=1;a<t;a++)n[a-1]=arguments[a];0===n.length&&(n=[0]),bu(n.length===this.rank,()=>"The number of provided coordinates (".concat(n.length,") must ")+"match the rank (".concat(this.rank,")"));const s=this.locToIndex(n);this.values[s]=e}get(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];0===t.length&&(t=[0]);let a=0;for(const r of t){if(r<0||r>=this.shape[a]){const e="Requested out of range element at ".concat(t,". ")+"  Buffer shape=".concat(this.shape);throw new Error(e)}a++}let s=t[t.length-1];for(let r=0;r<t.length-1;++r)s+=this.strides[r]*t[r];return this.values[s]}locToIndex(e){if(0===this.rank)return 0;if(1===this.rank)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(0===this.rank)return[];if(1===this.rank)return[e];const t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return sm().makeTensor(this.values,this.shape,this.dtype)}}let sm=null,rm=null,im=null;class om{constructor(e,t,n,a){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=wu(e),this.strides=ju(e),this.dataId=n,this.id=a,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return rm.buffer(this.shape,this.dtype,e)}bufferSync(){return rm.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return Vu(this.shape,e,"complex64"===this.dtype)}arraySync(){return Vu(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();const e=sm().read(this.dataId);if("string"===this.dtype){const n=await e;try{return n.map(e=>qf(e))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),sm().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=sm().readSync(this.dataId);if("string"===this.dtype)try{return e.map(e=>qf(e))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await sm().read(this.dataId);return"string"===this.dtype?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),sm().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return rm.print(this,e)}clone(){return this.throwIfDisposed(),rm.clone(this)}toString(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return Jf(this.dataSync(),this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),rm.cast(this,e)}variable(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],t=arguments.length>1?arguments[1]:void 0,n=arguments.length>2?arguments[2]:void 0;return this.throwIfDisposed(),sm().makeVariable(this,e,t,n)}}function cm(){return sh("Tensor",()=>om)}Object.defineProperty(om,Symbol.hasInstance,{value:e=>!!e&&null!=e.data&&null!=e.dataSync&&null!=e.throwIfDisposed}),cm();class lm extends om{constructor(e,t,n,a){super(e.shape,e.dtype,e.dataId,a),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error("dtype of the new value (".concat(e.dtype,") and ")+"previous value (".concat(this.dtype,") must match"));if(!Su(e.shape,this.shape))throw new Error("shape of the new value (".concat(e.shape,") and ")+"previous value (".concat(this.shape,") must match"));sm().disposeTensor(this),this.dataId=e.dataId,sm().incRef(this,null)}dispose(){sm().disposeVariable(this),this.isDisposedInternal=!0}}var um,hm,dm,pm,fm;Object.defineProperty(lm,Symbol.hasInstance,{value:e=>e instanceof om&&null!=e.assign&&e.assign instanceof Function}),function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"}(um||(um={})),function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"}(hm||(hm={})),function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"}(dm||(dm={})),function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"}(pm||(pm={})),function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"}(fm||(fm={}));const mm={float32:pm,int32:hm,bool:dm,complex64:fm};function gm(e,t){if("string"===e||"string"===t){if("string"===e&&"string"===t)return"string";throw new Error("Can not upcast ".concat(e," with ").concat(t))}return mm[e][t]}function ym(e){return gm(e,"int32")}function bm(e){return null!=e&&"object"===typeof e&&"texture"in e&&e.texture instanceof WebGLTexture}function xm(e){return"undefined"!==typeof GPUBuffer&&null!=e&&"object"===typeof e&&"buffer"in e&&e.buffer instanceof GPUBuffer}function vm(e,t){if(e.dtype===t.dtype)return[e,t];const n=gm(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function wm(e,t){return t.some(t=>t.id===e.id)}function km(e){const t=[];return Sm(e,t,new Set),t}function Sm(e,t,n){if(null==e)return;if(e instanceof om)return void t.push(e);if(a=e,!Array.isArray(a)&&"object"!==typeof a)return;var a;const s=e;for(const r in s){const e=s[r];n.has(e)||(n.add(e),Sm(e,t,n))}}function Cm(e){return null!=e.kernelName}class Im{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class Nm{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new Im}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then(()=>{});if(null!=this.backendInstance)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t];if(await this.initializeBackend(n).success)return void await this.setBackend(n)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error("Backend '".concat(this.backendName,"' has not yet been initialized. Make ")+"sure to await tf.ready() or await tf.setBackend() before calling other methods");if(null==this.backendInstance){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error("The highest priority backend '".concat(e,"' has not yet been ")+"initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{const{asyncInit:t}=this.initializeBackend(e);if(t)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return e in this.registryFactory?(yf("".concat(e," backend was already registered. ")+"Reusing existing backend factory."),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(null==this.registryFactory[e])throw new Error("Backend name '".concat(e,"' not found in registry"));if(this.backendName=e,null==this.registry[e]){this.backendInstance=null;const{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new Yf(this.backendInstance),!0}setupRegisteredKernels(){Sf(this.backendName).forEach(e=>{null!=e.setupFunc&&e.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){Sf(e).forEach(t=>{null!=t.disposeFunc&&t.disposeFunc(this.registry[e])})}initializeBackend(e){const t=this.registryFactory[e];if(null==t)throw new Error("Cannot initialize backend ".concat(e,", no registration found."));try{const n=t.factory();if(!n||n instanceof hu||"function"!==typeof n.then)return this.registry[e]=n,{success:!0,asyncInit:!1};{const t=++this.pendingBackendInitId,a=n.then(n=>!(t<this.pendingBackendInitId)&&(this.registry[e]=n,this.pendingBackendInit=null,!0)).catch(n=>(t<this.pendingBackendInitId||(this.pendingBackendInit=null,yf("Initialization of backend ".concat(e," failed")),yf(n.stack||n.message)),!1));return this.pendingBackendInit=a,{success:a,asyncInit:!0}}}catch(n){return yf("Initialization of backend ".concat(e," failed")),yf(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error("".concat(e," backend not found in registry"));this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t],{success:a,asyncInit:s}=this.initializeBackend(n);if(s||a)return{name:n,asyncInit:s}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const n=this.state.tensorInfo.get(t),a=n.backend,s=this.readSync(t),r=a.refCount(t);a.disposeData(t,!0),n.backend=e,e.move(t,s,n.shape,n.dtype,r),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n,a=null;if(null==t){if("function"!==typeof e)throw new Error("Please provide a function to tidy()");t=e}else{if("string"!==typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!==typeof t)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");a=e}return this.scopedRun(()=>this.startScope(a),()=>this.endScope(n),()=>(n=t(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n))}scopedRun(e,t,n){e();try{const e=n();return t(),e}catch(a){throw t(),a}}nextTensorId(){return Nm.nextTensorId++}nextVariableId(){return Nm.nextVariableId++}clone(e){const t=Em.runKernel(vd,{x:e}),n={x:e};return this.addTapeNode(this.state.activeScope.name,n,[t],e=>({x:()=>{const t={x:e},n={dtype:"float32"};return Em.runKernel(Eh,t,n)}}),[],{}),t}runKernel(e,t,n){null==this.backendName&&this.backend;if(!(null!=wf(e,this.backendName)))throw new Error("Kernel '".concat(e,"' not registered for backend '").concat(this.backendName,"'"));return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){const a=this.backend.numDataIds();let s=0;n.forEach(e=>{s+="complex64"===e.dtype?3:1});const r=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],i=a-t-s-r;if(i>0)throw new Error("Backend '".concat(this.backendName,"' has an internal memory leak ")+"(".concat(i," data ids) after running '").concat(e,"'"))}runKernelFunc(e){let t,n=[];const a=this.isTapeOn(),s=this.state.numBytes,r=this.state.numTensors;let i,o;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;const c=Cm(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(Cm(e)){const{kernelName:t,inputs:s,attrs:r}=e;null==this.backendName&&this.backend;const c=wf(t,this.backendName);bu(null!=c,()=>"Cannot find registered kernel '".concat(t,"' for backend '").concat(this.backendName,"'")),i=()=>{const e=this.backend.numDataIds();o=c.kernelFunc({inputs:s,attrs:r,backend:this.backend});const i=Array.isArray(o)?o:[o];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(t,e,i);const l=i.map(e=>null!=e.rank?e:this.makeTensorFromTensorInfo(e));if(a){const e=this.getTensorsForGradient(t,s,l);n=this.saveTensorsForBackwardMode(e)}return l}}else{const{forwardFunc:t}=e,s=e=>{a&&(n=e.map(e=>this.keep(this.clone(e))))};i=()=>{const e=this.backend.numDataIds();o=this.tidy(()=>t(this.backend,s));const n=Array.isArray(o)?o:[o];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,e,n),n}}const{inputs:l,attrs:u}=e,h=Cm(e)?null:e.backwardsFunc;let d;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(d=this.profiler.profileKernel(c,l,()=>i()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(d),t=d.outputs):t=i()}),a&&this.addTapeNode(c,l,t,h,n,u),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-r,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(l).map(e=>null!=l[e]?l[e].shape:null),outputShapes:t.map(e=>e.shape),kernelTimeMs:d.timeMs,extraInfo:d.extraInfo}),Array.isArray(o)?t:t[0]}saveTensorsForBackwardMode(e){const t=e.map(e=>this.keep(this.clone(e)));return t}getTensorsForGradient(e,t,n){const a=kf(e);if(null!=a){const e=a.inputsToSave||[],s=a.outputsToSave||[];let r;a.saveAllInputs?(bu(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),r=Object.keys(t).map(e=>t[e])):r=e.map(e=>t[e]);const i=n.filter((e,t)=>s[t]);return r.concat(i)}return[]}makeTensor(e,t,n,a){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",a=a||this.backend;let s=e;"string"===n&&Ou(e[0])&&(s=e.map(e=>Gf(e)));const r=a.write(s,t,n),i=new om(t,n,r,this.nextTensorId());if(this.trackTensor(i,a),"string"===n){const e=this.state.tensorInfo.get(r),t=function(e){if(null==e)return 0;let t=0;return e.forEach(e=>t+=e.length),t}(s);this.state.numBytes+=t-e.bytes,e.bytes=t}return i}makeTensorFromDataId(e,t,n,a){const s={dataId:e,shape:t,dtype:n=n||"float32"};return this.makeTensorFromTensorInfo(s,a)}makeTensorFromTensorInfo(e,t){const{dataId:n,shape:a,dtype:s}=e,r=new om(a,s,n,this.nextTensorId());return this.trackTensor(r,t),r}makeVariable(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0;n=n||this.nextVariableId().toString(),null!=a&&a!==e.dtype&&(e=e.cast(a));const s=new lm(e,t,n,this.nextTensorId());if(null!=this.state.registeredVariables[s.name])throw new Error("Variable with name ".concat(s.name," was already registered"));return this.state.registeredVariables[s.name]=s,this.incRef(s,this.backend),s}trackTensor(e,t){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(n=e.size*Du(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof lm||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){const t=e.size*Du(e.dtype);this.state.numBytes-=t}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(e=>e.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const a of this.state.activeProfile.kernels)a.kernelTimeMs=await a.kernelTimeMs,a.extraInfo=await a.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,t,n,a,s,r){const i={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:s},o=kf(e);null!=o&&(a=o.gradFunc),null!=a&&(i.gradient=e=>(e=e.map((e,t)=>{if(null==e){const e=n[t],a=Gu(e.size,e.dtype);return this.makeTensor(a,e.shape,e.dtype)}return e}),a(e.length>1?e:e[0],s,r))),this.state.activeTape.push(i)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=km(e),n=new Set(t.map(e=>e.id));for(let s=0;s<this.state.activeScope.track.length;s++){const e=this.state.activeScope.track[s];e.kept||n.has(e.id)||e.dispose()}const a=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(e=>{e.kept||e.scopeId!==a.id||this.track(e)})}gradients(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(bu(t.length>0,()=>"gradients() received an empty list of xs."),null!=n&&"float32"!==n.dtype)throw new Error("dy must have 'float32' dtype, but has '".concat(n.dtype,"'"));const s=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));bu(s instanceof om,()=>"The result y returned by f() must be a tensor.");const r=function(e,t,n){const a={},s={};for(let c=0;c<t.length;c++)a[t[c].id]=!0;for(let c=0;c<e.length;c++){const n=e[c],r=n.inputs;for(const e in r){const i=r[e];let o=!1;for(let e=0;e<t.length;e++)if(a[i.id]){n.outputs.forEach(e=>a[e.id]=!0),o=!0,s[n.id]=!0;break}if(o)break}}const r={};r[n.id]=!0;const i={};for(let c=e.length-1;c>=0;c--){const t=e[c],n=t.inputs;for(let e=0;e<t.outputs.length;e++)if(r[t.outputs[e].id]){for(const e in n)r[n[e].id]=!0,i[t.id]=!0;break}}const o=[];for(let c=0;c<e.length;c++){const t=e[c];if(s[t.id]&&i[t.id]){const e={};for(const s in t.inputs){const n=t.inputs[s];a[n.id]&&(e[s]=n)}const n=Object.assign({},t);n.inputs=e,n.outputs=t.outputs,o.push(n)}}return o}(this.state.activeTape,t,s);if(!a&&0===r.length&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const e={};e[s.id]=null==n?function(e){const t=Hu(wu(e),"float32");return Em.makeTensor(t,e,"float32")}(s.shape):n,function(e,t,n,a){for(let s=t.length-1;s>=0;s--){const r=t[s],i=[];if(r.outputs.forEach(t=>{const n=e[t.id];null!=n?i.push(n):i.push(null)}),null==r.gradient)throw new Error("Cannot compute gradient: gradient function not found "+"for ".concat(r.kernelName,"."));const o=r.gradient(i);for(const t in r.inputs){if(!(t in o))throw new Error("Cannot backprop through input ".concat(t,". ")+"Available gradients found: ".concat(Object.keys(o),"."));const s=n(()=>o[t]());if("float32"!==s.dtype)throw new Error("Error in gradient for op ".concat(r.kernelName,". The gradient of input ")+"".concat(t," must have 'float32' dtype, but has '").concat(s.dtype,"'"));const i=r.inputs[t];if(!Su(s.shape,i.shape))throw new Error("Error in gradient for op ".concat(r.kernelName,". The gradient of input ")+"'".concat(t,"' has shape '").concat(s.shape,"', which does not match ")+"the shape of the input '".concat(i.shape,"'"));if(null==e[i.id])e[i.id]=s;else{const t=e[i.id];e[i.id]=a(t,s),t.dispose()}}}}(e,r,e=>this.tidy(e),Rm);const a=t.map(t=>e[t.id]);return 0===this.state.gradientDepth&&(this.state.activeTape.forEach(e=>{for(const t of e.saved)t.dispose()}),this.state.activeTape=null),{value:s,grads:a}})}customGrad(e){var t=this;return bu(zu(e),()=>"The f passed in customGrad(f) must be a function."),function(){for(var n=arguments.length,a=new Array(n),s=0;s<n;s++)a[s]=arguments[s];let r;bu(a.every(e=>e instanceof om),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");const i={};a.forEach((e,t)=>{i[t]=e});return t.runKernelFunc({forwardFunc:(t,n)=>(r=e(...a,n),bu(r.value instanceof om,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),bu(zu(r.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),r.value),backwardsFunc:(e,t)=>{const n=r.gradFunc(e,t),s=Array.isArray(n)?n:[n];bu(s.length===a.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),bu(s.every(e=>e instanceof om),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const i={};return s.forEach((e,t)=>{i[t]=()=>e}),i},inputs:i})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=Hf(),n=await this.backend.time(e);return n.wallMs=Hf()-t,n}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new Im;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function Tm(){const e=ah();if(null==e._tfengine){const t=new Ju(e);e._tfengine=new Nm(t)}var t;return t=e._tfengine.ENV,nh=t,function(e){sm=e}(()=>e._tfengine),e._tfengine}Nm.nextTensorId=0,Nm.nextVariableId=0;const Em=Tm();function Rm(e,t){const n={a:e,b:t};return Em.runKernel(ch,n)}let _m;function Am(e){if(void 0!==_m)return _m;if(e||"undefined"!==typeof navigator&&null!=navigator){if(e||(e=navigator),"ReactNative"===e.product)return!0;const t=e.userAgent||e.vendor||("undefined"!==typeof window?window.opera:"");if(!t){const t=e;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function Mm(){return"undefined"!==typeof window&&null!=window.document||"undefined"!==typeof WorkerGlobalScope}const Pm=eh();function Dm(e,t){let n=e;if(Kf(e))return"string"===t?[]:[e.length];if(bm(e)){const t=e.channels||"RGBA";return[e.height,e.width*t.length]}if(xm(e))return[e.buffer.size/(null==t?4:Du(t))];if(!Array.isArray(e))return[];const a=[];for(;Array.isArray(n)||Kf(n)&&"string"!==t;)a.push(n.length),n=n[0];return Array.isArray(e)&&eh().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&Om(e,a,[]),a}function Om(e,t,n){if(n=n||[],!Array.isArray(e)&&!Kf(e))return void bu(0===t.length,()=>"Element arr[".concat(n.join("]["),"] is a primitive, ")+"but should be an array/TypedArray of ".concat(t[0]," elements"));bu(t.length>0,()=>"Element arr[".concat(n.join("]["),"] should be a primitive, ")+"but is an array of ".concat(e.length," elements")),bu(e.length===t[0],()=>"Element arr[".concat(n.join("]["),"] should have ").concat(t[0]," ")+"elements, but has ".concat(e.length," elements"));const a=t.slice(1);for(let s=0;s<e.length;++s)Om(e[s],a,n.concat(s))}function Fm(e,t,n,a){if("string_or_numeric"!==e){if(null==e)throw new Error("Expected dtype cannot be null.");if("numeric"!==e&&e!==t||"numeric"===e&&"string"===t)throw new Error("Argument '".concat(n,"' passed to '").concat(a,"' must ")+"be ".concat(e," tensor, but got ").concat(t," tensor"))}}function Lm(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"numeric";if(e instanceof cm())return Fm(a,e.dtype,t,n),e;let s=Lu(e);if("string"!==s&&["bool","int32","float32"].indexOf(a)>=0&&(s=a),Fm(a,s,t,n),null==e||!Kf(e)&&!Array.isArray(e)&&"number"!==typeof e&&"boolean"!==typeof e&&"string"!==typeof e){const a=null==e?"null":e.constructor.name;throw new Error("Argument '".concat(t,"' passed to '").concat(n,"' must be a ")+"Tensor or TensorLike, but got '".concat(a,"'"))}const r=Dm(e,s);Kf(e)||Array.isArray(e)||(e=[e]);const i="string"!==s?Uf(e,s):Xf(e,[],!0);return Em.makeTensor(i,r,s)}function zm(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"numeric";if(!Array.isArray(e))throw new Error("Argument ".concat(t," passed to ").concat(n," must be a ")+"`Tensor[]` or `TensorLike[]`");return e.map((e,s)=>Lm(e,"".concat(t,"[").concat(s,"]"),n,a))}Pm.registerFlag("DEBUG",()=>!1,e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),Pm.registerFlag("IS_BROWSER",()=>Mm()),Pm.registerFlag("IS_NODE",()=>"undefined"!==typeof process&&"undefined"!==typeof process.versions&&"undefined"!==typeof process.versions.node),Pm.registerFlag("IS_CHROME",()=>"undefined"!==typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),Pm.registerFlag("IS_SAFARI",()=>"undefined"!==typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor)),Pm.registerFlag("PROD",()=>!1),Pm.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Pm.getBool("DEBUG")),Pm.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),Pm.registerFlag("IS_TEST",()=>!1),Pm.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>Pm.getBool("DEBUG")),Pm.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1),Pm.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1),Pm.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);const Bm="__op";function jm(e){const t=Object.keys(e);if(1!==t.length)throw new Error("Please provide an object with a single key (operation name) mapping to a function. Got an object with "+"".concat(t.length," keys."));let n=t[0];const a=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+=Bm;const s=function(){Em.startScope(n);try{const e=a(...arguments);return Qu(e)&&console.error("Cannot return a Promise inside of tidy."),Em.endScope(e),e}catch(e){throw Em.endScope(null),e}};return Object.defineProperty(s,"name",{value:n,configurable:!0}),s}const Wm=jm({complex_:function(e,t){const n=Lm(e,"real","complex"),a=Lm(t,"imag","complex");xu(n.shape,a.shape,"real and imag shapes, ".concat(n.shape," and ").concat(a.shape,", ")+"must match in call to tf.complex().");const s={real:n,imag:a};return Em.runKernel(Ah,s)}});function Vm(e,t,n,a){if(null==a)a=Lu(e);else if("complex64"===a)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(xm(e)||bm(e)){if("float32"!==a&&"int32"!==a)throw new Error("Creating tensor from GPU data only supports "+"'float32'|'int32' dtype, while the dtype is ".concat(a,"."));return Em.backend.createTensorFromGPUData(e,t||n,a)}if(!Kf(e)&&!Array.isArray(e)&&"number"!==typeof e&&"boolean"!==typeof e&&"string"!==typeof e)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){Ku(t);const e=wu(t),a=wu(n);bu(e===a,()=>"Based on the provided shape, [".concat(t,"], the tensor should have ")+"".concat(e," values but has ").concat(a));for(let s=0;s<n.length;++s){const e=n[s],a=s!==n.length-1||e!==wu(t.slice(s));bu(n[s]===t[s]||!a,()=>"Error creating a new Tensor. Inferred shape "+"(".concat(n,") does not match the provided ")+"shape (".concat(t,"). "))}}return Kf(e)||Array.isArray(e)||(e=[e]),t=t||n,e="string"!==a?Uf(e,a):Xf(e,[],!0),Em.makeTensor(e,t,a)}function Um(e,t,n){return Vm(e,t,Dm(e,n),n)}const Hm={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class Gm{static join(e){return new Gm(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,null==e)return;if(e instanceof Array||(e=[e]),0===(e=e.map(e=>Kf(e)?e.buffer:e)).length)return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let n=0;n<e.length;n++){const a=e[n];n!==e.length-1&&a.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const s=t+a.byteLength;this.shards.push({buffer:a,start:t,end:s}),t=s}0===this.shards.length&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.byteLength;if(0===this.shards.length)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),t=Math.min(this.byteLength,t),t<=e)return new ArrayBuffer(0);const n=this.findShardForByte(e);if(-1===n)throw new Error("Could not find start shard for byte ".concat(e));const a=new ArrayBuffer(t-e),s=new Uint8Array(a);let r=0;for(let i=n;i<this.shards.length;i++){const n=this.shards[i],a=e+r-n.start,o=r,c=Math.min(t,n.end)-n.start,l=new Uint8Array(n.buffer,a,c-a);if(s.set(l,o),r+=l.length,t<n.end)break}return a}findShardForByte(e){if(0===this.shards.length||e<0||e>=this.byteLength)return-1;if(null!=this.bufferUniformSize)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(t){return e<t.start?-1:e>=t.end?1:0}if(0===t(this.shards[this.previousShardIndex]))return this.previousShardIndex;const n=function(e,t){let n=0,a=e.length;for(;n<=a;){const s=Math.floor((a-n)/2)+n,r=t(e[s]);if(0===r)return s;r<0?a=s:n=s+1}return-1}(this.shards,t);return-1===n?-1:(this.previousShardIndex=n,this.previousShardIndex)}}function qm(){return Em}function Km(){return Em.memory()}function Xm(e,t){return Em.tidy(e,t)}function Ym(e){km(e).forEach(e=>e.dispose())}function Qm(e){return Em.keep(e)}function Zm(){return Em.backendName}function Jm(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Em.registerBackend(e,t,n)}function $m(){return Em.backend}!function(e){im=e}(function(e){eh().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")});const eg=4;async function tg(e,t){const n=[],a=[],s=Array.isArray(e)?e.map(e=>e.name):Object.keys(e);for(let r=0;r<s.length;++r){const i=s[r],o=Array.isArray(e)?e[r].tensor:e[i];if("float32"!==o.dtype&&"int32"!==o.dtype&&"bool"!==o.dtype&&"string"!==o.dtype&&"complex64"!==o.dtype)throw new Error("Unsupported dtype in weight '".concat(i,"': ").concat(o.dtype));const c={name:i,shape:o.shape,dtype:o.dtype};if("string"===o.dtype){const e=new Promise(async e=>{const t=await o.bytes(),n=t.reduce((e,t)=>e+t.length,0)+eg*t.length,a=new Uint8Array(n);let s=0;for(let r=0;r<t.length;r++){const e=t[r],n=new Uint8Array(new Uint32Array([e.length]).buffer);a.set(n,s),s+=eg,a.set(e,s),s+=e.length}e(a)});a.push(e)}else a.push(o.data());null!=t&&(c.group=t),n.push(c)}return{data:cg(await Promise.all(a)),specs:n}}function ng(e,t){const n=new Gm(e),a={};let s=0;for(const r of t){const e=ag(r,(e,t)=>n.slice(s+e,s+t));a[r.name]=rg(r,n.slice(s,s+e)),s+=e}return a}function ag(e,t){const n=wu(e.shape);let a;if("quantization"in e){const t=e.quantization;a=Hm[t.dtype]}else{if("string"===e.dtype){let e=0;for(let a=0;a<n;a++)e+=eg+new Uint32Array(t(e,e+eg))[0];return e}a=Hm[e.dtype]}return n*a}async function sg(e,t){const n=wu(e.shape);let a;if("quantization"in e){const t=e.quantization;a=Hm[t.dtype]}else{if("string"===e.dtype){let e=0;for(let a=0;a<n;a++)e+=eg+new Uint32Array(await t(e,e+eg))[0];return e}a=Hm[e.dtype]}return n*a}function rg(e,t){const n=e.name,a=e.dtype,s=e.shape,r=wu(s);let i,o=0;if("quantization"in e){const s=e.quantization;if("uint8"===s.dtype||"uint16"===s.dtype){if(!("min"in s)||!("scale"in s))throw new Error("Weight ".concat(e.name," with quantization ").concat(s.dtype," ")+"doesn't have corresponding metadata min and scale.")}else{if("float16"!==s.dtype)throw new Error("Weight ".concat(e.name," has unknown ")+"quantization dtype ".concat(s.dtype,". ")+"Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.");if("float32"!==a)throw new Error("Weight ".concat(e.name," is quantized with ").concat(s.dtype," ")+"which only supports weights of type float32 not ".concat(a,"."))}const c=Hm[s.dtype],l="uint8"===s.dtype?new Uint8Array(t):new Uint16Array(t);if("float32"===a)if("uint8"===s.dtype||"uint16"===s.dtype){i=new Float32Array(l.length);for(let e=0;e<l.length;e++){const t=l[e];i[e]=t*s.scale+s.min}}else{if("float16"!==s.dtype)throw new Error("Unsupported quantization type ".concat(s.dtype," ")+"for weight type float32.");{const e=function(){const e=function(){const e=e=>{let t=e<<13,n=0;for(;0===(8388608&t);)n-=8388608,t<<=1;return t&=-8388609,n+=947912704,t|n},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let n=1024;n<2048;n++)t[n]=939524096+(n-1024<<13);return t}(),t=function(){const e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}(),n=function(){const e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}();return a=>{const s=new ArrayBuffer(4*a.length),r=new Uint32Array(s);for(let i=0;i<a.length;i++){const s=a[i],o=e[n[s>>10]+(1023&s)]+t[s>>10];r[i]=o}return new Float32Array(s)}}();i=e(l)}}else{if("int32"!==a)throw new Error("Unsupported dtype in weight '".concat(n,"': ").concat(a));if("uint8"!==s.dtype&&"uint16"!==s.dtype)throw new Error("Unsupported quantization type ".concat(s.dtype," ")+"for weight type int32.");i=new Int32Array(l.length);for(let e=0;e<l.length;e++){const t=l[e];i[e]=Math.round(t*s.scale+s.min)}}o+=r*c}else if("string"===a){const n=wu(e.shape);i=[];for(let e=0;e<n;e++){const e=new Uint32Array(t.slice(o,o+eg))[0];o+=eg;const n=new Uint8Array(t.slice(o,o+e));i.push(n),o+=e}}else{const e=Hm[a];if("float32"===a)i=new Float32Array(t);else if("int32"===a)i=new Int32Array(t);else{if("bool"!==a){if("complex64"===a){i=new Float32Array(t);const e=new Float32Array(i.length/2),n=new Float32Array(i.length/2);for(let t=0;t<e.length;t++)e[t]=i[2*t],n[t]=i[2*t+1];const a=Um(e,s,"float32"),r=Um(n,s,"float32"),o=Wm(a,r);return a.dispose(),r.dispose(),o}throw new Error("Unsupported dtype in weight '".concat(n,"': ").concat(a))}i=new Uint8Array(t)}o+=r*e}return Um(i,s,a)}async function ig(e,t,n){let a=new Uint8Array(t);for(;a.byteLength<n;){const{done:t,value:s}=await e.read();if(t&&null==s){const e=n-a.byteLength;throw new Error("Reader is done but ".concat(e," bytes are still expected"))}const r=new Uint8Array(a.length+s.byteLength);r.set(a,0),r.set(new Uint8Array(s),a.length),a=r}return a.buffer}async function og(e,t){const n={},a=e.getReader();let s=new ArrayBuffer(0);for(const r of t){const e=await sg(r,async(e,t)=>(s=await ig(a,s,t),s.slice(e,t)));s=await ig(a,s,e);const t=s.slice(0,e);s=s.slice(e);const i=rg(r,t);if(n[r.name]=i,"webgpu"===Zm()){const e=$m();"uploadToGPU"in e&&wu(i.shape)>=eh().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&e.uploadToGPU(i.dataId)}}return n}function cg(e){if(null===e)throw new Error("Invalid input value: ".concat(JSON.stringify(e)));let t=0;const n=[];e.forEach(e=>{if(t+=e.byteLength,n.push(e.byteLength===e.buffer.byteLength?e:new e.constructor(e)),!(e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array))throw new Error("Unsupported TypedArray subtype: ".concat(e.constructor.name))});const a=new Uint8Array(t);let s=0;return n.forEach(e=>{a.set(new Uint8Array(e.buffer),s),s+=e.byteLength}),a.buffer}const lg="undefined"!==typeof Buffer&&("undefined"===typeof Blob||"undefined"===typeof atob||"undefined"===typeof btoa);function ug(e){return lg?Buffer.byteLength(e,"utf8"):new Blob([e]).size}function hg(e){return Gm.join(e)}function dg(e){for(e=e.trim();e.endsWith("/");)e=e.slice(0,e.length-1);const t=e.split("/");return t[t.length-1]}function pg(e,t){const n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(n.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(n.trainingConfig=e.trainingConfig),n}function fg(e,t,n){const a={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(null!=e.trainingConfig&&(a.trainingConfig=e.trainingConfig),null!=e.weightsManifest){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");a.weightSpecs=t,a.weightData=n}return null!=e.signature&&(a.signature=e.signature),null!=e.userDefinedMetadata&&(a.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(a.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(a.initializerSignature=e.initializerSignature),a}async function mg(e,t){let n,a;return null!=e.weightsManifest&&([n,a]=await t(e.weightsManifest)),fg(e,n,a)}function gg(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==e.modelTopology?0:ug(JSON.stringify(e.modelTopology)),weightSpecsBytes:null==e.weightSpecs?0:ug(JSON.stringify(e.weightSpecs)),weightDataBytes:null==e.weightData?0:new Gm(e.weightData).byteLength}}function yg(e){const t=[];for(const n of e)t.push(...n.weights);return t}class bg{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==bg.instance&&(bg.instance=new bg),bg.instance}static registerSaveRouter(e){bg.getInstance().saveRouters.push(e)}static registerLoadRouter(e){bg.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return bg.getHandlers(e,"save")}static getLoadHandlers(e,t){return bg.getHandlers(e,"load",t)}static getHandlers(e,t,n){const a=[];return("load"===t?bg.getInstance().loadRouters:bg.getInstance().saveRouters).forEach(t=>{const s=t(e,n);null!==s&&a.push(s)}),a}}const xg=e=>bg.registerSaveRouter(e),vg=e=>bg.registerLoadRouter(e),wg=e=>bg.getSaveHandlers(e),kg=(e,t)=>bg.getLoadHandlers(e,t),Sg="tensorflowjs",Cg="models_store",Ig="model_info_store";function Ng(){if(!eh().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const e="undefined"===typeof window?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function Tg(e){const t=e.result;t.createObjectStore(Cg,{keyPath:"modelPath"}),t.createObjectStore(Ig,{keyPath:"modelPath"})}class Eg{constructor(e){if(this.indexedDB=Ng(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((e,n)=>{const a=this.indexedDB.open(Sg,1);a.onupgradeneeded=()=>Tg(a),a.onsuccess=()=>{const s=a.result;if(null==t){const t=s.transaction(Cg,"readonly"),a=t.objectStore(Cg).get(this.modelPath);a.onsuccess=()=>{if(null==a.result)return s.close(),n(new Error("Cannot find model with path '".concat(this.modelPath,"' ")+"in IndexedDB."));e(a.result.modelArtifacts)},a.onerror=e=>(s.close(),n(a.error)),t.oncomplete=()=>s.close()}else{t.weightData=Gm.join(t.weightData);const a=gg(t),i=s.transaction(Ig,"readwrite");let o,c,l=i.objectStore(Ig);try{o=l.put({modelPath:this.modelPath,modelArtifactsInfo:a})}catch(r){return n(r)}o.onsuccess=()=>{c=s.transaction(Cg,"readwrite");const o=c.objectStore(Cg);let u;try{u=o.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:a})}catch(r){return n(r)}u.onsuccess=()=>e({modelArtifactsInfo:a}),u.onerror=e=>{l=i.objectStore(Ig);const t=l.delete(this.modelPath);t.onsuccess=()=>(s.close(),n(u.error)),t.onerror=e=>(s.close(),n(u.error))}},o.onerror=e=>(s.close(),n(o.error)),i.oncomplete=()=>{null==c?s.close():c.oncomplete=()=>s.close()}}},a.onerror=e=>n(a.error)})}}Eg.URL_SCHEME="indexeddb://";const Rg=e=>{return eh().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Eg.URL_SCHEME)?(t=e.slice(Eg.URL_SCHEME.length),new Eg(t)):null;var t};bg.registerSaveRouter(Rg),bg.registerLoadRouter(Rg);class _g{constructor(){this.indexedDB=Ng()}async listModels(){return new Promise((e,t)=>{const n=this.indexedDB.open(Sg,1);n.onupgradeneeded=()=>Tg(n),n.onsuccess=()=>{const a=n.result,s=a.transaction(Ig,"readonly"),r=s.objectStore(Ig).getAll();r.onsuccess=()=>{const t={};for(const e of r.result)t[e.modelPath]=e.modelArtifactsInfo;e(t)},r.onerror=e=>(a.close(),t(r.error)),s.oncomplete=()=>a.close()},n.onerror=e=>t(n.error)})}async removeModel(e){var t;return e=(t=e).startsWith(Eg.URL_SCHEME)?t.slice(Eg.URL_SCHEME.length):t,new Promise((t,n)=>{const a=this.indexedDB.open(Sg,1);a.onupgradeneeded=()=>Tg(a),a.onsuccess=()=>{const s=a.result,r=s.transaction(Ig,"readwrite"),i=r.objectStore(Ig),o=i.get(e);let c;o.onsuccess=()=>{if(null==o.result)return s.close(),n(new Error("Cannot find model with path '".concat(e,"' ")+"in IndexedDB."));{const a=i.delete(e),r=()=>{c=s.transaction(Cg,"readwrite");const a=c.objectStore(Cg).delete(e);a.onsuccess=()=>t(o.result.modelArtifactsInfo),a.onerror=e=>n(o.error)};a.onsuccess=r,a.onerror=e=>(r(),s.close(),n(o.error))}},o.onerror=e=>(s.close(),n(o.error)),r.oncomplete=()=>{null==c?s.close():c.oncomplete=()=>s.close()}},a.onerror=e=>n(a.error)})}}const Ag="/",Mg="tensorflowjs_models",Pg="info",Dg="model_topology",Og="weight_specs",Fg="weight_data",Lg="model_metadata";function zg(e){return{info:[Mg,e,Pg].join(Ag),topology:[Mg,e,Dg].join(Ag),weightSpecs:[Mg,e,Og].join(Ag),weightData:[Mg,e,Fg].join(Ag),modelMetadata:[Mg,e,Lg].join(Ag)}}function Bg(e){for(const t of Object.values(e))window.localStorage.removeItem(t)}function jg(e){const t=e.split(Ag);if(t.length<3)throw new Error("Invalid key format: ".concat(e));return t.slice(1,t.length-1).join(Ag)}class Wg{constructor(e){if(!eh().getBool("IS_BROWSER")||"undefined"===typeof window||"undefined"===typeof window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=zg(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const n=JSON.stringify(e.modelTopology),a=JSON.stringify(e.weightSpecs),s=gg(e),r=Gm.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(s)),this.LS.setItem(this.keys.topology,n),this.LS.setItem(this.keys.weightSpecs,a),this.LS.setItem(this.keys.weightData,function(e){if(lg)return Buffer.from(e).toString("base64");const t=new Uint8Array(e);let n="";for(let a=0,s=t.length;a<s;a++)n+=String.fromCharCode(t[a]);return btoa(n)}(r));const t={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,initializerSignature:null!=e.initializerSignature?e.initializerSignature:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(t)),{modelArtifactsInfo:s}}catch(t){throw Bg(this.keys),new Error("Failed to save model '".concat(this.modelPath,"' to local storage: ")+"size quota being exceeded is a possible cause of this failure: "+"modelTopologyBytes=".concat(s.modelTopologyBytes,", ")+"weightSpecsBytes=".concat(s.weightSpecsBytes,", ")+"weightDataBytes=".concat(s.weightDataBytes,"."))}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(null==e)throw new Error("In local storage, there is no model with name '".concat(this.modelPath,"'"));if("JSON"!==e.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error("In local storage, the topology of model '".concat(this.modelPath,"' ")+"is missing.");t.modelTopology=n;const a=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==a)throw new Error("In local storage, the weight specs of model '".concat(this.modelPath,"' ")+"are missing.");t.weightSpecs=a;const s=this.LS.getItem(this.keys.modelMetadata);if(null!=s){const e=JSON.parse(s);t.format=e.format,t.generatedBy=e.generatedBy,t.convertedBy=e.convertedBy,null!=e.signature&&(t.signature=e.signature),null!=e.userDefinedMetadata&&(t.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(t.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(t.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(t.trainingConfig=e.trainingConfig)}const r=this.LS.getItem(this.keys.weightData);if(null==r)throw new Error("In local storage, the binary weight values of model "+"'".concat(this.modelPath,"' are missing."));return t.weightData=function(e){if(lg){const t=Buffer.from(e,"base64");return t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)}const t=atob(e),n=new Uint8Array(t.length);for(let a=0;a<t.length;++a)n.set([t.charCodeAt(a)],a);return n.buffer}(r),t}}Wg.URL_SCHEME="localstorage://";const Vg=e=>{return eh().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Wg.URL_SCHEME)?(t=e.slice(Wg.URL_SCHEME.length),new Wg(t)):null;var t};bg.registerSaveRouter(Vg),bg.registerLoadRouter(Vg);class Ug{constructor(){bu(eh().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),bu("undefined"===typeof window||"undefined"!==typeof window.localStorage,()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},t=Mg+Ag,n=Ag+Pg;for(let a=0;a<this.LS.length;++a){const s=this.LS.key(a);if(s.startsWith(t)&&s.endsWith(n)){e[jg(s)]=JSON.parse(this.LS.getItem(s))}}return e}async removeModel(e){var t;const n=zg(e=(t=e).startsWith(Wg.URL_SCHEME)?t.slice(Wg.URL_SCHEME.length):t);if(null==this.LS.getItem(n.info))throw new Error("Cannot find model at path '".concat(e,"'"));const a=JSON.parse(this.LS.getItem(n.info));return Bg(n),a}}const Hg="://";class Gg{constructor(){this.managers={}}static getInstance(){return null==Gg.instance&&(Gg.instance=new Gg),Gg.instance}static registerManager(e,t){bu(null!=e,()=>"scheme must not be undefined or null."),e.endsWith(Hg)&&(e=e.slice(0,e.indexOf(Hg))),bu(e.length>0,()=>"scheme must not be an empty string.");const n=Gg.getInstance();bu(null==n.managers[e],()=>"A model store manager is already registered for scheme '".concat(e,"'.")),n.managers[e]=t}static getManager(e){const t=Gg.getInstance().managers[e];if(null==t)throw new Error("Cannot find model manager for scheme '".concat(e,"'"));return t}static getSchemes(){return Object.keys(Gg.getInstance().managers)}}function qg(e){if(-1===e.indexOf(Hg))throw new Error("The url string provided does not contain a scheme. Supported schemes are: "+"".concat(Gg.getSchemes().join(",")));return{scheme:e.split(Hg)[0],path:e.split(Hg)[1]}}async function Kg(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];bu(e!==t,()=>"Old path and new path are the same: '".concat(e,"'"));const a=bg.getLoadHandlers(e);bu(a.length>0,()=>"Copying failed because no load handler is found for source URL ".concat(e,".")),bu(a.length<2,()=>"Copying failed because more than one (".concat(a.length,") ")+"load handlers for source URL ".concat(e,"."));const s=a[0],r=bg.getSaveHandlers(t);bu(r.length>0,()=>"Copying failed because no save handler is found for destination "+"URL ".concat(t,".")),bu(r.length<2,()=>"Copying failed because more than one (".concat(a.length,") ")+"save handlers for destination URL ".concat(t,"."));const i=r[0],o=qg(e).scheme,c=qg(e).path,l=o===qg(e).scheme,u=await s.load();n&&l&&await Gg.getManager(o).removeModel(c);const h=await i.save(u);return n&&!l&&await Gg.getManager(o).removeModel(c),h.modelArtifactsInfo}async function Xg(){const e=Gg.getSchemes(),t={};for(const n of e){const e=await Gg.getManager(n).listModels();for(const a in e){t[n+Hg+a]=e[a]}}return t}async function Yg(e){const t=qg(e);return Gg.getManager(t.scheme).removeModel(t.path)}async function Qg(e,t){return Kg(e,t,!1)}async function Zg(e,t){return Kg(e,t,!0)}class Jg{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error("Browser's encoder only supports utf-8, but got ".concat(t));return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){"undefined"!==typeof window&&eh().getBool("USE_SETTIMEOUTCUSTOM")?(this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",e=>{if(e.source===window&&e.data.name===this.messageName){e.stopPropagation();(0,this.functionRefs[e.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))):setTimeout(e,t)}isTypedArray(e){return Tf(e)}}if(eh().get("IS_BROWSER")){eh().setPlatform("browser",new Jg);try{Gg.registerManager(Wg.URL_SCHEME,new Ug)}catch(K5){}try{Gg.registerManager(Eg.URL_SCHEME,new _g)}catch(K5){}}const $g=()=>n(817);let ey;class ty{constructor(){this.util=n(590),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return null!=eh().global.fetch?eh().global.fetch(e,t):(null==ey&&(ey=$g()),ey(e,t))}now(){const e=process.hrtime();return 1e3*e[0]+e[1]/1e6}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error("Node built-in encoder only supports utf-8, but got ".concat(t));return this.textEncoder.encode(e)}decode(e,t){return 0===e.length?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}function ny(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32",n=arguments.length>2?arguments[2]:void 0;return t=t||"float32",Ku(e),new am(e,t,n)}eh().get("IS_NODE")&&!eh().get("IS_BROWSER")&&eh().setPlatform("node",new ty);const ay=jm({cast_:function(e,t){const n=Lm(e,"x","cast");if(!function(e){return"bool"===e||"complex64"===e||"float32"===e||"int32"===e||"string"===e}(t))throw new Error("Failed to cast to unknown dtype ".concat(t));if("string"===t&&"string"!==n.dtype||"string"!==t&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");const a={x:n},s={dtype:t};return Em.runKernel(Eh,a,s)}});const sy=jm({clone_:function(e){const t={x:Lm(e,"x","clone","string_or_numeric")};return Em.runKernel(vd,t)}});function ry(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];console.log(e.toString(t))}Tm();rm={buffer:ny,cast:ay,clone:sy,print:ry};const iy=jm({add_:function(e,t){let n=Lm(e,"a","add"),a=Lm(t,"b","add");[n,a]=vm(n,a);const s={a:n,b:a};return Em.runKernel(ch,s)}});const oy=jm({floorDiv_:function(e,t){let n=Lm(e,"a","floorDiv"),a=Lm(t,"b","floorDiv");[n,a]=vm(n,a);const s={a:n,b:a};return Em.runKernel(fd,s)}});const cy=jm({div_:function(e,t){let n=Lm(e,"a","div"),a=Lm(t,"b","div");if([n,a]=vm(n,a),"int32"===n.dtype&&"int32"===a.dtype)return oy(n,a);const s={a:n,b:a};return Em.runKernel(td,s,{})}});const ly=jm({mul_:function(e,t){let n=Lm(e,"a","mul"),a=Lm(t,"b","mul");[n,a]=vm(n,a);const s={a:n,b:a};return Em.runKernel(Qd,s)}});const uy=jm({sqrt_:function(e){const t={x:Lm(e,"x","sqrt","float32")};return Em.runKernel(Fp,t)}});const hy=jm({square_:function(e){const t=Lm(e,"x","square");return Em.runKernel("Square",{x:t},{})}});const dy=jm({zerosLike_:function(e){const t={x:Lm(e,"x","zerosLike")};return Em.runKernel(uf,t)}});function py(e){return Em.customGrad(e)}function fy(e,t){if((Kf(e)&&"string"!==t||Array.isArray(e))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&Kf(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Vm(e,[],[],t)}const my=new Map,gy=new Map;class yy{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class by{constructor(){this.classNameMap={}}static getMap(){return null==by.instance&&(by.instance=new by),by.instance}static register(e){by.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function xy(e,t,n){bu(null!=e.className,()=>"Class being registered does not have the static className property defined."),bu("string"===typeof e.className,()=>"className is required to be a string, but got type "+typeof e.className),bu(e.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),"undefined"===typeof t&&(t="Custom"),"undefined"===typeof n&&(n=e.className);const a=t+">"+n;return by.register(e),my.set(a,e),gy.set(e,a),e}class vy extends yy{minimize(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2?arguments[2]:void 0;const{value:a,grads:s}=this.computeGradients(e,n);if(null!=n){const e=n.map(e=>({name:e.name,tensor:s[e.name]}));this.applyGradients(e)}else this.applyGradients(s);return Ym(s),t?a:(a.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return function(e,t){bu(zu(e),()=>"The f passed in variableGrads(f) must be a function"),bu(null==t||Array.isArray(t)&&t.every(e=>e instanceof lm),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const n=null!=t;if(!n){t=[];for(const e in Em.registeredVariables)t.push(Em.registeredVariables[e])}const a=n?t.filter(e=>!e.trainable):null,s=t.length;t=t.filter(e=>e.trainable),bu(t.length>0,()=>"variableGrads() expects at least one of the input variables to "+"be trainable, but none of the ".concat(s," variables is ")+"trainable.");const{value:r,grads:i}=Em.gradients(e,t,null,!0);bu(i.some(e=>null!=e),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),bu(0===r.rank,()=>"The f passed in variableGrads(f) must return a scalar, but it "+"returned a rank-".concat(r.rank," tensor"));const o={};return t.forEach((e,t)=>{null!=i[t]&&(o[e.name]=i[t])}),null!=a&&a.forEach(e=>o[e.name]=null),{value:r,grads:o}}(e,t)}dispose(){null!=this.iterations_&&Ym(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:fy(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for this optimizer class "+"".concat(this.getClassName()))}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(vy,Symbol.hasInstance,{value:e=>null!=e.minimize&&null!=e.computeGradients&&null!=e.applyGradients});class wy extends vy{static get className(){return"Adadelta"}constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=Em.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,n)=>{const a=Em.registeredVariables[t],s=!1;null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:"".concat(t,"/accum_grad"),variable:Xm(()=>dy(a).variable(s))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:"".concat(t,"/accum_var"),variable:Xm(()=>dy(a).variable(s))});const r=Array.isArray(e)?e[n].tensor:e[t];if(null==r)return;const i=this.accumulatedGrads[n].variable,o=this.accumulatedUpdates[n].variable;Xm(()=>{const e=iy(ly(i,this.rho),ly(hy(r),1-this.rho)),t=ly(cy(uy(iy(o,this.epsilon)),uy(iy(i,this.epsilon))),r),n=iy(ly(o,this.rho),ly(hy(t),1-this.rho));i.assign(e),o.assign(n);const s=iy(ly(t,-this.learningRate),a);a.assign(s)})}),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(Ym(this.accumulatedGrads.map(e=>e.variable)),Ym(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){const t=(e=await this.extractIterations(e)).length/2,n=!1;this.accumulatedGrads=e.slice(0,t).map(e=>({originalName:e.name,variable:e.tensor.variable(n)})),this.accumulatedUpdates=e.slice(t,2*t).map(e=>({originalName:e.name,variable:e.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}function ky(e,t,n){Ku(e);const a={shape:e,value:t,dtype:n=n||Lu(t)};return Em.runKernel(hd,{},a)}class Sy extends vy{static get className(){return"Adagrad"}constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.1;super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,n)=>{const a=Em.registeredVariables[t];if(null==this.accumulatedGrads[n]){const e=!1;this.accumulatedGrads[n]={originalName:"".concat(t,"/accumulator"),variable:Xm(()=>ky(a.shape,this.initialAccumulatorValue).variable(e))}}const s=Array.isArray(e)?e[n].tensor:e[t];if(null==s)return;const r=this.accumulatedGrads[n].variable;Xm(()=>{const e=iy(r,hy(s));r.assign(e);const t=iy(ly(cy(s,uy(iy(e,Em.backend.epsilon()))),-this.learningRate),a);a.assign(t)})}),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&Ym(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);this.accumulatedGrads=e.map(e=>({originalName:e.name,variable:e.tensor.variable(false)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}const Cy=jm({pow_:function(e,t){let n=Lm(e,"base","pow"),a=Lm(t,"exp","pow");[n,a]=vm(n,a);const s={a:n,b:a};return Em.runKernel(ip,s)}});const Iy=jm({sub_:function(e,t){let n=Lm(e,"a","sub"),a=Lm(t,"b","sub");[n,a]=vm(n,a);const s={a:n,b:a};return Em.runKernel($p,s)}});class Ny extends vy{static get className(){return"Adam"}constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=a,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],Xm(()=>{this.accBeta1=fy(t).variable(),this.accBeta2=fy(n).variable()}),null==a&&(this.epsilon=Em.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(e=>e.name):Object.keys(e);Xm(()=>{const n=Iy(1,this.accBeta1),a=Iy(1,this.accBeta2);t.forEach((t,s)=>{const r=Em.registeredVariables[t],i=!1;null==this.accumulatedFirstMoment[s]&&(this.accumulatedFirstMoment[s]={originalName:"".concat(t,"/m"),variable:Xm(()=>dy(r).variable(i))}),null==this.accumulatedSecondMoment[s]&&(this.accumulatedSecondMoment[s]={originalName:"".concat(t,"/v"),variable:Xm(()=>dy(r).variable(i))});const o=Array.isArray(e)?e[s].tensor:e[t];if(null==o)return;const c=this.accumulatedFirstMoment[s].variable,l=this.accumulatedSecondMoment[s].variable,u=iy(ly(c,this.beta1),ly(o,1-this.beta1)),h=iy(ly(l,this.beta2),ly(hy(o),1-this.beta2)),d=cy(u,n),p=cy(h,a);c.assign(u),l.assign(h);const f=iy(ly(cy(d,iy(uy(p),this.epsilon)),-this.learningRate),r);r.assign(f)}),this.accBeta1.assign(ly(this.accBeta1,this.beta1)),this.accBeta2.assign(ly(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&Ym(this.accumulatedFirstMoment.map(e=>e.variable)),null!=this.accumulatedSecondMoment&&Ym(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e),Xm(()=>{this.accBeta1.assign(Cy(this.beta1,this.iterations_+1)),this.accBeta2.assign(Cy(this.beta2,this.iterations_+1))});const t=e.length/2,n=!1;this.accumulatedFirstMoment=e.slice(0,t).map(e=>({originalName:e.name,variable:e.tensor.variable(n)})),this.accumulatedSecondMoment=e.slice(t,2*t).map(e=>({originalName:e.name,variable:e.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}const Ty=jm({abs_:function(e){const t=Lm(e,"x","abs");if("complex64"===t.dtype){const e={x:t};return Em.runKernel(Mh,e)}{const e={x:t};return Em.runKernel(rh,e)}}});function Ey(e,t){const n=e.length,a=[];for(let s=0;s<n;s++){const r=n-1-s,i=e[r]||1;(t[t.length-1-s]||1)>1&&1===i&&a.unshift(r)}return a}function Ry(e,t){const n=[];for(let a=0;a<t.length;a++){const s=e[e.length-a-1],r=t.length-a-1,i=t[r];(null==s||1===s&&i>1)&&n.unshift(r)}return n}function _y(e,t){const n=Math.max(e.length,t.length),a=new Array(n);for(let s=0;s<n;s++){let r=e[e.length-s-1];null==r&&(r=1);let i=t[t.length-s-1];if(null==i&&(i=1),1===r)a[n-s-1]=i;else if(1===i)a[n-s-1]=r;else{if(r!==i){const n="Operands could not be broadcast together with shapes "+"".concat(e," and ").concat(t,".");throw Error(n)}a[n-s-1]=r}}return a}const Ay=jm({maximum_:function(e,t){let n=Lm(e,"a","maximum"),a=Lm(t,"b","maximum");[n,a]=vm(n,a),"bool"===n.dtype&&(n=ay(n,"int32"),a=ay(a,"int32")),_y(n.shape,a.shape);const s={a:n,b:a};return Em.runKernel(zd,s)}});class My extends vy{static get className(){return"Adamax"}constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0;super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=a,this.decay=s,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],Xm(()=>{this.iteration=fy(0).variable(),this.accBeta1=fy(t).variable()}),null==a&&(this.epsilon=Em.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(e=>e.name):Object.keys(e);Xm(()=>{const n=Iy(1,this.accBeta1),a=cy(-this.learningRate,iy(ly(this.iteration,this.decay),1));t.forEach((t,s)=>{const r=Em.registeredVariables[t],i=!1;null==this.accumulatedFirstMoment[s]&&(this.accumulatedFirstMoment[s]={originalName:"".concat(t,"/m"),variable:dy(r).variable(i)}),null==this.accumulatedWeightedInfNorm[s]&&(this.accumulatedWeightedInfNorm[s]={originalName:"".concat(t,"/v"),variable:dy(r).variable(i)});const o=Array.isArray(e)?e[s].tensor:e[t];if(null==o)return;const c=this.accumulatedFirstMoment[s].variable,l=this.accumulatedWeightedInfNorm[s].variable,u=iy(ly(c,this.beta1),ly(o,1-this.beta1)),h=ly(l,this.beta2),d=Ty(o),p=Ay(h,d);c.assign(u),l.assign(p);const f=iy(ly(cy(a,n),cy(u,iy(p,this.epsilon))),r);r.assign(f)}),this.iteration.assign(iy(this.iteration,1)),this.accBeta1.assign(ly(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&Ym(this.accumulatedFirstMoment.map(e=>e.variable)),null!=this.accumulatedWeightedInfNorm&&Ym(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}class Py extends vy{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,n)=>{const a=Array.isArray(e)?e[n].tensor:e[t];if(null==a)return;const s=Em.registeredVariables[t];Xm(()=>{const e=iy(ly(this.c,a),s);s.assign(e)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,null!=this.c&&this.c.dispose(),this.c=Qm(fy(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(0!==(e=await this.extractIterations(e)).length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}class Dy extends Py{static get className(){return"Momentum"}constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=fy(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,n)=>{const a=Em.registeredVariables[t];if(null==this.accumulations[n]){const e=!1;this.accumulations[n]={originalName:"".concat(t,"/momentum"),variable:Xm(()=>dy(a).variable(e))}}const s=this.accumulations[n].variable,r=Array.isArray(e)?e[n].tensor:e[t];null!=r&&Xm(()=>{let e;const t=iy(ly(this.m,s),r);e=this.useNesterov?iy(ly(this.c,iy(r,ly(t,this.m))),a):iy(ly(this.c,t),a),s.assign(t),a.assign(e)})}),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&Ym(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);this.accumulations=e.map(e=>({originalName:e.name,variable:e.tensor.variable(false)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}class Oy extends vy{static get className(){return"RMSProp"}constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,s=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=a,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=s,null==a&&(this.epsilon=Em.backend.epsilon()),null==e)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,n)=>{const a=Em.registeredVariables[t],s=!1;null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:"".concat(t,"/rms"),variable:Xm(()=>dy(a).variable(s))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:"".concat(t,"/momentum"),variable:Xm(()=>dy(a).variable(s))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:"".concat(t,"/mg"),variable:Xm(()=>dy(a).variable(s))});const r=Array.isArray(e)?e[n].tensor:e[t];if(null==r)return;const i=this.accumulatedMeanSquares[n].variable,o=this.accumulatedMoments[n].variable;Xm(()=>{const e=iy(ly(i,this.decay),ly(hy(r),1-this.decay));if(this.centered){const t=this.accumulatedMeanGrads[n].variable,s=iy(ly(t,this.decay),ly(r,1-this.decay)),c=cy(ly(r,this.learningRate),uy(Iy(e,iy(hy(s),this.epsilon)))),l=iy(ly(o,this.momentum),c);i.assign(e),t.assign(s),o.assign(l);const u=Iy(a,l);a.assign(u)}else{const e=iy(ly(i,this.decay),ly(hy(r),1-this.decay)),t=iy(ly(o,this.momentum),cy(ly(r,this.learningRate),uy(iy(e,this.epsilon))));i.assign(e),o.assign(t);const n=Iy(a,t);a.assign(n)}})}),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&Ym(this.accumulatedMeanSquares.map(e=>e.variable)),null!=this.accumulatedMeanGrads&&this.centered&&Ym(this.accumulatedMeanGrads.map(e=>e.variable)),null!=this.accumulatedMoments&&Ym(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map(e=>({originalName:e.name,variable:e.tensor.variable(n)})),this.accumulatedMoments=e.slice(t,2*t).map(e=>({originalName:e.name,variable:e.tensor.variable(n)})),this.centered&&(this.accumulatedMeanGrads=e.slice(2*t,3*t).map(e=>({originalName:e.name,variable:e.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}const Fy=[wy,Sy,Ny,My,Dy,Oy,Py];function Ly(e){return new Promise(e=>setTimeout(e)).then(e)}class zy{constructor(e){if(!eh().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(zy.URL_SCHEME)&&(e=e.slice(zy.URL_SCHEME.length)),null!=e&&0!==e.length||(e="model"),this.modelJsonFileName=e+".json",this.weightDataFileName=e+".weights.bin"}async save(e){if("undefined"===typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=Gm.join(e.weightData),n=window.URL.createObjectURL(new Blob([t],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const t=pg(e,[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}]),a=window.URL.createObjectURL(new Blob([JSON.stringify(t)],{type:"application/json"})),s=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(s.download=this.modelJsonFileName,s.href=a,await Ly(()=>s.dispatchEvent(new MouseEvent("click"))),null!=e.weightData){const e=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;e.download=this.weightDataFileName,e.href=n,await Ly(()=>e.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:gg(e)}}}}zy.URL_SCHEME="downloads://";class By{constructor(e){if(null==e||e.length<1)throw new Error("When calling browserFiles, at least 1 file is required, "+"but received ".concat(e));this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{const n=new FileReader;n.onload=n=>{const a=JSON.parse(n.target.result),s=a.modelTopology;if(null==s)return void t(new Error("modelTopology field is missing from file ".concat(this.jsonFile.name)));if(null==a.weightsManifest)return void t(new Error("weightManifest field is missing from file ".concat(this.jsonFile.name)));if(0===this.weightsFiles.length)return void e({modelTopology:s});const r=mg(a,e=>this.loadWeights(e));e(r)},n.onerror=e=>t("Failed to read model topology and weights manifest JSON "+"from file '".concat(this.jsonFile.name,"'. BrowserFiles supports loading ")+"Keras-style tf.Model artifacts only."),n.readAsText(this.jsonFile)})}loadWeights(e){const t=[],n=[];for(const r of e)t.push(...r.weights),n.push(...r.paths);const a=this.checkManifestAndWeightFiles(e),s=n.map(e=>this.loadWeightsFile(e,a[e]));return Promise.all(s).then(e=>[t,e])}loadWeightsFile(e,t){return new Promise((n,a)=>{const s=new FileReader;s.onload=e=>{const t=e.target.result;n(t)},s.onerror=t=>a("Failed to weights data from file of path '".concat(e,"'.")),s.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){const t=[],n=this.weightsFiles.map(e=>dg(e.name)),a={};for(const s of e)s.paths.forEach(e=>{const s=dg(e);if(-1!==t.indexOf(s))throw new Error("Duplicate file basename found in weights manifest: "+"'".concat(s,"'"));if(t.push(s),-1===n.indexOf(s))throw new Error("Weight file with basename '".concat(s,"' is not provided."));a[e]=this.weightsFiles[n.indexOf(s)]});if(t.length!==this.weightsFiles.length)throw new Error("Mismatch in the number of files in weights manifest "+"(".concat(t.length,") and the number of weight files provided ")+"(".concat(this.weightsFiles.length,")."));return a}}function jy(e){return new By(e)}function Wy(e,t,n,a){!function(e){bu(null!=e&&Array.isArray(e)&&e.length>0,()=>"promises must be a none empty array")}(e),function(e,t){bu(e>=0&&e<=1,()=>"Progress fraction must be in range [0, 1], but "+"got startFraction ".concat(e)),bu(t>=0&&t<=1,()=>"Progress fraction must be in range [0, 1], but "+"got endFraction ".concat(t)),bu(t>=e,()=>"startFraction must be no more than endFraction, but "+"got startFraction ".concat(e," and endFraction ")+"".concat(t))}(n=null==n?0:n,a=null==a?1:a);let s=0;return Promise.all(e.map(r=>(r.then(r=>{const i=n+ ++s/e.length*(a-n);return t(i),r}),r)))}async function Vy(e,t){null==t&&(t={});const n=null==t.fetchFunc?eh().platform.fetch:t.fetchFunc,a=e.map(e=>n(e,t.requestInit,{isBinary:!0})),s=(null==t.onProgress?await Promise.all(a):await Wy(a,t.onProgress,0,.5)).map(e=>e.arrayBuffer());return null==t.onProgress?await Promise.all(s):await Wy(s,t.onProgress,.5,1)}async function Uy(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",n=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0;return Hy(e=>Vy(e,{requestInit:a}))(e,t,n)}function Hy(e){return async function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",a=arguments.length>2?arguments[2]:void 0;const s=t.map(()=>!1),r={},i=null!=a?a.map(()=>!1):[],o=[];if(t.forEach((e,t)=>{let n=0;e.weights.forEach(e=>{const c="quantization"in e?e.quantization.dtype:e.dtype,l=Hm[c]*wu(e.shape),u=()=>{s[t]=!0,null==r[t]&&(r[t]=[]),r[t].push({manifestEntry:e,groupOffset:n,sizeBytes:l})};null!=a?a.forEach((t,n)=>{t===e.name&&(u(),i[n]=!0)}):u(),o.push(e.name),n+=l})}),!i.every(e=>e)){const e=a.filter((e,t)=>!i[t]);throw new Error("Could not find weights in manifest with names: "+"".concat(e.join(", "),". \n")+"Manifest JSON has weights with names: "+"".concat(o.join(", "),"."))}const c=s.reduce((e,t,n)=>(t&&e.push(n),e),[]),l=[];c.forEach(e=>{t[e].paths.forEach(e=>{const t=n+(n.endsWith("/")?"":"/")+e;l.push(t)})});const u=await e(l),h={};let d=0;return c.forEach(e=>{const n=t[e].paths.length,a=new Gm(u.slice(d,d+n));r[e].forEach(e=>{const t=ng(a.slice(e.groupOffset,e.groupOffset+e.sizeBytes),[e.manifestEntry]);for(const n in t)h[n]=t[n]}),d+=n}),h}}bg.registerSaveRouter(e=>eh().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(zy.URL_SCHEME)?function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"model";return new zy(e)}(e.slice(zy.URL_SCHEME.length)):null);class Gy{constructor(e,t){if(this.DEFAULT_METHOD="POST",null==t&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,null!=t.fetchFunc?(bu("function"===typeof t.fetchFunc,()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=eh().platform.fetch,bu(null!=e&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&bu(2===e.length,()=>"URL paths for http must have a length of 2, "+"(actual length is ".concat(e.length,").")),this.path=e,null!=t.requestInit&&null!=t.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const n=pg(e,[{paths:["./model.weights.bin"],weights:e.weightSpecs}]);if(t.body.append("model.json",new Blob([JSON.stringify(n)],{type:"application/json"}),"model.json"),null!=e.weightData){const n=Gm.join(e.weightData);t.body.append("model.weights.bin",new Blob([n],{type:"application/octet-stream"}),"model.weights.bin")}const a=await this.fetch(this.path,t);if(a.ok)return{modelArtifactsInfo:gg(e),responses:[a]};throw new Error("BrowserHTTPRequest.save() failed due to HTTP response status "+"".concat(a.status,"."))}async loadModelJSON(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error("Request to ".concat(this.path," failed with status code ")+"".concat(e.status,". Please verify this URL points to ")+"the model JSON of the model to load.");let t;try{t=await e.json()}catch(q5){let t="Failed to parse model JSON of response from ".concat(this.path,".");throw this.path.endsWith(".pb")?t+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":t+=" Please make sure the server is serving valid JSON for this request.",new Error(t)}const n=t.modelTopology,a=t.weightsManifest;if(null==n&&null==a)throw new Error("The JSON from HTTP path ".concat(this.path," contains neither model ")+"topology or manifest for weights.");return t}async load(){if(this.loadOptions.streamWeights)return this.loadStream();return mg(await this.loadModelJSON(),e=>this.loadWeights(e))}async loadStream(){const e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),n=yg(e.weightsManifest);return Object.assign(Object.assign({},e),{weightSpecs:n,getWeightStream:()=>function(e,t){var n;const a=null==t.fetchFunc?eh().platform.fetch:t.fetchFunc;let s,r=0;return null===(n=t.onProgress)||void 0===n||n.call(t,0),new ReadableStream({pull:async n=>{for(var i;r<e.length;){if(!s){const n=(await a(e[r],t.requestInit,{isBinary:!0})).body;s=n.getReader()}const{done:o,value:c}=await s.read();if(!o)return void n.enqueue(c);r++,s=void 0,null===(i=t.onProgress)||void 0===i||i.call(t,r/e.length)}n.close()}})}(t,this.loadOptions)})}async getWeightUrls(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[n,a]=function(e){const t=e.lastIndexOf("/"),n=e.lastIndexOf("?"),a=e.substring(0,t),s=n>t?e.substring(n):"";return[a+"/",s]}(t),s=this.weightPathPrefix||n,r=[],i=[];for(const o of e)for(const e of o.paths)null!=this.weightUrlConverter?i.push(this.weightUrlConverter(e)):r.push(s+e+a);return this.weightUrlConverter&&r.push(...await Promise.all(i)),r}async loadWeights(e){const t=await this.getWeightUrls(e);return[yg(e),await Vy(t,this.loadOptions)]}}function qy(e){return null!=e.match(Gy.URL_SCHEME_REGEX)}Gy.URL_SCHEME_REGEX=/^https?:\/\//;const Ky=(e,t)=>{if("undefined"===typeof fetch&&(null==t||null==t.fetchFunc))return null;{let n=!0;if(n=Array.isArray(e)?e.every(e=>qy(e)):qy(e),n)return Xy(e,t)}return null};function Xy(e,t){return new Gy(e,t)}function Yy(e,t){return Xy(e,t)}bg.registerSaveRouter(Ky),bg.registerLoadRouter(Ky);class Qy{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class Zy{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class Jy{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}}function $y(e,t,n,a){return new Jy(eb(...arguments))}function eb(e,t,n,a){if(1===arguments.length){return null!=e.modelTopology||null!=e.weightSpecs?new Qy(e):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Qy({modelTopology:e}))}return console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Qy({modelTopology:e,weightSpecs:t,weightData:n,trainingConfig:a})}function tb(e){return new Zy(e)}function nb(e){return new Zy(e)}function ab(e,t,n){if(vu(e),null!=t&&3!==t.length)throw new Error("tensor3d() requires shape to have three numbers");const a=Dm(e,n);if(3!==a.length&&1!==a.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===a.length&&null==t)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Vm(e,t,a,n)}let sb,rb=!1;function ib(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==e)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,a=!1,s=!1,r=!1,i=!1,o=!1;if(e.data instanceof Uint8Array)n=!0;else if("undefined"!==typeof ImageData&&e instanceof ImageData)a=!0;else if("undefined"!==typeof HTMLVideoElement&&e instanceof HTMLVideoElement)s=!0;else if("undefined"!==typeof HTMLImageElement&&e instanceof HTMLImageElement)r=!0;else if(null!=e.getContext)i=!0;else{if(!("undefined"!==typeof ImageBitmap&&e instanceof ImageBitmap))throw new Error("pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, "+"but was ".concat(e.constructor.name));o=!0}if(null!=wf(df,Em.backendName)){const n={pixels:e},a={numChannels:t};return Em.runKernel(df,n,a)}const[c,l]=s?[e.videoWidth,e.videoHeight]:[e.width,e.height];let u,h;if(i)u=e.getContext("2d").getImageData(0,0,c,l).data;else if(a||n)u=e.data;else if(r||s||o){if(null==sb)if("undefined"===typeof document){if("undefined"===typeof OffscreenCanvas||"undefined"===typeof OffscreenCanvasRenderingContext2D)throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");sb=new OffscreenCanvas(1,1).getContext("2d")}else sb=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});sb.canvas.width=c,sb.canvas.height=l,sb.drawImage(e,0,0,c,l),u=sb.getImageData(0,0,c,l).data}if(4===t)h=new Int32Array(u);else{const e=c*l;h=new Int32Array(e*t);for(let n=0;n<e;n++)for(let e=0;e<t;++e)h[n*t+e]=u[4*n+e]}return ab(h,[l,c,t],"int32")}function ob(e){if(2!==e.rank&&3!==e.rank)throw new Error("toPixels only supports rank 2 or 3 tensors, got rank ".concat(e.rank,"."));const t=2===e.rank?1:e.shape[2];if(t>4||2===t)throw new Error("toPixels only supports depth of size "+"1, 3 or 4 but got ".concat(t));if("float32"!==e.dtype&&"int32"!==e.dtype)throw new Error("Unsupported type for toPixels: ".concat(e.dtype,".")+" Please use float32 or int32 tensors.")}async function cb(e,t){let n=Lm(e,"img","toPixels");if(!(e instanceof om)){const e=n;n=ay(e,"int32"),e.dispose()}ob(n);const[a,s]=n.shape.slice(0,2),r=2===n.rank?1:n.shape[2],i=await n.data(),o="float32"===n.dtype?255:1,c=new Uint8ClampedArray(s*a*4);for(let l=0;l<a*s;++l){const e=[0,0,0,255];for(let a=0;a<r;a++){const t=i[l*r+a];if("float32"===n.dtype){if(t<0||t>1)throw new Error("Tensor values for a float32 Tensor must be in the "+"range [0 - 1] but encountered ".concat(t,"."))}else if("int32"===n.dtype&&(t<0||t>255))throw new Error("Tensor values for a int32 Tensor must be in the "+"range [0 - 255] but encountered ".concat(t,"."));1===r?(e[0]=t*o,e[1]=t*o,e[2]=t*o):e[a]=t*o}const t=4*l;c[t+0]=Math.round(e[0]),c[t+1]=Math.round(e[1]),c[t+2]=Math.round(e[2]),c[t+3]=Math.round(e[3])}if(null!=t){if(!rb){null!=wf(ed,Em.backendName)&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),rb=!0)}t.width=s,t.height=a;const e=t.getContext("2d"),n=new ImageData(c,s,a);e.putImageData(n,0,0)}return n!==e&&n.dispose(),c}const lb=jm({fromPixels_:ib}),ub=-2,hb=-1;function db(e,t,n){const a=e.shape.length;bu(a===t.length,()=>"Error in slice".concat(a,"D: Length of begin ").concat(t," must ")+"match the rank of the array (".concat(a,").")),bu(a===n.length,()=>"Error in slice".concat(a,"D: Length of size ").concat(n," must ")+"match the rank of the array (".concat(a,")."));for(let s=0;s<a;++s)bu(t[s]+n[s]<=e.shape[s],()=>"Error in slice".concat(a,"D: begin[").concat(s,"] + size[").concat(s,"] ")+"(".concat(t[s]+n[s],") would overflow input.shape[").concat(s,"] (").concat(e.shape[s],")"))}function pb(e){const t=[];let n=0;for(;e>0;)1&e&&t.push(n),e/=2,n++;return t}function fb(e,t,n){const a=[];for(let s=0;s<e.length;s++)a[s]=Math.ceil((t[s]-e[s])/n[s]);return a}function mb(e,t,n,a){const s=[...e];for(let r=s.length;r<a.length;r++)s.push(1);for(let r=0;r<n;r++)0===r?s[t]=1:(s.splice(t,0,1),s.pop());return s}function gb(e,t,n){return n<=e?n:n-(t-1)}function yb(e,t){const n=[];for(let a=0;a<e;a++)n.push(t+a);return n}function bb(e,t,n,a,s,r,i,o,c){const l=e.length;let u=new Array(l),h=new Array(l),d=new Array(l);if(t.length&&n>0){const c=t[0],l=n+1;u=xb(i,c,l,a,e),h=vb(o,c,l,s,e),d=mb(r,c,l,e)}else for(let p=0;p<l;p++)u[p]=kb(i,a,r,e,p,c),h[p]=Sb(o,s,r,e,p,c),d[p]=wb(r,p,c);return{begin:u,end:h,strides:d}}function xb(e,t,n,a,s){const r=[...s],i=yb(n,t);for(let o=0;o<r.length;o++)if(i.indexOf(o)>-1)r[o]=0;else{const s=gb(t,n,o);let i=a[s];e&1<<s&&(i=0),r[o]=i}return r}function vb(e,t,n,a,s){const r=[...s],i=yb(n,t);for(let o=0;o<r.length;o++)if(i.indexOf(o)>-1)r[o]=Number.MAX_SAFE_INTEGER;else{const s=gb(t,n,o);let i=a[s];e&1<<s&&(i=Number.MAX_SAFE_INTEGER),r[o]=i}for(let o=0;o<r.length;o++){const e=s[o];r[o]<0&&(r[o]+=e),r[o]=fu(0,r[o],s[o])}return r}function wb(e,t,n){let a=e[t];return(n&1<<t||null==a)&&(a=1),a}function kb(e,t,n,a,s,r){let i=t[s];const o=n[s]||1;(e&1<<s||r&1<<s||null==i)&&(i=o>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const c=a[s];return i<0&&(i+=c),i=fu(0,i,c-1),i}function Sb(e,t,n,a,s,r){let i=t[s];const o=n[s]||1;(e&1<<s||r&1<<s||null==i)&&(i=o>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const c=a[s];return i<0&&(i+=c),i=o>0?fu(0,i,c):fu(-1,i,c-1),i}function Cb(e,t,n){let a=n.length;for(let s=0;s<n.length;s++)if(n[s]>1){a=s;break}for(let s=a+1;s<n.length;s++)if(t[s]>0||n[s]!==e[s])return!1;return!0}function Ib(e,t){let n=e.length>0?e[e.length-1]:1;for(let a=0;a<e.length-1;a++)n+=e[a]*t[a];return n}function Nb(e,t,n){let a;const s=e.shape.length;let r;return a="number"===typeof t?[t,...new Array(s-1).fill(0)]:t.length<s?t.concat(new Array(s-t.length).fill(0)):t.slice(),a.forEach(e=>{bu(-1!==e,()=>"slice() does not support negative begin indexing.")}),r=null==n?new Array(s).fill(-1):"number"===typeof n?[n,...new Array(s-1).fill(-1)]:n.length<s?n.concat(new Array(s-n.length).fill(-1)):n,r=r.map((t,n)=>t>=0?t:(bu(-1===t,()=>"Negative size values should be exactly -1 but got "+"".concat(t," for the slice() size at index ").concat(n,".")),e.shape[n]-a[n])),[a,r]}function Tb(e,t,n,a,s,r,i,o,c){let l;if(null==a?(l=new Array(t.length),l.fill(1)):l=a,null!=i&&0!==(i&i-1))throw new Error("Multiple ellipses in slice is not allowed.");let u=!1;const h={dims:l.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:l.slice(),beginMask:s,endMask:r,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:c};for(let b=0;b<h.dims;b++)u&&0!==(1<<b&o)&&h.numAddAxisAfterEllipsis++,1<<b&i&&(u=!0);u||(h.ellipsisMask|=1<<h.dims,h.dims++);const d={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=null!=e.begin,t.endValid=null!=e.end,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let a=0;a<e.dims;a++)if(1<<a&e.ellipsisMask){const s=Math.min(t.dims-(e.dims-a)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<s;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=a}else if(1<<a&e.newAxisMask)t.finalShapeGatherIndices.push(ub),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error("Index out of range using input dim ".concat(n,"; input ")+"has only ".concat(t.dims," dims, ").concat(t.begin.length,"."));null!=e.begin&&(t.begin[n]=e.begin[a]),null!=e.end&&(t.end[n]=e.end[a]),t.strides[n]=e.strides[a],e.beginMask&1<<a&&(t.beginMask|=1<<n),e.endMask&1<<a&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<a?(t.finalShapeGatherIndices.push(hb),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(a)),t.inputShapeGatherIndicesSparse[n]=a,n++}}(h,d);let p=!0,f=!0,m=!0;const g=[],y=[];for(let b=0;b<e.length;++b){if(0===d.strides[b])throw Error("strides[".concat(b,"] must be non-zero"));const t=!!(d.shrinkAxisMask&1<<b),n=e[b];if(-1===n){g.push(t?1:-1);continue}const a=[d.beginMask&1<<b,d.endMask&1<<b],s=[d.strides[b]>0?0:-1,d.strides[b]>0?n:n-1];if(t&&d.strides[b]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&1===d.strides[b];const r=!!(d.beginMask&1<<b&&d.endMask&1<<b);if(d.beginValid&&d.endValid){if(t){const e=d.begin[b]<0?n+d.begin[b]:d.begin[b];if(d.begin[b]=e,d.end[b]=d.begin[b]+1,e<0||e>=n)throw Error("slice index ".concat(d.begin[b]," of dimension ").concat(b," out of bounds."))}else d.begin[b]=Eb(d.begin[b],0,d.strides[b],n,a,s),d.end[b]=Eb(d.end[b],1,d.strides[b],n,a,s);const e=1===d.strides[b]&&0===d.begin[b]&&d.end[b]===n;p=p&&e,f=f&&(0===b&&1===d.strides[b]||e)}else p=p&&1===d.strides[b]&&r,f=f&&(0===b&&1===d.strides[b]||r);let i,o=!1;if(d.beginValid&&d.endValid?(i=d.end[b]-d.begin[b],o=!0):t?(i=1,o=!0):r&&n>=0&&(i=d.strides[b]<0?-n:n,o=!0),o){let e;e=0===i||i<0!==d.strides[b]<0?0:Math.trunc(i/d.strides[b])+(i%d.strides[b]!==0?1:0),g.push(e)}else g.push(-1)}for(let b=0;b<d.finalShapeGatherIndices.length;++b){const e=d.finalShapeGatherIndices[b];e>=0?y.push(g[e]):e===ub&&y.push(1)}return{finalShapeSparse:y.filter((e,t)=>d.finalShapeGatherIndices[t]!==ub),finalShape:y,isIdentity:p,sliceDim0:f,isSimpleSlice:m,begin:d.begin,end:d.end,strides:d.strides}}function Eb(e,t,n,a,s,r){if(s[t])return n>0?r[t]:r[t+1&1];{const t=e<0?a+e:e;return t<r[0]?r[0]:t>r[1]?r[1]:t}}const Rb=jm({acos_:function(e){const t={x:Lm(e,"x","acos")};return Em.runKernel(ih,t)}});const _b=jm({acosh_:function(e){const t={x:Lm(e,"x","acosh")};return Em.runKernel(oh,t)}});const Ab=jm({addN_:function(e){bu(Array.isArray(e),()=>"The argument passed to tf.addN() must be a list of tensors"),bu(e.length>=1,()=>"Must pass at least one tensor to tf.addN(), but got "+"".concat(e.length));const t=e.map((e,t)=>Lm(e,"tensors".concat(t),"addN")),n=t[0];t.forEach(e=>{if(e.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),t.forEach(e=>{if(!Su(e.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const a=t;return Em.runKernel(lh,a)}});const Mb=jm({all_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const a={x:Lm(e,"x","all","bool")},s={axis:t,keepDims:n};return Em.runKernel(uh,a,s)}});const Pb=jm({any_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const a={x:Lm(e,"x","any","bool")},s={axis:t,keepDims:n};return Em.runKernel(hh,a,s)}});const Db=jm({argMax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:Lm(e,"x","argMax")},a={axis:t};return Em.runKernel(dh,n,a)}});const Ob=jm({argMin_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:Lm(e,"x","argMin")},a={axis:t};return Em.runKernel(ph,n,a)}});const Fb=jm({asin_:function(e){const t={x:Lm(e,"x","asin")};return Em.runKernel(fh,t)}});const Lb=jm({asinh_:function(e){const t={x:Lm(e,"x","asinh")};return Em.runKernel(mh,t)}});const zb=jm({atan_:function(e){const t={x:Lm(e,"x","atan")};return Em.runKernel(gh,t)}});const Bb=jm({atan2_:function(e,t){let n=Lm(e,"a","atan2"),a=Lm(t,"b","atan2");[n,a]=vm(n,a);const s={a:n,b:a};return Em.runKernel(bh,s)}});const jb=jm({atanh_:function(e){const t={x:Lm(e,"x","atanh")};return Em.runKernel(yh,t)}});function Wb(e,t,n,a){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",r=arguments.length>5?arguments[5]:void 0;return Hb(e,[...t,e[3]],n,r,a,null,null,ex(s))}function Vb(e,t,n,a,s,r){let i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"channelsLast";const[o,c]=Kb(t);let l;if("channelsLast"===i)l=[o,c,e[3],e[3]];else{if("channelsFirst"!==i)throw new Error("Unknown dataFormat ".concat(i));l=[o,c,e[1],e[1]]}return Hb(e,l,n,a,s,r,!1,i)}function Ub(e,t,n,a,s,r){let i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"NDHWC";const[o,c,l]=Xb(t);let u,h;if("NDHWC"===i)h="channelsLast",u=[o,c,l,e[4],e[4]];else{if("NCDHW"!==i)throw new Error("Unknown dataFormat ".concat(i));h="channelsFirst",u=[o,c,l,e[1],e[1]]}return Gb(e,u,n,a,s,!1,h,r)}function Hb(e,t,n,a,s,r){let i=arguments.length>6&&void 0!==arguments[6]&&arguments[6],o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:"channelsLast",[c,l,u,h]=[-1,-1,-1,-1];if("channelsLast"===o)[c,l,u,h]=e;else{if("channelsFirst"!==o)throw new Error("Unknown dataFormat ".concat(o));[c,h,l,u]=e}const[d,p,,f]=t,[m,g]=Kb(n),[y,b]=Kb(a),x=Yb(d,y),v=Yb(p,b),{padInfo:w,outHeight:k,outWidth:S}=function(e,t,n,a,s,r,i,o,c){let l,u,h;if("number"===typeof e){l={top:e,bottom:e,left:e,right:e,type:0===e?"VALID":"NUMBER"};const s=function(e,t,n,a,s){null==a&&(a=qb(e,t,n));const r=e[0],i=e[1],o=Qb((r-t+2*a)/n+1,s),c=Qb((i-t+2*a)/n+1,s);return[o,c]}([t,n],r,a,e,o);u=s[0],h=s[1]}else if("same"===e){u=Math.ceil(t/a),h=Math.ceil(n/s);const e=Math.max(0,(u-1)*a+r-t),o=Math.max(0,(h-1)*s+i-n),c=Math.floor(e/2),d=e-c,p=Math.floor(o/2);l={top:c,bottom:d,left:p,right:o-p,type:"SAME"}}else if("valid"===e)l={top:0,bottom:0,left:0,right:0,type:"VALID"},u=Math.ceil((t-r+1)/a),h=Math.ceil((n-i+1)/s);else{if("object"!==typeof e)throw Error("Unknown padding parameter: ".concat(e));{const d="channelsLast"===c?e[1][0]:e[2][0],p="channelsLast"===c?e[1][1]:e[2][1],f="channelsLast"===c?e[2][0]:e[3][0],m="channelsLast"===c?e[2][1]:e[3][1];l={top:d,bottom:p,left:f,right:m,type:0===d&&0===p&&0===f&&0===m?"VALID":"EXPLICIT"},u=Qb((t-r+d+p)/a+1,o),h=Qb((n-i+f+m)/s+1,o)}}return{padInfo:l,outHeight:u,outWidth:h}}(s,l,u,m,g,x,v,r,o),C=i?f*h:f;let I;return"channelsFirst"===o?I=[c,C,k,S]:"channelsLast"===o&&(I=[c,k,S,C]),{batchSize:c,dataFormat:o,inHeight:l,inWidth:u,inChannels:h,outHeight:k,outWidth:S,outChannels:C,padInfo:w,strideHeight:m,strideWidth:g,filterHeight:d,filterWidth:p,effectiveFilterHeight:x,effectiveFilterWidth:v,dilationHeight:y,dilationWidth:b,inShape:e,outShape:I,filterShape:t}}function Gb(e,t,n,a,s){let r=arguments.length>5&&void 0!==arguments[5]&&arguments[5],i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"channelsLast",o=arguments.length>7?arguments[7]:void 0,[c,l,u,h,d]=[-1,-1,-1,-1,-1];if("channelsLast"===i)[c,l,u,h,d]=e;else{if("channelsFirst"!==i)throw new Error("Unknown dataFormat ".concat(i));[c,d,l,u,h]=e}const[p,f,m,,g]=t,[y,b,x]=Xb(n),[v,w,k]=Xb(a),S=Yb(p,v),C=Yb(f,w),I=Yb(m,k),{padInfo:N,outDepth:T,outHeight:E,outWidth:R}=function(e,t,n,a,s,r,i,o,c,l,u){let h,d,p,f;"valid"===e&&(e=0);if("number"===typeof e){h={top:e,bottom:e,left:e,right:e,front:e,back:e,type:0===e?"VALID":"NUMBER"};const m=function(e,t,n,a,s,r){null==s&&(s=qb(e,t[0],a[0]));const i=[0,0,0,n];for(let o=0;o<3;o++)e[o]+2*s>=t[o]&&(i[o]=Qb((e[o]-t[o]+2*s)/a[o]+1,r));return i}([t,n,a,1],[o,c,l],1,[s,r,i],e,u);d=m[0],p=m[1],f=m[2]}else{if("same"!==e)throw Error("Unknown padding parameter: ".concat(e));{d=Math.ceil(t/s),p=Math.ceil(n/r),f=Math.ceil(a/i);const e=(d-1)*s+o-t,u=(p-1)*r+c-n,m=(f-1)*i+l-a,g=Math.floor(e/2),y=e-g,b=Math.floor(u/2),x=u-b,v=Math.floor(m/2);h={top:b,bottom:x,left:v,right:m-v,front:g,back:y,type:"SAME"}}}return{padInfo:h,outDepth:d,outHeight:p,outWidth:f}}(s,l,u,h,y,b,x,S,C,I,o),_=r?g*d:g;let A;return"channelsFirst"===i?A=[c,_,T,E,R]:"channelsLast"===i&&(A=[c,T,E,R,_]),{batchSize:c,dataFormat:i,inDepth:l,inHeight:u,inWidth:h,inChannels:d,outDepth:T,outHeight:E,outWidth:R,outChannels:_,padInfo:N,strideDepth:y,strideHeight:b,strideWidth:x,filterDepth:p,filterHeight:f,filterWidth:m,effectiveFilterDepth:S,effectiveFilterHeight:C,effectiveFilterWidth:I,dilationDepth:v,dilationHeight:w,dilationWidth:k,inShape:e,outShape:A,filterShape:t}}function qb(e,t,n){const a=Yb(t,arguments.length>3&&void 0!==arguments[3]?arguments[3]:1);return Math.floor((e[0]*(n-1)-n+a)/2)}function Kb(e){return"number"===typeof e?[e,e,e]:2===e.length?[e[0],e[1],1]:e}function Xb(e){return"number"===typeof e?[e,e,e]:e}function Yb(e,t){return t<=1?e:e+(e-1)*(t-1)}function Qb(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error("Unknown roundingMode ".concat(t))}}function Zb(e){const[t,n,a]=Kb(e);return 1===t&&1===n&&1===a}function Jb(e,t){return Zb(e)||Zb(t)}function $b(e){return Kb(e).every(e=>e>0)}function ex(e){if("NHWC"===e)return"channelsLast";if("NCHW"===e)return"channelsFirst";throw new Error("Unknown dataFormat ".concat(e))}function tx(e,t,n){if(null!=n){if("string"===typeof t)throw Error("Error in ".concat(e,": pad must be an integer when using ")+"dimRoundingMode ".concat(n," but got pad ").concat(t,"."));if("number"===typeof t)bu(Cu(t),()=>"Error in ".concat(e,": pad must be an integer when using ")+"dimRoundingMode ".concat(n," but got pad ").concat(t,"."));else{if("object"!==typeof t)throw Error("Error in ".concat(e,": Unknown padding parameter: ").concat(t));t.forEach(t=>{t.forEach(t=>{bu(Cu(t),()=>"Error in ".concat(e,": pad must be an integer when using ")+"dimRoundingMode ".concat(n," but got pad ").concat(t,"."))})})}}}const nx=jm({reshape_:function(e,t){const n={x:Lm(e,"x","reshape","string_or_numeric")},a={shape:t};return Em.runKernel(gp,n,a)}});const ax=jm({avgPool_:function(e,t,n,a,s){const r=Lm(e,"x","avgPool","float32");bu(Jb(n,1),()=>"Error in avgPool: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(1,"'"));let i=r,o=!1;3===r.rank&&(o=!0,i=nx(r,[1,r.shape[0],r.shape[1],r.shape[2]])),bu(4===i.rank,()=>"Error in avgPool: x must be rank 4 but got rank ".concat(i.rank,".")),tx("avgPool",a,s);const c={x:i},l={filterSize:t,strides:n,pad:a,dimRoundingMode:s};let u=Em.runKernel(xh,c,l);return u=ay(u,r.dtype),o?nx(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});const sx=jm({avgPool3d_:function(e,t,n,a,s){let r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NDHWC";const i=Lm(e,"x","avgPool3d","float32");let o=i,c=!1;4===i.rank&&(c=!0,o=nx(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),bu(5===o.rank,()=>"Error in avgPool3d: x must be rank 5 but got rank ".concat(o.rank,".")),bu("NDHWC"===r,()=>"Error in avgPool3d: Only NDHWC is currently supported, "+"but got dataFormat of ".concat(r)),bu("number"===typeof n&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,()=>"Error in avgPool3d: Stride must be > 0, but got '".concat(n,"'")),tx("avgPool3d",a,s);const l={x:o},u={filterSize:t,strides:n,pad:a,dimRoundingMode:s,dataFormat:r};let h=Em.runKernel(wh,l,u);return h=ay(h,o.dtype),c?nx(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}});const rx=jm({concat_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;bu(e.length>=1,()=>"Pass at least one tensor to concat");const n=zm(e,"tensors","concat","string_or_numeric");if("complex64"===n[0].dtype&&n.forEach(e=>{if("complex64"!==e.dtype)throw new Error("Cannot concatenate complex64 tensors with a tensor\n          with dtype ".concat(e.dtype,". "))}),1===n.length)return sy(n[0]);const a=n,s={axis:t};return Em.runKernel(Ph,a,s)}});const ix=jm({matMul_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=Lm(e,"a","matMul"),r=Lm(t,"b","matMul");[s,r]=vm(s,r);const i={a:s,b:r},o={transposeA:n,transposeB:a};return Em.runKernel(Sh,i,o)}});const ox=jm({sigmoid_:function(e){const t={x:Lm(e,"x","sigmoid","float32")};return Em.runKernel(Dp,t)}});const cx=jm({slice_:function(e,t,n){const a=Lm(e,"x","slice","string_or_numeric");if(0===a.rank)throw new Error("Slicing scalar is not possible");const s={x:a},r={begin:t,size:n};return Em.runKernel(_p,s,r)}});const lx=jm({tanh_:function(e){const t={x:Lm(e,"x","tanh","float32")};return Em.runKernel(tf,t)}});const ux=jm({basicLSTMCell_:function(e,t,n,a,s,r){const i=Lm(e,"forgetBias","basicLSTMCell"),o=Lm(t,"lstmKernel","basicLSTMCell"),c=Lm(n,"lstmBias","basicLSTMCell"),l=Lm(a,"data","basicLSTMCell"),u=Lm(s,"c","basicLSTMCell"),h=Lm(r,"h","basicLSTMCell"),d=rx([l,h],1),p=ix(d,o),f=iy(p,c),m=f.shape[0],g=f.shape[1]/4,y=[m,g],b=cx(f,[0,0],y),x=cx(f,[0,g],y),v=cx(f,[0,2*g],y),w=cx(f,[0,3*g],y),k=iy(ly(ox(b),lx(x)),ly(u,ox(iy(i,v))));return[k,ly(lx(k),ox(w))]}});const hx=jm({batchToSpaceND_:function(e,t,n){const a=Lm(e,"x","batchToSpaceND"),s=t.reduce((e,t)=>e*t);bu(a.rank>=1+t.length,()=>"input rank is ".concat(a.rank," but should be > than blockShape.length ").concat(t.length)),bu(n.length===t.length,()=>"crops.length is ".concat(n.length," but should be equal to blockShape.length  ").concat(t.length)),bu(a.shape[0]%s===0,()=>"input tensor batch is ".concat(a.shape[0]," but is not divisible by the product of ")+"the elements of blockShape ".concat(t.join(" * ")," === ").concat(s));const r={x:a},i={blockShape:t,crops:n};return Em.runKernel(Ch,r,i)}});const dx=jm({batchNorm_:function(e,t,n,a,s,r){null==r&&(r=.001);const i=Lm(e,"x","batchNorm"),o=Lm(t,"mean","batchNorm"),c=Lm(n,"variance","batchNorm");let l,u;null!=s&&(l=Lm(s,"scale","batchNorm")),null!=a&&(u=Lm(a,"offset","batchNorm")),bu(o.rank===c.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),bu(null==u||o.rank===u.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),bu(null==l||o.rank===l.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const h={x:function(e){let t;return t=0===e.rank||1===e.rank?nx(e,[1,1,1,e.size]):2===e.rank?nx(e,[1,1,e.shape[0],e.shape[1]]):3===e.rank?nx(e,[1,e.shape[0],e.shape[1],e.shape[2]]):e,t}(i),scale:l,offset:u,mean:o,variance:c},d={varianceEpsilon:r},p=Em.runKernel(md,h,d);return nx(p,i.shape)}});const px=jm({batchNorm2d_:function(e,t,n,a,s,r){const i=Lm(e,"x","batchNorm"),o=Lm(t,"mean","batchNorm"),c=Lm(n,"variance","batchNorm");let l,u;return null!=s&&(l=Lm(s,"scale","batchNorm")),null!=a&&(u=Lm(a,"offset","batchNorm")),bu(2===i.rank,()=>"Error in batchNorm2D: x must be rank 2 but got rank "+"".concat(i.rank,".")),bu(2===o.rank||1===o.rank,()=>"Error in batchNorm2D: mean must be rank 2 or rank 1 but "+"got rank ".concat(o.rank,".")),bu(2===c.rank||1===c.rank,()=>"Error in batchNorm2D: variance must be rank 2 or rank 1 "+"but got rank ".concat(c.rank,".")),null!=l&&bu(2===l.rank||1===l.rank,()=>"Error in batchNorm2D: scale must be rank 2 or rank 1 "+"but got rank ".concat(l.rank,".")),null!=u&&bu(2===u.rank||1===u.rank,()=>"Error in batchNorm2D: offset must be rank 2 or rank 1 "+"but got rank ".concat(u.rank,".")),dx(i,o,c,u,l,r)}});const fx=jm({batchNorm3d_:function(e,t,n,a,s,r){const i=Lm(e,"x","batchNorm"),o=Lm(t,"mean","batchNorm"),c=Lm(n,"variance","batchNorm");let l,u;return null!=s&&(l=Lm(s,"scale","batchNorm")),null!=a&&(u=Lm(a,"offset","batchNorm")),bu(3===i.rank,()=>"Error in batchNorm3D: x must be rank 3 but got rank "+"".concat(i.rank,".")),bu(3===o.rank||1===o.rank,()=>"Error in batchNorm3D: mean must be rank 3 or rank 1 but "+"got rank ".concat(o.rank,".")),bu(3===c.rank||1===c.rank,()=>"Error in batchNorm3D: variance must be rank 3 or rank 1 "+"but got rank ".concat(c.rank,".")),null!=l&&bu(3===l.rank||1===l.rank,()=>"Error in batchNorm3D: scale must be rank 3 or rank 1 "+"but got rank ".concat(l.rank,".")),null!=u&&bu(3===u.rank||1===u.rank,()=>"Error in batchNorm3D: offset must be rank 3 or rank 1 "+"but got rank ".concat(u.rank,".")),dx(i,o,c,u,l,r)}});const mx=jm({batchNorm4d_:function(e,t,n,a,s,r){const i=Lm(e,"x","batchNorm"),o=Lm(t,"mean","batchNorm"),c=Lm(n,"variance","batchNorm");let l,u;return null!=s&&(l=Lm(s,"scale","batchNorm")),null!=a&&(u=Lm(a,"offset","batchNorm")),bu(4===i.rank,()=>"Error in batchNorm4D: x must be rank 4 but got rank "+"".concat(i.rank,".")),bu(4===o.rank||1===o.rank,()=>"Error in batchNorm4D: mean must be rank 4 or rank 1 but "+"got rank ".concat(o.rank,".")),bu(4===c.rank||1===c.rank,()=>"Error in batchNorm4D: variance must be rank 4 or rank 1 "+"but got rank ".concat(c.rank,".")),null!=l&&bu(4===l.rank||1===l.rank,()=>"Error in batchNorm4D: scale must be rank 4 or rank 1 "+"but got rank ".concat(l.rank,".")),null!=u&&bu(4===u.rank||1===u.rank,()=>"Error in batchNorm4D: offset must be rank 4 or rank 1 "+"but got rank ".concat(u.rank,".")),dx(i,o,c,u,l,r)}});const gx=jm({bincount_:function(e,t,n){const a=Lm(e,"x","bincount"),s=Lm(t,"weights","bincount");bu("int32"===a.dtype,()=>"Error in bincount: input "+"dtype must be int32, but got ".concat(a.dtype)),bu(n>=0,()=>"size must be non-negative, but got ".concat(n,".")),bu(s.size===a.size||0===s.size,()=>"Error in bincount: weights must have the same size as input or"+"0-length, but got input shape: ".concat(a.shape,", weights shape: ")+"".concat(s.shape,"."));const r={x:a,weights:s},i={size:n};return Em.runKernel(Ih,r,i)}});const yx=jm({bitwiseAnd_:function(e,t){const n=Lm(e,"x","bitwiseAnd"),a=Lm(t,"y","bitwiseAnd");if(!Su(n.shape,a.shape))throw new Error("BitwiseAnd: Tensors must have the same shape. x: ".concat(n.shape,", y: ").concat(a.shape));if("int32"!==n.dtype||"int32"!==a.dtype)throw new Error("BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ".concat(n.dtype," and type of y: ").concat(a.dtype));const s={a:n,b:a};return Em.runKernel(Nh,s)}});const bx=jm({broadcastArgs_:function(e,t){const n=Lm(e,"s0","broadcastArgs","int32"),a=Lm(t,"s1","broadcastArgs","int32");if(1!==n.rank)throw new Error("broadcastArgs(): first input must be a vector (rank=1). "+"Has rank ".concat(n.rank));if(1!==a.rank)throw new Error("broadcastArgs(): second input must be a vector (rank=1). "+"Has rank ".concat(a.rank));const s={s0:n,s1:a};return Em.runKernel(Th,s)}});const xx=jm({broadcastTo_:function(e,t){let n=Lm(e,"broadcastTo","x");const a=n.shape;if(Ku(t),t.length<n.rank)throw new Error("broadcastTo(): shape.length=".concat(t.length," < input.rank=").concat(n.rank,"."));if(t.length>n.rank){const e=n.shape.slice();for(;e.length<t.length;)e.unshift(1);n=nx(n,e)}const s=n.shape,r=Array.from(t);for(let c=t.length-1;c>=0;c--)if(s[c]===t[c])r[c]=1;else if(1!==n.shape[c])throw new Error("broadcastTo(): [".concat(a,"] cannot be broadcast to [").concat(t,"]."));if(0===r.map((e,t)=>e>1?t:-1).filter(e=>e>=0).length)return sy(n);const i={x:n},o={reps:r};return Em.runKernel(nf,i,o)}});const vx=jm({ceil_:function(e){const t={x:Lm(e,"x","ceil","float32")};return Em.runKernel(Rh,t)}});const wx=jm({clipByValue_:function(e,t,n){const a=Lm(e,"x","clipByValue");if(bu(t<=n,()=>"Error in clip: min (".concat(t,") must be ")+"less than or equal to max (".concat(n,").")),t===n)return ky(a.shape,t,a.dtype);const s={x:a},r={clipValueMin:t,clipValueMax:n};return Em.runKernel(_h,s,r)}});const kx=jm({concat1d_:function(e){return rx(e,0)}});const Sx=jm({concat2d_:function(e,t){return rx(e,t)}});const Cx=jm({concat3d_:function(e,t){return rx(e,t)}});const Ix=jm({concat4d_:function(e,t){return rx(e,t)}});const Nx=jm({conv2d_:function(e,t,n,a){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6?arguments[6]:void 0;const o=Lm(e,"x","conv2d","float32"),c=Lm(t,"filter","conv2d","float32");let l=o,u=!1;3===o.rank&&(u=!0,l=nx(o,[1,o.shape[0],o.shape[1],o.shape[2]])),bu(4===l.rank,()=>"Error in conv2d: input must be rank 4, but got rank ".concat(l.rank,".")),bu(4===c.rank,()=>"Error in conv2d: filter must be rank 4, but got rank "+"".concat(c.rank,".")),tx("conv2d",a,i);const h="NHWC"===s?l.shape[3]:l.shape[1];bu(h===c.shape[2],()=>"Error in conv2d: depth of input (".concat(h,") must match ")+"input depth for filter ".concat(c.shape[2],".")),bu(Jb(n,r),()=>"Error in conv2D: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(r,"'")),bu($b(r),()=>"Error in conv2D: Dilated rates should be larger than 0."),bu($b(n),()=>"Error in conv2D: Strides should be larger than 0.");const d={x:l,filter:c},p={strides:n,pad:a,dataFormat:s,dilations:r,dimRoundingMode:i},f=Em.runKernel(Dh,d,p);return u?nx(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const Tx=jm({conv1d_:function(e,t,n,a){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NWC",r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,i=arguments.length>6?arguments[6]:void 0;const o=Lm(e,"x","conv1d"),c=Lm(t,"filter","conv1d");let l=o,u=!1;2===o.rank&&(u=!0,l=nx(o,[1,o.shape[0],o.shape[1]])),bu(3===l.rank,()=>"Error in conv1d: input must be rank 3, but got rank ".concat(l.rank,".")),bu(3===c.rank,()=>"Error in conv1d: filter must be rank 3, but got rank "+"".concat(c.rank,".")),tx("conv1d",a,i),bu(l.shape[2]===c.shape[1],()=>"Error in conv1d: depth of input (".concat(l.shape[2],") must match ")+"input depth for filter ".concat(c.shape[1],".")),bu(Jb(n,r),()=>"Error in conv1D: Either stride or dilation must be 1. "+"Got stride ".concat(n," and dilation '").concat(r,"'")),bu($b(r),()=>"Error in conv1D: Dilated rates should be larger than 0."),bu($b(n),()=>"Error in conv1D: Stride should be larger than 0."),bu("NWC"===s,()=>"Error in conv1d: got dataFormat of ".concat(s," but only NWC is currently supported."));const h=nx(c,[1,c.shape[0],c.shape[1],c.shape[2]]),d=nx(l,[l.shape[0],1,l.shape[1],l.shape[2]]),p=Nx(d,h,[1,n],a,"NHWC",[1,r],i);return nx(p,u?[p.shape[2],p.shape[3]]:[p.shape[0],p.shape[2],p.shape[3]])}});const Ex=jm({conv2DBackpropInput_:function(e,t,n,a,s){let r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",i=arguments.length>6?arguments[6]:void 0;bu(e.length===t.rank,()=>"Length of inShape "+"(".concat(e.length,") and rank of dy (").concat(t.rank,") must match"));let o=e,c=t,l=!1;3===t.rank&&(l=!0,c=nx(t,[1,t.shape[0],t.shape[1],t.shape[2]]),o=[1,e[0],e[1],e[2]]),bu(4===o.length,()=>"Error in conv2dDerInput: inShape must be length 4, but got length "+"".concat(o.length,".")),bu(4===c.rank,()=>"Error in conv2dDerInput: dy must be rank 4, but got "+"rank ".concat(c.rank)),bu(4===n.rank,()=>"Error in conv2dDerInput: filter must be rank 4, but got "+"rank ".concat(n.rank));const u="NHWC"===r?o[3]:o[1],h="NHWC"===r?c.shape[3]:c.shape[1];bu(u===n.shape[2],()=>"Error in conv2dDerInput: depth of input (".concat(u,") must ")+"match input depth for filter ".concat(n.shape[2],".")),bu(h===n.shape[3],()=>"Error in conv2dDerInput: depth of output (".concat(h,") must ")+"match output depth for filter ".concat(n.shape[3],".")),tx("conv2dDerInput",s,i);const d={dy:c,filter:n},p={strides:a,pad:s,dataFormat:r,dimRoundingMode:i,inputShape:o},f=Em.runKernel(Fh,d,p);return l?nx(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const Rx=jm({conv2dTranspose_:function(e,t,n,a,s,r){const i=Lm(e,"x","conv2dTranspose"),o=Lm(t,"filter","conv2dTranspose");return Ex(n,i,o,a,s,"NHWC",r)}});const _x=jm({conv3d_:function(e,t,n,a){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NDHWC",r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1,1];const i=Lm(e,"x","conv3d"),o=Lm(t,"filter","conv3d");let c=i,l=!1;4===i.rank&&(l=!0,c=nx(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),bu(5===c.rank,()=>"Error in conv3d: input must be rank 5, but got rank ".concat(c.rank,".")),bu(5===o.rank,()=>"Error in conv3d: filter must be rank 5, but got rank "+"".concat(o.rank,".")),bu(c.shape[4]===o.shape[3],()=>"Error in conv3d: depth of input (".concat(c.shape[4],") must match ")+"input depth for filter ".concat(o.shape[3],".")),bu(Jb(n,r),()=>"Error in conv3D: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(r,"'")),bu("NDHWC"===s,()=>"Error in conv3d: got dataFormat of ".concat(s," but only NDHWC is currently supported.")),bu($b(r),()=>"Error in conv3D: Dilated rates should be larger than 0."),bu($b(n),()=>"Error in conv3D: Strides should be larger than 0.");const u={x:c,filter:o},h={strides:n,pad:a,dataFormat:s,dilations:r},d=Em.runKernel(Lh,u,h);return l?nx(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});const Ax=jm({conv3DBackpropInput_:function(e,t,n,a,s){bu(e.length===t.rank,()=>"Length of inShape "+"(".concat(e.length,") and rank of dy (").concat(t.rank,") must match"));let r=e,i=t,o=!1;4===t.rank&&(o=!0,i=nx(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),r=[1,e[0],e[1],e[2],e[3]]);const c=r[4],l=i.shape[4];bu(5===r.length,()=>"Error in conv3dDerInput: inShape must be length 5, but got length "+"".concat(r.length,".")),bu(5===i.rank,()=>"Error in conv3dDerInput: dy must be rank 5, but got "+"rank ".concat(i.rank)),bu(5===n.rank,()=>"Error in conv3dDerInput: filter must be rank 5, but got "+"rank ".concat(n.rank)),bu(c===n.shape[3],()=>"Error in conv3dDerInput: depth of input (".concat(c,") must ")+"match input depth for filter ".concat(n.shape[3],".")),bu(l===n.shape[4],()=>"Error in conv3dDerInput: depth of output (".concat(l,") must ")+"match output depth for filter ".concat(n.shape[4],"."));const u={dy:i,filter:n},h={pad:s,strides:a,inputShape:r},d=Em.runKernel(Bh,u,h);return o?nx(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});const Mx=jm({conv3dTranspose_:function(e,t,n,a,s){const r=Lm(e,"x","conv3dTranspose"),i=Lm(t,"filter","conv3dTranspose");return Ax(n,r,i,a,s)}});const Px=jm({cos_:function(e){const t={x:Lm(e,"x","cos","float32")};return Em.runKernel(jh,t)}});const Dx=jm({cosh_:function(e){const t={x:Lm(e,"x","cosh","float32")};return Em.runKernel(Wh,t)}});const Ox=jm({cumprod_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s={x:Lm(e,"x","cumprod")},r={axis:t,exclusive:n,reverse:a};return Em.runKernel(Vh,s,r)}});const Fx=jm({cumsum_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s={x:Lm(e,"x","cumsum")},r={axis:t,exclusive:n,reverse:a};return Em.runKernel(Uh,s,r)}});const Lx=jm({denseBincount_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s=Lm(e,"x","denseBincount"),r=Lm(t,"weights","denseBincount");bu("int32"===s.dtype,()=>"Error in denseBincount: input "+"dtype must be int32, but got ".concat(s.dtype)),bu(s.rank<=2,()=>"Error in denseBincount: input must be at most rank 2, but got "+"rank ".concat(s.rank,".")),bu(n>=0,()=>"size must be non-negative, but got ".concat(n,".")),bu(r.size===s.size||0===r.size,()=>"Error in denseBincount: weights must have the same shape as x or "+"0-length, but got x shape: ".concat(s.shape,", weights shape: ")+"".concat(r.shape,"."));const i={x:s,weights:r},o={size:n,binaryOutput:a};return Em.runKernel(Gh,i,o)}});const zx=jm({depthToSpace_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"NHWC";const a=Lm(e,"x","depthToSpace","float32"),s="NHWC"===n?a.shape[1]:a.shape[2],r="NHWC"===n?a.shape[2]:a.shape[3],i="NHWC"===n?a.shape[3]:a.shape[1];bu(t>1,()=>"blockSize should be > 1 for depthToSpace, but was: ".concat(t)),bu(s*t>=0,()=>"Negative dimension size caused by overflow when multiplying\n    ".concat(s," and ").concat(t,"  for depthToSpace with input shape\n    ").concat(a.shape)),bu(r*t>=0,()=>"Negative dimension size caused by overflow when multiplying\n    ".concat(r," and ").concat(t," for depthToSpace with input shape\n        ").concat(a.shape)),bu(i%(t*t)===0,()=>"Dimension size must be evenly divisible by ".concat(t*t," but is ").concat(i," for depthToSpace with input shape ").concat(a.shape));const o={x:a},c={blockSize:t,dataFormat:n};return Em.runKernel(qh,o,c)}});const Bx=jm({depthwiseConv2d_:function(e,t,n,a){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6?arguments[6]:void 0;const o=Lm(e,"x","depthwiseConv2d","float32"),c=Lm(t,"filter","depthwiseConv2d","float32");let l=o,u=!1;3===o.rank&&(u=!0,l=nx(o,[1,o.shape[0],o.shape[1],o.shape[2]])),bu(4===l.rank,()=>"Error in depthwiseConv2d: input must be rank 4, but got "+"rank ".concat(l.rank,".")),bu(4===c.rank,()=>"Error in depthwiseConv2d: filter must be rank 4, but got rank "+"".concat(c.rank,"."));const h="NHWC"===s?l.shape[3]:l.shape[1];bu(h===c.shape[2],()=>"Error in depthwiseConv2d: number of input channels "+"(".concat(h,") must match the inChannels dimension in ")+"filter ".concat(c.shape[2],".")),tx("depthwiseConv2d",a,i);const d={x:l,filter:c},p={strides:n,pad:a,dataFormat:s,dilations:r,dimRoundingMode:i},f=Em.runKernel(Kh,d,p);return u?nx(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const jx=jm({diag_:function(e){const t={x:Lm(e,"x","diag")};return Em.runKernel(Qh,t)}});const Wx=jm({dilation2d_:function(e,t,n,a){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:[1,1],r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC";const i=Lm(e,"x","dilation2d"),o=Lm(t,"filter","dilation2d");bu(3===i.rank||4===i.rank,()=>"Error in dilation2d: input must be rank 3 or 4, but got rank "+"".concat(i.rank,".")),bu(3===o.rank,()=>"Error in dilation2d: filter must be rank 3, but got rank "+"".concat(o.rank,".")),bu("NHWC"===r,()=>"Error in dilation2d: Only NHWC is currently supported, "+"but got dataFormat of ".concat(r));let c=i,l=!1;3===i.rank&&(c=nx(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=!0),bu(c.shape[3]===o.shape[2],()=>"Error in dilation2d:  input and filter must have the same depth: ".concat(c.shape[3]," vs ").concat(o.shape[2]));const u={x:c,filter:o},h={strides:n,pad:a,dilations:s},d=Em.runKernel(Zh,u,h);return l?nx(d,[d.shape[1],d.shape[2],d.shape[3]]):d}});const Vx=jm({equal_:function(e,t){let n=Lm(e,"a","equal","string_or_numeric"),a=Lm(t,"b","equal","string_or_numeric");[n,a]=vm(n,a),_y(n.shape,a.shape);const s={a:n,b:a};return Em.runKernel(id,s)}});const Ux=jm({where_:function(e,t,n){const a=Lm(t,"a","where"),s=Lm(n,"b","where"),r=Lm(e,"condition","where","bool"),i=_y(_y(r.shape,a.shape),s.shape),o={condition:xx(r,i),t:xx(a,i),e:xx(s,i)};return Em.runKernel(Ep,o)}});const Hx=jm({divNoNan_:function(e,t){let n=Lm(e,"a","div"),a=Lm(t,"b","div");[n,a]=vm(n,a);const s=cy(n,a),r=dy(s),i=Vx(a,r);return Ux(i,r,s)}});const Gx=jm({dot_:function(e,t){const n=Lm(e,"t1","dot"),a=Lm(t,"t2","dot");bu((1===n.rank||2===n.rank)&&(1===a.rank||2===a.rank),()=>"Error in dot: inputs must all be rank 1 or 2, but got ranks "+"".concat(n.rank," and ").concat(a.rank,"."));const s=1===n.rank?n.size:n.shape[1],r=1===a.rank?a.size:a.shape[0];if(bu(s===r,()=>"Error in dot: inner dimensions of inputs must match, but got "+"".concat(s," and ").concat(r,".")),1===n.rank&&1===a.rank){const e=nx(n,[1,-1]),t=nx(a,[-1,1]),s=ix(e,t);return nx(s,[])}if(1===n.rank&&2===a.rank){const e=nx(n,[1,-1]),t=nx(a,[a.shape[0],a.shape[1]]),s=ix(e,t);return nx(s,[s.size])}if(2===n.rank&&1===a.rank){const e=nx(a,[-1,1]),t=ix(n,e);return nx(t,[t.size])}{const e=nx(a,[a.shape[0],a.shape[1]]);return ix(n,e)}}});const qx=jm({einsum_:function(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),a=1;a<t;a++)n[a-1]=arguments[a];const s=n.map((e,t)=>Lm(e,"tensors".concat(t),"einsum")),r={equation:e};return Em.runKernel(nd,s,r)}});const Kx=jm({elu_:function(e){const t={x:Lm(e,"x","elu","float32")};return Em.runKernel(ad,t)}});const Xx=jm({ensureShape_:function(e,t){const n=Lm(e,"x","ensureShape","string_or_numeric");if(!function(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(null!==e[n]&&null!==t[n]&&e[n]!==t[n])return!1;return!0}(n.shape,t))throw new Error("EnsureShape: Shape of tensor ".concat(n.shape," is not compatible with expected shape ").concat(t));return e}});const Yx=jm({erf_:function(e){let t=Lm(e,"x","erf");bu("int32"===t.dtype||"float32"===t.dtype,()=>"Input dtype must be `int32` or `float32`."),"int32"===t.dtype&&(t=ay(t,"float32"));const n={x:t};return Em.runKernel(rd,n)}});function Qx(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function Zx(e,t,n){const a=e.length+t.length,s=[];let r=0,i=0;for(let o=0;o<a;o++)-1===n.indexOf(o)?s.push(e[r++]):s.push(t[i++]);return s}function Jx(e,t){const n=[],a=e.length;for(let s=0;s<a;s++)-1===t.indexOf(s)&&n.push(e[s]);return[n,t.map(t=>e[t])]}function $x(e,t){return Zx(e,t.map(e=>1),t)}function ev(e,t,n){bu(Qx(t,n),()=>"".concat(e," supports only inner-most axes for now. ")+"Got axes ".concat(t," and rank-").concat(n," input."))}function tv(e,t){if(Qx(e,t))return null;const n=[];for(let a=0;a<t;++a)-1===e.indexOf(a)&&n.push(a);return e.forEach(e=>n.push(e)),n}function nv(e){return e.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function av(e,t){const n=[];for(let a=t-e;a<t;++a)n.push(a);return n}const sv=jm({max_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const a={x:Lm(e,"x","max")},s={reductionIndices:t,keepDims:n};return Em.runKernel(Ld,a,s)}});const rv=jm({min_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const a={x:Lm(e,"x","min")},s={axis:t,keepDims:n};return Em.runKernel(Gd,a,s)}});const iv=jm({sum_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=Lm(e,"x","sum");"bool"===a.dtype&&(a=ay(a,"int32"));const s={x:a},r={axis:t,keepDims:n};return Em.runKernel(Lp,s,r)}});function ov(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;if(0===e.rank)return Ty(e);if(1!==e.rank&&null===n)return ov(nx(e,[-1]),t,n);if(1===e.rank||"number"===typeof n||Array.isArray(n)&&1===n.length){if(1===t)return iv(Ty(e),n);if(t===1/0)return sv(Ty(e),n);if(t===-1/0)return rv(Ty(e),n);if("euclidean"===t||2===t)return uy(iv(Cy(Ty(e),fy(2,"int32")),n));throw new Error("Error in norm: invalid ord value: ".concat(t))}if(Array.isArray(n)&&2===n.length){if(1===t)return sv(iv(Ty(e),n[0]),n[1]-1);if(t===1/0)return sv(iv(Ty(e),n[1]),n[0]);if(t===-1/0)return rv(iv(Ty(e),n[1]),n[0]);if("fro"===t||"euclidean"===t)return uy(iv(hy(e),n));throw new Error("Error in norm: invalid ord value: ".concat(t))}throw new Error("Error in norm: invalid axis: ".concat(n))}const cv=jm({norm_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"euclidean",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s=ov(e=Lm(e,"x","norm"),t,n);let r=s.shape;if(a){const t=Ru(n,e.shape);r=$x(s.shape,t)}return nx(s,r)}});const lv=jm({euclideanNorm_:function(e){return cv(e,"euclidean",arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,arguments.length>2&&void 0!==arguments[2]&&arguments[2])}});const uv=jm({exp_:function(e){const t={x:Lm(e,"x","exp")};return Em.runKernel(od,t)}});const hv=jm({expandDims_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=Lm(e,"x","expandDims","string_or_numeric");bu(t<=n.rank,()=>"Axis must be <= rank of the tensor");const a={input:n},s={dim:t};return Em.runKernel(cd,a,s)}});const dv=jm({expm1_:function(e){const t={x:Lm(e,"x","expm1")};return Em.runKernel(ld,t)}});const pv=jm({tile_:function(e,t){const n=Lm(e,"x","tile","string_or_numeric");bu(n.rank===t.length,()=>"Error in transpose: rank of input ".concat(n.rank," ")+"must match length of reps ".concat(t,"."));const a={x:n},s={reps:t};return Em.runKernel(nf,a,s)}});const fv=jm({eye_:function(e,t,n){null==t&&(t=e);const a=ny([e,t],arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32"),s=e<=t?e:t;for(let i=0;i<s;++i)a.set(1,i,i);const r=nx(a.toTensor(),[e,t]);if(null==n)return r;if(1===n.length)return pv(hv(r,0),[n[0],1,1]);if(2===n.length)return pv(hv(hv(r,0),0),[n[0],n[1],1,1]);if(3===n.length)return pv(hv(hv(hv(r,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error("eye() currently supports only 1D and 2D "+"batchShapes, but received ".concat(n.length,"D."))}});const mv=jm({floor_:function(e){const t={x:Lm(e,"x","floor","float32")};return Em.runKernel(pd,t)}});const gv=jm({gather_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const s={x:Lm(e,"x","gather"),indices:Lm(t,"indices","gather","int32")},r={axis:n,batchDims:a};return Em.runKernel(gd,s,r)}});const yv=jm({greater_:function(e,t){let n=Lm(e,"a","greater","string_or_numeric"),a=Lm(t,"b","greater","string_or_numeric");[n,a]=vm(n,a),_y(n.shape,a.shape);const s={a:n,b:a};return Em.runKernel(bd,s)}});const bv=jm({greaterEqual_:function(e,t){let n=Lm(e,"a","greaterEqual","string_or_numeric"),a=Lm(t,"b","greaterEqual","string_or_numeric");[n,a]=vm(n,a),_y(n.shape,a.shape);const s={a:n,b:a};return Em.runKernel(xd,s)}});const xv=jm({imag_:function(e){const t={input:Lm(e,"input","imag")};return Em.runKernel(kd,t)}});const vv=jm({isFinite_:function(e){const t={x:Lm(e,"x","isFinite")};return Em.runKernel(Sd,t)}});const wv=jm({isInf_:function(e){const t={x:Lm(e,"x","isInf")};return Em.runKernel(Cd,t)}});const kv=jm({isNaN_:function(e){const t={x:Lm(e,"x","isNaN")};return Em.runKernel(Id,t)}});const Sv=jm({leakyRelu_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.2;const n={x:Lm(e,"x","leakyRelu")},a={alpha:t};return Em.runKernel(Nd,n,a)}});const Cv=jm({less_:function(e,t){let n=Lm(e,"a","less","string_or_numeric"),a=Lm(t,"b","less","string_or_numeric");[n,a]=vm(n,a),_y(n.shape,a.shape);const s={a:n,b:a};return Em.runKernel(Td,s)}});const Iv=jm({lessEqual_:function(e,t){let n=Lm(e,"a","lessEqual","string_or_numeric"),a=Lm(t,"b","lessEqual","string_or_numeric");[n,a]=vm(n,a),_y(n.shape,a.shape);const s={a:n,b:a};return Em.runKernel(Ed,s)}});function Nv(e,t,n){if(n<=0)throw new Error("The number of values should be positive.");const a={start:e,stop:t,num:n};return Em.runKernel(Rd,{},a)}const Tv=jm({localResponseNormalization_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:5,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5;const r=Lm(e,"x","localResponseNormalization");bu(4===r.rank||3===r.rank,()=>"Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ".concat(r.rank,".")),bu(Cu(t),()=>"Error in localResponseNormalization: depthRadius must be an "+"integer but got depthRadius ".concat(t,"."));let i=r,o=!1;3===r.rank&&(o=!0,i=nx(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const c={x:i},l={depthRadius:t,bias:n,alpha:a,beta:s},u=Em.runKernel(Od,c,l);return o?nx(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});const Ev=jm({log_:function(e){const t={x:Lm(e,"x","log","float32")};return Em.runKernel(_d,t)}});const Rv=jm({log1p_:function(e){const t={x:Lm(e,"x","log1p")};return Em.runKernel(Ad,t)}});const _v=jm({neg_:function(e){const t={x:Lm(e,"x","neg")};return Em.runKernel(Zd,t)}});const Av=jm({softplus_:function(e){const t={x:Lm(e,"x","softplus")};return Em.runKernel(Op,t)}});const Mv=jm({logSigmoid_:function(e){const t=Lm(e,"x","logSigmoid");return py(e=>({value:_v(Av(_v(e))),gradFunc:t=>ly(t,ox(_v(e)))}))(t)}});const Pv=jm({logSoftmax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=Lm(e,"logits","logSoftmax");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error("Log Softmax along a non-last dimension is not yet supported. "+"Logits was rank ".concat(n.rank," and axis was ").concat(t));const a=py((e,n)=>{const a=sv(e,t,!0),s=Iy(e,a),r=Iy(ay(s,"float32"),Ev(iv(uv(s),t,!0)));n([r]);return{value:r,gradFunc:(e,n)=>{const[a]=n,s=uv(a);return Iy(e,ly(iv(e,t,!0),s))}}});return a(n)}});const Dv=jm({logSumExp_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const a=Lm(e,"x","logSumExp"),s=Ru(t,a.shape),r=sv(a,s,!0),i=Iy(a,r),o=uv(i),c=iv(o,s),l=Ev(c),u=iy(nx(r,l.shape),l);if(n){const e=$x(u.shape,s);return nx(u,e)}return u}});const Ov=jm({logicalAnd_:function(e,t){const n=Lm(e,"a","logicalAnd","bool"),a=Lm(t,"b","logicalAnd","bool");_y(n.shape,a.shape);const s={a:n,b:a};return Em.runKernel(Md,s)}});const Fv=jm({logicalNot_:function(e){const t={x:Lm(e,"x","logicalNot","bool")};return Em.runKernel(Pd,t)}});const Lv=jm({logicalOr_:function(e,t){const n=Lm(e,"a","logicalOr","bool"),a=Lm(t,"b","logicalOr","bool");_y(n.shape,a.shape);const s={a:n,b:a};return Em.runKernel(Dd,s)}});const zv=jm({logicalXor_:function(e,t){const n=Lm(e,"a","logicalXor","bool"),a=Lm(t,"b","logicalXor","bool");return _y(n.shape,a.shape),Ov(Lv(e,t),Fv(Ov(e,t)))}}),Bv=2147483648;const jv=jm({searchSorted_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"left";const a=Lm(e,"sortedSequence","searchSorted"),s=Lm(t,"values","searchSorted"),r=a.shape[a.shape.length-1],i=s.shape[s.shape.length-1],o=nx(a,[-1,r]),c=nx(s,[-1,i]);if(o.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(o.shape[0]!==c.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(wu(c.shape)>=Bv)throw new Error("values tensor size must less than ".concat(Bv));if(o.shape[1]>=Bv)throw new Error("trailing dim_size must less than ".concat(Bv," for int32 output type, was ").concat(o.shape[1]));const l={sortedSequence:o,values:c},u={side:n};return Em.runKernel(Tp,l,u)}});function Wv(e,t){return jv(e,t,"left")}const Vv=jm({maxPool_:function(e,t,n,a,s){const r=Lm(e,"x","maxPool");let i=r,o=!1;3===r.rank&&(o=!0,i=nx(r,[1,r.shape[0],r.shape[1],r.shape[2]])),bu(4===i.rank,()=>"Error in maxPool: input must be rank 4 but got rank ".concat(i.rank,".")),bu(Jb(n,1),()=>"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(1,"'")),tx("maxPool",a,s);const c={x:i},l={filterSize:t,strides:n,pad:a,dimRoundingMode:s},u=Em.runKernel(Bd,c,l);return o?nx(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});const Uv=jm({maxPool3d_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[1,1,1],n=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0,s=arguments.length>4?arguments[4]:void 0,r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NDHWC";const i=Lm(e,"x","maxPool3d");let o=i,c=!1;4===i.rank&&(c=!0,o=nx(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),bu(5===o.rank,()=>"Error in maxPool3d: x must be rank 5 but got rank ".concat(o.rank,".")),bu("NDHWC"===r,()=>"Error in maxPool3d: Only NDHWC is currently supported, "+"but got dataFormat of ".concat(r)),tx("maxPool3d",a,s);const l={x:o},u={filterSize:t,strides:n,pad:a,dimRoundingMode:s,dataFormat:r},h=Em.runKernel(Wd,l,u);return c?nx(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}});const Hv=jm({maxPoolWithArgmax_:function(e,t,n,a){let s=arguments.length>4&&void 0!==arguments[4]&&arguments[4];const r={x:Lm(e,"x","maxPoolWithArgmax")},i={filterSize:t,strides:n,pad:a,includeBatchInIndex:s},o=Em.runKernel(Ud,r,i);return{result:o[0],indexes:o[1]}}});const Gv=jm({mean_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const a={x:Lm(e,"x","mean")},s={axis:t,keepDims:n};return Em.runKernel(Hd,a,s)}});function qv(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32";if(Ku(e),"complex64"===t){const t=qv(e,"float32"),n=qv(e,"float32");return Wm(t,n)}const n=Gu(wu(e),t);return Em.makeTensor(n,e,t)}function Kv(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32";if(Ku(e),"complex64"===t){const t=Kv(e,"float32"),n=qv(e,"float32");return Wm(t,n)}const n=Hu(wu(e),t);return Em.makeTensor(n,e,t)}function Xv(e,t){let{indexing:n="xy"}=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if("xy"!==n&&"ij"!==n)throw new TypeError("".concat(n," is not a valid third argument to meshgrid"));if(void 0===e)return[];let a=Lm(e,"x","meshgrid",e instanceof om?e.dtype:"float32");if(void 0===t)return[a];let s=Lm(t,"y","meshgrid",t instanceof om?t.dtype:"float32");const r=wu(a.shape),i=wu(s.shape);return"xy"===n?(a=nx(a,[1,-1]),s=nx(s,[-1,1]),[ix(Kv([i,1],a.dtype),a),ix(s,Kv([1,r],s.dtype))]):(a=nx(a,[-1,1]),s=nx(s,[1,-1]),[ix(a,Kv([1,i],a.dtype)),ix(Kv([r,1],s.dtype),s)])}const Yv=jm({minimum_:function(e,t){let n=Lm(e,"a","minimum"),a=Lm(t,"b","minimum");[n,a]=vm(n,a),"bool"===n.dtype&&(n=ay(n,"int32"),a=ay(a,"int32")),_y(n.shape,a.shape);const s={a:n,b:a};return Em.runKernel(qd,s)}});const Qv=jm({mirrorPad_:function(e,t,n){bu("reflect"===n||"symmetric"===n,()=>"Invalid mode. Mode must be either reflect or symmetric. "+"Got ".concat(n,"."));const a=Lm(e,"x","mirrorPad");if(0===a.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");bu(t.length===a.rank,()=>"Padding doesn't match input. Must be ".concat(a.rank,". ")+"Got ".concat(t.length,"."));const s="reflect"===n?1:0;for(let o=0;o<a.rank;o++)bu(2===t[o].length,()=>"Invalid number of paddings. Must be length of 2 each."),bu(t[o][0]>=0&&t[o][0]<=a.shape[o]-s&&t[o][1]>=0&&t[o][1]<=a.shape[o]-s,()=>"Padding in dimension ".concat(o," cannot be greater than or equal ")+"to ".concat(a.shape[o]-s," or less than 0 for input of ")+"shape ".concat(a.shape));const r={paddings:t,mode:n},i={x:a};return Em.runKernel(Kd,i,r)}});const Zv=jm({mod_:function(e,t){let n=Lm(e,"a","mod"),a=Lm(t,"b","mod");[n,a]=vm(n,a);const s={a:n,b:a};return Em.runKernel(Xd,s)}});const Jv=jm({moments_:function(e){let t=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const n=Ru(arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,(e=Lm(e,"x","moments")).shape),a=Gv(e,n,t);let s=a.shape;t||(s=$x(a.shape,n));const r=hy(Iy(ay(e,"float32"),nx(a,s)));return{mean:a,variance:Gv(r,n,t)}}});const $v=jm({multiRNNCell_:function(e,t,n,a){const s=Lm(t,"data","multiRNNCell"),r=zm(n,"c","multiRNNCell"),i=zm(a,"h","multiRNNCell");let o=s;const c=[];for(let h=0;h<e.length;h++){const t=e[h](o,r[h],i[h]);c.push(t[0]),c.push(t[1]),o=t[1]}const l=[],u=[];for(let h=0;h<c.length;h+=2)l.push(c[h]),u.push(c[h+1]);return[l,u]}});const ew=jm({multinomial_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s=Lm(e,"logits","multinomial"),r=s.size,i=s.rank;if(r<2)throw new Error("Error in multinomial: you need at least 2 outcomes, but got "+"".concat(r,"."));if(i>2)throw new Error("Rank of probabilities must be 1 or 2, but is ".concat(i));n=n||Math.random();const o={logits:1===i?nx(s,[1,-1]):s},c={numSamples:t,seed:n,normalized:a},l=Em.runKernel(Yd,o,c);return 1===i?nx(l,[l.size]):l}});const tw=jm({notEqual_:function(e,t){let n=Lm(e,"a","notEqual","string_or_numeric"),a=Lm(t,"b","notEqual","string_or_numeric");[n,a]=vm(n,a),_y(n.shape,a.shape);const s={a:n,b:a};return Em.runKernel(Jd,s)}});const nw=jm({oneHot_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"int32";if(t<2)throw new Error("Error in oneHot: depth must be >=2, but it is ".concat(t));const r={indices:Lm(e,"indices","oneHot","int32")},i={dtype:s,depth:t,onValue:n,offValue:a};return Em.runKernel(ap,r,i)}});const aw=jm({onesLike_:function(e){const t={x:Lm(e,"x","onesLike")};return Em.runKernel(np,t)}});const sw=jm({outerProduct_:function(e,t){const n=Lm(e,"v1","outerProduct"),a=Lm(t,"v2","outerProduct");bu(1===n.rank&&1===a.rank,()=>"Error in outerProduct: inputs must be rank 1, but got ranks "+"".concat(n.rank," and ").concat(a.rank,"."));const s=nx(n,[-1,1]),r=nx(a,[1,-1]);return ix(s,r)}});const rw=jm({pad_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const a=Lm(e,"x","pad");if(0===a.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const s={paddings:t,constantValue:n},r={x:a};return Em.runKernel(rp,r,s)}});const iw=jm({pad1d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return bu(2===t.length,()=>"Invalid number of paddings. Must be length of 2."),rw(e,[t],n)}});const ow=jm({pad2d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return bu(2===t.length&&2===t[0].length&&2===t[1].length,()=>"Invalid number of paddings. Must be length of 2 each."),rw(e,t,n)}});const cw=jm({pad3d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return bu(3===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length,()=>"Invalid number of paddings. Must be length of 2 each."),rw(e,t,n)}});const lw=jm({pad4d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return bu(4===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length&&2===t[3].length,()=>"Invalid number of paddings. Must be length of 2 each."),rw(e,t,n)}});const uw=jm({spaceToBatchND_:function(e,t,n){const a=Lm(e,"x","spaceToBatchND");bu(a.rank>=1+t.length,()=>"input rank ".concat(a.rank," should be > than [blockShape] ").concat(t.length)),bu(n.length===t.length,()=>"paddings.shape[0] ".concat(n.length," must be equal to [blockShape] ").concat(t.length)),bu(a.shape.reduce((e,a,s)=>s>0&&s<=t.length?e&&(a+n[s-1][0]+n[s-1][1])%t[s-1]===0:e,!0),()=>"input spatial dimensions ".concat(a.shape.slice(1)," with paddings ").concat(n.toString()," must be divisible by blockShapes ").concat(t.toString()));const s={x:a},r={blockShape:t,paddings:n};return Em.runKernel(zp,s,r)}});const hw=jm({pool_:function(e,t,n,a,s,r,i){null==s&&(s=[1,1]),null==r&&(r=1),0===a&&(a="valid");const o=Lm(e,"x","maxPool");let c=o,l=!1;3===o.rank&&(l=!0,c=nx(o,[1,o.shape[0],o.shape[1],o.shape[2]])),bu(Jb(r,s),()=>"Error in pool: Either strides or dilations must be 1. "+"Got strides ".concat(r," and dilations '").concat(s,"'"));const u=Vb(c.shape,t,r,s,a),h=[u.dilationHeight,u.dilationWidth];let d;d="same"===a?function(e,t){const n=e.map((e,n)=>e+(e-1)*(t[n]-1)),a=n.map(e=>e-1),s=a.map(e=>Math.floor(e/2)),r=a.map((e,t)=>e-s[t]);return a.map((e,t)=>[s[t],r[t]])}([u.filterHeight,u.filterWidth],h):[[0,0],[0,0]];const p=1===h[0]&&1===h[1],[f,m]=function(e,t,n){const a=n.map(e=>e[0]),s=n.map(e=>e[1]),r=e.concat(a,s),i=t.map((e,t)=>(e-r[t]%e)%e),o=s.map((e,t)=>e+i[t]),c=t.map((e,t)=>[a[t],o[t]]),l=t.map((e,t)=>[0,i[t]]);return[c,l]}([u.inHeight,u.inWidth],h,d),g=p?a:"valid",y=p?c:uw(c,h,f),b=("avg"===n?()=>ax(y,t,r,g,i):()=>Vv(y,t,r,g,i))(),x=p?b:hx(b,h,m);return l?nx(x,[x.shape[1],x.shape[2],x.shape[3]]):x}});const dw=jm({prelu_:function(e,t){const n={x:Lm(e,"x","prelu"),alpha:Lm(t,"alpha","prelu")};return Em.runKernel(op,n)}});const pw=jm({prod_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=Lm(e,"x","prod");"bool"===a.dtype&&(a=ay(a,"int32"));const s={x:a},r={axis:t,keepDims:n};return Em.runKernel(cp,s,r)}});const fw=jm({raggedGather_:function(e,t,n,a){const s={paramsNestedSplits:e.map((e,t)=>Lm(e,"tensors".concat(t),"raggedGather","int32")),paramsDenseValues:Lm(t,"paramsDenseValues","raggedGather"),indices:Lm(n,"indices","raggedGather","int32")},r={outputRaggedRank:a},i=Em.runKernel(lp,s,r);return{outputNestedSplits:i.slice(0,i.length-1),outputDenseValues:i[i.length-1]}}});const mw=jm({raggedRange_:function(e,t,n){const a=Lm(e,"starts","raggedRange"),s={starts:a,limits:Lm(t,"limits","raggedRange",a.dtype),deltas:Lm(n,"deltas","raggedRange",a.dtype)},r=Em.runKernel(up,s);return{rtNestedSplits:r[0],rtDenseValues:r[1]}}});const gw=jm({raggedTensorToTensor_:function(e,t,n,a,s){const r=Lm(e,"shape","raggedTensorToTensor","int32"),i=Lm(t,"values","raggedTensorToTensor"),o={shape:r,values:i,defaultValue:Lm(n,"defaultValue","raggedTensorToTensor",i.dtype),rowPartitionTensors:a.map((e,t)=>Lm(e,"tensors".concat(t),"raggedTensorToTensor","int32"))},c={rowPartitionTypes:s};return Em.runKernel(hp,o,c)}});const yw=jm({rand_:function(e,t,n){Ku(e);const a=wu(e);let s=null;if(null==n||"float32"===n)s=new Float32Array(a);else if("int32"===n)s=new Int32Array(a);else{if("bool"!==n)throw new Error("Unknown data type ".concat(n));s=new Uint8Array(a)}for(let r=0;r<a;r++)s[r]=t();return Em.makeTensor(s,e,n)}});var bw=n(334);class xw{constructor(e,t,n,a,s){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=a,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const r=s||Math.random();this.random=bw.alea(r.toString())}nextValue(){if(!isNaN(this.nextVal)){const e=this.nextVal;return this.nextVal=NaN,e}let e,t,n=!1;for(;!n;){let a,s,r;do{a=2*this.random()-1,s=2*this.random()-1,r=a*a+s*s}while(r>=1||0===r);const i=Math.sqrt(-2*Math.log(r)/r);e=this.mean+this.stdDev*a*i,t=this.mean+this.stdDev*s*i,this.truncated&&!this.isValidTruncated(e)||(n=!0)}return this.truncated&&!this.isValidTruncated(t)||(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return null==this.dtype||"float32"===this.dtype?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class vw{constructor(e,t,n,a){this.alpha=e,this.beta=1/t,this.dtype=n;const s=a||Math.random();this.randu=bw.alea(s.toString()),this.randn=new xw(0,1,n,!1,this.randu()),this.d=e<1?e+2/3:e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,n,a,s,r;for(;;){do{a=this.randn.nextValue(),r=1+this.c*a}while(r<=0);if(r*=r*r,e=a*a,t=1-.331*e*e,n=.5*e+this.d*(1-r+Math.log(r)),s=this.randu(),s<t||Math.log(s)<n)break}return r=1/this.beta*this.d*r,this.alpha<1&&(r*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(r)}convertValue(e){return"float32"===this.dtype?e:Math.round(e)}}class ww{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0;if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=e,this.range=t-e,this.dtype=n,null==a&&(a=Math.random()),"number"===typeof a&&(a=a.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error("The difference between ".concat(e," - ").concat(t," <= 1 and dtype is not float"));this.random=bw.alea(a)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const kw=jm({randomGamma_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32",s=arguments.length>4?arguments[4]:void 0;if(Ku(e),null==n&&(n=1),null==a&&(a="float32"),"float32"!==a&&"int32"!==a)throw new Error("Unsupported data type ".concat(a));const r=new vw(t,n,a,s),i=ny(e,a);for(let o=0;o<i.values.length;o++)i.values[o]=r.nextValue();return i.toTensor()}});const Sw=jm({randomNormal_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3?arguments[3]:void 0,s=arguments.length>4?arguments[4]:void 0;if(Ku(e),null!=a&&"bool"===a)throw new Error("Unsupported data type ".concat(a));const r=new xw(t,n,a,!1,s),i=ny(e,a);for(let o=0;o<i.values.length;o++)i.values[o]=r.nextValue();return i.toTensor()}});const Cw=jm({randomStandardNormal_:function(e,t,n){if(null!=t&&"bool"===t)throw new Error("Unsupported data type ".concat(t));return Sw(e,0,1,t,n)}});const Iw=jm({randomUniform_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32",s=arguments.length>4?arguments[4]:void 0;Ku(e);const r=ny(e,a),i=new ww(t,n,null,s);for(let o=0;o<r.values.length;o++)r.values[o]=i.nextValue();return r.toTensor()}});const Nw=jm({randomUniformInt_:function(e,t,n,a){return Iw(e,t,n,"int32",a)}});function Tw(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32";if(0===n)throw new Error("Cannot have a step of zero");const s={start:e,stop:t,step:n,dtype:a};return Em.runKernel(dp,{},s)}const Ew=jm({real_:function(e){const t={input:Lm(e,"input","real")};return Em.runKernel(pp,t)}});const Rw=jm({reciprocal_:function(e){const t={x:Lm(e,"x","reciprocal")};return Em.runKernel(fp,t)}});const _w=jm({relu_:function(e){const t={x:Lm(e,"x","relu")};return Em.runKernel(mp,t)}});const Aw=jm({relu6_:function(e){const t={x:Lm(e,"x","relu6")};return Em.runKernel(wp,t)}});const Mw=jm({reverse_:function(e,t){const n={x:Lm(e,"x","reverse")},a={dims:t};return Em.runKernel(kp,n,a)}});const Pw=jm({reverse1d_:function(e){const t=Lm(e,"x","reverse");return bu(1===t.rank,()=>"Error in reverse1D: x must be rank 1 but got rank ".concat(t.rank,".")),Mw(t,0)}});const Dw=jm({reverse2d_:function(e,t){const n=Lm(e,"x","reverse");return bu(2===n.rank,()=>"Error in reverse2D: x must be rank 2 but got rank ".concat(n.rank,".")),Mw(n,t)}});const Ow=jm({reverse3d_:function(e,t){const n=Lm(e,"x","reverse");return bu(3===n.rank,()=>"Error in reverse3D: x must be rank 3 but got rank ".concat(n.rank,".")),Mw(n,t)}});const Fw=jm({reverse4d_:function(e,t){const n=Lm(e,"x","reverse");return bu(4===n.rank,()=>"Error in reverse4D: x must be rank 4 but got rank ".concat(n.rank,".")),Mw(n,t)}});const Lw=jm({round_:function(e){const t={x:Lm(e,"x","round")};return Em.runKernel(Sp,t)}});const zw=jm({rsqrt_:function(e){const t={x:Lm(e,"x","rsqrt","float32")};return Em.runKernel(Cp,t)}});const Bw=jm({selu_:function(e){const t={x:Lm(e,"x","selu")};return Em.runKernel(Rp,t)}});const jw=jm({separableConv2d_:function(e,t,n,a,s){let r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"NHWC";const o=Lm(e,"x","separableConv2d"),c=Lm(t,"depthwiseFilter","separableConv2d"),l=Lm(n,"pointwiseFilter","separableConv2d");let u=o,h=!1;if(3===o.rank&&(h=!0,u=nx(o,[1,o.shape[0],o.shape[1],o.shape[2]])),"NCHW"===i)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");bu(4===u.rank,()=>"Error in separableConv2d: input must be rank 4, but got "+"rank ".concat(u.rank,".")),bu(4===c.rank,()=>"Error in separableConv2d: depthwise filter must be rank 4, but "+"got rank ".concat(c.rank,".")),bu(4===l.rank,()=>"Error in separableConv2d: pointwise filter must be rank 4, but "+"got rank ".concat(c.rank,".")),bu(1===l.shape[0],()=>"Error in separableConv2d: the first dimension of pointwise filter "+" must be 1, but got ".concat(l.shape[0],".")),bu(1===l.shape[1],()=>"Error in separableConv2d: the second dimension of pointwise "+"filter must be 1, but got ".concat(l.shape[1],"."));const d=c.shape[2],p=c.shape[3];bu(l.shape[2]===d*p,()=>"Error in separableConv2d: the third dimension of pointwise filter "+"must be ".concat(d*p,", ")+"but got ".concat(l.shape[2],"."));const f=Bx(u,c,a,s,i,r),m=Nx(f,l,1,"valid",i);return h?nx(m,[m.shape[1],m.shape[2],m.shape[3]]):m}});const Ww=async function(e,t){const n=Lm(e,"x","setdiff1d"),a=Lm(t,"y","setdiff1d");bu(n.dtype===a.dtype,()=>"x and y should have the same dtype, but got x (".concat(n.dtype,") and y (").concat(a.dtype,").")),bu(1===n.rank,()=>"x should be 1D tensor, but got x (".concat(n.shape,").")),bu(1===a.rank,()=>"y should be 1D tensor, but got y (".concat(a.shape,")."));const s=await n.data(),r=await a.data(),i=new Set(r);let o=0;for(let u=0;u<s.length;u++)i.has(s[u])||o++;const c=new am([o],n.dtype),l=new am([o],"int32");for(let u=0,h=0;u<s.length;u++)i.has(s[u])||(c.values[h]=s[u],l.values[h]=u,h++);return[c.toTensor(),l.toTensor()]};const Vw=jm({sign_:function(e){const t={x:Lm(e,"x","sign")};return Em.runKernel(Pp,t)}});const Uw=jm({sin_:function(e){const t={x:Lm(e,"x","sin","float32")};return Em.runKernel(Ap,t)}});const Hw=jm({sinh_:function(e){const t={x:Lm(e,"x","sinh")};return Em.runKernel(Mp,t)}});const Gw=jm({slice1d_:function(e,t,n){const a=Lm(e,"x","slice1d");return bu(1===a.rank,()=>"slice1d expects a rank-1 tensor, but got a rank-".concat(a.rank," tensor")),cx(a,[t],[n])}});const qw=jm({slice2d_:function(e,t,n){const a=Lm(e,"x","slice2d");return bu(2===a.rank,()=>"slice2d expects a rank-2 tensor, but got a rank-".concat(a.rank," tensor")),cx(a,t,n)}});const Kw=jm({slice3d_:function(e,t,n){const a=Lm(e,"x","slice3d");return bu(3===a.rank,()=>"slice3d expects a rank-3 tensor, but got a rank-".concat(a.rank," tensor")),cx(a,t,n)}});const Xw=jm({slice4d_:function(e,t,n){const a=Lm(e,"x","slice4d");return bu(4===a.rank,()=>"slice4d expects a rank-4 tensor, but got a rank-".concat(a.rank," tensor")),cx(a,t,n)}});const Yw=jm({softmax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=Lm(e,"logits","softmax","float32");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error("Softmax along a non-last dimension is not yet supported. "+"Logits was rank ".concat(n.rank," and dim was ").concat(t));const a={logits:n},s={dim:t};return Em.runKernel(jp,a,s)}});const Qw=jm({fft_:function(e){bu("complex64"===e.dtype,()=>"The dtype for tf.spectral.fft() must be complex64 "+"but got ".concat(e.dtype,"."));const t={input:e};return Em.runKernel(ud,t)}});const Zw=jm({ifft_:function(e){bu("complex64"===e.dtype,()=>"The dtype for tf.spectral.ifft() must be complex64 "+"but got ".concat(e.dtype,"."));const t={input:e};return Em.runKernel(wd,t)}});const Jw=jm({irfft_:function(e){const t=e.shape[e.shape.length-1],n=e.size/t;let a;if(t<=2){const s=nx(e,[n,t]);a=Zw(s)}else{const s=[n,2*(t-1)],r=nx(Ew(e),[n,t]),i=nx(xv(e),[n,t]),o=Mw(cx(r,[0,1],[n,t-2]),1),c=ly(Mw(cx(i,[0,1],[n,t-2]),1),fy(-1)),l=rx([r,o],1),u=rx([i,c],1),h=nx(Wm(l,u),[s[0],s[1]]);a=Zw(h)}if(a=Ew(a),3===e.rank&&0!==e.shape[0]){const t=a,n=e.shape[0];a=nx(a,[n,a.shape[0]/n,a.shape[1]]),t.dispose()}return a}});const $w=jm({split_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const a={x:Lm(e,"x","split")},s={numOrSizeSplits:t,axis:n};return Em.runKernel(Bp,a,s)}});const ek=jm({rfft_:function(e,t){bu("float32"===e.dtype,()=>"The dtype for rfft() must be real value but got ".concat(e.dtype));let n=e.shape[e.shape.length-1];const a=e.size/n;let s;if(null!=t&&t<n){const a=e.shape.map(e=>0),r=e.shape.map(e=>e);r[e.shape.length-1]=t,s=cx(e,a,r),n=t}else if(null!=t&&t>n){const a=e.shape.map(e=>e);a[e.shape.length-1]=t-n,s=rx([e,qv(a)],e.shape.length-1),n=t}else s=e;const r=dy(s),i=nx(Wm(s,r),[a,n]),o=Qw(i),c=Math.floor(n/2)+1,l=Ew(o),u=xv(o),h=$w(l,[c,n-c],l.shape.length-1),d=$w(u,[c,n-c],u.shape.length-1),p=s.shape.slice();return p[s.shape.length-1]=c,nx(Wm(h[0],d[0]),p)}});const tk=jm({squaredDifference_:function(e,t){let n=Lm(e,"a","squaredDifference"),a=Lm(t,"b","squaredDifference");[n,a]=vm(n,a),_y(n.shape,a.shape);const s={a:n,b:a};return Em.runKernel(qp,s,{})}});const nk=jm({squeeze_:function(e,t){const n=Lm(e,"x","squeeze","string_or_numeric");return nx(n,_u(n.shape,t).newShape)}});const ak=jm({stack_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=zm(e,"tensors","stack","string_or_numeric");bu(n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&bu(t<=n[0].rank,()=>"Axis must be <= rank of the tensor");const a=n,s={axis:t};return Em.runKernel(sp,a,s)}});const sk=jm({step_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:Lm(e,"x","step")},a={alpha:t};return Em.runKernel(hf,n,a)}});const rk=jm({stridedSlice_:function(e,t,n,a){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0,o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,c=arguments.length>8&&void 0!==arguments[8]?arguments[8]:0;const l={x:Lm(e,"x","stridedSlice","string_or_numeric")},u={begin:t,end:n,strides:a,beginMask:s,endMask:r,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:c};return Em.runKernel(Yp,l,u)}});const ik=jm({tan_:function(e){const t={x:Lm(e,"x","tan","float32")};return Em.runKernel(ef,t)}});function ok(e,t){vu(e);const n=Dm(e,t);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Vm(e,null,n,t)}function ck(e,t,n){if(vu(e),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");const a=Dm(e,n);if(2!==a.length&&1!==a.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===a.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Vm(e,t,a,n)}function lk(e,t,n){if(vu(e),null!=t&&4!==t.length)throw new Error("tensor4d() requires shape to have four numbers");const a=Dm(e,n);if(4!==a.length&&1!==a.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===a.length&&null==t)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return Vm(e,t,a,n)}function uk(e,t,n){if(vu(e),null!=t&&5!==t.length)throw new Error("tensor5d() requires shape to have five numbers");const a=Dm(e,n);if(5!==a.length&&1!==a.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===a.length&&null==t)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return Vm(e,t,a,n)}function hk(e,t,n){if(vu(e),null!=t&&6!==t.length)throw new Error("tensor6d() requires shape to have six numbers");const a=Dm(e,n);if(6!==a.length&&1!==a.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===a.length&&null==t)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return Vm(e,t=t||a,a,n)}function dk(e,t,n){const a=t.rank>1?t.shape[t.rank-1]:1,s=t.rank>1?t.rank-1:1,r="Must have updates.shape = indices.shape[:batchDim] + "+"shape[sliceDim:], got updates.shape: ".concat(n.shape)+", indices.shape: ".concat(t.shape,", shape: ").concat(e)+", sliceDim: ".concat(a,", and batchDim: ").concat(s,".");if(n.rank<s)throw new Error(r+" update.rank < ".concat(s,". "));if(e.length<a+(n.rank-s))throw new Error(r+" Output shape length < ".concat(a+(n.rank-s)));if(n.rank!==s+e.length-a)throw new Error(r+" update.rank != ".concat(s+e.length-a));for(let i=0;i<s;++i)if(n.shape[i]!==t.shape[i])throw new Error(r+" updates.shape[".concat(i,"] (").concat(n.shape[i],") != indices.shape[").concat(i,"] (").concat(t.shape[i],")."));for(let i=0;i<n.rank-s;++i)if(n.shape[i+s]!==e[i+a])throw new Error(r+" updates.shape[".concat(i+s,"] (").concat(n.shape[i+s],") != shape[").concat(i+s,"] (").concat(e[i+s],")"))}function pk(e,t,n){if(t.rank<1)throw new Error("tf.scatterND() expects the indices to be rank 1 or higher,"+" but the rank was ".concat(t.rank,"."));if(e.rank<1)throw new Error("tf.scatterND() expects the updates to be rank 1 or higher,"+" but the rank was ".concat(e.rank,"."));if("int32"!==t.dtype)throw new Error("The dtype of 'indices' should be int32, but got dtype: ".concat(t.dtype));if(n.length<1)throw new Error("Output rank must be greater or equal to 1, but got shape: ".concat(n));if(0===n.length){if(0===t.size)throw new Error("Indices specified for empty output. indices shape: ".concat(t.shape));if(0===e.size)throw new Error("Updates specified for empty output. updates shape: ".concat(e.shape))}dk(n,t,e)}function fk(e,t,n){const a=t.shape.length,s=a>1?t.shape[a-1]:1,r=n.length;let i=1;for(let c=s;c<r;++c)i*=n[c];const o=s<1?1:s;return{sliceRank:s,numUpdates:wu(t.shape)/o,sliceSize:i,strides:[...ju(n.slice(0,s)),1],outputSize:wu(n)}}const mk=jm({tensorScatterUpdate_:function(e,t,n){const a=Lm(e,"tensor","tensorScatterupdate"),s=Lm(t,"indices","tensorScatterupdate","int32"),r=Lm(n,"updates","tensorScatterupdate");if(pk(r,s,a.shape),a.dtype!==r.dtype)throw new Error("tensor and updates must have the same dtype, instead they are ".concat(a.dtype," and ").concat(r.dtype,"."));const i={tensor:a,indices:s,updates:r};return Em.runKernel(Np,i,{})}});const gk=jm({topk_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];const a=Lm(e,"x","topk");if(0===a.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const s=a.shape[a.shape.length-1];if(t<0)throw new Error("'k' passed to topk() must be >= 0 but got ".concat(t));if(t>s)throw new Error("'k' passed to topk() must be <= the last dimension (".concat(s,") ")+"but got ".concat(t));const r={x:a},i={k:t,sorted:n},[o,c]=Em.runKernel(af,r,i);return{values:o,indices:c}}});const yk=jm({truncatedNormal_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3?arguments[3]:void 0,s=arguments.length>4?arguments[4]:void 0;if(Ku(e),null!=a&&"bool"===a)throw new Error("Unsupported data type $ { dtype }");const r=new xw(t,n,a,!0,s),i=ny(e,a);for(let o=0;o<i.values.length;o++)i.values[o]=r.nextValue();return i.toTensor()}});const bk=jm({unique_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=Lm(e,"x","unique","string_or_numeric");bu(n.rank>0,()=>"The input tensor must be at least 1D");const a={x:n},s={axis:t},[r,i]=Em.runKernel(of,a,s);return{values:r,indices:i}}});const xk=jm({unsortedSegmentSum_:function(e,t,n){const a=Lm(e,"x","unsortedSegmentSum"),s=Lm(t,"segmentIds","unsortedSegmentSum","int32");bu(Cu(n),()=>"numSegments must be of dtype int");const r={x:a,segmentIds:s},i={numSegments:n};return Em.runKernel(lf,r,i)}});const vk=jm({unstack_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=Lm(e,"x","unstack","string_or_numeric");bu(t>=-n.shape.length&&t<n.shape.length,()=>"Axis = ".concat(t," is not in [-").concat(n.shape.length,", ").concat(n.shape.length,")"));const a={value:n},s={axis:t};return Em.runKernel(cf,a,s)}});function wk(e,t){return jv(e,t,"right")}function kk(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0;return Em.makeVariable(e,t,n,a)}function Sk(e,t){const n=[];for(let r=0;r<t.length;r++)t[r]&&n.push(r);const a=ny(e,"int32"),s=ny([n.length,e.length],"int32");for(let r=0;r<n.length;r++){const t=a.indexToLoc(n[r]),i=r*e.length;s.values.set(t,i)}return s.toTensor()}const Ck=async function(e){const t=Lm(e,"condition","whereAsync","bool"),n=await t.data(),a=Sk(t.shape,n);return e!==t&&t.dispose(),a};const Ik=async function(e,t,n){const a=Lm(e,"tensor","boolMask"),s=Lm(t,"mask","boolMask","bool"),r=null==n?0:n,i=s.rank,o=a.shape;bu(i>0,()=>"mask cannot be scalar"),xu(o.slice(r,r+i),s.shape,"mask's shape must match the first K dimensions of tensor's shape,");let c=1;for(let m=r;m<r+i;m++)c*=o[m];const l=o.slice(0,r).concat([c],o.slice(r+i)),u=nx(a,l),h=nx(s,[-1]),d=await Ck(h),p=nk(d,[1]),f=gv(u,p,r);return e!==a&&a.dispose(),t!==s&&s.dispose(),p.dispose(),u.dispose(),h.dispose(),d.dispose(),f};const Nk=jm({transpose_:function(e,t,n){const a=Lm(e,"x","transpose");if(null==t&&(t=a.shape.map((e,t)=>t).reverse()),bu(a.rank===t.length,()=>"Error in transpose: rank of input ".concat(a.rank," ")+"must match length of perm ".concat(t,".")),t.forEach(e=>{bu(e>=0&&e<a.rank,()=>"All entries in 'perm' must be between 0 and ".concat(a.rank-1)+" but got ".concat(t))}),a.rank<=1)return a.clone();const s={x:a},r={perm:t};return"complex64"===a.dtype?Xm(()=>{let e=Ew(a),t=xv(a);return e=Em.runKernel(rf,{x:e},r),t=Em.runKernel(rf,{x:t},r),n&&(t=_v(t)),Wm(e,t)}):Em.runKernel(rf,s,r)}});const Tk=jm({movingAverage_:function(e,t,n,a){let s=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];const r=Lm(e,"v","movingAverage"),i=Lm(t,"x","movingAverage"),o=Lm(n,"decay","movingAverage");var c,l;l=i,bu((c=r).dtype===l.dtype,()=>"The dtypes of the first(".concat(c.dtype,") and")+" second(".concat(l.dtype,") input must match")),bu(Su(r.shape,i.shape),()=>"Shape mismatch in v and x");const u=fy(1),h=Iy(u,o);let d=ly(Iy(i,r),h);if(s){bu(null!=a,()=>"When using zeroDebias: true, step is required.");const e=Lm(a,"step","movingAverage");d=cy(d,Iy(u,Cy(o,e)))}return iy(r,d)}});const Ek=jm({scatterND_:function(e,t,n){Ku(n);const a=Lm(e,"indices","scatterND","int32"),s=Lm(t,"updates","scatterND");pk(s,a,n);const r={indices:a,updates:s},i={shape:n};return Em.runKernel(Ip,r,i)}});const Rk=jm({sparseToDense_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;Ku(n);const s=Lm(e,"sparseIndices","sparseToDense","int32"),r=Lm(t,"sparseValues","sparseToDense","string_or_numeric"),i=Lm(a,"defaultValue","sparseToDense",r.dtype);!function(e,t,n,a){if("int32"!==e.dtype)throw new Error("tf.sparseToDense() expects the indices to be int32 type,"+" but the dtype was ".concat(e.dtype,"."));if(e.rank>2)throw new Error("sparseIndices should be a scalar, vector, or matrix,"+" but got shape ".concat(e.shape,"."));const s=e.rank>0?e.shape[0]:1,r=e.rank>1?e.shape[1]:1;if(n.length!==r)throw new Error("outputShape has incorrect number of elements:,"+" ".concat(n.length,", should be: ").concat(r,"."));const i=t.size;if(0!==t.rank&&(1!==t.rank||i!==s))throw new Error("sparseValues has incorrect shape "+"".concat(t.shape,", should be [] or [").concat(s,"]"));if(t.dtype!==a.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(s,r,n,i);const o={sparseIndices:s,sparseValues:r,defaultValue:i},c={outputShape:n};return Em.runKernel(Gp,o,c)}});const _k=jm({gatherND_:function(e,t){const n=Lm(t,"indices","gatherND","int32"),a={params:Lm(e,"x","gatherND","string_or_numeric"),indices:n};return Em.runKernel(yd,a)}});const Ak=jm({dropout_:function(e,t,n,a){const s=Lm(e,"x","dropout");if(bu("float32"===s.dtype,()=>"x has to be a floating point tensor since it's going to be "+"scaled, but got a ".concat(s.dtype," tensor instead.")),bu(t>=0&&t<1,()=>"rate must be a float in the range [0, 1), but got ".concat(t,".")),0===t)return e instanceof om?s.clone():s;const r=function(e,t){if(null==t)return e.shape.slice();if(Su(e.shape,t))return t;if(e.shape.length===t.length){const n=[];for(let a=0;a<e.shape.length;a++)null==t[a]&&null!=e.shape[a]?n.push(e.shape[a]):n.push(t[a]);return n}return t}(s,n),i=1-t,o=cy(mv(iy(Iw(r,0,1,"float32",a),i)),i);return ly(s,o)}});function Mk(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function Pk(e,t,n){const a=1-e%2,s=new Float32Array(e);for(let r=0;r<e;++r){const i=2*Math.PI*r/(e+a-1);s[r]=t-n*Math.cos(i)}return ok(s,"float32")}const Dk=async function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;const a=Lm(e,"predictions","inTopK"),s=Lm(t,"targets","inTopK");bu(a.rank>1,()=>"inTopK() expects the predictions to be of rank 2 or higher, "+"but got ".concat(a.rank)),bu(a.rank-1===s.rank,()=>"predictions rank should be 1 larger than targets rank, but got predictions rank "+"".concat(a.rank," and targets rank ").concat(s.rank)),xu(a.shape.slice(0,a.shape.length-1),s.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const r=a.shape[a.shape.length-1];bu(n>0&&n<=r,()=>"'k' passed to inTopK() must be > 0 && <= the predictions last "+"dimension (".concat(r,"), but got ").concat(n));const i=await a.data(),o=await s.data(),[c,l]=[i.length/r,r],u=Au("bool",c);for(let h=0;h<c;h++){const e=h*l,t=i.subarray(e,e+l),a=[];for(let n=0;n<t.length;n++)a.push({value:t[n],index:n});a.sort((e,t)=>t.value-e.value),u[h]=0;for(let s=0;s<n;s++)if(a[s].index===o[h]){u[h]=1;break}}return e!==a&&a.dispose(),t!==s&&s.dispose(),Um(u,s.shape,"bool")};const Ok=jm({conv2DBackpropFilter_:function(e,t,n,a,s){let r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",i=arguments.length>6?arguments[6]:void 0,o=e;3===e.rank&&(o=nx(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let c=t;3===c.rank&&(c=nx(t,[1,t.shape[0],t.shape[1],t.shape[2]])),bu(4===o.rank,()=>"Error in conv2dDerFilter: input must be rank 4, but got shape "+"".concat(o.shape,".")),bu(4===c.rank,()=>"Error in conv2dDerFilter: dy must be rank 4, but got shape "+"".concat(c.shape,".")),bu(4===n.length,()=>"Error in conv2dDerFilter: filterShape must be length 4, but got "+"".concat(n,"."));const l="NHWC"===r?o.shape[3]:o.shape[1],u="NHWC"===r?c.shape[3]:c.shape[1];bu(l===n[2],()=>"Error in conv2dDerFilter: depth of input ".concat(l,") must ")+"match input depth in filter (".concat(n[2],".")),bu(u===n[3],()=>"Error in conv2dDerFilter: depth of dy (".concat(u,") must ")+"match output depth for filter (".concat(n[3],").")),tx("conv2dDerFilter",s,i);const h={x:o,dy:c},d={strides:a,pad:s,dataFormat:r,dimRoundingMode:i,filterShape:n};return Em.runKernel(Oh,h,d)}});function Fk(e,t,n){if(null==n||"linear"===n)return e;if("relu"===n)return ly(e,sk(t));throw new Error("Cannot compute gradient for fused activation ".concat(n,"."))}function Lk(e,t){let n=t;const a=Ry(e.shape,t.shape);return a.length>0&&(n=iv(n,a)),nx(n,e.shape)}function zk(e,t,n,a){if("linear"===t)return e;if("relu"===t)return _w(e);if("elu"===t)return Kx(e);if("relu6"===t)return Aw(e);if("prelu"===t)return dw(e,n);if("leakyrelu"===t)return Sv(e,a);if("sigmoid"===t)return ox(e);throw new Error("Unknown fused activation ".concat(t,"."))}const Bk=(e,t)=>!(e>0)||"linear"===t;const jk=jm({fusedConv2d_:function(e){let{x:t,filter:n,strides:a,pad:s,dataFormat:r="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:c,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:h}=e;if(l=l||"linear",!1===Bk(Em.state.gradientDepth,l)){bu("NHWC"===r,()=>"Error in fused conv2d: got dataFormat of ".concat(r," but ")+"only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.");let e=Nx(t,n,a,s,r,i,o);return null!=c&&(e=iy(e,c)),zk(e,l,u,h)}const d=Lm(t,"x","conv2d","float32"),p=Lm(n,"filter","conv2d","float32");let f=d,m=!1;3===d.rank&&(m=!0,f=nx(d,[1,d.shape[0],d.shape[1],d.shape[2]])),bu(4===f.rank,()=>"Error in fused conv2d: input must be rank 4, but got rank "+"".concat(f.rank,".")),bu(4===p.rank,()=>"Error in fused conv2d: filter must be rank 4, but got rank "+"".concat(p.rank,".")),tx("fused conv2d",s,o);const g="NHWC"===r?f.shape[3]:f.shape[1];bu(p.shape[2]===g,()=>"Error in conv2d: depth of input (".concat(g,") must match ")+"input depth for filter ".concat(p.shape[2],".")),bu(Jb(a,i),()=>"Error in conv2D: Either strides or dilations must be 1. "+"Got strides ".concat(a," and dilations '").concat(i,"'"));const y=Hb(f.shape,p.shape,a,i,s,o);let b,x;if(null!=c&&(b=Lm(c,"bias","fused conv2d"),[b]=vm(b,d),"NHWC"===r?_y(y.outShape,b.shape):(bu(b.shape.length<=1,()=>"Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of "+"rank-".concat(b.shape.length,".")),bu(0===b.shape.length||b.shape[0]===y.outChannels||1===b.shape[0],()=>"Error in fused conv2d: bias shape (".concat(b.shape,") is not ")+"compatible with the number of output channels "+"(".concat(y.outChannels,")")))),null!=u){const e=u.shape;if(bu(e.length<=1||3===e.length,()=>"Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of "+"rank-".concat(e.length,".")),1===e.length)bu(1===e[0]||e[0]===y.outChannels,()=>"Error in fused conv2d: PReLU activation weights "+"(".concat(e,") is not compatible with the number of output ")+"channels (".concat(y.outChannels,")."));else if(3===e.length)try{_y(e,y.outShape)}catch(q5){const n="Error in fused conv2d: PReLU activation weights (".concat(e,") ")+"is not compatible with the output shape of the conv2d "+"(".concat(y.outShape,").");throw Error(n)}x=Lm(u,"prelu weights","fused conv2d")}const v=(e,t)=>{bu("NHWC"===r,()=>"Error in gradient of fused conv2D: got dataFormat of ".concat(r," but only NHWC is currently supported."));const[n,o,c,u]=t,h=Fk(e,c,l);bu(Zb(i),()=>"Error in gradient of fused conv2D: dilation rates greater than 1 "+"are not yet supported in gradients. Got dilations '".concat(i,"'"));const d=[Ex(o.shape,h,n,a,s),Ok(o,h,n.shape,a,s)];if(null!=u){const e=Lk(u,h);d.push(e)}return d},w={x:f,filter:p,bias:b,preluActivationWeights:x},k={strides:a,pad:s,dataFormat:r,dilations:i,dimRoundingMode:o,activation:l,leakyreluAlpha:h};if(null==c){const e=py((e,t,n)=>{let a=Em.runKernel(mf,w,k);return n([t,e,a]),m&&(a=nx(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:v}});return e(f,p)}{const e=py((e,t,n,a)=>{let s=Em.runKernel(mf,w,k);return a([t,e,s,n]),m&&(s=nx(s,[s.shape[1],s.shape[2],s.shape[3]])),{value:s,gradFunc:v}});return e(f,p,b)}}});const Wk=jm({depthwiseConv2dNativeBackpropFilter_:function(e,t,n,a,s){let r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6?arguments[6]:void 0,o=e;3===e.rank&&(o=nx(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let c=t;3===c.rank&&(c=nx(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const l={x:o,dy:c},u={strides:a,pad:s,dimRoundingMode:i,dilations:r,filterShape:n};return Em.runKernel(Xh,l,u)}});const Vk=jm({depthwiseConv2dNativeBackpropInput_:function(e,t,n,a,s){let r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6?arguments[6]:void 0,o=t,c=!1;3===t.rank&&(c=!0,o=nx(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const l={dy:o,filter:n},u={strides:a,pad:s,dimRoundingMode:i,dilations:r,inputShape:e},h=Em.runKernel(Yh,l,u);return c?nx(h,[h.shape[1],h.shape[2],h.shape[3]]):h}});const Uk=jm({fusedDepthwiseConv2d_:function(e){let{x:t,filter:n,strides:a,pad:s,dataFormat:r="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:c,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:h}=e;if(!1===Bk(Em.state.gradientDepth,l)){let e=Bx(t,n,a,s,r,i,o);return null!=c&&(e=iy(e,c)),zk(e,l,u,h)}const d=Lm(t,"x","depthwiseConv2d","float32"),p=Lm(n,"filter","depthwiseConv2d","float32");let f=d,m=!1;3===d.rank&&(m=!0,f=nx(d,[1,d.shape[0],d.shape[1],d.shape[2]])),bu(4===f.rank,()=>"Error in fused depthwiseConv2d: input must be rank 4, but got "+"rank ".concat(f.rank,".")),bu(4===p.rank,()=>"Error in fused depthwiseConv2d: filter must be rank 4, "+"but got rank ".concat(p.rank,".")),bu(f.shape[3]===p.shape[2],()=>"Error in fused depthwiseConv2d: number of input channels "+"(".concat(f.shape[3],") must match the inChannels dimension in ")+"filter ".concat(p.shape[2],".")),null==i&&(i=[1,1]),bu(Jb(a,i),()=>"Error in fused depthwiseConv2d: Either strides or dilations must "+"be 1. Got strides ".concat(a," and dilations '").concat(i,"'")),tx("fused depthwiseConv2d",s,o);const g=Hb(f.shape,p.shape,a,i,s,o,!0);let y,b;null!=c&&(y=Lm(c,"bias","fused conv2d"),[y]=vm(y,d),_y(g.outShape,y.shape)),null!=u&&(b=Lm(u,"prelu weights","fused depthwiseConv2d"));const x=(e,t)=>{bu(Zb(i),()=>"Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations "+"'".concat(i,"'"));const[n,r,c,u]=t,h=Fk(e,c,l),d=Vk(r.shape,h,n,a,s,i,o),p=Wk(r,h,n.shape,a,s,i,o);if(null!=u){return[d,p,Lk(y,h)]}return[d,p]},v={x:f,filter:p,bias:y,preluActivationWeights:b},w={strides:a,pad:s,dataFormat:r,dilations:i,dimRoundingMode:o,activation:l,leakyreluAlpha:h};if(null==c){const e=py((e,t,n)=>{let a=Em.runKernel(gf,v,w);return n([t,e,a]),m&&(a=nx(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:x}});return e(f,p)}{const e=py((e,t,n,a)=>{let s=Em.runKernel(gf,v,w);return a([t,e,s,n]),m&&(s=nx(s,[s.shape[1],s.shape[2],s.shape[3]])),{value:s,gradFunc:x}});return e(f,p,y)}}});const Hk=jm({fusedMatMul_:function(e){let{a:t,b:n,transposeA:a=!1,transposeB:s=!1,bias:r,activation:i="linear",preluActivationWeights:o,leakyreluAlpha:c=.2}=e;if(!1===Bk(Em.state.gradientDepth,i)){let e=ix(t,n,a,s);return null!=r&&(e=iy(e,r)),zk(e,i,o,c)}let l=Lm(t,"a","fused matMul"),u=Lm(n,"b","fused matMul");[l,u]=vm(l,u);const h=a?l.shape[l.rank-2]:l.shape[l.rank-1],d=s?u.shape[u.rank-1]:u.shape[u.rank-2],p=a?l.shape[l.rank-1]:l.shape[l.rank-2],f=s?u.shape[u.rank-2]:u.shape[u.rank-1],m=l.shape.slice(0,-2),g=u.shape.slice(0,-2),y=wu(m),b=wu(g);bu(h===d,()=>"Error in fused matMul: inner shapes (".concat(h,") and (")+"".concat(d,") of Tensors with shapes ").concat(l.shape," and ")+"".concat(u.shape," and transposeA=").concat(a)+" and transposeB=".concat(s," must match."));const x=_y(l.shape.slice(0,-2),u.shape.slice(0,-2)).concat([p,f]),v=nx(l,a?[y,h,p]:[y,p,h]),w=nx(u,s?[b,f,d]:[b,d,f]);let k,S;null!=r&&(k=Lm(r,"bias","fused matMul"),[k]=vm(k,l),_y(x,k.shape)),null!=o&&(S=Lm(o,"prelu weights","fused matMul"));const C=(e,t)=>{const[n,o,c,l]=t,u=Fk(nx(e,c.shape),c,i);let h,d;if(a||s?!a&&s?(h=ix(u,o,!1,!1),d=ix(u,n,!0,!1)):a&&!s?(h=ix(o,u,!1,!0),d=ix(n,u,!1,!1)):(h=ix(o,u,!0,!0),d=ix(u,n,!0,!0)):(h=ix(u,o,!1,!0),d=ix(n,u,!0,!1)),null!=r){return[h,d,Lk(l,u)]}return[h,d]},I={a:v,b:w,bias:k,preluActivationWeights:S},N={transposeA:a,transposeB:s,activation:i,leakyreluAlpha:c};if(null==r){const e=py((e,t,n)=>{const a=Em.runKernel(ff,I,N);return n([e,t,a]),{value:nx(a,x),gradFunc:C}});return e(v,w)}{const e=py((e,t,n,a)=>{const s=Em.runKernel(ff,I,N);return a([e,t,s,n]),{value:nx(s,x),gradFunc:C}});return e(v,w,k)}}});const Gk=jm({hammingWindow_:function(e){return Pk(e,.54,.46)}});const qk=jm({hannWindow_:function(e){return Pk(e,.5,.5)}});const Kk=jm({frame_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,r=0;const i=[];for(;r+t<=e.size;)i.push(cx(e,r,t)),r+=n;if(a)for(;r<e.size;){const a=r+t-e.size,o=rx([cx(e,r,t-a),ky([a],s)]);i.push(o),r+=n}return 0===i.length?ck([],[0,t]):nx(rx(i),[i.length,t])}});const Xk=jm({stft_:function(e,t,n,a){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:qk;null==a&&(a=Mk(t));const r=Kk(e,t,n),i=ly(r,s(t));return ek(i,a)}});const Yk=jm({cropAndResize_:function(e,t,n,a){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"bilinear",r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const i=Lm(e,"image","cropAndResize"),o=Lm(t,"boxes","cropAndResize","float32"),c=Lm(n,"boxInd","cropAndResize","int32"),l=o.shape[0];bu(4===i.rank,()=>"Error in cropAndResize: image must be rank 4,"+"but got rank ".concat(i.rank,".")),bu(2===o.rank&&4===o.shape[1],()=>"Error in cropAndResize: boxes must be have size [".concat(l,",4] ")+"but had shape ".concat(o.shape,".")),bu(1===c.rank&&c.shape[0]===l,()=>"Error in cropAndResize: boxInd must be have size [".concat(l,"] ")+"but had shape ".concat(o.shape,".")),bu(2===a.length,()=>"Error in cropAndResize: cropSize must be of length 2, but got "+"length ".concat(a.length,".")),bu(a[0]>=1&&a[1]>=1,()=>"cropSize must be atleast [1,1], but was ".concat(a)),bu("bilinear"===s||"nearest"===s,()=>"method must be bilinear or nearest, but was ".concat(s));const u={image:i,boxes:o,boxInd:c},h={method:s,extrapolationValue:r,cropSize:a};return Em.runKernel(Hh,u,h)}});const Qk=jm({flipLeftRight_:function(e){const t=Lm(e,"image","flipLeftRight","float32");bu(4===t.rank,()=>"Error in flipLeftRight: image must be rank 4,"+"but got rank ".concat(t.rank,"."));const n={image:t};return Em.runKernel(dd,n,{})}});const Zk=jm({grayscaleToRGB_:function(e){const t=Lm(e,"image","grayscaleToRGB"),n=t.rank-1,a=t.shape[n];bu(t.rank>=2,()=>"Error in grayscaleToRGB: images must be at least rank 2, "+"but got rank ".concat(t.rank,".")),bu(1===a,()=>"Error in grayscaleToRGB: last dimension of a grayscale image "+"should be size 1, but got size ".concat(a,"."));const s=new Array(t.rank);return s.fill(1,0,n),s[n]=3,pv(t,s)}});const Jk=jm({rgbToGrayscale_:function(e){const t=Lm(e,"image","RGBToGrayscale"),n=t.rank-1,a=t.shape[n];bu(t.rank>=2,()=>"Error in RGBToGrayscale: images must be at least rank 2, "+"but got rank ".concat(t.rank,".")),bu(3===a,()=>"Error in RGBToGrayscale: last dimension of an RGB image "+"should be size 3, but got size ".concat(a,"."));const s=t.dtype,r=ay(t,"float32"),i=ok([.2989,.587,.114]);let o;switch(t.rank){case 2:o=qx("ij,j->i",r,i);break;case 3:o=qx("ijk,k->ij",r,i);break;case 4:o=qx("ijkl,l->ijk",r,i);break;case 5:o=qx("ijklm,m->ijkl",r,i);break;case 6:o=qx("ijklmn,n->ijklm",r,i);break;default:throw new Error("Not a valid tensor rank.")}return o=hv(o,-1),ay(o,s)}});const $k=jm({rotateWithOffset_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5;const s=Lm(e,"image","rotateWithOffset","float32");bu(4===s.rank,()=>"Error in rotateWithOffset: image must be rank 4,"+"but got rank ".concat(s.rank,"."));const r={image:s},i={radians:t,fillValue:n,center:a};return Em.runKernel(pf,r,i)}});function eS(e,t,n,a,s,r){null==a&&(a=.5),null==s&&(s=Number.NEGATIVE_INFINITY),null==r&&(r=0);const i=e.shape[0];return n=Math.min(n,i),bu(0<=a&&a<=1,()=>"iouThreshold must be in [0, 1], but was '".concat(a,"'")),bu(2===e.rank,()=>"boxes must be a 2D tensor, but was of rank '".concat(e.rank,"'")),bu(4===e.shape[1],()=>"boxes must have 4 columns, but 2nd dimension was ".concat(e.shape[1])),bu(1===t.rank,()=>"scores must be a 1D tensor"),bu(t.shape[0]===i,()=>"scores has incompatible shape with boxes. Expected ".concat(i,", ")+"but was ".concat(t.shape[0])),bu(0<=r&&r<=1,()=>"softNmsSigma must be in [0, 1], but was '".concat(r,"'")),{maxOutputSize:n,iouThreshold:a,scoreThreshold:s,softNmsSigma:r}}const tS=jm({nonMaxSuppression_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY;const r=Lm(e,"boxes","nonMaxSuppression","float32"),i=Lm(t,"scores","nonMaxSuppression","float32"),o=eS(r,i,n,a,s);n=o.maxOutputSize,a=o.iouThreshold,s=o.scoreThreshold;const c={maxOutputSize:n,iouThreshold:a,scoreThreshold:s};return Em.runKernel($d,{boxes:r,scores:i},c)}});function nS(e,t,n){const a=function(e,t,n){return function(e,t,n){let a=0,s=e.length,r=0,i=!1;for(;a<s;){r=a+(s-a>>>1);const o=n(t,e[r]);o>0?a=r+1:(s=r,i=!o)}return i?a:-a-1}(e,t,n||aS)}(e,t,n),s=a<0?-(a+1):a;e.splice(s,0,t)}function aS(e,t){return e>t?1:e<t?-1:0}function sS(e,t,n,a,s){return oS(e,t,n,a,s,0)}function rS(e,t,n,a,s,r){return oS(e,t,n,a,s,0,!1,r,!0)}function iS(e,t,n,a,s,r){return oS(e,t,n,a,s,r,!0)}function oS(e,t,n,a,s,r){let i=arguments.length>6&&void 0!==arguments[6]&&arguments[6],o=arguments.length>7&&void 0!==arguments[7]&&arguments[7],c=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const l=[];for(let g=0;g<t.length;g++)t[g]>s&&l.push({score:t[g],boxIndex:g,suppressBeginIndex:0});l.sort(uS);const u=r>0?-.5/r:0,h=[],d=[];for(;h.length<n&&l.length>0;){const t=l.pop(),{score:n,boxIndex:r,suppressBeginIndex:i}=t;if(n<s)break;let o=!1;for(let c=h.length-1;c>=i;--c){const n=cS(e,r,h[c]);if(n>=a){o=!0;break}if(t.score=t.score*lS(a,u,n),t.score<=s)break}t.suppressBeginIndex=h.length,o||(t.score===n?(h.push(r),d.push(t.score)):t.score>s&&nS(l,t,uS))}const p=h.length,f=n-p;o&&f>0&&(h.push(...new Array(f).fill(0)),d.push(...new Array(f).fill(0)));const m={selectedIndices:h};return i&&(m.selectedScores=d),c&&(m.validOutputs=p),m}function cS(e,t,n){const a=e.subarray(4*t,4*t+4),s=e.subarray(4*n,4*n+4),r=Math.min(a[0],a[2]),i=Math.min(a[1],a[3]),o=Math.max(a[0],a[2]),c=Math.max(a[1],a[3]),l=Math.min(s[0],s[2]),u=Math.min(s[1],s[3]),h=Math.max(s[0],s[2]),d=Math.max(s[1],s[3]),p=(o-r)*(c-i),f=(h-l)*(d-u);if(p<=0||f<=0)return 0;const m=Math.max(r,l),g=Math.max(i,u),y=Math.min(o,h),b=Math.min(c,d),x=Math.max(y-m,0)*Math.max(b-g,0);return x/(p+f-x)}function lS(e,t,n){const a=Math.exp(t*n*n);return n<=e?a:0}function uS(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}const hS=async function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY;const r=Lm(e,"boxes","nonMaxSuppressionAsync"),i=Lm(t,"scores","nonMaxSuppressionAsync"),o=eS(r,i,n,a,s);n=o.maxOutputSize,a=o.iouThreshold,s=o.scoreThreshold;const c=await Promise.all([r.data(),i.data()]),l=c[0],u=c[1],{selectedIndices:h}=sS(l,u,n,a,s);return r!==e&&r.dispose(),i!==t&&i.dispose(),ok(h,"int32")};const dS=jm({nonMaxSuppressionWithScore_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const i=Lm(e,"boxes","nonMaxSuppression"),o=Lm(t,"scores","nonMaxSuppression"),c=eS(i,o,n,a,s,r);n=c.maxOutputSize,a=c.iouThreshold,s=c.scoreThreshold,r=c.softNmsSigma;const l={boxes:i,scores:o},u={maxOutputSize:n,iouThreshold:a,scoreThreshold:s,softNmsSigma:r},h=Em.runKernel(tp,l,u);return{selectedIndices:h[0],selectedScores:h[1]}}});const pS=async function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const i=Lm(e,"boxes","nonMaxSuppressionAsync"),o=Lm(t,"scores","nonMaxSuppressionAsync"),c=eS(i,o,n,a,s,r);n=c.maxOutputSize,a=c.iouThreshold,s=c.scoreThreshold,r=c.softNmsSigma;const l=await Promise.all([i.data(),o.data()]),u=l[0],h=l[1],{selectedIndices:d,selectedScores:p}=iS(u,h,n,a,s,r);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:ok(d,"int32"),selectedScores:ok(p)}};const fS=jm({nonMaxSuppressionPadded_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,r=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const i=Lm(e,"boxes","nonMaxSuppression"),o=Lm(t,"scores","nonMaxSuppression"),c=eS(i,o,n,a,s,null),l={boxes:i,scores:o},u={maxOutputSize:c.maxOutputSize,iouThreshold:c.iouThreshold,scoreThreshold:c.scoreThreshold,padToMaxOutputSize:r},h=Em.runKernel(ep,l,u);return{selectedIndices:h[0],validOutputs:h[1]}}});const mS=async function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,r=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const i=Lm(e,"boxes","nonMaxSuppressionAsync"),o=Lm(t,"scores","nonMaxSuppressionAsync"),c=eS(i,o,n,a,s,null),l=c.maxOutputSize,u=c.iouThreshold,h=c.scoreThreshold,[d,p]=await Promise.all([i.data(),o.data()]),{selectedIndices:f,validOutputs:m}=rS(d,p,l,u,h,r);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:ok(f,"int32"),validOutputs:fy(m,"int32")}};const gS=jm({resizeBilinear_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s=Lm(e,"images","resizeBilinear");bu(3===s.rank||4===s.rank,()=>"Error in resizeBilinear: x must be rank 3 or 4, but got "+"rank ".concat(s.rank,".")),bu(2===t.length,()=>"Error in resizeBilinear: new shape must 2D, but got shape "+"".concat(t,".")),bu(!1===a||!1===n,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let r=s,i=!1;3===s.rank&&(i=!0,r=nx(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const[]=t,o={images:r},c={alignCorners:n,halfPixelCenters:a,size:t},l=Em.runKernel(xp,o,c);return i?nx(l,[l.shape[1],l.shape[2],l.shape[3]]):l}});const yS=jm({resizeNearestNeighbor_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s=Lm(e,"images","resizeNearestNeighbor");bu(3===s.rank||4===s.rank,()=>"Error in resizeNearestNeighbor: x must be rank 3 or 4, but got "+"rank ".concat(s.rank,".")),bu(2===t.length,()=>"Error in resizeNearestNeighbor: new shape must 2D, but got shape "+"".concat(t,".")),bu("float32"===s.dtype||"int32"===s.dtype,()=>"`images` must have `int32` or `float32` as dtype"),bu(!1===a||!1===n,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let r=s,i=!1;3===s.rank&&(i=!0,r=nx(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const[]=t,o={images:r},c={alignCorners:n,halfPixelCenters:a,size:t},l=Em.runKernel(yp,o,c);return i?nx(l,[l.shape[1],l.shape[2],l.shape[3]]):l}});const bS=jm({threshold_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"binary",n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5;const s=Lm(e,"image","threshold"),r=s.shape[0]*s.shape[1];let i,o,c,l,u=ly(ok([a]),255);if(bu(3===s.rank,()=>"Error in threshold: image must be rank 3,"+"but got rank ".concat(s.rank,".")),bu(3===s.shape[2]||1===s.shape[2],()=>"Error in threshold: image color channel must be equal to 3 or 1"+"but got ".concat(s.shape[2],".")),bu("int32"===s.dtype||"float32"===s.dtype,()=>"Error in dtype: image dtype must be int32 or float32,"+"but got dtype ".concat(s.dtype,".")),bu("otsu"===t||"binary"===t,()=>"Method must be binary or otsu, but was ".concat(t)),3===s.shape[2]){[i,o,c]=$w(s,[1,1,1],-1);const e=ly(i,.2989),t=ly(o,.587),n=ly(c,.114);l=iy(iy(e,t),n)}else l=e;if("otsu"===t){u=function(e,t){let n,a,s,r,i,o,c=ok([-1]),l=ok([0]),u=ok([0]);for(let h=0;h<e.size-1;h++){n=cx(e,0,h+1),a=cx(e,h+1),i=cy(iv(n),t),o=cy(iv(a),t);const d=iv(ly(n,Tw(0,n.size)));s=cy(d,iv(n));const p=ky(a.shape,n.size),f=iy(Tw(0,a.size),p),m=ly(a,f);r=cy(iv(m),iv(a));const g=Iy(s,r),y=Iy(s,r),b=ly(i,o);u=ly(ly(b,g),y);const x=yv(u,l);l=Ux(x,u,l),c=Ux(x,ok([h]),c)}return c}(gx(ay(Lw(l),"int32"),Um([]),256),r)}const h=n?Iv(l,u):yv(l,u);return ay(ly(h,255),"int32")}});const xS=jm({transform_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"nearest",a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"constant",s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,r=arguments.length>5?arguments[5]:void 0;const i=Lm(e,"image","transform","float32"),o=Lm(t,"transforms","transform","float32");bu(4===i.rank,()=>"Error in transform: image must be rank 4,"+"but got rank ".concat(i.rank,".")),bu(2===o.rank&&(o.shape[0]===i.shape[0]||1===o.shape[0])&&8===o.shape[1],()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),bu(null==r||2===r.length,()=>"Error in transform: outputShape must be [height, width] or null, "+"but got ".concat(r,"."));const c={image:i,transforms:o},l={interpolation:n,fillMode:a,fillValue:s,outputShape:r};return Em.runKernel(sf,c,l)}});const vS=jm({bandPart_:function(e,t,n){const a=Lm(e,"a","bandPart");bu(a.rank>=2,()=>"bandPart(): Rank must be at least 2, got ".concat(a.rank,"."));const s=a.shape,[r,i]=a.shape.slice(-2);let o,c;"number"===typeof t?(bu(t%1===0,()=>"bandPart(): numLower must be an integer, got ".concat(t,".")),bu(t<=r,()=>"bandPart(): numLower (".concat(t,")")+" must not be greater than the number of rows (".concat(r,").")),o=Lm(t<0?r:t,"numLower","bandPart")):(bu("int32"===t.dtype,()=>"bandPart(): numLower's dtype must be an int32."),o=Ux(Cv(t,0),r,Yv(t,r))),"number"===typeof n?(bu(n%1===0,()=>"bandPart(): numUpper must be an integer, got ".concat(n,".")),bu(n<=i,()=>"bandPart(): numUpper (".concat(n,")")+" must not be greater than the number of columns (".concat(i,").")),c=Lm(n<0?i:n,"numUpper","bandPart")):(bu("int32"===n.dtype,()=>"bandPart(): numUpper's dtype must be an int32."),c=Ux(Cv(n,0),i,Yv(n,i)));const l=nx(Tw(0,r,1,"int32"),[-1,1]),u=Tw(0,i,1,"int32"),h=Iy(l,u),d=Ov(Iv(h,o),bv(h,_v(c))),p=qv([r,i],a.dtype);return nx(ak(vk(nx(a,[-1,r,i])).map(e=>Ux(d,e,p))),s)}});const wS=jm({gramSchmidt_:function(e){let t;if(Array.isArray(e)){t=!1,bu(null!=e&&e.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const n=e[0].shape[0];for(let t=1;t<e.length;++t)bu(e[t].shape[0]===n,()=>"Gram-Schmidt: Non-unique lengths found in the input vectors: "+"(".concat(e[t].shape[0]," vs. ").concat(n,")"))}else t=!0,e=$w(e,e.shape[0],0).map(e=>nk(e,[0]));bu(e.length<=e[0].shape[0],()=>"Gram-Schmidt: Number of vectors (".concat(e.length,") exceeds ")+"number of dimensions (".concat(e[0].shape[0],")."));const n=[],a=e;for(let s=0;s<e.length;++s)n.push(Em.tidy(()=>{let e=a[s];if(s>0)for(let t=0;t<s;++t){const a=ly(iv(ly(n[t],e)),n[t]);e=Iy(e,a)}return cy(e,cv(e,"euclidean"))}));return t?ak(n,0):n}});function kS(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return Em.tidy(()=>{bu(2===e.shape.length,()=>"qr2d() requires a 2D Tensor, but got a ".concat(e.shape.length,"D Tensor."));const n=e.shape[0],a=e.shape[1];let s=fv(n),r=sy(e);const i=ck([[1]],[1,1]);let o=sy(i);const c=n>=a?a:n;for(let e=0;e<c;++e){const t=r,c=o,l=s;[o,r,s]=Em.tidy(()=>{const t=cx(r,[e,e],[n-e,1]),c=cv(t),l=cx(r,[e,e],[1,1]),u=Ux(yv(l,0),ck([[-1]]),ck([[1]])),h=Iy(l,ly(u,c)),d=cy(t,h);o=1===d.shape[0]?sy(i):rx([i,cx(d,[1,0],[d.shape[0]-1,d.shape[1]])],0);const p=_v(cy(ix(u,h),c)),f=cx(r,[e,0],[n-e,a]),m=ly(p,o),g=Nk(o);if(0===e)r=Iy(f,ix(m,ix(g,f)));else{const t=Iy(f,ix(m,ix(g,f)));r=rx([cx(r,[0,0],[e,a]),t],0)}const y=Nk(m),b=cx(s,[0,e],[n,s.shape[1]-e]);if(0===e)s=Iy(b,ix(ix(b,o),y));else{const t=Iy(b,ix(ix(b,o),y));s=rx([cx(s,[0,0],[n,e]),t],1)}return[o,r,s]}),Ym([t,c,l])}return!t&&n>a&&(s=cx(s,[0,0],[n,a]),r=cx(r,[0,0],[a,a])),[s,r]})}const SS=jm({qr_:function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(bu(e.rank>=2,()=>"qr() requires input tensor to have a rank >= 2, but got rank ".concat(e.rank)),2===e.rank)return kS(e,t);{const n=e.shape.slice(0,e.shape.length-2).reduce((e,t)=>e*t),a=vk(nx(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),s=[],r=[];a.forEach(e=>{const[n,a]=kS(e,t);s.push(n),r.push(a)});return[nx(ak(s,0),e.shape),nx(ak(r,0),e.shape)]}}});var CS;!function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(CS||(CS={}));const IS=jm({computeWeightedLoss_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:CS.SUM_BY_NONZERO_WEIGHTS;const a=Lm(e,"losses","computeWeightedLoss");let s=null;null!=t&&(s=Lm(t,"weights","computeWeightedLoss"));const r=null==s?a:ly(a,s);if(n===CS.NONE)return r;if(n===CS.SUM)return iv(r);if(n===CS.MEAN){if(null==s)return Gv(r);{const e=a.size/s.size,t=cy(iv(r),iv(s));return e>1?cy(t,fy(e)):t}}if(n===CS.SUM_BY_NONZERO_WEIGHTS){if(null==s)return cy(iv(r),fy(a.size));{const e=ly(s,Kv(a.shape)),t=ay(iv(tw(e,fy(0))),"float32");return cy(iv(r),t)}}throw Error("Unknown reduction: ".concat(n))}});const NS=jm({absoluteDifference_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:CS.SUM_BY_NONZERO_WEIGHTS;const s=Lm(e,"labels","absoluteDifference"),r=Lm(t,"predictions","absoluteDifference");let i=null;null!=n&&(i=Lm(n,"weights","absoluteDifference")),xu(s.shape,r.shape,"Error in absoluteDifference: ");const o=Ty(Iy(s,r));return IS(o,i,a)}});const TS=jm({cosineDistance_:function(e,t,n,a){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:CS.SUM_BY_NONZERO_WEIGHTS;const r=Lm(e,"labels","cosineDistance"),i=Lm(t,"predictions","cosineDistance");let o=null;null!=a&&(o=Lm(a,"weights","cosineDistance")),xu(r.shape,i.shape,"Error in cosineDistance: ");const c=fy(1),l=Iy(c,iv(ly(r,i),n,!0));return IS(l,o,s)}});const ES=jm({hingeLoss_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:CS.SUM_BY_NONZERO_WEIGHTS,s=Lm(e,"labels","hingeLoss");const r=Lm(t,"predictions","hingeLoss");let i=null;null!=n&&(i=Lm(n,"weights","hingeLoss")),xu(s.shape,r.shape,"Error in hingeLoss: ");const o=fy(1);s=Iy(ly(fy(2),s),o);const c=_w(Iy(o,ly(s,r)));return IS(c,i,a)}});const RS=jm({huberLoss_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:CS.SUM_BY_NONZERO_WEIGHTS;const r=Lm(e,"labels","huberLoss"),i=Lm(t,"predictions","huberLoss");let o=null;null!=n&&(o=Lm(n,"weights","huberLoss")),xu(r.shape,i.shape,"Error in huberLoss: ");const c=fy(a),l=Ty(Iy(i,r)),u=Yv(l,c),h=Iy(l,u),d=iy(ly(fy(.5),hy(u)),ly(c,h));return IS(d,o,s)}});const _S=jm({logLoss_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1e-7,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:CS.SUM_BY_NONZERO_WEIGHTS;const r=Lm(e,"labels","logLoss"),i=Lm(t,"predictions","logLoss");let o=null;null!=n&&(o=Lm(n,"weights","logLoss")),xu(r.shape,i.shape,"Error in logLoss: ");const c=fy(1),l=fy(a),u=_v(ly(r,Ev(iy(i,l)))),h=ly(Iy(c,r),Ev(iy(Iy(c,i),l))),d=Iy(u,h);return IS(d,o,s)}});const AS=jm({meanSquaredError_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:CS.SUM_BY_NONZERO_WEIGHTS;const s=Lm(e,"labels","meanSquaredError"),r=Lm(t,"predictions","meanSquaredError");let i=null;null!=n&&(i=Lm(n,"weights","meanSquaredError")),xu(s.shape,r.shape,"Error in meanSquaredError: ");const o=tk(s,r);return IS(o,i,a)}});const MS=jm({sigmoidCrossEntropy_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:CS.SUM_BY_NONZERO_WEIGHTS,r=Lm(e,"multiClassLabels","sigmoidCrossEntropy");const i=Lm(t,"logits","sigmoidCrossEntropy");let o=null;if(null!=n&&(o=Lm(n,"weights","sigmoidCrossEntropy")),xu(r.shape,i.shape,"Error in sigmoidCrossEntropy: "),a>0){const e=fy(a),t=fy(1),n=fy(.5);r=iy(ly(r,Iy(t,e)),ly(n,e))}const c=function(e,t){const n=Lm(e,"labels","sigmoidCrossEntropyWithLogits"),a=Lm(t,"logits","sigmoidCrossEntropyWithLogits");xu(n.shape,a.shape,"Error in sigmoidCrossEntropyWithLogits: ");const s=_w(a),r=ly(a,n),i=Rv(uv(_v(Ty(a))));return iy(Iy(s,r),i)}(r,i);return IS(c,o,s)}});const PS=jm({softmaxCrossEntropy_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:CS.SUM_BY_NONZERO_WEIGHTS,r=Lm(e,"onehotLabels","softmaxCrossEntropy");const i=Lm(t,"logits","softmaxCrossEntropy");let o=null;if(null!=n&&(o=Lm(n,"weights","softmaxCrossEntropy")),xu(r.shape,i.shape,"Error in softmaxCrossEntropy: "),a>0){const e=fy(a),t=fy(1),n=fy(r.shape[1]);r=iy(ly(r,Iy(t,e)),cy(e,n))}const c=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;if(-1===n&&(n=t.rank-1),n!==t.rank-1)throw Error("Softmax cross entropy along a non-last dimension is not yet "+"supported. Labels / logits was rank ".concat(t.rank," ")+"and dim was ".concat(n));const a=py((e,t,a)=>{const s=Dv(t,[n],!0),r=Iy(ay(t,"float32"),s);a([e,r]);const i=_v(ly(r,e));return{value:iv(i,[n]),gradFunc:(e,t)=>{const[a,s]=t,r=$x(e.shape,[n]);return[ly(nx(e,r),Iy(ay(a,"float32"),uv(s))),ly(nx(e,r),Iy(uv(s),ay(a,"float32")))]}}});return a(e,t)}(r,i);return IS(c,o,s)}});const DS=jm({sparseFillEmptyRows_:function(e,t,n,a){const s=Lm(e,"indices","sparseFillEmptyRows","int32"),r=Lm(t,"values","sparseFillEmptyRows"),i=Lm(n,"denseShape","sparseFillEmptyRows","int32"),o=Lm(a,"defaultValue","sparseFillEmptyRows",r.dtype);if(2!==s.rank)throw new Error("Indices should be Tensor2D but received shape\n        ".concat(s.shape));if(1!==r.rank)throw new Error("Values should be Tensor1D but received shape ".concat(r.shape));if(1!==i.rank)throw new Error("Dense shape should be Tensor1D but received shape ".concat(i.shape));if(0!==o.rank)throw new Error("Default value should be a scalar but received shape ".concat(o.shape));const c={indices:s,values:r,denseShape:i,defaultValue:o},l=Em.runKernel(Wp,c);return{outputIndices:l[0],outputValues:l[1],emptyRowIndicator:l[2],reverseIndexMap:l[3]}}});const OS=jm({sparseReshape_:function(e,t,n){const a=Lm(e,"inputIndices","sparseReshape","int32"),s=Lm(t,"inputShape","sparseReshape","int32"),r=Lm(n,"newShape","sparseReshape","int32");if(2!==a.rank)throw new Error("Input indices should be Tensor2D but received shape\n        ".concat(a.shape));if(1!==s.rank)throw new Error("Input shape should be Tensor1D but received shape ".concat(s.shape));if(1!==r.rank)throw new Error("New shape should be Tensor1D but received shape ".concat(r.shape));const i={inputIndices:a,inputShape:s,newShape:r},o=Em.runKernel(Vp,i);return{outputIndices:o[0],outputShape:o[1]}}});const FS=jm({sparseSegmentMean_:function(e,t,n){const a=Lm(e,"data","sparseSegmentMean"),s=Lm(t,"indices","sparseSegmentMean","int32"),r=Lm(n,"segmentIds","sparseSegmentMean","int32");if(a.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.rank)throw new Error("Indices should be Tensor1D but received shape\n          ".concat(s.shape));if(1!==r.rank)throw new Error("Segment ids should be Tensor1D but received shape\n          ".concat(r.shape));const i={data:a,indices:s,segmentIds:r};return Em.runKernel(Up,i)}});const LS=jm({sparseSegmentSum_:function(e,t,n){const a=Lm(e,"data","sparseSegmentSum"),s=Lm(t,"indices","sparseSegmentSum","int32"),r=Lm(n,"segmentIds","sparseSegmentSum","int32");if(a.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.rank)throw new Error("Indices should be Tensor1D but received shape\n         ".concat(s.shape));if(1!==r.rank)throw new Error("Segment ids should be Tensor1D but received shape\n         ".concat(r.shape));const i={data:a,indices:s,segmentIds:r};return Em.runKernel(Hp,i)}});const zS=jm({stringNGrams_:function(e,t,n,a,s,r,i,o){const c=Lm(e,"data","stringNGrams","string");if("string"!==c.dtype)throw new Error("Data must be of datatype string");if(1!==c.shape.length)throw new Error("Data must be a vector, saw: ".concat(c.shape));const l=Lm(t,"dataSplits","stringNGrams");if("int32"!==l.dtype)throw new Error("Data splits must be of datatype int32");const u={separator:n,nGramWidths:a,leftPad:s,rightPad:r,padWidth:i,preserveShortSequences:o},h={data:c,dataSplits:l},d=Em.runKernel(Qp,h,u);return{nGrams:d[0],nGramsSplits:d[1]}}});const BS=jm({stringSplit_:function(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];const a=Lm(e,"input","stringSplit","string"),s=Lm(t,"delimiter","stringSplit","string");if(1!==a.rank)throw new Error("Input should be Tensor1D but received shape ".concat(a.shape));if(0!==s.rank)throw new Error("Delimiter should be a scalar but received shape ".concat(s.shape));const r={skipEmpty:n},i={input:a,delimiter:s},o=Em.runKernel(Zp,i,r);return{indices:o[0],values:o[1],shape:o[2]}}});const jS=jm({stringToHashBucketFast_:function(e,t){const n=Lm(e,"input","stringToHashBucketFast","string"),a={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");const s={input:n};return Em.runKernel(Jp,s,a)}});const WS=jm({staticRegexReplace_:function(e,t,n){let a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];const s=Lm(e,"input","staticRegexReplace","string"),r={pattern:t,rewrite:n,replaceGlobal:a};return Em.runKernel(Xp,{x:s},r)}}),VS={fft:Qw,ifft:Zw,rfft:ek,irfft:Jw},US={hammingWindow:Gk,hannWindow:qk,frame:Kk,stft:Xk},HS={flipLeftRight:Qk,grayscaleToRGB:Zk,resizeNearestNeighbor:yS,resizeBilinear:gS,rgbToGrayscale:Jk,rotateWithOffset:$k,cropAndResize:Yk,nonMaxSuppression:tS,nonMaxSuppressionAsync:hS,nonMaxSuppressionWithScore:dS,nonMaxSuppressionWithScoreAsync:pS,nonMaxSuppressionPadded:fS,nonMaxSuppressionPaddedAsync:mS,threshold:bS,transform:xS},GS={bandPart:vS,gramSchmidt:wS,qr:SS},qS={absoluteDifference:NS,computeWeightedLoss:IS,cosineDistance:TS,hingeLoss:ES,huberLoss:RS,logLoss:_S,meanSquaredError:AS,sigmoidCrossEntropy:MS,softmaxCrossEntropy:PS},KS={sparseFillEmptyRows:DS,sparseReshape:OS,sparseSegmentMean:FS,sparseSegmentSum:LS},XS={stringNGrams:zS,stringSplit:BS,stringToHashBucketFast:jS,staticRegexReplace:WS};const YS=class{static sgd(e){return new Py(e)}static momentum(e,t){return new Dy(e,t,arguments.length>2&&void 0!==arguments[2]&&arguments[2])}static rmsprop(e){return new Oy(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,arguments.length>4&&void 0!==arguments[4]&&arguments[4])}static adam(){return new Ny(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.001,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:.999,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null)}static adadelta(){return new wy(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.001,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.95,arguments.length>2&&void 0!==arguments[2]?arguments[2]:null)}static adamax(){return new My(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.002,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:.999,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,arguments.length>4&&void 0!==arguments[4]?arguments[4]:0)}static adagrad(e){return new Sy(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.1)}},QS="undefined"!==typeof requestAnimationFrame?requestAnimationFrame:"undefined"!==typeof setImmediate?setImmediate:e=>e();function ZS(){return new Promise(e=>QS(()=>e()))}function JS(e,t){const n=e[0].length;e.forEach((e,t)=>{bu(e.length===n,()=>"Error in concat".concat(n,"D: rank of tensors[").concat(t,"] must be the same ")+"as the rank of the rest (".concat(n,")"))}),bu(t>=0&&t<n,()=>"Error in concat".concat(n,"D: axis must be between 0 and ").concat(n-1,"."));const a=e[0];e.forEach((e,s)=>{for(let r=0;r<n;r++)bu(r===t||e[r]===a[r],()=>"Error in concat".concat(n,"D: Shape of tensors[").concat(s,"] (").concat(e,") ")+"does not match the shape of the rest (".concat(a,") ")+"along the non-concatenated axis ".concat(s,"."))})}function $S(e,t){const n=e[0].slice();for(let a=1;a<e.length;a++)n[t]+=e[a][t];return n}var eC;function tC(e,t,n){let a=new Array;if(null==n&&null==t)return a;if(null==t)for(;a.length<e+n.length;)a.push(-1);else a=t.slice();if(null==n)return a;if(e+n.length!==a.length)throw new Error("rt input.shape and shape=".concat(t," are incompatible: rt input.rank = ").concat(e+n.length,", but shape.rank = ").concat(a.length));for(let s=1;s<n.length;++s){const r=n[s],i=a[a.length-n.length+s],o=a[i];if(r>=0)if(o>=0){if(o!==r)throw new Error("rt input.shape and shape=".concat(t," are incompatible: rt input.shape[").concat(s+e,"] = ").concat(r," but shape[").concat(s+e,"] = ").concat(o))}else a[i]=r}return a}function nC(e){const t={FIRST_DIM_SIZE:eC.FIRST_DIM_SIZE,VALUE_ROWIDS:eC.VALUE_ROWIDS,ROW_LENGTHS:eC.ROW_LENGTHS,ROW_SPLITS:eC.ROW_SPLITS,ROW_LIMITS:eC.ROW_LIMITS,ROW_STARTS:eC.ROW_STARTS},n=[];for(const a of e){if(!(a in t))break;n.push(t[a])}return n}function aC(e){return 0===e.length?0:e[0]===eC.FIRST_DIM_SIZE?e.length-1:e.length}function sC(e,t){if(null==e||null==t)return;const n=e.length,a=t.length;if(n>=a)throw new Error("defaultValue.shape=".concat(e," and ragged tensor flatValues.shape=").concat(t,", are incompatible: defaultValue.rank = ").concat(n," must be less than ragged tensor input flatValues.rank = ").concat(a,")"));for(let s=0;s<Math.min(n,a-1);++s){const n=e[s],a=t[s+1];if(n>=0&&a>=0&&1!==n&&n!==a)throw new Error("defaultValue.shape=".concat(e,", and ragged tensor input flatValues.shape=").concat(t," are incompatible: defaultValue.shape[").concat(s-e.length,"] = ").concat(n," but ragged tensor input.flatValues.shape[").concat(s-e.length,"] = ").concat(a))}}!function(e){e[e.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",e[e.VALUE_ROWIDS=1]="VALUE_ROWIDS",e[e.ROW_LENGTHS=2]="ROW_LENGTHS",e[e.ROW_SPLITS=3]="ROW_SPLITS",e[e.ROW_LIMITS=4]="ROW_LIMITS",e[e.ROW_STARTS=5]="ROW_STARTS"}(eC||(eC={}));const rC=30;function iC(e){return e<=rC?e:Bu(e,Math.floor(Math.sqrt(e)))}function oC(e,t,n){return[n*("number"===typeof e?e:e[0]),t*("number"===typeof e?e:e[1])]}function cC(e,t,n){let a=[];if(!(arguments.length>3&&void 0!==arguments[3])||arguments[3])a=a.concat(t.slice(0)),a.push(e[0]/n),a=a.concat(e.slice(1));else{a=a.concat(e[0]);const n=t.length;for(let s=0;s<n;++s)a=a.concat([e[s+1]/t[s],t[s]]);a=a.concat(e.slice(n+1))}return a}function lC(e,t){const n=[];if(!(arguments.length>2&&void 0!==arguments[2])||arguments[2]){n.push(t);for(let a=t+1;a<e;++a)a<=2*t?(n.push(a),n.push(a-(t+1))):n.push(a)}else{const a=[],s=[];for(let n=1;n<e;++n)n>=2*t+1||n%2===1?s.push(n):a.push(n);n.push(...a),n.push(0),n.push(...s)}return n}function uC(e,t,n){let a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];const s=[];a?s.push(e[0]/n):s.push(e[0]*n);for(let r=1;r<e.length;++r)r<=t.length?a?s.push(t[r-1]*e[r]):s.push(e[r]/t[r-1]):s.push(e[r]);return s}function hC(e,t){const n=[0];for(let a=0;a<t;++a)n.push(e[a][0]);return n}function dC(e,t,n){const a=e.slice(0,1);for(let s=0;s<n;++s)a.push(e[s+1]-t[s][0]-t[s][1]);return a}function pC(e,t){const n=e.shape.length,a=t.shape.length;if(n<1)throw new Error("tf.gatherND() expects the input to be rank 1 or higher,"+" but the rank was ".concat(n,"."));if(a<1)throw new Error("tf.gatherND() expects the indices to be rank 1 or higher,"+" but the rank was ".concat(a,"."));if("int32"!==t.dtype)throw new Error("tf.gatherND() expects the indices to be int32 type,"+" but the dtype was ".concat(t.dtype,"."));if(t.shape[a-1]>n)throw new Error("index innermost dimension length must be <= tensor rank; saw: "+"".concat(t.shape[a-1]," vs. ").concat(n));if(0===wu(e.shape))throw new Error("Requested more than 0 entries, but input is empty."+" Input shape: ".concat(e.shape,"."));const s=t.shape,r=s[s.length-1];let i=1;for(let h=0;h<s.length-1;++h)i*=s[h];const o=e.shape,c=s.slice();c.pop();let l=1;for(let h=r;h<n;++h)l*=o[h],c.push(o[h]);const u=[...ju(e.shape).map(e=>e/l),1].slice(0,r);return[c,i,l,u]}const fC=1.7580993408473768,mC=1.0507009873554805,gC=.3275911,yC=.254829592,bC=-.284496736,xC=1.421413741,vC=-1.453152027,wC=1.061405429;function kC(e,t){if(e.length!==t.length)throw new Error("Cannot merge real and imag arrays of different lengths. real:"+"".concat(e.length,", imag: ").concat(t.length,"."));const n=new Float32Array(2*e.length);for(let a=0;a<n.length;a+=2)n[a]=e[a/2],n[a+1]=t[a/2];return n}function SC(e){const t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let a=0;a<e.length;a+=2)t[a/2]=e[a],n[a/2]=e[a+1];return{real:t,imag:n}}function CC(e){const t=Math.ceil(e.length/4),n=new Float32Array(t),a=new Float32Array(t);for(let s=0;s<e.length;s+=4)n[Math.floor(s/4)]=e[s],a[Math.floor(s/4)]=e[s+1];return{real:n,imag:a}}function IC(e){const t=Math.floor(e.length/4),n=new Float32Array(t),a=new Float32Array(t);for(let s=2;s<e.length;s+=4)n[Math.floor(s/4)]=e[s],a[Math.floor(s/4)]=e[s+1];return{real:n,imag:a}}function NC(e,t){return{real:e[2*t],imag:e[2*t+1]}}function TC(e,t,n,a){e[2*a]=t,e[2*a+1]=n}function EC(e,t){const n=new Float32Array(e/2),a=new Float32Array(e/2);for(let s=0;s<Math.ceil(e/2);s++){const r=(t?2:-2)*Math.PI*(s/e);n[s]=Math.cos(r),a[s]=Math.sin(r)}return{real:n,imag:a}}function RC(e,t,n){const a=(n?2:-2)*Math.PI*(e/t);return{real:Math.cos(a),imag:Math.sin(a)}}const _C="->",AC=/->/g,MC=",",PC="...";function DC(e,t){const n=((e=e.replace(/\s/g,"")).length-e.replace(AC,"").length)/_C.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error('Equation must contain exactly one arrow ("'.concat(_C,'").'));const[a,s]=e.split(_C);bu(-1===a.indexOf(PC),()=>'The ellipsis notation ("'.concat(PC,'") is not supported yet.'));const r=a.split(MC),i=r.length;if(t!==i)throw new Error("Expected ".concat(i," input tensors, received ").concat(t));if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const o=[];for(let h=0;h<s.length;++h){const e=s[h];if(!r.some(t=>-1!==t.indexOf(e)))throw new Error("Output subscripts contain the label ".concat(e," ")+"not present in the input subscripts.");-1===o.indexOf(e)&&o.push(e)}for(let h=0;h<a.length;++h){const e=a[h];-1===o.indexOf(e)&&e!==MC&&o.push(e)}const c=new Array(r.length);for(let h=0;h<i;++h){if(new Set(r[h].split("")).size!==r[h].length)throw new Error("Found duplicate axes in input component ".concat(r[h],". ")+"Support for duplicate axes in input is not implemented yet.");c[h]=[];for(let e=0;e<r[h].length;++e)c[h].push(o.indexOf(r[h][e]))}const l=o.length,u=[];for(let h=s.length;h<l;++h)u.push(h);return{allDims:o,summedDims:u,idDims:c}}function OC(e,t){let n=new Array(e);n.fill(-1);for(let s=0;s<t.length;++s)n[t[s]]=s;const a=[];for(let s=0;s<e;++s)-1===n[s]&&a.push(s);return n=n.filter(e=>-1!==e),{permutationIndices:n,expandDims:a}}function FC(e,t,n){const a=new Array(e);for(let s=0;s<n.length;++s){const e=n[s].shape;for(let n=0;n<t[s].length;++n)void 0===a[t[s][n]]?a[t[s][n]]=e[n]:bu(a[t[s][n]]===e[n],()=>"Expected dimension ".concat(a[t[s][n]]," at axis ").concat(n," ")+"of input shaped ".concat(JSON.stringify(e),", ")+"but got dimension ".concat(e[n]))}}function LC(e,t){const n=e,a=[];let s=0;0===e.length&&n.push(-1),s=e.length+1;for(let i=0;i<s;++i)a.push([]);const r=[];for(let i=0;i<n.length;++i){const e=BC(t,n[i]);for(const t of e)-1===r.indexOf(t)&&(a[i].push(t),r.push(t))}return{path:n,steps:a}}function zC(e){return e.every((e,t)=>e===t)}function BC(e,t){const n=[];for(let a=0;a<e.length;++a)0!==e[a].length&&-1===e[a].indexOf(t)&&-1!==t||n.push(a);return n}function jC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=[];if("number"===typeof t)bu(e.shape[n]%t===0,()=>"Number of splits must evenly divide the axis."),a=new Array(t).fill(e.shape[n]/t);else{const s=t.reduce((e,t)=>(-1===t&&(e+=1),e),0);bu(s<=1,()=>"There should be only one negative value in split array.");const r=t.indexOf(-1);if(-1!==r){const a=t.reduce((e,t)=>t>0?e+t:e);t[r]=e.shape[n]-a}bu(e.shape[n]===t.reduce((e,t)=>e+t),()=>"The sum of sizes must match the size of the axis dimension."),a=t}return a}function WC(e){return"Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ".concat(e)}function VC(e,t){return"indices(".concat(e,", 0) is invalid: ").concat(t," < 0")}function UC(e,t,n){return"indices(".concat(e,", 0) is invalid: ").concat(t," >= ").concat(n)}function HC(e,t){return"only one output dimension may be -1, not both ".concat(e," and ").concat(t)}function GC(e,t){return"size ".concat(e," must be non-negative, not ").concat(t)}function qC(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function KC(e,t){const n=wu(e),a=wu(t);return"Input to reshape is a SparseTensor with ".concat(n,"\n  dense values, but the requested shape requires a multiple of ").concat(a,". inputShape=").concat(e," outputShape= ").concat(t)}function XC(e,t){const n=wu(e),a=wu(t);return"Input to reshape is a tensor with ".concat(n," dense values, but the requested shape has ").concat(a,". inputShape=").concat(e," outputShape=").concat(t)}function YC(){return"segment ids must be >= 0"}function QC(){return"segment ids are not increasing"}function ZC(e,t){return"Segment id ".concat(e," out of range [0, ").concat(t,"), possibly because segmentIds input is not sorted.")}function JC(e,t,n){return"Bad: indices[".concat(e,"] == ").concat(t," out of range [0, ").concat(n,")")}function $C(e,t){let n,a=!1;for(e<=rC?(n=e,a=!0):n=Bu(e,Math.floor(Math.sqrt(e)));!a;)n>t||n===e?a=!0:n=Bu(e,n+1);return n}function eI(e,t,n){const a=[],s=e.length;for(let r=0;r<s;r++)r!==t?a.push(e[r]):a.push(n);return a}function tI(e,t,n,a){const s=t.shape.length,r=e.shape.length;if(0!==a&&(a<-s||a>s))throw new Error("Expect batchDims in the range of [-".concat(s,", ").concat(s,"], but got ").concat(a));if(a<0&&(a+=s),a>r)throw new Error("batchDims (".concat(a,") must be less than rank(x) (\n    ").concat(r,")."));if(n<a)throw new Error("batchDims (".concat(a,") must be less than or equal to axis (").concat(n,")."));for(let h=0;h<a;++h)if(e.shape[h]!==t.shape[h])throw new Error("x.shape[".concat(h,"]: ").concat(e.shape[h]," should be equal to indices.shape[").concat(h,"]: ").concat(t.shape[h],"."));const i=e.shape[n],o=[];let c=1,l=1,u=1;for(let h=0;h<a;++h)o.push(e.shape[h]),c*=e.shape[h];for(let h=a;h<n;h++)o.push(e.shape[h]),l*=e.shape[h];for(let h=a;h<s;h++)o.push(t.shape[h]);for(let h=n+1;h<r;h++)o.push(e.shape[h]),u*=e.shape[h];return{batchSize:c,sliceSize:u,outerSize:l,dimSize:i,outputShape:o}}function nI(e){try{return e.map(e=>qf(e))}catch(K5){throw new Error("Failed to decode encoded string bytes into utf-8, error: ".concat(K5))}}function aI(e){return e.map(e=>Gf(e))}!function(){for(const e of Fy)xy(e)}();const sI={kernelName:rh,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ly(e,sk(ay(n,"float32"),-1))}}},rI={kernelName:ih,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=hy(ay(n,"float32")),a=uy(Iy(fy(1),t));return _v(cy(e,a))}}}},iI={kernelName:oh,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=uy(Iy(hy(ay(n,"float32")),1));return cy(e,t)}}}},oI={kernelName:ch,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,s=_y(n.shape,a.shape);return{a:()=>{let t=e;const a=Ry(n.shape,s);return a.length>0&&(t=iv(t,a)),nx(t,n.shape)},b:()=>{let t=e;const n=Ry(a.shape,s);return n.length>0&&(t=iv(t,n)),nx(t,a.shape)}}}},cI={kernelName:lh,saveAllInputs:!0,gradFunc:(e,t)=>{const n={};return t.forEach((t,a)=>{n[a]=()=>e.clone()}),n}},lI={kernelName:dh,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>dy(n)}}},uI={kernelName:ph,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>dy(n)}}},hI={kernelName:fh,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>cy(e,uy(Iy(fy(1),hy(ay(n,"float32")))))}}},dI={kernelName:mh,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=uy(iy(fy(1),hy(ay(n,"float32"))));return cy(e,t)}}}},pI={kernelName:bh,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,s=_y(n.shape,a.shape);return{a:()=>{const t=iy(hy(n),hy(a));let r=ly(e,cy(a,t));const i=Ry(n.shape,s);return i.length>0&&(r=iv(r,i)),nx(r,n.shape)},b:()=>{const t=iy(hy(n),hy(a));let r=_v(ly(e,cy(n,t)));const i=Ry(a.shape,s);return i.length>0&&(r=iv(r,i)),nx(r,a.shape)}}}},fI={kernelName:gh,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>cy(e,iy(hy(ay(n,"float32")),1))}}},mI={kernelName:yh,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>cy(e,Iy(fy(1),hy(ay(n,"float32"))))}}};const gI=jm({avgPool3dGrad_:function(e,t,n,a,s,r){const i=Lm(e,"dy","avgPool3dGrad"),o=Lm(t,"input","avgPool3dGrad");let c=i,l=o,u=!1;4===o.rank&&(u=!0,c=nx(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),l=nx(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),bu(5===c.rank,()=>"Error in avgPool3dGrad: dy must be rank 5 but got rank "+"".concat(c.rank,".")),bu(5===l.rank,()=>"Error in avgPool3dGrad: input must be rank 5 but got rank "+"".concat(l.rank,".")),tx("avgPool3dGrad",s,r);const h={dy:c,input:l},d={filterSize:n,strides:a,pad:s,dimRoundingMode:r},p=Em.runKernel(kh,h,d);return u?nx(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}}),yI={kernelName:wh,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{filterSize:s,strides:r,pad:i,dimRoundingMode:o}=n;return{x:()=>gI(e,a,s,r,i,o)}}};const bI=jm({avgPoolGrad_:function(e,t,n,a,s){const r=Lm(e,"dy","avgPoolGrad"),i=Lm(t,"input","avgPoolGrad");bu(i.rank===r.rank,()=>"Rank of input (".concat(i.rank,") does not match rank of dy (").concat(r.rank,")"));let o=i,c=r,l=!1;3===i.rank&&(l=!0,o=nx(i,[1,i.shape[0],i.shape[1],i.shape[2]]),c=nx(r,[1,r.shape[0],r.shape[1],r.shape[2]])),bu(4===c.rank,()=>"Error in avgPoolGrad: dy must be rank 4 but got rank "+"".concat(c.rank,".")),bu(4===o.rank,()=>"Error in avgPoolGrad: input must be rank 4 but got rank "+"".concat(o.rank,"."));const u={dy:c,input:o},h={filterSize:n,strides:a,pad:s},d=Em.runKernel(vh,u,h);return l?nx(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),xI={kernelName:xh,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{filterSize:s,strides:r,pad:i}=n;return{x:()=>bI(e,a,s,r,i)}}},vI={kernelName:Sh,inputsToSave:["a","b"],gradFunc:(e,t,n)=>{const[a,s]=t,{transposeA:r,transposeB:i}=n;return r||i?!r&&i?{a:()=>ix(e,s,!1,!1),b:()=>ix(e,a,!0,!1)}:r&&!i?{a:()=>ix(s,e,!1,!0),b:()=>ix(a,e,!1,!1)}:{a:()=>ix(s,e,!0,!0),b:()=>ix(e,a,!0,!0)}:{a:()=>ix(e,s,!1,!0),b:()=>ix(a,e,!0,!1)}}},wI={kernelName:Ch,gradFunc:(e,t,n)=>{const{blockShape:a,crops:s}=n;return{x:()=>uw(e,a,s)}}},kI={kernelName:"BroadcastTo",gradFunc:(e,t,n)=>{const a=n,s=a.inputShape,r=a.shape,i=Array.from(r);for(let c=s.length-1;c>=0;c--)if(s[c]===r[c])i[c]=1;else if(1!==s[c])throw new Error("broadcastTo(): [".concat(s,"] cannot be broadcast to [").concat(r,"]."));const o=[];for(let c=0;c<i.length;c++)i[c]>1&&o.push(c);return{x:()=>iv(e,o,!0)}}},SI={kernelName:Eh,gradFunc:e=>({x:()=>e.clone()})},CI={kernelName:Rh,gradFunc:e=>({x:()=>dy(e)})},II={kernelName:_h,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{clipValueMin:s,clipValueMax:r}=n;return{x:()=>Ux(Ov(bv(a,s),Iv(a,r)),e,dy(e))}}},NI={kernelName:Mh,inputsToSave:["x"],gradFunc:sI.gradFunc},TI={kernelName:Ph,saveAllInputs:!0,gradFunc:(e,t,n)=>{const a=t.map(e=>e.shape),{axis:s}=n,r=Ru(s,t[0].shape)[0],i=a.map(e=>e[r]);return $w(e,i,r).map(e=>()=>e)}},EI={kernelName:Dh,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[a,s]=t,{dilations:r,strides:i,pad:o,dataFormat:c}=n;return bu(Zb(r),()=>"Error in gradient of conv2D: dilation rates greater than 1 "+"are not yet supported in gradients. Got dilations '".concat(r,"'")),{x:()=>Ex(a.shape,e,s,i,o,c),filter:()=>Ok(a,e,s.shape,i,o,c)}}},RI={kernelName:Fh,inputsToSave:["dy","filter"],gradFunc:(e,t,n)=>{const[a,s]=t,{strides:r,pad:i,dataFormat:o,dimRoundingMode:c}=n;return{dy:()=>Nx(e,s,r,i,o,1,c),filter:()=>Ok(e,a,s.shape,r,i,o,c)}}};const _I=jm({conv3DBackpropFilter_:function(e,t,n,a,s){let r=e;4===e.rank&&(r=nx(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let i=t;4===i.rank&&(i=nx(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),bu(5===r.rank,()=>"Error in conv3dDerFilter: input must be rank 5, but got shape "+"".concat(r.shape,".")),bu(5===i.rank,()=>"Error in conv3dDerFilter: dy must be rank 5, but got shape "+"".concat(i.shape,".")),bu(5===n.length,()=>"Error in conv3dDerFilter: filterShape must be length 5, but got "+"".concat(n,".")),bu(r.shape[4]===n[3],()=>"Error in conv3dDerFilter: depth of input ".concat(r.shape[4],") must ")+"match input depth in filter (".concat(n[3],".")),bu(i.shape[4]===n[4],()=>"Error in conv3dDerFilter: depth of dy (".concat(i.shape[4],") must ")+"match output depth for filter (".concat(n[4],")."));const o={x:r,dy:i},c={strides:a,pad:s,filterShape:n};return Em.runKernel(zh,o,c)}}),AI={kernelName:Lh,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:a,strides:s,pad:r}=n;bu(Zb(a),()=>"Error in gradient of conv3D: dilation rates greater than 1 are "+"not yet supported in gradients. Got dilations '".concat(a,"'"));const[i,o]=t;return{x:()=>Ax(i.shape,e,o,s,r),filter:()=>_I(i,e,o.shape,s,r)}}},MI={kernelName:jh,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ly(_v(Uw(ay(n,"float32"))),e)}}},PI={kernelName:Wh,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ly(Hw(ay(n,"float32")),e)}}},DI={kernelName:Uh,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{axis:s,exclusive:r,reverse:i}=n;return{x:()=>{const t=tv([s],a.rank);let n=Fx(e,s,r,!i);return null!=t&&(n=Nk(n,t)),n}}}},OI={kernelName:Kh,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:a,strides:s,pad:r,dimRoundingMode:i}=n,o=null==a?[1,1]:a;bu(Zb(o),()=>"Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations "+"'".concat(o,"'"));const[c,l]=t;return bu(4===c.rank,()=>"Error in gradient of depthwiseConv2dNative: input must be "+"rank 4, but got rank ".concat(c.rank,".")),bu(4===l.rank,()=>"Error in gradient of depthwiseConv2dNative: filter must be "+"rank 4, but got rank ".concat(l.rank,".")),bu(c.shape[3]===l.shape[2],()=>"Error in gradient of depthwiseConv2d: number of input "+"channels (".concat(c.shape[3],") must match the inChannels dimension ")+"in filter ".concat(l.shape[2],".")),bu(Jb(s,o),()=>"Error in gradient of depthwiseConv2d: Either strides or "+"dilations must be  1. Got strides ".concat(s," and dilations ")+"'".concat(o,"'.")),tx("depthwiseConv2d",r,i),{x:()=>Vk(c.shape,e,l,s,r,o,i),filter:()=>Wk(c,e,l.shape,s,r,o,i)}}},FI={kernelName:Zh,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[a,s]=t,r={x:a,filter:s,dy:e},i={x:a,filter:s,dy:e};return{x:()=>Em.runKernel(Jh,r,n),filter:()=>Em.runKernel($h,i,n)}}},LI={kernelName:ad,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t,a={dy:e,y:n};return{x:()=>Em.runKernel(sd,a)}}},zI={kernelName:rd,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,a=ly(uv(_v(hy(n))),2/Math.sqrt(Math.PI));return{x:()=>ly(e,a)}}},BI={kernelName:od,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ly(e,n)}}},jI={kernelName:cd,inputsToSave:["input"],gradFunc:(e,t)=>{const[n]=t;return{input:()=>nx(e,n.shape)}}},WI={kernelName:ld,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ly(e,uv(n))}}},VI={kernelName:pd,gradFunc:e=>({x:()=>dy(e)})},UI={kernelName:fd,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,s=_y(n.shape,a.shape);return{a:()=>{const t=cy(e,ay(a,"float32")),r=Ry(n.shape,s);return r.length>0?nx(iv(t,r),n.shape):t},b:()=>{let t=ly(e,ay(n,"float32"));const r=Ry(a.shape,s);r.length>0&&(t=nx(iv(t,r),a.shape));const i=hy(a);return _v(cy(t,ay(i,"float32")))}}}},HI={kernelName:md,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,n)=>{const{varianceEpsilon:a}=n,[s,r,i,o]=t,c=null==o?fy(1):o,l=Ry(r.shape,s.shape),u=[];if(1===r.rank){for(let e=0;e<s.shape.length-1;++e)u.push(s.shape[e]);u.push(1)}const h=Iy(s,r),d=ly(e,c),p=zw(iy(i,fy(a))),f=ly(ly(ly(p,p),p),fy(-.5));return{x:()=>1===r.rank?nx(ly(ly(e,pv(nx(p,[1,1,1,r.shape[0]]),u)),c),s.shape):nx(ly(ly(e,p),c),s.shape),mean:()=>{let e=ly(ly(p,fy(-1)),d);return 1===r.rank&&(e=iv(e,l)),nx(e,r.shape)},variance:()=>{let e=ly(ly(f,h),d);return 1===r.rank&&(e=iv(e,l)),nx(e,r.shape)},scale:()=>{const t=ly(h,p);let n=ly(e,t);return 1===r.rank&&(n=iv(n,l)),nx(n,r.shape)},offset:()=>{let t=e;return 1===r.rank&&(t=iv(t,l)),nx(t,r.shape)}}}},GI={kernelName:gd,inputsToSave:["x","indices"],gradFunc:(e,t,n)=>{const[a,s]=t,{axis:r,batchDims:i}=n,o=Ru(r,a.shape)[0],c=(e,t,n)=>()=>{const a=e.shape,s=t.size,i=a.slice(0,o),c=i.length,l=a.slice(r,a.length).slice(1),u=l.length,h=qI(0,c),d=qI(c+1,c+1+u),p=KI([i,[s],l]),f=nx(n,p),m=nx(t,[s]),g=KI([[c],h,d]),y=Nk(f,g);let b=xk(y,m,e.shape[o]);const x=nv(g);return b=Nk(b,x),b};if(1===i){const t=a.shape[0],n=a.split(t,0);return{x:()=>{const t=ak(n.map((t,n)=>c(t,s.slice(n,1),e.slice(n,1))()));return t.reshape(a.shape)},indices:()=>s}}return{x:c(a,s,e),indices:()=>s}}};function qI(e,t){const n=[];for(let a=e;a<t;++a)n.push(a);return n}function KI(e){const t=[];for(let n=0;n<e.length;++n)for(let a=0;a<e[n].length;++a)t.push(e[n][a]);return t}const XI={kernelName:xd,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t;return{a:()=>dy(n),b:()=>dy(a)}}},YI={kernelName:vd,gradFunc:e=>({x:()=>ay(e,"float32")})},QI={kernelName:Sd,gradFunc:e=>({x:()=>dy(e)})},ZI={kernelName:Cd,gradFunc:e=>({x:()=>dy(e)})},JI={kernelName:Id,gradFunc:e=>({x:()=>dy(e)})},$I={kernelName:Nd,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{alpha:s}=n,r=yv(a,0);return{x:()=>Ux(r,e,ly(e,s))}}},eN={kernelName:Ad,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>cy(e,iy(n,1))}}},tN={kernelName:_d,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>cy(e,ay(n,"float32"))}}},nN={kernelName:"LogSoftmax",inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[a]=t,{axis:s}=n;return{logits:()=>{const t=uv(a);return Iy(e,ly(iv(e,s,!0),t))}}}};const aN=jm({localResponseNormalizationBackprop_:function(e,t,n){const a={x:e,y:t,dy:n},s={depthRadius:arguments.length>3&&void 0!==arguments[3]?arguments[3]:5,bias:arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,alpha:arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,beta:arguments.length>6&&void 0!==arguments[6]?arguments[6]:.5};return Em.runKernel(Fd,a,s)}}),sN={kernelName:Od,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[a,s]=t,{depthRadius:r,bias:i,alpha:o,beta:c}=n;return{x:()=>aN(a,s,e,r,i,o,c)}}};function rN(e,t,n,a){return t.rank<n.rank&&(t=nx(t,$x(t.shape,a))),e.rank<n.rank&&(e=nx(e,$x(e.shape,a))),{x:()=>ly(e,ay(Vx(n,t),e.dtype))}}const iN={kernelName:Ld,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const a=n,{reductionIndices:s}=a,r=t[0],i=rN(e,t[1],r,Ru(s,r.shape));return{x:()=>i.x()}}},oN={kernelName:zd,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t;return{a:()=>ly(e,ay(bv(n,a),"float32")),b:()=>ly(e,ay(Cv(n,a),"float32"))}}};const cN=jm({maxPool3dGrad_:function(e,t,n,a,s,r,i){const o=Lm(e,"dy","maxPool3dGrad"),c=Lm(t,"input","maxPool3dGrad"),l=Lm(n,"output","maxPool3dGrad");let u=o,h=c,d=l,p=!1;4===c.rank&&(p=!0,u=nx(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),h=nx(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]]),d=nx(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]])),bu(5===u.rank,()=>"Error in maxPool3dGrad: dy must be rank 5 but got rank "+"".concat(u.rank,".")),bu(5===h.rank,()=>"Error in maxPool3dGrad: input must be rank 5 but got rank "+"".concat(h.rank,".")),bu(5===d.rank,()=>"Error in maxPool3dGrad: output must be rank 5 but got rank "+"".concat(d.rank,".")),tx("maxPool3dGrad",r,i);const f={dy:u,input:h,output:d},m={filterSize:a,strides:s,pad:r,dimRoundingMode:i},g=Em.runKernel(Vd,f,m);return p?nx(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}}),lN={kernelName:Wd,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[a,s]=t,{filterSize:r,strides:i,pad:o,dimRoundingMode:c}=n;return{x:()=>cN(e,a,s,r,i,o,c)}}};const uN=jm({maxPoolGrad_:function(e,t,n,a,s,r,i){const o=Lm(e,"dy","maxPoolGrad"),c=Lm(t,"input","maxPoolGrad"),l=Lm(n,"output","maxPoolGrad");bu(c.rank===o.rank,()=>"Rank of input (".concat(c.rank,") does not match rank of dy ")+"(".concat(o.rank,")")),bu(4===o.rank,()=>"Error in maxPoolGrad: dy must be rank 4 but got rank "+"".concat(o.rank,".")),bu(4===c.rank,()=>"Error in maxPoolGrad: input must be rank 4 but got rank "+"".concat(c.rank,".")),tx("maxPoolGrad",r,i);const u={dy:o,input:c,output:l},h={filterSize:a,strides:s,pad:r,dimRoundingMode:i};return Em.runKernel(jd,u,h)}}),hN={kernelName:Bd,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[a,s]=t,{filterSize:r,strides:i,pad:o}=n;return{x:()=>uN(e,a,s,r,i,o)}}},dN={kernelName:Kd,inputsToSave:["x"],gradFunc:(e,t,n)=>{const a=t[0],{paddings:s}=n,r=s.map(e=>e[0]);return{x:()=>cx(e,r,a.shape)}}},pN={kernelName:sp,saveAllInputs:!0,gradFunc:(e,t,n)=>{const{axis:a}=n;return vk(e,a).map(e=>()=>e)}},fN={kernelName:rp,inputsToSave:["x"],gradFunc:(e,t,n)=>{const a=t[0],{paddings:s}=n,r=s.map(e=>e[0]);return{x:()=>cx(e,r,a.shape)}}},mN={kernelName:ip,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{const[n,a,s]=t,r=n,i=a,o=_y(r.shape,i.shape);return{a:()=>{const t=ay(i,"float32");let n=ly(e,ly(t,Cy(r,Iy(t,fy(1)))));const a=Ry(r.shape,o);return a.length>0&&(n=iv(n,a)),nx(n,r.shape)},b:()=>{const t=yv(r,0),n=Ux(t,Ev(r),dy(r));let a=ly(e,ly(s,n));const c=Ry(i.shape,o);return c.length>0&&(a=iv(a,c)),nx(a,i.shape)}}}},gN={kernelName:op,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{const[n,a]=t,s=yv(n,0);return{x:()=>Ux(s,e,ly(e,a)),alpha:()=>{let t=Ux(s,dy(e),ly(e,n));const r=Ry(a.shape,e.shape);return r.length>0&&(t=iv(t,r)),nx(t,a.shape)}}}};function yN(e,t,n){const a=e.shape.length,s=a-n.length,r=tv(n,a);let i=e;null!=r&&(i=Nk(e,r));const o=i.shape.slice(),c=o.splice(a-n.length,n.length).reduce((e,t)=>e*t,1);o.push(c);let l=function(e,t,n){const a=e.shape.slice();a[n]=1;const s=nx(t,a),r=Ox(e,n,!0,!1),i=Ox(e,n,!0,!0),o=ly(r,i);return ly(s,o)}(i.reshape(o),t,s);if(l=l.reshape(i.shape),null!=r){const e=nv(r);l=Nk(l,e)}return l}const bN={kernelName:Rp,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=yv(n,fy(0)),a=fy(fC),s=fy(mC),r=ly(e,s),i=ly(ly(e,a),uv(ay(n,"float32")));return Ux(t,r,i)}}}},xN={kernelName:zp,gradFunc:(e,t,n)=>{const{blockShape:a,paddings:s}=n;return{x:()=>hx(e,a,s)}}},vN={kernelName:Bp,gradFunc:(e,t,n)=>{const{axis:a}=n;return{x:()=>rx(e,a)}}},wN={kernelName:nf,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{reps:s}=n;return{x:()=>{let t=dy(a);if(1===a.rank)for(let n=0;n<s[0];++n)t=iy(t,cx(e,[n*a.shape[0]],[a.shape[0]]));else if(2===a.rank)for(let n=0;n<s[0];++n)for(let r=0;r<s[1];++r)t=iy(t,cx(e,[n*a.shape[0],r*a.shape[1]],[a.shape[0],a.shape[1]]));else if(3===a.rank)for(let n=0;n<s[0];++n)for(let r=0;r<s[1];++r)for(let i=0;i<s[2];++i)t=iy(t,cx(e,[n*a.shape[0],r*a.shape[1],i*a.shape[2]],[a.shape[0],a.shape[1],a.shape[2]]));else{if(4!==a.rank)throw new Error("Gradient for tile operation is not implemented for rank-"+"".concat(a.rank," tensors yet."));for(let n=0;n<s[0];++n)for(let r=0;r<s[1];++r)for(let i=0;i<s[2];++i)for(let o=0;o<s[3];++o)t=iy(t,cx(e,[n*a.shape[0],r*a.shape[1],i*a.shape[2],o*a.shape[3]],[a.shape[0],a.shape[1],a.shape[2],a.shape[3]]))}return t}}}};const kN=[sI,rI,iI,oI,cI,lI,uI,hI,dI,pI,fI,mI,yI,xI,vI,wI,kI,SI,CI,II,NI,TI,RI,EI,AI,MI,PI,DI,OI,FI,{kernelName:td,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,s=_y(n.shape,a.shape);return{a:()=>{const t=cy(e,ay(a,"float32")),r=Ry(n.shape,s);return r.length>0?nx(iv(t,r),n.shape):t},b:()=>{let t=ly(e,ay(n,"float32"));const r=Ry(a.shape,s);r.length>0&&(t=nx(iv(t,r),a.shape));const i=hy(a);return _v(cy(t,ay(i,"float32")))}}}},LI,zI,BI,jI,WI,UI,VI,HI,GI,XI,YI,QI,ZI,JI,$I,eN,tN,nN,sN,iN,iN,oN,lN,hN,{kernelName:Hd,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{axis:s}=n,r=Ru(s,a.shape),i=wu(Jx(a.shape,r)[1]);return{x:()=>{const t=a.shape.slice();r.forEach(e=>{t[e]=1});const n=nx(e,t);return cy(ly(n,Kv(a.shape,"float32")),i)}}}},{kernelName:Gd,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const a=n,{axis:s}=a,[r,i]=t,o=rN(e,i,r,Ru(s,r.shape));return{x:()=>o.x()}}},{kernelName:qd,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t;return{a:()=>ly(e,ay(Iv(n,a),"float32")),b:()=>ly(e,ay(yv(n,a),"float32"))}}},dN,{kernelName:Xd,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,s=_y(n.shape,a.shape);return{a:()=>{const t=Ry(n.shape,s);return t.length>0?nx(iv(e,t),n.shape):e},b:()=>{const t=ly(e,_v(mv(cy(n,a)))),r=Ry(a.shape,s);return r.length>0?nx(iv(t,r),a.shape):t}}}},{kernelName:Qd,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,s=_y(n.shape,a.shape);return{a:()=>{const t=ly(e,ay(a,"float32")),r=Ry(n.shape,s);return r.length>0?nx(iv(t,r),n.shape):t},b:()=>{const t=ly(e,ay(n,"float32")),r=Ry(a.shape,s);return r.length>0?nx(iv(t,r),a.shape):t}}}},{kernelName:Zd,gradFunc:e=>({x:()=>_v(e)})},{kernelName:ap,inputsToSave:["indices"],gradFunc:(e,t)=>{const n=t[0];return{indices:()=>qv(n.shape,"float32")}}},{kernelName:np,gradFunc:e=>({x:()=>dy(e)})},pN,fN,fN,mN,gN,{kernelName:cp,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{axis:s}=n;let r=[];return r=void 0===s||null===s?a.shape.map((e,t)=>t):"number"===typeof s?[s]:s,{x:()=>yN(a,e,r)}}},{kernelName:fp,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>cy(e,_v(hy(n)))}}},{kernelName:wp,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,a=ly(Iv(n,6),sk(n));return{x:()=>ly(e,ay(a,"float32"))}}},{kernelName:mp,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ly(e,ay(sk(n),"float32"))}}},{kernelName:gp,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>nx(e,n.shape)}}},{kernelName:xp,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[a]=t,s={dy:e,images:a};return{images:()=>Em.runKernel(vp,s,n)}}},{kernelName:yp,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[a]=t,s={dy:e,images:a};return{images:()=>Em.runKernel(bp,s,n)}}},{kernelName:kp,gradFunc:(e,t,n)=>{const{dims:a}=n,s=Ru(a,e.shape);return{x:()=>Mw(e,s)}}},{kernelName:Sp,gradFunc:e=>({x:()=>dy(e)})},{kernelName:Cp,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>_v(cy(e,ly(Cy(n,1.5),2)))}}},{kernelName:Ep,inputsToSave:["condition"],gradFunc:(e,t)=>{const[n]=t;return{condition:()=>ay(dy(n),"float32"),t:()=>ly(e,ay(n,e.dtype)),e:()=>ly(e,ay(Fv(n),e.dtype))}}},bN,{kernelName:Dp,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ly(e,ly(n,Iy(fy(1),n)))}}},{kernelName:Pp,gradFunc:e=>({x:()=>dy(e)})},{kernelName:Ap,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ly(Px(ay(n,"float32")),e)}}},{kernelName:Mp,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ly(Dx(ay(n,"float32")),e)}}},{kernelName:_p,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{begin:s,size:r}=n,i=a.shape,[o,c]=Nb(a,s,r),l=[];for(let u=0;u<e.rank;u++)l.push([o[u],i[u]-o[u]-c[u]]);return{x:()=>rw(e,l)}}},{kernelName:jp,outputsToSave:[!0],gradFunc:(e,t,n)=>{const[a]=t,{dim:s}=n,r=ly(e,a);return{logits:()=>Iy(r,ly(iv(r,[s],true),a))}}},{kernelName:Op,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ly(e,ox(n))}}},xN,xN,vN,vN,{kernelName:Fp,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>cy(e,ly(uy(ay(n,"float32")),2))}}},{kernelName:qp,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,s=fy(2);return{a:()=>ly(e,ly(s,Iy(n,a))),b:()=>ly(e,ly(s,Iy(a,n)))}}},{kernelName:Kp,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ly(e,ly(ay(n,"float32"),2))}}},{kernelName:hf,gradFunc:e=>({x:()=>dy(e)})},{kernelName:$p,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,s=_y(n.shape,a.shape);return{a:()=>{let t=e;const a=Ry(n.shape,s);return a.length>0&&(t=iv(t,a)),nx(t,n.shape)},b:()=>{let t=e;const n=Ry(a.shape,s);return n.length>0&&(t=iv(t,n)),nx(_v(t),a.shape)}}}},{kernelName:Lp,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,s=a.shape.slice(),{axis:r}=n;Ru(r,a.shape).forEach(e=>{s[e]=1});const i=nx(e,s),o=ly(i,Kv(a.shape,"float32"));return{x:()=>o}}},{kernelName:ef,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>cy(e,hy(Px(n)))}}},{kernelName:tf,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ly(Iy(fy(1),hy(n)),e)}}},wN,{kernelName:rf,gradFunc:(e,t,n)=>{const a=n,{perm:s}=a,r=nv(s);return{x:()=>Nk(e,r)}}},{kernelName:cf,gradFunc:(e,t,n)=>{const a=n,{axis:s}=a;return{value:()=>ak(e,s)}}},{kernelName:lf,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>function(e,t){const n=Ay(t,dy(t)),a=gv(e,n);let s=bv(t,fy(0,"int32"));const r=a.rank-s.rank;for(let o=0;o<r;++o)s=hv(s,o+1);s=Ov(s,Kv(a.shape,"bool"));const i=dy(a);return Ux(s,a,i)}(e,n)}}},{kernelName:uf,gradFunc:e=>({x:()=>dy(e)})}];for(const n of kN)If(n);cm().prototype.abs=function(){return this.throwIfDisposed(),Ty(this)},cm().prototype.acos=function(){return this.throwIfDisposed(),Rb(this)},cm().prototype.acosh=function(){return this.throwIfDisposed(),_b(this)},cm().prototype.add=function(e){return this.throwIfDisposed(),iy(this,e)},cm().prototype.all=function(e,t){return this.throwIfDisposed(),Mb(this,e,t)},cm().prototype.any=function(e,t){return this.throwIfDisposed(),Pb(this,e,t)},cm().prototype.argMax=function(e){return this.throwIfDisposed(),Db(this,e)},cm().prototype.argMin=function(e){return this.throwIfDisposed(),Ob(this,e)},cm().prototype.asScalar=function(){return this.throwIfDisposed(),bu(1===this.size,()=>"The array must have only 1 element."),nx(this,[])},cm().prototype.asType=function(e){return this.throwIfDisposed(),ay(this,e)},cm().prototype.as1D=function(){return this.throwIfDisposed(),nx(this,[this.size])},cm().prototype.as2D=function(e,t){return this.throwIfDisposed(),nx(this,[e,t])},cm().prototype.as3D=function(e,t,n){return this.throwIfDisposed(),nx(this,[e,t,n])},cm().prototype.as4D=function(e,t,n,a){return this.throwIfDisposed(),nx(this,[e,t,n,a])},cm().prototype.as5D=function(e,t,n,a,s){return this.throwIfDisposed(),nx(this,[e,t,n,a,s])},cm().prototype.asin=function(){return this.throwIfDisposed(),Fb(this)},cm().prototype.asinh=function(){return this.throwIfDisposed(),Lb(this)},cm().prototype.atan=function(){return this.throwIfDisposed(),zb(this)},cm().prototype.atan2=function(e){return this.throwIfDisposed(),Bb(this,e)},cm().prototype.atanh=function(){return this.throwIfDisposed(),jb(this)},cm().prototype.avgPool=function(e,t,n,a){return this.throwIfDisposed(),ax(this,e,t,n,a)},cm().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),hx(this,e,t)},cm().prototype.batchNorm=function(e,t,n,a,s){return this.throwIfDisposed(),dx(this,e,t,n,a,s)},cm().prototype.broadcastTo=function(e){return this.throwIfDisposed(),xx(this,e)},cm().prototype.cast=function(e){return this.throwIfDisposed(),ay(this,e)},cm().prototype.ceil=function(){return this.throwIfDisposed(),vx(this)},cm().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),wx(this,e,t)},cm().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof om&&(e=[e]),rx([this,...e],t)},cm().prototype.conv1d=function(e,t,n,a,s,r){return this.throwIfDisposed(),Tx(this,e,t,n,a,s,r)},cm().prototype.conv2dTranspose=function(e,t,n,a,s){return this.throwIfDisposed(),Rx(this,e,t,n,a,s)},cm().prototype.conv2d=function(e,t,n,a,s,r){return this.throwIfDisposed(),Nx(this,e,t,n,a,s,r)},cm().prototype.cos=function(){return this.throwIfDisposed(),Px(this)},cm().prototype.cosh=function(){return this.throwIfDisposed(),Dx(this)},cm().prototype.cumprod=function(e,t,n){return this.throwIfDisposed(),Ox(this,e,t,n)},cm().prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),Fx(this,e,t,n)},cm().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),zx(this,e,t)},cm().prototype.depthwiseConv2d=function(e,t,n,a,s,r){return this.throwIfDisposed(),Bx(this,e,t,n,a,s,r)},cm().prototype.dilation2d=function(e,t,n,a,s){return this.throwIfDisposed(),Wx(this,e,t,n,a,s)},cm().prototype.divNoNan=function(e){return this.throwIfDisposed(),Hx(this,e)},cm().prototype.div=function(e){return this.throwIfDisposed(),cy(this,e)},cm().prototype.dot=function(e){return this.throwIfDisposed(),Gx(this,e)},cm().prototype.elu=function(){return this.throwIfDisposed(),Kx(this)},cm().prototype.equal=function(e){return this.throwIfDisposed(),Vx(this,e)},cm().prototype.erf=function(){return this.throwIfDisposed(),Yx(this)},cm().prototype.euclideanNorm=function(e,t){return this.throwIfDisposed(),lv(this,e,t)},cm().prototype.exp=function(){return this.throwIfDisposed(),uv(this)},cm().prototype.expandDims=function(e){return this.throwIfDisposed(),hv(this,e)},cm().prototype.expm1=function(){return this.throwIfDisposed(),dv(this)},cm().prototype.fft=function(){return this.throwIfDisposed(),Qw(this)},cm().prototype.flatten=function(){return this.throwIfDisposed(),nx(this,[this.size])},cm().prototype.floor=function(){return this.throwIfDisposed(),mv(this)},cm().prototype.floorDiv=function(e){return this.throwIfDisposed(),oy(this,e)},cm().prototype.gather=function(e,t,n){return this.throwIfDisposed(),gv(this,e,t,n)},cm().prototype.greaterEqual=function(e){return this.throwIfDisposed(),bv(this,e)},cm().prototype.greater=function(e){return this.throwIfDisposed(),yv(this,e)},cm().prototype.ifft=function(){return this.throwIfDisposed(),Zw(this)},cm().prototype.irfft=function(){return this.throwIfDisposed(),Jw(this)},cm().prototype.isFinite=function(){return this.throwIfDisposed(),vv(this)},cm().prototype.isInf=function(){return this.throwIfDisposed(),wv(this)},cm().prototype.isNaN=function(){return this.throwIfDisposed(),kv(this)},cm().prototype.leakyRelu=function(e){return this.throwIfDisposed(),Sv(this,e)},cm().prototype.lessEqual=function(e){return this.throwIfDisposed(),Iv(this,e)},cm().prototype.less=function(e){return this.throwIfDisposed(),Cv(this,e)},cm().prototype.localResponseNormalization=function(e,t,n,a){return this.throwIfDisposed(),Tv(this,e,t,n,a)},cm().prototype.logSigmoid=function(){return this.throwIfDisposed(),Mv(this)},cm().prototype.logSoftmax=function(e){return this.throwIfDisposed(),Pv(this,e)},cm().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),Dv(this,e,t)},cm().prototype.log=function(){return this.throwIfDisposed(),Ev(this)},cm().prototype.log1p=function(){return this.throwIfDisposed(),Rv(this)},cm().prototype.logicalAnd=function(e){return this.throwIfDisposed(),Ov(this,e)},cm().prototype.logicalNot=function(){return this.throwIfDisposed(),Fv(this)},cm().prototype.logicalOr=function(e){return this.throwIfDisposed(),Lv(this,e)},cm().prototype.logicalXor=function(e){return this.throwIfDisposed(),zv(this,e)},cm().prototype.matMul=function(e,t,n){return this.throwIfDisposed(),ix(this,e,t,n)},cm().prototype.maxPool=function(e,t,n,a){return this.throwIfDisposed(),Vv(this,e,t,n,a)},cm().prototype.max=function(e,t){return this.throwIfDisposed(),sv(this,e,t)},cm().prototype.maximum=function(e){return this.throwIfDisposed(),Ay(this,e)},cm().prototype.mean=function(e,t){return this.throwIfDisposed(),Gv(this,e,t)},cm().prototype.min=function(e,t){return this.throwIfDisposed(),rv(this,e,t)},cm().prototype.minimum=function(e){return this.throwIfDisposed(),Yv(this,e)},cm().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),Qv(this,e,t)},cm().prototype.mod=function(e){return this.throwIfDisposed(),Zv(this,e)},cm().prototype.mul=function(e){return this.throwIfDisposed(),ly(this,e)},cm().prototype.neg=function(){return this.throwIfDisposed(),_v(this)},cm().prototype.norm=function(e,t,n){return this.throwIfDisposed(),cv(this,e,t,n)},cm().prototype.notEqual=function(e){return this.throwIfDisposed(),tw(this,e)},cm().prototype.oneHot=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return this.throwIfDisposed(),nw(this,e,t,n)},cm().prototype.onesLike=function(){return this.throwIfDisposed(),aw(this)},cm().prototype.pad=function(e,t){return this.throwIfDisposed(),rw(this,e,t)},cm().prototype.pool=function(e,t,n,a,s,r){return this.throwIfDisposed(),hw(this,e,t,n,a,s,r)},cm().prototype.pow=function(e){return this.throwIfDisposed(),Cy(this,e)},cm().prototype.prelu=function(e){return this.throwIfDisposed(),dw(this,e)},cm().prototype.prod=function(e,t){return this.throwIfDisposed(),pw(this,e,t)},cm().prototype.reciprocal=function(){return this.throwIfDisposed(),Rw(this)},cm().prototype.relu=function(){return this.throwIfDisposed(),_w(this)},cm().prototype.relu6=function(){return this.throwIfDisposed(),Aw(this)},cm().prototype.reshapeAs=function(e){return this.throwIfDisposed(),nx(this,e.shape)},cm().prototype.reshape=function(e){return this.throwIfDisposed(),nx(this,e)},cm().prototype.resizeBilinear=function(e,t,n){return this.throwIfDisposed(),gS(this,e,t,n)},cm().prototype.resizeNearestNeighbor=function(e,t,n){return this.throwIfDisposed(),yS(this,e,t,n)},cm().prototype.reverse=function(e){return this.throwIfDisposed(),Mw(this,e)},cm().prototype.rfft=function(){return this.throwIfDisposed(),ek(this)},cm().prototype.round=function(){return this.throwIfDisposed(),Lw(this)},cm().prototype.rsqrt=function(){return this.throwIfDisposed(),zw(this)},cm().prototype.selu=function(){return this.throwIfDisposed(),Bw(this)},cm().prototype.separableConv2d=function(e,t,n,a,s,r){return this.throwIfDisposed(),jw(this,e,t,n,a,s,r)},cm().prototype.sigmoid=function(){return this.throwIfDisposed(),ox(this)},cm().prototype.sign=function(){return this.throwIfDisposed(),Vw(this)},cm().prototype.sin=function(){return this.throwIfDisposed(),Uw(this)},cm().prototype.sinh=function(){return this.throwIfDisposed(),Hw(this)},cm().prototype.slice=function(e,t){return this.throwIfDisposed(),cx(this,e,t)},cm().prototype.softmax=function(e){return this.throwIfDisposed(),Yw(this,e)},cm().prototype.softplus=function(){return this.throwIfDisposed(),Av(this)},cm().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),uw(this,e,t)},cm().prototype.split=function(e,t){return this.throwIfDisposed(),$w(this,e,t)},cm().prototype.sqrt=function(){return this.throwIfDisposed(),uy(this)},cm().prototype.square=function(){return this.throwIfDisposed(),hy(this)},cm().prototype.squaredDifference=function(e){return this.throwIfDisposed(),tk(this,e)},cm().prototype.squeeze=function(e){return this.throwIfDisposed(),nk(this,e)},cm().prototype.stack=function(e,t){this.throwIfDisposed();const n=e instanceof om?[this,e]:[this,...e];return ak(n,t)},cm().prototype.step=function(e){return this.throwIfDisposed(),sk(this,e)},cm().prototype.stridedSlice=function(e,t,n,a,s,r,i,o){return this.throwIfDisposed(),rk(this,e,t,n,a,s,r,i,o)},cm().prototype.sub=function(e){return this.throwIfDisposed(),Iy(this,e)},cm().prototype.sum=function(e,t){return this.throwIfDisposed(),iv(this,e,t)},cm().prototype.tan=function(){return this.throwIfDisposed(),ik(this)},cm().prototype.tanh=function(){return this.throwIfDisposed(),lx(this)},cm().prototype.tile=function(e){return this.throwIfDisposed(),pv(this,e)},cm().prototype.toBool=function(){return this.throwIfDisposed(),ay(this,"bool")},cm().prototype.toFloat=function(){return this.throwIfDisposed(),ay(this,"float32")},cm().prototype.toInt=function(){return this.throwIfDisposed(),ay(this,"int32")},cm().prototype.topk=function(e,t){return this.throwIfDisposed(),gk(this,e,t)},cm().prototype.transpose=function(e){return this.throwIfDisposed(),Nk(this,e)},cm().prototype.unique=function(e){return this.throwIfDisposed(),bk(this,e)},cm().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),xk(this,e,t)},cm().prototype.unstack=function(e){return this.throwIfDisposed(),vk(this,e)},cm().prototype.where=function(e,t){return this.throwIfDisposed(),Ux(e,this,t)},cm().prototype.zerosLike=function(){return this.throwIfDisposed(),dy(this)};class SN extends Error{constructor(e){super(e),Object.setPrototypeOf(this,SN.prototype)}}class CN extends Error{constructor(e){super(e),Object.setPrototypeOf(this,CN.prototype)}}class IN extends Error{constructor(e){super(e),Object.setPrototypeOf(this,IN.prototype)}}class NN extends Error{constructor(e){super(e),Object.setPrototypeOf(this,NN.prototype)}}class TN extends Error{constructor(e){super(e),Object.setPrototypeOf(this,TN.prototype)}}Error;class EN{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){const e=this.cache.keys().next().value;this.cache.delete(e)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error("The maxEntries of LRU caches must be at least 0, but got ".concat(e,"."));if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){const e=this.cache.keys().next().value;this.cache.delete(e)}this.maxEntries=e}}function RN(e,t){if(Array.isArray(e)){let n=[];for(let a=0;a<t;a++)n=n.concat(e);return n}{const n=new Array(t);return n.fill(e),n}}function _N(e,t){if(!e)throw new TN(t)}function AN(e,t){let n=0;for(const a of e)a===t&&n++;return n}function MN(e){return 1===e.length?e[0]:e}function PN(e){return Array.isArray(e)?e:[e]}function DN(e){const t=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==t[0]?t:"private"+t}function ON(e){return e.length<=1||-1===e.indexOf("_")?e:e.replace(/[_]+(\w|$)/g,(e,t)=>t.toUpperCase())}let FN={};function LN(e){if(null===e||void 0===e)return null;const t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function zN(e){if(null!=e&&"object"===typeof e)if(Array.isArray(e))e.forEach(e=>zN(e));else{const t=Object.keys(e);for(const n of t){const t=e[n];null!=t&&"object"===typeof t&&(Array.isArray(t)||"ndarray"!==t.type||"number"!==typeof t.value?zN(t):e[n]=t.value)}}}function BN(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"object",s=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if("string"===typeof e){const s=e;let r;if(s in n)r=n[s];else if(s in FN)r=FN[s];else if(r=t[s],null==r)throw new IN("Unknown ".concat(a,": ").concat(e,". ")+"This may be due to one of the following reasons:\n"+"1. The ".concat(a," is defined in Python, in which ")+"case it needs to be ported to TensorFlow.js or your JavaScript code.\n"+"2. The custom ".concat(a," is defined in JavaScript, ")+"but is not registered properly with tf.serialization.registerClass().");return r}{const r=e;if(null==r.className||null==r.config)throw new IN("".concat(a,": Improper config format: ")+"".concat(JSON.stringify(r),".\n")+"'className' and 'config' must set.");const i=r.className;let o,c;if(i in n?[o,c]=n[i]:i in FN?[o,c]=FN.className:i in t&&([o,c]=t[i]),null==o)throw new IN("Unknown ".concat(a,": ").concat(i,". ")+"This may be due to one of the following reasons:\n"+"1. The ".concat(a," is defined in Python, in which ")+"case it needs to be ported to TensorFlow.js or your JavaScript code.\n"+"2. The custom ".concat(a," is defined in JavaScript, ")+"but is not registered properly with tf.serialization.registerClass().");if(null!=c){const e={};for(const n of Object.keys(FN))e[n]=FN[n];for(const s of Object.keys(n))e[s]=n[s];r.config.customObjects=e;const t=Object.assign({},FN);for(const s of Object.keys(n))FN[s]=n[s];zN(r.config);const a=c(o,r.config,n,s);return FN=Object.assign({},t),a}{const e=Object.assign({},FN);for(const a of Object.keys(n))FN[a]=n[a];const t=new o(r.config);return FN=Object.assign({},e),t}}}function jN(e,t){return-1*function(e,t){return e<t?-1:e>t?1:0}(e,t)}function WN(e){if(null==e)return e;const t=[];for(const n of e)-1===t.indexOf(n)&&t.push(n);return t}function VN(e){if(null==e)throw new IN("Invalid value in obj: ".concat(JSON.stringify(e)));for(const t in e)if(e.hasOwnProperty(t))return!1;return!0}function UN(e,t,n){if(null!=n&&e.indexOf(n)<0)throw new IN("".concat(n," is not a valid ").concat(t,".  Valid values are ").concat(e," or null/undefined."))}function HN(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1/0;return _N(n>=0),_N(a>=n),Array.isArray(e)&&e.length>=n&&e.length<=a&&e.every(e=>typeof e===t)}function GN(e,t){Array.isArray(e)?(bu(e.length>0,()=>"".concat(t," is unexpectedly an empty array.")),e.forEach((e,n)=>GN(e,"element ".concat(n+1," of ").concat(t)))):bu(Number.isInteger(e)&&e>0,()=>"Expected ".concat(t," to be a positive integer, but got ")+"".concat(qN(e),"."))}function qN(e){return null===e?"null":Array.isArray(e)?"["+e.map(e=>qN(e)).join(",")+"]":"string"===typeof e?'"'.concat(e,'"'):"".concat(e)}function KN(e){return"relu"===e?"relu":"linear"===e?"linear":"elu"===e?"elu":null}let XN=0;function YN(){return XN++}const QN={};function ZN(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return e in QN||(QN[e]=0),QN[e]+=1,e+QN[e].toString()}const JN=["channelsFirst","channelsLast"],$N=["nearest","bilinear"],eT=["valid","same","causal"],tT=["max","avg"],nT=["sum","mul","concat","ave"],aT=new Map;function sT(e){UN(JN,"DataFormat",e)}function rT(e){UN(eT,"PaddingMode",e)}function iT(e){UN(tT,"PoolMode",e)}const oT=[];function cT(e,t){oT.push(e);try{const e=t();return oT.pop(),e}catch(q5){throw oT.pop(),q5}}function lT(e){if(!dT(e))throw new Error("Not a valid tensor name: '"+e+"'");return(0===oT.length?"":oT.join("/")+"/")+e}function uT(e){if(!dT(e))throw new Error("Not a valid tensor name: '"+e+"'");aT.has(e)||aT.set(e,0);const t=aT.get(e);if(aT.set(e,aT.get(e)+1),t>0){const n="".concat(e,"_").concat(t);return aT.set(n,1),n}return e}const hT=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function dT(e){return!!e.match(hT)}function pT(e){return e===parseInt(e.toString(),10)}function fT(e,t,n){null==t&&(t=0),null==n&&(n=e.length);let a=1;for(let s=t;s<n;++s)a*=e[s];return a}function mT(e){if(0===e.length)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let n=0;n<e.length;n++){const a=e[n];a<t&&(t=a)}return t}function gT(e){if(0===e.length)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let n=0;n<e.length;n++){const a=e[n];a>t&&(t=a)}return t}function yT(e,t){if(t<e)throw new IN("end (".concat(t,") < begin (").concat(e,") is forbidden."));const n=[];for(let a=e;a<t;++a)n.push(a);return n}let bT;function xT(){return null==bT&&(bT=$m().epsilon()),bT}function vT(e,t){return ay(e,t)}function wT(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),nx(e,n)}function kT(e,t,n){return Xm(()=>{switch(e.rank){case 1:return Gw(e,t,n);case 2:return qw(e,[t,0],[n,e.shape[1]]);case 3:return Kw(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return Xw(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return cx(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return cx(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new IN("sliceAlongFirstAxis() received an unsupported tensor rank: "+"".concat(e.rank))}})}function ST(e,t,n){return Xm(()=>{switch(e.rank){case 1:return Gw(e,t,n);case 2:return qw(e,[0,t],[e.shape[0],n]);case 3:return Kw(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return Xw(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new IN("sliceAlongLastAxis() received an unsupported tensor rank: "+"".concat(e.rank))}})}function CT(e,t,n,a){return Xm(()=>{switch(e.rank){case 1:return Gw(e,t,n);case 2:switch(a){case 1:return kT(e,t,n);case 2:return ST(e,t,n);default:throw new IN("The axis is not within the rank of the tensor "+"".concat(a))}case 3:switch(a){case 1:return kT(e,t,n);case 2:return Kw(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return ST(e,t,n);default:throw new IN("The axis is not within the rank of the tensor "+"".concat(a))}case 4:switch(a){case 1:return kT(e,t,n);case 2:return Xw(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return Xw(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return ST(e,t,n);default:throw new IN("The axis is not within the rank of the tensor "+"".concat(a))}default:throw new IN("sliceAlongLastAxis() received an unsupported tensor rank: "+"".concat(e.rank))}})}function IT(e){let t,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;return n<0&&(t=e[0].rank,n=0!==t?t:0),n===e[0].rank&&(n=-1),rx(e,n)}function NT(e,t){switch(e.rank){case 1:return kx([e,t]);case 2:return Sx([e,t],0);case 3:return Cx([e,t],0);case 4:return Ix([e,t],0);default:throw new IN("concatAlongFirstAxis() received an unsupported "+"tensor rank: ".concat(e.rank))}}function TT(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new IN("The length of input n (".concat(t.length,") does not match ")+"the number of dimensions in input x (".concat(e.rank,")"));return pv(e,t)}function ET(e){return Sw(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,arguments.length>3?arguments[3]:void 0,arguments.length>4?arguments[4]:void 0)}function RT(e,t,n,a){if(e.rank<2||t.rank<2)throw new NN("dot requires both inputs to be rank >= 2"+" but got x shape = ".concat(e.shape," and y shape = ").concat(t.shape));if(t.rank>=3){if(e.shape.slice(-1)[0]!==t.shape.slice(-2)[0])throw new NN("If rank y >= 3, then the second last dim"+" of y must equal the last dim of x but got x shape = ".concat(e.shape," and ")+" y shape = ".concat(t.shape))}if(2===e.rank&&2===t.rank){return Hk({a:e,b:t,transposeA:!1,transposeB:!1,bias:a?MT(e.rank,a,"channelsLast"):null,activation:n})}{const s=e.shape.slice(),r=s.pop();e=nx(e,[-1,r]);const i=t.shape.slice(),o=i.pop(),c=i.pop(),l=[...i,o],u=Array.from({length:t.rank},(e,n)=>0===n?t.rank-2:n<=t.rank-2?n-1:n);t=nx(Nk(t,u),[c,-1]);const h=[...s,...l];return nx(Hk({a:e,b:t,transposeA:!1,transposeB:!1,bias:a?MT(e.rank,a,"channelsLast"):null,activation:n}),h)}}function _T(e,t,n){return Xm(()=>(t=Array.isArray(t)?ok(t,"int32"):ay(t,"int32"),gv(e,t,n)))}function AT(e){return ly(e,e)}function MT(e,t,n){const a=t.shape;if(1!==t.rank&&t.rank!==e)throw new IN("Unexpected bias dimensions: ".concat(t.rank)+"; expected it to be 1 or ".concat(e));if(5===e){if("channelsFirst"===n)return 1===a.length?nx(t,[1,a[0],1,1,1]):nx(t,[1,a[3],a[0],a[1],a[2]]);if("channelsLast"===n)return 1===a.length?nx(t,[1,1,1,1,a[0]]):nx(t,[1].concat(a))}else if(4===e){if("channelsFirst"===n)return 1===a.length?nx(t,[1,a[0],1,1]):nx(t,[1,a[2],a[0],a[1]]);if("channelsLast"===n)return 1===a.length?nx(t,[1,1,1,a[0]]):nx(t,[1].concat(a))}else if(3===e){if("channelsFirst"===n)return 1===a.length?nx(t,[1,a[0],1]):nx(t,[1,a[1],a[0]]);if("channelsLast"===n)return 1===a.length?nx(t,[1,1,a[0]]):nx(t,[1].concat(a))}else if(e<3)return t;throw new IN("Unsupported input rank by biasAdd: ".concat(t.rank))}function PT(e,t,n){return Xm(()=>(null==n&&(n="channelsLast"),sT(n),iy(e,MT(e.rank,t,n))))}function DT(e,t,n,a){return Xm(()=>Ak(e,t,n,a))}function OT(e,t){return arguments.length>2&&void 0!==arguments[2]&&arguments[2]?e():t()}const FT=["fanIn","fanOut","fanAvg"],LT=["normal","uniform","truncatedNormal"];class zT extends yy{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class BT extends zT{apply(e,t){return qv(e,t)}}BT.className="Zeros",xy(BT);class jT extends zT{apply(e,t){return Kv(e,t)}}jT.className="Ones",xy(jT);class WT extends zT{constructor(e){if(super(),"object"!==typeof e)throw new IN("Expected argument of type ConstantConfig but got ".concat(e));if(void 0===e.value)throw new IN("config must have value set but got ".concat(e));this.value=e.value}apply(e,t){return Xm(()=>ly(fy(this.value),Kv(e,t)))}getConfig(){return{value:this.value}}}WT.className="Constant",xy(WT);class VT extends zT{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return Iw(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}VT.className="RandomUniform",xy(VT);class UT extends zT{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new NN("randomNormal does not support dType ".concat(t,"."));return ET(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}UT.className="RandomNormal",xy(UT);class HT extends zT{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new NN("truncatedNormal does not support dType ".concat(t,"."));return yk(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}HT.className="TruncatedNormal",xy(HT);class GT extends zT{constructor(e){super(),this.gain=null!=e.gain?e.gain:1}apply(e,t){return Xm(()=>{if(2!==e.length||e[0]!==e[1])throw new IN("Identity matrix initializer can only be used for 2D square matrices.");return ly(this.gain,fv(e[0]))})}getConfig(){return{gain:this.gain}}}GT.className="Identity",xy(GT);class qT extends zT{constructor(e){if(super(),e.scale<0)throw new IN("scale must be a positive float. Got: ".concat(e.scale));var t;this.scale=null==e.scale?1:e.scale,this.mode=null==e.mode?"fanIn":e.mode,t=this.mode,UN(FT,"FanMode",t),this.distribution=null==e.distribution?"normal":e.distribution,function(e){UN(LT,"Distribution",e)}(this.distribution),this.seed=e.seed}apply(e,t){const n=function(e){let t,n,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"channelsLast";if(sT(a),2===e.length)t=e[0],n=e[1];else if(-1!==[3,4,5].indexOf(e.length)){if("channelsFirst"===a){const a=fT(e,2);t=e[1]*a,n=e[0]*a}else if("channelsLast"===a){const a=fT(e,0,e.length-2);t=e[e.length-2]*a,n=e[e.length-1]*a}}else{const a=fT(e);t=Math.sqrt(a),n=Math.sqrt(a)}return[t,n]}(e),a=n[0],s=n[1];let r=this.scale;if("fanIn"===this.mode?r/=Math.max(1,a):"fanOut"===this.mode?r/=Math.max(1,s):r/=Math.max(1,(a+s)/2),"normal"===this.distribution){const n=Math.sqrt(r);if("float32"!==(t=t||"float32")&&"int32"!==t)throw new NN("".concat(this.getClassName()," does not support dType ").concat(t,"."));return yk(e,0,n,t,this.seed)}{const n=Math.sqrt(3*r);return Iw(e,-n,n,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}qT.className="VarianceScaling",xy(qT);class KT extends qT{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return qT.className}}KT.className="GlorotUniform",xy(KT);class XT extends qT{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return qT.className}}XT.className="GlorotNormal",xy(XT);class YT extends qT{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return qT.className}}YT.className="HeNormal",xy(YT);class QT extends qT{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return qT.className}}QT.className="HeUniform",xy(QT);class ZT extends qT{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return qT.className}}ZT.className="LeCunNormal",xy(ZT);class JT extends qT{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return qT.className}}JT.className="LeCunUniform",xy(JT);class $T extends zT{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=null==e.gain?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return Xm(()=>{if(e.length<2)throw new NN("Shape must be at least 2D.");if("int32"!==t&&"float32"!==t&&void 0!==t)throw new TypeError("Unsupported data type ".concat(t,"."));const n=wu(e.slice(0,-1)),a=e[e.length-1],s=n*a;s>this.ELEMENTS_WARN_SLOW&&console.warn("Orthogonal initializer is being called on a matrix with more "+"than ".concat(this.ELEMENTS_WARN_SLOW," (").concat(s,") elements: ")+"Slowness may result.");const r=ET([Math.max(a,n),Math.min(a,n)],0,1,t,this.seed),i=GS.qr(r,!1);let o=i[0];const c=i[1].flatten().stridedSlice([0],[Math.min(a,n)*Math.min(a,n)],[Math.min(a,n)+1]);return o=ly(o,c.sign()),n<a&&(o=o.transpose()),ly(fy(this.gain),o.reshape(e))})}getConfig(){return{gain:this.gain,seed:this.seed}}}$T.className="Orthogonal",xy($T);const eE={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function tE(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return BN(e,by.getMap().classNameMap,t,"initializer")}function nE(e){return LN(e)}function aE(e){if("string"===typeof e){const t=e in eE?eE[e]:e;if("GlorotNormal"===t)return new XT;if("GlorotUniform"===t)return new KT;if("HeNormal"===t)return new YT;if("HeUniform"===t)return new QT;if("LeCunNormal"===t)return new ZT;if("LeCunUniform"===t)return new JT;{const e={};return e.className=t,e.config={},tE(e)}}return e instanceof zT?e:tE(e)}function sE(e){return Array.isArray(e)&&Array.isArray(e[0])}function rE(e){return 0===e.length?[]:Array.isArray(e[0])?e:[e]}function iE(e){let t;if(Array.isArray(e)){if(1!==e.length)throw new IN("Expected Tensor length to be 1; got ".concat(e.length));t=e[0]}else t=e;return t}function oE(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(1===e.length)return e[0];throw new IN("Expected exactly 1 Shape; got ".concat(e.length))}return e}function cE(e){let t=0;for(const n of e)0===n.shape.length?t+=1:t+=n.shape.reduce((e,t)=>e*t);return t}const lE="Variable";class uE{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:lE,a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this.dtype=null==t?"float32":t,this.shape=e.shape,this.id=YN(),n=null==n?lE:n,this.originalName=lT(n),this.name=uT(this.originalName),this.trainable_=a,this.constraint=s,this.val=kk(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),function(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}(this.val,e),this.val.id!==e.id&&(this.val.assign(e),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error("LayersVariable ".concat(this.name," is already disposed."))}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function hE(e){return e.map(e=>e.read())}function dE(e){e.forEach(e=>{e[0].write(e[1])})}class pE{constructor(e){this.dtype=e.dtype,this.shape=e.shape,null!=e.shape?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}class fE{constructor(e,t,n,a,s,r,i){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=a,this.callArgs=s,this.outputTensorIndex=i,this.id=YN(),null!=r&&(this.originalName=lT(r),this.name=uT(this.originalName)),this.rank=t.length}}let mE=0;class gE{constructor(e,t){this.callArgs=t,this.id=mE++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const n of e.inboundLayers)null!=n&&n.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const t of this.inboundLayers)null!=t?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let yE=0;class bE extends yy{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=yE++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){const e=this.getClassName();t=DN(e)+"_"+ZN(e)}if(this.name=t,this.trainable_=null==e.trainable||e.trainable,null!=e.inputShape||null!=e.batchInputShape){let t;if(null!=e.batchInputShape)t=e.batchInputShape;else if(null!=e.inputShape){let n=null;null!=e.batchSize&&(n=e.batchSize),t=[n].concat(e.inputShape)}this.batchInputShape=t;let n=e.dtype;null==n&&(n=e.inputDType),null==n&&(n="float32"),this.dtype=n}null!=e.weights?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(0===this.inboundNodes.length)throw new CN("The layer has never been called "+"and thus has no defined ".concat(t,"."));if(this.inboundNodes.length<=e)throw new IN("Asked to get ".concat(t," at node ").concat(e,", ")+"but the layer has only ".concat(this.inboundNodes.length," inbound nodes."));return this.inboundNodes[e]}getInputAt(e){return MN(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return MN(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new SN("Layer ".concat(this.name)+' has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use `getInputAt(nodeIndex)` instead.');if(0===this.inboundNodes.length)throw new SN("Layer ".concat(this.name)+" is not connected, no input to return.");return MN(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new SN("Layer ".concat(this.name)+" has no inbound nodes.");if(this.inboundNodes.length>1)throw new SN("Layer ".concat(this.name)+' has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use `getOutputAt(nodeIndex)` instead.');return MN(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(t=>t.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){const t=PN(e);if(null==this.inputSpec||0===this.inputSpec.length)return;const n=PN(this.inputSpec);if(t.length!==n.length)throw new IN("Layer ".concat(this.name," expects ").concat(n.length," inputs, ")+"but it received ".concat(t.length," input tensors. ")+"Input received: ".concat(e));for(let a=0;a<t.length;a++){const e=t[a],s=n[a];if(null==s)continue;const r=e.rank;if(null!=s.ndim&&r!==s.ndim)throw new IN("Input ".concat(a," is incompatible with layer ").concat(this.name,": ")+"expected ndim=".concat(s.ndim,", found ndim=").concat(r));if(null!=s.maxNDim&&r>s.maxNDim)throw new IN("Input ".concat(a," is incompatible with layer ").concat(this.name)+": expected max_ndim=".concat(s.maxNDim,", found ndim=").concat(r));if(null!=s.minNDim&&r<s.minNDim)throw new IN("Input ".concat(a," is incompatible with layer ").concat(this.name)+": expected min_ndim=".concat(s.minNDim,", found ndim=").concat(r,"."));if(null!=s.dtype&&e.dtype!==s.dtype)throw new IN("Input ".concat(a," is incompatible with layer ").concat(this.name," ")+": expected dtype=".concat(s.dtype,", found dtype=").concat(e.dtype,"."));if(s.axes){const t=e.shape;for(const e in s.axes){const n=Number(e),r=s.axes[e],i=n>=0?t[n]:t[t.length+n];if(null!=r&&-1===[r,null].indexOf(i))throw new IN("Input ".concat(a," is incompatible with layer ")+"".concat(this.name,": expected axis ").concat(n," of input shape to ")+"have value ".concat(r," but got shape ").concat(t,"."))}}if(null!=s.shape)for(let t=0;t<s.shape.length;++t){const n=s.shape[t],r=e.shape[t];if(null!=n&&null!=r&&n!==r)throw new IN("Input ".concat(a," is incompatible with layer ")+"".concat(this.name,": expected shape=").concat(s.shape,", ")+"found shape=".concat(e.shape,"."))}}}call(e,t){return e}invokeCallHook(e,t){null!=this._callHook&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();const n=PN(e),a=function(e){let t=!0;for(const n of PN(e))if(!(n instanceof fE)){t=!1;break}return t}(e),s=function(e){let t=!0;for(const n of PN(e))if(n instanceof fE){t=!1;break}return t}(e);if(a===s)throw new IN("Arguments to apply() must be all SymbolicTensors or all Tensors");return cT(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);const t=[];for(const n of PN(e))t.push(n.shape);this.build(MN(t)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&s&&(this._refCount=1)}if(this.assertInputCompatibility(e),s){let a=this.call(e,t);this.supportsMasking&&this.setMaskMetadata(e,a);const s=PN(a),r=[];for(let e of s)-1!==n.indexOf(e)&&(e=e.clone()),r.push(e);if(a=MN(r),null!=this.activityRegularizer)throw new NN("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return a}{const n=function(e){e=PN(e);const t=[];for(const n of e)t.push(n.shape);return MN(t)}(e),a=this.computeOutputShape(n);let s;const r="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(e)?n[0]:n),s=null!=a&&a.length>0&&Array.isArray(a[0])?a.map((n,a)=>new fE(r,n,this,PN(e),t,this.name,a)):new fE(r,a,this,PN(e),t,this.name),this.addInboundNode(e,s,null,null,n,a,t),this._refCount++,null!=this.activityRegularizer)throw new NN("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return s}})}warnOnIncompatibleInputShape(e){if(null!=this.batchInputShape)if(e.length!==this.batchInputShape.length)console.warn("The rank of the input tensor provided (shape: "+"".concat(JSON.stringify(e),") does not match that of the ")+"batchInputShape (".concat(JSON.stringify(this.batchInputShape),") ")+"of the layer ".concat(this.name));else{let t=!1;this.batchInputShape.forEach((n,a)=>{null!=n&&null!=e[a]&&e[a]!==n&&(t=!0)}),t&&console.warn("The shape of the input tensor "+"(".concat(JSON.stringify(e),") does not ")+"match the expectation of layer ".concat(this.name,": ")+"".concat(JSON.stringify(this.batchInputShape)))}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new SN("The layer ".concat(this.name," has never been called and thus has no ")+"defined output shape.");const e=[];for(const t of this.inboundNodes){const n=JSON.stringify(t.outputShapes);-1===e.indexOf(n)&&e.push(n)}if(1===e.length){const e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&1===e.length?e[0]:e}throw new SN("The layer ".concat(this.name," has multiple inbound nodes with different ")+'output shapes. Hence the notion of "output shape" is ill-defined for the layer.')}countParams(){if(!this.built)throw new CN("You tried to call countParams() on ".concat(this.name,", ")+"but the layer is not built yet. Build it first by calling build(batchInputShape).");return cE(this.weights)}build(e){this.built=!0}getWeights(){return hE(arguments.length>0&&void 0!==arguments[0]&&arguments[0]?this.trainableWeights:this.weights)}setWeights(e){Xm(()=>{const t=this.weights;if(t.length!==e.length)throw new IN('You called setWeights(weights) on layer "'.concat(this.name,'" ')+"with a weight list of length ".concat(e.length,", ")+"but the layer was expecting ".concat(t.length," weights. ")+"Provided weights: ".concat(e,"..."));if(0===t.length)return;const n=[],a=hE(t);for(let s=0;s<a.length;++s){const r=a[s],i=t[s],o=e[s];if(!Su(r.shape,o.shape))throw new IN("Layer weight shape ".concat(r.shape," ")+"not compatible with provided weight shape ".concat(o.shape));n.push([i,o])}dE(n)})}addWeight(e,t,n,a,s,r,i,o){if(-1!==this._addedWeightNames.indexOf(e))throw new IN("Duplicate weight name ".concat(e," for layer ").concat(this.name));this._addedWeightNames.push(e),null==n&&(n="float32"),this.fastWeightInitDuringBuild&&(a=null!=o?o():aE("zeros"));const c=a.apply(t,n),l=new uE(c,n,e,r,i);return c.dispose(),null!=s&&this.addLoss(()=>s.apply(l.read())),null==r&&(r=!0),r?this._trainableWeights.push(l):this._nonTrainableWeights.push(l),l}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){null==e||Array.isArray(e)&&0===e.length||(e=PN(e),void 0!==this._losses&&null!==this._losses&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(null!=t){if(!Array.isArray(t))throw new TypeError("Layer ".concat(this.name," does not support masking, ")+"but was passed an inputMask.");t.forEach(e=>{if(null!=e)throw new TypeError("Layer ".concat(this.name," does not support masking, ")+"but was passed an inputMask.")})}return null}return t}setMaskMetadata(e,t,n){if(!this.supportsMasking)return;const a=this.computeMask(e,n),s=PN(t),r=PN(a);if(s.length!==r.length)throw new Error("".concat(this.name," outputs ").concat(s.length," tensors ")+"but ".concat(s.length," masks for those tensors"));for(let i=0;i<s.length;i++)s[i].kerasMask=r[i]}addInboundNode(e,t,n,a,s,r){let i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null;const o=PN(e);t=PN(t),n=PN(n),a=PN(a),s=rE(s),r=rE(r);const c=[],l=[],u=[];for(const h of o)c.push(h.sourceLayer),l.push(h.nodeIndex),u.push(h.tensorIndex);new gE({outboundLayer:this,inboundLayers:c,nodeIndices:l,tensorIndices:u,inputTensors:o,outputTensors:t,inputMasks:n,outputMasks:a,inputShapes:s,outputShapes:r},i);for(let h=0;h<t.length;h++)t[h].sourceLayer=this,t[h].nodeIndex=this.inboundNodes.length-1,t[h].tensorIndex=h}getConfig(){const e={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(e.batchInputShape=this.batchInputShape),null!=this.dtype&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error("Layer '".concat(this.name,"' is already disposed."))}dispose(){if(!this.built)throw new Error("Cannot dispose Layer ".concat(this.name," because it has not been ")+"built yet.");if(null===this._refCount)throw new Error("Cannot dispose Layer ".concat(this.name," because it has not been used ")+"yet.");this.assertNotDisposed();let e=0;return 0===--this._refCount&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}}function xE(e,t,n){if((null==t||null!=n&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),0===t.inboundNodes.length)return[e];{const e=t.inboundNodes[n];if(0===e.inboundLayers.length)return e.inputTensors;{const t=[];for(let n=0;n<e.inboundLayers.length;n++){const a=xE(e.inputTensors[n],e.inboundLayers[n],e.nodeIndices[n]);for(const e of a)-1===t.indexOf(e)&&t.push(e)}return t}}}class vE extends bE{constructor(e){if(super({dtype:e.dtype,name:null!=e.name?e.name:ZN("input").toString()}),null==e.batchSize&&(e.batchSize=null),null==e.sparse&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,null!=e.inputShape&&null!=e.batchInputShape)throw new IN("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(null==t){if(null==e.inputShape)throw new IN("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(null!=e.batchSize)throw new IN("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const n=e.dtype||"float32";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];const a=new fE(this.dtype,this.batchInputShape,this,[],{},this.name);a.nodeIndex=0,a.tensorIndex=0,new gE({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[a],outputTensors:[a],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new IN("Cannot pass any input to an "+"InputLayer's apply() method. InputLayer name: ".concat(this.name))}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}vE.className="InputLayer",xy(vE);class wE{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof wE)for(const t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(null==e)return;for(const t of e)this.add(t.key,t.value)}}add(e,t,n){if(null!=this.id2Value[e.id])throw new IN("Duplicate key: name=".concat(e.name,", id=").concat(e.id));return this.id2Value[e.id]=function(e,t){if(null==e.dtype||e.dtype===t.dtype)return t;try{return ay(t,e.dtype)}catch(K5){throw new IN("The dtype of the feed (".concat(t.dtype,") can not be cast to the dtype ")+"of the key '".concat(e.name,"' (").concat(e.dtype,")."))}}(e,t),this.name2Id[e.name]=e.id,null!=n&&(this.id2Mask[e.id]=n),this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return null!=this.id2Value[e.id]}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof fE){if(null==this.id2Value[e.id])throw new IN("Nonexistent key: ".concat(e.name));return this.id2Value[e.id]}{const t=this.name2Id[e];if(null==t)throw new IN("Feed dict has no SymbolicTensor name: ".concat(e));return this.id2Value[t]}}getMask(e){if(e instanceof fE){if(null==this.id2Value[e.id])throw new IN("Nonexistent key: ".concat(e.name));return this.id2Mask[e.id]}{const t=this.name2Id[e];if(null==t)throw new IN("Feed dict has no SymbolicTensor name: ".concat(e));return this.id2Mask[t]}}disposeMasks(){null!=this.id2Mask&&Ym(this.id2Mask)}}const kE=new EN,SE=new EN;function CE(e,t,n,a){const s=null!=n&&n.training,r=Array.isArray(e),i=r?e:[e],o=i.map(e=>e.name),c=[],l=t.names();for(const f of o)-1!==l.indexOf(f)?c.push(t.getValue(f)):c.push(null);null!=a&&(a.maxNumTensors=-1/0,a.minNumTensors=1/0);const u=o.join(",")+"|"+t.names().sort().join(",");let h,d=kE.get(u);if(null==d){const e=function(e,t){bu(null!=e&&e.length>0,()=>"Expected at least one fetch, got none");let n=[],a={};if(1===e.length){const s=NE(e[0],t);n=s.sorted,a=s.recipientMap}else{const s=new Set;for(const r of e){const{sorted:e,recipientMap:i}=NE(r,t);for(const t of e)s.has(t.name)||(n.push(t),s.add(t.name));for(const t in i)null==a[t]&&(a[t]=new Set),i[t].forEach(e=>a[t].add(e))}}return{sorted:n,recipientCounts:IE(a)}}(i,t);d=e.sorted,h=e.recipientCounts,kE.put(u,d),SE.put(u,h)}h={},s||Object.assign(h,SE.get(u));const p=new wE(t);for(let f=0;f<d.length;++f){if(null!=a){const e=Km().numTensors;e>a.maxNumTensors&&(a.maxNumTensors=e),e<a.minNumTensors&&(a.minNumTensors=e)}const e=d[f],r=e.sourceLayer;if(r instanceof vE)continue;const i=[],l=[],u=[];let m=!1;for(const n of e.inputs){const e=p.getValue(n),a=p.getMask(n);i.push(e),l.push(a),null!=a&&(m=!0),s||(h[n.name]--,0!==h[n.name]||t.hasKey(n)||-1!==o.indexOf(n.name)||e.isDisposed||!0===n.sourceLayer.stateful||u.push(e))}m&&((n=n||{}).mask=l[0]);const g=PN(r.apply(i,n));let y=null;r.supportsMasking&&(y=r.computeMask(i,l));const b=TE(e),x=Array.isArray(b)?b:[b];for(let t=0;t<x.length;++t){p.hasKey(x[t])||p.add(x[t],g[t],Array.isArray(y)?y[0]:y);const e=o.indexOf(x[t].name);-1!==e&&(c[e]=g[t])}s||Ym(u)}return p.disposeMasks(),r?c:c[0]}function IE(e){const t={};for(const n in e)t[n]=e[n].size;return t}function NE(e,t){const n=new Set,a=[],s={};for(const o of t.names())n.add(o);const r=[],i=[];for(r.push(e);r.length>0;){const e=r[r.length-1];if(n.has(e.name)){r.pop();continue}const t=i[i.length-1]===r.length-1;if(0===e.inputs.length||t)r.pop(),a.push(e),n.add(e.name),t&&i.pop();else{i.push(r.length-1);for(const t of e.inputs)null==s[t.name]&&(s[t.name]=new Set),s[t.name].add(e.name),n.has(t.name)||r.push(t)}}return{sorted:a,recipientMap:s}}function TE(e){let t;if(1===e.sourceLayer.inboundNodes.length)t=e.sourceLayer.output;else{let n=null;for(let t=0;t<e.sourceLayer.inboundNodes.length;++t)for(const a of e.sourceLayer.inboundNodes[t].outputTensors)if(a.id===e.id){n=t;break}t=e.sourceLayer.getOutputAt(n)}return t}function EE(e,t){return Xm(()=>uy(iv(ly(e,e),t,!0)))}eh().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,function(e){null!=kE&&kE.setMaxEntries(e),null!=SE&&SE.setMaxEntries(e)});class RE extends yy{getConfig(){return{}}}class _E extends RE{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return Xm(()=>{const t=EE(e,this.axis),n=wx(t,0,this.maxValue);return ly(e,cy(n,iy(xT(),t)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}_E.className="MaxNorm",xy(_E);class AE extends RE{constructor(e){super(),this.defaultAxis=0,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return Xm(()=>cy(e,iy(xT(),EE(e,this.axis))))}getConfig(){return{axis:this.axis}}}AE.className="UnitNorm",xy(AE);class ME extends RE{apply(e){return _w(e)}}ME.className="NonNeg",xy(ME);class PE extends RE{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=e.minValue?e.minValue:this.defaultMinValue,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.rate=null!=e.rate?e.rate:this.defaultRate,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return Xm(()=>{const t=EE(e,this.axis),n=iy(ly(this.rate,wx(t,this.minValue,this.maxValue)),ly(1-this.rate,t));return ly(e,cy(n,iy(xT(),t)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}PE.className="MinMaxNorm",xy(PE);const DE={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function OE(e){return LN(e)}function FE(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return BN(e,by.getMap().classNameMap,t,"constraint")}function LE(e){if(null==e)return null;if("string"===typeof e){return FE({className:e in DE?DE[e]:e,config:{}})}return e instanceof RE?e:FE(e)}async function zE(e){if(null==e)return;const t=[],n=[],a=[];for(const s in e){const r=e[s];if("number"!==typeof r){const e=r;t.push(e.data()),n.push(s),a.push(e)}}if(t.length>0){const s=await Promise.all(t);for(let t=0;t<s.length;++t)e[n[t]]=s[t][0];Ym(a)}}function BE(e){if(null!=e)for(const t in e){const n=e[t];"number"!==typeof n&&n.dispose()}}var jE;!function(e){e[e.SILENT=0]="SILENT",e[e.VERBOSE=1]="VERBOSE"}(jE||(jE={}));class WE{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}}class VE{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:10;null==e&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(const t of this.callbacks)t.setParams(e)}setModel(e){for(const t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onEpochBegin(e,t)}async onEpochEnd(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onEpochEnd(e,t)}async onBatchBegin(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onBatchBegin(e,t)}async onBatchEnd(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onBatchEnd(e,t)}async onTrainBegin(e){null==e&&(e={});for(const t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){null==e&&(e={});for(const t of this.callbacks)await t.onTrainEnd(e)}}class UE extends WE{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){null==t&&(t={});const n=null==t.size?0:t.size;this.seen+=n;for(const a in t){const e=t[a];if("number"===typeof e)this.totals.hasOwnProperty(a)||(this.totals[a]=0),this.totals[a]=this.totals[a]+e*n;else{let t;a in this.totals?t=this.totals[a]:this.totals[a]=0;const s=Xm(()=>iy(this.totals[a],ly(e,n)));this.totals[a]=s,null!=t&&t.dispose()}}}async onEpochEnd(e,t){if(null!=t)for(const n of this.params.metrics)null!=this.totals[n]&&("number"===typeof this.totals[n]?t[n]=this.totals[n]/this.seen:Xm(()=>{const e=ly(cy(1,this.seen),this.totals[n]);t[n]=e,this.totals[n].dispose(),Qm(t[n])}))}}class HE extends WE{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){null==t&&(t={}),this.epoch.push(e);for(const n in t)null==this.history[n]&&(this.history[n]=[]),this.history[n].push(t[n])}async syncData(){const e=[],t=[],n=[];for(const s in this.history){const a=this.history[s];for(let r=0;r<a.length;++r)if("number"!==typeof a[r]){const i=a[r];e.push(i.data()),t.push(s),n.push(r)}}const a=await Promise.all(e);for(let s=0;s<a.length;++s){this.history[t[s]][n[s]].dispose(),this.history[t[s]][n[s]]=a[s][0]}}}class GE extends WE{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||ZS,this.yieldEvery=t||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=e.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");Fu(this.yieldEvery)&&(this.maybeWait=function(e,t,n){let a,s=null!=n?n():Hf();return function(){const r=null!=n?n():Hf();return r-s<t||(s=r,a=e(...arguments)),a}}(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,n){const a=[];null!=this.yield&&(await zE(n),a.push(this.yield(e,t,n))),a.push(this.nextFrameFunc()),await Promise.all(a)}async onEpochBegin(e,t){this.currentEpoch=e,null!=this.epochBegin&&(await zE(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){const n=[];null!=this.epochEnd&&(await zE(t),n.push(this.epochEnd(e,t))),"epoch"===this.yieldEvery&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(e,t){null!=this.batchBegin&&(await zE(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){const n=[];null!=this.batchEnd&&(await zE(t),n.push(this.batchEnd(e,t))),"batch"===this.yieldEvery?n.push(this.nextFrameFunc()):Fu(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(n)}async onTrainBegin(e){null!=this.trainBegin&&(await zE(e),await this.trainBegin(e))}async onTrainEnd(e){null!=this.trainEnd&&(await zE(e),await this.trainEnd(e))}}function qE(e,t){if(null==e&&(e={}),e instanceof WE)return[e];if(Array.isArray(e)&&e[0]instanceof WE)return e;return PN(e).map(e=>new GE(e,t))}class KE{constructor(){}static registerCallbackConstructor(e,t){bu(e>=0&&Number.isInteger(e),()=>"Verbosity level is expected to be an integer >= 0, "+"but got ".concat(e)),KE.checkForDuplicate(t),null==KE.constructors[e]&&(KE.constructors[e]=[]),KE.constructors[e].push(t)}static checkForDuplicate(e){for(const t in KE.constructors){KE.constructors[+t].forEach(t=>{if(t===e)throw new IN("Duplicate callback constructor.")})}}static clear(){KE.constructors={}}static createCallbacks(e){const t=[];for(const n in KE.constructors){const a=+n;e>=a&&t.push(...KE.constructors[a])}return t.map(e=>new e)}}function XE(e,t,n,a,s,r,i,o,c){const l=new HE,u=[new UE,...KE.createCallbacks(t)];null!=e&&u.push(...e),u.push(l);const h=new VE(u);return h.setParams({epochs:n,initialEpoch:a,samples:s,steps:r,batchSize:i,verbose:t,doValidation:o,metrics:c}),{callbackList:h,history:l}}function YE(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return BN(e,by.getMap().classNameMap,t,"layer",n)}function QE(e,t){return Xm(()=>{"float32"!==e.dtype&&(e=ay(e,"float32"));const n=iv(AT(e),t,!0),a=ky(n.shape,xT()),s=uy(Ay(n,a));return cy(e,s)})}function ZE(e,t){return Xm(()=>Gv(AT(Iy(t,e)),-1))}function JE(e,t){return Xm(()=>Gv(Ty(Iy(t,e)),-1))}function $E(e,t){return Xm(()=>{const n=Iy(e,t),a=wx(Ty(e),xT(),Number.MAX_VALUE),s=Ty(cy(n,a));return ly(100,Gv(s,-1))})}function eR(e,t){return Xm(()=>{const n=wx(t,xT(),Number.MAX_VALUE),a=Ev(iy(1,n)),s=wx(e,xT(),Number.MAX_VALUE),r=Ev(iy(1,s));return Gv(AT(Iy(a,r)),-1)})}function tR(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return Xm(()=>{if(n)t=Yw(t);else{const e=iv(t,t.shape.length-1,!0);t=cy(t,e)}return t=wx(t,xT(),1-xT()),_v(iv(ly(ay(e,"float32"),Ev(t)),t.shape.length-1))})}function nR(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return Xm(()=>{const a=ay(mv(function(e){const t=[fT(e.shape)];return nx(e,t)}(e)),"int32"),s=(t=wx(t,xT(),1-xT())).shape;return tR(nx(nw(a,s[s.length-1]),s),t,n)})}function aR(e,t){return Xm(()=>{let n;return n=wx(t,xT(),1-xT()),n=Ev(cy(n,Iy(1,n))),Gv(function(e,t){if(!Su(e.shape,t.shape))throw new IN("logits and labels must have the same shape, but got shapes "+"".concat(JSON.stringify(e.shape)," and ").concat(JSON.stringify(t.shape)));return Xm(()=>{const n=_w(t),a=_v(Ty(t));return iy(Iy(n,ly(t,e)),Rv(uv(a)))})}(e,n),-1)})}function sR(e,t){return Xm(()=>{const n=wx(e,xT(),1),a=wx(t,xT(),1);return iv(ly(e,Ev(cy(n,a))),-1)})}function rR(e,t){return Xm(()=>{const n=QE(e,-1),a=QE(t,-1),s=ly(n,a);return _v(iv(s,-1))})}KE.constructors={};const iR={meanSquaredError:ZE,meanAbsoluteError:JE,meanAbsolutePercentageError:$E,meanSquaredLogarithmicError:eR,squaredHinge:function(e,t){return Xm(()=>{const n=Ay(0,Iy(1,ly(e,t)));return Gv(AT(n),-1)})},hinge:function(e,t){return Xm(()=>{const n=Ay(0,Iy(1,ly(e,t)));return Gv(n,-1)})},categoricalHinge:function(e,t){return Xm(()=>{const n=iv(ly(e,t),-1),a=sv(ly(Iy(1,e),t),-1);return Ay(0,iy(1,Iy(a,n)))})},logcosh:function(e,t){return Xm(()=>{const n=Math.log(2),a=Iy(t,e),s=Iy(iy(a,Av(ly(-2,a))),n);return Gv(s,-1)})},categoricalCrossentropy:tR,sparseCategoricalCrossentropy:nR,binaryCrossentropy:aR,kullbackLeiblerDivergence:sR,poisson:function(e,t){return Xm(()=>{const n=Ev(iy(xT(),t));return Gv(Iy(t,ly(e,n)),-1)})},cosineProximity:rR};function oR(e){if("string"===typeof e){if(e in iR)return iR[e];let t="Unknown loss ".concat(e);throw e.toLowerCase().includes("softmaxcrossentropy")&&(t="Unknown loss ".concat(e,". ")+'Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy'),new IN(t)}return e}function cR(e,t){return Xm(()=>{const n=ly(.5,aw(t)),a=vT(yv(t,n),e.dtype);return Gv(Vx(e,a),-1)})}function lR(e,t){return Xm(()=>vT(Vx(Db(e,-1),Db(t,-1)),"float32"))}function uR(e,t){return Xm(()=>ay(iv(Ov(Vx(e,1),Vx(t,1))),"float32"))}function hR(e,t){return aR(e,t)}function dR(e,t){return e.rank===t.rank&&(e=nk(e,[e.rank-1])),(t=Db(t,-1)).dtype!==e.dtype&&(t=ay(t,e.dtype)),ay(Vx(e,t),"float32")}const pR=tR,fR=nR,mR={binaryAccuracy:cR,categoricalAccuracy:lR,precision:function(e,t){return Xm(()=>{const n=uR(e,t),a=function(e,t){return Xm(()=>ay(iv(Ov(Vx(e,0),Vx(t,1))),"float32"))}(e,t),s=iy(n,a);return ay(Ux(yv(s,0),cy(n,s),0),"float32")})},categoricalCrossentropy:pR,sparseCategoricalCrossentropy:fR,mse:ZE,MSE:ZE,mae:JE,MAE:JE,mape:$E,MAPE:$E,cosine:rR};function gR(e){if("string"===typeof e&&e in mR)return mR[e];if("string"!==typeof e&&null!=e)return e;throw new IN("Unknown metric ".concat(e))}function yR(e){if(_N(null!==e,"Unknown LossOrMetricFn ".concat(e)),"string"===typeof e)return e;{let t;for(const n of Object.keys(iR))if(iR[n]===e){t=n;break}if(void 0!==t)return t;for(const n of Object.keys(mR))if(mR[n]===e){t=n;break}return void 0!==t?t:e.name}}const bR=1048576;function xR(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(null==e||"object"!==typeof e||Object.getPrototypeOf(e)!==Object.prototype||!vR(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){const n=JSON.stringify(e);n.length>bR&&console.warn('User-defined metadata of model "'.concat(t,'" is too large in ')+"size (length=".concat(n.length," when serialized). It is not ")+"recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= "+"".concat(bR,"."))}}function vR(e){if(null===e)return!0;if("object"===typeof e){if(Object.getPrototypeOf(e)===Object.prototype){const t=Object.keys(e);for(const n of t){if("string"!==typeof n)return!1;if(!vR(e[n]))return!1}return!0}if(Array.isArray(e)){for(const t of e)if(!vR(t))return!1;return!0}return!1}{const t=typeof e;return"string"===t||"number"===t||"boolean"===t}}function wR(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:console.log;const s=function(e){let t=!0;const n=[],a=[];for(const s in e.nodesByDepth)n.push(e.nodesByDepth[s]);for(const s of n){if(s.length>1||1===s.length&&s[0].inboundLayers.length>1){t=!1;break}a.push(...s)}if(t)for(const s of e.layers){let e=!1;for(const n of s.inboundNodes)if(-1!==a.indexOf(n)){if(e){t=!1;break}e=!0}if(!t)break}return t}(e),r=["Layer (type)","Input Shape","Output shape","Param #"];let i;if(s?(t=t||90,n=n||[.32,.61,.89,1]):(t=t||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map(e=>Math.floor(t*e))),!s){r.push("Receives inputs"),i=[];for(const t in e.nodesByDepth)i.push(...e.nodesByDepth[t])}a("_".repeat(t)),kR(r,n,a),a("=".repeat(t));const o=e.layers;for(let u=0;u<o.length;++u)s?SR(o[u],n,a):CR(o[u],n,i,a),a((u===o.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();const c=function(e){let t;t=null!=e.collectedTrainableWeights?cE(e.collectedTrainableWeights):cE(e.trainableWeights);return t}(e),l=cE(e.nonTrainableWeights);a("Total params: ".concat(c+l)),a("Trainable params: ".concat(c)),a("Non-trainable params: ".concat(l)),a("_".repeat(t))}function kR(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log,a="";for(let s=0;s<e.length;++s)s>0&&(a=a.slice(0,a.length-1)+" "),a+=e[s],a=a.slice(0,t[s]),a+=" ".repeat(t[s]-a.length);n(a)}function SR(e,t,n){let a,s;try{s=e.inboundNodes.map(e=>JSON.stringify(e.inputShapes)).join(",")}catch(K5){s="multiple"}try{a=JSON.stringify(e.outputShape)}catch(K5){a="multiple"}const r=e.name,i=e.getClassName();kR(["".concat(r," (").concat(i,")"),s,a,e.countParams().toString()],t,n)}function CR(e,t,n,a){let s,r;try{r=e.inboundNodes.map(e=>JSON.stringify(e.inputShapes)).join(",")}catch(K5){r="multiple"}try{s=JSON.stringify(e.outputShape)}catch(K5){s="multiple"}const i=[];for(const u of e.inboundNodes)if(!(null!=n&&n.length>0&&-1===n.indexOf(u)))for(let e=0;e<u.inboundLayers.length;++e){const t=u.inboundLayers[e].name,n=u.nodeIndices[e],a=u.tensorIndices[e];i.push("".concat(t,"[").concat(n,"][").concat(a,"]"))}const o=e.name,c=e.getClassName(),l=0===i.length?"":i[0];kR(["".concat(o," (").concat(c,")"),r,s,e.countParams().toString(),l],t,a);for(let u=1;u<i.length;++u)kR(["","","","",i[u]],t,a)}function IR(e,t,n){return("inboundNodes"===e||"outputLayers"===e||"inputLayers"===e)&&0===t&&"string"===typeof n}function NR(e,t){if(null===e)return null;if("string"===typeof e)return ON(e);if("number"===typeof e||"boolean"===typeof e)return e;if(e instanceof Array){const n=[],a=e.length;for(let s=0;s<a;++s){const a=e[s];IR(t,s,a)?n.push(a):n.push(NR(a,t))}return n}{const t={};for(const n of Object.keys(e)){const a=e[n];if("name"===n&&"string"===typeof a)t[n]=a;else{const e=ON(n);t[e]=NR(a,e)}}return t}}function TR(e,t){if(null===e||void 0===e)return null;if("string"===typeof e)return DN(e);if("number"===typeof e||"boolean"===typeof e)return e;if(e instanceof Array){const n=[],a=e.length;for(let s=0;s<a;++s){const a=e[s];IR(t,s,a)?n.push(a):n.push(TR(a,t))}return n}{const t={};for(const n of Object.keys(e)){const a=e[n],s=DN(n);t[s]="name"!==n&&"className"!==n||"string"!==typeof a?TR(a,n):a}return t}}const ER="4.22.0";class RR extends bE{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,null==this.name){const e=this.getClassName().toLowerCase();this.name=ZN(e)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],WN(this.inputs).length!==this.inputs.length)throw new IN("The list of inputs passed to the model is redundant. All inputs should only appear once. Found: "+"".concat(this.inputs.map(e=>e.name)));WN(this.outputs).length!==this.outputs.length&&console.warn("The list of outputs passed to the model is redundant. All outputs should only appear once. Found: "+"".concat(this.outputs.map(e=>e.name))),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const y of this.outputs){const e=y.sourceLayer,t=y.nodeIndex,n=y.tensorIndex;this.outputLayers.push(e),this.outputLayersNodeIndices.push(t),this.outputLayersTensorIndices.push(n)}for(const y of this.inputs){const e=y.sourceLayer,t=y.nodeIndex,n=y.tensorIndex;_N(0===t,"input layer has >1 nodes"),_N(0===n,"input layer has >1 tensors"),this.inputLayers.push(e),this.inputLayersNodeIndices.push(t),this.inputLayersTensorIndices.push(n)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let y=0;y<this.inputLayers.length;y++){const t=this.inputLayers[y];if(!(t instanceof vE))throw new TypeError("Input layers to a LayersModel must be InputLayer objects. "+"Received inputs: ".concat(e.inputs,". ")+"Input ".concat(y," (0-based) originates ")+"from layer type ".concat(t.getClassName(),"."));this.inputNames.push(t.name),this.feedInputShapes.push(t.batchInputShape),this.feedInputNames.push(t.name)}for(const y of this.outputLayers)this.outputNames.push(y.name);this.internalInputShapes=this.inputs.map(e=>e.shape),this.internalOutputShapes=this.outputs.map(e=>e.shape);const t={},n={},a={},s={},r={},i=[],o=(e,t,n,a,s,c)=>{null!=a&&null!=s&&null!=c||(a=e.sourceLayer,s=e.nodeIndex,c=e.tensorIndex);const l=a.inboundNodes[s];if(-1!==n.indexOf(l))throw new CN("The tensor ".concat(e.name,' at layer "').concat(a.name,'" ')+"is part of a cycle.");if(-1!==t.indexOf(l))return;this.containerNodes.add(RR.nodeKey(a,s)),a.id in r||(r[a.id]=Object.keys(r).length),-1===n.indexOf(l)&&n.push(l);const u=l.inboundLayers.length;for(let r=0;r<u;r++){const e=l.inputTensors[r],a=l.inboundLayers[r],s=l.nodeIndices[r],i=l.tensorIndices[r];o(e,t,n,a,s,i)}for(t.push(l);n.indexOf(l)>=0;)n.splice(n.indexOf(l),1);i.push(l)},c=[],l=[];for(const y of this.outputs)o(y,c,l);const u=i.slice().reverse();for(const y of u){n[y.id]=y,y.id in t||(t[y.id]=0);let e=t[y.id];const r=null==a[y.outboundLayer.id]?0:a[y.outboundLayer.id];e=Math.max(e,r),a[y.outboundLayer.id]=e,s[y.outboundLayer.id]=y.outboundLayer,t[y.id]=e;for(let a=0;a<y.inboundLayers.length;a++){const s=y.inboundLayers[a],r=y.nodeIndices[a],i=s.inboundNodes[r],o=null==t[i.id]?0:t[i.id];t[i.id]=Math.max(e+1,o),n[i.id]=i}}const h={};for(const y in t){const e=t[y];e in h||(h[e]=[]),h[e].push(n[y])}const d={};for(const y in a){const e=a[y];e in d||(d[e]=[]),d[e].push(s[y])}let p=Object.keys(d).map(e=>parseInt(e,10)).sort(jN);this.layers=[];for(const y of p){const e=d[y];e.sort((e,t)=>{const n=r[e.id],a=r[t.id];return n<a?-1:n>a?1:0});for(const t of e)t instanceof RR&&this.internalContainerRefs.push(t),this.layers.push(t)}this.layersByDepth=d,p=Object.keys(h).map(e=>parseInt(e,10)).sort(jN);const f=this.inputs.slice(),m=[];for(const y of p)for(const e of h[y]){const t=e.outboundLayer;if(null!=t){for(const n of e.inputTensors)if(-1===f.indexOf(n))throw new CN("Graph disconnected: cannot obtain value for tensor ".concat(n)+' at layer "'.concat(t.name,'". ')+"The following previous layers were accessed without "+"issue: ".concat(m));for(const t of e.outputTensors)f.push(t);m.push(t.name)}}this.nodesByDepth=h;const g=this.layers.map(e=>e.name);for(const y of g){const e=g.filter(e=>e===y).length;if(1!==e)throw new CN('The name "'.concat(y,'" is used ').concat(e," times ")+"in the model. All layer names should be unique. Layer names: "+JSON.stringify(g))}this.outboundNodes=[],this.inboundNodes=[],new gE({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(e=>null),outputMasks:this.outputs.map(e=>null),inputShapes:this.inputs.map(e=>e.shape),outputShapes:this.outputs.map(e=>e.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error("Container '".concat(this.name,"' is already disposed."))}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(0===--this._refCount){for(const t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(const t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach(t=>{t._trainableWeights.forEach(t=>t.trainable=e)}),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new IN("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const e of this.layers)t.push(...e.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n={};let a=0;const s=(e=>{const t=Object.keys(e);if(0===t.length)return!1;const n=t[0].split("/");return!isNaN(parseInt(n[n.length-1],10))})(e);s&&this.parseWeights(e);for(const i of this.layers)for(const[e,t]of i.weights.entries()){const r=s?"".concat(t.name.split("/").slice(0,-1).join("/")+"/").concat(e):t.originalName;if(null!=n[r])throw new IN("Duplicate weight name: ".concat(r));n[r]=t,a++}const r=[];for(const i in e){let a=i;if(null==n[i]){const e=i.split("/");a=e.slice(0,-2).concat([e[e.length-1]]).join("/")}if(null!=n[a])r.push([n[a],e[i]]);else if(t)throw new IN("Provided weight data has no target variable: ".concat(i));delete n[a]}if(t){const e=[];for(const t in n)e.push(t);if(e.length>0)throw new IN("".concat(e.length," of ").concat(a," weights are not set: ")+"".concat(e))}dE(r)}parseWeights(e){for(const t in Object.keys(e)){const n=t.split("/"),a=["vars","layer_checkpoint_dependencies"],s=n.map(e=>e.startsWith("_")?e.slice(1):e).filter(e=>!a.includes(e)).join("/");s!==t&&(e[s]=e[t],delete e[t])}}updatedConfig(){const e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion="tfjs-layers ".concat(ER),t.backend="TensorFlow.js",t}toJSON(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n=TR(this.updatedConfig());return t?JSON.stringify(n):n}call(e,t){return Xm(()=>{e=PN(e);const n=new wE;for(let t=0;t<this.inputs.length;++t)n.add(this.inputs[t],e[t]);return CE(this.outputs,n,t)})}computeMask(e,t){return Xm(()=>{let n;return e=PN(e),n=null==t?RN(null,e.length):PN(t),this.runInternalGraph(e,n)[1]})}computeOutputShape(e){const t=rE(e);if(t.length!==this.inputLayers.length)throw new IN("Invalid inputShape argument ".concat(e,": ")+"model has ".concat(this.inputLayers.length," tensor inputs."));const n={};for(let i=0;i<t.length;i++){const e=this.inputLayers[i],a=t[i];n[e.name+"_0_0"]=a}const a=Object.keys(this.nodesByDepth).map(e=>parseInt(e,10)).sort(jN);if(a.length>1)for(const i of a){const e=this.nodesByDepth[i];for(const t of e){const e=t.outboundLayer;if(-1!==this.inputLayers.map(e=>e.id).indexOf(e.id))continue;const a=[];for(let i=0;i<t.inboundLayers.length;i++){const e=t.inboundLayers[i],s=t.nodeIndices[i],r=t.tensorIndices[i],o=n["".concat(e.name,"_").concat(s,"_").concat(r)];a.push(o)}const s=rE(e.computeOutputShape(MN(a))),r=e.inboundNodes.indexOf(t);for(let t=0;t<s.length;t++){n["".concat(e.name,"_").concat(r,"_").concat(t)]=s[t]}}}const s=[],r=[];for(let i=0;i<this.outputLayers.length;i++){const e=this.outputLayers[i],t=this.outputLayersNodeIndices[i],n=this.outputLayersTensorIndices[i],a="".concat(e.name,"_").concat(t,"_").concat(n);r.push(a)}for(let i=0;i<r.length;i++){const e=r[i];_N(e in n),s.push(n[e])}return MN(s)}runInternalGraph(e,t){null==t&&(t=RN(null,e.length));const n={};for(let o=0;o<this.inputs.length;++o){const a=this.inputs[o],s=e[o],r=t[o];n[a.id]=[s,r]}const a=Object.keys(this.nodesByDepth).map(e=>parseInt(e,10)).sort(jN);for(const o of a){const e=this.nodesByDepth[o];for(const t of e){const e=t.outboundLayer,a=t.inputTensors,s=t.outputTensors,r=new Array;for(const t of a)t.id in n&&r.push(n[t.id]);if(r.length===a.length){let a,i,o,c,l={};if(null!=t.callArgs&&(l=t.callArgs),1===r.length){const[t,n]=r[0];null==l.mask&&(l.mask=n),o=PN(e.call(t,l)),c=PN(e.computeMask(t,n)),a=[t],i=[n]}else a=r.map(e=>e[0]),i=r.map(e=>e[1]),null==l.mask&&(l.mask=i),o=PN(e.call(a,l)),c=PN(e.computeMask(a,i));if(e.activityRegularizer)throw new NN("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let e=0;e<s.length;++e){const t=s[e],a=o[e],r=c[e];n[t.id]=[a,r]}}}}const s=[],r=[],i=[];for(const o of this.outputs){_N(o.id in n,"Could not compute output ".concat(o.name," : ").concat(o.id));const[e,t]=n[o.id];i.push(e.shape),s.push(e),r.push(t)}return[s,r,i]}buildNodeConversionMap(e){const t={};let n;for(const a of this.layers){n=a instanceof RR?1:0;for(let e=0;e<a.inboundNodes.length;e++){const s=RR.nodeKey(a,e);this.containerNodes.has(s)&&(t[s]=n,n+=1)}}return t}getLayer(e,t){if(null!=t)return this.findLayer(t);if(null==e)throw new IN("Provide either a layer name or layer index");if("number"===typeof e)return this.findLayer(e);for(const n of this.layers)if(n.name===e)return n;throw new IN("No such layer: ".concat(e))}findLayer(e){if(this.layers.length<=e)throw new IN("Was asked to retrieve layer at index ".concat(e,", but model only ")+"has ".concat(this.layers.length," layer(s)."));return this.layers[e]}calculateLosses(){return Xm(()=>{const e=[];for(const t of this.layers)for(let n=0;n<t.inboundNodes.length;++n){const a=RR.nodeKey(t,n);this.containerNodes.has(a)&&e.push(...t.calculateLosses())}return e})}getConfig(){const e={name:this.name},t=this.buildNodeConversionMap(this.layers),n=[];for(const r of this.layers){const e=r.getClassName(),a=r.getConfig(),s=[];for(let n=0;n<r.inboundNodes.length;n++){const e=r.inboundNodes[n],a=RR.nodeKey(r,n);let i={};if(this.containerNodes.has(a)){if(e.callArgs)try{JSON.stringify(e.callArgs),i=e.callArgs}catch(K5){console.warn("Layer ".concat(r.name," was passed ")+"non-serializable keyword arguments: "+"".concat(e.callArgs,". They will not be included ")+"in the serialized model (and thus will be missing at deserialization time)."),i={}}if(e.inboundLayers.length>0){const n=[];for(let a=0;a<e.inboundLayers.length;a++){const s=e.inboundLayers[a],r=e.nodeIndices[a],o=e.tensorIndices[a];let c=t[RR.nodeKey(s,r)];null==c&&(c=0),n.push([s.name,c,o,i])}s.push(n)}}}const i={};i.name=r.name,i.className=e,i.config=a,i.inboundNodes=s,n.push(i)}e.layers=n;const a=[];for(let r=0;r<this.inputLayers.length;r++){const e=this.inputLayers[r],n=this.inputLayersNodeIndices[r],s=RR.nodeKey(e,n);if(!this.containerNodes.has(s))continue;let i=t[s];null!==i&&void 0!==i||(i=0);const o=this.inputLayersTensorIndices[r];a.push([e.name,i,o])}e.inputLayers=a;const s=[];for(let r=0;r<this.outputLayers.length;r++){const e=this.outputLayers[r],n=this.outputLayersNodeIndices[r],a=RR.nodeKey(e,n);if(!this.containerNodes.has(a))continue;let i=t[a];null!==i&&void 0!==i||(i=0);const o=this.outputLayersTensorIndices[r];s.push([e.name,i,o])}return e.outputLayers=s,e}static fromConfig(e,t){let n=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a={},s={};function r(e,t){e.name in s?s[e.name].push(t):s[e.name]=[t]}function i(e,t){const n=[];let s;for(const i of t){const o=i[0],c=i[1],l=i[2];if(s=null==i[3]?{}:i[3],!(o in a))return void r(e,t);const u=a[o];if(u.inboundNodes.length<=c)return void r(e,t);const h=u.inboundNodes[c];n.push(h.outputTensors[l])}n.length>0&&e.apply(MN(n),s)}function o(e){const s=e.name,i=YE(e,null!=t.customObjects?t.customObjects:{});i.setFastWeightInitDuringBuild(n),a[s]=i;e.inboundNodes.forEach(e=>{if(!(e instanceof Array))throw new IN("Corrupted configuration, expected array for nodeData: ".concat(e));r(i,e)})}const c=t.name,l=t.layers;for(const f of l)o(f);for(;!VN(s);)for(const e of l){const t=a[e.name];if(t.name in s){const e=s[t.name];delete s[t.name];for(const n of e)i(t,n)}}const u=[],h=[],d=t.inputLayers;for(const f of d){const e=f[0],t=f[1],n=f[2];_N(e in a);const s=a[e].inboundNodes[t].outputTensors;u.push(s[n])}const p=t.outputLayers;for(const f of p){const e=f[0],t=f[1],n=f[2];_N(e in a);const s=a[e].inboundNodes[t].outputTensors;h.push(s[n])}return new e({inputs:u,outputs:h,name:c})}get stateful(){if(this._stateful)throw new IN("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){Xm(()=>{this.layers.forEach(e=>{e.stateful&&e.resetStates()})})}}function _R(e,t,n){const a=t.length;if(null==e||Array.isArray(e)&&0===e.length)return t.map(e=>null);if(1===a)return Array.isArray(e)&&1===e.length?e:"object"===typeof e&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==a)throw new Error("Provided ".concat(n," is an array of ").concat(e.length," ")+"element(s), but the model has ".concat(a," outputs. ")+"Make sure a set of weights is provided for each model output.");return e}if("object"===typeof e&&Object.keys(e).length>0&&"object"===typeof e[Object.keys(e)[0]]){const n=[];return t.forEach(t=>{t in e?n.push(e[t]):n.push(null)}),n}throw new Error("The model has multiple (".concat(a,") outputs, ")+"so ".concat(n," must be either an array with ")+"".concat(a," elements or an object with ").concat(t," keys. ")+"Provided ".concat(n," not understood: ").concat(JSON.stringify(e)))}function AR(e,t){return _R(e,t,"classWeight")}async function MR(e,t,n,a){if(null!=t||null!=a)throw new Error("Support sampleWeight is not implemented yet");if(null!=n){const t=Xm(()=>{if(1===e.shape.length)return sy(e);if(2===e.shape.length){if(e.shape[1]>1){return Db(e,1)}if(1===e.shape[1])return nx(e,[e.shape[0]]);throw new Error("Encountered unexpected last-dimension size (".concat(e.shape[1],") ")+"during handling of class weights. The size is expected to be >= 1.")}throw new Error("Unexpected rank of target (y) tensor (".concat(e.rank,") during ")+"handling of class weights. The rank is expected to be 1 or 2.")}),a=Array.from(await t.data());Ym(t);const s=[];return a.forEach(e=>{if(null==n[e])throw new Error("classWeight must contain all classes in the training data. "+"The class ".concat(e," exists in the data but not in ")+"classWeight");s.push(n[e])}),ok(s,"float32")}return null}function PR(e,t){return ly(e,t)}function DR(e,t){let n,a;const s=t;n=s.xs,a=s.ys,bu(null!=n&&null!=a,()=>"A Dataset iterator for fitDataset() is expected to generate objects of the form `{xs: xVal, ys: yVal}`, where the two values may be `tf.Tensor`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates "+"".concat(t));const r=OR("input",e.inputNames,n),i=OR("output",e.outputNames,a),o=r[0].shape[0];bu(r.length===e.inputs.length,()=>"LayersModel has ".concat(e.inputs.length," inputs, but the dataset ")+"provides ".concat(r.length," inputs.  (Expected input keys: ")+"".concat(JSON.stringify(e.inputNames),")")),bu(i.length===e.outputs.length,()=>"LayersModel has ".concat(e.outputs.length," outputs, but the dataset ")+"provides ".concat(i.length," outputs.  (Expected output keys: ")+"".concat(JSON.stringify(e.outputNames),")"));for(let c=0;c<r.length;c++)bu(r[c].shape[0]===o,()=>"Batch size mismatch: input "+"".concat(e.inputNames[c]," has ").concat(r[c].shape[0],"; ")+"expected  ".concat(o," based on input ").concat(e.inputNames[0],"."));for(let c=0;c<i.length;c++)bu(i[c].shape[0]===o,()=>"Batch size mismatch: output "+"".concat(e.outputNames[c]," has ").concat(i[c].shape[0],"; ")+"expected  ".concat(o," based on input ").concat(e.inputNames[0],"."));return{xs:r,ys:i}}function OR(e,t,n){if(n instanceof om)return[n];if(Array.isArray(n))return bu(n.length===t.length,()=>"Received an array of ".concat(n.length," Tensors, but expected ").concat(t.length," to match the ").concat(e," keys ").concat(t,".")),n;{const a=[];for(const s of t){if(null==n[s])throw new IN("The feature data generated by the dataset lacks the required "+"".concat(e," key '").concat(s,"'."));a.push(n[s])}return a}}async function FR(e,t,n){const a=null!=n.batchesPerEpoch;if(bu(null!=e.optimizer,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),bu(null!=n,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),bu(null!=n.epochs&&n.epochs>0&&Number.isInteger(n.epochs),()=>"For fitDataset(), config.epochs is expected to be a positive "+"integer, but got ".concat(n.epochs)),bu(!a||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),()=>"For fitDataset(), config.batchesPerEpoch is expected to be a "+"positive integer if specified, but got ".concat(n.batchesPerEpoch)),bu(null==n.validationSplit,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{const s=null!=n.validationData;let r,i;if(s)if(LR(n.validationData))bu(null==n.validationBatches||n.validationBatches>0&&Number.isInteger(n.validationBatches),()=>"For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, "+"but got ".concat(n.validationBatches));else{const e=function(e){if(3===e.length)throw new NN("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}(n.validationData);r=e.xs,i=e.ys}const o=e.makeTrainFunction(),c=e.getDedupedMetricsNames();let l;l=s?c.slice().concat(c.map(e=>"val_"+e)):c.slice();const u=qE(n.callbacks,n.yieldEvery),h=null==n.verbose?1:n.verbose,{callbackList:d,history:p}=XE(u,h,n.epochs,null,null,function(e,t){let n=null;null!=t.batchesPerEpoch?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size);return n}(t,n),null,s,l);d.setModel(e),e.history=p,await d.onTrainBegin(),e.stopTraining_=!1;let f=null==n.initialEpoch?0:n.initialEpoch,m=await t.iterator();for(;f<n.epochs;){const l={};await d.onEpochBegin(f);let u=0,h=0;for(a||(m=await t.iterator());!a||u<n.batchesPerEpoch;){const t=await m.next();if(a&&t.done){console.warn("You provided `batchesPerEpoch` as "+"".concat(n.batchesPerEpoch,", ")+"but your dataset iterator ran out of data after "+"".concat(u," batches; ")+"interrupting training. Make sure that your dataset can generate at least `batchesPerEpoch * epochs` batches (in this case, "+"".concat(n.batchesPerEpoch*n.epochs," batches). ")+"You may need to use the repeat() function when building your dataset.");break}if(null!=t.value){const{xs:a,ys:s}=DR(e,t.value),r={};r.batch=h,r.size=a[0].shape[0],await d.onBatchBegin(h,r);const i=[];if(null!=n.classWeight){const t=AR(n.classWeight,e.outputNames);for(let e=0;e<t.length;++e)i.push(await MR(s[e],null,t[e]))}const l=a.concat(s).concat(i),p=o(l);Ym(l);for(let e=0;e<c.length;++e){const t=c[e],n=p[e];r[t]=n,Qm(n)}await d.onBatchEnd(h,r),BE(r),h++,u++}if(a?u>=n.batchesPerEpoch:t.done){if(s){let t;t=LR(n.validationData)?PN(await e.evaluateDataset(n.validationData,{batches:n.validationBatches})):PN(e.evaluate(r,i,{batchSize:null==n.validationBatchSize?32:n.validationBatchSize,verbose:0}));for(let n=0;n<e.metricsNames.length;++n)l["val_".concat(e.metricsNames[n])]=t[n]}break}if(e.stopTraining_)break}if(await d.onEpochEnd(f,l),f++,e.stopTraining_)break}return await d.onTrainEnd(),await e.history.syncData(),e.history}finally{e.isTraining=!1}}function LR(e){return"function"===typeof e.iterator}function zR(e){bu(e>0&&Number.isInteger(e),()=>"batchSize is required to be a positive integer, but got ".concat(e))}function BR(e,t,n){return null==e?[null]:Array.isArray(e)?e.map(e=>kT(e,t,n-t)):kT(e,t,n-t)}function jR(e,t){return Xm(()=>null==e?null:Array.isArray(e)?e.map(e=>jR(e,t)):_T(e,"int32"===t.dtype?t:ay(t,"int32")))}function WR(e,t){const n=[];let a=0,s=null;for(;a<e;)s=a+t,s>=e&&(s=e),n.push([a,s]),a=s;return n}function VR(e){const t=[];e instanceof om&&(e=[e]);for(let n=0;n<e.length;++n){const a=e[n];if(1===a.rank)t.push(wT(a,1));else{if(0===a.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(a)}}return t}function UR(e,t){if(null==e)return;const n=[];if(t instanceof om)n.push(t.id);else if(Array.isArray(t))t.forEach(e=>n.push(e.id));else if(null!=t)for(const s in t){const e=t[s];n.push(e.id)}const a=[];if(e instanceof om)-1===n.indexOf(e.id)&&a.push(e);else if(Array.isArray(e))e.forEach(e=>{-1===n.indexOf(e.id)&&a.push(e)});else if(null!=e)for(const s in e){const t=e[s];-1===n.indexOf(t.id)&&a.push(t)}a.forEach(e=>{e.isDisposed||e.dispose()})}function HR(e){return Array.isArray(e)}function GR(e){return!function(e){return e instanceof om}(e)&&!HR(e)}function qR(e,t,n){let a,s=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"";if(null==t||0===t.length){if(null!=e){let t=!1;if(HR(e)&&e.length>0)t=!0;else if(GR(e)){for(const n in e)if(e.hasOwnProperty(n)){t=!0;break}}else t=!0;if(t)throw new IN("Error when checking model ".concat(r," expected no data, ")+"but got ".concat(e))}return[]}if(null==e)return t.map(e=>null);if(GR(e)){a=[];for(const n of t){if(null==e[n])throw new IN('No data provided for "'.concat(n,'". Need data for each key in: ')+"".concat(t));a.push(e[n])}}else if(HR(e)){if(e.length!==t.length)throw new IN("Error when checking model ".concat(r,": the Array of ")+"Tensors that you are passing to your model is not the size the "+"model expected. Expected to see ".concat(t.length," Tensor(s), but ")+"instead got the following list of Tensor(s): ".concat(e));a=e}else{if(t.length>1)throw new IN("The model ".concat(r," expects ").concat(t.length," Tensor(s), ")+"but only received one Tensor. Found: Tensor with shape ".concat(e.shape));a=[e]}if(a=VR(a),null!=n)for(let i=0;i<t.length;++i){if(null==n[i])continue;const e=a[i];if(e.shape.length!==n[i].length)throw new IN("Error when checking ".concat(r,": expected ").concat(t[i]," ")+"to have ".concat(n[i].length," dimension(s). but got array with ")+"shape ".concat(e.shape));for(let t=0;t<n[i].length;++t){if(0===t&&!s)continue;const a=e.shape[t],o=n[i][t];if(null!=o&&o>=0&&a!==o)throw new IN("".concat(r," expected a batch of elements where each ")+"example has shape [".concat(n[i].slice(1,n[i].length),"] ")+"(i.e.,tensor shape [*,".concat(n[i].slice(1,n[i].length),"])")+" but the ".concat(r," received an input with ").concat(e.shape[0])+" examples, each with shape [".concat(e.shape.slice(1,e.shape.length),"]")+" (tensor shape [".concat(e.shape,"])"))}}return a}function KR(e,t,n){let a,s=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"";if(Array.isArray(e)){if(e.length!==t.length)throw new IN("Error when checking model ".concat(r,": the Array of ")+"Tensors that you are passing to your model is not the size the "+"the model expected. Expected to see ".concat(t.length," Tensor(s),")+" but instead got ".concat(e.length," Tensors(s)."));a=e}else{if(t.length>1)throw new IN("The model expects ".concat(t.length," ").concat(r," Tensors, ")+"but only received one Tensor. Found: array with shape "+"".concat(JSON.stringify(e.shape),"."));a=[e]}if(null!=n)for(let i=0;i<t.length;++i){if(null==n[i])continue;const e=a[i];if(e.shape.length!==n[i].length)throw new IN("Error when checking ".concat(r,": expected ").concat(t[i]," ")+"to have ".concat(n[i].length," dimension(s), but got array with ")+"shape ".concat(JSON.stringify(e.shape)));for(let a=0;a<n[i].length;++a){if(0===a&&!s)continue;const o=e.shape[a],c=n[i][a];if(null!=c&&c!==o)throw new IN("Error when checking ".concat(r,": expected ")+"".concat(t[i]," to have shape ").concat(JSON.stringify(n[i])," but ")+"got array with shape ".concat(JSON.stringify(e.shape),"."))}}}class XR extends RR{constructor(e){super(e),this.isTraining=!1}summary(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log;if(!this.built)throw new IN("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");wR(this,e,t,n)}compile(e){if(null==e.loss&&(e.loss=[]),this.loss=e.loss,"string"===typeof e.optimizer)this.optimizer_=function(e){const t={Adagrad:()=>YS.adagrad(.01),Adadelta:()=>YS.adadelta(1,.95,xT()),Adam:()=>YS.adam(.001,.9,.999,xT()),Adamax:()=>YS.adamax(.002,.9,.999,xT(),0),RMSProp:()=>YS.rmsprop(.001,.9,0,xT()),SGD:()=>YS.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new IN("Unknown Optimizer ".concat(e))}(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof vy))throw new IN("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(Array.isArray(e.loss)||"string"===typeof e.loss||"function"===typeof e.loss)if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new IN("When passing an Array as loss, it should have one entry per "+"model output. The model has ".concat(this.outputs.length," output(s), ")+"but you passed loss=".concat(e.loss,"."));const n=e.loss;t=n.map(e=>oR(e))}else{const n=oR(e.loss);this.outputs.forEach(e=>{t.push(n)})}else{e.loss=e.loss;for(const t in e.loss)if(-1===this.outputNames.indexOf(t))throw new IN('Unknown entry in loss dictionary: "'.concat(t,'". ')+"Only expected the following keys: ".concat(this.outputNames));for(const n of this.outputNames)null==e.loss[n]&&console.warn('Output "'.concat(n,'" is missing from loss dictionary. We assume ')+"this was done on purpose, and we will not be expecting data "+"to be passed to ".concat(n," during training")),t.push(oR(e.loss[n]))}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let r=0;r<this.outputs.length;++r){const e=this.internalOutputShapes[r],t=this.outputNames[r];this.feedOutputNames.push(t),this.feedOutputShapes.push(e),this.feedLossFns.push(this.lossFunctions[r])}const n=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],cT("loss",()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;const t=this.lossFunctions[e];this.outputs.length>1&&(this.metricsTensors.push([t,e]),this.metricsNames.push(this.outputNames[e]+"_loss"))}});const a=function(e,t){if(null==e||Array.isArray(e)&&0===e.length)return t.map(e=>[]);let n;if("string"===typeof e||"function"===typeof e)n=[e];else{if(!Array.isArray(e)&&"object"!==typeof e)throw new TypeError("Type of metrics argument not understood. Expected an string,"+"function, Array, or Object, found: ".concat(e));n=e}if(Array.isArray(n))return t.map(e=>n);{const e=[];for(const a of t){let t=n.hasOwnProperty(a)?n[a]:[];Array.isArray(t)||(t=[t]),e.push(t)}return e}}(e.metrics,this.outputNames),s=(e,t,n)=>{this.outputNames.length>1&&(t=this.outputNames[e]+"_"+t),this.metricsNames.push(t),this.metricsTensors.push([n,e])};cT("metric",()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;(t=>{let n,a,r;for(const i of t){if("string"===typeof i&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(i)){const t=this.internalOutputShapes[e];let s;1===t[t.length-1]||this.lossFunctions[e]===aR?-1!==["accuracy","acc"].indexOf(i)?a=cR:-1!==["crossentropy","ce"].indexOf(i)&&(a=hR):this.lossFunctions[e]===nR?-1!==["accuracy","acc"].indexOf(i)?a=dR:-1!==["crossentropy","ce"].indexOf(i)&&(a=fR):-1!==["accuracy","acc"].indexOf(i)?a=lR:-1!==["crossentropy","ce"].indexOf(i)&&(a=pR),-1!==["accuracy","acc"].indexOf(i)?s="acc":-1!==["crossentropy","ce"].indexOf(i)&&(s="ce"),r=a,n=""+s}else{const e=gR(i);r=e,n=""+yR(i)}let t;cT(n,()=>{t=r}),s(e,n,t)}})(a[e])}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const a=null==n.batchSize?32:n.batchSize;zR(a);const s=this.standardizeUserDataXY(e,t,!0,a);try{const e=s[0].concat(s[1]);this.makeTestFunction();const t=this.testFunction;return MN(this.testLoop(t,e,a,n.verbose,n.steps))}finally{UR(s[0],e),UR(s[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),async function(e,t,n){const a=null!=(n=n||{}).batches,s=e.testFunction;let r=[];if(n.verbose>0)throw new NN("Verbose mode is not implemented yet.");bu(!a||n.batches>0&&Number.isInteger(n.batches),()=>"Test loop expects `batches` to be a positive integer, but "+"received ".concat(JSON.stringify(n.batches)));const i="function"===typeof t.next?t:await t.iterator();let o=0,c=0;for(;!a||c<n.batches;){const t=await i.next();if(r=Xm(()=>{if(t.value){const{xs:n,ys:a}=DR(e,t.value),i=n.concat(a),l=Xm(()=>s(i));if(Ym(i),0===c)for(let e=0;e<l.length;++e)r.push(fy(0));const u=i[0].shape[0];for(let e=0;e<l.length;++e){const t=l[e],n=r[e];r[e]=Xm(()=>iy(r[e],ly(u,t))),c>0&&Ym(n)}Ym(l),o+=u,++c}return r}),t.done){a&&console.warn("Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least `batches` "+"batches (in this case, ".concat(n.batches," batches). ")+"You may need to use the repeat() function when building your dataset.");break}}for(let l=0;l<r.length;++l){const e=r[l];r[l]=cy(r[l],o),Ym(e)}return MN(r)}(this,e,t)}checkNumSamples(e,t,n){let a,s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"steps";if(null!=n){if(a=null,null!=t)throw new IN("If ".concat(s," is set, batchSize must be null or undefined.")+"Got batchSize = ".concat(t))}else{if(null==e)throw new IN("Either the input data should have a defined shape, or "+"".concat(s," shoud be specified."));a=Array.isArray(e)?e[0].shape[0]:e.shape[0]}return a}execute(e,t){if(Array.isArray(t)&&0===t.length)throw new IN("`outputs` is an empty Array, which is not allowed.");const n=Array.isArray(t),a=n?t:[t],s=this.retrieveSymbolicTensors(a),r=new wE;if(e instanceof om&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new IN("The number of inputs provided (".concat(e.length,") ")+"does not match the number of inputs of this model "+"(".concat(this.inputs.length,")."));for(let t=0;t<this.inputs.length;++t)r.add(this.inputs[t],e[t])}else for(const o of this.inputs){const t=e[o.name];if(null==t)throw new IN("No value is provided for the model's input ".concat(o.name));r.add(o,t)}const i=CE(s,r);return n?i:i[0]}retrieveSymbolicTensors(e){const t=RN(null,e.length);let n=e.length;for(const a of this.layers){const s=Array.isArray(a.output)?a.output:[a.output],r=s.map(e=>e.name);for(let a=0;a<e.length;++a){const i=r.indexOf(e[a]);if(-1!==i&&(t[a]=s[i],n--),0===n)break}if(0===n)break}if(n>0){const n=[];throw t.forEach((t,a)=>{null==t&&n.push(e[a])}),new IN("Cannot find SymbolicTensors for output name(s): "+"".concat(JSON.stringify(n)))}return t}predictLoop(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:32,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return Xm(()=>{const a=this.checkNumSamples(e);if(n)throw new NN("Verbose predictLoop() is not implemented yet.");const s=WR(a,t),r=this.outputs.map(e=>[]);for(let t=0;t<s.length;++t){Xm(()=>{const n=s[t][0],a=s[t][1],r=BR(e,n,a),i=[];if(Array.isArray(r))for(let e=0;e<r.length;++e)i.push({key:this.inputs[e],value:r[e]});else i.push({key:this.inputs[0],value:r});const o=new wE(i);return CE(this.outputs,o)}).forEach((e,t)=>r[t].push(e))}return MN(r.map(e=>rx(e,0)))})}predict(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=VR(e);KR(n,this.inputNames,this.feedInputShapes,!1);try{const e=null==t.batchSize?32:t.batchSize;return zR(e),this.predictLoop(n,e)}finally{UR(n,e)}}predictOnBatch(e){KR(e,this.inputNames,this.feedInputShapes,!0);const t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t){let n=arguments.length>3?arguments[3]:void 0;if(null==this.optimizer_)throw new CN("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const a=[];for(let s=0;s<this.feedOutputShapes.length;++s){const e=this.feedOutputShapes[s];this.feedLossFns[s]===nR?a.push(e.slice(0,e.length-1).concat([1])):a.push(e)}if(function(e,t){const n=WN(e.map(e=>e.shape[0]));n.sort();const a=WN(t.map(e=>e.shape[0]));if(a.sort(),n.length>1)throw new IN("All input Tensors (x) should have the same number of samples. Got array shapes: "+"".concat(JSON.stringify(e.map(e=>e.shape))));if(a.length>1)throw new IN("All target Tensors (y) should have the same number of samples. Got array shapes: "+"".concat(JSON.stringify(t.map(e=>e.shape))));if(n.length>0&&a.length>0&&!Su(n,a))throw new IN("Input Tensors should have the same number of samples as target "+"Tensors. Found ".concat(n[0]," input sample(s) and ").concat(a[0]," target ")+"sample(s).")}(e=qR(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=qR(t,this.feedOutputNames,a,!1,"target")),function(e,t,n){const a=[ZE,aR,tR];for(let s=0;s<e.length;++s){const r=e[s],i=t[s],o=n[s];if(null!=i){if(i===tR&&1===r.shape[r.shape.length-1])throw new IN("You are passing a target array of shape ".concat(r.shape," while using ")+"a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].");if(-1!==a.indexOf(i)){const e=r.shape.slice(1),t=o.slice(1);for(let n=0;n<e.length;++n){const a=e[n],s=t[n];if(null!=s&&a!==s)throw new IN("A target Tensor with shape ".concat(r.shape," was passed for an ")+"output of shape ".concat(o,", while using a loss function that ")+"expects targets to have the same shape as the output.")}}}}}(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=n&&n>0&&e[0].shape[0]%n!==0)throw new IN("In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size "+"".concat(n,". Found: ").concat(e[0].shape[0]," sample(s)."));return[e,t]}async standardizeUserData(e,t,n,a){let s=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],r=arguments.length>5?arguments[5]:void 0;const[i,o]=this.standardizeUserDataXY(e,t,s,r);if(null!=n)throw new Error("sample weight is not supported yet.");let c=null;if(null!=a){const e=AR(a,this.outputNames);c=[];for(let t=0;t<e.length;++t)c.push(await MR(o[t],null,e[t]))}return[i,o,c]}testLoop(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,s=arguments.length>4?arguments[4]:void 0;return Xm(()=>{const r=this.checkNumSamples(t,n,s,"steps"),i=[];if(a>0)throw new NN("Verbose mode is not implemented yet.");if(null!=s)throw new NN("steps mode in testLoop() is not implemented yet");{const a=WR(r,n),s=ok(yT(0,r));for(let n=0;n<a.length;++n){const r=a[n][0],o=a[n][1],c=kT(s,r,o-r),l=jR(t,c),u=e(l);if(0===n)for(let e=0;e<u.length;++e)i.push(fy(0));for(let e=0;e<u.length;++e){const t=u[e];i[e]=iy(i[e],ly(o-r,t))}}for(let e=0;e<i.length;++e)i[e]=cy(i[e],r)}return i})}getDedupedMetricsNames(){const e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){const a=e[n];let s=a;if(AN(e,a)>1){const t=AN(e.slice(0,n),a);s+="_".concat(t)}t.push(s)}return t}makeTrainFunction(){return e=>{const t=[],n=e.slice(0,this.inputs.length),a=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),r=[],i=this.collectedTrainableWeights.map(e=>e.read());return[this.optimizer_.minimize(()=>{const e=[];for(let t=0;t<this.inputs.length;++t)e.push({key:this.inputs[t],value:n[t]});const i=new wE(e),o=CE(this.outputs,i,{training:!0});let c;for(let n=0;n<this.lossFunctions.length;++n){let e=(0,this.lossFunctions[n])(a[n],o[n]);null!=s[n]&&(e=PR(e,s[n]));const r=Gv(e);t.push(r),c=0===n?e:iy(c,e)}for(let n=0;n<this.metricsTensors.length;++n){let e;if(this.outputs.length>1&&n<this.outputs.length)e=t[n];else{const t=this.metricsTensors[n][0],s=this.metricsTensors[n][1];e=Gv(t(a[s],o[s]))}Qm(e),r.push(e)}return c=Gv(c),this.calculateLosses().forEach(e=>{c=iy(c,e)}),c},!0,i)].concat(r)}}makeTestFunction(){this.testFunction=e=>Xm(()=>{const t=[];let n;const a=e.slice(0,this.inputs.length),s=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),r=[];for(let e=0;e<this.inputs.length;++e)r.push({key:this.inputs[e],value:a[e]});const i=new wE(r),o=CE(this.outputs,i);for(let e=0;e<this.lossFunctions.length;++e){const a=this.lossFunctions[e],r=Gv(a(s[e],o[e]));n=0===e?r:iy(n,r),t.push(n)}for(let e=0;e<this.metricsTensors.length;++e){const n=this.metricsTensors[e][0],a=this.metricsTensors[e][1],r=Gv(n(s[a],o[a]));t.push(r)}return t})}async fit(e,t){let n,a,s,r,i,o,c,l,u,h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;try{const d=null==h.batchSize?32:h.batchSize;zR(d);const p=!1,f=await this.standardizeUserData(e,t,h.sampleWeight,h.classWeight,p,d);n=f[0],a=f[1],u=f[2];let m,g=!1;if(null!=h.validationData&&h.validationData.length>0){if(g=!0,2!==h.validationData.length)throw 3===h.validationData.length?new NN("validationData including sample weights is not supported yet."):new IN("When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; "+"".concat(h.validationData," is invalid."));i=h.validationData[0],o=h.validationData[1];const e=!0,t=await this.standardizeUserData(i,o,null,null,e,d);c=t[0],l=t[1],m=c.concat(l)}else if(null!=h.validationSplit&&h.validationSplit>0&&h.validationSplit<1){g=!0;const e=Math.floor(n[0].shape[0]*(1-h.validationSplit)),t=n[0].shape[0];c=BR(n,e,t),s=n,n=BR(n,0,e),l=BR(a,e,t),r=a,a=BR(a,0,e),m=c.concat(l)}else null!=h.validationSteps&&(g=!0);const y=n.concat(a).concat(u);this.checkTrainableWeightsConsistency();const b=this.makeTrainFunction(),x=this.getDedupedMetricsNames();let v,w;g?(this.makeTestFunction(),v=this.testFunction,w=x.slice().concat(x.map(e=>"val_"+e))):(v=null,m=[],w=x.slice());const k=qE(h.callbacks,h.yieldEvery);return await this.fitLoop(b,y,x,d,h.epochs,h.verbose,k,v,m,h.shuffle,w,h.initialEpoch,null,null)}finally{this.isTraining=!1,UR(n,e),UR(a,t),UR(s,e),UR(r,t),UR(c,i),UR(l,o),null!=u&&Ym(u)}}async fitLoop(e,t,n,a,s,r,i,o,c,l,u,h,d,p){null==a&&(a=32),null==s&&(s=1),null==l&&(l=!0),null==h&&(h=0);let f=!1;if(null!=o&&null!=c&&(f=!0),null!=p&&(f=!0,null==d))throw new IN("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const m=this.checkNumSamples(t,a,d,"steps_per_epoch");let g;null!=m&&(g=yT(0,m)),null==r&&(r=1);const{callbackList:y,history:b}=XE(i,r,s,h,m,d,a,f,u);y.setModel(this),this.history=b,await y.onTrainBegin(),this.stopTraining_=!1;for(let x=h;x<s;++x){await y.onEpochBegin(x);const s={};if(null!=d)throw new NN("stepsPerEpoch mode is not implemented yet.");{if("batch"===l)throw new NN("batch shuffling is not implemneted yet");l&&pu(g);const r=ok(g),i=WR(m,a);for(let l=0;l<i.length;++l){const u={};if(await y.onBatchBegin(l,u),Xm(()=>{const h=i[l][0],d=i[l][1],p=kT(r,h,d-h);u.batch=l,u.size=d-h;const m=jR(t,p),g=e(m);for(let e=0;e<n.length;++e){const t=n[e],a=g[e];u[t]=a,Qm(a)}if(l===i.length-1&&f){const e=this.testLoop(o,c,a);for(let t=0;t<n.length;++t){const a=n[t],r=e[t];Qm(r),s["val_"+a]=r}}}),await y.onBatchEnd(l,u),BE(u),this.stopTraining_)break}r.dispose()}if(await y.onEpochEnd(x,s),this.stopTraining_)break}return await y.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return FR(this,e,t)}async trainOnBatch(e,t){const n=await this.standardizeUserData(e,t),a=n[0],s=n[1],r=this.makeTrainFunction()(a.concat(s)),i=[];for(const o of r){const e=await o.data();i.push(e[0])}return Ym(r),UR(n[0],e),UR(n[1],t),MN(i)}getNamedWeights(e){const t=[],n=null!=e&&e.trainableOnly,a=n?this.trainableWeights:this.weights,s=this.getWeights(n);for(let r=0;r<a.length;++r)n&&!a[r].trainable||t.push({name:a[r].originalName,tensor:s[r]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(0===e.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const t=Km().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-Km().numTensors}return e}getLossIdentifiers(){let e;if("string"===typeof this.loss)e=DN(this.loss);else if(Array.isArray(this.loss)){for(const e of this.loss)if("string"!==typeof e)throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(e=>DN(e))}else{const t=Object.keys(this.loss);e={};const n=this.loss;for(const a of t){if("string"!==typeof n[a])throw new Error("Serialization of non-string loss is not supported.");e[a]=DN(n[a])}}return e}getMetricIdentifiers(){if("string"===typeof this.metrics||"function"===typeof this.metrics)return[DN(yR(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>DN(yR(e)));{const e={};for(const t in this.metrics)e[t]=DN(yR(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(null!=e.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=e.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=e.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const t=YE(NR(e.optimizer_config));let n,a;if("string"===typeof e.loss)n=ON(e.loss);else if(Array.isArray(e.loss))n=e.loss.map(e=>ON(e));else if(null!=e.loss){n={};for(const t in e.loss)n[t]=ON(e.loss[t])}if(Array.isArray(e.metrics))a=e.metrics.map(e=>ON(e));else if(null!=e.metrics){a={};for(const t in e.metrics)a[t]=ON(e.metrics[t])}this.compile({loss:n,metrics:a,optimizer:t})}async save(e,t){if("string"===typeof e){const t=wg(e);if(0===t.length)throw new IN("Cannot find any save handlers for URL '".concat(e,"'"));if(t.length>1)throw new IN("Found more than one (".concat(t.length,") save handlers for ")+"URL '".concat(e,"'"));e=t[0]}if(null==e.save)throw new IN("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const n=await tg(this.getNamedWeights(t)),a={modelTopology:this.toJSON(null,!1),format:"layers-model",generatedBy:"TensorFlow.js tfjs-layers v".concat(ER),convertedBy:null};if(null!=t&&t.includeOptimizer&&null!=this.optimizer){a.trainingConfig=this.getTrainingConfig();const e="optimizer",{data:t,specs:s}=await tg(await this.optimizer.getWeights(),e);n.specs.push(...s),n.data=hg([n.data,t])}if(null!=this.userDefinedMetadata){const e=!0;xR(this.userDefinedMetadata,this.name,e),a.userDefinedMetadata=this.userDefinedMetadata}return a.weightData=n.data,a.weightSpecs=n.specs,e.save(a)}setUserDefinedMetadata(e){xR(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}XR.className="Model",xy(XR);class YR extends XR{}YR.className="Functional",xy(YR);class QR extends XR{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=null!=e.name?e.name:ZN("sequential_"),null!=e.layers)for(const t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(e=>e<0))throw new IN("Negative dimension size caused by adding layer "+"".concat(e.name," with input shape [")+"".concat(e.inboundNodes[0].inputTensors[0].shape,"]"))}add(e){const t=e instanceof QR||e instanceof XR;let n;if(t){if(n=e,1!==n.outputs.length)throw new IN("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==n.inputs.length)throw new IN("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===e.inboundNodes.length){if(null==e.batchInputShape)throw new IN("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const t=function(e){if(null==e.batchShape&&null==e.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=e.batchShape&&null!=e.shape)throw new IN("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;null!=e.shape&&null==t&&(t=[null].concat(e.shape));let n=e.dtype;return null==n&&(n="float32"),new vE({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(t)}if(t)this.outputs=n.outputs,this.inputs=n.inputs;else{if(1!==e.inboundNodes.length)throw new IN("A layer added to a Sequential model must not already be "+"connected somewhere else. LayersModel received layer ".concat(e.name," ")+"which has ".concat(e.inboundNodes.length," pre-existing inbound ")+"connections.");if(1!==e.inboundNodes[0].outputTensors.length)throw new IN("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=xE(this.outputs[0])}this.inboundNodes=[],new gE({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:RN(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(e=>e.shape),outputShapes:this.outputs[0].shape})}else{const t=e.apply(this.outputs[0]);if(Array.isArray(t))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[t],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return null==this.model&&this.build(),this.model.call(e,t)}build(e){if(oE(e),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new XR({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log;this.built||this.build(),super.summary(e,t,n)}setWeights(e){null==this.model&&this.build(),this.model.setWeights(e)}evaluate(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this.built)throw new CN("The model needs to be compiled before being used.");return this.model.evaluate(e,t,n)}async evaluateDataset(e,t){if(!this.built)throw new CN("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return null==this.model&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this.built)throw new CN("The model needs to be compiled before being used.");return this.model.fit(e,t,n)}async fitDataset(e,t){if(!this.built)throw new CN("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t){let n,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s={};if(t instanceof Array){if(null==t[0].className||"Merge"===t[0].className)throw new IN("Legacy serialization format not supported yet.");n=t}else bu(null!=t.layers,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),n=t.layers,delete t.layers,s=t;const r=new e(s);if(!(r instanceof QR))throw new NN("Sequential.fromConfig called on non-Sequential input: ".concat(r));for(const i of n){const e=YE(i,void 0,a);a&&e.setFastWeightInitDuringBuild(!0),r.add(e)}return r}set stopTraining(e){if(null==this.model)throw new IN("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(null==this.model)throw new IN("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const t of this.layers){const n={};n.className=t.getClassName(),n.config=t.getConfig(),e.push(n)}return{name:this.name,layers:e}}}QR.className="Sequential",xy(QR);class ZR extends yy{getConfig(){return{}}}class JR extends ZR{apply(e){return function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(1!==t)throw new NN("Support for alpha values other than 1 (".concat(t,") is not implemented ")+"yet.");return Kx(e)}(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:1)}}JR.className="elu",xy(JR);class $R extends ZR{apply(e){return Bw(e)}}$R.className="selu",xy($R);class e_ extends ZR{apply(e){return _w(e)}}e_.className="relu",xy(e_);class t_ extends ZR{apply(e){return Xm(()=>Yv(6,_w(e)))}}t_.className="relu6",xy(t_);class n_ extends ZR{apply(e){return e}}n_.className="linear",xy(n_);class a_ extends ZR{apply(e){return ox(e)}}a_.className="sigmoid",xy(a_);class s_ extends ZR{apply(e){return function(e){return Xm(()=>{const t=iy(.5,ly(.2,e));return wx(t,0,1)})}(e)}}s_.className="hardSigmoid",xy(s_);class r_ extends ZR{apply(e){return Av(e)}}r_.className="softplus",xy(r_);class i_ extends ZR{apply(e){return function(e){return Xm(()=>cy(e,iy(Ty(e),1)))}(e)}}i_.className="softsign",xy(i_);class o_ extends ZR{apply(e){return lx(e)}}o_.className="tanh",xy(o_);class c_ extends ZR{apply(e){return Yw(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1)}}c_.className="softmax",xy(c_);class l_ extends ZR{apply(e){return Pv(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1)}}l_.className="logSoftmax",xy(l_);class u_ extends ZR{apply(e){return Xm(()=>Xm(()=>{const t=Math.sqrt(2),n=ly(.5,iy(1,Yx(cy(e,t))));return ly(e,n)}))}}u_.className="gelu",xy(u_);class h_ extends ZR{apply(e){return Xm(()=>ly(.5,ly(e,iy(1,lx(ly(uy(cy(2,Math.PI)),iy(e,ly(.044715,Cy(e,3)))))))))}}h_.className="gelu_new",xy(h_);class d_ extends ZR{apply(e){return Xm(()=>ly(e,lx(Av(e))))}}d_.className="mish",xy(d_);class p_ extends ZR{apply(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return Xm(()=>ly(ox(ly(e,t)),e))}}function f_(e){return e.getClassName()}function m_(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return BN(e,by.getMap().classNameMap,t,"activation")}function g_(e){if(null==e){const e={className:"linear",config:{}};return m_(e)}if("string"===typeof e){const t={};return t.className=e,t.config={},m_(t)}return e instanceof ZR?e:m_(e)}function y_(e){if(null!=e&&"object"!==typeof e)throw new Error("Argument to L1L2 regularizer's constructor is expected to be an "+"object, but received: ".concat(e))}p_.className="swish",xy(p_);class b_ extends yy{}class x_ extends b_{constructor(e){super(),y_(e),this.l1=null==e||null==e.l1?.01:e.l1,this.l2=null==e||null==e.l2?.01:e.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(e){return Xm(()=>{let t=qv([1]);return this.hasL1&&(t=iy(t,iv(ly(this.l1,Ty(e))))),this.hasL2&&(t=iy(t,iv(ly(this.l2,AT(e))))),nx(t,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}}x_.className="L1L2",xy(x_);const v_={l1l2:"L1L2"};function w_(e){return LN(e)}function k_(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return BN(e,by.getMap().classNameMap,t,"regularizer")}function S_(e){if(null==e)return null;if("string"===typeof e){return k_({className:e in v_?v_[e]:e,config:{}})}return e instanceof b_?e:k_(e)}class C_ extends bE{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,null!=e&&(this.maxValue=e.maxValue)}call(e,t){e=iE(e);let n=_w(e);return null!=this.maxValue&&(n=wx(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}}C_.className="ReLU",xy(C_);class I_ extends bE{constructor(e){super(null==e?{}:e),this.DEFAULT_ALPHA=.3,null==e&&(e={}),this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=iE(e);return Sv(n,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}I_.className="LeakyReLU",xy(I_);class N_ extends bE{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==e&&(e={}),this.supportsMasking=!0,this.alphaInitializer=aE(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=S_(e.alphaRegularizer),this.alphaConstraint=LE(e.alphaConstraint),null==e.sharedAxes)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else{if("number"!==typeof e.sharedAxes)throw new IN("Expected sharedAxes to be a number or an array of numbers, "+"but got ".concat(e.sharedAxes));this.sharedAxes=[e.sharedAxes]}}build(e){const t=(e=oE(e)).slice(1);if(null!=this.sharedAxes)for(const a of this.sharedAxes)t[a-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const n={};if(null!=this.sharedAxes)for(let a=1;a<e.length;++a)n[a]=e[a];this.inputSpec=[new pE({ndim:e.length,axes:n})],this.built=!0}call(e,t){return e=iE(e),dw(e,this.alpha.read())}getConfig(){const e={alphaInitializer:nE(this.alphaInitializer),alphaRegularizer:w_(this.alphaRegularizer),alphaConstraint:OE(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}}N_.className="PReLU",xy(N_);class T_ extends bE{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA=1,null==e&&(e={}),null!=e.alpha&&e.alpha!==this.DEFAULT_ALPHA)throw new NN("Non-default alpha value (".concat(e.alpha,") is not supported by the ")+"ELU layer yet.");this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=iE(e);return Kx(n)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}T_.className="ELU",xy(T_);class E_ extends bE{constructor(e){super(null==e?{}:e),this.DEFAULT_THETA=1,null==e&&(e={}),this.theta=null==e.theta?this.DEFAULT_THETA:e.theta}call(e,t){const n=iE(e);return ly(n,ay(yv(n,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}}E_.className="ThresholdedReLU",xy(E_);class R_ extends bE{constructor(e){super(null==e?{}:e),this.DEFAULT_AXIS=1,null==e&&(e={}),this.softmax=(new c_).apply,this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis}call(e,t){return Xm(()=>{let n=iE(e);const a=t.mask;if(null!=a){const e=ly(Iy(Kv(n.shape),ay(a,n.dtype)),fy(-1e9));n=iy(n,e)}return this.axis instanceof Array?this.axis.length>1?uv(Iy(n,Dv(n,this.axis,!0))):this.softmax(n,this.axis[0]):this.softmax(n,this.axis)})}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}function __(e,t,n){if("number"===typeof e)return RN(e,t);if(e.length!==t)throw new IN("The ".concat(n," argument must be an integer or tuple of ").concat(t," integers.")+" Received: ".concat(e.length," elements."));for(let a=0;a<t;++a){const s=e[a];if(!pT(s))throw new IN("The ".concat(n," argument must be an integer or tuple of ").concat(t)+" integers. Received: ".concat(JSON.stringify(e)," including a")+" non-integer number ".concat(s))}return e}function A_(e,t,n,a){if(null==e)return e;let s;return s="same"===n?e:e-(t+(t-1)*((arguments.length>4&&void 0!==arguments[4]?arguments[4]:1)-1))+1,Math.floor((s+a-1)/a)}function M_(e,t,n,a){if(null==e)return null;if("valid"===a)e=e*t+gT([n-t,0]);else{if("same"!==a)throw new IN("Unsupport padding mode: ".concat(a,"."));e*=t}return e}function P_(e,t){return Xm(()=>(sT(t),"channelsFirst"===t?Nk(e,[0,2,3,1]):e))}function D_(e,t){return Xm(()=>(sT(t),"channelsFirst"===t?Nk(e,[0,2,3,4,1]):e))}function O_(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",r=arguments.length>5?arguments[5]:void 0,i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:1;return Xm(()=>{if(null==r&&(r="channelsLast"),sT(r),3!==e.shape.length)throw new IN("The input of a conv1dWithBias operation should be 3, but is "+"".concat(e.shape.length," instead."));if(3!==t.shape.length)throw new IN("The kernel for a conv1dWithBias operation should be 3, but is "+"".concat(t.shape.length," instead"));if(null!=n&&1!==n.shape.length)throw new IN("The bias for a conv1dWithBias operation should be 1, but is "+"".concat(n.shape.length," instead"));if("channelsFirst"===r&&(e=Nk(e,[0,2,1])),"causal"===s)throw new NN("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=Tx(e,t,a,"same"===s?"same":"valid","NWC",i);return null!=n&&(o=PT(o,n)),o})}function F_(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[1,1],s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",r=arguments.length>5?arguments[5]:void 0,i=arguments.length>6?arguments[6]:void 0,o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null;return Xm(()=>{if(null==r&&(r="channelsLast"),sT(r),3!==e.rank&&4!==e.rank)throw new IN("conv2dWithBiasActivation expects input to be of rank 3 or 4, "+"but received ".concat(e.rank,"."));if(3!==t.rank&&4!==t.rank)throw new IN("conv2dWithBiasActivation expects kernel to be of rank 3 or 4, "+"but received ".concat(e.rank,"."));let c=P_(e,r);if("causal"===s)throw new NN("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return c=jk({x:c,filter:t,strides:a,pad:"same"===s?"same":"valid",dilations:i,dataFormat:"NHWC",bias:n,activation:o}),"channelsFirst"===r&&(c=Nk(c,[0,3,1,2])),c})}function L_(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[1,1,1],s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",r=arguments.length>5?arguments[5]:void 0,i=arguments.length>6?arguments[6]:void 0;return Xm(()=>{if(null==r&&(r="channelsLast"),sT(r),4!==e.rank&&5!==e.rank)throw new IN("conv3dWithBias expects input to be of rank 4 or 5, but received "+"".concat(e.rank,"."));if(4!==t.rank&&5!==t.rank)throw new IN("conv3dWithBias expects kernel to be of rank 4 or 5, but received "+"".concat(e.rank,"."));let o=D_(e,r);if("causal"===s)throw new NN("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=_x(o,t,a,"same"===s?"same":"valid","NDHWC",i),null!=n&&(o=PT(o,n)),"channelsFirst"===r&&(o=Nk(o,[0,4,1,2,3])),o})}R_.className="Softmax",xy(R_);class z_ extends bE{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",z_.verifyArgs(t),this.rank=e,GN(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new NN("Convolution layer for rank other than 1, 2, or 3 (".concat(this.rank,") is ")+"not implemented yet.");if(this.kernelSize=__(t.kernelSize,e,"kernelSize"),this.strides=__(null==t.strides?1:t.strides,e,"strides"),this.padding=null==t.padding?"valid":t.padding,rT(this.padding),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,sT(this.dataFormat),this.activation=g_(t.activation),this.useBias=null==t.useBias||t.useBias,this.biasInitializer=aE(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=LE(t.biasConstraint),this.biasRegularizer=S_(t.biasRegularizer),this.activityRegularizer=S_(t.activityRegularizer),this.dilationRate=__(null==t.dilationRate?1:t.dilationRate,e,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new IN("dilationRate must be a number or an array of a single number for 1D convolution, but received "+"".concat(JSON.stringify(this.dilationRate)));if(2===this.rank){if("number"===typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new IN("dilationRate must be a number or array of two numbers for 2D "+"convolution, but received ".concat(JSON.stringify(this.dilationRate)))}else if(3===this.rank)if("number"===typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new IN("dilationRate must be a number or array of three numbers for 3D "+"convolution, but received ".concat(JSON.stringify(this.dilationRate)))}static verifyArgs(e){if(_N("kernelSize"in e,"required key 'kernelSize' not in config"),"number"!==typeof e.kernelSize&&!HN(e.kernelSize,"number",1,3))throw new IN("BaseConv expects config.kernelSize to be number or number[] with "+"length 1, 2, or 3, but received ".concat(JSON.stringify(e.kernelSize),"."))}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:f_(this.activation),useBias:this.useBias,biasInitializer:nE(this.biasInitializer),biasRegularizer:w_(this.biasRegularizer),activityRegularizer:w_(this.activityRegularizer),biasConstraint:OE(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}class B_ extends z_{constructor(e,t){super(e,t),this.kernel=null,B_.verifyArgs(t),this.filters=t.filters,GN(this.filters,"filters"),this.kernelInitializer=aE(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=LE(t.kernelConstraint),this.kernelRegularizer=S_(t.kernelRegularizer)}build(e){e=oE(e);const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new IN("The channel dimension of the input should be defined. "+"Found ".concat(e[t]));const n=e[t],a=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:n}}],this.built=!0}call(e,t){return Xm(()=>{let t;e=iE(e);const n=null==this.bias?null:this.bias.read(),a=KN(this.activation.getClassName());if(null!=a&&2===this.rank)t=F_(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate,a);else{if(1===this.rank)t=O_(e,this.kernel.read(),n,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)t=F_(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new NN("convolutions greater than 3D are not implemented yet.");t=L_(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(t=this.activation.apply(t))}return t})}computeOutputShape(e){e=oE(e);const t=[],n="channelsLast"===this.dataFormat?e.slice(1,e.length-1):e.slice(2);for(let s=0;s<n.length;++s){const e=A_(n[s],this.kernelSize[s],this.padding,this.strides[s],"number"===typeof this.dilationRate?this.dilationRate:this.dilationRate[s]);t.push(e)}let a=[e[0]];return"channelsLast"===this.dataFormat?(a=a.concat(t),a.push(this.filters)):(a.push(this.filters),a=a.concat(t)),a}getConfig(){const e={filters:this.filters,kernelInitializer:nE(this.kernelInitializer),kernelRegularizer:w_(this.kernelRegularizer),kernelConstraint:OE(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||"number"!==typeof e.filters||e.filters<1)throw new IN("Convolution layer expected config.filters to be a 'number' > 0 "+"but got ".concat(JSON.stringify(e.filters)))}}class j_ extends B_{constructor(e){super(2,e),j_.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!==typeof e.kernelSize&&!HN(e.kernelSize,"number",1,2))throw new IN("Conv2D expects config.kernelSize to be number or number[] with "+"length 1 or 2, but received ".concat(JSON.stringify(e.kernelSize),"."))}}j_.className="Conv2D",xy(j_);class W_ extends B_{constructor(e){super(3,e),W_.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!==typeof e.kernelSize&&(!Array.isArray(e.kernelSize)||1!==e.kernelSize.length&&3!==e.kernelSize.length))throw new IN("Conv3D expects config.kernelSize to be number or"+" [number, number, number], but received ".concat(JSON.stringify(e.kernelSize),"."))}}W_.className="Conv3D",xy(W_);class V_ extends j_{constructor(e){if(super(e),this.inputSpec=[new pE({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new IN("Conv2DTranspose currently supports only padding modes 'same' "+"and 'valid', but received padding mode ".concat(this.padding))}build(e){if(4!==(e=oE(e)).length)throw new IN("Input should have rank 4; Received input shape: "+JSON.stringify(e));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new IN("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],a=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",a,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new pE({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return Xm(()=>{let t=iE(e);if(4!==t.shape.length)throw new IN("Conv2DTranspose.call() expects input tensor to be rank-4, but "+"received a tensor of rank-".concat(t.shape.length));const n=t.shape,a=n[0];let s,r;"channelsFirst"===this.dataFormat?(s=2,r=3):(s=1,r=2);const i=n[s],o=n[r],c=this.kernelSize[0],l=this.kernelSize[1],u=this.strides[0],h=this.strides[1],d=[a,M_(i,u,c,this.padding),M_(o,h,l,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=Nk(t,[0,2,3,1]));let p=Rx(t,this.kernel.read(),d,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(p=Nk(p,[0,3,1,2])),null!=this.bias&&(p=PT(p,this.bias.read(),this.dataFormat)),null!=this.activation&&(p=this.activation.apply(p)),p})}computeOutputShape(e){const t=(e=oE(e)).slice();let n,a,s;"channelsFirst"===this.dataFormat?(n=1,a=2,s=3):(n=3,a=1,s=2);const r=this.kernelSize[0],i=this.kernelSize[1],o=this.strides[0],c=this.strides[1];return t[n]=this.filters,t[a]=M_(t[a],o,r,this.padding),t[s]=M_(t[s],c,i,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}V_.className="Conv2DTranspose",xy(V_);class U_ extends W_{constructor(e){if(super(e),this.inputSpec=[new pE({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new IN("Conv3DTranspose currently supports only padding modes 'same' "+"and 'valid', but received padding mode ".concat(this.padding))}build(e){if(5!==(e=oE(e)).length)throw new IN("Input should have rank 5; Received input shape: "+JSON.stringify(e));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new IN("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],a=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",a,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new pE({ndim:5,axes:{[t]:n}})],this.built=!0}call(e,t){return Xm(()=>{let t=iE(e);if(5!==t.shape.length)throw new IN("Conv3DTranspose.call() expects input tensor to be rank-4, but "+"received a tensor of rank-".concat(t.shape.length));const n=t.shape,a=n[0];let s,r,i;"channelsFirst"===this.dataFormat?(i=2,s=3,r=4):(i=1,s=2,r=3);const o=n[i],c=n[s],l=n[r],u=this.kernelSize[0],h=this.kernelSize[1],d=this.kernelSize[2],p=this.strides[0],f=this.strides[1],m=this.strides[2],g=[a,M_(o,p,u,this.padding),M_(c,f,h,this.padding),M_(l,m,d,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=Nk(t,[0,2,3,4,1]));let y=Mx(t,this.kernel.read(),g,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(y=Nk(y,[0,4,1,2,3])),null!==this.bias&&(y=PT(y,this.bias.read(),this.dataFormat)),null!==this.activation&&(y=this.activation.apply(y)),y})}computeOutputShape(e){const t=(e=oE(e)).slice();let n,a,s,r;"channelsFirst"===this.dataFormat?(n=1,a=2,s=3,r=4):(n=4,a=1,s=2,r=3);const i=this.kernelSize[0],o=this.kernelSize[1],c=this.kernelSize[2],l=this.strides[0],u=this.strides[1],h=this.strides[2];return t[n]=this.filters,t[a]=M_(t[a],l,i,this.padding),t[s]=M_(t[s],u,o,this.padding),t[r]=M_(t[r],h,c,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}U_.className="Conv3DTranspose",xy(U_);class H_ extends B_{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==t.filters)throw new IN("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=t.kernelInitializer||null!=t.kernelRegularizer||null!=t.kernelConstraint)throw new IN("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=t.padding&&"same"!==t.padding&&"valid"!==t.padding)throw new IN("SeparableConv".concat(this.rank,"D supports only padding modes: ")+"'same' and 'valid', but received ".concat(JSON.stringify(t.padding)));this.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,this.depthwiseInitializer=aE(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=S_(t.depthwiseRegularizer),this.depthwiseConstraint=LE(t.depthwiseConstraint),this.pointwiseInitializer=aE(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=S_(t.pointwiseRegularizer),this.pointwiseConstraint=LE(t.pointwiseConstraint)}build(e){if((e=oE(e)).length<this.rank+2)throw new IN("Inputs to SeparableConv".concat(this.rank,"D should have rank ")+"".concat(this.rank+2,", but received input shape: ")+"".concat(JSON.stringify(e)));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t]||e[t]<0)throw new IN("The channel dimension of the inputs should be defined, "+"but found ".concat(JSON.stringify(e[t])));const n=e[t],a=this.kernelSize.concat([n,this.depthMultiplier]),s=[];for(let i=0;i<this.rank;++i)s.push(1);s.push(n*this.depthMultiplier,this.filters);const r=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",a,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,r,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",s,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,r,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,r,this.biasConstraint):this.bias=null,this.inputSpec=[new pE({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return Xm(()=>{let t;if(e=iE(e),1===this.rank)throw new NN("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(e=Nk(e,[0,2,3,1])),t=jw(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(t=PT(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),"channelsFirst"===this.dataFormat&&(t=Nk(t,[0,3,1,2])),t})}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=nE(this.depthwiseInitializer),e.pointwiseInitializer=nE(this.pointwiseInitializer),e.depthwiseRegularizer=w_(this.depthwiseRegularizer),e.pointwiseRegularizer=w_(this.pointwiseRegularizer),e.depthwiseConstraint=OE(this.depthwiseConstraint),e.pointwiseConstraint=OE(this.pointwiseConstraint),e}}H_.className="SeparableConv";class G_ extends H_{constructor(e){super(2,e)}}G_.className="SeparableConv2D",xy(G_);class q_ extends B_{constructor(e){super(1,e),q_.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if("number"!==typeof e.kernelSize&&!HN(e.kernelSize,"number",1,1))throw new IN("Conv1D expects config.kernelSize to be number or number[] with "+"length 1, but received ".concat(JSON.stringify(e.kernelSize),"."))}}q_.className="Conv1D",xy(q_);class K_ extends bE{constructor(e){super(e),"number"===typeof e.cropping?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:"number"===typeof e.cropping[0]?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=void 0===e.dataFormat?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return Xm(()=>{if(e=iE(e),"channelsLast"===this.dataFormat){const t=CT(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return CT(t,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const t=CT(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return CT(t,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}K_.className="Cropping2D",xy(K_);class X_ extends bE{constructor(e){var t;super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==e.size?this.DEFAULT_SIZE:e.size,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,sT(this.dataFormat),this.interpolation=null==e.interpolation?"nearest":e.interpolation,t=this.interpolation,UN($N,"InterpolationFormat",t)}computeOutputShape(e){if("channelsFirst"===this.dataFormat){const t=null==e[2]?null:this.size[0]*e[2],n=null==e[3]?null:this.size[1]*e[3];return[e[0],e[1],t,n]}{const t=null==e[1]?null:this.size[0]*e[1],n=null==e[2]?null:this.size[1]*e[2];return[e[0],t,n,e[3]]}}call(e,t){return Xm(()=>{let t=iE(e);const n=t.shape;if("channelsFirst"===this.dataFormat){t=Nk(t,[0,2,3,1]);const e=this.size[0]*n[2],a=this.size[1]*n[3],s="nearest"===this.interpolation?HS.resizeNearestNeighbor(t,[e,a]):HS.resizeBilinear(t,[e,a]);return Nk(s,[0,3,1,2])}{const e=this.size[0]*n[1],a=this.size[1]*n[2];return"nearest"===this.interpolation?HS.resizeNearestNeighbor(t,[e,a]):HS.resizeBilinear(t,[e,a])}})}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}}X_.className="UpSampling2D",xy(X_);class Y_ extends z_{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=aE(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=LE(e.depthwiseConstraint),this.depthwiseRegularizer=S_(e.depthwiseRegularizer)}build(e){if((e=oE(e)).length<4)throw new IN("Inputs to DepthwiseConv2D should have rank 4. "+"Received input shape: ".concat(JSON.stringify(e),"."));const t="channelsFirst"===this.dataFormat?1:3;if(null==e[t]||e[t]<0)throw new IN("The channel dimension of the inputs to DepthwiseConv2D should "+"be defined, but is not (".concat(e[t],")."));const n=e[t],a=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",a,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return Xm(()=>{let t=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[1,1],a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"valid",s=arguments.length>4?arguments[4]:void 0,r=arguments.length>5?arguments[5]:void 0;return Xm(()=>{null==s&&(s="channelsLast"),sT(s);let i=P_(e,s);if(4!==e.rank)throw new IN("Input for depthwiseConv2d is required to be 4-D, but is instead "+"".concat(e.rank,"-D"));if(4!==t.rank)throw new IN("depthwiseKernel is required to be 4-D, but is instead "+"".concat(t.rank,"-D"));return i=Bx(i,t,n,"same"===a?"same":"valid","NHWC",r),"channelsFirst"===s&&(i=Nk(i,[0,3,1,2])),i})}(e=iE(e),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(t=PT(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),t})}computeOutputShape(e){e=oE(e);const t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],a="channelsFirst"===this.dataFormat?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,s=A_(t,this.kernelSize[0],this.padding,this.strides[0]),r=A_(n,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[e[0],a,s,r]:[e[0],s,r,a]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=nE(this.depthwiseInitializer),e.depthwiseRegularizer=w_(this.depthwiseRegularizer),e.depthwiseConstraint=OE(this.depthwiseRegularizer),e}}function Q_(e,t,n,a){if(Array.isArray(e)){if(null!=t||null!=n)throw new IN("When inputs is an array, neither initialState or constants should be provided");null!=a&&(n=e.slice(e.length-a,e.length),e=e.slice(0,e.length-a)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function s(e){return null==e||Array.isArray(e)?e:[e]}return{inputs:e,initialState:t=s(t),constants:n=s(n)}}function Z_(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=arguments.length>4?arguments[4]:void 0,r=arguments.length>5?arguments[5]:void 0,i=arguments.length>6&&void 0!==arguments[6]&&arguments[6],o=arguments.length>7&&void 0!==arguments[7]&&arguments[7];return Xm(()=>{const c=t.shape.length;if(c<3)throw new IN("Input should be at least 3D, but is ".concat(c,"D."));const l=[1,0].concat(yT(2,c));if(t=Nk(t,l),null!=r)throw new NN("The rnn() functoin of the deeplearn.js backend does not support constants yet.");i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=s&&(s=ay(ay(s,"bool"),"float32"),s.rank===c-1&&(s=hv(s,-1)),s=Nk(s,l)),a&&(t=Mw(t,0),null!=s&&(s=Mw(s,0)));const u=[];let h,d=n;const p=t.shape[0],f=vk(t);let m,g;null!=s&&(m=vk(s));for(let t=0;t<p;++t){const n=f[t],a=Xm(()=>e(n,d));if(null==s)h=a[0],d=a[1];else{const e=Xm(()=>{const e=m[t],n=Iy(aw(e),e);return{output:iy(ly(a[0],e),ly(d[0],n)),newStates:d.map((t,s)=>iy(ly(a[1][s],e),ly(t,n)))}});h=e.output,d=e.newStates}o&&u.push(h)}if(o){g=ak(u,1)}return[h,g,d]})}Y_.className="DepthwiseConv2D",xy(Y_);class J_ extends bE{constructor(e){let t;if(super(e),null==e.cell)throw new IN("cell property is missing for the constructor of RNN.");if(t=Array.isArray(e.cell)?new iA({cells:e.cell}):e.cell,null==t.stateSize)throw new IN("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=null!=e.returnSequences&&e.returnSequences,this.returnState=null!=e.returnState&&e.returnState,this.goBackwards=null!=e.goBackwards&&e.goBackwards,this._stateful=null!=e.stateful&&e.stateful,this.unroll=null!=e.unroll&&e.unroll,this.supportsMasking=!0,this.inputSpec=[new pE({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(null==this.states_){return yT(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map(e=>null)}return this.states_}setStates(e){this.states_=e}computeOutputShape(e){sE(e)&&(e=e[0]);let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);const n=t[0];let a;if(a=this.returnSequences?[e[0],e[1],n]:[e[0],n],this.returnState){const n=[];for(const a of t)n.push([e[0],a]);return[a].concat(n)}return a}computeMask(e,t){return Xm(()=>{Array.isArray(t)&&(t=t[0]);const e=this.returnSequences?t:null;if(this.returnState){const t=this.states.map(e=>null);return[e].concat(t)}return e})}get states(){if(null==this.states_){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let n=0;n<e;++n)t.push(null);return t}return this.states_}set states(e){this.states_=e}build(e){if(null!=this.numConstants)throw new NN("Constants support is not implemented in RNN yet.");sE(e)&&(e=e[0]);const t=this.stateful?e[0]:null,n=e.slice(2);this.inputSpec[0]=new pE({shape:[t,null,...n]});const a=[e[0]].concat(e.slice(2));let s;if(this.cell.build(a),s=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!Su(this.stateSpec.map(e=>e.shape[e.shape.length-1]),s))throw new IN("An initialState was passed that is not compatible with "+"cell.stateSize. Received stateSpec=".concat(this.stateSpec,"; ")+"However cell.stateSize is ".concat(this.cell.stateSize))}else this.stateSpec=s.map(e=>new pE({shape:[null,e]}));this.stateful&&this.resetStates()}resetStates(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];Xm(()=>{if(!this.stateful)throw new SN("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape[0];if(null==n)throw new IN("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(e=>qv([n,e])):this.states_=[qv([n,this.cell.stateSize])];else if(null==e)Ym(this.states_),null!=this.keptStates&&(Ym(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(e=>qv([n,e])):this.states_[0]=qv([n,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new IN("Layer ".concat(this.name," expects ").concat(this.states_.length," state(s), ")+"but it received ".concat(e.length," state value(s). Input ")+"received: ".concat(e));!0===t?this.keptStates.push(this.states_.slice()):Ym(this.states_);for(let t=0;t<this.states_.length;++t){const a=e[t],s=Array.isArray(this.cell.stateSize)?this.cell.stateSize[t]:this.cell.stateSize,r=[n,s];if(!Su(a.shape,r))throw new IN("State ".concat(t," is incompatible with layer ").concat(this.name,": ")+"expected shape=".concat(r,", received shape=").concat(a.shape));this.states_[t]=a}}this.states_=this.states_.map(e=>Qm(e.clone()))})}apply(e,t){let n=null==t?null:t.initialState,a=null==t?null:t.constants;null==t&&(t={});const s=Q_(e,n,a,this.numConstants);e=s.inputs,n=s.initialState,a=s.constants;let r=[],i=[];if(null!=n){t.initialState=n,r=r.concat(n),this.stateSpec=[];for(const e of n)this.stateSpec.push(new pE({shape:e.shape}));i=i.concat(this.stateSpec)}null!=a&&(t.constants=a,r=r.concat(a),this.numConstants=a.length);if(r[0]instanceof fE){const n=[e].concat(r),a=this.inputSpec.concat(i),s=this.inputSpec;this.inputSpec=a;const o=super.apply(n,t);return this.inputSpec=s,o}return super.apply(e,t)}call(e,t){return Xm(()=>{const n=null==t?null:t.mask,a=null==t?null:t.training;let s=null==t?null:t.initialState;e=iE(e),null==s&&(s=this.stateful?this.states_:this.getInitialState(e));const r=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(s.length!==r)throw new IN("RNN Layer has ".concat(r," state(s) but was passed ")+"".concat(s.length," initial state(s)."));this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const i={training:a},o=Z_((e,t)=>{const n=this.cell.call([e].concat(t),i);return[n[0],n.slice(1)]},e,s,this.goBackwards,n,null,this.unroll,this.returnSequences),c=o[0],l=o[1],u=o[2];this.stateful&&this.resetStates(u,a);const h=this.returnSequences?l:c;return this.returnState?[h].concat(u):h})}getInitialState(e){return Xm(()=>{let t=qv(e.shape);return t=iv(t,[1,2]),t=wT(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(e=>e>1?TT(t,[1,e]):t):this.cell.stateSize>1?[TT(t,[1,this.cell.stateSize])]:[t]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(t.numConstants=this.numConstants);const n=this.cell.getConfig();return this.getClassName()===J_.className&&(t.cell={className:this.cell.getClassName(),config:n}),Object.assign(Object.assign(Object.assign({},n),e),t)}static fromConfig(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const a=YE(t.cell,n);return new e(Object.assign(t,{cell:a}))}}J_.className="RNN",xy(J_);class $_ extends bE{}class eA extends $_{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,GN(this.units,"units"),this.activation=g_(null==e.activation?this.DEFAULT_ACTIVATION:e.activation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=aE(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=aE(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=aE(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=S_(e.kernelRegularizer),this.recurrentRegularizer=S_(e.recurrentRegularizer),this.biasRegularizer=S_(e.biasRegularizer),this.kernelConstraint=LE(e.kernelConstraint),this.recurrentConstraint=LE(e.recurrentConstraint),this.biasConstraint=LE(e.biasConstraint),this.dropout=mT([1,gT([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=mT([1,gT([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=oE(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return Xm(()=>{if(2!==e.length)throw new IN("SimpleRNNCell expects 2 input Tensors, got ".concat(e.length,"."));let n=e[1];e=e[0];const a=null!=t.training&&t.training;let s;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=oA({ones:()=>aw(e),rate:this.dropout,training:a,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=oA({ones:()=>aw(n),rate:this.recurrentDropout,training:a,dropoutFunc:this.dropoutFunc}));const r=this.dropoutMask,i=this.recurrentDropoutMask;s=RT(null!=r?ly(e,r):e,this.kernel.read()),null!=this.bias&&(s=PT(s,this.bias.read())),null!=i&&(n=ly(n,i));let o=iy(s,RT(n,this.recurrentKernel.read()));return null!=this.activation&&(o=this.activation.apply(o)),[o,o]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:f_(this.activation),useBias:this.useBias,kernelInitializer:nE(this.kernelInitializer),recurrentInitializer:nE(this.recurrentInitializer),biasInitializer:nE(this.biasInitializer),kernelRegularizer:w_(this.kernelRegularizer),recurrentRegularizer:w_(this.recurrentRegularizer),biasRegularizer:w_(this.biasRegularizer),activityRegularizer:w_(this.activityRegularizer),kernelConstraint:OE(this.kernelConstraint),recurrentConstraint:OE(this.recurrentConstraint),biasConstraint:OE(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}}eA.className="SimpleRNNCell",xy(eA);class tA extends J_{constructor(e){e.cell=new eA(e),super(e)}call(e,t){return Xm(()=>{null!=this.cell.dropoutMask&&(Ym(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Ym(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,a=null==t?null:t.training,s=null==t?null:t.initialState;return super.call(e,{mask:n,training:a,initialState:s})})}static fromConfig(e,t){return new e(t)}}tA.className="SimpleRNN",xy(tA);class nA extends $_{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new IN("GRUCell does not support reset_after parameter set to true.");this.units=e.units,GN(this.units,"units"),this.activation=g_(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=g_(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=aE(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=aE(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=aE(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=S_(e.kernelRegularizer),this.recurrentRegularizer=S_(e.recurrentRegularizer),this.biasRegularizer=S_(e.biasRegularizer),this.kernelConstraint=LE(e.kernelConstraint),this.recurrentConstraint=LE(e.recurrentConstraint),this.biasConstraint=LE(e.biasConstraint),this.dropout=mT([1,gT([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=mT([1,gT([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){const t=(e=oE(e))[e.length-1];this.kernel=this.addWeight("kernel",[t,3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return Xm(()=>{if(2!==e.length)throw new IN("GRUCell expects 2 input Tensors (inputs, h, c), got "+"".concat(e.length,"."));const n=null!=t.training&&t.training;let a=e[1];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=oA({ones:()=>aw(e),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=oA({ones:()=>aw(a),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));const s=this.dropoutMask,r=this.recurrentDropoutMask;let i,o,c;0<this.dropout&&this.dropout<1&&(e=ly(e,s[0]));let l=RT(e,this.kernel.read());this.useBias&&(l=PT(l,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(a=ly(a,r[0]));const u=this.recurrentKernel.read(),[h,d]=$w(u,[2*this.units,this.units],u.rank-1),p=RT(a,h),[f,m,g]=$w(l,3,l.rank-1),[y,b]=$w(p,2,p.rank-1);i=this.recurrentActivation.apply(iy(f,y)),o=this.recurrentActivation.apply(iy(m,b));const x=RT(ly(o,a),d);c=this.activation.apply(iy(g,x));const v=iy(ly(i,a),ly(iy(1,_v(i)),c));return[v,v]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:f_(this.activation),recurrentActivation:f_(this.recurrentActivation),useBias:this.useBias,kernelInitializer:nE(this.kernelInitializer),recurrentInitializer:nE(this.recurrentInitializer),biasInitializer:nE(this.biasInitializer),kernelRegularizer:w_(this.kernelRegularizer),recurrentRegularizer:w_(this.recurrentRegularizer),biasRegularizer:w_(this.biasRegularizer),activityRegularizer:w_(this.activityRegularizer),kernelConstraint:OE(this.kernelConstraint),recurrentConstraint:OE(this.recurrentConstraint),biasConstraint:OE(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}}nA.className="GRUCell",xy(nA);class aA extends J_{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new nA(e),super(e)}call(e,t){return Xm(()=>{null!=this.cell.dropoutMask&&(Ym(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Ym(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,a=null==t?null:t.training,s=null==t?null:t.initialState;return super.call(e,{mask:n,training:a,initialState:s})})}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}}aA.className="GRU",xy(aA);class sA extends $_{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,GN(this.units,"units"),this.activation=g_(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=g_(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=aE(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=aE(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=aE(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=S_(e.kernelRegularizer),this.recurrentRegularizer=S_(e.recurrentRegularizer),this.biasRegularizer=S_(e.biasRegularizer),this.kernelConstraint=LE(e.kernelConstraint),this.recurrentConstraint=LE(e.recurrentConstraint),this.biasConstraint=LE(e.biasConstraint),this.dropout=mT([1,gT([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=mT([1,gT([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;const n=(e=oE(e))[e.length-1];let a;if(this.kernel=this.addWeight("kernel",[n,4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const e=this.biasInitializer,n=this.units;a=new((t=class extends zT{apply(t,a){const s=e.apply([n]),r=(new jT).apply([n]),i=e.apply([2*n]);return NT(NT(s,r),i)}}).className="CustomInit",t)}else a=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,a,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return Xm(()=>{const n=null!=t.training&&t.training;if(3!==e.length)throw new IN("LSTMCell expects 3 input Tensors (inputs, h, c), got "+"".concat(e.length,"."));let a=e[1];const s=e[2];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=oA({ones:()=>aw(e),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=oA({ones:()=>aw(a),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const r=this.dropoutMask,i=this.recurrentDropoutMask;let o,c,l,u;0<this.dropout&&this.dropout<1&&(e=ly(e,r[0]));let h=RT(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(a=ly(a,i[0])),h=iy(h,RT(a,this.recurrentKernel.read())),this.useBias&&(h=PT(h,this.bias.read()));const[d,p,f,m]=$w(h,4,h.rank-1);o=this.recurrentActivation.apply(d),c=this.recurrentActivation.apply(p),l=iy(ly(c,s),ly(o,this.activation.apply(f))),u=this.recurrentActivation.apply(m);const g=ly(u,this.activation.apply(l));return[g,g,l]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:f_(this.activation),recurrentActivation:f_(this.recurrentActivation),useBias:this.useBias,kernelInitializer:nE(this.kernelInitializer),recurrentInitializer:nE(this.recurrentInitializer),biasInitializer:nE(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:w_(this.kernelRegularizer),recurrentRegularizer:w_(this.recurrentRegularizer),biasRegularizer:w_(this.biasRegularizer),activityRegularizer:w_(this.activityRegularizer),kernelConstraint:OE(this.kernelConstraint),recurrentConstraint:OE(this.recurrentConstraint),biasConstraint:OE(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}}sA.className="LSTMCell",xy(sA);class rA extends J_{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new sA(e),super(e)}call(e,t){return Xm(()=>{null!=this.cell.dropoutMask&&(Ym(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Ym(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,a=null==t?null:t.training,s=null==t?null:t.initialState;return super.call(e,{mask:n,training:a,initialState:s})})}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}}rA.className="LSTM",xy(rA);class iA extends $_{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return Xm(()=>{let n=e.slice(1);const a=[];for(const e of this.cells.slice().reverse())Array.isArray(e.stateSize)?a.push(n.splice(0,e.stateSize.length)):a.push(n.splice(0,1));a.reverse();const s=[];let r;for(let i=0;i<this.cells.length;++i){const o=this.cells[i];n=a[i],r=0===i?[e[0]].concat(n):[r[0]].concat(n),r=o.call(r,t),s.push(r.slice(1))}n=[];for(const e of s.slice().reverse())n.push(...e);return[r[0]].concat(n)})}build(e){let t;sE(e)&&(e=e[0]),this.cells.forEach((n,a)=>{cT("RNNCell_".concat(a),()=>{n.build(e),t=Array.isArray(n.stateSize)?n.stateSize[0]:n.stateSize,e=[e[0],t]})}),this.built=!0}getConfig(){const e=super.getConfig(),t={cells:this.cells.map(e=>({className:e.getClassName(),config:e.getConfig()}))};return Object.assign(Object.assign({},e),t)}static fromConfig(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const a=[];for(const s of t.cells)a.push(YE(s,n));return new e({cells:a})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const e of this.cells)t.push(...e.trainableWeights);return t.concat(e)}return e}getWeights(){const e=[];for(const t of this.cells)e.push(...t.weights);return hE(e)}setWeights(e){const t=[];for(const n of this.cells){const a=n.weights.length,s=e.splice(a);for(let e=0;e<n.weights.length;++e)t.push([n.weights[e],s[e]])}dE(t)}}function oA(e){const{ones:t,rate:n,training:a=!1,count:s=1,dropoutFunc:r}=e,i=()=>null!=r?r(t(),n):DT(t(),n),o=()=>OT(i,t,a);if(!s||s<=1)return Qm(o().clone());return Array(s).fill(void 0).map(o).map(e=>Qm(e.clone()))}iA.className="StackedRNNCells",xy(iA);var cA=function(e,t){var n={};for(var a in e)Object.prototype.hasOwnProperty.call(e,a)&&t.indexOf(a)<0&&(n[a]=e[a]);if(null!=e&&"function"===typeof Object.getOwnPropertySymbols){var s=0;for(a=Object.getOwnPropertySymbols(e);s<a.length;s++)t.indexOf(a[s])<0&&Object.prototype.propertyIsEnumerable.call(e,a[s])&&(n[a[s]]=e[a[s]])}return n};class lA extends J_{constructor(e){if(e.unroll)throw new NN("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new NN("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new pE({ndim:5})]}call(e,t){return Xm(()=>{if(null!=this.cell.dropoutMask&&(Ym(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Ym(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new IN("ConvRNN2D cell does not support constants");const n=null==t?null:t.mask,a=null==t?null:t.training,s=null==t?null:t.initialState;return super.call(e,{mask:n,training:a,initialState:s})})}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return Xm(()=>{const{stateSize:t}=this.cell,n=e.shape,a=this.computeSingleOutputShape(n),s=qv([a[0],...a.slice(2)]);return Array.isArray(t)?Array(t.length).fill(s):[s]})}resetStates(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];Xm(()=>{if(!this.stateful)throw new SN("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape,a=this.computeSingleOutputShape(n),s=[a[0],...a.slice(2)];if(null==n[0])throw new IN("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>qv(s)):this.states_=[qv(s)];else if(null==e)Ym(this.states_),null!=this.keptStates&&(Ym(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>qv(s)):this.states_[0]=qv(s);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new IN("Layer ".concat(this.name," expects ").concat(this.states_.length," state(s), ")+"but it received ".concat(e.length," state value(s). Input ")+"received: ".concat(e));t?this.keptStates.push(this.states_.slice()):Ym(this.states_);for(let t=0;t<this.states_.length;++t){const n=e[t],a=s;if(!Su(n.shape,a))throw new IN("State ".concat(t," is incompatible with layer ").concat(this.name,": ")+"expected shape=".concat(a,", received shape=").concat(n.shape));this.states_[t]=n}}this.states_=this.states_.map(e=>Qm(e.clone()))})}computeSingleOutputShape(e){const{dataFormat:t,filters:n,kernelSize:a,padding:s,strides:r,dilationRate:i}=this.cell,o="channelsFirst"===t,c=e[o?3:2],l=e[o?4:3],u=A_(c,a[0],s,r[0],i[0]),h=A_(l,a[1],s,r[1],i[1]);return[...e.slice(0,2),...o?[n,u,h]:[u,h,n]]}}lA.className="ConvRNN2D";class uA extends sA{constructor(e){const{filters:t,kernelSize:n,strides:a,padding:s,dataFormat:r,dilationRate:i}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,GN(this.filters,"filters"),this.kernelSize=__(n,2,"kernelSize"),this.kernelSize.forEach(e=>GN(e,"kernelSize")),this.strides=__(a||1,2,"strides"),this.strides.forEach(e=>GN(e,"strides")),this.padding=s||"valid",rT(this.padding),this.dataFormat=r||"channelsLast",sT(this.dataFormat),this.dilationRate=__(i||1,2,"dilationRate"),this.dilationRate.forEach(e=>GN(e,"dilationRate"))}build(e){var t;e=oE(e);const n="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[n])throw new IN("The channel dimension of the input should be defined. "+"Found ".concat(e[n]));const a=e[n],s=this.kernelSize.concat([a,4*this.filters]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const r=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",r,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let e;if(this.unitForgetBias){const n=this.biasInitializer,a=this.filters;e=new((t=class extends zT{apply(e,t){return IT([n.apply([a]),Kv([a]),n.apply([2*a])])}}).className="CustomInit",t)}else e=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,e,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return Xm(()=>{if(3!==e.length)throw new IN("ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got "+"".concat(e.length,"."));const n=t.training||!1,a=e[0],s=e[1],r=e[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=oA({ones:()=>aw(a),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const i=this.dropoutMask,o=(e,t,n)=>t&&t[n]?ly(t[n],e):e;let c=o(a,i,0),l=o(a,i,1),u=o(a,i,2),h=o(a,i,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=oA({ones:()=>aw(s),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const d=this.recurrentDropoutMask;let p=o(s,d,0),f=o(s,d,1),m=o(s,d,2),g=o(s,d,3);const[y,b,x,v]=$w(this.kernel.read(),4,3),[w,k,S,C]=this.useBias?$w(this.bias.read(),4):[null,null,null,null];c=this.inputConv(c,y,w,this.padding),l=this.inputConv(l,b,k,this.padding),u=this.inputConv(u,x,S,this.padding),h=this.inputConv(h,v,C,this.padding);const[I,N,T,E]=$w(this.recurrentKernel.read(),4,3);p=this.recurrentConv(p,I),f=this.recurrentConv(f,N),m=this.recurrentConv(m,T),g=this.recurrentConv(g,E);const R=this.recurrentActivation.apply(iy(c,p)),_=this.recurrentActivation.apply(iy(l,f)),A=iy(ly(_,r),ly(R,this.activation.apply(iy(u,m)))),M=ly(this.recurrentActivation.apply(iy(h,g)),this.activation.apply(A));return[M,M,A]})}getConfig(){const e=super.getConfig(),{units:t}=e,n=cA(e,["units"]),a={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},n),a)}inputConv(e,t,n,a){const s=Nx(e,t,this.strides,a||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return n?PT(s,n,this.dataFormat):s}recurrentConv(e,t){return Nx(e,t,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}uA.className="ConvLSTM2DCell",xy(uA);class hA extends lA{constructor(e){const t=new uA(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}}hA.className="ConvLSTM2D",xy(hA);class dA extends bE{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(null==this.noiseShape)return this.noiseShape;const t=e.shape,n=[];for(let a=0;a<this.noiseShape.length;++a)n.push(null==this.noiseShape[a]?t[a]:this.noiseShape[a]);return n}call(e,t){return Xm(()=>{this.invokeCallHook(e,t);const n=iE(e);if(0<this.rate&&this.rate<1){const e=null!=t.training&&t.training,a=this.getNoiseShape(n);return OT(()=>DT(n,this.rate,a,this.seed),()=>n,e)}return e})}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}}dA.className="Dropout",xy(dA);class pA extends dA{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const t=e.shape;return[t[0],1,t[2]]}}pA.className="SpatialDropout1D",xy(pA);class fA extends bE{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==e.batchInputShape&&null==e.inputShape&&null!=e.inputDim){let t=null;null!=e.batchSize&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,GN(this.units,"units"),this.activation=g_(e.activation),null!=e.useBias&&(this.useBias=e.useBias),this.kernelInitializer=aE(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=aE(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=LE(e.kernelConstraint),this.biasConstraint=LE(e.biasConstraint),this.kernelRegularizer=S_(e.kernelRegularizer),this.biasRegularizer=S_(e.biasRegularizer),this.activityRegularizer=S_(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){const t=(e=oE(e))[e.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){const t=(e=oE(e)).slice();return t[t.length-1]=this.units,t}call(e,t){return Xm(()=>{this.invokeCallHook(e,t);const n=iE(e),a=KN(this.activation.getClassName());let s;return null!=a?s=RT(n,this.kernel.read(),a,this.bias?this.bias.read():null):(s=RT(n,this.kernel.read()),null!=this.bias&&(s=PT(s,this.bias.read())),null!=this.activation&&(s=this.activation.apply(s))),s})}getConfig(){const e={units:this.units,activation:f_(this.activation),useBias:this.useBias,kernelInitializer:nE(this.kernelInitializer),biasInitializer:nE(this.biasInitializer),kernelRegularizer:w_(this.kernelRegularizer),biasRegularizer:w_(this.biasRegularizer),activityRegularizer:w_(this.activityRegularizer),kernelConstraint:OE(this.kernelConstraint),biasConstraint:OE(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}fA.className="Dense",xy(fA);class mA extends bE{constructor(e){super(e=e||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=oE(e);for(const t of e.slice(1))if(null==t)throw new IN('The shape of the input to "Flatten" is not fully defined '+"(got ".concat(e.slice(1),"). Make sure to pass a complete ")+'"input_shape" or "batch_input_shape" argument to the first layer in your model.');return[e[0],fT(e,1)]}call(e,t){return Xm(()=>{this.invokeCallHook(e,t);let n=iE(e);if("channelsFirst"===this.dataFormat&&n.rank>1){const e=[0];for(let t=2;t<n.rank;++t)e.push(t);e.push(1),n=Nk(n,e)}return function(e){if(e.rank<=1)throw new IN("batchFlatten requires a minimum rank of 2. Got rank: ".concat(e.rank,"."));const t=[e.shape[0],fT(e.shape,1)];return nx(e,t)}(n)})}getConfig(){const e={};null!=this.dataFormat&&(e.dataFormat=this.dataFormat);const t=super.getConfig();return Object.assign(e,t),e}}mA.className="Flatten",xy(mA);class gA extends bE{constructor(e){super(e),this.supportsMasking=!0,this.activation=g_(e.activation)}call(e,t){return Xm(()=>{this.invokeCallHook(e,t);const n=iE(e);return this.activation.apply(n)})}getConfig(){const e={activation:f_(this.activation)},t=super.getConfig();return Object.assign(e,t),e}}gA.className="Activation",xy(gA);class yA extends bE{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return Xm(()=>{return e=iE(e),t=e,n=this.n,Xm(()=>{if(2!==t.shape.length)throw new IN("repeat() expects a rank-2 tensor, but received a "+"rank-".concat(t.shape.length," tensor."));return TT(wT(t,1),[1,n,1])});var t,n})}getConfig(){const e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}}yA.className="RepeatVector",xy(yA);class bA extends bE{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||null==e}fixUnknownDimension(e,t){const n="Total size of new array must be unchanged.",a=t.slice();let s=1,r=null;for(let o=0;o<a.length;++o){const e=a[o];if(this.isUnknown(e)){if(null!==r)throw new IN("Can only specifiy one unknown dimension.");r=o}else s*=e}const i=fT(e);if(null!==r){if(0===s||i%s!==0)throw new IN(n);a[r]=i/s}else if(i!==s)throw new IN(n);return a}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return Xm(()=>{this.invokeCallHook(e,t);const n=iE(e),a=n.shape,s=a.slice(0,1).concat(this.fixUnknownDimension(a.slice(1),this.targetShape));return nx(n,s)})}getConfig(){const e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}}bA.className="Reshape",xy(bA);class xA extends bE{constructor(e){if(super(e),null==e.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error("Permute constructor requires `dims` to be an Array, but received "+"".concat(e.dims," instead."));const t=yT(1,e.dims.length+1);if(!Su(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new pE({ndim:this.dims.length+1})]}computeOutputShape(e){const t=(e=oE(e)).slice();return this.dims.forEach((n,a)=>{t[a+1]=e[n]}),t}call(e,t){return Nk(iE(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}}xA.className="Permute",xy(xA);class vA extends bE{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,this.maskValue=null!=e?null==e.maskValue?0:e.maskValue:0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){const n=iE(e);return Pb(tw(n,this.maskValue),-1)}call(e,t){return Xm(()=>{this.invokeCallHook(e,t);const n=iE(e),a=Pb(tw(n,this.maskValue),-1,!0);return ly(n,ay(a,n.dtype))})}}vA.className="Masking",xy(vA);class wA extends bE{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==e.batchInputShape&&null==e.inputShape){let t=null;null!=e.batchSize&&(t=e.batchSize),null==e.inputLength?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(PN(e.inputLength))}this.inputDim=e.inputDim,GN(this.inputDim,"inputDim"),this.outputDim=e.outputDim,GN(this.outputDim,"outputDim"),this.embeddingsInitializer=aE(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=S_(e.embeddingsRegularizer),this.activityRegularizer=S_(e.activityRegularizer),this.embeddingsConstraint=LE(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return Xm(()=>this.maskZero?(e=iE(e),tw(e,dy(e))):null)}computeOutputShape(e){if(e=oE(e),null==this.inputLength)return[...e,this.outputDim];const t=PN(this.inputLength);if(t.length!==e.length-1)throw new IN('"inputLength" is '.concat(this.inputLength,", but received ")+"input shape has shape ".concat(e));{let n=0;for(let a=0;a<t.length;++a){const s=t[a],r=e[a+1];if(null!=s&&null!=r&&s!==r)throw new IN('"inputLength" is '.concat(this.inputLength,", but received ")+"input shape has shape ".concat(e));null==s&&(t[n]=r),n++}}return[e[0],...t,this.outputDim]}call(e,t){return Xm(()=>{this.invokeCallHook(e,t);let n=iE(e);"int32"!==n.dtype&&(n=vT(n,"int32"));const a=_T(this.embeddings.read(),nx(n,[n.size]));return nx(a,oE(this.computeOutputShape(n.shape)))})}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:nE(this.embeddingsInitializer),embeddingsRegularizer:w_(this.embeddingsRegularizer),activityRegularizer:w_(this.activityRegularizer),embeddingsConstraint:OE(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}}wA.className="Embedding",xy(wA);class kA extends bE{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new NN}computeElementwiseOpOutputShape(e,t){if(null==e||null==t)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(0===t.length)return e;const n=e.slice(0,e.length-t.length);for(let a=0;a<t.length;++a){const s=e[e.length-t.length+a],r=t[a];if(null==s||null==r||s<0||r<0)n.push(null);else if(1===s)n.push(r);else if(1===r)n.push(s);else{if(s!==r)throw new IN("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(s)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[oE(e)]),e.length<2)throw new IN("A merge layer should be called on an Array of at least 2 inputs."+" Got ".concat(e.length," input(s)."));let t=[];for(const s of e)null!=s&&null!==s[0]&&t.push(s[0]);if(t=WN(t),t.length>1)throw new IN("Can not merge tensors with different batch sizes. "+"Got tensors with shapes: ".concat(JSON.stringify(e),"."));let n=null==e[0]?null:e[0].slice(1);for(let s=1;s<e.length;++s){const t=null==e[s]?null:e[s].slice(1);n=this.computeElementwiseOpOutputShape(n,t)}const a=e.map(e=>e.length);-1===e.indexOf(null)&&1===WN(a).length?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return Xm(()=>{if(this.reshapeRequired){const t=[],n=e.map(e=>e.rank);if(-1===n.indexOf(null)){const a=gT(n);for(let n of e){const e=n.rank;for(let t=0;t<a-e;++t)n=wT(n,1);t.push(n)}return this.mergeFunction(t)}{let n=!1;for(const r of e){const e=r.rank;if(null==e){const e=r.shape,a=e[0],s=e.slice(1).concat([a]);let i=nx(r,[a].concat(fT(e.slice(1))));i=Nk(i,[1,0]),i=nx(i,s),t.push(i),n=!0}else if(e>1){const a=yT(1,e).concat([0]);t.push(Nk(r,a)),n=!0}else t.push(r)}let a=this.mergeFunction(t);const s=a.rank;if(n)if(null==s){const e=a.shape,t=e[e.length-1],n=[t].concat(e.slice(0,e.length-1));a=nx(Nk(nx(a,[-1,t]),[1,0]),n)}else if(s>1){const e=[s-1].concat(yT(0,s-1));a=Nk(a,e)}return a}}return this.mergeFunction(e)})}computeOutputShape(e){let t;t=null==e[0]?null:e[0].slice(1);for(let a=1;a<e.length;++a){const n=null==e[a]?null:e[a].slice(1);t=this.computeElementwiseOpOutputShape(t,n)}let n=[];for(const a of e)null!=a&&null!==a[0]&&n.push(a[0]);return n=WN(n),t=1===n.length?n.concat(t):[null].concat(t),t}computeMask(e,t){return Xm(()=>{if(null==t)return null;if(!Array.isArray(t))throw new IN("`mask` should be an Array");if(!Array.isArray(e))throw new IN("`inputs` should be an Array");if(t.length!==e.length)throw new IN("The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths "+"(".concat(e.length," vs ").concat(t.length,")"));if(t.every(e=>null==e))return null;let n=(t=t.map(e=>null==e?e:hv(e,0)))[0];for(let e=1;e<t.length-1;++e)n=Ov(n,t[e]);return n})}}class SA extends kA{constructor(e){super(e)}mergeFunction(e){return Xm(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=iy(t,e[n]);return t})}}SA.className="Add",xy(SA);class CA extends kA{constructor(e){super(e)}mergeFunction(e){return Xm(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=ly(t,e[n]);return t})}}CA.className="Multiply",xy(CA);class IA extends kA{constructor(e){super(e)}mergeFunction(e){return Xm(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=iy(t,e[n]);return ly(1/e.length,t)})}}IA.className="Average",xy(IA);class NA extends kA{constructor(e){super(e)}mergeFunction(e){return Xm(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=Ay(t,e[n]);return t})}}NA.className="Maximum",xy(NA);class TA extends kA{constructor(e){super(e)}mergeFunction(e){return Xm(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=Yv(t,e[n]);return t})}}TA.className="Minimum",xy(TA);class EA extends kA{constructor(e){super(e),this.DEFAULT_AXIS=-1,null==e&&(e={}),this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!Array.isArray(e)||!Array.isArray(e[0])||1===e.length)throw new IN("A `Concatenate` layer should be called on a list of at least 2 inputs");let t=!0;for(const a of e)if(null!=a){t=!1;break}if(t)return;const n=[];for(let a=0;a<e.length;++a){const t=e[a].slice();t.splice(this.axis,1);let s=!1;for(const e of n)if(Su(e,t)){s=!0;break}s||n.push(t)}if(n.length>1)throw new IN("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return Xm(()=>IT(e,this.axis))}computeOutputShape(e){if(!Array.isArray(e)||!Array.isArray(e[0]))throw new IN("A `Concatenate` layer should be called on a list of inputs.");const t=e,n=t[0].slice(),a=this.axis<0?n.length+this.axis:this.axis;for(const s of t.slice(1)){if(null==n[a]||null==s[a]){n[a]=null;break}n[a]+=s[a]}return n}computeMask(e,t){if(null==t)return null;if(!Array.isArray(t))throw new IN("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new IN("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new IN("Mismatch in the length of mask (".concat(t.length,") ")+"and the legnth of inputs (".concat(e.length,")"));return Xm(()=>{let n=!0;if(t.forEach(e=>{null==e||(n=!1)}),n)return null;const a=[];for(let r=0;r<e.length;++r)null==t[r]?a.push(ay(aw(e[r]),"bool")):t[r].rank<e[r].rank?a.push(hv(t[r],-1)):a.push(t[r]);const s=rx(a,this.axis);return Mb(s,-1,!1)})}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}function RA(e,t){for(;e<0;)e+=t;return e}EA.className="Concatenate",xy(EA);class _A extends kA{constructor(e){super(e),this.axes=e.axes,this.normalize=null!=e.normalize&&e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){bu(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0],n=e[1];if(t.length>3||n.length>3)throw new NN("Dot layer does not support tensors of 4D or higher rank yet.");const a=this.interpretAxes(t,n);if(t[a[0]]!==n[a[1]])throw new IN("Dimension incompatibility: "+"".concat(t[a[0]]," !== ").concat(n[a[1]]))}mergeFunction(e){if(2!==e.length)throw new IN("A `Dot` layer must be called on exactly 2 inputs, "+"but received ".concat(e.length," input(s)."));let t,n=e[0],a=e[1];return t=Array.isArray(this.axes)?this.axes.map((t,n)=>RA(t,e[n].shape.length)):[RA(this.axes,n.shape.length),RA(this.axes,a.shape.length)],this.normalize&&(n=QE(n,t[0]),a=QE(a,t[1])),function(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new NN("batchDot is not implemented for tensors of 4D or higher rank yet");if(bu(e.shape.length>=2,()=>"batchDot requires the rank of x to be >= 2, "+"but got ".concat(e.shape.length)),bu(e.shape.length>=2,()=>"batchDot requires the rank of y to be >= 2, "+"but got ".concat(t.shape.length)),"number"===typeof n&&(n=[n,n]),"complex64"===e.dtype||"complex64"===t.dtype)throw new NN("batchDot is not implemented for complex64-type Tensors yet.");const a=e.shape.length,s=t.shape.length;null==n&&(n=[a-1,s-2]);const r=n;return Xm(()=>{let n,i;if(a>s){n=a-s;const e=[];for(let t=0;t<n;++t)e.push(1);t=nx(t,t.shape.concat(e))}else if(s>a){n=s-a;const t=[];for(let e=0;e<n;++e)t.push(1);e=nx(e,e.shape.concat(t))}else n=0;if(2===e.shape.length&&2===t.shape.length)i=r[0]===r[1]?iv(ly(e,t),r[0]):iv(ly(Nk(e,[1,0]),t),r[1]);else{const n=r[0]!==e.shape.length-1,a=r[1]===t.shape.length-1;i=ix(e,t,n,a)}if(n>0){let e;e=a>s?a+s-3:a-1;const t=[];for(let a=e;a<e+n;++a)t.push(a);i=nk(i,t)}return 1===i.shape.length&&(i=hv(i,1)),i})}(n,a,t)}interpretAxes(e,t){let n;return n=Array.isArray(this.axes)?this.axes:[RA(this.axes,e.length),RA(this.axes,t.length)],n}computeOutputShape(e){bu(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new NN("Dot layer does not support tensors of 4D or higher rank yet.");const a=this.interpretAxes(t,n);t.splice(a[0],1),n.splice(a[1],1),n.splice(0,1);const s=t.concat(n);return 1===s.length&&s.push(1),s}computeMask(e,t){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}}_A.className="Dot",xy(_A);class AA extends bE{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return Xm(()=>{this.invokeCallHook(e,t);const n=iE(e);return OT(()=>iy(ET(n.shape,0,this.stddev),n),()=>n,t.training||!1)})}}AA.className="GaussianNoise",xy(AA);class MA extends bE{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return Xm(()=>{this.invokeCallHook(e,t);const n=iE(e);if(this.rate>0&&this.rate<1){return OT(()=>{const e=Math.sqrt(this.rate/(1-this.rate));return ly(n,ET(n.shape,1,e))},()=>n,t.training||!1)}return n})}}MA.className="GaussianDropout",xy(MA);class PA extends bE{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||iE(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return Xm(()=>{if(this.rate<1&&this.rate>0){const n=this._getNoiseShape(e),a=()=>{const t=iE(e),a=-1.7580993408473766;let s=bv(Iw(n),this.rate);s=vT(s,"float32");const r=((1-this.rate)*(1+this.rate*a**2))**-.5,i=-r*a*this.rate,o=iy(ly(t,s),ly(iy(s,-1),a));return iy(ly(o,r),i)};return OT(a,()=>iE(e),t.training||!1)}return e})}}function DA(e,t,n,a,s){let r,i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:.001;if(2===e.rank)r=px(e,t,n,a,s,i);else if(3===e.rank)r=fx(e,t,n,a,s,i);else{if(4!==e.rank)throw new NN("batchNormalization is not implemented for array of rank ".concat(e.rank," ")+"yet");r=mx(e,t,n,a,s,i)}return r}function OA(e,t,n,a){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return Su(a.slice().sort(),yT(0,e.rank-1))?function(e,t,n,a){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return Xm(()=>{const r=Jv(e,a),i=r.mean,o=r.variance;return[DA(e,i,o,n,t,s),i,o]})}(e,t,n,a,s):function(e,t,n,a){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return Xm(()=>{const r=Jv(e,a),i=r.mean,o=r.variance,c=[];for(const t of yT(0,e.rank))-1!==a.indexOf(t)?c.push(1):c.push(e.shape[t]);const l=nx(i,c),u=nx(o,c),h=null==t?null:nx(t,c),d=null==n?null:nx(n,c);return[DA(e,l,u,d,h,s),i,o]})}(e,t,n,a,s)}PA.className="AlphaDropout",xy(PA);class FA extends bE{constructor(e){null==e&&(e={}),super(e),this.supportsMasking=!0,this.axis=null==e.axis?-1:e.axis,this.momentum=null==e.momentum?.99:e.momentum,this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=aE(e.betaInitializer||"zeros"),this.gammaInitializer=aE(e.gammaInitializer||"ones"),this.movingMeanInitializer=aE(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=aE(e.movingVarianceInitializer||"ones"),this.betaConstraint=LE(e.betaConstraint),this.gammaConstraint=LE(e.gammaConstraint),this.betaRegularizer=S_(e.betaRegularizer),this.gammaRegularizer=S_(e.gammaRegularizer)}build(e){e=oE(e);const t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(null==n)throw new IN("Axis ".concat(t," of input tensor should have a defined dimension but ")+"the layer received an input with shape "+"".concat(JSON.stringify(e),"."));this.inputSpec=[new pE({ndim:e.length,axes:{[t]:n}})];const a=[n];this.scale&&(this.gamma=this.addWeight("gamma",a,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",a,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",a,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",a,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return Xm(()=>{const n=null!=t.training&&t.training,a=iE(e),s=a.shape,r=s.length,i=yT(0,r),o=this.axis>=0?this.axis:this.axis+r;i.splice(o,1);const c=RN(1,r);c[o]=s[o];const l=i.slice();l.sort();const u=!Su(l,yT(0,r).slice(0,r-1));if(!n)return(()=>{if(u){const e=nx(this.movingMean.read(),c),t=nx(this.movingVariance.read(),c),n=this.center?nx(this.beta.read(),c):null,s=this.scale?nx(this.gamma.read(),c):null;return DA(a,e,t,n,s,this.epsilon)}return DA(a,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[h,d,p]=OA(a,this.gamma.read(),this.beta.read(),i,this.epsilon),f=(e,t,n)=>{Xm(()=>{const a=1-n,s=e.read(),r=ly(Iy(s,t),a);e.write(Iy(s,r))})};return(()=>{f(this.movingMean,d,this.momentum),f(this.movingVariance,p,this.momentum)})(),h})}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:nE(this.betaInitializer),gammaInitializer:nE(this.gammaInitializer),movingMeanInitializer:nE(this.movingMeanInitializer),movingVarianceInitializer:nE(this.movingVarianceInitializer),betaRegularizer:w_(this.betaRegularizer),gammaRegularizer:w_(this.gammaRegularizer),betaConstraint:OE(this.betaConstraint),gammaConstraint:OE(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}}FA.className="BatchNormalization",xy(FA);class LA extends bE{constructor(e){if(null==e&&(e={}),super(e),this.axis=null==e.axis?-1:e.axis,"number"===typeof this.axis){if(!Number.isInteger(this.axis))throw new Error("Expected axis to be an integer, but received ".concat(this.axis))}else{if(!Array.isArray(this.axis))throw new Error("Expected axis to be an integer or an array of integers, "+"but received ".concat(JSON.stringify(this.axis)));for(const e of this.axis)if(!Number.isInteger(e))throw new Error("Expected axis to be an array of integers, "+"but received ".concat(JSON.stringify(this.axis)))}this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=aE(e.betaInitializer||"zeros"),this.gammaInitializer=aE(e.gammaInitializer||"ones"),this.betaRegularizer=S_(e.betaRegularizer),this.gammaRegularizer=S_(e.gammaRegularizer),this.supportsMasking=!0}build(e){const t=(e=oE(e)).length;"number"===typeof this.axis&&(this.axis=[this.axis]);for(let s=0;s<this.axis.length;++s)this.axis[s]<0&&(this.axis[s]+=t);for(const s of this.axis)if(s<0||s>=t)throw new Error("Invalid axis: ".concat(s));if(this.axis.length!==WN(this.axis).length)throw new Error("Found duplicate axes in: ".concat(this.axis));const n=this.axis.map(t=>e[t]),a=!0;this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,a):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,a):this.beta=null,this.built=!0}call(e,t){const n=iE(e),a=n.shape,s=a.length;return Xm(()=>{let{mean:e,variance:t}=Jv(n,this.axis,!0);const r=RN(1,s);for(const n of this.axis)r[n]=a[n];const i=e=>null!=e&&e.shape.length!==s?nx(e,r):e;let o=this.scale?i(this.gamma.read()):null,c=this.center?i(this.beta.read()):null;const l=[],u=[];for(let n=0;n<s;++n)-1!==this.axis.indexOf(n)?(l.push(a[n]),u.push(1)):(l.push(1),u.push(a[n]));return e=pv(e,l),t=pv(t,l),null!=o&&(o=pv(o,u)),null!=c&&(c=pv(c,u)),DA(n,e,t,c,o,this.epsilon)})}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:nE(this.betaInitializer),gammaInitializer:nE(this.gammaInitializer),betaRegularizer:w_(this.betaRegularizer),gammaRegularizer:w_(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}}LA.className="LayerNormalization",xy(LA);class zA extends bE{constructor(e){if(null==e&&(e={}),super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,null==e.padding)this.padding=[[1,1],[1,1]];else if("number"===typeof e.padding)this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,2!==e.padding.length)throw new IN("ZeroPadding2D expects padding to be a length-2 array, but "+"received a length-".concat(e.padding.length," array."));let t,n;if("number"===typeof e.padding[0])t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,2!==e.padding[0].length)throw new IN("ZeroPadding2D expects height padding to be a length-2 array, "+"but received a length-".concat(e.padding[0].length," array."));if(t=e.padding[0],2!==e.padding[1].length)throw new IN("ZeroPadding2D expects width padding to be a length-2 array, "+"but received a length-".concat(e.padding[1].length," array."));n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new pE({ndim:4})]}computeOutputShape(e){let t,n;return e=oE(e),"channelsFirst"===this.dataFormat?(t=null!=e[2]&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[3]&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],t,n]):(t=null!=e[1]&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[2]&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],t,n,e[3]])}call(e,t){return Xm(()=>{return t=iE(e),n=this.padding,a=this.dataFormat,Xm(()=>{if(4!==t.rank)throw new IN("temporalPadding expects input tensor to be 4-D, but received a "+"".concat(t.rank,"-D tensor."));if(null==n&&(n=[[1,1],[1,1]]),2!==n.length||2!==n[0].length||2!==n[1].length)throw new IN("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==a&&(a="channelsLast"),"channelsLast"!==a&&"channelsFirst"!==a)throw new IN("Unknown data format: ".concat(a,". ")+"Supported data formats are 'channelsLast' and 'channelsFirst.");let e;return e="channelsFirst"===a?[[0,0],[0,0],n[0],n[1]]:[[0,0],n[0],n[1],[0,0]],rw(t,e)});var t,n,a})}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}function BA(e,t,n,a,s,r){return Xm(()=>{let i;sT(s),iT(r),rT(a),null==n&&(n=[1,1]),null==a&&(a="valid"),null==s&&(s="channelsLast"),null==r&&(r="max"),e=P_(e,s);const o="same"===a?"same":"valid";return i="max"===r?Vv(e,t,n,o):ax(e,t,n,o),"channelsFirst"===s&&(i=Nk(i,[0,3,1,2])),i})}function jA(e,t,n,a,s,r){return Xm(()=>{let i;sT(s),iT(r),rT(a),null==n&&(n=[1,1,1]),null==a&&(a="valid"),null==s&&(s="channelsLast"),null==r&&(r="max"),e=D_(e,s);const o="same"===a?"same":"valid";return i="max"===r?Uv(e,t,n,o):sx(e,t,n,o),"channelsFirst"===s&&(i=Nk(i,[0,4,1,2,3])),i})}zA.className="ZeroPadding2D",xy(zA);class WA extends bE{constructor(e){if(null==e.poolSize&&(e.poolSize=2),super(e),"number"===typeof e.poolSize)this.poolSize=[e.poolSize];else{if(!Array.isArray(e.poolSize)||1!==e.poolSize.length||"number"!==typeof e.poolSize[0])throw new IN("poolSize for 1D convolutional layer must be a number or an Array of a single number, but received "+"".concat(JSON.stringify(e.poolSize)));this.poolSize=e.poolSize}if(GN(this.poolSize,"poolSize"),null==e.strides)this.strides=this.poolSize;else if("number"===typeof e.strides)this.strides=[e.strides];else{if(!Array.isArray(e.strides)||1!==e.strides.length||"number"!==typeof e.strides[0])throw new IN("strides for 1D convolutional layer must be a number or an Array of a single number, but received "+"".concat(JSON.stringify(e.strides)));this.strides=e.strides}GN(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,rT(this.padding),this.inputSpec=[new pE({ndim:3})]}computeOutputShape(e){const t=A_((e=oE(e))[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return Xm(()=>{this.invokeCallHook(e,t),e=wT(iE(e),2);const n=this.poolingFunction(iE(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return nk(n,[2])})}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}}class VA extends WA{constructor(e){super(e)}poolingFunction(e,t,n,a,s){return sT(s),rT(a),BA(e,t,n,a,s,"max")}}VA.className="MaxPooling1D",xy(VA);class UA extends WA{constructor(e){super(e)}poolingFunction(e,t,n,a,s){return sT(s),rT(a),BA(e,t,n,a,s,"avg")}}UA.className="AveragePooling1D",xy(UA);class HA extends bE{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(2!==e.strides.length)throw new IN("If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length "+"".concat(e.strides.length,"."));this.strides=e.strides}else this.strides=[e.strides,e.strides];GN(this.poolSize,"poolSize"),GN(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,sT(this.dataFormat),rT(this.padding),this.inputSpec=[new pE({ndim:4})]}computeOutputShape(e){e=oE(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2];return t=A_(t,this.poolSize[0],this.padding,this.strides[0]),n=A_(n,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return Xm(()=>(this.invokeCallHook(e,t),this.poolingFunction(iE(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class GA extends HA{constructor(e){super(e)}poolingFunction(e,t,n,a,s){return sT(s),rT(a),BA(e,t,n,a,s,"max")}}GA.className="MaxPooling2D",xy(GA);class qA extends HA{constructor(e){super(e)}poolingFunction(e,t,n,a,s){return sT(s),rT(a),BA(e,t,n,a,s,"avg")}}qA.className="AveragePooling2D",xy(qA);class KA extends bE{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(3!==e.strides.length)throw new IN("If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length "+"".concat(e.strides.length,"."));this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];GN(this.poolSize,"poolSize"),GN(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,sT(this.dataFormat),rT(this.padding),this.inputSpec=[new pE({ndim:5})]}computeOutputShape(e){e=oE(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],a="channelsFirst"===this.dataFormat?e[4]:e[3];return t=A_(t,this.poolSize[0],this.padding,this.strides[0]),n=A_(n,this.poolSize[1],this.padding,this.strides[1]),a=A_(a,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n,a]:[e[0],t,n,a,e[4]]}call(e,t){return Xm(()=>(this.invokeCallHook(e,t),this.poolingFunction(iE(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class XA extends KA{constructor(e){super(e)}poolingFunction(e,t,n,a,s){return sT(s),rT(a),jA(e,t,n,a,s,"max")}}XA.className="MaxPooling3D",xy(XA);class YA extends KA{constructor(e){super(e)}poolingFunction(e,t,n,a,s){return sT(s),rT(a),jA(e,t,n,a,s,"avg")}}YA.className="AveragePooling3D",xy(YA);class QA extends bE{constructor(e){super(e),this.inputSpec=[new pE({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new NN}}class ZA extends QA{constructor(e){super(e||{})}call(e,t){return Xm(()=>{const t=iE(e);return Gv(t,1)})}}ZA.className="GlobalAveragePooling1D",xy(ZA);class JA extends QA{constructor(e){super(e||{})}call(e,t){return Xm(()=>{const t=iE(e);return sv(t,1)})}}JA.className="GlobalMaxPooling1D",xy(JA);class $A extends bE{constructor(e){super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,sT(this.dataFormat),this.inputSpec=[new pE({ndim:4})]}computeOutputShape(e){return"channelsLast"===this.dataFormat?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new NN}getConfig(){const e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class eM extends $A{call(e,t){return Xm(()=>{const t=iE(e);return"channelsLast"===this.dataFormat?Gv(t,[1,2]):Gv(t,[2,3])})}}eM.className="GlobalAveragePooling2D",xy(eM);class tM extends $A{call(e,t){return Xm(()=>{const t=iE(e);return"channelsLast"===this.dataFormat?sv(t,[1,2]):sv(t,[2,3])})}}tM.className="GlobalMaxPooling2D",xy(tM);class nM extends bE{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(e){null!=this.layer&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const a=YE(t.layer,n);delete t.layer;const s={layer:a};return Object.assign(s,t),new e(s)}}class aM extends nM{constructor(e){super(e),this.supportsMasking=!0}build(e){if((e=oE(e)).length<3)throw new IN("TimeDistributed layer expects an input shape >= 3D, but received "+"input shape ".concat(JSON.stringify(e)));this.inputSpec=[{shape:e}];const t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){const t=[(e=oE(e))[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t),a=e[1];return[n[0],a].concat(n.slice(1))}call(e,t){return Xm(()=>Z_((e,n)=>[iE(this.layer.call(e,t)),[]],e=iE(e),[],!1,null,null,!1,!0)[1])}}aM.className="TimeDistributed",xy(aM);class sM extends nM{constructor(e){super(e);const t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=YE(n),t.goBackwards=!0!==t.goBackwards;const a={};var s;if(a.className=e.layer.getClassName(),a.config=t,this.backwardLayer=YE(a),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===e.mergeMode?"concat":e.mergeMode,s=this.mergeMode,UN(nT,"BidirectionalMergeMode",s),e.weights)throw new NN("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const t=e.length,n=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))}computeOutputShape(e){let t,n,a,s=this.forwardLayer.computeOutputShape(e);return Array.isArray(s)&&Array.isArray(s[0])||(s=[s]),this.returnState?(a=s.slice(1),t=s[0]):t=s[0],"concat"===this.mergeMode?(t[t.length-1]*=2,n=[t]):n=null==this.mergeMode?[t,t.slice()]:[t],this.returnState?null==this.mergeMode?n.concat(a).concat(a.slice()):[t].concat(a).concat(a.slice()):MN(n)}apply(e,t){let n=null==t?null:t.initialState,a=null==t?null:t.constants;null==t&&(t={});const s=Q_(e,n,a,this.numConstants);if(e=s.inputs,n=s.initialState,a=s.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(null==n||0===n.length)&&null==a)return super.apply(e,t);const r=[],i=[];if(null!=n){const e=n.length;if(e%2>0)throw new IN("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=n,r.push(...n);const a=n.map(e=>new pE({shape:e.shape}));this.forwardLayer.stateSpec=a.slice(0,e/2),this.backwardLayer.stateSpec=a.slice(e/2),i.push(...a)}if(null!=a)throw new NN("Support for constants in Bidirectional layers is not implemented yet.");const o=r[0]instanceof fE;for(const c of r)if(c instanceof fE!==o)throw new IN("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(o){const n=[e].concat(r),a=this.inputSpec.concat(i),s=this.inputSpec;this.inputSpec=a;const o=super.apply(n,t);return this.inputSpec=s,o}return super.apply(e,t)}call(e,t){return Xm(()=>{const n=t.initialState;let a,s,r,i;if(null==n)a=this.forwardLayer.call(e,t),s=this.backwardLayer.call(e,t);else{const r=n.slice(0,n.length/2),i=n.slice(n.length/2);a=this.forwardLayer.call(e,Object.assign(t,{initialState:r})),s=this.backwardLayer.call(e,Object.assign(t,{initialState:i}))}return this.returnState&&(Array.isArray(a)&&(r=a.slice(1).concat(s.slice(1))),a=a[0],s=s[0]),this.returnSequences&&(s=Mw(s,1)),"concat"===this.mergeMode?i=IT([a,s]):"sum"===this.mergeMode?i=iy(a,s):"ave"===this.mergeMode?i=ly(.5,iy(a,s)):"mul"===this.mergeMode?i=ly(a,s):null==this.mergeMode&&(i=[a,s]),this.returnState?null==this.mergeMode?i.concat(r):[i].concat(r):i})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){cT(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),cT(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,t){let n;if(Array.isArray(t)&&(t=t[0]),n=this.returnSequences?null==this.mergeMode?[t,t]:t:null==this.mergeMode?[null,null]:null,this.returnState){const e=this.forwardLayer.states.map(e=>null);return Array.isArray(n)?n.concat(e).concat(e):[n].concat(e).concat(e)}return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(e),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){const n=YE(t.layer);if(delete t.layer,null!=t.numConstants)throw new NN("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const a=t;return a.layer=n,new e(a)}}sM.className="Bidirectional",xy(sM);class rM extends bE{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){const e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return Xm(()=>("float32"!==(e=iE(e)).dtype&&(e=vT(e,"float32")),iy(ly(e,this.scale),this.offset)))}}rM.className="Rescaling",xy(rM);const{resizeBilinear:iM,cropAndResize:oM}=HS;class cM extends bE{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,n,a,s,r,i,o){return Xm(()=>{let c,l=!1;const u=[t/r,n/i,(a+t)/r,(s+n)/i],h=[];3===e.rank?(l=!0,c=ak([e])):c=e;for(let e=0;e<c.shape[0];e++)h.push(u);const d=Um(h,[h.length,4]),p=Tw(0,h.length,1,"int32"),f=oM(c,d,p,[a,s],"nearest");return vT(l?iE(vk(f)):f,o)})}upsize(e,t,n,a){return Xm(()=>vT(iM(e,[t,n]),a))}call(e,t){return Xm(()=>{const t=iE(e),n=t.dtype,a=t.shape,s=a[a.length-3],r=a[a.length-2];let i=0;s!==this.height&&(i=Math.floor((s-this.height)/2));let o=0;return r!==this.width&&(o=Math.floor((r-this.width)/2),0===o&&(o=1)),i>=0&&o>=0?this.centerCrop(t,i,o,this.height,this.width,s,r,n):this.upsize(e,this.height,this.width,n)})}getConfig(){const e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){const t=(e=oE(e)).length-3,n=e.length-2;return e[t]=this.height,e[n]=this.width,e}}cM.className="CenterCrop",xy(cM);class lM extends bE{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return null==(e=oE(e))?[this.numTokens]:"oneHot"===this.outputMode&&1!==e[e.length-1]?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return Xm(()=>{let n;if("int32"!==(e=iE(e)).dtype&&(e=vT(e,"int32")),"undefined"!==typeof t.countWeights){if("count"!==this.outputMode)throw new IN("countWeights is not used when outputMode !== count.\n              Received countWeights=".concat(t.countWeights));n=iE(t.countWeights)}const a=sv(e),s=rv(e),r=yv(this.numTokens,a).bufferSync().get(0),i=bv(s,0).bufferSync().get(0);if(!r||!i)throw new IN("Input values must be between 0 < values <="+" numTokens with numTokens=".concat(this.numTokens));return function(e,t,n,a){let s=iE(e);if("int32"!==s.dtype&&(s=vT(s,"int32")),"int"===t)return s;const r=s.shape;if(0===s.rank&&(s=hv(s,-1)),"oneHot"===t&&1!==s.shape[s.shape.length-1]&&(s=hv(s,-1)),s.rank>2)throw new IN("When outputMode is not int, maximum output rank is 2"+" Received outputMode ".concat(t," and input shape ").concat(r)+" which would result in output rank ".concat(s.rank,"."));const i=["multiHot","oneHot"].includes(t),o=s;let c;if(c=Lx(o,"undefined"!==typeof a&&"count"===t?a:[],n,i),"tfIdf"!==t)return c;if(a)return ly(c,a);throw new IN("When outputMode is 'tfIdf', weights must be provided.")}(e,this.outputMode,this.numTokens,n)})}}lM.className="CategoryEncoding",xy(lM);const uM=new Set(["bilinear","nearest"]);class hM extends bE{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation){if(!uM.has(e.interpolation))throw new IN("Invalid interpolation parameter: ".concat(e.interpolation," is not implemented"));this.interpolation=e.interpolation}else this.interpolation="bilinear";this.cropToAspectRatio=Boolean(e.cropToAspectRatio)}computeOutputShape(e){const t=(e=oE(e))[2];return[this.height,this.width,t]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return Xm(()=>{const t=[this.height,this.width];if("bilinear"===this.interpolation)return HS.resizeBilinear(e,t,!this.cropToAspectRatio);if("nearest"===this.interpolation)return HS.resizeNearestNeighbor(e,t,!this.cropToAspectRatio);throw new Error("Interpolation is ".concat(this.interpolation," but only ").concat([...uM]," are supported"))})}}hM.className="Resizing",xy(hM);class dM{constructor(e){this.seed=e}next(){if(void 0!==this.seed)return this.seed++}}dM.className="RandomSeed";class pM extends bE{constructor(e){super(e),this.randomGenerator=new dM(e.seed)}getConfig(){const e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}}pM.className="BaseRandomLayer";const fM=new Set(["bilinear","nearest"]);class mM extends pM{constructor(e){super(e);const{factor:t,interpolation:n="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&2===this.factor.length)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else{if(Array.isArray(this.factor)||!(this.factor>0))throw new IN("Invalid factor: ".concat(this.factor,". Must be positive number or tuple of 2 numbers"));this.widthLower=-this.factor,this.widthUpper=this.factor}if(this.widthLower<-1||this.widthUpper<-1)throw new IN("factor must have values larger than -1. Got: ".concat(this.factor));if(this.widthUpper<this.widthLower)throw new IN("factor cannot have upper bound less than lower bound.\n        Got upper bound: ".concat(this.widthUpper,".\n        Got lower bound: ").concat(this.widthLower,"\n      "));if(n){if(!fM.has(n))throw new IN("Invalid interpolation parameter: ".concat(n," is not implemented"));this.interpolation=n}}getConfig(){const e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){const t=(e=oE(e))[2];return[this.imgHeight,-1,t]}call(e,t){return Xm(()=>{const t=iE(e);this.imgHeight=t.shape[t.shape.length-3];const n=t.shape[t.shape.length-2];this.widthFactor=Iw([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let a=this.widthFactor.dataSync()[0]*n;a=Math.round(a);const s=[this.imgHeight,a];switch(this.interpolation){case"bilinear":return HS.resizeBilinear(e,s);case"nearest":return HS.resizeNearestNeighbor(e,s);default:throw new Error("Interpolation is ".concat(this.interpolation,"\n          but only ").concat([...fM]," are supported"))}})}}mM.className="RandomWidth",xy(mM);var gM,yM;eh().registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")}),function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF"}(gM||(gM={})),function(e){let t;!function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"}(t=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))}(yM||(yM={}));const bM={};function xM(e){return bM[e]}function vM(e,t,n,a,s){const r=t.inputParams[e];if(r&&void 0!==r.inputIndexStart){const e=r.inputIndexStart,i=0===r.inputIndexEnd?void 0:void 0===r.inputIndexEnd?e+1:r.inputIndexEnd,o=e<0?t.inputNames.length+e:e;if("tensor"===r.type)return wM(t.inputNames[o],n,a,s);if("tensors"===r.type){const r=t.inputs.slice(e,i),o=t.inputNames.slice(e,i).filter((e,t)=>{var n;return"NoOp"!==(null===(n=r[t])||void 0===n?void 0:n.op)});return o.map(e=>wM(e,n,a,s))}const c=wM(t.inputNames[o],n,a,s),l=c.dataSync();return"number"===r.type?l[0]:Vu(c.shape,l)}const i=t.attrParams[e];return i&&i.value}function wM(e,t,n,a){const[s,r]=IM(e,n);if(null!=a){const e=a.getHashTableHandleByName(s);if(null!=e)return e}const i=n.currentContextIds.find(e=>!!t[CM(s,e)]);return void 0!==i?t[CM(s,i)][r]:void 0}function kM(e,t,n){return t[CM(e,n.currentContextId)]}function SM(e,t){const[n,a,s]=IM(e,t);return[CM(n,t&&t.currentContextId),a,s]}function CM(e,t){return t?"".concat(e,"-").concat(t):e}function IM(e,t){if(""===e)return["",0,void 0];const n=null!=t&&null!=t.parseNodeNameCache;if(n){const n=t.parseNodeNameCache.get(e);if(null!=n)return n}const a=e.split(":");let s;if(1===a.length)s=[e,0,void 0];else{const e=a[0],t=3===a.length?a[1]:void 0;s=[e,Number(a[a.length-1]),t]}return n&&t.parseNodeNameCache.set(e,s),s}function NM(e,t,n){let a=vM("pad",e,t,n);if("explicit"===a){a=vM("explicitPaddings",e,t,n);const s=[[0,0],[0,0],[0,0],[0,0]];for(let e=0;e<4;e++)s[e][0]=a[2*e],s[e][1]=a[2*e+1];return s}return a}function TM(e){return e.kept?e:sy(e)}const EM=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],RM=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],_M=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],AM=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],MM=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],PM=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],DM=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],OM=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],FM=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],LM=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],zM=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],BM=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],jM=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],WM=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],VM=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],UM=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],HM=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],GM=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],qM=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];class KM{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[].concat(...[i,o,c,l,u,h,d,p,f,m,g,y,b,x,v,w,k,S,C].map(e=>e.json));this.opMappers=e.reduce((e,t)=>(e[t.tfOpName]=t,e),{})}transformGraph(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=e.node,a=[],s=[],r=[],i=n.reduce((e,t)=>(e[t.name]=this.mapNode(t),t.op.startsWith("Placeholder")?a.push(e[t.name]):"Const"===t.op?s.push(e[t.name]):null!=t.input&&0!==t.input.length||r.push(e[t.name]),e),{});let o=[];const c=[];let l={},u={};null!=t&&(l=this.mapSignatureEntries(t.inputs),u=this.mapSignatureEntries(t.outputs));const h=Object.keys(i);h.forEach(e=>{const t=i[e];t.inputNames.forEach((e,n)=>{const[a,,s]=SM(e),r=i[a];if(null!=r.outputs){const e=r.outputs.indexOf(s);if(-1!==e){const s="".concat(a,":").concat(e);t.inputNames[n]=s}}t.inputs.push(r),r.children.push(t)})}),0===Object.keys(u).length?h.forEach(e=>{const t=i[e];0===t.children.length&&c.push(t)}):Object.keys(u).forEach(e=>{const[t]=SM(e),n=i[t];null!=n&&(n.signatureKey=u[e],c.push(n))}),Object.keys(l).length>0?Object.keys(l).forEach(e=>{const[t]=SM(e),n=i[t];n&&(n.signatureKey=l[e],o.push(n))}):o=a;let d={};null!=e.library&&null!=e.library.function&&(d=e.library.function.reduce((e,t)=>(e[t.signature.name]=this.mapFunction(t),e),{}));const p={nodes:i,inputs:o,outputs:c,weights:s,placeholders:a,signature:t,functions:d};return r.length>0&&(p.initNodes=r),p}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,n)=>(t[e[n].name]=n,t),{})}mapNode(e){const t=xM(e.op)||this.opMappers[e.op]||{};null==e.attr&&(e.attr={});const n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(e=>e.startsWith("^")?e.slice(1):e),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return null!=t.inputs&&(n.inputParams=t.inputs.reduce((e,t)=>(e[t.name]={type:t.type,inputIndexStart:t.start,inputIndexEnd:t.end},e),{})),null!=t.attrs&&(n.attrParams=t.attrs.reduce((t,n)=>{const a=n.type;let s;switch(n.type){case"string":s=YM(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=YM(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"string[]":s=rP(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=rP(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number":s=ZM(e.attr,n.tfName,n.defaultValue||0),void 0===s&&n.tfDeprecatedName&&(s=ZM(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number[]":s=sP(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=sP(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool":s=QM(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=QM(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool[]":s=oP(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=oP(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape":s=aP(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=aP(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape[]":s=iP(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=iP(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype":s=eP(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=eP(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype[]":s=tP(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=tP(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"func":s=$M(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=$M(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error("Unsupported param type: ".concat(n.type," for op: ").concat(e.op))}return t[n.name]={value:s,type:a},t},{})),n}mapFunction(e){const t=e.nodeDef,n=[];let a={};null!=t&&(a=t.reduce((e,t)=>(e[t.name]=this.mapNode(t),"Const"===t.op&&n.push(e[t.name]),e),{}));const s=[],r=[];e.signature.inputArg.forEach(e=>{const[t]=SM(e.name),n={name:t,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:JM(e.type),type:"dtype"}},children:[]};n.signatureKey=e.name,s.push(n),a[t]=n});Object.keys(a).forEach(e=>{const t=a[e];t.inputNames.forEach((e,n)=>{const[s,,r]=SM(e),i=a[s];if(null!=i.outputs){const e=i.outputs.indexOf(r);if(-1!==e){const a="".concat(s,":").concat(e);t.inputNames[n]=a}}t.inputs.push(i),i.children.push(t)})});const i=e.ret;e.signature.outputArg.forEach(e=>{const[t,n]=SM(i[e.name]),s=a[t];null!=s&&(s.defaultOutput=n,r.push(s))});const o=this.mapArgsToSignature(e);return{nodes:a,inputs:s,outputs:r,weights:n,placeholders:[],signature:o}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((e,t)=>(e[t.name]=this.mapArgToTensorInfo(t),e),{}),outputs:e.signature.outputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t),{})}}mapArgToTensorInfo(e,t){let n=e.name;return null!=t&&(n=t[n]),{name:n,dtype:e.type}}}function XM(e,t){const n=Array.isArray(e)?String.fromCharCode.apply(null,e):function(e){const t=eh().global;if("undefined"!==typeof t.atob)return t.atob(e);if("undefined"!==typeof Buffer)return new Buffer(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(e);return t?n:n.toLowerCase()}function YM(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s=e[t];return null!=s?XM(s.s,a):n}function QM(e,t,n){const a=e[t];return a?a.b:n}function ZM(e,t,n){const a=e[t]||{},s=null!=a.i?a.i:null!=a.f?a.f:n;return"number"===typeof s?s:parseInt(s,10)}function JM(e){switch("string"===typeof e&&(e=gM[e]),e){case gM.DT_FLOAT:case gM.DT_HALF:return"float32";case gM.DT_INT32:case gM.DT_INT64:case gM.DT_INT8:case gM.DT_UINT8:return"int32";case gM.DT_BOOL:return"bool";case gM.DT_DOUBLE:return"float32";case gM.DT_STRING:return"string";case gM.DT_COMPLEX64:case gM.DT_COMPLEX128:return"complex64";default:return null}}function $M(e,t,n){const a=e[t];return a&&a.func?a.func.name:n}function eP(e,t,n){const a=e[t];return a&&a.type?JM(a.type):n}function tP(e,t,n){const a=e[t];return a&&a.list&&a.list.type?a.list.type.map(e=>JM(e)):n}function nP(e){if(!e.unknownRank)return null!=e.dim?e.dim.map(e=>"number"===typeof e.size?e.size:parseInt(e.size,10)):[]}function aP(e,t,n){const a=e[t];return a&&a.shape?nP(a.shape):n}function sP(e,t,n){const a=e[t];return a?((a.list.f&&a.list.f.length?a.list.f:a.list.i)||[]).map(e=>"number"===typeof e?e:parseInt(e,10)):n}function rP(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s=e[t];return s&&s.list&&s.list.s?s.list.s.map(e=>XM(e,a)):n}function iP(e,t,n){const a=e[t];return a&&a.list&&a.list.shape?a.list.shape.map(e=>nP(e)):n}function oP(e,t,n){const a=e[t];return a&&a.list&&a.list.b?a.list.b:n}class cP{constructor(e,t,n){this.node=e,this.tensorMap=t,this.context=n,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(e=>this.getInput(e)),null!=e.rawAttrs&&(this.attrs=Object.keys(e.rawAttrs).reduce((e,t)=>(e[t]=this.getAttr(t),e),{}))}getInput(e){return wM(e,this.tensorMap,this.context)}getAttr(e,t){const n=this.node.rawAttrs[e];if(null!=n.tensor)return wM(e,this.tensorMap,this.context);if(null!=n.i||null!=n.f)return ZM(this.node.rawAttrs,e,t);if(null!=n.s)return YM(this.node.rawAttrs,e,t);if(null!=n.b)return QM(this.node.rawAttrs,e,t);if(null!=n.shape)return aP(this.node.rawAttrs,e,t);if(null!=n.type)return eP(this.node.rawAttrs,e,t);if(null!=n.list){if(null!=n.list.i||null!=n.list.f)return sP(this.node.rawAttrs,e,t);if(null!=n.list.s)return rP(this.node.rawAttrs,e,t);if(null!=n.list.shape)return iP(this.node.rawAttrs,e,t);if(null!=n.list.b)return oP(this.node.rawAttrs,e,t);if(null!=n.list.type)return tP(this.node.rawAttrs,e,t)}return t}}function lP(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";if("number"!==typeof e&&"number"!==typeof t){bu(e.length===t.length,()=>n+" Shapes ".concat(e," and ").concat(t," must match"));for(let a=0;a<e.length;a++){const s=e[a],r=t[a];bu(s<0||r<0||s===r,()=>n+" Shapes ".concat(e," and ").concat(t," must match"))}}}function uP(e){return"number"!==typeof e&&!e.some(e=>e<0)}function hP(e,t,n){let a=dP(e,n);const s=!uP(a);if(s&&0===t.length)throw new Error("Tried to calculate elements of an empty list"+" with non-fully-defined elementShape: ".concat(a));if(s&&t.forEach(e=>{a=dP(e.shape,a)}),!uP(a))throw new Error("Non-fully-defined elementShape: ".concat(a));return a}function dP(e,t){if("number"===typeof e)return t;if("number"===typeof t)return e;if(e.length!==t.length)throw new Error("Incompatible ranks during merge: ".concat(e," vs. ").concat(t));const n=[];for(let a=0;a<e.length;++a){const s=e[a],r=t[a];if(s>=0&&r>=0&&s!==r)throw new Error("Incompatible shape during merge: ".concat(e," vs. ").concat(t));n[a]=s>=0?s:r}return n}class pP{constructor(e,t,n,a,s,r,i){this.name=e,this.dtype=t,this.maxSize=n,this.elementShape=a,this.identicalElementShapes=s,this.dynamicSize=r,this.clearAfterRead=i,this.tensors=[],this.closed_=!1,this.idTensor=fy(0),Qm(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{null!=e&&e.has(t.tensor.id)||t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error("TensorArray ".concat(this.name," has already been closed."));if(e<0||e>=this.size())throw new Error("Tried to read from index ".concat(e,", but array size is: ").concat(this.size()));const t=this.tensors[e];if(t.cleared)throw new Error("TensorArray ".concat(this.name,": Could not read index ").concat(e," twice because it was cleared after a previous read ")+"(perhaps try setting clear_after_read = false?).");return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(e=>this.read(e))}write(e,t){if(this.closed_)throw new Error("TensorArray ".concat(this.name," has already been closed."));if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error("Tried to write to index ".concat(e,", but array is not resizeable and size is: ").concat(this.maxSize));const n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error("TensorArray ".concat(this.name,": Could not write to TensorArray index ").concat(e,",\n          because the value dtype is ").concat(t.dtype,", but TensorArray dtype is ").concat(this.dtype,"."));if(0!==this.size()||null!=this.elementShape&&0!==this.elementShape.length||(this.elementShape=t.shape),lP(this.elementShape,t.shape,"TensorArray ".concat(this.name,": Could not write to TensorArray index ").concat(e,".")),n.read)throw new Error("TensorArray ".concat(this.name,": Could not write to TensorArray index ").concat(e,", because it has already been read."));if(n.written)throw new Error("TensorArray ".concat(this.name,": Could not write to TensorArray index ").concat(e,", because it has already been written."));n.tensor=t,Qm(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error("TensorArray ".concat(this.name,": could not write multiple tensors,")+"because the index size: ".concat(e.length," is not the same as tensors size: ").concat(t.length,"."));e.forEach((e,n)=>this.write(e,t[n]))}gather(e,t){if(t&&t!==this.dtype)throw new Error("TensorArray dtype is ".concat(this.dtype," but gather requested dtype ").concat(t));if(e)e=e.slice(0,this.size());else{e=[];for(let t=0;t<this.size();t++)e.push(t)}if(0===e.length)return Um([],[0].concat(this.elementShape));const n=this.readMany(e);return lP(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),ak(n,0)}concat(e){if(e&&e!==this.dtype)throw new Error("TensorArray dtype is ".concat(this.dtype," but concat requested dtype ").concat(e));if(0===this.size())return Um([],[0].concat(this.elementShape));const t=[];for(let a=0;a<this.size();a++)t.push(a);const n=this.readMany(t);return lP(this.elementShape,n[0].shape,"TensorArray shape mismatch: tensor array shape (".concat(this.elementShape,") vs first tensor shape (").concat(n[0].shape,")")),rx(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error("TensorArray dtype is ".concat(this.dtype," but tensor has dtype ").concat(t.dtype));if(e.length!==t.shape[0])throw new Error("Expected len(indices) == tensor.shape[0], but saw: ".concat(e.length," vs. ").concat(t.shape[0]));const n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error("Max index must be < array size (".concat(n,"  vs. ").concat(this.maxSize,")"));this.writeMany(e,vk(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error("TensorArray dtype is ".concat(this.dtype," but tensor has dtype ").concat(t.dtype));let n=0;const a=e.map(e=>(n+=e,n));if(n!==t.shape[0])throw new Error("Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ".concat(n,", and tensor's shape is: ").concat(t.shape));if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error("TensorArray's size is not equal to the size of lengths (".concat(this.maxSize," vs. ").concat(e.length,"), ")+"and the TensorArray is not marked as dynamically resizeable");const s=0===n?0:t.size/n,r=[];Xm(()=>{t=nx(t,[1,n,s]);for(let n=0;n<e.length;++n){const i=[0,0===n?0:a[n-1],0],o=[1,e[n],s];r[n]=nx(cx(t,i,o),this.elementShape)}return r});const i=[];for(let o=0;o<e.length;o++)i[o]=o;this.writeMany(i,r)}}class fP{get id(){return this.idTensor.id}constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:-1;this.tensors=e,this.elementShape=t,this.elementDtype=n,null!=e&&e.forEach(e=>{if(n!==e.dtype)throw new Error("Invalid data types; op elements ".concat(n,", but list elements ").concat(e.dtype));lP(t,e.shape,"TensorList shape mismatch: "),Qm(e)}),this.idTensor=fy(0),this.maxNumElements=a,Qm(this.idTensor)}copy(){return new fP([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{null!=e&&e.has(t.id)||t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;if(t!==this.elementDtype)throw new Error("Invalid data types; op elements ".concat(t,", but list elements ").concat(this.elementDtype));if(-1!==n&&this.tensors.length!==n)throw new Error("Operation expected a list with ".concat(n," elements but got a list with ").concat(this.tensors.length," elements."));lP(e,this.elementShape,"TensorList shape mismatch: ");const a=hP(this.elementShape,this.tensors,e);return Xm(()=>{const e=this.tensors.map(e=>nx(e,a));return ak(e,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error("Invalid data types; op elements ".concat(t,", but list elements ").concat(this.elementDtype));if(0===this.size())throw new Error("Trying to pop from an empty list.");const n=hP(this.elementShape,this.tensors,e),a=this.tensors.pop();return a.kept=!1,lP(a.shape,e,"TensorList shape mismatch: "),nx(a,n)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error("Invalid data types; op elements ".concat(e.dtype,", but list elements ").concat(this.elementDtype));if(lP(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");Qm(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error("TensorListResize expects size to be non-negative. Got: ".concat(e));if(-1!==this.maxNumElements&&e>this.maxNumElements)throw new Error("TensorListResize input size ".concat(e," is greater maxNumElement ").concat(this.maxNumElements,"."));const t=new fP([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let n=0;n<Math.min(this.tensors.length,e);++n)t.tensors[n]=this.tensors[n];return t}getItem(e,t,n){if(n!==this.elementDtype)throw new Error("Invalid data types; op elements ".concat(n,", but list elements ").concat(this.elementDtype));if(e<0||e>this.tensors.length)throw new Error("Trying to access element ".concat(e," in a list with ").concat(this.tensors.length," elements."));if(null==this.tensors[e])throw new Error("element at index ".concat(e," is null."));lP(this.tensors[e].shape,t,"TensorList shape mismatch: ");const a=hP(this.elementShape,this.tensors,t);return nx(this.tensors[e],a)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error("Invalid data types; op elements ".concat(t.dtype,", but list elements ").concat(this.elementDtype));if(e<0||-1!==this.maxNumElements&&e>=this.maxNumElements)throw new Error("Trying to set element ".concat(e," in a list with max ").concat(this.maxNumElements," elements."));lP(this.elementShape,t.shape,"TensorList shape mismatch: "),Qm(t),null!=this.tensors[e]&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,n){if(t!==this.elementDtype)throw new Error("Invalid data types; op elements ".concat(t,", but list elements ").concat(this.elementDtype));lP(this.elementShape,n,"TensorList shape mismatch: "),e=e.slice(0,this.size());const a=hP(this.elementShape,this.tensors,n);return 0===e.length?Um([],[0].concat(a)):Xm(()=>{const t=e.map(e=>nx(this.tensors[e],a));return ak(t,0)})}concat(e,t){if(e&&e!==this.elementDtype)throw new Error("TensorList dtype is ".concat(this.elementDtype," but concat requested dtype ").concat(e));lP(this.elementShape,t,"TensorList shape mismatch: ");const n=hP(this.elementShape,this.tensors,t);return 0===this.size()?Um([],[0].concat(n)):Xm(()=>{const e=this.tensors.map(e=>nx(e,n));return rx(e,0)})}}const mP=async(e,t,n)=>{switch(e.op){case"If":case"StatelessIf":{const a=vM("thenBranch",e,t,n),s=vM("elseBranch",e,t,n),r=vM("cond",e,t,n),i=vM("args",e,t,n);return(await r.data())[0]?n.functionMap[a].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap):n.functionMap[s].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{const a=vM("body",e,t,n),s=vM("cond",e,t,n),r=vM("args",e,t,n),i=await n.functionMap[s].executeFunctionAsync(r,n.tensorArrayMap,n.tensorListMap),o=r.map(e=>e.id);let c=await i[0].data();i.forEach(e=>{e.kept||-1!==o.indexOf(e.id)||e.dispose()});let l=r;for(;c[0];){const e=l;l=await n.functionMap[a].executeFunctionAsync(l,n.tensorArrayMap,n.tensorListMap);const t=l.map(e=>e.id);e.forEach(e=>{e.kept||-1!==o.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()});const r=await n.functionMap[s].executeFunctionAsync(l,n.tensorArrayMap,n.tensorListMap);c=await r[0].data(),r.forEach(e=>{e.kept||-1!==o.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()})}return l}case"LoopCond":return[TM(vM("pred",e,t,n))];case"Switch":{const a=vM("pred",e,t,n);let s=vM("data",e,t,n);return s.kept||(s=TM(s)),(await a.data())[0]?[void 0,s]:[s,void 0]}case"Merge":{const a=e.inputNames.find(e=>void 0!==wM(e,t,n));if(a){return[TM(wM(a,t,n))]}return}case"Enter":{const a=vM("frameName",e,t,n),s=vM("tensor",e,t,n);return n.enterFrame(a),[TM(s)]}case"Exit":{const a=vM("tensor",e,t,n);return n.exitFrame(),[TM(a)]}case"NextIteration":{const a=vM("tensor",e,t,n);return n.nextIteration(),[TM(a)]}case"TensorArrayV3":{const a=vM("size",e,t,n),s=vM("dtype",e,t,n),r=vM("elementShape",e,t,n),i=vM("dynamicSize",e,t,n),o=vM("clearAfterRead",e,t,n),c=vM("identicalElementShapes",e,t,n),l=vM("name",e,t,n),u=new pP(l,s,a,r,c,i,o);return n.addTensorArray(u),[u.idTensor,fy(1)]}case"TensorArrayWriteV3":{const a=vM("tensorArrayId",e,t,n),s=vM("index",e,t,n),r=vM("tensor",e,t,n),i=n.getTensorArray(a.id);return i.write(s,r),[i.idTensor]}case"TensorArrayReadV3":{const a=vM("tensorArrayId",e,t,n),s=vM("index",e,t,n);return[n.getTensorArray(a.id).read(s)]}case"TensorArrayGatherV3":{const a=vM("tensorArrayId",e,t,n),s=vM("indices",e,t,n),r=vM("dtype",e,t,n);return[n.getTensorArray(a.id).gather(s,r)]}case"TensorArrayScatterV3":{const a=vM("tensorArrayId",e,t,n),s=vM("indices",e,t,n),r=vM("tensor",e,t,n),i=n.getTensorArray(a.id);return i.scatter(s,r),[i.idTensor]}case"TensorArrayConcatV3":{const a=vM("tensorArrayId",e,t,n),s=n.getTensorArray(a.id),r=vM("dtype",e,t,n);return[s.concat(r)]}case"TensorArraySplitV3":{const a=vM("tensorArrayId",e,t,n),s=vM("tensor",e,t,n),r=vM("lengths",e,t,n),i=n.getTensorArray(a.id);return i.split(r,s),[i.idTensor]}case"TensorArraySizeV3":{const a=vM("tensorArrayId",e,t,n);return[fy(n.getTensorArray(a.id).size(),"int32")]}case"TensorArrayCloseV3":{const a=vM("tensorArrayId",e,t,n),s=n.getTensorArray(a.id);return s.clearAndClose(),[s.idTensor]}case"TensorListSetItem":{const a=vM("tensorListId",e,t,n),s=vM("index",e,t,n),r=vM("tensor",e,t,n),i=n.getTensorList(a.id);return i.setItem(s,r),[i.idTensor]}case"TensorListGetItem":{const a=vM("tensorListId",e,t,n),s=vM("index",e,t,n),r=vM("elementShape",e,t,n),i=vM("elementDType",e,t,n);return[n.getTensorList(a.id).getItem(s,r,i)]}case"TensorListScatterV2":case"TensorListScatter":{const a=vM("indices",e,t,n),s=function(e,t,n,a){if(t.length!==e.shape[0])throw new Error("Expected len(indices) == tensor.shape[0], but saw: ".concat(t.length," vs. ").concat(e.shape[0]));const s=Math.max(...t);if(null!=a&&-1!==a&&s>=a)throw new Error("Max index must be < array size (".concat(s,"  vs. ").concat(a,")"));const r=new fP([],n,e.dtype,a),i=vk(e,0);return t.forEach((e,t)=>{r.setItem(e,i[t])}),r}(vM("tensor",e,t,n),a,vM("elementShape",e,t,n),vM("numElements",e,t,n));return n.addTensorList(s),[s.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const a=vM("elementShape",e,t,n),s=vM("elementDType",e,t,n);let r;r="TensorListReserve"===e.op?"numElements":"maxNumElements";const i=vM(r,e,t,n),o=function(e,t,n,a){return new fP([],e,t,a)}(a,s,0,"TensorListReserve"===e.op?-1:i);return n.addTensorList(o),[o.idTensor]}case"TensorListGather":{const a=vM("tensorListId",e,t,n),s=vM("indices",e,t,n),r=vM("elementShape",e,t,n),i=vM("elementDType",e,t,n);return[n.getTensorList(a.id).gather(s,i,r)]}case"TensorListStack":{const a=vM("tensorListId",e,t,n),s=vM("elementShape",e,t,n),r=vM("elementDType",e,t,n),i=vM("numElements",e,t,n);return[n.getTensorList(a.id).stack(s,r,i)]}case"TensorListFromTensor":{const a=function(e,t,n){const a=e.dtype;if(e.shape.length<1)throw new Error("Tensor must be at least a vector, but saw shape: ".concat(e.shape));if(e.dtype!==n)throw new Error("Invalid data types; op elements ".concat(e.dtype,", but list elements ").concat(n));lP(e.shape.slice(1),t,"TensorList shape mismatch: ");const s=vk(e);return new fP(s,t,a)}(vM("tensor",e,t,n),vM("elementShape",e,t,n),vM("elementDType",e,t,n));return n.addTensorList(a),[a.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const a=vM("tensorListId",e,t,n),s=n.getTensorList(a.id),r=vM("dtype",e,t,n),i=vM("elementShape",e,t,n);return[s.concat(r,i)]}case"TensorListPushBack":{const a=vM("tensorListId",e,t,n),s=vM("tensor",e,t,n),r=n.getTensorList(a.id);return r.pushBack(s),[r.idTensor]}case"TensorListPopBack":{const a=vM("tensorListId",e,t,n),s=vM("elementShape",e,t,n),r=vM("elementDType",e,t,n);return[n.getTensorList(a.id).popBack(s,r)]}case"TensorListSplit":{const a=vM("tensor",e,t,n),s=vM("elementShape",e,t,n),r=function(e,t,n){let a=0;const s=t.map(e=>(a+=e,a));if(a!==e.shape[0])throw new Error("Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ".concat(a,", and tensor's shape is: ").concat(e.shape));const r=dP(e.shape.slice(1),n),i=0===a?0:e.size/a,o=Xm(()=>{const n=[];e=nx(e,[1,a,i]);for(let a=0;a<t.length;++a){const o=[0,0===a?0:s[a-1],0],c=[1,t[a],i];n[a]=nx(cx(e,o,c),r)}return e.dispose(),n}),c=new fP([],n,e.dtype,t.length);for(let l=0;l<o.length;l++)c.setItem(l,o[l]);return c}(a,vM("lengths",e,t,n),s);return n.addTensorList(r),[r.idTensor]}case"TensorListLength":{const a=vM("tensorListId",e,t,n);return[fy(n.getTensorList(a.id).size(),"int32")]}case"TensorListResize":{const a=vM("tensorListId",e,t,n),s=vM("size",e,t,n),r=n.getTensorList(a.id).resize(s);return n.addTensorList(r),[r.idTensor]}default:throw TypeError("Node type ".concat(e.op," is not implemented"))}};function gP(e,t,n){const[a,s]=vM("fusedOps",e,t,n),r="biasadd"===a,i=!r,o="prelu"===s,c="fusedbatchnorm"===a,l=vM("numArgs",e,t,n);if(r){if(o&&2!==l)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&r&&1!==l)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(c)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const u=vM("strides",e,t,n),h=NM(e,t,n),d=vM("dataFormat",e,t,n).toUpperCase(),p=vM("dilations",e,t,n);let[f,m]=vM("args",e,t,n);i&&(m=f,f=void 0);return{stride:u,pad:h,dataFormat:d,dilations:p,biasArg:f,preluArg:m,activationFunc:s,leakyreluAlpha:vM("leakyreluAlpha",e,t,n)}}function yP(e,t,n){return{boxes:vM("boxes",e,t,n),scores:vM("scores",e,t,n),maxOutputSize:vM("maxOutputSize",e,t,n),iouThreshold:vM("iouThreshold",e,t,n),scoreThreshold:vM("scoreThreshold",e,t,n),softNmsSigma:vM("softNmsSigma",e,t,n)}}class bP{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=fy(0),this.tensorMap=new Map,Qm(this.handle)}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return fy(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const n=await e.data();return this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),Xm(()=>{const e=vk(t),a=n.length,s=e.length;bu(a===s,()=>"The number of elements doesn't match, keys has "+"".concat(a," elements, the values has ").concat(s," ")+"elements.");for(let t=0;t<a;t++){const a=n[t],s=e[t];Qm(s),this.tensorMap.set(a,s)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);const n=await e.data();return Xm(()=>{const e=[];for(let a=0;a<n.length;a++){const s=n[a],r=this.findWithDefault(s,t);e.push(r)}return ak(e)})}findWithDefault(e,t){const n=this.tensorMap.get(e);return null!=n?n:t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error("Expect key dtype ".concat(this.keyDType,", but got ")+"".concat(e.dtype));if(t.dtype!==this.valueDType)throw new Error("Expect value dtype ".concat(this.valueDType,", but got ")+"".concat(t.dtype))}}function xP(e,t,n,a){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Xm;const r=((e,t,n)=>{switch(e.category){case"arithmetic":return s(()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I;switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[a.add(vM("a",e,t,n),vM("b",e,t,n))];case"AddN":return[a.addN(vM("tensors",e,t,n))];case"FloorMod":case"Mod":return[a.mod(vM("a",e,t,n),vM("b",e,t,n))];case"Mul":return[a.mul(vM("a",e,t,n),vM("b",e,t,n))];case"RealDiv":case"Div":return[a.div(vM("a",e,t,n),vM("b",e,t,n))];case"DivNoNan":return[a.divNoNan(vM("a",e,t,n),vM("b",e,t,n))];case"FloorDiv":return[a.floorDiv(vM("a",e,t,n),vM("b",e,t,n))];case"Sub":return[a.sub(vM("a",e,t,n),vM("b",e,t,n))];case"Minimum":return[a.minimum(vM("a",e,t,n),vM("b",e,t,n))];case"Maximum":return[a.maximum(vM("a",e,t,n),vM("b",e,t,n))];case"Pow":return[a.pow(vM("a",e,t,n),vM("b",e,t,n))];case"SquaredDifference":return[a.squaredDifference(vM("a",e,t,n),vM("b",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n));case"basic_math":return s(()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I;switch(e.op){case"Abs":case"ComplexAbs":return[a.abs(vM("x",e,t,n))];case"Acos":return[a.acos(vM("x",e,t,n))];case"Acosh":return[a.acosh(vM("x",e,t,n))];case"Asin":return[a.asin(vM("x",e,t,n))];case"Asinh":return[a.asinh(vM("x",e,t,n))];case"Atan":return[a.atan(vM("x",e,t,n))];case"Atan2":return[a.atan2(vM("x",e,t,n),vM("y",e,t,n))];case"Atanh":return[a.atanh(vM("x",e,t,n))];case"Ceil":return[a.ceil(vM("x",e,t,n))];case"Complex":return[a.complex(vM("real",e,t,n),vM("imag",e,t,n))];case"Cos":return[a.cos(vM("x",e,t,n))];case"Cosh":return[a.cosh(vM("x",e,t,n))];case"Elu":return[a.elu(vM("x",e,t,n))];case"Erf":return[a.erf(vM("x",e,t,n))];case"Exp":return[a.exp(vM("x",e,t,n))];case"Expm1":return[a.expm1(vM("x",e,t,n))];case"Floor":return[a.floor(vM("x",e,t,n))];case"Log":return[a.log(vM("x",e,t,n))];case"Log1p":return[a.log1p(vM("x",e,t,n))];case"Imag":return[a.imag(vM("x",e,t,n))];case"Neg":return[a.neg(vM("x",e,t,n))];case"Reciprocal":return[a.reciprocal(vM("x",e,t,n))];case"Real":return[a.real(vM("x",e,t,n))];case"Relu":return[a.relu(vM("x",e,t,n))];case"Round":return[a.round(vM("x",e,t,n))];case"Selu":return[a.selu(vM("x",e,t,n))];case"Sigmoid":return[a.sigmoid(vM("x",e,t,n))];case"Sin":return[a.sin(vM("x",e,t,n))];case"Sign":return[a.sign(vM("x",e,t,n))];case"Sinh":return[a.sinh(vM("x",e,t,n))];case"Softplus":return[a.softplus(vM("x",e,t,n))];case"Sqrt":return[a.sqrt(vM("x",e,t,n))];case"Square":return[a.square(vM("x",e,t,n))];case"Tanh":return[a.tanh(vM("x",e,t,n))];case"Tan":return[a.tan(vM("x",e,t,n))];case"ClipByValue":return[a.clipByValue(vM("x",e,t,n),vM("clipValueMin",e,t,n),vM("clipValueMax",e,t,n))];case"Relu6":return[a.relu6(vM("x",e,t,n))];case"Rsqrt":return[a.rsqrt(wM(e.inputNames[0],t,n))];case"LeakyRelu":return[a.leakyRelu(vM("x",e,t,n),vM("alpha",e,t,n))];case"Prelu":return[a.prelu(vM("x",e,t,n),vM("alpha",e,t,n))];case"IsNan":return[a.isNaN(wM(e.inputNames[0],t,n))];case"IsInf":return[a.isInf(wM(e.inputNames[0],t,n))];case"IsFinite":return[a.isFinite(wM(e.inputNames[0],t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n));case"control":return mP(e,t,n);case"convolution":return s(()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I;switch(e.op){case"Conv1D":{const s=vM("stride",e,t,n),r=vM("pad",e,t,n),i=vM("dataFormat",e,t,n).toUpperCase(),o=vM("dilation",e,t,n);return[a.conv1d(vM("x",e,t,n),vM("filter",e,t,n),s,r,i,o)]}case"Conv2D":{const s=vM("strides",e,t,n),r=NM(e,t,n),i=vM("dataFormat",e,t,n).toUpperCase(),o=vM("dilations",e,t,n);return[a.conv2d(vM("x",e,t,n),vM("filter",e,t,n),[s[1],s[2]],r,i,[o[1],o[2]])]}case"_FusedConv2D":{const{stride:s,pad:r,dataFormat:i,dilations:o,biasArg:c,preluArg:l,activationFunc:u,leakyreluAlpha:h}=gP(e,t,n);return[a.fused.conv2d({x:vM("x",e,t,n),filter:vM("filter",e,t,n),strides:[s[1],s[2]],pad:r,dataFormat:i,dilations:[o[1],o[2]],bias:c,activation:u,preluActivationWeights:l,leakyreluAlpha:h})]}case"FusedDepthwiseConv2dNative":{const{stride:s,pad:r,dataFormat:i,dilations:o,biasArg:c,preluArg:l,activationFunc:u,leakyreluAlpha:h}=gP(e,t,n);return[a.fused.depthwiseConv2d({x:vM("x",e,t,n),filter:vM("filter",e,t,n),strides:[s[1],s[2]],pad:r,dataFormat:i,dilations:[o[1],o[2]],bias:c,activation:u,preluActivationWeights:l,leakyreluAlpha:h})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const s=vM("outputShape",e,t,n),r=vM("strides",e,t,n),i=NM(e,t,n);return[a.conv2dTranspose(vM("x",e,t,n),vM("filter",e,t,n),s,[r[1],r[2]],i)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const s=vM("strides",e,t,n),r=NM(e,t,n),i=vM("dilations",e,t,n),o=vM("dataFormat",e,t,n).toUpperCase();return[a.depthwiseConv2d(vM("input",e,t,n),vM("filter",e,t,n),[s[1],s[2]],r,o,[i[1],i[2]])]}case"Conv3D":{const s=vM("strides",e,t,n),r=vM("pad",e,t,n),i=vM("dataFormat",e,t,n).toUpperCase(),o=vM("dilations",e,t,n);return[a.conv3d(vM("x",e,t,n),vM("filter",e,t,n),[s[1],s[2],s[3]],r,i,[o[1],o[2],o[3]])]}case"AvgPool":{const s=vM("strides",e,t,n),r=vM("pad",e,t,n),i=vM("kernelSize",e,t,n);return[a.avgPool(vM("x",e,t,n),[i[1],i[2]],[s[1],s[2]],r)]}case"MaxPool":{const s=vM("strides",e,t,n),r=vM("pad",e,t,n),i=vM("kernelSize",e,t,n);return[a.maxPool(vM("x",e,t,n),[i[1],i[2]],[s[1],s[2]],r)]}case"MaxPoolWithArgmax":{const s=vM("strides",e,t,n),r=vM("pad",e,t,n),i=vM("kernelSize",e,t,n),o=vM("includeBatchInIndex",e,t,n),{result:c,indexes:l}=a.maxPoolWithArgmax(vM("x",e,t,n),[i[1],i[2]],[s[1],s[2]],r,o);return[c,l]}case"AvgPool3D":{const s=vM("strides",e,t,n),r=vM("pad",e,t,n),i=vM("kernelSize",e,t,n);return[a.avgPool3d(vM("x",e,t,n),[i[1],i[2],i[3]],[s[1],s[2],s[3]],r)]}case"MaxPool3D":{const s=vM("strides",e,t,n),r=vM("pad",e,t,n),i=vM("kernelSize",e,t,n);return[a.maxPool3d(vM("x",e,t,n),[i[1],i[2],i[3]],[s[1],s[2],s[3]],r)]}case"Dilation2D":{const s=vM("strides",e,t,n),r=vM("pad",e,t,n),i=vM("dilations",e,t,n),o=s[1],c=s[2],l=i[1],u=i[2];return[a.dilation2d(vM("x",e,t,n),vM("filter",e,t,n),[o,c],r,[l,u],"NHWC")]}default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n));case"creation":return s(()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I;switch(e.op){case"Fill":{const s=vM("shape",e,t,n),r=vM("dtype",e,t,n),i=vM("value",e,t,n);return[a.fill(s,i,r)]}case"LinSpace":{const s=vM("start",e,t,n),r=vM("stop",e,t,n),i=vM("num",e,t,n);return[a.linspace(s,r,i)]}case"Multinomial":{const s=vM("logits",e,t,n),r=vM("numSamples",e,t,n),i=vM("seed",e,t,n);return[a.multinomial(s,r,i)]}case"OneHot":{const s=vM("indices",e,t,n),r=vM("depth",e,t,n),i=vM("onValue",e,t,n),o=vM("offValue",e,t,n),c=vM("dtype",e,t,n);return[a.oneHot(s,r,i,o,c)]}case"Ones":return[a.ones(vM("shape",e,t,n),vM("dtype",e,t,n))];case"OnesLike":return[a.onesLike(vM("x",e,t,n))];case"RandomStandardNormal":return[a.randomStandardNormal(vM("shape",e,t,n),vM("dtype",e,t,n),vM("seed",e,t,n))];case"RandomUniform":return[a.randomUniform(vM("shape",e,t,n),vM("minval",e,t,n),vM("maxval",e,t,n),vM("dtype",e,t,n))];case"RandomUniformInt":return[a.randomUniformInt(vM("shape",e,t,n),vM("minval",e,t,n),vM("maxval",e,t,n),vM("seed",e,t,n))];case"Range":{const s=vM("start",e,t,n),r=vM("stop",e,t,n),i=vM("step",e,t,n);return[a.range(s,r,i,vM("dtype",e,t,n))]}case"TruncatedNormal":{const s=vM("shape",e,t,n),r=vM("mean",e,t,n),i=vM("stdDev",e,t,n),o=vM("seed",e,t,n);return[a.truncatedNormal(s,r,i,vM("dtype",e,t,n),o)]}case"Zeros":return[a.zeros(vM("shape",e,t,n),vM("dtype",e,t,n))];case"ZerosLike":return[a.zerosLike(vM("x",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n));case"dynamic":return async function(e,t,n,a){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:I;switch(e.op){case"NonMaxSuppressionV5":{const{boxes:a,scores:r,maxOutputSize:i,iouThreshold:o,scoreThreshold:c,softNmsSigma:l}=yP(e,t,n),u=await s.image.nonMaxSuppressionWithScoreAsync(a,r,i,o,c,l);return[u.selectedIndices,u.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:a,scores:r,maxOutputSize:i,iouThreshold:o,scoreThreshold:c}=yP(e,t,n),l=vM("padToMaxOutputSize",e,t,n),u=await s.image.nonMaxSuppressionPaddedAsync(a,r,i,o,c,l);return[u.selectedIndices,u.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:a,scores:r,maxOutputSize:i,iouThreshold:o,scoreThreshold:c}=yP(e,t,n);return[await s.image.nonMaxSuppressionAsync(a,r,i,o,c)]}case"Where":{const a=s.cast(vM("condition",e,t,n),"bool"),r=[await s.whereAsync(a)];return a.dispose(),r}case"ListDiff":return s.setdiff1dAsync(vM("x",e,t,n),vM("y",e,t,n));default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n);case"evaluation":return s(()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I;switch(e.op){case"LowerBound":{const s=vM("sortedSequence",e,t,n),r=vM("values",e,t,n);return[a.lowerBound(s,r)]}case"TopKV2":{const s=vM("x",e,t,n),r=vM("k",e,t,n),i=vM("sorted",e,t,n),o=a.topk(s,r,i);return[o.values,o.indices]}case"UpperBound":{const s=vM("sortedSequence",e,t,n),r=vM("values",e,t,n);return[a.upperBound(s,r)]}case"Unique":{const s=vM("x",e,t,n),r=a.unique(s);return[r.values,r.indices]}case"UniqueV2":{const s=vM("x",e,t,n),r=vM("axis",e,t,n),i=a.unique(s,r);return[i.values,i.indices]}default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n));case"image":return s(()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I;switch(e.op){case"ResizeBilinear":{const s=vM("images",e,t,n),r=vM("size",e,t,n),i=vM("alignCorners",e,t,n),o=vM("halfPixelCenters",e,t,n);return[a.image.resizeBilinear(s,[r[0],r[1]],i,o)]}case"ResizeNearestNeighbor":{const s=vM("images",e,t,n),r=vM("size",e,t,n),i=vM("alignCorners",e,t,n),o=vM("halfPixelCenters",e,t,n);return[a.image.resizeNearestNeighbor(s,[r[0],r[1]],i,o)]}case"CropAndResize":{const s=vM("image",e,t,n),r=vM("boxes",e,t,n),i=vM("boxInd",e,t,n),o=vM("cropSize",e,t,n),c=vM("method",e,t,n),l=vM("extrapolationValue",e,t,n);return[a.image.cropAndResize(s,r,i,o,c,l)]}case"ImageProjectiveTransformV3":{const s=vM("images",e,t,n),r=vM("transforms",e,t,n),i=vM("outputShape",e,t,n),o=vM("fillValue",e,t,n),c=vM("interpolation",e,t,n),l=vM("fillMode",e,t,n);return[a.image.transform(s,r,c.toLowerCase(),l.toLowerCase(),o,i)]}default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n));case"graph":return s(()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I;switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":const s=vM("default",e,t,n);return[wM(e.name,t,n)||s];case"Placeholder":return[wM(e.name,t,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":case"Snapshot":return[TM(vM("x",e,t,n))];case"IdentityN":return vM("x",e,t,n).map(e=>TM(e));case"Shape":return[a.tensor1d(vM("x",e,t,n).shape,"int32")];case"ShapeN":return vM("x",e,t,n).map(e=>a.tensor1d(e.shape));case"Size":return[a.scalar(vM("x",e,t,n).size,"int32")];case"Rank":return[a.scalar(vM("x",e,t,n).rank,"int32")];case"NoOp":return[a.scalar(1)];case"Print":const r=vM("x",e,t,n),i=vM("data",e,t,n),o=vM("message",e,t,n),c=vM("summarize",e,t,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(o);for(let e=0;e<i.length;e++)console.log(Array.prototype.slice.call(i[e].dataSync()).slice(0,c));return[r];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n));case"logical":return s(()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I;switch(e.op){case"Equal":return[a.equal(vM("a",e,t,n),vM("b",e,t,n))];case"NotEqual":return[a.notEqual(vM("a",e,t,n),vM("b",e,t,n))];case"Greater":return[a.greater(vM("a",e,t,n),vM("b",e,t,n))];case"GreaterEqual":return[a.greaterEqual(vM("a",e,t,n),vM("b",e,t,n))];case"Less":return[a.less(vM("a",e,t,n),vM("b",e,t,n))];case"LessEqual":return[a.lessEqual(vM("a",e,t,n),vM("b",e,t,n))];case"LogicalAnd":return[a.logicalAnd(vM("a",e,t,n),vM("b",e,t,n))];case"LogicalNot":return[a.logicalNot(vM("a",e,t,n))];case"LogicalOr":return[a.logicalOr(vM("a",e,t,n),vM("b",e,t,n))];case"Select":case"SelectV2":return[a.where(vM("condition",e,t,n),vM("a",e,t,n),vM("b",e,t,n))];case"BitwiseAnd":return[a.bitwiseAnd(vM("a",e,t,n),vM("b",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n));case"matrices":return s(()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I;switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[a.matMul(vM("a",e,t,n),vM("b",e,t,n),vM("transposeA",e,t,n),vM("transposeB",e,t,n))];case"Einsum":return[a.einsum(vM("equation",e,t,n),...vM("tensors",e,t,n))];case"Transpose":return[a.transpose(vM("x",e,t,n),vM("perm",e,t,n))];case"_FusedMatMul":const[s,r]=vM("fusedOps",e,t,n),i="biasadd"===s,o="prelu"===r,c=vM("numArgs",e,t,n),l=vM("leakyreluAlpha",e,t,n);if(i){if(o&&2!==c)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&1!==c)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[u,h]=vM("args",e,t,n);return[a.fused.matMul({a:vM("a",e,t,n),b:vM("b",e,t,n),transposeA:vM("transposeA",e,t,n),transposeB:vM("transposeB",e,t,n),bias:u,activation:r,preluActivationWeights:h,leakyreluAlpha:l})];case"MatrixBandPart":return[a.linalg.bandPart(vM("a",e,t,n),vM("numLower",e,t,n),vM("numUpper",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n));case"normalization":return s(()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I;switch(e.op){case"EuclideanNorm":return[a.euclideanNorm(vM("x",e,t,n),vM("axis",e,t,n),vM("keepDims",e,t,n))];case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[a.batchNorm(vM("x",e,t,n),vM("mean",e,t,n),vM("variance",e,t,n),vM("offset",e,t,n),vM("scale",e,t,n),vM("epsilon",e,t,n))];case"LRN":return[a.localResponseNormalization(vM("x",e,t,n),vM("radius",e,t,n),vM("bias",e,t,n),vM("alpha",e,t,n),vM("beta",e,t,n))];case"Softmax":return[a.softmax(vM("x",e,t,n))];case"LogSoftmax":return[a.logSoftmax(vM("x",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n));case"ragged":return s(()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I;switch(e.op){case"RaggedGather":{const{outputNestedSplits:s,outputDenseValues:r}=a.raggedGather(vM("paramsNestedSplits",e,t,n),vM("paramsDenseValues",e,t,n),vM("indices",e,t,n),vM("outputRaggedRank",e,t,n));return s.concat(r)}case"RaggedRange":{const{rtNestedSplits:s,rtDenseValues:r}=a.raggedRange(vM("starts",e,t,n),vM("limits",e,t,n),vM("splits",e,t,n));return[s,r]}case"RaggedTensorToTensor":return[a.raggedTensorToTensor(vM("shape",e,t,n),vM("values",e,t,n),vM("defaultValue",e,t,n),vM("rowPartitionTensors",e,t,n),vM("rowPartitionTypes",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n));case"reduction":return s(()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I;switch(e.op){case"Max":{const s=vM("axis",e,t,n),r=vM("keepDims",e,t,n);return[a.max(vM("x",e,t,n),s,r)]}case"Mean":{const s=vM("axis",e,t,n),r=vM("keepDims",e,t,n);return[a.mean(vM("x",e,t,n),s,r)]}case"Min":{const s=vM("axis",e,t,n),r=vM("keepDims",e,t,n);return[a.min(vM("x",e,t,n),s,r)]}case"Sum":{const s=vM("axis",e,t,n),r=vM("keepDims",e,t,n);return[a.sum(vM("x",e,t,n),s,r)]}case"All":{const s=vM("axis",e,t,n),r=vM("keepDims",e,t,n);return[a.all(vM("x",e,t,n),s,r)]}case"Any":{const s=vM("axis",e,t,n),r=vM("keepDims",e,t,n);return[a.any(vM("x",e,t,n),s,r)]}case"ArgMax":{const s=vM("axis",e,t,n);return[a.argMax(vM("x",e,t,n),s)]}case"ArgMin":{const s=vM("axis",e,t,n);return[a.argMin(vM("x",e,t,n),s)]}case"Prod":{const s=vM("axis",e,t,n),r=vM("keepDims",e,t,n);return[a.prod(vM("x",e,t,n),s,r)]}case"Cumprod":{const s=vM("axis",e,t,n),r=vM("exclusive",e,t,n),i=vM("reverse",e,t,n);return[a.cumprod(vM("x",e,t,n),s,r,i)]}case"Cumsum":{const s=vM("axis",e,t,n),r=vM("exclusive",e,t,n),i=vM("reverse",e,t,n);return[a.cumsum(vM("x",e,t,n),s,r,i)]}case"Bincount":const s=vM("x",e,t,n),r=vM("weights",e,t,n),i=vM("size",e,t,n);return[a.bincount(s,r,i)];case"DenseBincount":{const s=vM("x",e,t,n),r=vM("weights",e,t,n),i=vM("size",e,t,n),o=vM("binaryOutput",e,t,n);return[a.denseBincount(s,r,i,o)]}default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n));case"slice_join":return s(()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I;switch(e.op){case"ConcatV2":case"Concat":{const s=vM("n",e,t,n),r=vM("axis",e,t,n);let i=vM("tensors",e,t,n);return i=i.slice(0,s),[a.concat(i,r)]}case"Gather":{const s=vM("x",e,t,n),r=vM("indices",e,t,n);return[a.gather(s,a.cast(r,"int32"),0)]}case"GatherV2":{const s=vM("axis",e,t,n),r=vM("batchDims",e,t,n),i=vM("x",e,t,n),o=vM("indices",e,t,n);return[a.gather(i,a.cast(o,"int32"),s,r)]}case"Reverse":{const s=vM("dims",e,t,n),r=[];for(let e=0;e<s.length;e++)s[e]&&r.push(e);const i=vM("x",e,t,n);return[a.reverse(i,r)]}case"ReverseV2":{const s=vM("axis",e,t,n),r=vM("x",e,t,n);return[a.reverse(r,s)]}case"Slice":{const s=vM("begin",e,t,n),r=vM("size",e,t,n);return[a.slice(vM("x",e,t,n),s,r)]}case"StridedSlice":{const s=vM("begin",e,t,n),r=vM("end",e,t,n),i=vM("strides",e,t,n),o=vM("beginMask",e,t,n),c=vM("endMask",e,t,n),l=vM("ellipsisMask",e,t,n),u=vM("newAxisMask",e,t,n),h=vM("shrinkAxisMask",e,t,n),d=vM("x",e,t,n);return[a.stridedSlice(d,s,r,i,o,c,l,u,h)]}case"Pack":return Xm(()=>{const s=vM("axis",e,t,n),r=vM("tensors",e,t,n),i=r[0].shape,o=a.squeeze(r[0]).shape,c=r.map(e=>{const t=Su(e.shape,i);if(!t&&!Su(a.squeeze(e).shape,o))throw new Error("the input tensors shape does not match");return t?e:a.reshape(e,i)});return[a.stack(c,s)]});case"Unpack":{const s=vM("axis",e,t,n),r=vM("tensor",e,t,n);return a.unstack(r,s)}case"Tile":{const s=vM("reps",e,t,n);return[a.tile(vM("x",e,t,n),s)]}case"Split":case"SplitV":{const s=vM("axis",e,t,n),r=vM("numOrSizeSplits",e,t,n),i=vM("x",e,t,n);return a.split(i,r,s)}case"ScatterNd":{const s=vM("indices",e,t,n),r=vM("values",e,t,n),i=vM("shape",e,t,n);return[a.scatterND(s,r,i)]}case"GatherNd":{const s=vM("x",e,t,n),r=vM("indices",e,t,n);return[a.gatherND(s,r)]}case"SparseToDense":{const s=vM("sparseIndices",e,t,n),r=vM("outputShape",e,t,n),i=vM("sparseValues",e,t,n),o=vM("defaultValue",e,t,n);return[a.sparseToDense(s,i,r,i.dtype===o.dtype?o:a.cast(o,i.dtype))]}case"TensorScatterUpdate":{const s=vM("indices",e,t,n),r=vM("values",e,t,n),i=vM("tensor",e,t,n);return[a.tensorScatterUpdate(i,s,r)]}default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n));case"sparse":return s(()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I;switch(e.op){case"SparseFillEmptyRows":{const{outputIndices:s,outputValues:r,emptyRowIndicator:i,reverseIndexMap:o}=a.sparse.sparseFillEmptyRows(vM("indices",e,t,n),vM("values",e,t,n),vM("denseShape",e,t,n),vM("defaultValue",e,t,n));return[s,r,i,o]}case"SparseReshape":{const{outputIndices:s,outputShape:r}=a.sparse.sparseReshape(vM("inputIndices",e,t,n),vM("inputShape",e,t,n),vM("newShape",e,t,n));return[s,r]}case"SparseSegmentMean":return[a.sparse.sparseSegmentMean(vM("data",e,t,n),vM("indices",e,t,n),vM("segmentIds",e,t,n))];case"SparseSegmentSum":return[a.sparse.sparseSegmentSum(vM("data",e,t,n),vM("indices",e,t,n),vM("segmentIds",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n));case"spectral":return s(()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I;switch(e.op){case"FFT":return[a.fft(vM("x",e,t,n))];case"IFFT":return[a.ifft(vM("x",e,t,n))];case"RFFT":return[a.rfft(vM("x",e,t,n))];case"IRFFT":return[a.irfft(vM("x",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n));case"string":return s(()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I;switch(e.op){case"StaticRegexReplace":return[a.string.staticRegexReplace(vM("input",e,t,n),vM("pattern",e,t,n),vM("rewrite",e,t,n),vM("replaceGlobal",e,t,n))];case"StringNGrams":{const{nGrams:s,nGramsSplits:r}=a.string.stringNGrams(vM("data",e,t,n),vM("dataSplits",e,t,n),vM("separator",e,t,n),vM("nGramWidths",e,t,n),vM("leftPad",e,t,n),vM("rightPad",e,t,n),vM("padWidth",e,t,n),vM("preserveShortSequences",e,t,n));return[s,r]}case"StringSplit":{const{indices:s,values:r,shape:i}=a.string.stringSplit(vM("input",e,t,n),vM("delimiter",e,t,n),vM("skipEmpty",e,t,n));return[s,r,i]}case"StringToHashBucketFast":return[a.string.stringToHashBucketFast(vM("input",e,t,n),vM("numBuckets",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n));case"transformation":return s(()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I;switch(e.op){case"Cast":return[a.cast(vM("x",e,t,n),vM("dtype",e,t,n))];case"ExpandDims":{const s=vM("axis",e,t,n);return[a.expandDims(vM("x",e,t,n),s)]}case"Squeeze":{const s=vM("axis",e,t,n);return[a.squeeze(vM("x",e,t,n),s)]}case"Reshape":return[a.reshape(vM("x",e,t,n),vM("shape",e,t,n))];case"EnsureShape":return[a.ensureShape(vM("x",e,t,n),vM("shape",e,t,n))];case"MirrorPad":return[a.mirrorPad(vM("x",e,t,n),vM("padding",e,t,n),vM("mode",e,t,n))];case"PadV2":case"Pad":return[a.pad(vM("x",e,t,n),vM("padding",e,t,n),vM("constantValue",e,t,n))];case"SpaceToBatchND":{const s=vM("blockShape",e,t,n),r=vM("paddings",e,t,n);return[a.spaceToBatchND(vM("x",e,t,n),s,r)]}case"BatchToSpaceND":{const s=vM("blockShape",e,t,n),r=vM("crops",e,t,n);return[a.batchToSpaceND(vM("x",e,t,n),s,r)]}case"DepthToSpace":{const s=vM("blockSize",e,t,n),r=vM("dataFormat",e,t,n).toUpperCase();return[a.depthToSpace(vM("x",e,t,n),s,r)]}case"BroadcastTo":return[a.broadcastTo(vM("x",e,t,n),vM("shape",e,t,n))];case"BroadcastArgs":return[a.broadcastArgs(vM("s0",e,t,n),vM("s1",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n));case"hash_table":return(async(e,t,n,a)=>{switch(e.op){case"HashTable":case"HashTableV2":{const s=a.getHashTableHandleByName(e.name);if(null!=s)return[s];{const s=vM("keyDType",e,t,n),r=vM("valueDType",e,t,n),i=new bP(s,r);return a.addHashTable(e.name,i),[i.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const s=vM("tableHandle",e,t,n,a),r=vM("keys",e,t,n),i=vM("values",e,t,n),o=a.getHashTableById(s.id);return[await o.import(r,i)]}case"LookupTableFind":case"LookupTableFindV2":{const s=vM("tableHandle",e,t,n,a),r=vM("keys",e,t,n),i=vM("defaultValue",e,t,n),o=a.getHashTableById(s.id);return[await o.find(r,i)]}case"LookupTableSize":case"LookupTableSizeV2":{const s=vM("tableHandle",e,t,n,a);return[a.getHashTableById(s.id).tensorSize()]}default:throw TypeError("Node type ".concat(e.op," is not implemented"))}})(e,t,n,a);case"custom":const r=xM(e.op);if(r&&r.customExecutor)return r.customExecutor(new cP(e,t,n));throw TypeError("Custom op ".concat(e.op," is not registered."));default:throw TypeError("Unknown op '".concat(e.op,"'. File an issue at ")+"https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()")}})(e,t,n);return Qu(r)?r.then(e=>[].concat(e)):[].concat(r)}class vP{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},s=arguments.length>4?arguments[4]:void 0;this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=n,this.functionMap=a,this.parseNodeNameCache=s,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(e=>0===e.id&&0===e.iterationId?"":"".concat(e.frameName,"-").concat(e.iterationId)).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}function wP(e,t,n,a){const s=new Set,r=[];let i=null,o=null;const c=new Set,l=new Set(Object.keys(e).map(e=>IM(e)[0]));a=a||[];const u=new Set(a.map(e=>IM(e.name)[0])),h=[...t];for(;h.length>0;){const e=h.pop();(TP(e)||EP(e)||RP(e))&&null==i&&(i=e,o=i.children.map(e=>e.name).filter(e=>s.has(e))),s.add(e.name),null==n[e.name]&&(l.has(e.name)||u.has(e.name)||(0!==e.inputs.length?e.inputs.forEach(e=>{c.has(e.name)||(c.add(e.name),h.push(e))}):r.push(e.name)))}return{inputs:e,outputs:t,usedNodes:s,missingInputs:r,dynamicNode:i,syncInputs:o}}function kP(e,t){const{usedNodes:n,inputs:a}=t,s=Object.keys(a).map(e=>IM(e)[0]).map(t=>e.nodes[t]),r=e.initNodes||[],i=e=>n.has("string"===typeof e?e:e.name);function o(e){return[...new Map(e.map(e=>[e.name,e])).values()]}const c=o([...s,...e.weights,...r]).filter(i),l=o([...c,...Object.values(e.nodes)]).filter(i),u=new Map(l.map(e=>[e.name,e])),h={};for(const m of l){h[m.name]=h[m.name]||0;for(const e of m.children)i(e)||(h[e.name]=Number.POSITIVE_INFINITY),h[e.name]=(h[e.name]||0)+1}const d=Object.entries(h).filter(e=>{let[,t]=e;return 0===t}).map(e=>{let[t]=e;return t}),p=[...d];for(;d.length>0;){const e=d.pop(),t=u.get(e);for(const n of t.children.filter(i))0===--h[n.name]&&(p.push(n.name),d.push(n.name))}const f=function(e,t){const n=new Map(e.map(e=>[e.name,e])),a=t.map(e=>e.name),s=new Set(a);for(;a.length>0;){const e=a.pop(),t=n.get(e);for(const r of t.children)n.has(r.name)&&!s.has(r.name)&&(s.add(r.name),a.push(r.name))}const r=e.filter(e=>s.has(e.name));return r}(p.map(e=>u.get(e)),c);return function(e,t){const n=new Map(e.map((e,t)=>[e.name,t])),a=new Set(t.map(e=>e.name)),s=e=>a.has("string"===typeof e?e:e.name),r=new Set(e.map(e=>e.name)),i=e=>r.has("string"===typeof e?e:e.name);for(const o of e){for(const e of o.children.filter(i)){if(!n.has(e.name))throw new SP("Child ".concat(e.name," of node ").concat(o.name," is unreachable."));if(n.get(o.name)>n.get(e.name))throw new SP("Node ".concat(o.name," is scheduled to run after its child ").concat(e.name,"."))}if(!s(o))for(const e of o.inputs){if(!n.has(e.name))throw new SP("Input ".concat(e.name," of node ").concat(o.name," is unreachable."));if(n.get(e.name)>n.get(o.name))throw new SP("Node ".concat(o.name," is scheduled to run before its input ").concat(e.name,"."))}}}(f,c),f}class SP extends Error{constructor(e){super("NodesExecutionOrderError: ".concat(e))}}const CP=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),IP=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),NP=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function TP(e){return CP.has(e.op)}function EP(e){return IP.has(e.op)}function RP(e){return NP.has(e.op)}class _P{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map(t=>e[t].map(e=>e.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const t=e.signatureKey||e.name;return e.defaultOutput?"".concat(t,":").concat(e.defaultOutput):t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,null!=e.functions&&Object.keys(e.functions).forEach(t=>{this._functionExecutorMap[t]=new _P(e.functions[t],this)})}getCompilationKey(e,t){const n=e.map(e=>e.name).sort(),a=t.map(e=>e.name).sort();return n.join(this.SEPARATOR)+"--"+a.join(this.SEPARATOR)}compile(e,t){const n=wP(e,t,this.weightMap,this._initNodes),{missingInputs:a,dynamicNode:s,syncInputs:r}=n;if(null!=s)throw new Error("This execution contains the node '".concat(s.name,"', which has ")+"the dynamic op '".concat(s.op,"'. Please use ")+"model.executeAsync() instead. Alternatively, to avoid the "+"dynamic ops, specify the inputs [".concat(r,"]"));if(a.length>0){const n=t.map(e=>e.name),s=Object.keys(e);throw new Error("Cannot compute the outputs [".concat(n,"] from the provided inputs ")+"[".concat(s,"]. Missing the following inputs: [").concat(a,"]"))}const i=kP(this.graph,n),o=function(e){const t=new Map(e.map((e,t)=>[e.name,t])),n=Number.MAX_SAFE_INTEGER,a=e.map((e,t)=>TP(e)?n:t),s=e=>{const n=a[t.get(e.name)];return null==n?-1:n},r=e.map((e,t)=>e.children.map(s).reduce((e,t)=>Math.max(e,t),a[t])),i=new Map;for(let o=0;o<e.length;++o){const t=r[o];if(t===n)continue;const a=e[o],s=e[t];i.has(s.name)||i.set(s.name,[]),i.get(s.name).push(a)}return i}(i);return{orderedNodes:i,nodeLiveUntilMap:o}}cloneAndKeepTensor(e){if(null==e)return null;const t=e.clone();return Qm(t),t}cloneTensorList(e){if(!e)return null;const t=e.map(e=>this.cloneAndKeepTensor(e));return t}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map(e=>{let[t,n]=e;return[t,this.cloneTensorList(n)]}))}execute(e,t){this.disposeIntermediateTensors(),e=this.mapInputs(e);const n=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const a=n.map(e=>this.graph.nodes[IM(e)[0]]),s=t.map(e=>IM(e)[0]),r=new Set(s);let i=s.map(e=>this.graph.nodes[e]);0===i.length&&(i=this._outputs);const o=this.getCompilationKey(a,i);let c=this.compiledMap.get(o);null==c&&(c=this.compile(e,i),this.compiledMap.set(o,c));try{this.keepIntermediateTensors=eh().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(q5){this.keepIntermediateTensors=!1,console.warn(q5.message)}const l={},u={};return Xm(()=>{const n=new vP(this.weightMap,l,u,this.functionExecutorMap,this.parseNodeNameCache),a=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach(t=>{const[s,r]=IM(t,n),i=[];i[r]=e[t],a[s]=i,this.keepIntermediateTensors&&(this.clonedTensorsMap[s]=this.cloneTensorList(i))});const s=this.getFrozenTensorIds(a),{orderedNodes:i,nodeLiveUntilMap:o}=c;for(const e of i){if(a[e.name])continue;const t=xP(e,a,n,this._resourceManager);if(Qu(t))throw new Error("The execution of the op '".concat(e.op,"' returned a promise. ")+"Please use model.executeAsync() instead.");a[e.name]=t,this.keepIntermediateTensors&&(this.clonedTensorsMap[e.name]=this.cloneTensorList(t)),this.checkTensorForDisposalWithNodeLiveUntilInfo(e,a,n,s,r,o.get(e.name))}return null==this.parent&&n.dispose(s),t.map(e=>wM(e,a,n))})}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map(t=>e[t]).map(e=>e.map(e=>e.id)));return new Set(t)}checkTensorForDisposal(e,t,n,a,s,r,i){if(!TP(t)&&!r.has(e)){for(const a of n[e])null!=a&&(i[a.id]=(i[a.id]||0)+t.children.length);for(const e of t.inputs){if(TP(e))continue;const t=kM(e.name,n,a);if(null!=t)for(const e of t){if(!e||e.kept||s.has(e.id))continue;const t=i[e.id];1===t?(e.dispose(),delete i[e.id]):null!=t&&i[e.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,t,n,a,s,r){function i(e){return TP(e)||s.has(e.name)}if(!TP(e)&&null!=r)for(const o of r){if(i(o))continue;const e=kM(o.name,t,n);for(const t of e)!t||t.kept||a.has(t.id)||t.dispose()}}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(e=>{for(const t of e)t&&!t.isDisposed&&t.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{};this.disposeIntermediateTensors(),n||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepIntermediateTensors=eh().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(q5){this.keepIntermediateTensors=!1,console.warn(q5.message)}const r=new vP(this.weightMap,a,s,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const i=await this.executeWithControlFlow(e,r,t,n),o=t.map(e=>wM(e,i,r)),c=o.map(e=>e.id),l=Object.keys(e).map(t=>e[t].id),u=new Set([...c,...l,...this.weightIds]);return Object.values(i).forEach(e=>{e.forEach(e=>{!e||e.isDisposed||u.has(e.id)||e.dispose()})}),null==this.parent&&r.dispose(u),o}async executeFunctionAsync(e,t,n){const a=e.reduce((e,t,n)=>(e[this.inputs[n].name]=t,e),{});return this._executeAsync(a,this.outputNodes,!0,t,n)}async executeWithControlFlow(e,t,n,a){const s=Object.keys(e),r=s.map(e=>this.graph.nodes[IM(e)[0]]),i=n.map(e=>IM(e)[0]),o=new Set(i);let c=i.map(e=>this.graph.nodes[e]);0===c.length&&(c=this._outputs);const{usedNodes:l,missingInputs:u,dynamicNode:h,syncInputs:d}=wP(e,c,this.weightMap,this._initNodes),p=[...r,...this.graph.weights,...this._initNodes||[]].map(e=>({node:e,contexts:t.currentContext})),f=Object.assign({},this.weightMap);Object.keys(e).forEach(t=>{const[n,a]=IM(t),s=[];s[a]=e[t],f[n]=s});const m={},g=this.getFrozenTensorIds(f),y={};for(;p.length>0;){const e=this.processStack(r,p,t,f,y,g,o,m,l);await Promise.all(e)}null!=h||a||console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const b=c.filter(e=>!TP(e)&&!wM(e.name,f,t)).map(e=>e.name);if(b.length>0){let e="";throw null!=h&&(e="Alternatively, to avoid the dynamic ops, use model.execute() "+"and specify the inputs [".concat(d,"]")),new Error("Cannot compute the outputs [".concat(b,"] from the provided ")+"inputs [".concat(s,"]. Consider providing the following inputs: ")+"[".concat(u,"]. ").concat(e))}return f}processStack(e,t,n,a,s,r,i,o,c){const l=[];for(;t.length>0;){const e=t.pop();n.currentContext=e.contexts;let u="";if("Enter"===e.node.op&&vM("isConstant",e.node,a,n)&&([u]=SM(e.node.name,n)),null==a[e.node.name]){const h=xP(e.node,a,n,this._resourceManager);u||([u]=SM(e.node.name,n));const d=n.currentContext;Qu(h)?l.push(h.then(l=>(a[u]=l,this.keepIntermediateTensors&&(this.clonedTensorsMap[u]=this.cloneTensorList(l)),n.currentContext=d,this.checkTensorForDisposal(u,e.node,a,n,r,i,o),this.processChildNodes(e.node,t,n,a,s,c),l))):(a[u]=h,this.keepIntermediateTensors&&(this.clonedTensorsMap[u]=this.cloneTensorList(h)),this.checkTensorForDisposal(u,e.node,a,n,r,i,o),this.processChildNodes(e.node,t,n,a,s,c))}else this.processChildNodes(e.node,t,n,a,s,c)}return l}processChildNodes(e,t,n,a,s,r){e.children.forEach(e=>{const[i]=SM(e.name,n);!s[i]&&r.has(e.name)&&("Merge"===e.op?e.inputNames.some(e=>!!wM(e,a,n))&&(s[i]=!0,t.push({contexts:n.currentContext,node:e})):e.inputNames.every(e=>!!wM(e,a,n))&&(s[i]=!0,t.push({contexts:n.currentContext,node:e})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(e=>e.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{const n=e[t],[a]=IM(t),s=this.graph.nodes[a];if(s.attrParams.shape&&s.attrParams.shape.value){const e=s.attrParams.shape.value,t=e.length===n.shape.length&&n.shape.every((t,n)=>-1===e[n]||e[n]===t);bu(t,()=>"The shape of dict['".concat(s.name,"'] provided in ")+"model.execute(dict) must be [".concat(e,"], but was ")+"[".concat(n.shape,"]"))}s.attrParams.dtype&&s.attrParams.dtype.value&&bu(n.dtype===s.attrParams.dtype.value,()=>"The dtype of dict['".concat(s.name,"'] provided in ")+"model.execute(dict) must be "+"".concat(s.attrParams.dtype.value,", but was ").concat(n.dtype))})}mapInputs(e){var t,n;const a={};for(const s in e){const r=null===(n=null===(t=this._signature)||void 0===t?void 0:t.inputs)||void 0===n?void 0:n[s];null!=r?a[r.name]=e[s]:a[s]=e[s]}return a}checkInputs(e){const t=Object.keys(e).filter(e=>{const[t]=IM(e);return null==this.graph.nodes[t]});if(t.length>0)throw new Error("The dict provided in model.execute(dict) has "+"keys: [".concat(t,"] that are not part of graph"))}mapOutputs(e){return e.map(e=>{var t,n;const a=null===(n=null===(t=this._signature)||void 0===t?void 0:t.outputs)||void 0===n?void 0:n[e];return null!=a?a.name:e},{})}checkOutputs(e){e.forEach(e=>{const[t]=IM(e);if(!this.graph.nodes[t])throw new Error("The output '".concat(e,"' is not found in the graph"))})}}class AP{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}const MP="?tfjs-format=file",PP="model.json";class DP{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:e;this.modelUrl=t,this.loadOptions=n,this.version="n/a",this.io=a,null==n&&(this.loadOptions={}),this.resourceManager=new AP}findIOHandler(){const e=this.modelUrl;if(null!=e.load)this.handler=e;else if(null!=this.loadOptions.requestInit)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const t=this.io.getLoadHandlers(e,this.loadOptions);if(0===t.length)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error("Found more than one (".concat(t.length,") load handlers for ")+"URL '".concat([e],"'"));this.handler=t[0]}}load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return Qu(e)?e.then(e=>null==e.getWeightStream?this.loadSync(e):this.loadStreaming(e)):this.loadSync(e)}loadSync(e){const t=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,t)}async loadStreaming(e){if(null==e.getWeightStream)throw new Error("Model artifacts missing streamWeights function");const t=await og(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,t)}loadWithWeightMap(e,t){this.artifacts=e;const n=this.artifacts.modelTopology;let a=this.artifacts.signature;if(null!=this.artifacts.userDefinedMetadata){const e=this.artifacts.userDefinedMetadata;null!=e.signature&&(a=e.signature),null!=e.structuredOutputKeys&&(this.structuredOutputKeys=e.structuredOutputKeys)}if(this.signature=a,this.version="".concat(n.versions.producer,".").concat(n.versions.minConsumer),this.executor=new _P(KM.Instance.transformGraph(n,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(t),this.executor.resourceManager=this.resourceManager,null!=e.modelInitializer&&null!=e.modelInitializer.node){const t=KM.Instance.transformGraph(e.modelInitializer);this.initializer=new _P(t),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if("string"===typeof e){const t=this.io.getSaveHandlers(e);if(0===t.length)throw new Error("Cannot find any save handlers for URL '".concat(e,"'"));if(t.length>1)throw new Error("Found more than one (".concat(t.length,") save handlers for ")+"URL '".concat(e,"'"));e=t[0]}if(null==e.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){const t={};return(e instanceof om?[e]:e).forEach((e,n)=>t[this.structuredOutputKeys[n]]=e),t}return e}predict(e,t){const n=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(n)}async predictAsync(e,t){const n=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(n)}normalizeInputs(e){var t;if(!(e instanceof om)&&!Array.isArray(e)){const n=null===(t=this.signature)||void 0===t?void 0:t.inputs;if(null!=n)for(const t in n){const a=n[t];null!=a.resourceId&&(e[t]=this.resourceIdToCapturedInput[a.resourceId])}return e}e=Array.isArray(e)?e:[e];const n=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+n!==this.inputNodes.length)throw new Error("Input tensor count mismatch, the graph model has ".concat(this.inputNodes.length-n," non-resource placeholders, while there are ").concat(e.length," input tensors provided."));let a=0;return this.inputNodes.reduce((t,n)=>{var s,r,i;const o=null===(i=null===(r=null===(s=this.signature)||void 0===s?void 0:s.inputs)||void 0===r?void 0:r[n])||void 0===i?void 0:i.resourceId;return t[n]=null!=o?this.resourceIdToCapturedInput[o]:e[a++],t},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return null==this.initializer?[]:null==this.initializerSignature?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return null==this.initializer?[]:null==this.initializerSignature?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){const t=this.initializerSignature.outputs,n=Object.keys(t);for(let a=0;a<n.length;a++){const s=t[n[a]];this.resourceIdToCapturedInput[s.resourceId]=e[a]}}}execute(e,t){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const n=this.executor.execute(e,t);return n.length>1?n:n[0]}async executeAsync(e,t){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const n=await this.executor.executeAsync(e,t);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,n)=>(t[n]=[e[n]],t),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&Ym(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function OP(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:e;if(null==t)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==n&&(n={}),n.fromTFHub&&"string"===typeof t&&(t=function(e){e.endsWith("/")||(e+="/");return"".concat(e).concat(PP).concat(MP)}(t));const s=new DP(t,n,a);return await s.load(),s}function FP(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Map,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new Set;if(null==e)return null;if("function"===typeof Blob&&e instanceof Blob)return e.slice();if(a.has(e))throw new Error("Circular references are not supported.");if(n.has(e))return n.get(e);const s=t(e);if(s.recurse&&null!==s.value)throw new Error("A deep map function may not return both a value and recurse=true.");if(s.recurse){if(jP(e)){const s=Array.isArray(e)?[]:{};a.add(e);for(const r in e){const i=FP(e[r],t,n,a);s[r]=i}return a.delete(e),e.__proto__&&(s.__proto__=e.__proto__),s}throw new Error("Can't recurse into non-iterable type: ".concat(e))}return n.set(e,s.value),s.value}function LP(e){return zP(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:BP)}function zP(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Set;const a=e[0];if(n.has(a))throw new Error("Circular references are not supported.");const s=t(e);if(s.recurse&&null!==s.value)throw new Error("A deep zip function may not return both a value and recurse=true.");if(s.recurse){if(jP(a)){const s=Array.isArray(a)?[]:{};n.add(a);for(const r in a){const a=zP(e.map(e=>e[r]),t,n);s[r]=a}return n.delete(a),s}throw new Error("Can't recurse into non-iterable type: ".concat(a))}return s.value}function BP(e){return null===e?null:jP(e[0])?{value:null,recurse:!0}:{value:e,recurse:!1}}function jP(e){let t=!1;if(eh().get("IS_BROWSER"))t=e instanceof TextDecoder;else{const{StringDecoder:a}=n(551);t=e instanceof a}return null!=e&&!ArrayBuffer.isView(e)&&(Array.isArray(e)||"object"===typeof e&&!(e instanceof om)&&!(e instanceof Promise)&&!t)}function WP(e){return function(e,t){return FP(e,t)}(e,VP)}function VP(e){return e instanceof om?{value:e.clone(),recurse:!1}:jP(e)?{value:null,recurse:!0}:{value:e,recurse:!1}}class UP{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,null==e)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(const t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const t=this.wrap(this.begin+e),n=this.get(t);return this.set(t,this.pop()),n}}class HP extends UP{constructor(){super(HP.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){const e=2*this.capacity,t=new Array(e),n=this.length();for(let a=0;a<n;a++)t[a]=this.get(this.wrap(this.begin+a));this.data=t,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}}function GP(e){return new YP(e)}function qP(e,t){return new iD(e,t)}HP.INITIAL_CAPACITY=32;class KP{async toArray(){const e=[];let t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){const e=this.prefetch(100),t=[];let n=await e.next();for(;!n.done;)t.push(n.value),n=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),n=e(t.value);for(;!t.done&&n;)t=await this.next(),n=e(t.value)}handleErrors(e){return new nD(this,e)}filter(e){return new eD(this,e)}map(e){return new tD(this,e)}mapAsync(e){return new aD(this,e)}serialMapAsync(e){return new aD(this,e).serial()}flatmap(e){return new rD(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile(e=>!0===e)}rowMajorBatch(e){return new $P(this,e,!(arguments.length>1&&void 0!==arguments[1])||arguments[1])}columnMajorBatch(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:BP;return this.rowMajorBatch(e,t).map(e=>LP(e,n))}concatenate(e,t){return new iD(new XP([this,e]),t)}take(e){return e<0||null==e?this:new JP(this,e)}skip(e){return e<0||null==e?this:new ZP(this,e)}prefetch(e){return new cD(this,e)}shuffle(e,t){return new lD(this,e,t)}serial(){return new QP(this)}}class XP extends KP{constructor(e){super(),this.items=e,this.trav=0}summary(){return"Array of ".concat(this.items.length," items")}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};const e=this.items[this.trav];return this.trav++,{value:WP(e),done:!1}}}class YP extends KP{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(q5){throw q5.message="Error thrown while iterating through a dataset: ".concat(q5.message),q5}}}class QP extends KP{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> Serial")}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}}class ZP extends KP{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> Skip")}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){const e=await this.upstream.next();if(e.done)return e;Ym(e.value)}return this.upstream.next()}}class JP extends KP{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return"".concat(this.upstream.summary()," -> Take")}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}}class $P extends KP{constructor(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> RowMajorBatch")}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){const e=[];for(;e.length<this.batchSize;){const t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}}class eD extends KP{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> Filter")}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){const e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;Ym(e.value)}}}class tD extends KP{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return"".concat(this.upstream.summary()," -> Map")}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=km(e.value),n=this.transform(e.value),a=km(n);for(const s of t)wm(s,a)||s.dispose();return{value:n,done:!1}}}class nD extends KP{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> handleErrors")}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(q5){if(!this.handler(q5))return{value:null,done:!0}}}}class aD extends KP{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return"".concat(this.upstream.summary()," -> AsyncMap")}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=km(e.value),n=await this.transform(e.value),a=km(n);for(const s of t)wm(s,a)||s.dispose();return{value:n,done:!1}}}class sD extends KP{constructor(){super(),this.outputQueue=new HP,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;0===this.outputQueue.length();)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}}class rD extends sD{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return"".concat(this.upstream.summary()," -> Flatmap")}async pump(){const e=await this.upstream.next();if(e.done)return!1;const t=km(e.value),n=this.transform(e.value),a=km(n);this.outputQueue.pushAll(n);for(const s of t)wm(s,a)||s.dispose();return!0}}class iD extends KP{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"".concat("TODO: fill in upstream of chained summaries"," -> Chained")}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,null==this.iterator){const e=await this.moreIterators.next();if(e.done)return{value:null,done:!0};this.iterator=e.value,null!=this.baseErrorHandler&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}const t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}}var oD;!function(e){e[e.FAIL=0]="FAIL",e[e.SHORTEST=1]="SHORTEST",e[e.LONGEST=2]="LONGEST"}(oD||(oD={}));class cD extends KP{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new UP(t)}summary(){return"".concat(this.upstream.summary()," -> Prefetch")}refill(){for(;!this.buffer.isFull();){const e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}}class lD extends cD{constructor(e,t,n){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=bw.alea(n||Hf().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){const e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(!t.done)return this.refill(),t;this.upstreamExhausted=!0}return{value:null,done:!0}}}class uD{constructor(){this.size=null}batch(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n=this;let a;return bu(e>0,()=>"batchSize needs to be positive, but it is\n      ".concat(e)),a=this.size===1/0||null==this.size?this.size:t?Math.ceil(this.size/e):Math.floor(this.size/e),hD(async()=>(await n.iterator()).columnMajorBatch(e,t,dD),a)}concatenate(e){const t=this;let n;return n=this.size===1/0||e.size===1/0?1/0:null!=this.size&&null!=e.size?this.size+e.size:null,hD(async()=>(await t.iterator()).concatenate(await e.iterator()),n)}filter(e){const t=this;let n;return n=this.size===1/0?1/0:null,hD(async()=>(await t.iterator()).filter(t=>Xm(()=>e(t))),n)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){const t=this;return hD(async()=>(await t.iterator()).map(t=>Xm(()=>e(t))),this.size)}mapAsync(e){const t=this;return hD(async()=>(await t.iterator()).mapAsync(e),this.size)}prefetch(e){if(null==e)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const t=this;return hD(async()=>(await t.iterator()).prefetch(e),this.size)}repeat(e){const t=this;let n;return n=null!=this.size&&e>0?this.size*e:0===e?0:null!=this.size&&(void 0===e||e<0)?1/0:null,hD(async()=>qP(GP(async()=>({value:await t.iterator(),done:!1})).take(e)),n)}skip(e){const t=this;let n;return n=null!=this.size&&e>=0&&this.size>=e?this.size-e:null!=this.size&&(this.size<e||void 0===e||e<0)?0:null,hD(async()=>(await t.iterator()).skip(e),n)}shuffle(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(null==e||e<0)throw null==this.size?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError("`Dataset.shuffle()` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for `tf.Tensor`s), consider setting "+"bufferSize to the dataset size (".concat(this.size," elements)"));const a=this,s=bw.alea(t||Hf().toString());return hD(async()=>{let t=s.int32();return n&&(t+=s.int32()),(await a.iterator()).shuffle(e,t.toString())},this.size)}take(e){const t=this;let n;return n=null!=this.size&&this.size>e?e:null!=this.size&&this.size<=e?this.size:null,hD(async()=>(await t.iterator()).take(e),n)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}}function hD(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return new class extends uD{constructor(){super(...arguments),this.size=t}async iterator(){return e()}}}function dD(e){if(null===e)return null;if(function(e){return null==e||null===(t=e)||"object"!==typeof t&&"function"!==typeof t||Array.isArray(e)||"object"===typeof e&&e instanceof om||Kf(e);var t}(e[0])){return{value:function(e){if(0===e.length)throw new Error("Can't make a batch of zero elements.");return e[0]instanceof om?ak(e):Um(e)}(e),recurse:!1}}return{value:null,recurse:!0}}uD.MAX_BUFFER_SIZE=1e4;Symbol("out"),Symbol("field"),Symbol("quote"),Symbol("quoteafterquote"),Symbol("quoteinquote");function pD(e,t){Array.isArray(e)||(e=[e]),e.forEach(e=>{null!=e&&bu("complex64"!==e.dtype,()=>"".concat(t," does not support complex64 tensors in the CPU backend."))})}const fD=Sk;class mD extends hu{nextDataId(){return mD.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new uu(this,qm())}write(e,t,n){this.firstUse&&(this.firstUse=!1,eh().get("IS_NODE")&&yf("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));const a={id:this.nextDataId()};return this.data.set(a,{values:e,dtype:n,refCount:1}),a}makeTensorInfo(e,t,n){let a;if("string"===t&&null!=n&&n.length>0&&Ou(n[0])){const s=n.map(e=>Gf(e));a=this.write(s,e,t)}else a=this.write(n,e,t);return{dataId:a,shape:e,dtype:t}}refCount(e){if(this.data.has(e)){return this.data.get(e).refCount}return 0}incRef(e){this.data.get(e).refCount++}decRef(e){if(this.data.has(e)){this.data.get(e).refCount--}}move(e,t,n,a,s){this.data.set(e,{values:t,dtype:a,refCount:s})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:t,complexTensorInfos:n}=this.data.get(e);if("complex64"===t){return kC(this.readSync(n.real.dataId),this.readSync(n.imag.dataId))}return Uu(this.data.get(e).values,t)}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map(e=>qf(e));return ny(e.shape,e.dtype,n)}catch(n){throw new Error("Failed to decode encoded string bytes into utf-8")}return ny(e.shape,e.dtype,t)}makeOutput(e,t,n){return qm().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,e),this)}disposeData(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:n}=this.data.get(e);null!=n&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const t=Hf();e();return{kernelMs:Hf()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){pD([e],"where");const t=this.readSync(e.dataId);return fD(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}mD.nextDataId=0;function gD(e){return(t,n,a)=>{const s=Mu(n,t.length);for(let r=0;r<t.length;++r)s[r]=e(t[r],a);return s}}function yD(e,t,n){return bD(e,gD(t),n)}function bD(e,t,n){return a=>{let{inputs:s,attrs:r,backend:i}=a;const{x:o}=s;pD(o,e);const c=i,l=c.data.get(o.dataId).values;let u;if("string"===o.dtype){if(!Array.isArray(l))throw new Error("String tensor's value was not an instance of Array");u=nI(l)}else u=l;const h=n||o.dtype,d=t(u,h,r);return c.makeTensorInfo(o.shape,h,d)}}Jm("cpu",()=>new mD,1);const xD=yD(ad,e=>e>=0?e:Math.exp(e)-1),vD={kernelName:ad,backendName:"cpu",kernelFunc:xD};function wD(e){const{inputs:t,backend:n}=e,{x:a}=t;return n.incRef(a.dataId),{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}const kD={kernelName:vd,backendName:"cpu",kernelFunc:wD};function SD(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{alpha:r}=a;pD([s],"leakyRelu");const i=wu(s.shape),o=n.data.get(s.dataId).values,c=Au("float32",i);for(let l=0;l<o.length;l++)c[l]=o[l]<0?r*o[l]:o[l];return n.makeTensorInfo(s.shape,"float32",c)}const CD={kernelName:Nd,backendName:"cpu",kernelFunc:SD};function ID(e){return(t,n,a,s,r)=>{const i=_y(t,n),o=i.length,c=ju(i),l=Au(r,wu(i)),u=t.length,h=n.length,d=ju(t),p=ju(n),f=Ey(t,i),m=Ey(n,i);if(f.length+m.length===0)for(let g=0;g<l.length;++g)l[g]=e(a[g%a.length],s[g%s.length]);else for(let g=0;g<l.length;++g){const t=Yu(g,o,c),n=t.slice(-u);f.forEach(e=>n[e]=0);const r=Xu(n,u,d),i=t.slice(-h);m.forEach(e=>i[e]=0);const y=Xu(i,h,p);l[g]=e(a[r],s[y])}return[l,i]}}const ND=ID((e,t)=>e<0?t*e:e);function TD(e){const{inputs:t,backend:n}=e,{x:a,alpha:s}=t;pD([a,s],"prelu");const r=n.data.get(a.dataId).values,i=n.data.get(s.dataId).values,[o,c]=ND(a.shape,s.shape,r,i,"float32");return n.makeTensorInfo(c,"float32",o)}const ED={kernelName:op,backendName:"cpu",kernelFunc:TD},RD=yD(mp,e=>Math.max(0,e)),_D={kernelName:mp,backendName:"cpu",kernelFunc:RD},AD=yD(wp,e=>Math.min(Math.max(0,e),6)),MD={kernelName:wp,backendName:"cpu",kernelFunc:AD},PD=gD(e=>1/(1+Math.exp(-e))),DD=yD(Dp,e=>1/(1+Math.exp(-e))),OD={kernelName:Dp,backendName:"cpu",kernelFunc:DD};function FD(e,t,n,a,s){if("linear"===n)return wD({inputs:{x:t},backend:e});if("relu"===n)return RD({inputs:{x:t},backend:e});if("elu"===n)return xD({inputs:{x:t},backend:e});if("relu6"===n)return AD({inputs:{x:t},backend:e});if("prelu"===n)return TD({inputs:{x:t,alpha:a},backend:e});if("leakyrelu"===n)return SD({inputs:{x:t},backend:e,attrs:{alpha:s}});if("sigmoid"===n)return DD({inputs:{x:t},backend:e});throw new Error("Activation ".concat(n," has not been implemented for the CPU backend."))}function LD(e){const{inputs:t,backend:n}=e,{real:a,imag:s}=t,r=n.data.get(a.dataId).values,i=n.data.get(s.dataId).values,o=n.makeTensorInfo(a.shape,"complex64");return n.data.get(o.dataId).complexTensorInfos={real:n.makeTensorInfo(a.shape,"float32",r),imag:n.makeTensorInfo(s.shape,"float32",i)},o}const zD={kernelName:Ah,backendName:"cpu",kernelFunc:LD};function BD(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"float32";if("complex64"===n){return LD({inputs:{real:BD(e,t,"float32"),imag:BD(e,t,"float32")},backend:e})}const a=Gu(wu(t),n);return e.makeTensorInfo(t,n,a)}function jD(e){const{inputs:t,backend:n}=e,{input:a}=t,s=n.data.get(a.dataId).complexTensorInfos.real,r=n.data.get(s.dataId).values;return n.makeTensorInfo(s.shape,s.dtype,r)}const WD={kernelName:pp,backendName:"cpu",kernelFunc:jD};function VD(e,t,n,a){if("int32"===a){return[t,"int32",Int32Array.from(e)]}if("bool"===a){const a=Uf([0],n),[s,r]=ID((e,t)=>e!==t?1:0)(t,[],e,a,"bool");return[r,"bool",s]}throw new Error("Error in Cast: failed to cast ".concat(n," to ").concat(a))}function UD(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{dtype:r}=a;if("complex64"===r){if("complex64"===s.dtype)return wD({inputs:{x:s},backend:n});const e=BD(n,s.shape,s.dtype),t=UD({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),a=LD({inputs:{real:t,imag:e},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),a}if("complex64"===s.dtype){const e=jD({inputs:{input:s},backend:n}),t=UD({inputs:{x:e},backend:n,attrs:{dtype:r}});return n.disposeIntermediateTensorInfo(e),t}if(!Pu(s.dtype,r)){const e=wD({inputs:{x:s},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:r}}const i=n.data.get(s.dataId).values,[o,c,l]=VD(i,s.shape,s.dtype,r);return n.makeTensorInfo(o,c,l)}const HD={kernelName:Eh,backendName:"cpu",kernelFunc:UD};function GD(e,t,n,a){return null==n?n=>{let{inputs:s,backend:r}=n;const{a:i,b:o}=s,c=r;pD([i,o],e);const l=c.data.get(i.dataId).values,u=c.data.get(o.dataId).values,h="string"===i.dtype?nI(l):l,d="string"===i.dtype?nI(u):u,p=a||i.dtype,[f,m]=t(i.shape,o.shape,h,d,p);return c.makeTensorInfo(m,p,f)}:e=>{let{inputs:s,backend:r}=e;const{a:i,b:o}=s,c=r;if("complex64"===i.dtype||"complex64"===o.dtype){const e=UD({inputs:{x:i},backend:c,attrs:{dtype:"complex64"}}),t=c.data.get(e.dataId),a=t.complexTensorInfos.real,s=t.complexTensorInfos.imag,r=c.data.get(a.dataId).values,l=c.data.get(s.dataId).values,u=UD({inputs:{x:o},backend:c,attrs:{dtype:"complex64"}}),h=c.data.get(u.dataId),d=h.complexTensorInfos.real,p=h.complexTensorInfos.imag,f=c.data.get(d.dataId).values,m=c.data.get(p.dataId).values,[g,y,b]=n(i.shape,o.shape,r,l,f,m),x=c.makeTensorInfo(b,"float32",g),v=c.makeTensorInfo(b,"float32",y),w=LD({inputs:{real:x,imag:v},backend:c});return c.disposeIntermediateTensorInfo(e),c.disposeIntermediateTensorInfo(u),c.disposeIntermediateTensorInfo(x),c.disposeIntermediateTensorInfo(v),w}{const e=c.data.get(i.dataId).values,n=c.data.get(o.dataId).values,s=a||i.dtype,[r,l]=t(i.shape,o.shape,e,n,s);return c.makeTensorInfo(l,s,r)}}}function qD(e){return(t,n,a,s,r,i)=>{const o=_y(t,n),c=wu(o),l=o.length,u=ju(o),h=Au("float32",c),d=Au("float32",c),p=Ey(t,o),f=Ey(n,o),m=kC(a,s),g=kC(r,i),y=t.length,b=ju(t),x=n.length,v=ju(n);if(p.length+f.length===0)for(let w=0;w<h.length;w++){const t=w%m.length,n=w%g.length,a=e(m[2*t],m[2*t+1],g[2*n],g[2*n+1]);h[w]=a.real,d[w]=a.imag}else for(let w=0;w<h.length;w++){const t=Yu(w,l,u),n=t.slice(-y);p.forEach(e=>n[e]=0);const a=Xu(n,y,b),s=t.slice(-x);f.forEach(e=>s[e]=0);const r=Xu(s,x,v),i=e(m[2*a],m[2*a+1],g[2*r],g[2*r+1]);h[w]=i.real,d[w]=i.imag}return[h,d,o]}}const KD=ID((e,t)=>e+t),XD=qD((e,t,n,a)=>({real:e+n,imag:t+a})),YD=GD(ch,KD,XD),QD={kernelName:ch,backendName:"cpu",kernelFunc:YD};function ZD(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{shape:r}=a,i=wu(s.shape),o=Eu(r,i),c=wu(o);bu(i===c,()=>"The new shape (".concat(o,") has ").concat(c," elements and the old ")+"shape (".concat(s.shape,") has ").concat(i," elements. The new shape and old ")+"shape must have the same number of elements."),n.incRef(s.dataId);const l=n.data.get(s.dataId);if(null!=l.complexTensorInfos){const e=l.complexTensorInfos.real,t=l.complexTensorInfos.imag;e.shape=o,t.shape=o}return{dataId:s.dataId,shape:o,dtype:s.dtype}}const JD={kernelName:gp,backendName:"cpu",kernelFunc:ZD};function $D(e){const{inputs:t,backend:n,attrs:a}=e,{a:s,b:r}=t,{transposeA:i,transposeB:o}=a;pD([s,r],"matMul");const c=s.shape.length,l=r.shape.length,u=i?s.shape[c-2]:s.shape[c-1],h=o?r.shape[l-1]:r.shape[l-2],d=i?s.shape[c-1]:s.shape[c-2],p=o?r.shape[l-2]:r.shape[l-1],f=s.shape.slice(0,-2),m=r.shape.slice(0,-2),g=wu(f),y=wu(m),b=_y(s.shape.slice(0,-2),r.shape.slice(0,-2)).concat([d,p]);bu(u===h,()=>"Error in matMul: inner shapes (".concat(u,") and (")+"".concat(h,") of Tensors with shapes ").concat(s.shape," and ")+"".concat(r.shape," and transposeA=").concat(i)+" and transposeB=".concat(o," must match."));const x=o?[y,p,h]:[y,h,p],v=ZD({inputs:{x:s},backend:n,attrs:{shape:i?[g,u,d]:[g,d,u]}}),w=ZD({inputs:{x:r},backend:n,attrs:{shape:x}}),k=i?v.shape[1]:v.shape[2],S=i?v.shape[2]:v.shape[1],C=o?w.shape[1]:w.shape[2],I=Math.max(g,y),N=n.data.get(v.dataId).values,T=n.data.get(w.dataId).values,E=ju(v.shape),R=ju(w.shape),[_,A,M]=i?[E[0],1,E[1]]:[E[0],E[1],1],[P,D,O]=o?[1,R[1],R[0]]:[R[1],1,R[0]],F=S*C,L=ny([I,S,C],v.dtype),z=L.values,B=n.blockSize;for(let j=0;j<I;j++){const e=j%g,t=j%y;for(let n=0;n<S;n+=B){const a=Math.min(n+B,S);for(let s=0;s<C;s+=B){const r=Math.min(s+B,C);for(let i=0;i<k;i+=B){const o=Math.min(i+B,k);for(let c=n;c<a;c++)for(let n=s;n<r;n++){let a=0;for(let s=i;s<o;s++){a+=N[e*_+c*A+s*M]*T[s*P+n*D+t*O]}z[j*F+(c*C+n)]+=a}}}}}return n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(w),n.makeTensorInfo(b,L.dtype,L.values)}const eO={kernelName:Sh,backendName:"cpu",kernelFunc:$D};const tO={kernelName:ff,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{a:s,b:r,bias:i,preluActivationWeights:o}=t,{transposeA:c,transposeB:l,activation:u,leakyreluAlpha:h}=a;let d,p,f;const m=[];d=$D({inputs:{a:s,b:r},attrs:{transposeA:c,transposeB:l},backend:n}),i&&(p=YD({inputs:{a:d,b:i},backend:n}),m.push(d),d=p),u&&(f=FD(n,d,u,o,h),m.push(d),d=f);for(const g of m)n.disposeIntermediateTensorInfo(g);return d}};function nO(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}const aO={kernelName:rh,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend;pD(t,"abs");let a=new Float32Array(wu(t.shape));return a=nO(n.data.get(t.dataId).values),n.makeOutput(a,t.shape,t.dtype)}},sO=yD(ih,e=>Math.acos(e)),rO={kernelName:ih,backendName:"cpu",kernelFunc:sO},iO=yD(oh,e=>Math.acosh(e)),oO={kernelName:oh,backendName:"cpu",kernelFunc:iO};const cO={kernelName:lh,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,a=t;pD(t,"addN");const s=a.map(e=>n.data.get(e.dataId).values),r=ny(a[0].shape,a[0].dtype),i=r.values;for(let o=0;o<a.length;o++){const e=s[o];for(let t=0;t<i.length;t++)i[t]+=e[t]}return n.makeTensorInfo(r.shape,r.dtype,r.values)}};function lO(e,t,n,a,s){const r=t.length,i=wu(t),o=ju(t),c=ju(s),l=Au(n,wu(s));for(let u=0;u<i;++u){const t=Yu(u,r,o),n=new Array(t.length);for(let e=0;e<n.length;e++)n[e]=t[a[e]];l[Xu(n,r,c)]=e[u]}return l}function uO(e){const{inputs:t,attrs:n,backend:a}=e,{x:s}=t,{perm:r}=n;pD(s,"transpose");const i=s.shape.length,o=new Array(i);for(let l=0;l<o.length;l++)o[l]=s.shape[r[l]];const c=lO(a.data.get(s.dataId).values,s.shape,s.dtype,r,o);return{dataId:a.write(c,o,s.dtype),shape:o,dtype:s.dtype}}const hO={kernelName:rf,backendName:"cpu",kernelFunc:uO};const dO={kernelName:uh,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{axis:r,keepDims:i}=a;pD(s,"all");const o=Ru(r,s.shape);let c=o;const l=tv(c,s.shape.length);let u=s;null!=l&&(u=uO({inputs:{x:s},backend:n,attrs:{perm:l}}),c=av(c.length,s.shape.length)),ev("all",c,u.shape.length);const[h,d]=Jx(u.shape,c),p=wu(d),f=Gu(wu(h),u.dtype),m=n.data.get(u.dataId).values;for(let y=0;y<f.length;++y){const e=y*p;let t=m[e];for(let n=0;n<p;++n){const a=m[e+n];t=t&&a}f[y]=t}null!=l&&n.disposeIntermediateTensorInfo(u);const g=n.makeTensorInfo(h,u.dtype,f);if(i){const e=ZD({inputs:{x:g},backend:n,attrs:{shape:$x(h,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}};const pO={kernelName:hh,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{axis:r,keepDims:i}=a;pD(s,"any");const o=Ru(r,s.shape);let c=o;const l=tv(c,s.shape.length);let u=s;null!=l&&(u=uO({inputs:{x:s},backend:n,attrs:{perm:l}}),c=av(c.length,s.shape.length)),ev("any",c,u.shape.length);const[h,d]=Jx(u.shape,c),p=wu(d),f=Gu(wu(h),u.dtype),m=n.data.get(u.dataId).values;for(let y=0;y<f.length;++y){const e=y*p;let t=m[e];for(let n=0;n<p;++n){const a=m[e+n];t=t||a}f[y]=t}null!=l&&n.disposeIntermediateTensorInfo(u);const g=n.makeTensorInfo(h,u.dtype,f);if(i){const e=ZD({inputs:{x:g},backend:n,attrs:{shape:$x(h,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}};const fO={kernelName:dh,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{axis:r}=a;pD(s,"argMax");let i=Ru(r,s.shape);const o=tv(i,s.shape.length);let c=s;const l=[];null!=o&&(c=uO({inputs:{x:s},backend:n,attrs:{perm:o}}),l.push(c),i=av(i.length,c.shape.length)),i=[i[0]],ev("argMax",i,c.shape.length);const[u,h]=Jx(c.shape,i),d=Gu(wu(u),"int32"),p=wu(h),f=n.data.get(c.dataId).values;for(let m=0;m<d.length;++m){const e=m*p;let t=f[e],n=0;for(let a=0;a<p;++a){const s=f[e+a];s>t&&(t=s,n=a)}d[m]=n}return l.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.makeTensorInfo(u,"int32",d)}};const mO={kernelName:ph,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{axis:r}=a;pD(s,"argMin");let i=Ru(r,s.shape);const o=tv(i,s.shape.length);let c=s;const l=[];null!=o&&(c=uO({inputs:{x:s},backend:n,attrs:{perm:o}}),l.push(c),i=av(i.length,c.shape.length)),i=[i[0]],ev("argMin",i,c.shape.length);const[u,h]=Jx(c.shape,i),d=Gu(wu(u),"int32"),p=wu(h),f=n.data.get(c.dataId).values;for(let m=0;m<d.length;++m){const e=m*p;let t=f[e],n=0;for(let a=0;a<p;++a){const s=f[e+a];s<t&&(t=s,n=a)}d[m]=n}return l.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.makeTensorInfo(u,"int32",d)}},gO=yD(fh,e=>Math.asin(e)),yO={kernelName:fh,backendName:"cpu",kernelFunc:gO},bO=yD(mh,e=>Math.asinh(e)),xO={kernelName:mh,backendName:"cpu",kernelFunc:bO},vO=yD(gh,e=>Math.atan(e)),wO={kernelName:gh,backendName:"cpu",kernelFunc:vO},kO=ID((e,t)=>Math.atan2(e,t)),SO=GD(bh,kO),CO={kernelName:bh,backendName:"cpu",kernelFunc:SO},IO=yD(yh,e=>Math.atanh(e)),NO={kernelName:yh,backendName:"cpu",kernelFunc:IO};function TO(e,t,n,a,s,r){const i=s.strideHeight,o=s.strideWidth,c=s.dilationHeight,l=s.dilationWidth,u=s.effectiveFilterHeight,h=s.effectiveFilterWidth,d=s.padInfo.top,p=s.padInfo.left,f="max"===r?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=ny(s.outShape,n),g=m.values,y=s.outShape[1]*s.outShape[2]*s.outShape[3],b=s.outShape[2]*s.outShape[3],x=s.outShape[3];for(let v=0;v<s.batchSize;++v){const t=v*y,n=v*a[0];for(let m=0;m<s.inChannels;++m)for(let y=0;y<s.outHeight;++y){const v=y*i-d,w=Math.max(0,v),k=Math.min(s.inHeight,u+v),S=t+y*b;for(let t=0;t<s.outWidth;++t){const i=t*o-p,u=Math.max(0,i),d=Math.min(s.inWidth,h+i);let y=f,b=0,v=0;for(let t=w;t<k;t+=c){const s=n+t*a[1];for(let t=u;t<d;t+=l){const n=e[s+t*a[2]+m];"max"===r&&n>y?y=n:"avg"===r&&(b+=n,v++)}if(isNaN(y))break}g[S+t*x+m]="avg"===r?b/v:y}}}return m}function EO(e,t,n,a){let s=arguments.length>4&&void 0!==arguments[4]&&arguments[4],r=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const i=ny(a.outShape,"int32"),o=a.strideHeight,c=a.strideWidth,l=a.dilationHeight,u=a.dilationWidth,h=a.effectiveFilterHeight,d=a.effectiveFilterWidth,p=a.padInfo.top,f=a.padInfo.left,m=ny(t,n,e);for(let g=0;g<a.batchSize;++g)for(let e=0;e<a.inChannels;++e)for(let t=0;t<a.outHeight;++t){const n=t*o-p;let y=n;for(;y<0;)y+=l;const b=Math.min(a.inHeight,h+n);for(let o=0;o<a.outWidth;++o){const h=o*c-f;let p=h;for(;p<0;)p+=u;const x=Math.min(a.inWidth,d+h);let v=Number.NEGATIVE_INFINITY,w=-1;for(let t=y;t<b;t+=l){const i=t-n;for(let n=p;n<x;n+=u){const o=n-h,c=m.get(g,t,n,e);c>v&&(v=c,w=s?r?((g*a.inHeight+t)*a.inWidth+n)*a.inChannels+e:(t*a.inWidth+n)*a.inChannels+e:i*d+o)}}i.set(w,g,t,o,e)}}return i}function RO(e,t,n,a,s,r){const i=s.strideDepth,o=s.strideHeight,c=s.strideWidth,l=s.dilationDepth,u=s.dilationHeight,h=s.dilationWidth,d=s.effectiveFilterDepth,p=s.effectiveFilterHeight,f=s.effectiveFilterWidth,m=s.padInfo.front,g=s.padInfo.top,y=s.padInfo.left,b="max"===r?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,x=ny(s.outShape,n),v=x.values,w=s.outShape[1]*s.outShape[2]*s.outShape[3]*s.outShape[4],k=s.outShape[2]*s.outShape[3]*s.outShape[4],S=s.outShape[3]*s.outShape[4],C=s.outShape[4];for(let I=0;I<s.batchSize;++I){const t=I*w,n=I*a[0];for(let x=0;x<s.inChannels;++x)for(let w=0;w<s.outDepth;++w){const I=w*i-m;let N=I;for(;N<0;)N+=l;const T=Math.min(s.inDepth,d+I),E=t+w*k;for(let t=0;t<s.outHeight;++t){const i=t*o-g;let d=i;for(;d<0;)d+=u;const m=Math.min(s.inHeight,p+i),w=E+t*S;for(let t=0;t<s.outWidth;++t){const i=t*c-y;let o=i;for(;o<0;)o+=h;const p=Math.min(s.inWidth,f+i),g=w+t*C;let k=b,S=0,I=0;for(let t=N;t<T;t+=l){const s=n+t*a[1];for(let t=d;t<m;t+=u){const n=s+t*a[2];for(let t=o;t<p;t+=h){const s=e[n+t*a[3]+x];if("max"===r&&s>k?k=s:"avg"===r&&(S+=s,I++),isNaN(k))break}if(isNaN(k))break}if(isNaN(k))break}v[g+x]="avg"===r?S/Math.max(I,1):k}}}}return x}const _O={kernelName:xh,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t;pD(s,"avgPool");const{filterSize:r,strides:i,pad:o,dimRoundingMode:c}=a;bu(Jb(i,1),()=>"Error in avgPool: Either strides or dilations must be 1. "+"Got strides ".concat(i," and dilations '").concat(1,"'"));const l=Vb(s.shape,r,i,1,o,c);let u;if(1===l.filterWidth&&1===l.filterHeight&&Su(l.inShape,l.outShape))u=wD({inputs:{x:s},backend:n});else{const e=n.data.get(s.dataId).values,t=ju(s.shape),a=TO(e,s.shape,s.dtype,t,l,"avg");u=n.makeTensorInfo(l.outShape,s.dtype,a.values)}return u}};const AO={kernelName:wh,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{filterSize:r,strides:i,pad:o,dimRoundingMode:c,dataFormat:l}=a;pD(s,"avgPool3d");const u=Ub(s.shape,r,i,1,o,c,l),h=RO(n.data.get(s.dataId).values,s.shape,s.dtype,ju(s.shape),u,"avg");return n.makeTensorInfo(h.shape,"float32",h.values)}};const MO={kernelName:kh,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:s,input:r}=t,{filterSize:i,strides:o,pad:c,dimRoundingMode:l}=a;pD([s,r],"avgPool3DGrad");const u=Ub(r.shape,i,o,1,c,l),h=u.strideDepth,d=u.strideHeight,p=u.strideWidth,f=u.filterDepth,m=u.filterHeight,g=u.filterWidth,y=u.dilationDepth,b=u.dilationHeight,x=u.dilationWidth,v=u.effectiveFilterDepth,w=u.effectiveFilterHeight,k=u.effectiveFilterWidth,S=v-1-u.padInfo.front,C=k-1-u.padInfo.left,I=w-1-u.padInfo.top,N=ny(r.shape,"float32"),T=1/(f*m*g),E=n.bufferSync(s);for(let R=0;R<u.batchSize;++R)for(let e=0;e<u.inChannels;++e)for(let t=0;t<u.inDepth;++t)for(let n=0;n<u.inHeight;++n)for(let a=0;a<u.inWidth;++a){const s=t-S,r=n-I,i=a-C;let o=0;for(let t=0;t<v;t+=y){const n=(s+t)/h;if(!(n<0||n>=u.outDepth||Math.floor(n)!==n))for(let t=0;t<w;t+=b){const a=(r+t)/d;if(!(a<0||a>=u.outHeight||Math.floor(a)!==a))for(let t=0;t<k;t+=x){const s=(i+t)/p;if(s<0||s>=u.outWidth||Math.floor(s)!==s)continue;o+=E.get(R,n,a,s,e)}}}N.set(o*T,R,t,n,a,e)}return n.makeTensorInfo(N.shape,N.dtype,N.values)}};const PO={kernelName:vh,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:s,input:r}=t,i=r;pD([s,r],"avgPoolGrad");const{filterSize:o,strides:c,pad:l}=a,u=Vb(i.shape,o,c,1,l),h=u.strideHeight,d=u.strideWidth,p=u.filterHeight,f=u.filterWidth,m=u.dilationHeight,g=u.dilationWidth,y=u.effectiveFilterHeight,b=u.effectiveFilterWidth,x=b-1-u.padInfo.left,v=y-1-u.padInfo.top,w=ny(i.shape,"float32"),k=1/(p*f),S=n.data.get(s.dataId).values,C=ny(s.shape,"float32",S);for(let I=0;I<u.batchSize;++I)for(let e=0;e<u.inChannels;++e)for(let t=0;t<u.inHeight;++t)for(let n=0;n<u.inWidth;++n){const a=t-v,s=n-x;let r=0;for(let t=0;t<y;t+=m){const n=(a+t)/h;if(!(n<0||n>=u.outHeight||Math.floor(n)!==n))for(let t=0;t<b;t+=g){const a=(s+t)/d;if(a<0||a>=u.outWidth||Math.floor(a)!==a)continue;r+=C.get(I,n,a,e)}}w.set(r*k,I,t,n,e)}return n.makeTensorInfo(w.shape,w.dtype,w.values)}};const DO={kernelName:md,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,scale:r,offset:i,mean:o,variance:c}=t;bu(o.shape.length===c.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),bu(null==i||o.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),bu(null==r||o.shape.length===r.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),pD([s,o,c,r,i],"batchNorm");let{varianceEpsilon:l}=a;null==l&&(l=.001);const u=n.data.get(s.dataId).values,h=n.data.get(o.dataId).values,d=n.data.get(c.dataId).values,p=r?n.data.get(r.dataId).values:new Float32Array([1]),f=i?n.data.get(i.dataId).values:new Float32Array([0]),m=new Float32Array(u.length),g=f.length,y=p.length,b=d.length,x=h.length;let v=0,w=0,k=0,S=0;for(let C=0;C<u.length;++C)m[C]=f[v++]+(u[C]-h[w++])*p[k++]/Math.sqrt(d[S++]+l),v>=g&&(v=0),w>=x&&(w=0),k>=y&&(k=0),S>=b&&(S=0);return n.makeTensorInfo(s.shape,s.dtype,m)}};function OO(e,t,n,a,s){const r=Cb(a,t,n),i=wu(n),o=ju(a);if(r){const n=Ib(t,o);return"string"===s?e.slice(n,n+i):e.subarray(n,n+i)}const c=ny(a,s,"string"===s?nI(e):e),l=ny(n,s);for(let u=0;u<l.size;++u){const e=l.indexToLoc(u),n=e.map((e,n)=>e+t[n]);l.set(c.get(...n),...e)}return"string"===s?aI(l.values):l.values}function FO(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{begin:r,size:i}=a;pD(s,"slice");const[o,c]=Nb(s,r,i);db(s,o,c);const l=OO(n.data.get(s.dataId).values,o,c,s.shape,s.dtype);return n.makeTensorInfo(c,s.dtype,l)}const LO={kernelName:_p,backendName:"cpu",kernelFunc:FO};const zO={kernelName:Ch,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{blockShape:r,crops:i}=a;pD([s],"batchToSpaceND");const o=r.reduce((e,t)=>e*t),c=cC(s.shape,r,o),l=lC(c.length,r.length),u=uC(s.shape,r,o),h=hC(i,r.length),d=dC(u,i,r.length),p=ZD({inputs:{x:s},backend:n,attrs:{shape:c}}),f=uO({inputs:{x:p},backend:n,attrs:{perm:l}}),m=ZD({inputs:{x:f},backend:n,attrs:{shape:u}}),g=FO({inputs:{x:m},backend:n,attrs:{begin:h,size:d}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}};function BO(e,t,n,a,s){const r=wu(a),i=Gu(s,n);for(let o=0;o<e.length;o++){const n=e[o];if(n<0)throw new Error("Input x must be non-negative!");n>=s||(i[n]+=r>0?t[o]:1)}return i}function jO(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s=e.shape[0],r=e.shape[1],i=ny([s,n],t.dtype);for(let o=0;o<s;o++)for(let s=0;s<r;s++){const r=e.get(o,s);if(r<0)throw new Error("Input x must be non-negative!");r>=n||(a?i.set(1,o,r):t.size>0?i.set(i.get(o,r)+t.get(o,s),o,r):i.set(i.get(o,r)+1,o,r))}return i}const WO={kernelName:Ih,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,weights:r}=t,{size:i}=a,o=BO(n.data.get(s.dataId).values,n.data.get(r.dataId).values,r.dtype,r.shape,i);return n.makeTensorInfo([i],r.dtype,o)}},VO=ID((e,t)=>e&t),UO=GD(Nh,VO),HO={kernelName:Nh,backendName:"cpu",kernelFunc:UO};const GO={kernelName:Th,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{s0:a,s1:s}=t,r=n.data.get(a.dataId).values,i=n.data.get(s.dataId).values,o=_y(Array.from(r),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}},qO=gD(e=>Math.ceil(e)),KO=bD(Rh,qO),XO={kernelName:Rh,backendName:"cpu",kernelFunc:KO},YO=yD(_h,(e,t)=>{const n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e}),QO={kernelName:_h,backendName:"cpu",kernelFunc:YO},ZO={kernelName:Mh,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend,a=new Float32Array(wu(t.shape)),s=n.data.get(t.dataId),r=s.complexTensorInfos.real,i=s.complexTensorInfos.imag,o=n.data.get(r.dataId).values,c=n.data.get(i.dataId).values;for(let l=0;l<o.length;l++){const e=o[l],t=c[l];a[l]=Math.hypot(e,t)}return n.makeOutput(a,t.shape,"float32")}};function JO(e,t,n,a){const s=Mu(n,wu(t));if(a&&"string"!==n){let t=0;e.forEach(e=>{const n=wu(e.shape);s.set(e.vals,t),t+=n})}else{let a=0;e.forEach(e=>{const r="string"===n?nI(e.vals):e.vals;let i=0;for(let n=0;n<e.shape[0];++n){const o=n*t[1]+a;for(let t=0;t<e.shape[1];++t)s[o+t]=r[i++]}a+=e.shape[1]})}return s}function $O(e){const{inputs:t,backend:n}=e,{input:a}=t,s=n.data.get(a.dataId).complexTensorInfos.imag,r=n.data.get(s.dataId).values;return n.makeTensorInfo(s.shape,s.dtype,r)}const eF={kernelName:kd,backendName:"cpu",kernelFunc:$O};function tF(e){const{inputs:t,backend:n,attrs:a}=e,{axis:s}=a,r=Ru(s,t[0].shape)[0];JS(t.map(e=>e.shape),r);let i=$S(t.map(e=>e.shape),r);if(0===wu(i))return n.makeTensorInfo(i,t[0].dtype,[]);const o=t.filter(e=>wu(e.shape)>0);if(1===o.length)return wD({inputs:{x:o[0]},backend:n});if("complex64"===o[0].dtype){const e=o.map(e=>jD({inputs:{input:e},backend:n})),t=o.map(e=>$O({inputs:{input:e},backend:n})),a=tF({inputs:e,backend:n,attrs:{axis:r}}),s=tF({inputs:t,backend:n,attrs:{axis:r}}),i=LD({inputs:{real:a,imag:s},backend:n});return e.forEach(e=>n.disposeIntermediateTensorInfo(e)),t.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),i}const c=o.map(e=>{const t=wu(e.shape.slice(r));return ZD({inputs:{x:e},backend:n,attrs:{shape:[-1,t]}})}),l=c.map(e=>({vals:n.data.get(e.dataId).values,shape:e.shape}));i=$S(c.map(e=>e.shape),1);const u=1===c[0].shape[0],h=JO(l,i,t[0].dtype,u),d=$S(o.map(e=>e.shape),r),p=n.makeTensorInfo(d,t[0].dtype,h);return c.forEach(e=>n.disposeIntermediateTensorInfo(e)),p}const nF={kernelName:Ph,backendName:"cpu",kernelFunc:tF};function aF(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,filter:r}=t,{strides:i,pad:o,dataFormat:c,dilations:l,dimRoundingMode:u}=a;pD([s,r],"conv2d");const h=ex(c),d=Hb(s.shape,r.shape,i,l,o,u,!1,h),p=d.filterHeight,f=d.filterWidth,m=d.dilationHeight,g=d.dilationWidth,y=d.padInfo.left,b=d.padInfo.top,x="channelsLast"===d.dataFormat,v=new am(d.outShape,s.dtype),w=ju(s.shape),k=ju(r.shape),S=w[0],C=x?w[1]:w[2],I=x?w[2]:1,N=x?1:w[1],T=v.strides[0],E=x?v.strides[1]:v.strides[2],R=x?v.strides[2]:1,_=x?1:v.strides[1],A=n.data.get(s.dataId).values,M=n.data.get(r.dataId).values,P=v.values;for(let D=0;D<d.batchSize;++D){const e=D*S,t=D*T;for(let n=0;n<d.outHeight;++n){const a=t+n*E,s=n*d.strideHeight-b;for(let t=0;t<p;++t){const n=s+t*m;if(n<0||n>=d.inHeight)continue;const r=t*k[0],i=e+n*C;for(let e=0;e<d.outWidth;++e){const t=a+e*R,n=e*d.strideWidth-y;for(let e=0;e<f;++e){const a=n+e*g;if(a<0||a>=d.inWidth)continue;const s=i+a*I;let o=r+e*k[1];for(let e=0;e<d.inChannels;++e){const n=A[s+e*N];for(let e=0;e<d.outChannels;++e)P[t+e*_]+=n*M[o+e];o+=d.outChannels}}}}}}return n.makeTensorInfo(v.shape,v.dtype,P)}const sF={kernelName:Dh,backendName:"cpu",kernelFunc:aF};const rF={kernelName:Oh,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,dy:r}=t,{strides:i,pad:o,dataFormat:c,dimRoundingMode:l,filterShape:u}=a;pD([s,r],"conv2dBackpropFilter");const h=ex(c),d=Hb(s.shape,u,i,1,o,l,!1,h),{strideHeight:p,strideWidth:f,filterHeight:m,filterWidth:g}=d,y="channelsLast"===d.dataFormat,b=new am(d.filterShape,"float32"),x=d.padInfo.left,v=d.padInfo.top,w=n.data.get(s.dataId).values,k=n.data.get(r.dataId).values,S=new am(s.shape,s.dtype,w),C=new am(r.shape,r.dtype,k);for(let I=0;I<m;++I){const e=Math.max(0,Math.ceil((v-I)/p)),t=Math.min(d.outHeight,(d.inHeight+v-I)/p);for(let n=0;n<g;++n){const a=Math.max(0,Math.ceil((x-n)/f)),s=Math.min(d.outWidth,(d.inWidth+x-n)/f);for(let r=0;r<d.inChannels;++r)for(let i=0;i<d.outChannels;++i){let o=0;for(let c=0;c<d.batchSize;++c)for(let l=e;l<t;++l){const e=I+l*p-v;for(let t=a;t<s;++t){const a=n+t*f-x;o+=y?S.get(c,e,a,r)*C.get(c,l,t,i):S.get(c,r,e,a)*C.get(c,i,l,t)}}b.set(o,I,n,r,i)}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}};const iF={kernelName:Fh,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:s,filter:r}=t,{inputShape:i,strides:o,pad:c,dataFormat:l,dimRoundingMode:u}=a;pD([s,r],"conv2dBackpropInput");const h=ju(r.shape),d=ju(s.shape);let p=ex(l);const f=Hb(i,r.shape,o,1,c,u,!1,p),m=new am(f.inShape,"float32"),g=m.values,y=n.data.get(s.dataId).values,b=n.data.get(r.dataId).values,[x,v,w]=h,{batchSize:k,filterHeight:S,filterWidth:C,inChannels:I,inHeight:N,inWidth:T,outChannels:E,outHeight:R,outWidth:_,strideHeight:A,strideWidth:M}=f;p=f.dataFormat;const P=S-1-f.padInfo.top,D=C-1-f.padInfo.left,O="channelsLast"===p,F=m.strides[0],L=O?m.strides[1]:m.strides[2],z=O?m.strides[2]:1,B=O?1:m.strides[1],j=d[0],W=O?d[1]:d[2],V=O?d[2]:1,U=O?1:d[1];for(let H=0;H<k;++H)for(let e=0;e<I;++e)for(let t=0;t<N;++t){const n=t-P,a=Math.max(0,Math.ceil(n/A)),s=Math.min(R,(S+n)/A);for(let r=0;r<T;++r){const i=r-D,o=Math.max(0,Math.ceil(i/M)),c=Math.min(_,(C+i)/M);let l=0;for(let t=a;t<s;++t){const a=t*A-n;for(let n=o;n<c;++n){const s=j*H+W*t+V*n,r=x*(S-1-a)+v*(C-1-(n*M-i))+w*e;for(let e=0;e<E;++e){l+=y[s+U*e]*b[r+e]}}}g[F*H+L*t+z*r+B*e]=l}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}};const oF={kernelName:Lh,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,filter:r}=t,{strides:i,pad:o,dilations:c}=a;pD([s,r],"conv3d");const l=Gb(s.shape,r.shape,i,c,o),{filterDepth:u,filterHeight:h,filterWidth:d,dilationDepth:p,dilationHeight:f,dilationWidth:m,padInfo:g}=l,y=g.front,b=g.left,x=g.top,v=new am(l.outShape,s.dtype),w=n.data.get(s.dataId).values,k=n.data.get(r.dataId).values,S=v.values,C=ju(s.shape),I=ju(r.shape);for(let N=0;N<l.batchSize;++N){const e=N*C[0],t=N*v.strides[0];for(let n=0;n<l.outDepth;++n){const a=t+n*v.strides[1],s=n*l.strideDepth-y;for(let t=0;t<u;++t){const n=s+t*p;if(n<0||n>=l.inDepth)continue;const r=t*I[0],i=e+n*C[1];for(let e=0;e<l.outHeight;++e){const t=a+e*v.strides[2],n=e*l.strideHeight-x;for(let e=0;e<h;++e){const a=n+e*f;if(a<0||a>=l.inHeight)continue;const s=r+e*I[1],o=i+a*C[2];for(let e=0;e<l.outWidth;++e){const n=t+e*l.outChannels,a=e*l.strideWidth-b;for(let e=0;e<d;++e){const t=a+e*m;if(t<0||t>=l.inWidth)continue;const r=s+e*I[2],i=o+t*l.inChannels;let c=r;for(let e=0;e<l.inChannels;++e){const t=w[i+e];for(let e=0;e<l.outChannels;++e)S[n+e]+=t*k[c+e];c+=l.outChannels}}}}}}}}return n.makeTensorInfo(v.shape,v.dtype,v.values)}};const cF={kernelName:zh,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,dy:r}=t,{strides:i,pad:o,filterShape:c}=a;pD([s,r],"conv3dBackpropFilterV2");const l=ju(s.shape),u=ju(r.shape),h=Gb(s.shape,c,i,1,o),d=h.strideDepth,p=h.strideHeight,f=h.strideWidth,m=h.filterDepth,g=h.filterHeight,y=h.filterWidth,b=new am(h.filterShape,"float32"),x=b.values,[v,w,k,S]=b.strides,C=n.data.get(r.dataId).values,[I,N,T,E]=u,R=n.data.get(s.dataId).values,[_,A,M,P]=l,D=h.padInfo.front,O=h.padInfo.left,F=h.padInfo.top;for(let L=0;L<m;++L){const e=Math.max(0,Math.ceil((D-L)/d)),t=Math.min(h.outDepth,(h.inDepth+D-L)/d),n=L*v;for(let a=0;a<g;++a){const s=Math.max(0,Math.ceil((F-a)/p)),r=Math.min(h.outHeight,(h.inHeight+F-a)/p),i=a*w+n;for(let n=0;n<y;++n){const o=Math.max(0,Math.ceil((O-n)/f)),c=Math.min(h.outWidth,(h.inWidth+O-n)/f),l=n*k+i;for(let i=0;i<h.inChannels;++i){const u=i*S+l;for(let l=0;l<h.outChannels;++l){let m=0;for(let u=0;u<h.batchSize;++u){const h=u*_,g=u*I;for(let u=e;u<t;++u){const e=(L+u*d-D)*A+h,t=u*N+g;for(let u=s;u<r;++u){const s=(a+u*p-F)*M+e,r=u*T+t;for(let e=o;e<c;++e){const t=e*E+r;m+=R[(n+e*f-O)*P+s+i]*C[t+l]}}}}x[u+l]=m}}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}};const lF={kernelName:Bh,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:s,filter:r}=t,{pad:i,strides:o,inputShape:c}=a;pD([s],"conv3dBackpropInputV2");const l=ju(s.shape),u=ju(r.shape),h=Gb(c,r.shape,o,1,i),d=new am(h.inShape,"float32"),p=d.values,[f,m,g,y]=d.strides,b=n.data.get(s.dataId).values,[x,v,w,k]=l,S=n.data.get(r.dataId).values,[C,I,N,T]=u,{batchSize:E,filterDepth:R,filterHeight:_,filterWidth:A,inChannels:M,inDepth:P,inHeight:D,inWidth:O,outChannels:F,outDepth:L,outHeight:z,outWidth:B,strideDepth:j,strideHeight:W,strideWidth:V}=h,U=R-1-h.padInfo.front,H=_-1-h.padInfo.top,G=A-1-h.padInfo.left;for(let q=0;q<E;++q)for(let e=0;e<M;++e)for(let t=0;t<P;++t){const n=t-U,a=Math.max(0,Math.ceil(n/j)),s=Math.min(L,(R+n)/j);for(let r=0;r<D;++r){const i=r-H,o=Math.max(0,Math.ceil(i/W)),c=Math.min(z,(_+i)/W);for(let l=0;l<O;++l){const u=l-G,h=Math.max(0,Math.ceil(u/V)),d=Math.min(B,(A+u)/V);let E=0;for(let t=a;t<s;++t){const a=t*j-n;for(let n=o;n<c;++n){const s=n*W-i;for(let r=h;r<d;++r){const i=x*q+v*t+w*n+k*r,o=C*(R-1-a)+I*(_-1-s)+N*(A-1-(r*V-u))+T*e;for(let e=0;e<F;++e){E+=b[i+e]*S[o+e]}}}}p[f*q+m*t+g*r+y*l+e]=E}}}return n.makeTensorInfo(d.shape,d.dtype,d.values)}},uF=yD(jh,e=>Math.cos(e)),hF={kernelName:jh,backendName:"cpu",kernelFunc:uF},dF=yD(Wh,e=>Math.cosh(e)),pF={kernelName:Wh,backendName:"cpu",kernelFunc:dF};const fF={kernelName:Hh,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{image:s,boxes:r,boxInd:i}=t,{cropSize:o,method:c,extrapolationValue:l}=a,[u,h,d,p]=s.shape,f=r.shape[0],[m,g]=o,y=ny([f,m,g,p],"float32"),b=n.data.get(r.dataId).values,x=n.data.get(i.dataId).values,v=n.data.get(s.dataId).values,w=ju(s.shape),k=ju(y.shape);for(let S=0;S<f;S++){const e=4*S,t=b[e],n=b[e+1],a=b[e+2],s=b[e+3],r=x[S];if(r>=u)continue;const i=m>1?(a-t)*(h-1)/(m-1):0,o=g>1?(s-n)*(d-1)/(g-1):0;for(let u=0;u<m;u++){const e=m>1?t*(h-1)+u*i:.5*(t+a)*(h-1);if(e<0||e>h-1)for(let t=0;t<g;t++)for(let e=0;e<p;e++){const n=e+t*k[2]+u*k[1]+S*k[0];y.values[n]=l}else if("bilinear"===c){const t=Math.floor(e),a=Math.ceil(e),i=e-t;for(let e=0;e<g;e++){const c=g>1?n*(d-1)+e*o:.5*(n+s)*(d-1);if(c<0||c>d-1){for(let t=0;t<p;t++){const n=t+e*k[2]+u*k[1]+S*k[0];y.values[n]=l}continue}const h=Math.floor(c),f=Math.ceil(c),m=c-h;for(let n=0;n<p;n++){let s=n+h*w[2]+t*w[1]+r*w[0];const o=v[s];s=n+f*w[2]+t*w[1]+r*w[0];const c=v[s];s=n+h*w[2]+a*w[1]+r*w[0];const l=v[s];s=n+f*w[2]+a*w[1]+r*w[0];const d=o+(c-o)*m,p=l+(v[s]-l)*m;s=n+e*k[2]+u*k[1]+S*k[0],y.values[s]=d+(p-d)*i}}}else for(let t=0;t<g;++t){const a=g>1?n*(d-1)+t*o:.5*(n+s)*(d-1);if(a<0||a>d-1){for(let e=0;e<p;e++){const n=e+t*k[2]+u*k[1]+S*k[0];y.values[n]=l}continue}const i=Math.round(a),c=Math.round(e);for(let e=0;e<p;e++){const n=e+i*w[2]+c*w[1]+r*w[0],a=e+t*k[2]+u*k[1]+S*k[0];y.values[a]=v[n]}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}};const mF={kernelName:Vh,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{axis:r,exclusive:i,reverse:o}=a;pD(s,"cumprod");const c=tv([r],s.shape.length);let l=s;null!=c&&(l=uO({inputs:{x:s},backend:n,attrs:{perm:c}}));const u=av(1,s.shape.length)[0];if(u!==l.shape.length-1)throw new Error("backend.cumprod in CPU expects an inner-most "+"axis=".concat(l.shape.length-1," but got axis=").concat(u));const h=gm(l.dtype,"int32"),d=Hu(wu(l.shape),h),p=n.data.get(l.dataId).values,f=l.shape[l.shape.length-1],m=o?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let y=0;y<p.length;y+=f)for(let e=0;e<f;e++){const t=m(y,e);if(0===e)d[t]=i?1:p[t];else{const n=m(y,e-1);d[t]=i?p[n]*d[n]:p[t]*d[n]}}const g=n.makeTensorInfo(l.shape,h,d);if(null!=c){const e=uO({inputs:{x:g},backend:n,attrs:{perm:nv(c)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(l),e}return g}};const gF={kernelName:Uh,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{axis:r,exclusive:i,reverse:o}=a;pD(s,"cumsum");const c=tv([r],s.shape.length);let l=s;null!=c&&(l=uO({inputs:{x:s},backend:n,attrs:{perm:c}}));const u=av(1,s.shape.length)[0];if(u!==l.shape.length-1)throw new Error("backend.cumsum in CPU expects an inner-most "+"axis=".concat(l.shape.length-1," but got axis=").concat(u));const h=gm(l.dtype,"int32"),d=Gu(wu(l.shape),h),p=n.data.get(l.dataId).values,f=l.shape[l.shape.length-1],m=o?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let y=0;y<p.length;y+=f)for(let e=0;e<f;e++){const t=m(y,e);if(0===e)d[t]=i?0:p[t];else{const n=m(y,e-1);d[t]=i?p[n]+d[n]:p[t]+d[n]}}const g=n.makeTensorInfo(l.shape,h,d);if(null!=c){const e=uO({inputs:{x:g},backend:n,attrs:{perm:nv(c)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(l),e}return g}};const yF={kernelName:Gh,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,weights:r}=t,{size:i,binaryOutput:o}=a;if(1===s.shape.length){const e=BO(n.data.get(s.dataId).values,n.data.get(r.dataId).values,r.dtype,r.shape,i);return n.makeTensorInfo([i],r.dtype,e)}if(2===s.shape.length){const e=jO(n.bufferSync(s),n.bufferSync(r),i,o);return n.makeTensorInfo(e.shape,r.dtype,e.values)}throw new Error("Error in denseBincount: input must be at most rank 2, but got rank"+"".concat(s.shape.length,"."))}};const bF={kernelName:qh,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{blockSize:r,dataFormat:i}=a;bu("NHWC"===i,()=>"Only NHWC dataFormat supported on CPU for depthToSpace. Got ".concat(i));const o=s.shape[0],c=s.shape[1],l=s.shape[2],u=s.shape[3],h=c*r,d=l*r,p=u/(r*r),f=n.data.get(s.dataId).values,m=new Float32Array(o*h*d*p);let g=0;for(let y=0;y<o;++y)for(let e=0;e<h;++e){const t=Math.floor(e/r),n=e%r;for(let e=0;e<d;++e){const a=Math.floor(e/r),s=(n*r+e%r)*p;for(let e=0;e<p;++e){const n=e+s+u*(a+l*(t+c*y));m[g++]=f[n]}}}return n.makeTensorInfo([o,h,d,p],s.dtype,m)}};function xF(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,filter:r}=t,{strides:i,pad:o,dilations:c,dimRoundingMode:l}=a;pD([s,r],"depthwiseConv2DNative");const u=ju(s.shape),h=ju(r.shape);let d=c;null==d&&(d=[1,1]),bu(Jb(i,d),()=>"Error in depthwiseConv2d: Either strides or dilations must be "+"1. Got strides ".concat(i," and dilations '").concat(d,"'"));const p=Hb(s.shape,r.shape,i,d,o,l,!0),{filterHeight:f,filterWidth:m,dilationHeight:g,dilationWidth:y,padInfo:b}=p,x=b.left,v=b.top,w=p.outChannels/p.inChannels,k=new am(p.outShape,s.dtype),S=n.data.get(s.dataId).values,C=n.data.get(r.dataId).values,I=k.values;for(let N=0;N<p.batchSize;++N){const e=N*u[0],t=N*k.strides[0];for(let n=0;n<p.outHeight;++n){const a=t+n*k.strides[1],s=n*p.strideHeight-v;for(let t=0;t<f;++t){const n=s+t*g;if(n<0||n>=p.inHeight)continue;const r=t*h[0],i=e+n*u[1];for(let e=0;e<p.outWidth;++e){const t=a+e*k.strides[2],n=e*p.strideWidth-x;for(let e=0;e<m;++e){const a=n+e*y;if(a<0||a>=p.inWidth)continue;const s=r+e*h[1],o=i+a*p.inChannels;let c=t,l=s;for(let e=0;e<p.inChannels;++e){const t=S[o+e];for(let e=0;e<w;++e)I[c+e]+=t*C[l+e];c+=w,l+=w}}}}}}return n.makeTensorInfo(k.shape,k.dtype,k.values)}const vF={kernelName:Kh,backendName:"cpu",kernelFunc:xF};const wF={kernelName:Xh,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,dy:r}=t,{strides:i,dilations:o,pad:c,dimRoundingMode:l,filterShape:u}=a;pD([s,r],"depthwiseConv2dNativeBackpropFilter");const h=Hb(s.shape,u,i,o,c,l,!0),{strideHeight:d,strideWidth:p,filterHeight:f,filterWidth:m}=h,g=new am(h.filterShape,"float32"),y=h.padInfo.left,b=h.padInfo.top,x=h.outChannels/h.inChannels,v=n.data.get(s.dataId).values,w=new am(s.shape,s.dtype,v),k=n.data.get(r.dataId).values,S=new am(r.shape,r.dtype,k);for(let C=0;C<f;++C){const e=Math.max(0,Math.ceil((b-C)/d)),t=Math.min(h.outHeight,(h.inHeight+b-C)/d);for(let n=0;n<m;++n){const a=Math.max(0,Math.ceil((y-n)/p)),s=Math.min(h.outWidth,(h.inWidth+y-n)/p);for(let r=0;r<h.outChannels;++r){const i=Math.trunc(r/x),o=r%x;let c=0;for(let l=0;l<h.batchSize;++l)for(let o=e;o<t;++o){const e=C+o*d-b;for(let t=a;t<s;++t){const a=n+t*p-y;c+=w.get(l,e,a,i)*S.get(l,o,t,r)}}g.set(c,C,n,i,o)}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}};const kF={kernelName:Yh,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:s,filter:r}=t,{strides:i,dilations:o,pad:c,dimRoundingMode:l,inputShape:u}=a;pD([s,r],"depthwiseConv2DNativeBackpropInput");const h=ju(s.shape),d=ju(r.shape),p=Hb(u,r.shape,i,o,c,l,!0),f=new am(p.inShape,"float32"),m=f.values,[g,y,b]=f.strides,x=n.data.get(s.dataId).values,[v,w,k]=h,S=n.data.get(r.dataId).values,[C,I,N]=d,{batchSize:T,filterHeight:E,filterWidth:R,inChannels:_,inHeight:A,inWidth:M,outChannels:P,outHeight:D,outWidth:O,strideHeight:F,strideWidth:L}=p,z=E-1-p.padInfo.top,B=R-1-p.padInfo.left,j=P/_;for(let W=0;W<T;++W)for(let e=0;e<_;++e)for(let t=0;t<A;++t){const n=t-z,a=Math.max(0,Math.ceil(n/F)),s=Math.min(D,(E+n)/F);for(let r=0;r<M;++r){const i=r-B,o=Math.max(0,Math.ceil(i/L)),c=Math.min(O,(R+i)/L);let l=0;for(let t=a;t<s;++t){const a=t*F-n;for(let n=o;n<c;++n){const s=v*W+w*t+k*n,r=C*(E-1-a)+I*(R-1-(n*L-i))+N*e;for(let t=0;t<j;++t){l+=x[s+(e*j+t)]*S[r+t]}}}m[g*W+y*t+b*r+e]=l}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}};const SF={kernelName:Qh,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t,s=wu(a.shape),r=n.data.get(a.dataId).values,i=ny([s,s],a.dtype),o=i.values;for(let l=0;l<r.length;l++)o[l*s+l]=r[l];const c=[...a.shape,...a.shape];return n.makeTensorInfo(c,i.dtype,i.values)}},CF={kernelName:Zh,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:a}=e;const{x:s,filter:r}=t,{strides:i,pad:o,dilations:c}=a,l=n,u=l.data.get(s.dataId).values,h=s.shape.length,d=l.data.get(r.dataId).values,p=r.shape.length,{batchSize:f,inHeight:m,inWidth:g,inChannels:y,outHeight:b,outWidth:x,padInfo:v,strideHeight:w,strideWidth:k,filterHeight:S,filterWidth:C,dilationHeight:I,dilationWidth:N,outShape:T}=Wb(s.shape,r.shape,i,o,"NHWC",c),E=wu(T),R=T.length,_=Mu(s.dtype,E);for(let A=0;A<f;++A)for(let e=0;e<b;++e){const t=e*w-v.top;for(let n=0;n<x;++n){const a=n*k-v.left;for(let i=0;i<y;++i){let o=Number.MIN_SAFE_INTEGER;for(let e=0;e<S;++e){const n=t+e*I;if(n>=0&&n<m)for(let t=0;t<C;++t){const c=a+t*N;if(c>=0&&c<g){const a=Xu([A,n,c,i],h,ju(s.shape)),l=Xu([e,t,i],p,ju(r.shape)),f=u[a]+d[l];f>o&&(o=f)}}}_[Xu([A,e,n,i],R,ju(T))]=o}}}return{dataId:l.write(Uf(_,s.dtype),T,s.dtype),shape:T,dtype:s.dtype}}},IF={kernelName:$h,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:a}=e;const{x:s,filter:r,dy:i}=t,{strides:o,pad:c,dilations:l}=a,u=n,h=Vu(s.shape,u.data.get(s.dataId).values),d=Vu(r.shape,u.data.get(r.dataId).values),{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:x,strideHeight:v,strideWidth:w,filterHeight:k,filterWidth:S,dilationHeight:C,dilationWidth:I,outShape:N}=Wb(s.shape,r.shape,o,c,"NHWC",l);bu(i.rank===N.length,()=>"Error in ".concat($h,", dy ")+"must have the same rank as output ".concat(N.length,", but got ")+"".concat(i.rank));const T=Vu(N,u.data.get(i.dataId).values),E=qu(r.shape,r.dtype);for(let R=0;R<p;++R)for(let e=0;e<y;++e){const t=e*v-x.top;for(let n=0;n<b;++n){const a=n*w-x.left;for(let s=0;s<g;++s){let r=Number.MIN_SAFE_INTEGER,i=0,o=0;for(let e=0;e<k;++e){const n=t+e*C;if(n>=0&&n<f)for(let t=0;t<S;++t){const c=a+t*I;if(c>=0&&c<m){const a=h[R][n][c][s]+d[e][t][s];a>r&&(r=a,i=e,o=t)}}}E[i][o][s]+=T[R][e][n][s]}}}return{dataId:u.write(Uf(E,s.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},NF={kernelName:Jh,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:a}=e;const{x:s,filter:r,dy:i}=t,{strides:o,pad:c,dilations:l}=a,u=n,h=Vu(s.shape,u.data.get(s.dataId).values),d=Vu(r.shape,u.data.get(r.dataId).values),{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:x,strideHeight:v,strideWidth:w,filterHeight:k,filterWidth:S,dilationHeight:C,dilationWidth:I,outShape:N}=Wb(s.shape,r.shape,o,c,"NHWC",l);bu(i.rank===N.length,()=>"Error in ".concat(Jh,", dy ")+"must have the same rank as output ".concat(N.length,", but got ")+"".concat(i.rank));const T=Vu(N,u.data.get(i.dataId).values),E=qu(s.shape,s.dtype);for(let R=0;R<p;++R)for(let e=0;e<y;++e){const t=e*v-x.top;for(let n=0;n<b;++n){const a=n*w-x.left;for(let s=0;s<g;++s){let r=Number.MIN_SAFE_INTEGER,i=t<0?0:t,o=a<0?0:a;for(let e=0;e<k;++e){const n=t+e*C;if(n>=0&&n<f)for(let t=0;t<S;++t){const c=a+t*I;if(c>=0&&c<m){const a=h[R][n][c][s]+d[e][t][s];a>r&&(r=a,i=n,o=c)}}}E[R][i][o][s]+=T[R][e][n][s]}}}return{dataId:u.write(Uf(E,s.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};const TF={kernelName:ed,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{image:s}=t,{canvas:r,options:i}=a,{contextOptions:o,imageOptions:c}=i||{},l=(null===c||void 0===c?void 0:c.alpha)||1,u=(null===o||void 0===o?void 0:o.contextType)||"2d";if("2d"!==u)throw new Error("Context type ".concat(o.contextType," is not supported by the CPU backend."));const h=r.getContext(u,(null===o||void 0===o?void 0:o.contextAttributes)||{});if(null==h)throw new Error("Could not get the context with ".concat(u," type."));const[d,p]=s.shape.slice(0,2),f=2===s.shape.length?1:s.shape[2],m=n.data.get(s.dataId).values,g="float32"===s.dtype?255:1,y=new Uint8ClampedArray(p*d*4);for(let x=0;x<d*p;++x){const e=[0,0,0,255*l];for(let n=0;n<f;n++){const t=m[x*f+n];if("float32"===s.dtype){if(t<0||t>1)throw new Error("Tensor values for a float32 Tensor must be in the "+"range [0 - 1] but encountered ".concat(t,"."))}else if("int32"===s.dtype&&(t<0||t>255))throw new Error("Tensor values for a int32 Tensor must be in the "+"range [0 - 255] but encountered ".concat(t,"."));1===f?(e[0]=t*g,e[1]=t*g,e[2]=t*g):e[n]=t*g}const t=4*x;y[t+0]=Math.round(e[0]),y[t+1]=Math.round(e[1]),y[t+2]=Math.round(e[2]),y[t+3]=Math.round(e[3])}r.width=p,r.height=d;const b=new ImageData(y,p,d);return h.putImageData(b,0,0),s}},EF=ID((e,t)=>e*t),RF=qD((e,t,n,a)=>({real:e*n-t*a,imag:e*a+t*n})),_F=GD(Qd,EF,RF),AF={kernelName:Qd,backendName:"cpu",kernelFunc:_F};function MF(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{axis:r,keepDims:i}=a;let o;pD(s,"sum"),o="bool"===s.dtype?UD({inputs:{x:s},backend:n,attrs:{dtype:"int32"}}):wD({inputs:{x:s},backend:n});const c=o.shape.length,l=Ru(r,o.shape),u=tv(l,c);let h=l,d=o;null!=u&&(d=uO({inputs:{x:o},backend:n,attrs:{perm:u}}),h=av(h.length,c)),ev("sum",h,d.shape.length);const[p,f]=Jx(d.shape,h);let m=BD(n,p,gm(d.dtype,"int32"));const g=wu(f),y=n.data.get(m.dataId).values,b=n.data.get(d.dataId).values;for(let x=0;x<y.length;++x){const e=x*g;let t=0;for(let n=0;n<g;++n)t+=b[e+n];y[x]=t}if(i){const e=m;m=ZD({inputs:{x:m},backend:n,attrs:{shape:$x(m.shape,l)}}),n.disposeIntermediateTensorInfo(e)}return n.disposeIntermediateTensorInfo(o),null!=u&&n.disposeIntermediateTensorInfo(d),m}const PF={kernelName:Lp,backendName:"cpu",kernelFunc:MF};const DF={kernelName:nd,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{equation:s}=a,r=t,{allDims:i,summedDims:o,idDims:c}=DC(s,r.length);FC(i.length,c,r);const{path:l,steps:u}=LC(o,c),h=u.length;let d=null,p=i.length;const f=[];for(let m=0;m<h;++m){for(const e of u[m]){const{permutationIndices:t,expandDims:a}=OC(p,c[e]);let s;zC(t)?s=r[e]:(s=uO({inputs:{x:r[e]},backend:n,attrs:{perm:t}}),f.push(s));const i=s.shape.slice();for(let e=0;e<a.length;++e)i.splice(a[e],0,1);Su(s.shape,i)||(s=ZD({inputs:{x:s},backend:n,attrs:{shape:i}}),f.push(s)),null===d?d=s:(d=_F({inputs:{a:s,b:d},backend:n}),f.push(d))}m<h-1&&(l[m]>=0&&(d=MF({inputs:{x:d},backend:n,attrs:{axis:l[m]-(i.length-p),keepDims:!1}}),f.push(d)),p--)}for(const m of f)m!==d&&n.disposeIntermediateTensorInfo(m);return d}};const OF={kernelName:sd,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{dy:a,y:s}=t;pD([a,s],"eluGrad");const r=new Float32Array(wu(s.shape)),i=n.data.get(s.dataId).values,o=n.data.get(a.dataId).values;for(let c=0;c<i.length;++c){const e=i[c];r[c]=e>=0?o[c]:o[c]*(e+1)}return n.makeTensorInfo(s.shape,"float32",r)}},FF=ID((e,t)=>e===t?1:0),LF=GD(id,FF,null,"bool"),zF={kernelName:id,backendName:"cpu",kernelFunc:LF},BF=gC,jF=yC,WF=bC,VF=xC,UF=vC,HF=wC,GF=yD(rd,e=>{const t=Math.sign(e),n=Math.abs(e),a=1/(1+BF*n);return t*(1-((((HF*a+UF)*a+VF)*a+WF)*a+jF)*a*Math.exp(-n*n))}),qF={kernelName:rd,backendName:"cpu",kernelFunc:GF},KF=gD(e=>Math.exp(e)),XF=bD(od,KF,"float32"),YF={kernelName:od,backendName:"cpu",kernelFunc:XF};function QF(e){const{inputs:t,backend:n,attrs:a}=e,{input:s}=t,{dim:r}=a,i=s.shape.length,o=s.shape.slice();let c=r;return r<0&&(bu(-(i+1)<=r,()=>"Axis must be in the interval [".concat(-(i+1),", ").concat(i,"]")),c=i+r+1),o.splice(c,0,1),ZD({inputs:{x:s},backend:n,attrs:{shape:o}})}const ZF={kernelName:cd,backendName:"cpu",kernelFunc:QF},JF=gD(e=>Math.expm1(e)),$F=bD(ld,JF),eL={kernelName:ld,backendName:"cpu",kernelFunc:$F},tL=ID((e,t)=>e/t),nL=GD(td,tL),aL={kernelName:td,backendName:"cpu",kernelFunc:nL},sL=ID((e,t)=>e-t),rL=qD((e,t,n,a)=>({real:e-n,imag:t-a})),iL=GD($p,sL,rL),oL={kernelName:$p,backendName:"cpu",kernelFunc:iL};function cL(e,t,n){const a=e.shape,s=a[0],r=a[1],i=n.data.get(e.dataId),o=i.complexTensorInfos.real,c=i.complexTensorInfos.imag,l=[s,r],u=wu(l),h=Au("float32",u),d=Au("float32",u);for(let g=0;g<s;g++){const e=FO({inputs:{x:o},backend:n,attrs:{begin:[g,0],size:[1,r]}}),a=FO({inputs:{x:c},backend:n,attrs:{begin:[g,0],size:[1,r]}}),s=LD({inputs:{real:e,imag:a},backend:n}),{real:i,imag:l}=lL(s,t,n),u=kC(i,l);for(let t=0;t<r;t++){const e=NC(u,t);h[g*r+t]=e.real,d[g*r+t]=e.imag}n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s)}const p=n.makeTensorInfo(l,"float32",h),f=n.makeTensorInfo(l,"float32",d),m=LD({inputs:{real:p,imag:f},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}function lL(e,t,n){const a=wu(e.shape),s=n.data.get(e.dataId),r=n.data.get(s.complexTensorInfos.real.dataId).values,i=n.data.get(s.complexTensorInfos.imag.dataId).values;if(0===((o=a)&o-1)){const s=uL(r,i,a,t,n),o=[e.shape[0],e.shape[1]];if(t){const e=n.makeTensorInfo(o,"float32",s.real),t=n.makeTensorInfo(o,"float32",s.imag),r=n.makeTensorInfo([],"float32",Vf(a,"float32")),i=wD({inputs:{x:r},backend:n}),c=aL.kernelFunc({inputs:{a:e,b:r},backend:n}),l=aL.kernelFunc({inputs:{a:t,b:i},backend:n}),u=n.data.get(c.dataId).values,h=n.data.get(l.dataId).values;return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(l),{real:u,imag:h}}return s}{const e=function(e,t,n){const a=new Float32Array(2*t);for(let s=0;s<t;s++){let r=0,i=0;for(let a=0;a<t;a++){const o=RC(s*a,t,n),c=NC(e,a);r+=c.real*o.real-c.imag*o.imag,i+=c.real*o.imag+c.imag*o.real}n&&(r/=t,i/=t),TC(a,r,i,s)}return a}(kC(r,i),a,t);return SC(e)}var o}function uL(e,t,n,a,s){if(1===n)return{real:e,imag:t};const r=kC(e,t),i=n/2,o=CC(r),c=o.real,l=o.imag,u=[c.length],h=s.makeTensorInfo(u,"float32",c),d=s.makeTensorInfo(u,"float32",l),p=LD({inputs:{real:h,imag:d},backend:s}),f=IC(r),m=f.real,g=f.imag,y=[m.length],b=s.makeTensorInfo(y,"float32",m),x=s.makeTensorInfo(y,"float32",g),v=LD({inputs:{real:b,imag:x},backend:s}),w=uL(c,l,i,a,s),k=w.real,S=w.imag,C=[k.length],I=s.makeTensorInfo(C,"float32",k),N=s.makeTensorInfo(C,"float32",S),T=LD({inputs:{real:I,imag:N},backend:s}),E=uL(m,g,i,a,s),R=E.real,_=E.imag,A=[R.length],M=s.makeTensorInfo(A,"float32",R),P=s.makeTensorInfo(A,"float32",_),D=LD({inputs:{real:M,imag:P},backend:s}),O=EC(n,a),F=[O.real.length],L=s.makeTensorInfo(F,"float32",O.real),z=s.makeTensorInfo(F,"float32",O.imag),B=LD({inputs:{real:L,imag:z},backend:s}),j=_F({inputs:{a:B,b:D},backend:s}),W=YD({inputs:{a:T,b:j},backend:s}),V=iL({inputs:{a:T,b:j},backend:s}),U=jD({inputs:{input:W},backend:s}),H=jD({inputs:{input:V},backend:s}),G=$O({inputs:{input:W},backend:s}),q=$O({inputs:{input:V},backend:s}),K=tF({inputs:[U,H],backend:s,attrs:{axis:0}}),X=tF({inputs:[G,q],backend:s,attrs:{axis:0}}),Y=s.data.get(K.dataId).values,Q=s.data.get(X.dataId).values;return s.disposeIntermediateTensorInfo(h),s.disposeIntermediateTensorInfo(d),s.disposeIntermediateTensorInfo(p),s.disposeIntermediateTensorInfo(b),s.disposeIntermediateTensorInfo(x),s.disposeIntermediateTensorInfo(v),s.disposeIntermediateTensorInfo(I),s.disposeIntermediateTensorInfo(N),s.disposeIntermediateTensorInfo(T),s.disposeIntermediateTensorInfo(M),s.disposeIntermediateTensorInfo(P),s.disposeIntermediateTensorInfo(D),s.disposeIntermediateTensorInfo(L),s.disposeIntermediateTensorInfo(z),s.disposeIntermediateTensorInfo(B),s.disposeIntermediateTensorInfo(j),s.disposeIntermediateTensorInfo(W),s.disposeIntermediateTensorInfo(V),s.disposeIntermediateTensorInfo(U),s.disposeIntermediateTensorInfo(G),s.disposeIntermediateTensorInfo(H),s.disposeIntermediateTensorInfo(q),s.disposeIntermediateTensorInfo(K),s.disposeIntermediateTensorInfo(X),{real:Y,imag:Q}}const hL={kernelName:ud,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:a}=t,s=wu(a.shape),r=a.shape[a.shape.length-1],i=ZD({inputs:{x:a},backend:n,attrs:{shape:[s/r,r]}}),o=cL(i,!1,n),c=ZD({inputs:{x:o},backend:n,attrs:{shape:a.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),c}};function dL(e){const{backend:t,attrs:n}=e,{shape:a,value:s,dtype:r}=n,i=r||Lu(s),o=Mu(i,wu(a));return function(e,t){e.fill(t)}(o,s),t.makeTensorInfo(a,i,o)}const pL={kernelName:hd,backendName:"cpu",kernelFunc:dL};const fL={kernelName:dd,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e;const{image:s}=t,r=a,i=Au(s.dtype,wu(s.shape)),[o,c,l,u]=s.shape,h=r.data.get(s.dataId).values;for(let d=0;d<o;d++){const e=d*l*c*u;for(let t=0;t<c;t++){const n=t*(l*u);for(let t=0;t<l;t++){const a=t*u;for(let s=0;s<u;s++){const r=Math.round(l-t-1),o=e+n+a+s;let c=h[o];if(r>=0&&r<l){c=h[e+n+r*u+s]}i[o]=c}}}}return{dataId:r.write(i,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},mL=gD(e=>Math.floor(e)),gL=bD(pd,mL),yL={kernelName:pd,backendName:"cpu",kernelFunc:gL},bL=ID((e,t)=>Math.floor(e/t)),xL=GD(fd,bL,null,"int32"),vL={kernelName:fd,backendName:"cpu",kernelFunc:xL};const wL={kernelName:mf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,filter:r,bias:i,preluActivationWeights:o}=t,{strides:c,pad:l,dataFormat:u,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=a;let m=aF({inputs:{x:s,filter:r},backend:n,attrs:{strides:c,pad:l,dataFormat:u,dilations:h,dimRoundingMode:d}});if(i){const e=m;if("NCHW"===u&&1===i.shape.length&&1!==i.shape[0]){const e=ZD({inputs:{x:i},backend:n,attrs:{shape:[i.shape[0],1,1]}});m=YD({inputs:{a:m,b:e},backend:n}),n.disposeIntermediateTensorInfo(e)}else m=YD({inputs:{a:m,b:i},backend:n});n.disposeIntermediateTensorInfo(e)}if(p){const e=m;if("NCHW"===u&&"prelu"===p&&1===o.shape.length&&1!==o.shape[0]){const e=ZD({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});m=FD(n,m,p,e,f),n.disposeIntermediateTensorInfo(e)}else m=FD(n,m,p,o,f);n.disposeIntermediateTensorInfo(e)}return m}};const kL={kernelName:gf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,filter:r,bias:i,preluActivationWeights:o}=t,{strides:c,pad:l,dataFormat:u,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=a;let m=xF({inputs:{x:s,filter:r},backend:n,attrs:{strides:c,pad:l,dataFormat:u,dilations:h,dimRoundingMode:d}});if(i){const e=m;m=YD({inputs:{a:m,b:i},backend:n}),n.disposeIntermediateTensorInfo(e)}if(p){const e=m;m=FD(n,m,p,o,f),n.disposeIntermediateTensorInfo(e)}return m}};function SL(e,t,n,a,s,r,i,o,c){const l=ny([a,r],n);for(let u=0;u<a;u++){const n=[];let a=0;for(let t=0;t<s;t++){const r=e[u*s+t];a+=r*i[t],n.push(r)}if(a<0||a>=c/r)throw new Error("Invalid indices: ".concat(n," does not index into ").concat(o));for(let e=0;e<r;e++)l.values[u*r+e]=t.get(...t.indexToLoc(a*r+e))}return l}const CL={kernelName:yd,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:a,indices:s}=t,r=wu(a.shape),i=s.shape,o=i[i.length-1],[c,l,u,h]=pC(a,s);if(0===l)return n.makeTensorInfo(c,a.dtype,[]);const d=SL(n.data.get(s.dataId).values,n.bufferSync(a),a.dtype,l,o,u,h,a.shape,r);return n.makeTensorInfo(c,a.dtype,d.values)}};function IL(e,t,n){const a=ny(n,e.dtype);for(let s=0;s<a.size;++s){const n=a.indexToLoc(s).slice(),r=n[0],i=n[2],o=t.locToIndex([r,i]);n[2]=t.values[o];const c=e.locToIndex(n);0<=c&&c<e.values.length&&(a.values[s]=e.values[c])}return a}const NL={kernelName:gd,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,indices:r}=t,{axis:i,batchDims:o}=a;pD([s,r],"gatherV2");const c=Ru(i,s.shape)[0],l=n.data.get(r.dataId).values,u=s.shape[c];for(let x=0;x<l.length;++x){const e=l[x];bu(e<=u-1&&e>=0,()=>"GatherV2: the index value ".concat(e," is not in [0, ").concat(u-1,"]"))}let h=o;null==o&&(h=0);const d=wu(r.shape),p=tI(s,r,c,h),f=ZD({inputs:{x:s},backend:n,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),m=ZD({inputs:{x:r},backend:n,attrs:{shape:[p.batchSize,d/p.batchSize]}}),g=[p.batchSize,p.outerSize,d/p.batchSize,p.sliceSize],y=n.bufferSync(m),b=IL(n.bufferSync(f),y,g);return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.makeTensorInfo(p.outputShape,b.dtype,b.values)}},TL=ID((e,t)=>e>t?1:0),EL=GD(bd,TL,null,"bool"),RL={kernelName:bd,backendName:"cpu",kernelFunc:EL},_L=ID((e,t)=>e>=t?1:0),AL=GD(xd,_L,null,"bool"),ML={kernelName:xd,backendName:"cpu",kernelFunc:AL};const PL={kernelName:wd,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:a}=t,s=wu(a.shape),r=a.shape[a.shape.length-1],i=ZD({inputs:{x:a},backend:n,attrs:{shape:[s/r,r]}}),o=cL(i,!0,n),c=ZD({inputs:{x:o},backend:n,attrs:{shape:a.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),c}},DL=yD(Sd,e=>Number.isFinite(e)?1:0,"bool"),OL={kernelName:Sd,backendName:"cpu",kernelFunc:DL},FL=yD(Cd,e=>Math.abs(e)===1/0?1:0,"bool"),LL={kernelName:Cd,backendName:"cpu",kernelFunc:FL},zL=yD(Id,e=>Number.isNaN(e)?1:0,"bool"),BL={kernelName:Id,backendName:"cpu",kernelFunc:zL},jL=ID((e,t)=>e<t?1:0),WL=GD(Td,jL,null,"bool"),VL={kernelName:Td,backendName:"cpu",kernelFunc:WL},UL=ID((e,t)=>e<=t?1:0),HL=GD(Ed,UL,null,"bool"),GL={kernelName:Ed,backendName:"cpu",kernelFunc:HL};function qL(e,t,n){const a=(t-e)/(n-1),s=Gu(n,"float32");s[0]=e;for(let r=1;r<s.length;r++)s[r]=s[r-1]+a;return s}const KL={kernelName:Rd,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:a,stop:s,num:r}=n,i=qL(a,s,r);return t.makeTensorInfo([i.length],"float32",i)}},XL=gD(e=>Math.log(e)),YL=bD(_d,XL),QL={kernelName:_d,backendName:"cpu",kernelFunc:YL},ZL=yD(Ad,e=>Math.log1p(e)),JL={kernelName:Ad,backendName:"cpu",kernelFunc:ZL},$L=ID((e,t)=>e&&t),ez=GD(Md,$L,null,"bool"),tz={kernelName:Md,backendName:"cpu",kernelFunc:ez},nz=yD(Pd,e=>e?0:1,"bool"),az={kernelName:Pd,backendName:"cpu",kernelFunc:nz},sz=ID((e,t)=>e||t),rz=GD(Dd,sz,null,"bool"),iz={kernelName:Dd,backendName:"cpu",kernelFunc:rz};const oz={kernelName:Od,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{depthRadius:r,bias:i,alpha:o,beta:c}=a;pD(s,"LRN");const l=s.shape[3],u=l-1,h=n.data.get(s.dataId).values,d=wu(s.shape),p=new Float32Array(d);function f(e){const t=e%l;let n=e-t+Math.max(0,t-r);const a=e-t+Math.min(t+r,u);let s=0;for(;n<=a;n++){const e=h[n];s+=e*e}return s}for(let m=0;m<d;m++){const e=f(m),t=h[m]*Math.pow(i+o*e,-c);p[m]=t}return n.makeTensorInfo(s.shape,s.dtype,p)}};const cz={kernelName:Fd,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,y:r,dy:i}=t,{depthRadius:o,bias:c,alpha:l,beta:u}=a;pD(i,"LRNGrad");const h=wu(i.shape),d=i.shape[3],p=n.data.get(i.dataId).values,f=n.data.get(s.dataId).values,m=n.data.get(r.dataId).values,g=new Float32Array(h),y=h;for(let b=0;b<y;b++){const e=b%d,t=b-e+Math.max(0,e-o),n=b-e+Math.min(d,e+o+1);let a=0;for(let s=t;s<n;s++)a+=Math.pow(f[s],2);a=l*a+c;for(let s=t;s<n;s++){let e=-2*l*u*f[s]*m[b]/a;b===s&&(e+=Math.pow(a,-u)),e*=p[b],g[s]+=e}}return n.makeTensorInfo(i.shape,s.dtype,g)}};function lz(e,t,n,a){const s=Au(a,wu(n));for(let r=0;r<s.length;++r){const n=r*t;let a=e[n];for(let s=0;s<t;++s){const t=e[n+s];(Number.isNaN(t)||t>a)&&(a=t)}s[r]=a}return s}function uz(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{reductionIndices:r,keepDims:i}=a,o=n;let c=s.shape;const l=c.length,u=Ru(r,c);let h=u;const d=tv(h,l);let p=o.data.get(s.dataId).values;if(null!=d){const e=new Array(l);for(let t=0;t<e.length;t++)e[t]=c[d[t]];p=lO(p,c,s.dtype,d,e),h=av(h.length,l),c=e}pD(s,"max"),ev("max",h,l);const[f,m]=Jx(c,h),g=lz(p,wu(m),f,s.dtype),y=o.write(g,f,s.dtype);let b=f;if(i){b=$x(f,u)}return{dataId:y,shape:b,dtype:s.dtype}}const hz={kernelName:Ld,backendName:"cpu",kernelFunc:uz},dz=ID((e,t)=>Math.max(e,t)),pz=GD(zd,dz),fz={kernelName:zd,backendName:"cpu",kernelFunc:pz};const mz={kernelName:Bd,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t;pD(s,"maxPool");const{filterSize:r,strides:i,pad:o,dimRoundingMode:c}=a;bu(Jb(i,1),()=>"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(i," and dilations '").concat(1,"'"));const l=Vb(s.shape,r,i,1,o,c);let u;if(1===l.filterWidth&&1===l.filterHeight&&Su(l.inShape,l.outShape))u=wD({inputs:{x:s},backend:n});else{const e=n.data.get(s.dataId).values,t=ju(s.shape),a=TO(e,s.shape,s.dtype,t,l,"max");u=n.makeTensorInfo(l.outShape,s.dtype,a.values)}return u}};const gz={kernelName:Wd,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{filterSize:r,strides:i,pad:o,dimRoundingMode:c,dataFormat:l}=a;pD(s,"maxPool3d");const u=Ub(s.shape,r,i,1,o,c,l),h=RO(n.data.get(s.dataId).values,s.shape,s.dtype,ju(s.shape),u,"max");return n.makeTensorInfo(h.shape,"float32",h.values)}};const yz={kernelName:Vd,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:s,input:r}=t,{filterSize:i,strides:o,pad:c,dimRoundingMode:l}=a;pD([s,r],"maxPool3DGrad");const u=Ub(r.shape,i,o,1,c,l),h=function(e,t){const n=ny(t.outShape,"int32"),a=t.strideDepth,s=t.strideHeight,r=t.strideWidth,i=t.dilationDepth,o=t.dilationHeight,c=t.dilationWidth,l=t.effectiveFilterDepth,u=t.effectiveFilterHeight,h=t.effectiveFilterWidth,d=t.padInfo.front,p=t.padInfo.top,f=t.padInfo.left;for(let m=0;m<t.batchSize;++m)for(let g=0;g<t.inChannels;++g)for(let y=0;y<t.outDepth;++y){const b=y*a-d;let x=b;for(;x<0;)x+=i;const v=Math.min(t.inDepth,l+b);for(let a=0;a<t.outHeight;++a){const l=a*s-p;let d=l;for(;d<0;)d+=o;const w=Math.min(t.inHeight,u+l);for(let s=0;s<t.outWidth;++s){const p=s*r-f;let k=p;for(;k<0;)k+=c;const S=Math.min(t.inWidth,h+p);let C=Number.NEGATIVE_INFINITY,I=-1;for(let t=x;t<v;t+=i){const n=t-b;for(let a=d;a<w;a+=o){const s=a-l;for(let r=k;r<S;r+=c){const i=r-p,o=e.get(m,t,a,r,g);o>=C&&(C=o,I=n*u*h+s*u+i)}}}n.set(I,m,y,a,s,g)}}}return n}(n.bufferSync(r),u),d=u.strideDepth,p=u.strideHeight,f=u.strideWidth,m=u.dilationDepth,g=u.dilationHeight,y=u.dilationWidth,b=u.effectiveFilterDepth,x=u.effectiveFilterHeight,v=u.effectiveFilterWidth,w=b-1-u.padInfo.front,k=v-1-u.padInfo.left,S=x-1-u.padInfo.top,C=ny(r.shape,"float32"),I=n.bufferSync(s);for(let N=0;N<u.batchSize;++N)for(let e=0;e<u.inChannels;++e)for(let t=0;t<u.inDepth;++t)for(let n=0;n<u.inHeight;++n)for(let a=0;a<u.inWidth;++a){const s=t-w,r=n-S,i=a-k;let o=0;for(let t=0;t<b;t+=m){const n=(s+t)/d;if(!(n<0||n>=u.outDepth||Math.floor(n)!==n))for(let a=0;a<x;a+=g){const s=(r+a)/p;if(!(s<0||s>=u.outHeight||Math.floor(s)!==s))for(let r=0;r<v;r+=y){const c=(i+r)/f;if(c<0||c>=u.outWidth||Math.floor(c)!==c)continue;const l=b*x*v-1-h.get(N,n,s,c,e)===t*x*v+a*v+r?1:0;if(0===l)continue;o+=I.get(N,n,s,c,e)*l}}}C.set(o,N,t,n,a,e)}return n.makeTensorInfo(C.shape,C.dtype,C.values)}};const bz={kernelName:jd,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:s,input:r,output:i}=t,o=r;pD([r,i],"maxPoolGrad");const{filterSize:c,strides:l,pad:u,dimRoundingMode:h}=a,d=Vb(o.shape,c,l,1,u,h),p=n.data.get(o.dataId).values,f=ny(d.outShape,o.dtype,EO(p,o.shape,o.dtype,d).values),m=d.strideHeight,g=d.strideWidth,y=d.dilationHeight,b=d.dilationWidth,x=d.effectiveFilterHeight,v=d.effectiveFilterWidth,w=v-1-d.padInfo.left,k=x-1-d.padInfo.top,S=ny(o.shape,"float32"),C=n.data.get(s.dataId).values,I=ny(s.shape,"float32",C);for(let N=0;N<d.batchSize;++N)for(let e=0;e<d.inChannels;++e)for(let t=0;t<d.inHeight;++t)for(let n=0;n<d.inWidth;++n){const a=t-k,s=n-w;let r=0;for(let t=0;t<x;t+=y){const n=(a+t)/m;if(!(n<0||n>=d.outHeight||Math.floor(n)!==n))for(let a=0;a<v;a+=b){const i=(s+a)/g;if(i<0||i>=d.outWidth||Math.floor(i)!==i)continue;const o=x*v-1-f.get(N,n,i,e)===t*v+a?1:0;if(0===o)continue;r+=I.get(N,n,i,e)*o}}S.set(r,N,t,n,e)}return n.makeTensorInfo(S.shape,S.dtype,S.values)}};const xz={kernelName:Ud,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e;const{x:s}=t,{filterSize:r,strides:i,pad:o,includeBatchInIndex:c}=n,l=a;pD(s,"MaxPoolWithArgmax");const u=l.data.get(s.dataId).values,h=Vb(s.shape,r,i,[1,1],o),[d,p]=function(e,t,n,a,s){const r=TO(e,0,n,ju(t),s,"max"),i=EO(e,t,n,s,!0,a);return[r.values,i.values]}(u,s.shape,s.dtype,c,h),f=l.write(d,h.outShape,s.dtype),m=l.write(p,h.outShape,s.dtype);return[{dataId:f,shape:h.outShape,dtype:s.dtype},{dataId:m,shape:h.outShape,dtype:"int32"}]}};const vz={kernelName:Hd,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{axis:r,keepDims:i}=a,o=Ru(r,s.shape),c=wu(Jx(s.shape,o)[1]),l=[],u=n.makeTensorInfo([],"float32",new Float32Array([c]));l.push(u);const h=UD({inputs:{x:s},backend:n,attrs:{dtype:"float32"}});l.push(h);const d=nL({inputs:{a:h,b:u},backend:n});l.push(d);const p=MF({inputs:{x:d},backend:n,attrs:{axis:r,keepDims:i}});return l.forEach(e=>n.disposeIntermediateTensorInfo(e)),p}};const wz={kernelName:Gd,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{axis:r,keepDims:i}=a;pD(s,"min");const o=Ru(r,s.shape);let c=o;const l=tv(c,s.shape.length);let u=s;null!=l&&(u=uO({inputs:{x:s},backend:n,attrs:{perm:l}}),c=av(c.length,s.shape.length)),ev("min",c,u.shape.length);const[h,d]=Jx(u.shape,c),p=wu(d),f=Gu(wu(h),u.dtype),m=n.data.get(u.dataId).values;for(let y=0;y<f.length;++y){const e=y*p;let t=m[e];for(let n=0;n<p;++n){const a=m[e+n];(Number.isNaN(a)||a<t)&&(t=a)}f[y]=t}null!=l&&n.disposeIntermediateTensorInfo(u);const g=n.makeTensorInfo(h,u.dtype,f);if(i){const e=ZD({inputs:{x:g},backend:n,attrs:{shape:$x(h,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}},kz=ID((e,t)=>Math.min(e,t)),Sz=GD(qd,kz),Cz={kernelName:qd,backendName:"cpu",kernelFunc:Sz};const Iz={kernelName:Kd,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{paddings:r,mode:i}=a;pD(s,"mirrorPad");const o=r.map((e,t)=>e[0]+s.shape[t]+e[1]),c=r.map(e=>e[0]),l=r.map((e,t)=>e[0]+s.shape[t]),u="reflect"===i?0:1,h=n.data.get(s.dataId).values,d=s.shape.length,p=ju(s.shape),f=wu(o),m=o.length,g=ju(o),y=Au(s.dtype,f);for(let b=0;b<f;b++){let e=Yu(b,m,g);for(let n=0;n<m;n++)e[n]<c[n]?e[n]=2*c[n]-e[n]-u:e[n]>=l[n]&&(e[n]=2*(l[n]-1)-e[n]+u);e=e.map((e,t)=>e-c[t]);const t=Xu(e,d,p);y[b]=h[t]}return{dataId:n.write(y,o,s.dtype),shape:o,dtype:s.dtype}}},Nz=ID((e,t)=>{const n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t}),Tz=GD(Xd,Nz),Ez={kernelName:Xd,backendName:"cpu",kernelFunc:Tz};function Rz(e){const{inputs:t,backend:n,attrs:a}=e,{logits:s}=t,{dim:r}=a,i=s.shape.length;let o=r;if(-1===o&&(o=i-1),o!==i-1)throw Error("Softmax along a non-last dimension is not yet supported. "+"Logits was rank ".concat(i," and dim was ").concat(o));const c=Ru([o],s.shape),l=uz({inputs:{x:s},backend:n,attrs:{reductionIndices:c,keepDims:!1}}),u=$x(l.shape,c),h=ZD({inputs:{x:l},backend:n,attrs:{shape:u}}),d=iL({inputs:{a:s,b:h},backend:n}),p=XF({inputs:{x:d},backend:n}),f=MF({inputs:{x:p},backend:n,attrs:{axis:c,keepDims:!1}}),m=ZD({inputs:{x:f},backend:n,attrs:{shape:u}}),g=nL({inputs:{a:p,b:m},backend:n});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}const _z={kernelName:jp,backendName:"cpu",kernelFunc:Rz};const Az={kernelName:Yd,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{logits:s}=t,{numSamples:r,seed:i,normalized:o}=a;pD(s,"multinomial");const c=o?s:Rz({inputs:{logits:s},backend:n,attrs:{dim:-1}}),l=c.shape[0],u=c.shape[1],h=n.data.get(c.dataId).values,d=[l,r],p=Gu(wu(d),"int32");for(let f=0;f<l;++f){const e=f*u,t=new Float32Array(u-1);t[0]=h[e];for(let s=1;s<t.length;++s)t[s]=t[s-1]+h[e+s];const n=bw.alea(i.toString()),a=f*r;for(let s=0;s<r;++s){const e=n();p[a+s]=t.length;for(let n=0;n<t.length;n++)if(e<t[n]){p[a+s]=n;break}}}return o||n.disposeIntermediateTensorInfo(c),n.makeTensorInfo(d,"int32",p)}};function Mz(e,t,n){const a=Vf(-1,n);return EF([],t,a,e,n)}const Pz={kernelName:Zd,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t;pD(a,"neg");const s=n.data.get(a.dataId).values,[r,i]=Mz(s,a.shape,a.dtype);return n.makeTensorInfo(i,a.dtype,r)}},Dz=sS;const Oz={kernelName:$d,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{boxes:s,scores:r}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:c}=a;pD(s,"NonMaxSuppression");const l=n.data.get(s.dataId).values,u=n.data.get(r.dataId).values,{selectedIndices:h}=Dz(l,u,i,o,c);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}},Fz=rS;const Lz={kernelName:ep,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{boxes:s,scores:r}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:c,padToMaxOutputSize:l}=a;pD(s,"NonMaxSuppressionPadded");const u=n.data.get(s.dataId).values,h=n.data.get(r.dataId).values,{selectedIndices:d,validOutputs:p}=Fz(u,h,i,o,c,l);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},zz=iS;const Bz={kernelName:tp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{boxes:s,scores:r}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:c,softNmsSigma:l}=a;pD(s,"NonMaxSuppressionWithScore");const u=n.data.get(s.dataId).values,h=n.data.get(r.dataId).values,d=i,p=o,f=c,m=l,{selectedIndices:g,selectedScores:y}=zz(u,h,d,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}},jz=ID((e,t)=>e!==t?1:0),Wz=GD(Jd,jz,null,"bool"),Vz={kernelName:Jd,backendName:"cpu",kernelFunc:Wz};const Uz={kernelName:ap,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{indices:s}=t,{dtype:r,depth:i,onValue:o,offValue:c}=a;pD(s,"oneHot");const l=wu(s.shape),u=new Float32Array(l*i);u.fill(c);const h=n.data.get(s.dataId).values;for(let d=0;d<l;++d)h[d]>=0&&h[d]<i&&(u[d*i+h[d]]=o);return n.makeTensorInfo([...s.shape,i],r,u)}};function Hz(e){const{inputs:t,backend:n}=e,{x:a}=t;if("string"===a.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===a.dtype){const e=jD({inputs:{input:a},backend:n}),t=Hz({inputs:{x:e},backend:n}),s=$O({inputs:{input:a},backend:n}),r=Hz({inputs:{x:s},backend:n}),i=LD({inputs:{real:t,imag:r},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(r),i}return dL({backend:n,attrs:{shape:a.shape,value:0,dtype:a.dtype}})}const Gz={kernelName:uf,backendName:"cpu",kernelFunc:Hz};const qz={kernelName:np,backendName:"cpu",kernelFunc:function e(t){const{inputs:n,backend:a}=t,{x:s}=n;if("string"===s.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===s.dtype){const t=jD({inputs:{input:s},backend:a}),n=e({inputs:{x:t},backend:a}),r=$O({inputs:{input:s},backend:a}),i=Hz({inputs:{x:r},backend:a}),o=LD({inputs:{real:n,imag:i},backend:a});return a.disposeIntermediateTensorInfo(t),a.disposeIntermediateTensorInfo(n),a.disposeIntermediateTensorInfo(r),a.disposeIntermediateTensorInfo(i),o}return dL({backend:a,attrs:{shape:s.shape,value:1,dtype:s.dtype}})}};function Kz(e){const{inputs:t,backend:n,attrs:a}=e,{axis:s}=a;if(1===t.length)return QF({inputs:{input:t[0]},backend:n,attrs:{dim:s}});const r=t[0].shape,i=t[0].dtype;t.forEach(e=>{xu(r,e.shape,"All tensors passed to stack must have matching shapes"),bu(i===e.dtype,()=>"All tensors passed to stack must have matching dtypes")});const o=[],c=tF({inputs:t.map(e=>{const t=QF({inputs:{input:e},backend:n,attrs:{dim:s}});return o.push(t),t}),backend:n,attrs:{axis:s}});return o.forEach(e=>n.disposeIntermediateTensorInfo(e)),c}const Xz={kernelName:sp,backendName:"cpu",kernelFunc:Kz};const Yz={kernelName:rp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{paddings:r,constantValue:i}=a;pD(s,"pad");const o=r.map((e,t)=>e[0]+s.shape[t]+e[1]),c=r.map(e=>e[0]),l=n.data.get(s.dataId).values,u=wu(s.shape),h=s.shape.length,d=ju(s.shape),p=wu(o),f=o.length,m=ju(o),g=Au(s.dtype,p);0!==i&&g.fill(i);for(let y=0;y<u;y++){g[Xu(Yu(y,h,d).map((e,t)=>e+c[t]),f,m)]=l[y]}return{dataId:n.write(g,o,s.dtype),shape:o,dtype:s.dtype}}},Qz=ID((e,t)=>Math.pow(e,t)),Zz=GD(ip,Qz),Jz={kernelName:ip,backendName:"cpu",kernelFunc:Zz};function $z(e,t,n,a){const[s,r]=Jx(e,a),i=gm(t,"int32"),o=Gu(wu(s),i),c=wu(r);for(let l=0;l<o.length;++l){const e=l*c;let t=1;for(let a=0;a<c;++a)t*=n[e+a];o[l]=t}return{outVals:o,outShape:s,outDtype:i}}const eB={kernelName:cp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{axis:r,keepDims:i}=a;pD(s,"prod");const o=s.shape.length,c=Ru(r,s.shape),l=tv(c,o);let u=c,h=s;const d=[];null!=l&&(h=uO({inputs:{x:s},backend:n,attrs:{perm:l}}),d.push(h),u=av(u.length,o));const p=n.data.get(h.dataId).values,{outVals:f,outShape:m,outDtype:g}=$z(h.shape,h.dtype,p,u);let y=m;return i&&(y=$x(m,c)),d.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.makeTensorInfo(y,g,f)}};function tB(e,t,n,a){const s=[];let r=0;const i=t.length-1+n.length,o=new Array(i).fill(null).map(()=>[0]);!function(e,t){for(let n=0;n<e.length;++n){const a=e[n],s=n===e.length-1?t:e[n+1].length;if(0===a.length)throw new Error("Ragged splits may not be empty");if(a[0]<0)throw new Error("Ragged splits must be non-negative");if(a[a.length-1]>s)throw new Error("Ragged splits must not point past values");for(let e=1;e<a.length;++e)if(a[e-1]>a[e])throw new Error("Ragged splits must be sorted in ascending order")}}(n,a);let c=1;for(let l=0;l<t.length-1;++l){c*=t[l];const e=t[l+1];for(let t=1;t<c+1;++t)o[l].push(t*e)}for(let l=0;l<e.length;++l){let a=e[l],i=e[l]+1;for(let e=0;e<n.length;++e){const s=n[e],r=e+t.length-1;if(r>=0){const e=o[r],t=e[e.length-1]-s[a];for(let n=a;n<i;++n)o[r].push(s[n+1]+t)}a=s[a],i=s[i]}i!==a&&(s.push([a,i]),r+=i-a)}return{outSplits:o,valueSlices:s,numValues:r}}function nB(e,t){const n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let a=t;a<e.length;a++)n[t-1]*=e[a];return n}function aB(e,t,n,a,s){const r=t.slice();r[0]=s;const i=Mu(n,wu(r)),o=e.length;return function(e,t,n,a,s,r){const i=nB(t,2)[1],o=nB(r,2)[1];let c=0;for(const l of n)for(let t=l[0];t<l[1];++t){for(let n=0;n<a;++n)s[c*o+n]=e[t*i+n];++c}}(e,t,a,0===o?0:o/t[0],i,r),[i,r]}function sB(e,t,n,a,s,r,i,o){if(0===e.length)throw new Error("paramsNestedSplits must be non empty");if(0===t[0].length)throw new Error("Split tensors must not be scalars");if(function(e,t,n){e.forEach((e,a)=>{if(e<0||e>=n){const s=Yu(a,t.length,ju(t)).join(",");throw new Error("indices[".concat(s,"] = ").concat(e," is not in [0, ").concat(n,")"))}})}(r,i,t[0][0]-1),0===a.length)throw new Error("params.rank must be nonzero");const c=a[0],{outSplits:l,valueSlices:u,numValues:h}=tB(r,i,e,c),d=function(e){const t=[];for(let n=0;n<e.length;++n){const a=Mu("int32",e[n].length);t.push(a),e[n].forEach((e,t)=>a[t]=e)}return t}(l),p=aB(n,a,s,u,h);return[d,p[0],p[1]]}const rB={kernelName:lp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{paramsNestedSplits:s,paramsDenseValues:r,indices:i}=t,{outputRaggedRank:o}=a,c=s.map(e=>n.data.get(e.dataId).values),l=s.map(e=>e.shape),u=n.data.get(r.dataId).values,h=n.data.get(i.dataId).values,[d,p,f]=sB(c,l,u,r.shape,r.dtype,h,i.shape),m=d.map(e=>n.makeTensorInfo([e.length],"int32",e)),g=n.makeTensorInfo(f,r.dtype,p);return m.concat([g])}},iB=2147483647;function oB(e,t,n,a,s,r,i){if(t.length>1)throw new Error("starts must be a scalar or vector");if(s.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");const o=0===t.length,c=0===s.length,l=0===i.length,u=[];o||u.push(t[0]),c||u.push(s[0]),l||u.push(i[0]);for(let m=1;m<u.length;++m)if(u[m]!==u[m-1])throw new Error("starts, limits, and deltas must have the same shape");const h=0===u.length?1:u[0],d=Mu("int32",h+1);d[0]=0;for(let m=0;m<h;++m){const t=o?e[0]:e[m],n=c?a[0]:a[m],s=l?r[0]:r[m];if(0===s)throw new Error("Requires delta != 0");let i;if(s>0&&n<t||s<0&&n>t)i=0;else if(i=Math.ceil(Math.abs((n-t)/s)),i>iB)throw new Error("Requires ((limit - start) / delta) <= ".concat(iB));d[m+1]=d[m]+i}const p=Mu(n,d[h]);let f=0;for(let m=0;m<h;++m){const t=d[m+1]-d[m];let n=o?e[0]:e[m];const a=l?r[0]:r[m];for(let e=0;e<t;++e)p[f++]=n,n+=a}return[d,p]}const cB={kernelName:up,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{starts:a,limits:s,deltas:r}=t,i=n.data.get(a.dataId).values,o=n.data.get(s.dataId).values,c=n.data.get(r.dataId).values,[l,u]=oB(i,a.shape,a.dtype,o,s.shape,c,r.shape);return[n.makeTensorInfo([l.length],"int32",l),n.makeTensorInfo([u.length],a.dtype,u)]}};var lB=eC;class uB{constructor(e,t,n,a,s,r,i,o,c,l){this.shape=e,this.shapeShape=t,this.values=n,this.valuesShape=a,this.valuesDType=s,this.defaultValue=r,this.defaultValueShape=i,this.rowPartitionValues=o,this.rowPartitionValuesShapes=c,this.rowPartitionTypes=nC(l),this.raggedRank=aC(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===lB.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===lB.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case lB.VALUE_ROWIDS:return uB.getMaxWidthValueRowID(t);case lB.ROW_SPLITS:return uB.getMaxWidthRowSplit(t);default:throw new Error("Cannot handle partition type ".concat(lB[this.getRowPartitionTypeByDimension(e-1)]))}}static getMaxWidthRowSplit(e){const t=e.length;if(0===t||1===t)return 0;let n=0;for(let a=0;a<t-1;++a){const t=e[a+1]-e[a];t>n&&(n=t)}return n}static getMaxWidthValueRowID(e){const t=e.length;if(0===t)return 0;let n=0,a=e[0],s=0;for(let r=1;r<t;++r){const t=e[r];t!==a&&(a=t,s=Math.max(r-n,s),n=r)}return Math.max(t-n,s)}tensorShapeFromTensor(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(0===t.length){if(-1===e[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return dB(e,n)}calculateOutputSize(e){const t=this.valuesShape;sC(this.defaultValueShape,t);const n=this.tensorShapeFromTensor(this.shape,this.shapeShape),a=tC(this.raggedRank,n,t);a[0]<0&&(a[0]=e);for(let s=1;s<=this.raggedRank;++s)a[s]<0&&(a[s]=this.getMaxWidth(s));return a}calculateFirstParentOutputIndex(e,t,n){const a=Math.min(e,n),s=[];let r=0;for(let i=0;i<a;++i,r+=t)s.push(r);for(let i=a;i<e;++i)s.push(-1);return bu(s.length===e,()=>"Final length of result must be equal to firstDimension."),s}calculateOutputIndexRowSplit(e,t,n,a){const s=e.length,r=[];for(let i=0;i<s-1;++i){const s=e[i+1]-e[i];let o=Math.min(a,s),c=t[i];-1===c&&(o=0);for(let e=0;e<o;++e)r.push(c),c+=n;for(let e=0;e<s-o;++e)r.push(-1)}if(s>0&&r.length!==e[s-1])throw new Error("Invalid row split size.");return r}calculateOutputIndexValueRowID(e,t,n,a){const s=e.length,r=[];if(0===s)return[];let i=0,o=e[0];if(o>=t.length)throw new Error("Got currentValueRowId=".concat(o,", which is not less than ").concat(t.length));let c=t[o];r.push(c);for(let l=1;l<s;++l){const s=e[l];if(s===o)c>=0&&(++i,i<a?c+=n:c=-1);else{if(i=0,o=s,s>=t.length)throw new Error("Got nextValueRowId=".concat(s," which is not less than ").concat(t.length));c=t[s]}r.push(c)}if(r.length!==e.length)throw new Error("Invalid row ids.");return r}calculateOutputIndex(e,t,n,a){const s=this.getRowPartitionTensor(e),r=this.getRowPartitionTypeByDimension(e);switch(r){case lB.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(s,t,n,a);case lB.ROW_SPLITS:if(s.length-1>t.length)throw new Error("Row partition size is greater than output size: ".concat(s.length-1," > ").concat(t.length));return this.calculateOutputIndexRowSplit(s,t,n,a);default:throw new Error("Unsupported partition type: ".concat(lB[r]))}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case lB.FIRST_DIM_SIZE:return e[0];case lB.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case lB.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error("Cannot handle type ".concat(lB[t]))}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),t=this.calculateOutputSize(e),n=new Array(this.raggedRank+1);n[n.length-1]=1;for(let r=n.length-2;r>=0;--r)n[r]=n[r+1]*t[r+1];const a=dB(t,!1),s=Mu(this.valuesDType,wu(a));if(n[0]*t[0]>0){let r=this.calculateFirstParentOutputIndex(e,n[0],t[0]);for(let e=1;e<=this.raggedRank;++e){r=this.calculateOutputIndex(e-1,r,n[e],t[e])}this.setOutput(this.raggedRank,r,s,a)}return[a,s]}setOutput(e,t,n,a){if(0===n.length)return;const s=this.values,r=n;let i=a.slice();i=i.slice(e+1);const o=wu(i),c=t.length;let l=this.defaultValue;if(l.length!==o&&1!==l.length){const e=this.defaultValueShape;Xm(()=>{const t=nx(l,e),n=xx(t,i);l=n.dataSync()})}let u=0,h=0,d=0;for(let p=0;p<=c;++p){let e=p<c?t[p]:-1;if(e!==d){if(h<d){const e=s.subarray(u*o);hB(r.subarray(h*o),e,(d-h)*o)}if(p>=c){const t=n.length;e=Math.floor(t/o)}if(e>d)if(1===this.defaultValue.length)r.subarray(d*o,e*o).fill(this.defaultValue[0]),d=e;else for(;e>d;){hB(r.slice(d*o),l,o),++d}e<0?(u=p+1,h=d):(u=p,h=d,d=h+1)}else++d}}}function hB(e,t,n){for(let a=0;a<n;a++)e[a]=t[a]}function dB(e,t){const n=[];for(let a of e){if(a<0){if(!t)throw new Error("Dimension ".concat(a," must be >= 0"));if(a<-1)throw new Error("Dimension ".concat(a," must be >= -1"));a=-1}n.push(a)}return n}function pB(e,t,n,a,s,r,i,o,c,l){return new uB(e,t,n,a,s,r,i,o,c,l).compute()}const fB={kernelName:hp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{shape:s,values:r,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:c}=a,l=n.data.get(s.dataId).values,u=n.data.get(r.dataId).values,h=n.data.get(i.dataId).values,d=o.map(e=>n.data.get(e.dataId).values),p=o.map(e=>e.shape),[f,m]=pB(l,s.shape,u,r.shape,r.dtype,h,i.shape,d,p,c);return n.makeTensorInfo(f,r.dtype,m)}};function mB(e,t,n,a){if(e===t||e<t&&n<0||t<e&&n>1)return Gu(0,a);const s=Gu(Math.abs(Math.ceil((t-e)/n)),a);t<e&&1===n&&(n=-1),s[0]=e;for(let r=1;r<s.length;r++)s[r]=s[r-1]+n;return s}const gB={kernelName:dp,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:a,stop:s,dtype:r,step:i}=n,o=mB(a,s,i,r);return t.makeTensorInfo([o.length],r,o)}},yB=yD(fp,e=>1/e),bB={kernelName:fp,backendName:"cpu",kernelFunc:yB};const xB={kernelName:xp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:s}=t,{alignCorners:r,halfPixelCenters:i,size:o}=a;pD(s,"resizeBilinear");const c=ju(s.shape),[l,u]=o,[h,d,p,f]=s.shape,m=n.data.get(s.dataId).values,g=new Float32Array(wu([h,l,u,f])),y=[r&&l>1?d-1:d,r&&u>1?p-1:p],b=[r&&l>1?l-1:l,r&&u>1?u-1:u];let x=0;const v=y[0]/b[0],w=y[1]/b[1];for(let k=0;k<h;k++)for(let e=0;e<l;e++){let t;t=i?v*(e+.5)-.5:v*e;const n=Math.max(0,Math.floor(t)),a=t-n,s=Math.min(d-1,Math.ceil(t)),r=k*c[0]+n*c[1],o=k*c[0]+s*c[1];for(let e=0;e<u;e++){let t;t=i?w*(e+.5)-.5:w*e;const n=Math.max(0,Math.floor(t)),s=t-n,l=Math.min(p-1,Math.ceil(t)),u=r+n*c[2],h=o+n*c[2],d=r+l*c[2],y=o+l*c[2];for(let e=0;e<f;e++){const t=m[u+e],n=m[h+e],r=t+(m[d+e]-t)*s,i=r+(n+(m[y+e]-n)*s-r)*a;g[x++]=i}}}return n.makeTensorInfo([h,l,u,f],"float32",g)}};const vB={kernelName:vp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:s,dy:r}=t,{alignCorners:i}=a;pD([r,s],"resizeBilinearGrad");const o=ju(s.shape),[c,l,u,h]=s.shape,[,d,p]=r.shape,f=new Float32Array(c*l*u*h),m=[i&&d>1?l-1:l,i&&p>1?u-1:u],g=[i&&d>1?d-1:d,i&&p>1?p-1:p],y=m[0]/g[0],b=m[1]/g[1],x=n.data.get(r.dataId).values;let v=0;for(let w=0;w<c;w++){const e=w*o[0];for(let t=0;t<d;t++){const n=t*y,a=Math.floor(n),s=Math.min(Math.ceil(n),l-1),r=e+a*o[1],i=e+s*o[1],c=n-a,d=1-c;for(let e=0;e<p;e++){const t=e*b,n=Math.floor(t),a=Math.min(Math.ceil(t),u-1),s=t-n,l=1-s,p=r+n*o[2],m=r+a*o[2],g=i+n*o[2],y=i+a*o[2],w=d*l,k=d*s,S=c*l,C=c*s;for(let e=0;e<h;e++){const t=x[v++];f[p+e]+=t*w,f[m+e]+=t*k,f[g+e]+=t*S,f[y+e]+=t*C}}}}return n.makeTensorInfo([c,u,l,h],"float32",f)}};const wB={kernelName:yp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:s}=t,{alignCorners:r,halfPixelCenters:i,size:o}=a;pD(s,"resizeNearestNeighbor");const c=ju(s.shape),[l,u]=o,[h,d,p,f]=s.shape,m=n.data.get(s.dataId).values,g=new Float32Array(h*l*u*f),y=[r&&l>1?d-1:d,r&&u>1?p-1:p],b=[r&&l>1?l-1:l,r&&u>1?u-1:u],x=y[0]/b[0],v=y[1]/b[1];let w=0;for(let k=0;k<h;k++){const e=k*c[0];for(let t=0;t<l;t++){const n=i?x*(t+.5):x*t;let a=Math.min(d-1,r?Math.round(n):Math.floor(n));i&&(a=Math.max(0,a));const s=e+a*c[1];for(let e=0;e<u;e++){const t=i?v*(e+.5):v*e;let n=Math.min(p-1,r?Math.round(t):Math.floor(t));i&&(n=Math.max(0,n));const a=s+n*c[2];for(let e=0;e<f;e++){const t=m[a+e];g[w++]=t}}}}return n.makeTensorInfo([h,l,u,f],s.dtype,g)}};const kB={kernelName:bp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:s,dy:r}=t,{alignCorners:i}=a;pD([r,s],"resizeNearestNeighborGrad");const o=ju(s.shape),c=ju(r.shape),[l,u,h,d]=s.shape,[,p,f]=r.shape,m=new Float32Array(l*u*h*d),g=n.data.get(r.dataId).values,y=[i&&p>1?u-1:u,i&&f>1?h-1:h],b=[i&&p>1?p-1:p,i&&f>1?f-1:f],x=y[0]/b[0],v=y[1]/b[1],w=1/x,k=1/v,S=2*Math.ceil(w)+2,C=2*Math.ceil(k)+2;for(let I=0;I<l;I++){const e=I*o[0];for(let t=0;t<u;t++){const n=e+t*o[1],a=Math.floor(t*w),s=Math.floor(a-S/2);for(let r=0;r<h;r++){const a=n+r*o[2],l=Math.floor(r*k),y=Math.floor(l-C/2);for(let n=0;n<d;n++){let o=0;for(let a=0;a<S;a++){const l=a+s;if(l<0||l>=p)continue;const d=e+l*c[1],m=l*x;if(t===Math.min(u-1,i?Math.round(m):Math.floor(m)))for(let e=0;e<C;e++){const t=e+y;if(t<0||t>=f)continue;const a=d+t*c[2],s=t*v;r===Math.min(h-1,i?Math.round(s):Math.floor(s))&&(o+=g[a+n])}}m[a+n]=o}}}}return n.makeTensorInfo(s.shape,s.dtype,m)}};const SB={kernelName:kp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{dims:r}=a;pD(s,"reverse");const i=s.shape.length,o=Ru(r,s.shape);if(0===i)return wD({inputs:{x:s},backend:n});const c=new am(s.shape,s.dtype),l=n.bufferSync(s);for(let u=0;u<c.size;u++){const e=c.indexToLoc(u),t=e.slice();o.forEach(e=>t[e]=s.shape[e]-1-t[e]),c.set(l.get(...t),...e)}return n.makeTensorInfo(c.shape,c.dtype,c.values)}},CB={kernelName:pf,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e;const{image:s}=t,{radians:r,fillValue:i,center:o}=n,c=a,l=Au(s.dtype,wu(s.shape)),[u,h,d,p]=s.shape,[f,m]=oC(o,h,d),g=Math.sin(r),y=Math.cos(r),b=c.data.get(s.dataId).values;for(let x=0;x<u;x++){const e=x*d*h*p;for(let t=0;t<h;t++){const n=t*(d*p);for(let a=0;a<d;a++){const s=a*p;for(let r=0;r<p;r++){const o=[u,t,a,r],c=o[2],x=o[1];let v=(c-f)*y-(x-m)*g,w=(c-f)*g+(x-m)*y;v=Math.round(v+f),w=Math.round(w+m);let k=i;if("number"!==typeof i&&(k=3===r?255:i[r]),v>=0&&v<d&&w>=0&&w<h){k=b[e+w*(d*p)+v*p+r]}l[e+n+s+r]=k}}}}return{dataId:c.write(l,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},IB=yD(Sp,e=>{const t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2===0?t:t+1}),NB={kernelName:Sp,backendName:"cpu",kernelFunc:IB},TB=gD(e=>1/Math.sqrt(e)),EB=bD(Cp,TB),RB={kernelName:Cp,backendName:"cpu",kernelFunc:EB};function _B(e,t,n,a,s,r,i,o,c,l){const u=[a/s,s],h=e.values,d=t.values;if(0===a)return ny(n,t.dtype);const p=c instanceof am?c:ny(u,t.dtype);"string"===typeof c||"number"===typeof c?p.values.fill(c):"boolean"===typeof c&&p.values.fill(+c);for(let f=0;f<r;f++){const e=[];let r=0;for(let t=0;t<i;t++){const n=h[f*i+t];e.push(n),r+=n*o[t]}if(r<0||r>=a/s)throw new Error("Invalid indices: ".concat(e," does not index into ").concat(n));for(let n=0;n<s;n++)l?p.values[r*s+n]+=d[f*s+n]:p.values[r*s+n]=0===t.rank?d[0]:d[f*s+n]}return p}const AB={kernelName:Ip,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{indices:s,updates:r}=t,{shape:i}=a,{sliceRank:o,numUpdates:c,sliceSize:l,strides:u,outputSize:h}=fk(0,s,i),d=_B(n.bufferSync(s),n.bufferSync(r),i,h,l,c,o,u,0,!0);return n.makeTensorInfo(i,d.dtype,d.values)}};function MB(e,t){let n=0,a=e.length,s=0;for(;n<a;)s=Math.floor((n+a)/2),e[s]<t?n=s+1:a=s;return a}function PB(e,t){let n=0,a=e.length,s=0;for(;n<a;)s=Math.floor((n+a)/2),e[s]<=t?n=s+1:a=s;return a}const DB={kernelName:Tp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{sortedSequence:s,values:r}=t,{side:i}=a,o=function(e,t,n,a,s,r){const i=Mu("int32",n*s);for(let o=0;o<n;++o){const n=e.slice(o*a,(o+1)*a),c=o*s;for(let e=0;e<s;++e)i[c+e]="left"===r?MB(n,t[e+c]):PB(n,t[e+c])}return i}(n.data.get(s.dataId).values,n.data.get(r.dataId).values,s.shape[0],s.shape[1],r.shape[1],i);return n.makeTensorInfo(r.shape,"int32",o)}};const OB={kernelName:Ep,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:a,t:s,e:r}=t;pD([a,s,r],"select");const i=a.shape.length,o=n.data.get(a.dataId).values,c=n.data.get(s.dataId).values,l=n.data.get(r.dataId).values,u=gm(s.dtype,r.dtype),h=Gu(wu(s.shape),u);let d=0;const p=0===i||i>1||1===s.shape.length?1:wu(s.shape.slice(1));for(let f=0;f<o.length;f++)for(let e=0;e<p;e++)1===o[f]?h[d++]=c[f]:h[d++]=l[f];return n.makeTensorInfo(s.shape,u,h)}},FB=fC,LB=mC,zB=yD(Rp,e=>e>=0?LB*e:FB*(Math.exp(e)-1)),BB={kernelName:Rp,backendName:"cpu",kernelFunc:zB},jB=yD(Pp,e=>e<0?-1:e>0?1:0),WB={kernelName:Pp,backendName:"cpu",kernelFunc:jB},VB=yD(Ap,e=>Math.sin(e)),UB={kernelName:Ap,backendName:"cpu",kernelFunc:VB},HB=yD(Mp,e=>Math.sinh(e)),GB={kernelName:Mp,backendName:"cpu",kernelFunc:HB},qB=Math.log(1.1920928955078125e-7)+2,KB=yD(Op,e=>{const t=e>-qB,n=e<qB,a=Math.exp(e);let s;return s=n?a:t?e:Math.log(1+a),s}),XB={kernelName:Op,backendName:"cpu",kernelFunc:KB};const YB={kernelName:zp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{blockShape:r,paddings:i}=a;pD([s],"spaceToBatchND");const o=wu(r),c=[[0,0]];c.push(...i);for(let g=1+r.length;g<s.shape.length;++g)c.push([0,0]);const l=Yz.kernelFunc({inputs:{x:s},backend:n,attrs:{paddings:c,constantValue:0}}),u=cC(l.shape,r,o,!1),h=lC(u.length,r.length,!1),d=uC(l.shape,r,o,!1),p=ZD({inputs:{x:l},backend:n,attrs:{shape:u}}),f=uO({inputs:{x:p},backend:n,attrs:{perm:h}}),m=ZD({inputs:{x:f},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}};function QB(e,t,n,a,s,r,i){const o=t[0],c=r[0],l=new Array(c),u=new Array(o),h=t[1];if(0===c){if(0!==o)throw new Error(WC(o));return[Mu(n,0),[0,h],Mu(s,0),l,u]}let d=!0,p=0;const f=new Array(c).fill(0);for(let g=0;g<o;++g){const t=e[g*h];if(t<0)throw new Error(VC(g,t));if(t>=c)throw new Error(UC(g,t,c));++f[t],d=d&&t>=p,p=t}let m=!0;for(let g=0;g<c;++g){const e=0===f[g];l[g]=e,m=m&&!e,f[g]=Math.max(f[g],1),g>0&&(f[g]+=f[g-1])}if(m&&d){const t=e,n=a;for(let e=0;e<o;++e)u[e]=e;return[t,[o,h],n,l,u]}{const t=f[c-1],r=Mu(n,t*h),d=Mu(s,t),p=new Array(c).fill(0);for(let n=0;n<o;++n){const t=e[n*h],s=p[t],i=(0===t?0:f[t-1])+s;p[t]++;for(let a=0;a<h;++a)r[i*h+a]=e[n*h+a];d[i]=a[n],u[n]=i}for(let e=0;e<c;++e){if(0===p[e]){const t=0===e?0:f[e-1];r[t*h+0]=e;for(let e=1;e<h;++e)r[t*h+e]=0;d[t]=i}}return[r,[t,h],d,l,u]}}const ZB={kernelName:Wp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:a,values:s,denseShape:r,defaultValue:i}=t;if(1!==r.shape.length)throw new Error("Dense shape must be a vector, saw:\n        ".concat(r.shape));if(2!==a.shape.length)throw new Error("Indices must be a matrix, saw:\n        ".concat(a.shape));if(1!==s.shape.length)throw new Error("Values must be a vector, saw:\n        ".concat(s.shape));if(0!==i.shape.length)throw new Error("Default value must be a scalar, saw:\n        ".concat(i.shape));const o=n.data.get(a.dataId).values,c=n.data.get(s.dataId).values,l=n.data.get(r.dataId).values,u=n.data.get(i.dataId).values[0],[h,d,p,f,m]=QB(o,a.shape,a.dtype,c,s.dtype,l,u);return[n.makeTensorInfo(d,a.dtype,h),n.makeTensorInfo([d[0]],s.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(e=>Number(e)))),n.makeTensorInfo([m.length],a.dtype,new Int32Array(m))]}};function JB(e,t,n,a,s){const r=wu(a),i=t[0],o=s.length,c=[];let l=1,u=-1;for(let m=0;m<o;++m){const e=s[m];if(-1===e){if(-1!==u)throw new Error(HC(u,m));u=m,c.push(1)}else{if(e<0)throw new Error(GC(m,e));l*=e,c.push(e)}}if(-1!==u){if(l<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");const e=Math.trunc(r/l);if(l*e!==r)throw new Error(KC(a,c));c[u]=e}if(wu(c)!==r)throw new Error(XC(a,c));const h=a.length,d=[];if(h>0){d[h-1]=1;for(let e=h-2;e>=0;--e)d[e]=d[e+1]*a[e+1]}const p=[];if(o>0){p[o-1]=1;for(let e=o-2;e>=0;--e)p[e]=p[e+1]*c[e+1]}const f=Mu(n,i*o);for(let m=0;m<i;++m){let t=0;for(let n=0;n<h;++n)t+=e[m*h+n]*d[n];for(let e=0;e<o;++e)f[m*o+e]=Math.trunc(t/p[e]),t%=p[e]}return[f,[i,o],c]}const $B={kernelName:Vp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:a,inputShape:s,newShape:r}=t;if(2!==a.shape.length)throw new Error("Input indices should be a matrix but received shape\n        ".concat(a.shape));if(1!==s.shape.length)throw new Error("Input shape should be a vector but received shape\n        ".concat(s.shape));if(1!==r.shape.length)throw new Error("Target shape should be a vector but received shape ".concat(r.shape));const i=Array.from(n.data.get(s.dataId).values),o=n.data.get(a.dataId).values,c=Array.from(n.data.get(r.dataId).values),[l,u,h]=JB(o,a.shape,a.dtype,i,c);return[n.makeTensorInfo(u,a.dtype,l),n.makeTensorInfo([h.length],r.dtype,new Int32Array(h))]}};function ej(e,t,n,a,s){let r=arguments.length>5&&void 0!==arguments[5]&&arguments[5],i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;const o=a.length,c=[t[0],e.length/t[0]],l=c[1],u=o>0?s[o-1]+1:0;if(u<0)throw new Error("segment ids must be >= 0");const h=t.slice();h[0]=u;const d=Mu(n,h.reduce((e,t)=>e*t,1));if(0===o)return u>0&&d.fill(i),[d,h];if(u<=0)throw new Error("segment ids must be >= 0");let p=0,f=1,m=0,g=s[p];for(;;){let t=0;if(f<o){if(t=s[f],g===t){++f;continue}if(g>=t)throw new Error(QC())}if(g<0||g>=u)throw new Error(ZC(g,u));g>m&&d.fill(i,m*l,g*l);for(let n=p;n<f;++n){const t=a[n];if(t<0||t>=c[0])throw new Error(JC(n,a[n],c[0]));for(let n=0;n<l;n++)d[g*l+n]+=e[t*l+n]}if(r)for(let e=0;e<l;e++)d[g*l+e]/=f-p;if(p=f,++f,m=g+1,g=t,f>o)break}return m<u&&d.fill(i,m*l,u*l),[d,h]}const tj={kernelName:Up,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:a,indices:s,segmentIds:r}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error("Indices should be a vector but received shape\n          ".concat(s.shape));if(1!==r.shape.length)throw new Error("Segment ids should be a vector but received shape\n          ".concat(r.shape));if(s.shape[0]!==r.shape[0])throw new Error("segmentIds and indices should have same size.");const i=n.data.get(a.dataId).values,o=n.data.get(s.dataId).values,c=n.data.get(r.dataId).values,[l,u]=ej(i,a.shape,a.dtype,o,c,!0);return n.makeTensorInfo(u,a.dtype,l)}};const nj={kernelName:Hp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:a,indices:s,segmentIds:r}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error("Indices should be a vector but received shape\n         ".concat(s.shape));if(1!==r.shape.length)throw new Error("Segment ids should be a vector but received shape\n         ".concat(r.shape));if(s.shape[0]!==r.shape[0])throw new Error("segmentIds and indices should have same size.");const i=n.data.get(a.dataId).values,o=n.data.get(s.dataId).values,c=n.data.get(r.dataId).values,[l,u]=ej(i,a.shape,a.dtype,o,c);return n.makeTensorInfo(u,a.dtype,l)}};const aj={kernelName:Gp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{sparseIndices:s,sparseValues:r,defaultValue:i}=t,{outputShape:o}=a,{sliceRank:c,numUpdates:l,sliceSize:u,strides:h,outputSize:d}=fk(0,s,o),p=!1,f=n.bufferSync(s);let m;switch(r.dtype){case"bool":m=_B(f,n.bufferSync(r),o,d,u,l,c,h,Boolean(n.data.get(i.dataId).values[0]),p);break;case"float32":m=_B(f,n.bufferSync(r),o,d,u,l,c,h,n.data.get(i.dataId).values[0],p);break;case"int32":m=_B(f,n.bufferSync(r),o,d,u,l,c,h,n.data.get(i.dataId).values[0],p);break;case"string":m=_B(f,n.bufferSync(r),o,d,u,l,c,h,qf(n.data.get(i.dataId).values[0]),p);break;default:throw new Error("Unsupported type ".concat(r.dtype))}return n.makeTensorInfo(o,m.dtype,m.values)}};const sj={kernelName:Bp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{numOrSizeSplits:r,axis:i}=a,o=Ru(i,s.shape)[0],c=jC(s,r,o),l=new Array(s.shape.length).fill(0),u=s.shape.slice();return c.map(e=>{const t=[...u];t[o]=e;const a=FO({inputs:{x:s},backend:n,attrs:{begin:l,size:t}});return l[o]+=e,a})}},rj=gD(e=>Math.sqrt(e)),ij=yD(Fp,e=>Math.sqrt(e)),oj={kernelName:Fp,backendName:"cpu",kernelFunc:ij},cj={kernelName:Kp,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n}=e;const{x:a}=t,s=n;pD(a,"square");const r=s.data.get(a.dataId).values,i=new Float32Array(r.length);for(let o=0;o<r.length;++o){const e=r[o];i[o]=e*e}return{dataId:s.write(i,a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}},lj=ID((e,t)=>{const n=e-t;return n*n}),uj=GD(qp,lj),hj={kernelName:qp,backendName:"cpu",kernelFunc:uj},dj=gD((e,t)=>{const{pattern:n,replaceGlobal:a,rewrite:s}=t;return e.replace(new RegExp(n,a?"g":""),s)}),pj=bD(Xp,dj),fj={kernelName:Xp,backendName:"cpu",kernelFunc:pj},mj=yD(hf,(e,t)=>{const n=t;return isNaN(e)?NaN:e>0?1:n.alpha}),gj={kernelName:hf,backendName:"cpu",kernelFunc:mj};function yj(e,t,n,a){const s=ny(e,t.dtype);for(let r=0;r<s.size;r++){const e=s.indexToLoc(r),i=new Array(e.length);for(let t=0;t<i.length;t++)i[t]=e[t]*n[t]+a[t];s.set(t.get(...i),...e)}return s}const bj={kernelName:Yp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{begin:r,end:i,strides:o,beginMask:c,endMask:l,ellipsisMask:u,newAxisMask:h,shrinkAxisMask:d}=a;pD(s,"stridedSlice");const{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:x,strides:v}=Tb(s.shape,r,i,o,c,l,u,h,d);let w;if(m)w=ZD({inputs:{x:s},backend:n,attrs:{shape:f}});else if(g||y){bu(s.shape.length>=1,()=>"Input must have rank at least 1, got: ".concat(s.shape.length));const e=fb(b,x,v),t=FO({inputs:{x:s},backend:n,attrs:{begin:b,size:e}});w=ZD({inputs:{x:t},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(t)}else{const e=yj(p,n.bufferSync(s),v,b);w=n.makeTensorInfo(f,e.dtype,e.values)}return w}};class xj{constructor(e,t,n,a,s,r){this.separator=Gf(e),this.nGramWidths=t,this.leftPad=Gf(n),this.rightPad=Gf(a),this.padWidth=s,this.preserveShort=r}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,a,s,r){for(let i=0;i<s;++i){const o=this.getPadWidth(r),c=Math.max(0,o-i),l=Math.max(0,o-(s-(i+1))),u=r-(c+l),h=t+(c>0?0:i-o);let d=0;d+=c*this.leftPad.length;for(let t=0;t<u;++t)d+=e[h+t].length;d+=l*this.rightPad.length;d+=(c+l+u-1)*this.separator.length,n[a+i]=new Uint8Array(d);const p=n[a+i];let f=0;const m=e=>e.forEach(e=>p[f++]=e);for(let e=0;e<c;++e)m(this.leftPad),m(this.separator);for(let t=0;t<u-1;++t)m(e[h+t]),m(this.separator);if(u>0){m(e[h+u-1]);for(let e=0;e<l;++e)m(this.separator),m(this.rightPad)}else{for(let e=0;e<l-1;++e)m(this.rightPad),m(this.separator);m(this.rightPad)}}}compute(e,t){const n=e.length,a=t.length;if(a>0){let e=t[0];if(0!==e)throw new Error("First split value must be 0, got ".concat(e));for(let s=1;s<a;++s){let a=t[s]>=e;if(a=a&&t[s]<=n,!a)throw new Error("Invalid split value ".concat(t[s],", must be in [").concat(e,", ").concat(n,"]"));e=t[s]}if(e!==n)throw new Error("Last split value must be data size. Expected ".concat(n,", got ").concat(e))}const s=a-1,r=Mu("int32",a);if(0===n||0===a){const e=new Array(n);for(let t=0;t<=s;++t)r[t]=0;return[e,r]}r[0]=0;for(let o=1;o<=s;++o){const e=t[o]-t[o-1];let n=0;this.nGramWidths.forEach(t=>{n+=this.getNumNGrams(e,t)}),this.preserveShort&&e>0&&0===n&&(n=1),r[o]=r[o-1]+n}const i=new Array(r[s]);for(let o=0;o<s;++o){const n=t[o];let a=r[o];if(this.nGramWidths.forEach(s=>{const r=t[o+1]-t[o],c=this.getNumNGrams(r,s);this.createNGrams(e,n,i,a,c,s),a+=c}),this.preserveShort&&a===r[o]){const s=t[o+1]-t[o];if(0===s)continue;const r=s+2*this.padWidth,c=1;this.createNGrams(e,n,i,a,c,r)}}return[i,r]}}function vj(e,t,n,a,s,r,i,o){return new xj(n,a,s,r,i,o).compute(e,t)}const wj={kernelName:Qp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{separator:s,nGramWidths:r,leftPad:i,rightPad:o,padWidth:c,preserveShortSequences:l}=a,{data:u,dataSplits:h}=t,d=n.data.get(u.dataId).values,p=n.data.get(h.dataId).values,[f,m]=vj(d,p,s,r,i,o,c,l);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(h.shape,"int32",m)]}};function kj(e,t,n,a){if(!e.length)return;if(0===t.length){for(let t=0;t<e.length;++t)a.push(e.subarray(t,t+1));return}if(1===t.length){const s=t[0];let r=e.indexOf(s);for(;-1!==r;){const t=e.subarray(0,r);n&&0===t.length||a.push(t),r=(e=e.subarray(r+1)).indexOf(s)}return void(n&&0===e.length||a.push(e))}let s=0;for(let r=0;r<e.length+1;r++)if(r===e.length||-1!==t.indexOf(e[r])){const t=e.subarray(s,r);n&&0===t.length||a.push(t),s=r+1}}function Sj(e,t,n){const a=e.length,s=[];let r=0,i=0;const o=new Array(a);for(let d=0;d<a;++d){const a=s.length;kj(e[d],t,n,s);const c=s.length-a;o[d]=c,r+=c,i=Math.max(i,c)}const c=Mu("int32",2*r),l=new Array(r),u=[a,i];let h=0;for(let d=0;d<a;++d)for(let e=0;e<o[d];++e)c[2*h]=d,c[2*h+1]=e,l[h]=s[h],++h;return[c,l,u]}const Cj={kernelName:Zp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{skipEmpty:s}=a,{input:r,delimiter:i}=t;if("string"!==r.dtype)throw new Error("Input must be of datatype string");if(1!==r.shape.length)throw new Error("Input must be a vector, got shape: ".concat(r.shape));if(0!==i.shape.length)throw new Error("Delimiter must be a scalar, got shape: ".concat(i.shape));const o=n.data.get(r.dataId).values,c=n.data.get(i.dataId).values[0],[l,u,h]=Sj(o,c,s),d=u.length;return[n.makeTensorInfo([d,2],"int32",l),n.makeTensorInfo([d],"string",u),n.makeTensorInfo([2],"int32",new Int32Array(h))]}};function Ij(e,t){const n=Mu("int32",e.length);for(let a=0;a<e.length;++a)n[a]=Wf(e[a]).modulo(t).getLowBitsUnsigned();return n}const Nj={kernelName:Jp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{numBuckets:s}=a,{input:r}=t;if("string"!==r.dtype)throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const i=Ij(n.data.get(r.dataId).values,s);return n.makeTensorInfo(r.shape,"int32",i)}},Tj=yD(ef,e=>Math.tan(e)),Ej={kernelName:ef,backendName:"cpu",kernelFunc:Tj},Rj=yD(tf,e=>Math.tanh(e));const _j={kernelName:Np,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{tensor:a,indices:s,updates:r}=t,{sliceRank:i,numUpdates:o,sliceSize:c,strides:l,outputSize:u}=fk(0,s,a.shape),h=n.bufferSync(s),d=n.bufferSync(r),p=n.bufferSync(a),f=_B(h,d,a.shape,u,c,o,i,l,p,!1);return n.makeTensorInfo(a.shape,f.dtype,f.values)}};function Aj(e,t){const n=new Array(e.rank);for(let s=0;s<n.length;s++)n[s]=e.shape[s]*t[s];const a=ny(n,e.dtype);for(let s=0;s<a.values.length;++s){const t=a.indexToLoc(s),n=new Array(e.rank);for(let a=0;a<n.length;a++)n[a]=t[a]%e.shape[a];const r=e.locToIndex(n);a.values[s]=e.values[r]}return a}const Mj={kernelName:nf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{reps:r}=a;pD(s,"tile");const i=Aj(n.bufferSync(s),r);return n.makeTensorInfo(i.shape,i.dtype,i.values)}},Pj=(e,t)=>{const n=t.value-e.value;return 0===n?e.index-t.index:n};function Dj(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:e.length-1;for(;a>n;){if(a-n>600){const s=a-n+1,r=t-n+1,i=Math.log(s),o=.5*Math.exp(2*i/3),c=.5*Math.sqrt(i*o*(s-o)/s)*Math.sign(r-s/2);Dj(e,t,Math.max(n,Math.floor(t-r*o/s+c)),Math.min(a,Math.floor(t+(s-r)*o/s+c)))}const s=e[t];let r=n,i=a;for(gu(e,n,t),Pj(e[a],s)>0&&gu(e,n,a);r<i;){for(gu(e,r,i),r++,i--;Pj(e[r],s)<0;)r+=1;for(;Pj(e[i],s)>0;)i-=1}0===Pj(e[n],s)?gu(e,n,i):(i+=1,gu(e,i,a)),i<=t&&(n=i+1),t<=i&&(a=i-1)}}function Oj(e,t,n,a,s){const r=t[t.length-1],[i,o]=[e.length/r,r],c=Au(n,i*a),l=Au("int32",i*a);for(let h=0;h<i;h++){const t=h*o,n=e.subarray(t,t+o);let r=new Array(n.length);n.forEach((e,t)=>r[t]={value:e,index:t}),a<r.length&&(Dj(r,a),r=r.slice(0,a)),s&&r.sort(Pj);const i=h*a,u=c.subarray(i,i+a),d=l.subarray(i,i+a);for(let e=0;e<a;e++)u[e]=r[e].value,d[e]=r[e].index}const u=t.slice();return u[u.length-1]=a,[ny(u,n,c),ny(u,"int32",l)]}const Fj={kernelName:af,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{k:r,sorted:i}=a;pD(s,"topk");const o=n.data.get(s.dataId).values,[c,l]=Oj(o,s.shape,s.dtype,r,i);return[n.makeTensorInfo(c.shape,c.dtype,c.values),n.makeTensorInfo(l.shape,l.dtype,l.values)]}};const Lj={kernelName:sf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:a}=e,{image:s,transforms:r}=t,{interpolation:i,fillMode:o,fillValue:c,outputShape:l}=n,[u,h,d,p]=s.shape,[f,m]=null!=l?l:[h,d],g=[u,f,m,p],y=ju(s.shape),b=y[0],x=y[1],v=y[2],w=ju(g),k=w[0],S=w[1],C=w[2],I=Au(s.dtype,wu(g));I.fill(c);const N=a.data.get(s.dataId).values,T=a.data.get(r.dataId).values;for(let E=0;E<u;++E){const e=1===r.shape[0]?T:T.subarray(8*E,8*E+8);for(let t=0;t<f;++t)for(let n=0;n<m;++n)for(let a=0;a<p;++a){let s;const r=e[6]*n+e[7]*t+1;if(0===r)continue;const l=(e[0]*n+e[1]*t+e[2])/r,u=(e[3]*n+e[4]*t+e[5])/r,p=zj(l,d,o),f=zj(u,h,o);switch(i){case"nearest":s=jj(N,h,d,b,x,v,E,f,p,a,c);break;case"bilinear":s=Wj(N,h,d,b,x,v,E,f,p,a,c);break;default:throw new Error("Error in Transform: Expect 'nearest' or "+"'bilinear', but got ".concat(i))}I[E*k+t*S+n*C+a]=s}return a.makeTensorInfo(g,s.dtype,I)}return{dataId:a.write(I,g,s.dtype),shape:s.shape,dtype:s.dtype}}};function zj(e,t,n){switch(n){case"reflect":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=2*t;n<e&&(n=e*Math.trunc(-n/e)+n),n=n<-t?n+e:-n-1}else if(n>t-1)if(t<=1)n=0;else{const e=2*t;n-=e*Math.trunc(n/e),n>=t&&(n=e-n-1)}return fu(0,n,t-1)}(e,t);case"wrap":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=t-1;n+=t*(Math.trunc(-n/e)+1)}else if(n>t-1)if(t<=1)n=0;else{const e=t-1;n-=t*Math.trunc(n/e)}return fu(0,n,t-1)}(e,t);case"nearest":return function(e,t){return fu(0,e,t-1)}(e,t);default:return function(e){return e}(e)}}function Bj(e,t,n,a,s,r,i,o,c,l,u){return 0<=o&&o<t&&0<=c&&c<n?e[i*a+o*s+c*r+l]:u}function jj(e,t,n,a,s,r,i,o,c,l,u){return Bj(e,t,n,a,s,r,i,Math.round(o),Math.round(c),l,u)}function Wj(e,t,n,a,s,r,i,o,c,l,u){const h=Math.floor(o),d=Math.floor(c),p=h+1,f=d+1;return(p-o)*((f-c)*Bj(e,t,n,a,s,r,i,h,d,l,u)+(c-d)*Bj(e,t,n,a,s,r,i,h,f,l,u))+(o-h)*((f-c)*Bj(e,t,n,a,s,r,i,p,d,l,u)+(c-d)*Bj(e,t,n,a,s,r,i,p,f,l,u))}function Vj(e,t,n,a){const s=Ru(t,n)[0],r=[1,n[0],1];for(let f=0;f<s;f++)r[0]*=n[f];r[1]=n[s];for(let f=s+1;f<n.length;f++)r[2]*=n[f];const i=new Map,o=new Int32Array(n[s]),c=new am(r,a,e),l=[],u=1===r[0]&&1===r[2];for(let f=0;f<n[s];f++){let t;if(u)t=e[f].toString();else{const e=[];for(let t=0;t<r[0];t++)for(let n=0;n<r[2];n++)e.push(c.get(t,f,n));t=e.join(",")}const n=i.get(t);if(null!=n)o[f]=n;else{const e=i.size;i.set(t,e),o[f]=e,l.push(f)}}const h=r.slice();h[1]=i.size;const d=new am(h,a);l.forEach((e,t)=>{for(let n=0;n<r[0];n++)for(let a=0;a<r[2];a++)d.set(c.get(n,e,a),n,t,a)});const p=n.slice();return p[s]=h[1],{outputValues:d.values,outputShape:p,indices:o}}const Uj={kernelName:of,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:a}=e,{axis:s}=n,{x:r}=t;pD(r,"unique");const i=a.data.get(r.dataId).values,{outputValues:o,outputShape:c,indices:l}=Vj(i,s,r.shape,r.dtype);return[a.makeTensorInfo(c,r.dtype,o),a.makeTensorInfo([l.length],"int32",l)]}};const Hj={kernelName:cf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{value:s}=t;let{axis:r}=a;r<0&&(r+=s.shape.length);const i=s.shape.length,o=s.shape[r],c=new Array(i-1);let l=0;for(let p=0;p<i;p++)p!==r&&(c[l++]=s.shape[p]);const u=new Array(i).fill(0),h=s.shape.slice();h[r]=1;const d=new Array(o);for(let p=0;p<d.length;p++){u[r]=p;const e=FO({inputs:{x:s},backend:n,attrs:{begin:u,size:h}});d[p]=ZD({inputs:{x:e},backend:n,attrs:{shape:c}}),n.disposeIntermediateTensorInfo(e)}return d}};const Gj={kernelName:lf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,segmentIds:r}=t,{numSegments:i}=a;pD(s,"unsortedSegmentSum");const o=[],c=[],l=s.shape.length-r.shape.length;let u=r;for(let d=0;d<l;++d){const e=QF({inputs:{input:u},backend:n,attrs:{dim:d+1}});u=e,c.push(e)}for(let d=0;d<i;++d){const e=Vf(d,"int32"),t=n.makeTensorInfo([],"int32",e),a=LF({inputs:{a:t,b:u},backend:n}),r=UD({inputs:{x:a},backend:n,attrs:{dtype:"float32"}}),i=_F({inputs:{a:r,b:s},backend:n}),l=MF({inputs:{x:i},backend:n,attrs:{axis:0,keepDims:!1}});o.push(l),c.push(t),c.push(a),c.push(r),c.push(i),c.push(l)}const h=Kz({inputs:o,backend:n,attrs:{axis:0}});return c.forEach(e=>n.disposeIntermediateTensorInfo(e)),h}},qj=[tO,aO,rO,oO,QD,cO,dO,pO,fO,mO,yO,xO,wO,CO,NO,_O,AO,MO,PO,eO,DO,zO,WO,HO,GO,HD,XO,QO,zD,ZO,nF,sF,rF,iF,oF,cF,lF,hF,pF,fF,mF,gF,yF,bF,vF,wF,kF,SF,CF,IF,NF,TF,DF,vD,OF,zF,qF,YF,ZF,eL,hL,pL,fL,yL,vL,wL,kL,CL,NL,RL,ML,kD,PL,eF,OL,LL,BL,CD,VL,GL,KL,QL,JL,tz,az,iz,oz,cz,hz,fz,mz,gz,yz,bz,xz,vz,wz,Cz,Iz,Ez,Az,AF,Pz,Oz,Lz,Bz,Vz,Uz,qz,Xz,Yz,Jz,ED,eB,rB,cB,fB,gB,WD,aL,bB,_D,MD,JD,xB,vB,wB,kB,SB,CB,NB,RB,AB,DB,OB,BB,OD,WB,UB,GB,LO,_z,XB,YB,ZB,$B,tj,nj,aj,sj,oj,cj,hj,fj,gj,bj,wj,Cj,Nj,oL,PF,Ej,{kernelName:tf,backendName:"cpu",kernelFunc:Rj},_j,Mj,Fj,Lj,hO,Uj,Hj,Gj,Gz];for(const n of qj)Cf(n);const Kj={},Xj={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function Yj(e,t){if(!(e in Kj)||null!=t){const n=function(e,t){if(1!==e&&2!==e)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const n=null==t?function(e){if(eh().getBool("IS_SAFARI")||"undefined"===typeof OffscreenCanvas||2!==e){if("undefined"!==typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}return new OffscreenCanvas(300,150)}(e):t;n.addEventListener("webglcontextlost",t=>{t.preventDefault(),delete Kj[e]},!1),eh().getBool("SOFTWARE_WEBGL_ENABLED")&&(Xj.failIfMajorPerformanceCaveat=!1);if(1===e)return n.getContext("webgl",Xj)||n.getContext("experimental-webgl",Xj);return n.getContext("webgl2",Xj)}(e,t);if(null===n)return console.log("Could not get context for WebGL version",e),null;Kj[e]=n}const n=Kj[e];return null==n||n.isContextLost()?(delete Kj[e],Yj(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),Kj[e])}var Qj,Zj,Jj;function $j(e,t){return[t,e]}function eW(e){const t=wu(e);return Iu(Math.ceil(t/4))}function tW(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function nW(e,t){const n=e;let a,s,r,i,o,c,l,u,h,d;return 2===eh().getNumber("WEBGL_VERSION")?(a=n.R32F,s=n.R16F,r=n.RGBA16F,i=n.RGBA32F,o=n.RED,l=4,u=1,h=n.HALF_FLOAT,d=n.FLOAT,c=n.RGBA8):(a=e.RGBA,s=e.RGBA,r=e.RGBA,i=n.RGBA,o=e.RGBA,l=4,u=4,h=null!=t?t.HALF_FLOAT_OES:null,d=e.FLOAT,c=e.RGBA),{internalFormatFloat:a,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:r,internalFormatPackedFloat:i,textureFormatFloat:o,downloadTextureFormat:c,downloadUnpackNumChannels:l,defaultNumChannels:u,textureTypeHalfFloat:h,textureTypeFloat:d}}function aW(e,t){const n=t();return eh().getBool("DEBUG")&&function(e){const t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+function(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return"Unknown error code ".concat(t)}}(e,t))}(e),n}!function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"}(Qj||(Qj={})),function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"}(Zj||(Zj={})),function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(Jj||(Jj={}));function sW(e){return!!(eh().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||5.96e-8<Math.abs(e)&&Math.abs(e)<65504)}function rW(e,t){return fW(e,()=>e.getExtension(t),'Extension "'+t+'" not supported on this browser.')}const iW=/ERROR: [0-9]+:([0-9]+):/g;function oW(e,t){const n=iW.exec(t);if(null==n)return console.log("Couldn't parse line number in error: ".concat(t)),void console.log(e);const a=+n[1],s=e.split("\n"),r=s.length.toString().length+2,i=s.map((e,t)=>Nu((t+1).toString(),r)+e);let o=0;for(let h=0;h<i.length;h++)o=Math.max(i[h].length,o);const c=i.slice(0,a-1),l=i.slice(a-1,a),u=i.slice(a);console.log(c.join("\n")),console.log(t.split("\n")[0]),console.log("%c ".concat(Nu(l[0],o)),"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(u.join("\n"))}function cW(e,t){if(aW(e,()=>e.validateProgram(t)),!1===e.getProgramParameter(t,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function lW(e,t,n,a,s,r,i){const o=e.getAttribLocation(t,n);return-1!==o&&(aW(e,()=>e.bindBuffer(e.ARRAY_BUFFER,a)),aW(e,()=>e.vertexAttribPointer(o,s,e.FLOAT,!1,r,i)),aW(e,()=>e.enableVertexAttribArray(o)),!0)}function uW(e,t,n,a){aW(e,()=>function(e,t,n){mW(e,n),aW(e,()=>e.activeTexture(e.TEXTURE0+n)),aW(e,()=>e.bindTexture(e.TEXTURE_2D,t))}(e,t,a)),aW(e,()=>e.uniform1i(n,a))}function hW(e,t,n){aW(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,n)),aW(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0))}function dW(e,t){aW(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,t)),aW(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0))}function pW(e){const t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return"unknown error ".concat(t)}}(e,t))}function fW(e,t,n){const a=aW(e,()=>t());if(null==a)throw new Error(n);return a}function mW(e,t){const n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,a=t+e.TEXTURE0;if(a<e.TEXTURE0||a>n){const e="[gl.TEXTURE0, gl.TEXTURE".concat(n,"]");throw new Error("textureUnit must be in ".concat(e,"."))}}function gW(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:2;return wu(e.slice(0,e.length-t))}function yW(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function bW(e){let t=[1,1,1];return 0===e.length||1===e.length&&1===e[0]||(t=[gW(e),...yW(e)]),t}function xW(e){return e%2===0}function vW(e,t){if(Su(e=e.slice(-2),t=t.slice(-2)))return!0;if(!e.length||!t.length)return!0;if(0===e[0]||0===e[1]||0===t[0]||0===t[1])return!0;if(e.length!==t.length){const n=e[e.length-1],a=t[t.length-1];if(n===a)return!0;if(xW(n)&&xW(a)&&(1===e[0]||1===t[0]))return!0}return e[1]===t[1]&&xW(e[0])&&xW(t[0])}let wW,kW;function SW(e,t){return null!=e.getExtension(t)}function CW(e){try{if(null!=Yj(e))return!0}catch(q5){return console.log("Error when getting WebGL context: ",q5),!1}return!1}function IW(e){if(0===e)return!1;const t=Yj(e);if(1!==e){if(SW(t,"EXT_color_buffer_float"))return NW(t);const e="EXT_color_buffer_half_float";if(SW(t,e)){const n=t.getExtension(e);return function(e,t){const n=nW(e,t),a=e.createTexture();e.bindTexture(e.TEXTURE_2D,a);const s=1,r=1;e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,s,r,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const i=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,i),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,a,0);const o=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(a),e.deleteFramebuffer(i),o}(t,n)}return!1}if(!SW(t,"OES_texture_float"))return!1;if(!SW(t,"WEBGL_color_buffer_float"))return!1;return NW(t)}function NW(e){const t=nW(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n);e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const a=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,a),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);const s=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(a),s}function TW(e,t){Array.isArray(e)||(e=[e]),e.forEach(e=>{null!=e&&bu("complex64"!==e.dtype,()=>"".concat(t," does not support complex64 tensors ")+"in the WebGL backend.")})}const EW=eh();function RW(){let e,t,n,a,s,r,i,o,c,l;return 2===eh().getNumber("WEBGL_VERSION")?(e="#version 300 es",t="in",n="out",a="in",s="texture",r="outputColor",i="out vec4 outputColor;",o=eh().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",c="",l="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(e="",t="attribute",n="varying",a="varying",s="texture2D",r="gl_FragColor",i="",o="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",c="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",l="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:e,attribute:t,varyingVs:n,varyingFs:a,texture2D:s,output:r,defineOutput:i,defineSpecialNaN:o,defineSpecialInf:c,defineRound:l}}function _W(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index";const a=ju(t);return a.map((t,s)=>{const r="int ".concat(e[s]," = ").concat(n," / ").concat(t),i=s===a.length-1?"int ".concat(e[s+1]," = ").concat(n," - ").concat(e[s]," * ").concat(t):"index -= ".concat(e[s]," * ").concat(t);return"".concat(r,"; ").concat(i,";")}).join("")}function AW(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index";const a=ju(t);return a.map((t,s)=>{const r="int ".concat(e[s]," = ").concat(n," / outShapeStrides[").concat(s,"]"),i=s===a.length-1?"int ".concat(e[s+1]," = ").concat(n," - ").concat(e[s]," * outShapeStrides[").concat(s,"]"):"index -= ".concat(e[s]," * outShapeStrides[").concat(s,"]");return"".concat(r,"; ").concat(i,";")}).join("")}function MW(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index";const a=function(e,t){const n=e.length,a=e.map(e=>"".concat(t,"[").concat(e,"]")),s=new Array(n-1);s[n-2]=a[n-1];for(let r=n-3;r>=0;--r)s[r]="(".concat(s[r+1]," * ").concat(a[r+1],")");return s}(e.map((e,t)=>t),t);return a.map((t,s)=>{const r="int ".concat(e[s]," = ").concat(n," / ").concat(a[s]),i=s===a.length-1?"int ".concat(e[s+1]," = ").concat(n," - ").concat(e[s]," * ").concat(a[s]):"index -= ".concat(e[s]," * ").concat(a[s]);return"".concat(r,"; ").concat(i,";")}).join("")}function PW(e){const t=ju(e).map(e=>e.toString());return"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ".concat(t[0]," + coords.y * ").concat(t[1]," + coords.z;\n  }\n")}EW.registerFlag("HAS_WEBGL",()=>EW.getNumber("WEBGL_VERSION")>0),EW.registerFlag("WEBGL_VERSION",()=>CW(2)?2:CW(1)?1:0),EW.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1),EW.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>2===EW.get("WEBGL_VERSION")),EW.registerFlag("WEBGL_CPU_FORWARD",()=>!0),EW.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),EW.registerFlag("WEBGL_PACK",()=>EW.getBool("HAS_WEBGL")),EW.registerFlag("WEBGL_PACK_NORMALIZATION",()=>EW.getBool("WEBGL_PACK")),EW.registerFlag("WEBGL_PACK_CLIP",()=>EW.getBool("WEBGL_PACK")),EW.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>EW.getBool("WEBGL_PACK")),EW.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>EW.getBool("WEBGL_PACK")),EW.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>EW.getBool("WEBGL_PACK")),EW.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>EW.getBool("WEBGL_PACK")),EW.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>EW.getBool("WEBGL_PACK")),EW.registerFlag("WEBGL_PACK_REDUCE",()=>EW.getBool("WEBGL_PACK")),EW.registerFlag("WEBGL_LAZILY_UNPACK",()=>EW.getBool("WEBGL_PACK")),EW.registerFlag("WEBGL_CONV_IM2COL",()=>EW.getBool("WEBGL_PACK")),EW.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>EW.getBool("WEBGL_PACK")),EW.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>function(e){if(null==wW){const t=Yj(e);wW=t.getParameter(t.MAX_TEXTURE_SIZE)}return wW}(EW.getNumber("WEBGL_VERSION"))),EW.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>function(e){if(null==kW){const t=Yj(e);kW=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,kW)}(EW.getNumber("WEBGL_VERSION"))),EW.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const e=EW.getNumber("WEBGL_VERSION");return 0===e?0:function(e){if(0===e)return 0;let t;const n=Yj(e);return t=SW(n,"EXT_disjoint_timer_query_webgl2")&&2===e?2:SW(n,"EXT_disjoint_timer_query")?1:0,t}(e)}),EW.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>EW.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!Am()),EW.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>function(e){if(0===e)return!1;const t=Yj(e);if(1===e){if(!SW(t,"OES_texture_float"))return!1}else if(!SW(t,"EXT_color_buffer_float"))return!1;return NW(t)}(EW.getNumber("WEBGL_VERSION"))),EW.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>!EW.getBool("WEBGL_FORCE_F16_TEXTURES")&&EW.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),EW.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>IW(EW.getNumber("WEBGL_VERSION"))),EW.registerFlag("WEBGL_FENCE_API_ENABLED",()=>{return 2===(e=EW.getNumber("WEBGL_VERSION"))&&null!=Yj(e).fenceSync;var e}),EW.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>EW.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0),EW.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,e=>{if("number"!==typeof e)throw new Error("WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but "+"got ".concat(e,"."));if(e<0&&-1!==e)throw new Error("WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never "+"delete) or at least 0, but got ".concat(e,"."))}),EW.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>Am()?1:-1,e=>{if("number"!==typeof e)throw new Error("WEBGL_FLUSH_THRESHOLD must be a number but got "+"".concat(e,"."));if(e<0&&-1!==e)throw new Error("WEBGL_FLUSH_THRESHOLD must be -1 (indicating never "+"manual flush) or at least 0, but got ".concat(e,"."))}),EW.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128),EW.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1),EW.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5),EW.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128),EW.registerFlag("WEBGL_EXP_CONV",()=>!1),EW.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>EW.getBool("IS_TEST")),EW.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0),EW.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1),EW.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1),EW.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);const DW="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:OW}=r;function FW(e,t,n){const a=[];if(e.forEach(e=>{const t=wu(e.shapeInfo.logicalShape);if(e.shapeInfo.isUniform?a.push("uniform float ".concat(e.name).concat(t>1?"[".concat(t,"]"):"",";")):(a.push("uniform sampler2D ".concat(e.name,";")),a.push("uniform int offset".concat(e.name,";"))),n.enableShapeUniforms){const{uniformShape:t}=qW(n.packedInputs,e.shapeInfo.logicalShape,e.shapeInfo.texShape);switch(t.length){case 1:a.push("uniform int ".concat(e.name,"Shape;"));break;case 2:a.push("uniform ivec2 ".concat(e.name,"Shape;"));break;case 3:a.push("uniform ivec3 ".concat(e.name,"Shape;"));break;case 4:a.push("uniform ivec4 ".concat(e.name,"Shape;"))}a.push("uniform ivec2 ".concat(e.name,"TexShape;"))}}),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:a.push("uniform int outShape;");break;case 2:a.push("uniform ivec2 outShape;"),a.push("uniform int outShapeStrides;");break;case 3:a.push("uniform ivec3 outShape;"),a.push("uniform ivec2 outShapeStrides;");break;case 4:a.push("uniform ivec4 outShape;"),a.push("uniform ivec3 outShapeStrides;")}a.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach(e=>{a.push("uniform ".concat(e.type," ").concat(e.name).concat(e.arrayIndex?"[".concat(e.arrayIndex,"]"):"",";"))});const s=a.join("\n"),r=e.map(e=>function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3?arguments[3]:void 0,s="";s+=n?zW(e,a):LW(e,a);const r=e.shapeInfo.logicalShape,i=t.logicalShape;r.length<=i.length&&(s+=n?function(e,t){const n=e.name,a=n.charAt(0).toUpperCase()+n.slice(1),s="get"+a+"AtOutCoords",r=e.shapeInfo.logicalShape.length,i=t.logicalShape.length,o=OW(e.shapeInfo.logicalShape,t.logicalShape),c=GW(i),l=i-r;let u;const h=["x","y","z","w","u","v"];u=0===r?"":i<2&&o.length>=1?"coords = 0;":o.map(e=>"coords.".concat(h[e+l]," = 0;")).join("\n");let d="";d=i<2&&r>0?"coords":e.shapeInfo.logicalShape.map((e,t)=>"coords.".concat(h[t+l])).join(", ");let p="return outputValue;";const f=1===wu(e.shapeInfo.logicalShape),m=wu(t.logicalShape),g=1===m;if(1!==r||f||g){if(f&&!g)p=1===i?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(o.length){const e=r-2,t=r-1;o.indexOf(e)>-1&&o.indexOf(t)>-1?p="return vec4(outputValue.x);":o.indexOf(e)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":o.indexOf(t)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}}else p="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return"\n    vec4 ".concat(s,"() {\n      ").concat(c," coords = getOutputCoords();\n      ").concat(u,"\n      vec4 outputValue = get").concat(a,"(").concat(d,");\n      ").concat(p,"\n    }\n  ")}(e,t):function(e,t){const n=e.name,a=n.charAt(0).toUpperCase()+n.slice(1),s="get"+a+"AtOutCoords",r=t.texShape,i=e.shapeInfo.texShape,o=e.shapeInfo.logicalShape.length,c=t.logicalShape.length;if(!e.shapeInfo.isUniform&&o===c&&null==e.shapeInfo.flatOffset&&Su(i,r))return"\n      float ".concat(s,"() {\n        return sampleTexture(").concat(n,", resultUV);\n      }\n    ");const l=GW(c),u=OW(e.shapeInfo.logicalShape,t.logicalShape),h=c-o;let d;const p=["x","y","z","w","u","v"];d=0===o?"":c<2&&u.length>=1?"coords = 0;":u.map(e=>"coords.".concat(p[e+h]," = 0;")).join("\n");let f="";f=c<2&&o>0?"coords":e.shapeInfo.logicalShape.map((e,t)=>"coords.".concat(p[t+h])).join(", ");return"\n    float ".concat(s,"() {\n      ").concat(l," coords = getOutputCoords();\n      ").concat(d,"\n      return get").concat(a,"(").concat(f,");\n    }\n  ")}(e,t));return s}(e,t,n.packedInputs,n.enableShapeUniforms)).join("\n"),i=t.texShape,o=RW(),c=function(e){return"\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ".concat(e.texture2D,"(textureSampler, uv).r;\n    }\n  ")}(o);let l,u,h=function(e){const t="".concat(e.version,"\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ").concat(e.varyingFs," vec2 resultUV;\n    ").concat(e.defineOutput,"\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ").concat(e.defineSpecialNaN,"\n    ").concat(e.defineSpecialInf,"\n    ").concat(e.defineRound,"\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ").concat(BW,"\n    ").concat(jW,"\n    ").concat(WW,"\n  ");return t}(o);t.isPacked?(l=function(e,t,n){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(e,t,n){const a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(1===a[0])return n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ".concat(a[1],".0);\n      }\n    ");if(1===a[1])return n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ".concat(a[0],".0);\n      }\n    ");if(n)return"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ";return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(a[0],", ").concat(a[1],"));\n      return 2 * (resTexRC.x * ").concat(a[1]," + resTexRC.y);\n    }\n  ")}(0,t,n);case 2:return function(e,t,n){const a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(Su(e,t))return n?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(".concat(a[0],", ").concat(a[1],"));\n      }\n    ");const s=Math.ceil(e[1]/2);if(n)return"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ";return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(a[0],", ").concat(a[1],"));\n\n      int index = resTexRC.x * ").concat(a[1]," + resTexRC.y;\n      int r = 2 * (index / ").concat(s,");\n      int c = imod(index, ").concat(s,") * 2;\n\n      return ivec2(r, c);\n    }\n  ")}(e,t,n);case 3:return function(e,t,n){if(n)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(e[2]/2),r=s*Math.ceil(e[1]/2);return"\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(a[0],", ").concat(a[1],"));\n      int index = resTexRC.x * ").concat(a[1]," + resTexRC.y;\n\n      int b = index / ").concat(r,";\n      index -= b * ").concat(r,";\n\n      int r = 2 * (index / ").concat(s,");\n      int c = imod(index, ").concat(s,") * 2;\n\n      return ivec3(b, r, c);\n    }\n  ")}(e,t,n);default:return function(e,t,n){if(n)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(e[e.length-1]/2),r=s*Math.ceil(e[e.length-2]/2);let i=r,o="",c="b, r, c";for(let l=2;l<e.length-1;l++)i*=e[e.length-l-1],o="\n      int b".concat(l," = index / ").concat(i,";\n      index -= b").concat(l," * ").concat(i,";\n    ")+o,c="b".concat(l,", ")+c;return"\n    ivec".concat(e.length," getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(").concat(a[0],", ").concat(a[1],"));\n      int index = resTexRC.x * ").concat(a[1]," + resTexRC.y;\n\n      ").concat(o,"\n\n      int b = index / ").concat(r,";\n      index -= b * ").concat(r,";\n\n      int r = 2 * (index / ").concat(s,");\n      int c = imod(index, ").concat(s,") * 2;\n\n      return ivec").concat(e.length,"(").concat(c,");\n    }\n  ")}(e,t,n)}}(t.logicalShape,i,n.enableShapeUniforms),u=function(e){return"\n    void setOutput(vec4 val) {\n      ".concat(e.output," = val;\n    }\n  ")}(o)):(l=function(e,t,n){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(e,t,n){if(1===t[0])return n?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":"\n      int getOutputCoords() {\n        return int(resultUV.x * ".concat(t[1],".0);\n      }\n    ");if(1===t[1])return n?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":"\n      int getOutputCoords() {\n        return int(resultUV.y * ".concat(t[0],".0);\n      }\n    ");if(n)return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ";return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(t[0],", ").concat(t[1],"));\n      return resTexRC.x * ").concat(t[1]," + resTexRC.y;\n    }\n  ")}(0,t,n);case 2:return function(e,t,n){if(Su(e,t))return n?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(".concat(t[0],", ").concat(t[1],"));\n      }\n    ");if(1===e[1])return n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(".concat(t[0],", ").concat(t[1],"));\n        int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ");if(1===e[0])return n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(".concat(t[0],", ").concat(t[1],"));\n        int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ");if(n)return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ";return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(t[0],", ").concat(t[1],"));\n      int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n      int r = index / ").concat(e[1],";\n      int c = index - r * ").concat(e[1],";\n      return ivec2(r, c);\n    }\n  ")}(e,t,n);case 3:return function(e,t,n){if(n){const t=AW(["r","c","d"],e);return"\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ".concat(t,"\n    return ivec3(r, c, d);\n  }\n")}const a=_W(["r","c","d"],e);return"\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(t[0],", ").concat(t[1],"));\n      int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n      ").concat(a,"\n      return ivec3(r, c, d);\n    }\n  ")}(e,t,n);case 4:return function(e,t,n){if(n){const t=AW(["r","c","d","d2"],e);return"\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ".concat(t,"\n      return ivec4(r, c, d, d2);\n    }\n  ")}const a=_W(["r","c","d","d2"],e);return"\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(".concat(t[0],", ").concat(t[1],"));\n      int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n      ").concat(a,"\n      return ivec4(r, c, d, d2);\n    }\n  ")}(e,t,n);case 5:return function(e,t){const n=_W(["r","c","d","d2","d3"],e);return"\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(".concat(t[0],",\n                             ").concat(t[1],"));\n\n      int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n\n      ").concat(n,"\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  ")}(e,t);case 6:return function(e,t){const n=_W(["r","c","d","d2","d3","d4"],e);return"\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(".concat(t[0],", ").concat(t[1],"));\n      int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n\n      ").concat(n,"\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  ")}(e,t);default:throw new Error("".concat(e.length,"-D output sampling is not yet supported"))}}(t.logicalShape,i,n.enableShapeUniforms),u=function(e){return"\n    void setOutput(float val) {\n      ".concat(e.output," = vec4(val, 0, 0, 0);\n    }\n  ")}(o)),n.packedInputs&&(h+=VW);return[h,c,u,s,l,r,n.userCode].join("\n")}function LW(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const n=e.shapeInfo.logicalShape;switch(n.length){case 0:return function(e,t){const n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return"float ".concat(a,"() {return ").concat(n,";}");const[s,r]=e.shapeInfo.texShape;if(1===s&&1===r)return"\n      float ".concat(a,"() {\n        return sampleTexture(").concat(n,", halfCR);\n      }\n    ");const i=UW(n);if(t)return"\n    float ".concat(a,"() {\n      vec2 uv = uvFromFlat(").concat(n,"TexShape[0], ").concat(n,"TexShape[1], ").concat(i,");\n      return sampleTexture(").concat(n,", uv);\n    }\n  ");const[o,c]=e.shapeInfo.texShape;return"\n    float ".concat(a,"() {\n      vec2 uv = uvFromFlat(").concat(o,", ").concat(c,", ").concat(i,");\n      return sampleTexture(").concat(n,", uv);\n    }\n  ")}(e,t);case 1:return function(e,t){const n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return"\n      float ".concat(a,"(int index) {\n        ").concat(HW(e),"\n      }\n    ");const s=e.shapeInfo.texShape,r=s[0],i=s[1];if(1===i&&1===r)return"\n      float ".concat(a,"(int index) {\n        return sampleTexture(").concat(n,", halfCR);\n      }\n    ");const o=UW(n);if(1===i)return t?"\n      float ".concat(a,"(int index) {\n        vec2 uv = vec2(0.5, (float(index + ").concat(o,") + 0.5) / float(").concat(n,"TexShape[0]));\n        return sampleTexture(").concat(n,", uv);\n      }\n    "):"\n      float ".concat(a,"(int index) {\n        vec2 uv = vec2(0.5, (float(index + ").concat(o,") + 0.5) / ").concat(r,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");if(1===r)return t?"\n      float ".concat(a,"(int index) {\n        vec2 uv = vec2((float(index + ").concat(o,") + 0.5) / float(").concat(n,"TexShape[1]), 0.5);\n        return sampleTexture(").concat(n,", uv);\n      }\n    "):"\n      float ".concat(a,"(int index) {\n        vec2 uv = vec2((float(index + ").concat(o,") + 0.5) / ").concat(i,".0, 0.5);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");if(t)return"\n    float ".concat(a,"(int index) {\n      vec2 uv = uvFromFlat(").concat(n,"TexShape[0], ").concat(n,"TexShape[1], index + ").concat(o,");\n      return sampleTexture(").concat(n,", uv);\n    }\n  ");return"\n    float ".concat(a,"(int index) {\n      vec2 uv = uvFromFlat(").concat(r,", ").concat(i,", index + ").concat(o,");\n      return sampleTexture(").concat(n,", uv);\n    }\n  ")}(e,t);case 2:return function(e,t){const n=e.shapeInfo.logicalShape,a=e.name,s="get"+a.charAt(0).toUpperCase()+a.slice(1),r=e.shapeInfo.texShape;if(null!=r&&Su(n,r)){if(t)return"\n      float ".concat(s,"(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n        return sampleTexture(").concat(a,", uv);\n      }\n    ");const e=r[0],n=r[1];return"\n    float ".concat(s,"(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(n,".0, ").concat(e,".0);\n      return sampleTexture(").concat(a,", uv);\n    }\n  ")}const{newShape:i,keptDims:o}=_u(n),c=i;if(c.length<n.length){const n=KW(e,c),a=["row","col"];return"\n      ".concat(LW(n,t),"\n      float ").concat(s,"(int row, int col) {\n        return ").concat(s,"(").concat(XW(a,o),");\n      }\n    ")}if(e.shapeInfo.isUniform)return"\n      float ".concat(s,"(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(").concat(n[1],", 1)));\n        ").concat(HW(e),"\n      }\n    ");const l=r[0],u=r[1],h=UW(a);if(1===u)return t?"\n      float ".concat(s,"(int row, int col) {\n        float index = dot(vec3(row, col, ").concat(h,"), vec3(").concat(a,"Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(").concat(a,"TexShape[0]));\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n    float ".concat(s,"(int row, int col) {\n      float index = dot(vec3(row, col, ").concat(h,"), vec3(").concat(n[1],", 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ").concat(l,".0);\n      return sampleTexture(").concat(a,", uv);\n    }\n  ");if(1===l)return t?"\n      float ".concat(s,"(int row, int col) {\n        float index = dot(vec3(row, col, ").concat(h,"), vec3(").concat(a,"Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(").concat(a,"TexShape[1]), 0.5);\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n    float ".concat(s,"(int row, int col) {\n      float index = dot(vec3(row, col, ").concat(h,"), vec3(").concat(n[1],", 1, 1));\n      vec2 uv = vec2((index + 0.5) / ").concat(u,".0, 0.5);\n      return sampleTexture(").concat(a,", uv);\n    }\n  ");if(t)return"\n      float ".concat(s,"(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ").concat(a,"Shape[1] + col + ").concat(h,";\n        vec2 uv = uvFromFlat(").concat(a,"TexShape[0], ").concat(a,"TexShape[1], index);\n        return sampleTexture(").concat(a,", uv);\n      }\n    ");return"\n  float ".concat(s,"(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ").concat(n[1]," + col + ").concat(h,";\n    vec2 uv = uvFromFlat(").concat(l,", ").concat(u,", index);\n    return sampleTexture(").concat(a,", uv);\n  }\n")}(e,t);case 3:return function(e,t){const n=e.shapeInfo.logicalShape,a=e.name,s="get"+a.charAt(0).toUpperCase()+a.slice(1),r=n[1]*n[2],i=n[2],{newShape:o,keptDims:c}=_u(n),l=o;if(l.length<n.length){const n=KW(e,l),a=["row","col","depth"];return"\n        ".concat(LW(n,t),"\n        float ").concat(s,"(int row, int col, int depth) {\n          return ").concat(s,"(").concat(XW(a,c),");\n        }\n      ")}if(e.shapeInfo.isUniform)return"\n      float ".concat(s,"(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(").concat(r,", ").concat(i,", 1)));\n        ").concat(HW(e),"\n      }\n    ");const u=e.shapeInfo.texShape,h=u[0],d=u[1],p=e.shapeInfo.flatOffset;if(d===r&&null==p)return t?"\n      float ".concat(s,"(int row, int col, int depth) {\n        int stride1 = ").concat(a,"Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n        float ".concat(s,"(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(").concat(i,", 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(").concat(d,".0, ").concat(h,".0);\n          return sampleTexture(").concat(a,", uv);\n        }\n      ");if(d===i&&null==p)return t?"\n      float ".concat(s,"(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(").concat(a,"Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n    float ".concat(s,"(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(").concat(n[1],", 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(d,".0, ").concat(h,".0);\n      return sampleTexture(").concat(a,", uv);\n    }\n  ");const f=UW(a);if(t)return"\n    float ".concat(s,"(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ").concat(a,"Shape[1] * ").concat(a,"Shape[2];\n      int stride1 = ").concat(a,"Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ").concat(f,";\n      vec2 uv = uvFromFlat(").concat(a,"TexShape[0], ").concat(a,"TexShape[1], index);\n      return sampleTexture(").concat(a,", uv);\n    }\n    ");return"\n      float ".concat(s,"(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ").concat(r," + col * ").concat(i," + depth + ").concat(f,";\n        vec2 uv = uvFromFlat(").concat(h,", ").concat(d,", index);\n        return sampleTexture(").concat(a,", uv);\n      }\n  ")}(e,t);case 4:return function(e,t){const n=e.shapeInfo.logicalShape,a=e.name,s="get"+a.charAt(0).toUpperCase()+a.slice(1),r=n[3],i=n[2]*r,o=n[1]*i,{newShape:c,keptDims:l}=_u(n);if(c.length<n.length){const n=KW(e,c),a=["row","col","depth","depth2"];return"\n      ".concat(LW(n,t),"\n      float ").concat(s,"(int row, int col, int depth, int depth2) {\n        return ").concat(s,"(").concat(XW(a,l),");\n      }\n    ")}if(e.shapeInfo.isUniform)return"\n      float ".concat(s,"(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(").concat(o,", ").concat(i,", ").concat(r,", 1)));\n        ").concat(HW(e),"\n      }\n    ");const u=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,d=h[0],p=h[1],f="int stride2 = ".concat(a,"Shape[3];"),m="int stride1 = ".concat(a,"Shape[2] * stride2;"),g="int stride0 = ".concat(a,"Shape[1] * stride1;");if(p===o&&null==u)return t?"\n      float ".concat(s,"(int row, int col, int depth, int depth2) {\n        ").concat(f,"\n        ").concat(m,"\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n      float ".concat(s,"(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(").concat(i,", ").concat(r,", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(p,".0, ").concat(d,".0);\n        return sampleTexture(").concat(a,", uv);\n      }\n    ");if(p===r&&null==u)return t?"\n      float ".concat(s,"(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(").concat(a,"Shape[1] * ").concat(a,"Shape[2], ").concat(a,"Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n      float ".concat(s,"(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(").concat(n[1]*n[2],", ").concat(n[2],", 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(p,".0, ").concat(d,".0);\n        return sampleTexture(").concat(a,", uv);\n      }\n    ");const y=UW(a);if(t)return"\n    float ".concat(s,"(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ").concat(f,"\n      ").concat(m,"\n      ").concat(g,"\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(").concat(a,"TexShape[0], ").concat(a,"TexShape[1], index + ").concat(y,");\n      return sampleTexture(").concat(a,", uv);\n    }\n  ");return"\n    float ".concat(s,"(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(o," + col * ").concat(i," +\n          depth * ").concat(r," + depth2;\n      vec2 uv = uvFromFlat(").concat(d,", ").concat(p,", index + ").concat(y,");\n      return sampleTexture(").concat(a,", uv);\n    }\n  ")}(e,t);case 5:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),s=t[4],r=t[3]*s,i=t[2]*r,o=t[1]*i,{newShape:c,keptDims:l}=_u(t);if(c.length<t.length){const t=KW(e,c),n=["row","col","depth","depth2","depth3"];return"\n      ".concat(LW(t),"\n      float ").concat(a,"(int row, int col, int depth, int depth2, int depth3) {\n        return ").concat(a,"(").concat(XW(n,l),");\n      }\n    ")}if(e.shapeInfo.isUniform)return"\n      float ".concat(a,"(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(o,", ").concat(i,", ").concat(r,", ").concat(s,")) +\n          depth3;\n        ").concat(HW(e),"\n      }\n    ");const u=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,d=h[0],p=h[1];if(p===o&&null==u)return"\n      float ".concat(a,"(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(").concat(i,", ").concat(r,", ").concat(s,", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(p,".0, ").concat(d,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");if(p===s&&null==u)return"\n      float ".concat(a,"(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(t[1]*t[2]*t[3],",\n               ").concat(t[2]*t[3],", ").concat(t[3],", 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(p,".0, ").concat(d,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");const f=UW(n);return"\n    float ".concat(a,"(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(o," + col * ").concat(i," + depth * ").concat(r," +\n          depth2 * ").concat(s," + depth3 + ").concat(f,";\n      vec2 uv = uvFromFlat(").concat(d,", ").concat(p,", index);\n      return sampleTexture(").concat(n,", uv);\n    }\n  ")}(e);case 6:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:s,keptDims:r}=_u(t);if(s.length<t.length){const t=KW(e,s),n=["row","col","depth","depth2","depth3","depth4"];return"\n      ".concat(LW(t),"\n      float ").concat(a,"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ").concat(a,"(").concat(XW(n,r),");\n      }\n    ")}const i=t[5],o=t[4]*i,c=t[3]*o,l=t[2]*c,u=t[1]*l;if(e.shapeInfo.isUniform)return"\n      float ".concat(a,"(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(u,", ").concat(l,", ").concat(c,", ").concat(o,")) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(").concat(i,", 1)));\n        ").concat(HW(e),"\n      }\n    ");const h=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,p=d[0],f=d[1];if(f===u&&null==h)return"\n      float ".concat(a,"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(").concat(l,", ").concat(c,", ").concat(o,", ").concat(i,")) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(f,".0, ").concat(p,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");if(f===i&&null==h)return"\n      float ".concat(a,"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(").concat(t[1]*t[2]*t[3]*t[4],",\n               ").concat(t[2]*t[3]*t[4],",\n               ").concat(t[3]*t[4],",\n               ").concat(t[4],")) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(f,".0, ").concat(p,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");const m=UW(n);return"\n    float ".concat(a,"(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(u," + col * ").concat(l," + depth * ").concat(c," +\n          depth2 * ").concat(o," + depth3 * ").concat(i," + depth4 + ").concat(m,";\n      vec2 uv = uvFromFlat(").concat(p,", ").concat(f,", index);\n      return sampleTexture(").concat(n,", uv);\n    }\n  ")}(e);default:throw new Error("".concat(n.length,"-D input sampling")+" is not yet supported")}}function zW(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return function(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),a=RW();return"\n    vec4 ".concat(n,"() {\n      return ").concat(a.texture2D,"(").concat(t,", halfCR);\n    }\n  ")}(e);case 1:return function(e,t){const n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e.shapeInfo.texShape,r=RW();if(t)return"\n    vec4 ".concat(a,"(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(n,"TexShape[0]) / 2.0), ceil(float(").concat(n,"TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ").concat(r.texture2D,"(").concat(n,", uv);\n    }\n  ");const i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return"\n    vec4 ".concat(a,"(int index) {\n      vec2 uv = packedUVfrom1D(\n        ").concat(i[0],", ").concat(i[1],", index);\n      return ").concat(r.texture2D,"(").concat(n,", uv);\n    }\n  ")}(e,t);case 2:return function(e,t){const n=e.shapeInfo.logicalShape,a=e.name,s="get"+a.charAt(0).toUpperCase()+a.slice(1),r=e.shapeInfo.texShape,i=r[0],o=r[1],c=RW();if(null!=r&&Su(n,r))return t?"\n      vec4 ".concat(s,"(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n\n        return ").concat(c.texture2D,"(").concat(a,", uv);\n      }\n    "):"\n      vec4 ".concat(s,"(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(o,".0, ").concat(i,".0);\n\n        return ").concat(c.texture2D,"(").concat(a,", uv);\n      }\n    ");if(t)return"\n    vec4 ".concat(s,"(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(a,"TexShape[0]) / 2.0), ceil(float(").concat(a,"TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(").concat(a,"Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ").concat(c.texture2D,"(").concat(a,", uv);\n    }\n  ");const l=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)],u=Math.ceil(n[1]/2);return"\n    vec4 ".concat(s,"(int row, int col) {\n      vec2 uv = packedUVfrom2D(").concat(u,", ").concat(l[0],", ").concat(l[1],", row, col);\n      return ").concat(c.texture2D,"(").concat(a,", uv);\n    }\n  ")}(e,t);case 3:return function(e,t){const n=e.shapeInfo.logicalShape,a=e.name,s="get"+a.charAt(0).toUpperCase()+a.slice(1),r=e.shapeInfo.texShape,i=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];if(1===n[0]){const a=[1,2],r=KW(e,n.slice(1)),i=["b","row","col"];return"\n        ".concat(zW(r,t),"\n        vec4 ").concat(s,"(int b, int row, int col) {\n          return ").concat(s,"(").concat(XW(i,a),");\n        }\n      ")}const o=RW();if(t)return"\n    vec4 ".concat(s,"(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(a,"TexShape[0]) / 2.0), ceil(float(").concat(a,"TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(").concat(a,"Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(").concat(a,"Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ").concat(o.texture2D,"(").concat(a,", uv);\n    }\n  ");const c=i[0],l=i[1],u=Math.ceil(n[2]/2),h=u*Math.ceil(n[1]/2);return"\n    vec4 ".concat(s,"(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ").concat(c,", ").concat(l,", ").concat(h,", ").concat(u,", b, row, col);\n      return ").concat(o.texture2D,"(").concat(a,", uv);\n    }\n  ")}(e,t);default:return function(e,t){const n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),s=RW();if(t)return"\n    vec4 ".concat(a,"(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(").concat(n,"Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(").concat(n,"Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ").concat(n,"Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(n,"TexShape[0]) / 2.0), ceil(float(").concat(n,"TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ").concat(s.texture2D,"(").concat(n,", uv);\n    }\n  ");const r=e.shapeInfo.logicalShape,i=r.length,o=e.shapeInfo.texShape,c=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],l=c[0],u=c[1],h=Math.ceil(r[i-1]/2);let d=h*Math.ceil(r[i-2]/2),p="int b, int row, int col",f="b * ".concat(d," + (row / 2) * ").concat(h," + (col / 2)");for(let m=2;m<i-1;m++)p="int b".concat(m,", ")+p,d*=r[i-m-1],f="b".concat(m," * ").concat(d," + ")+f;return"\n    vec4 ".concat(a,"(").concat(p,") {\n      int index = ").concat(f,";\n      int texR = index / ").concat(u,";\n      int texC = index - texR * ").concat(u,";\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(u,", ").concat(l,");\n      return ").concat(s.texture2D,"(").concat(n,", uv);\n    }\n  ")}(e,t)}}const BW="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",jW="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",WW="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",VW="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function UW(e){return"offset".concat(e)}function HW(e){const t=e.name,n=wu(e.shapeInfo.logicalShape);return n<2?"return ".concat(t,";"):"\n    for (int i = 0; i < ".concat(n,"; i++) {\n      if (i == index) {\n        return ").concat(t,"[i];\n      }\n    }\n  ")}function GW(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error("GPU for rank ".concat(e," is not yet supported"))}function qW(e,t,n){const{newShape:a,keptDims:s}=_u(t),r=t.length,i=e&&3===r&&1===t[0],o=i?t.slice(1):a,c=!e&&r>1&&!Su(t,n)&&a.length<r||i;return{useSqueezeShape:c,uniformShape:c?o:t,keptDims:s}}function KW(e,t){const n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function XW(e,t){return t.map(t=>e[t]).join(", ")}function YW(e,t,n,a){const s=n.map((e,n)=>{const a={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:!e.isUniform&&e.texData.isPacked,flatOffset:null};return null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0&&(a.flatOffset=e.texData.slice.flatOffset),{name:t.variableNames[n],shapeInfo:a}}),r=s.map(e=>e.shapeInfo),i={logicalShape:a.shape,texShape:a.texData.texShape,isUniform:!1,isPacked:a.texData.isPacked,flatOffset:null},o=FW(s,i,t),c=function(e,t){const n=fW(e,()=>e.createShader(e.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(aW(e,()=>e.shaderSource(n,t)),aW(e,()=>e.compileShader(n)),eh().get("ENGINE_COMPILE_ONLY"))return n;if(!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw oW(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}(e.gl,o),l=e.createProgram(c);return eh().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:c,source:o,webGLProgram:l,inShapeInfos:r,outShapeInfo:i,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(e.buildVao(l),Object.assign({program:t,fragmentShader:c,source:o,webGLProgram:l,inShapeInfos:r,outShapeInfo:i},QW(e,t,l)))}function QW(e,t,n){const a=[],s=[];let r,i,o,c=null,l=null;l=e.getUniformLocation(n,"NAN",!1),1===eh().getNumber("WEBGL_VERSION")&&(c=e.getUniformLocation(n,"INFINITY",!1));const u=!1;for(const h of t.variableNames){const s={name:h,uniform:e.getUniformLocation(n,h,u),offset:e.getUniformLocation(n,"offset".concat(h),u)};t.enableShapeUniforms&&(s.shape=e.getUniformLocation(n,"".concat(h,"Shape"),u),s.texShape=e.getUniformLocation(n,"".concat(h,"TexShape"),u)),a.push(s)}if(t.enableShapeUniforms&&(r=e.getUniformLocation(n,"outShape",u),o=e.getUniformLocation(n,"outShapeStrides",u),i=e.getUniformLocation(n,"outTexShape",u)),t.customUniforms)for(const h of t.customUniforms)s.push(e.getUniformLocation(n,h.name,u));return{variablesLocations:a,customUniformLocations:s,infLoc:c,nanLoc:l,outShapeLocation:r,outShapeStridesLocation:o,outTexShapeLocation:i}}function ZW(e,t){if(e.length!==t.length)throw Error("Binary was compiled with ".concat(e.length," inputs, but ")+"was executed with ".concat(t.length," inputs"));e.forEach((e,n)=>{const a=e.logicalShape,s=t[n],r=s.shape;if(!Su(a,r))throw Error("Binary was compiled with different shapes than "+"the current args. Shapes ".concat(a," and ").concat(r," must match"));if(e.isUniform&&s.isUniform)return;const i=e.texShape,o=s.isUniform?null:s.texData.texShape;if(!Su(i,o))throw Error("Binary was compiled with different texture shapes than the"+" current args. Shape ".concat(i," and ").concat(o," must match"))})}function JW(e){return eh().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}class $W{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=Qj.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=RW();this.outputShape=e,this.enableShapeUniforms=JW(this.outputShape.length),this.userCode="\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ".concat(this.enableShapeUniforms?AW(["r","c","d"],e):_W(["r","c","d"],e),"\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ").concat(t.output," = result;\n      }\n    ")}}class eV{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=Qj.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=RW();this.outputShape=e,this.enableShapeUniforms=JW(this.outputShape.length),this.userCode="\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ".concat(this.enableShapeUniforms?AW(["r","c","d"],e):_W(["r","c","d"],e),"\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ").concat(t.output," = result;\n      }\n    ")}}class tV{constructor(e){this.variableNames=["A"],this.outTexUsage=Zj.DOWNLOAD;const t=RW();this.outputShape=e,this.userCode="\n      ".concat(DW,"\n\n      void main() {\n        float x = getAAtOutCoords();\n        ").concat(t.output," = encode_float(x);\n      }\n    ")}}class nV{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=Zj.DOWNLOAD;const t=RW();this.outputShape=e,this.userCode="\n      ".concat(DW,"\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ").concat(t.output," = encode_float(x);\n      }\n    ")}}const aV={R:0,G:1,B:2,A:3};class sV{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"RGBA";this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const a=RW();this.outputShape=e,this.enableShapeUniforms=JW(this.outputShape.length);let s="result";t&&(s="floor(result * 255. + 0.5)");let r="";for(let i=0;i<n.length;i++){const e=n[i];r+="\n          if(offset == ".concat(i,") {\n            result = values[").concat(aV[e],"];\n          }")}this.userCode="\n      ".concat(this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":PW(e),"\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ").concat(n.length,");\n\n        flatIndex = idiv(flatIndex, ").concat(n.length,", 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ").concat(a.texture2D,"(A, uv);\n          ").concat(r,"\n        }\n        ").concat(a.output," = vec4(").concat(s,", 0., 0., 0.);\n      }\n    ")}}class rV{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=RW();this.outputShape=e,this.enableShapeUniforms=JW(this.outputShape.length);let a="",s="result";t&&(s="floor(result * 255. + 0.5)");for(let r=0;r<=1;r++)for(let t=0;t<=1;t++){const s=2*r+t;a+="\n          localCoords = coords;\n          if(localCoords[2] + ".concat(t," < ").concat(this.enableShapeUniforms?"outShape[2]":"".concat(e[2]),") {\n          localCoords[2] += ").concat(t,";\n          if (localCoords[1] + ").concat(r," < ").concat(this.enableShapeUniforms?"outShape[1]":"".concat(e[1]),") {\n            localCoords[1] += ").concat(r,";\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ").concat(n.texture2D,"(A, uv);\n\n            if (offset == 0) {\n              result[").concat(s,"] = values[0];\n            } else if (offset == 1) {\n              result[").concat(s,"] = values[1];\n            } else if (offset == 2) {\n              result[").concat(s,"] = values[2];\n            } else {\n              result[").concat(s,"] = values[3];\n            }\n          }\n        }\n        ")}this.userCode="\n        ".concat(this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":PW(e),"\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ").concat(a,"\n\n          ").concat(n.output," = ").concat(s,";\n        }\n    ")}}function iV(e){const t=RW();return function(e,t){const n=fW(e,()=>e.createShader(e.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(aW(e,()=>e.shaderSource(n,t)),aW(e,()=>e.compileShader(n)),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}(e,"".concat(t.version,"\n    precision highp float;\n    ").concat(t.attribute," vec3 clipSpacePos;\n    ").concat(t.attribute," vec2 uv;\n    ").concat(t.varyingVs," vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }"))}function oV(e){return function(e,t){const n=fW(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return aW(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),aW(e,()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW)),n}(e,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function cV(e){return function(e,t){const n=fW(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return aW(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n)),aW(e,()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW)),n}(e,new Uint16Array([0,1,2,2,1,3]))}function lV(e,t,n,a,s,r){!function(e,t){const n=eh().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0){const n="[".concat(e,"x").concat(t,"]");throw new Error("Requested texture size "+n+" is invalid.")}if(e>n||t>n){const a="[".concat(e,"x").concat(t,"]"),s="[".concat(n,"x").concat(n,"]");throw new Error("Requested texture size "+a+" greater than WebGL maximum on this browser / GPU "+s+".")}}(t,n);const i=function(e){return fW(e,()=>e.createTexture(),"Unable to create WebGLTexture.")}(e),o=e.TEXTURE_2D;return aW(e,()=>e.bindTexture(o,i)),aW(e,()=>e.texParameteri(o,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE)),aW(e,()=>e.texParameteri(o,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE)),aW(e,()=>e.texParameteri(o,e.TEXTURE_MIN_FILTER,e.NEAREST)),aW(e,()=>e.texParameteri(o,e.TEXTURE_MAG_FILTER,e.NEAREST)),1===eh().getNumber("WEBGL_VERSION")?aW(e,()=>e.texImage2D(o,0,a,t,n,0,s,r,null)):aW(e,()=>e.texStorage2D(o,1,a,t,n)),aW(e,()=>e.bindTexture(e.TEXTURE_2D,null)),{texture:i,texShape:[n,t]}}function uV(e){return e.internalFormatFloat}function hV(e){return e.internalFormatHalfFloat}function dV(e){return e.downloadTextureFormat}function pV(e){return e.internalFormatPackedFloat}function fV(e){return e.internalFormatPackedHalfFloat}function mV(e,t,n,a,s,r,i,o){const c=e,l=new Float32Array(function(e,t){const[n,a]=tW(e,t);return n*a*4}(r,i));return c.bindBuffer(c.PIXEL_PACK_BUFFER,t),c.getBufferSubData(c.PIXEL_PACK_BUFFER,0,l),c.bindBuffer(c.PIXEL_PACK_BUFFER,null),l}class gV{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const t=eh().getNumber("WEBGL_VERSION");if(null!=e?(this.gl=e,function(e,t){Kj[e]=t}(t,e)):this.gl=Yj(t),e=this.gl,2===eh().getNumber("WEBGL_VERSION")){const t=e;this.createVertexArray=()=>aW(t,()=>t.createVertexArray()),this.bindVertexArray=e=>aW(t,()=>t.bindVertexArray(e)),this.deleteVertexArray=e=>aW(t,()=>t.deleteVertexArray(e)),this.getVertexArray=()=>aW(t,()=>t.getParameter(t.VERTEX_ARRAY_BINDING))}else if(null!=e){const t=e.getExtension("OES_vertex_array_object");if(null==t)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>aW(e,()=>t.createVertexArrayOES()),this.bindVertexArray=n=>aW(e,()=>t.bindVertexArrayOES(n)),this.deleteVertexArray=n=>aW(e,()=>t.deleteVertexArrayOES(n)),this.getVertexArray=()=>aW(e,()=>e.getParameter(t.VERTEX_ARRAY_BINDING_OES))}let n="WEBGL_color_buffer_float";const a="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===eh().getNumber("WEBGL_VERSION")){const e="OES_texture_float",t="OES_texture_half_float";if(this.textureFloatExtension=rW(this.gl,e),SW(this.gl,t))this.textureHalfFloatExtension=rW(this.gl,t);else if(eh().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),SW(this.gl,a))this.colorBufferHalfFloatExtension=rW(this.gl,a);else if(eh().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",SW(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!SW(this.gl,a))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(a)}this.vertexBuffer=oV(this.gl),this.indexBuffer=cV(this.gl),this.framebuffer=function(e){return fW(e,()=>e.createFramebuffer(),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=nW(this.gl,this.textureHalfFloatExtension)}get debug(){return eh().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;aW(e,()=>e.finish()),aW(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),aW(e,()=>e.deleteFramebuffer(this.framebuffer)),aW(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),aW(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),aW(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,a){const[s,r]=$j(t,n);return lV(e,s,r,uV(a),a.textureFormatFloat,e.FLOAT)}(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,a){const[s,r]=$j(t,n);return lV(e,s,r,hV(a),a.textureFormatFloat,a.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,a){const[s,r]=$j(t,n);return lV(e,s,r,dV(a),e.RGBA,e.UNSIGNED_BYTE)}(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),function(e,t,n){aW(e,()=>e.bindTexture(e.TEXTURE_2D,t)),n.data instanceof Uint8Array?2===eh().getNumber("WEBGL_VERSION")?aW(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data)):aW(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data)):2===eh().getNumber("WEBGL_VERSION")?aW(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n)):aW(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n)),aW(e,()=>e.bindTexture(e.TEXTURE_2D,null))}(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,a){this.throwIfDisposed(),function(e,t,n,a,s,r){let i,o,c;aW(e,()=>e.bindTexture(e.TEXTURE_2D,t)),s instanceof Uint8Array?(i=new Uint8Array(n*a*4),o=e.UNSIGNED_BYTE,c=e.RGBA):(i=new Float32Array(n*a*4),o=e.FLOAT,c=r.internalFormatPackedFloat),i.set(s),2===eh().getNumber("WEBGL_VERSION")?aW(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,a,e.RGBA,o,i)):aW(e,()=>e.texImage2D(e.TEXTURE_2D,0,c,n,a,0,e.RGBA,o,i)),aW(e,()=>e.bindTexture(e.TEXTURE_2D,null))}(this.gl,e,t,n,a,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,a){const[s,r]=tW(t,n);return lV(e,s,r,fV(a),e.RGBA,a.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,a){const[s,r]=tW(t,n);return lV(e,s,r,pV(a),e.RGBA,e.FLOAT)}(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(dW(this.gl,this.framebuffer),this.outputTexture=null),aW(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,()=>function(e,t,n,a){const[s,r]=$j(t,n),i=new Uint8Array(t*n*4);return aW(e,()=>e.readPixels(0,0,s,r,a.downloadTextureFormat,e.UNSIGNED_BYTE,i)),new Float32Array(i.buffer)}(this.gl,t,n,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,n,a,s,r){return mV(this.gl,e,0,0,0,s,r,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return function(e,t,n){const a=e,s=new Float32Array(n);return a.bindBuffer(a.PIXEL_PACK_BUFFER,t),a.getBufferSubData(a.PIXEL_PACK_BUFFER,0,s),a.bindBuffer(a.PIXEL_PACK_BUFFER,null),s}(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);const a=function(e,t,n){const a=e.createBuffer();aW(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,a));const s=16*t*n;return aW(e,()=>e.bufferData(e.PIXEL_PACK_BUFFER,s,e.STREAM_READ)),aW(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0)),aW(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null)),a}(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),a}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(eh().getBool("WEBGL_FENCE_API_ENABLED")){const a=e,s=a.fenceSync(a.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{const e=a.clientWaitSync(s,0,0);return e===a.ALREADY_SIGNALED||e===a.CONDITION_SATISFIED},t=s}else eh().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,eh().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,()=>function(e,t,n){const a=new Float32Array(t*n*4);return aW(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,a)),a}(this.gl,t,n))}createProgram(e){this.throwIfDisposed();const t=this.gl;null==this.vertexShader&&(this.vertexShader=iV(t));const n=function(e){return fW(e,()=>e.createProgram(),"Unable to create WebGLProgram.")}(t);aW(t,()=>t.attachShader(n,this.vertexShader)),aW(t,()=>t.attachShader(n,e)),function(e,t){if(aW(e,()=>e.linkProgram(t)),!eh().get("ENGINE_COMPILE_ONLY")&&!1===e.getProgramParameter(t,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}(t,n);const a=Object.assign(n,{vao:this.createVertexArray()});return this.debug&&cW(t,a),a}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);const t=this.gl;aW(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),function(e,t,n){aW(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),lW(e,t,"clipSpacePos",n,3,20,0)&&lW(e,t,"uv",n,2,20,12)}(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&(aW(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,null!=this.program&&this.debug&&cW(this.gl,this.program),aW(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];return this.throwIfDisposed(),n?function(e,t,n){return fW(e,()=>e.getUniformLocation(t,n),'uniform "'+n+'" not present in program.')}(this.gl,e,t):function(e,t,n){return e.getUniformLocation(t,n)}(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),aW(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),uW(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();const[a,s]=tW(t,n);this.setOutputMatrixTextureDriver(e,a,s)}setOutputMatrixWriteRegion(e,t,n,a){this.setOutputMatrixWriteRegionDriver(n,e,a,t)}setOutputPackedMatrixWriteRegion(e,t,n,a){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&cW(this.gl,this.program),pW(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}aW(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),aW(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=rW(this.gl,2===eh().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===eh().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2(),n=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,n),n}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(2===eh().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2();return void e.endQuery(t.TIME_ELAPSED_EXT)}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await Tu(()=>this.disposed||this.isQueryAvailable(e,eh().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,eh().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(0===t)return null;if(2===t){const t=this.gl;return t.getQueryParameter(e,t.QUERY_RESULT)/1e6}{const t=this.getQueryTimerExtensionWebGL1();return t.getQueryObjectEXT(e,t.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(0===t)return!0;if(2===t){const t=this.gl,n=this.getQueryTimerExtensionWebGL2(),a=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),a&&!this.disjoint}{const t=this.getQueryTimerExtensionWebGL1(),n=t.getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){const e=function(e){let t=0;for(;t<e.length;++t){if(!e[t]())break}return t-1}(this.itemsToPoll.map(e=>e.isDoneFn));for(let t=0;t<=e;++t){const{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let n;"setTimeoutCustom"in eh().platform&&(n=eh().platform.setTimeoutCustom.bind(eh().platform)),Tu(()=>(this.pollItems(),0===this.itemsToPoll.length),()=>0,null,n)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),hW(this.gl,e,this.framebuffer),this.debug&&pW(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(hW(this.gl,this.outputTexture,this.framebuffer),this.debug&&pW(this.gl)):dW(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();const a=this.gl;hW(a,e,this.framebuffer),this.debug&&pW(a),this.outputTexture=e,aW(a,()=>a.viewport(0,0,t,n)),aW(a,()=>a.scissor(0,0,t,n))}setOutputMatrixWriteRegionDriver(e,t,n,a){this.throwIfDisposed(),aW(this.gl,()=>this.gl.scissor(e,t,n,a))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{mx:yV,XI:bV,Nk:xV,f6:vV,ct:wV,YG:kV,hH:SV,z3:CV,sG:IV,uM:NV,vS:TV,qB:EV,GG:RV,rq:_V,lg:AV,WR:MV,cu:PV,GE:DV,px:OV,jC:FV,He:LV,hE:zV,BF:BV,Dk:jV,cl:WV,_B:VV,ub:UV,_f:HV,Ku:GV,qy:qV,Zy:KV,bu:XV,zv:YV,dH:QV,HS:ZV,yH:JV,l3:$V,z9:eU,x6:tU,_m:nU,eW:aU,GK:sU,SP:rU,yr:iU,dl:oU,Dw:cU,xT:lU,_X:uU,wz:hU}=N;function dU(e,t){return["x","y","z","w","u","v"].slice(0,t).map(t=>"".concat(e,".").concat(t))}function pU(e,t){return 1===t?[e]:dU(e,t)}class fU{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=JW(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const e=pU("rc",this.rank),t=GW(this.rank),n=this.getOutOfBoundsCondition(e),a=this.getSetup(e),s=this.getOutput(e);this.userCode="\n        void main() {\n          ".concat(t," rc = getOutputCoords();\n\n          if(").concat(n,") {\n            setOutput(vec4(0));\n          } else {\n            ").concat(a,"\n\n            setOutput(vec4(").concat(s,"));\n          }\n        }\n      ")}}getSourceCoordsArr(e){const t=[];for(let n=0;n<=1;n++)for(let a=0;a<=1;a++){let s="".concat(0===n?"r":"rp1",", ").concat(0===a?"c":"cp1");for(let t=2;t<this.rank;t++)s="".concat(e[e.length-1-t],",")+s;t.push(s)}return t}getOutOfBoundsCondition(e){if(1===this.rank)return"rc > ".concat(this.enableShapeUniforms?"outShape":this.outputShape[0]);let t="";for(let n=this.rank-2;n<this.rank;n++)t+="".concat(e[n]," >= ").concat(this.enableShapeUniforms?"outShape[".concat(n,"]"):this.outputShape[n]),n<this.rank-1&&(t+="||");return t}getSetup(e){if(1===this.rank)return"";const t=e.slice(-2),n=this.enableShapeUniforms?"outShape[".concat(this.rank," - 1]"):this.outputShape[this.rank-1],a=this.enableShapeUniforms?"outShape[".concat(this.rank," - 2]"):this.outputShape[this.rank-2];return"\n      int r = ".concat(t[0],";\n      int c = ").concat(t[1],";\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ").concat(n,";\n      bool rEdge = rp1 >= ").concat(a,";\n    ")}getOutput(e){const t=this.getSourceCoordsArr(e);if(1===this.rank){const e=this.enableShapeUniforms?"outShape":this.outputShape[0];return"getA(rc), (rc + 1 >= ".concat(e," ? 0. : getA(rc + 1)), 0, 0")}return"getA(".concat(t[0],"),\n            cEdge ? 0. : getA(").concat(t[1],"),\n            rEdge ? 0. : getA(").concat(t[2],"),\n            rEdge || cEdge ? 0. : getA(").concat(t[3],")")}}class mU{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=JW(this.outputShape.length);let n="";for(let a=0;a<4;a++){let e="thisRC = rc;";a%2===1&&(e+="thisRC.z += 1;"),a>1&&(e+="thisRC.y += 1;"),n+="\n        ".concat(e,"\n        ").concat(a>0?"if(thisRC.y < rows && thisRC.z < cols){":"","\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[").concat(a,"] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ").concat(a>0?"}":"","\n      ")}this.userCode="\n      ".concat(function(e,t){const n=t?MW(["r","c","d"],"inputShape"):_W(["r","c","d"],e);return"\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ".concat(n,"\n      return ivec3(r, c, d);\n    }\n  ")}(t,this.enableShapeUniforms),"\n      ").concat(this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":PW(e),"\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ").concat(this.enableShapeUniforms?"outShape[1]":e[1],";\n        int cols = ").concat(this.enableShapeUniforms?"outShape[2]":e[2],";\n\n        ").concat(n,"\n\n        setOutput(result);\n      }\n    ")}}class gU{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,n){const a=bU(t,n),s=xU(e,a,n);s in this.freeTextures||(this.freeTextures[s]=[]),s in this.usedTextures||(this.usedTextures[s]=[]);const r=yU(e,a,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[s].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=r,this.log();const e=this.freeTextures[s].pop();return this.usedTextures[s].push(e),e}let i;return a===Jj.PACKED_2X2_FLOAT32?i=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):a===Jj.PACKED_2X2_FLOAT16?i=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):a===Jj.UNPACKED_FLOAT32?i=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):a===Jj.UNPACKED_FLOAT16?i=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):a===Jj.PACKED_4X1_UNSIGNED_BYTE&&(i=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[s].push(i),this.numUsedTextures++,this._numBytesAllocated+=r,this.log(),i}releaseTexture(e,t,n,a){if(null==this.freeTextures)return;const s=bU(n,a),r=xU(t,s,a);r in this.freeTextures||(this.freeTextures[r]=[]);const i=yU(t,s,this.gpgpu.gl,this.gpgpu.textureConfig,a),o=eh().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==o&&this._numBytesAllocated>o?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=i):(this.freeTextures[r].push(e),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;const c=this.usedTextures[r],l=c&&c.indexOf(e);if(null==l||l<0)throw new Error("Cannot release a texture that was never provided by this texture manager");c[l]=c[c.length-1],c.pop(),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used","".concat(this.numFreeTextures," / ").concat(this.numUsedTextures),"(".concat(e,")"));const t=this._numBytesFree/this._numBytesAllocated;console.log("Bytes allocated: ".concat(this._numBytesAllocated)),console.log("Bytes unused: ".concat(this._numBytesFree," (").concat(Math.round(100*t),"%)"))}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const e in this.freeTextures)this.freeTextures[e].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});for(const e in this.usedTextures)this.usedTextures[e].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function yU(e,t,n,a,s){const r=function(e,t){switch(e){case Jj.PACKED_2X2_FLOAT32:return pV(t);case Jj.PACKED_2X2_FLOAT16:return fV(t);case Jj.UNPACKED_FLOAT32:return uV(t);case Jj.UNPACKED_FLOAT16:return hV(t);case Jj.PACKED_4X1_UNSIGNED_BYTE:return dV(t);default:throw new Error("Unknown physical texture type ".concat(e))}}(t,a);let i;if(s){const[t,n]=tW(e[0],e[1]);i=t*n}else{const[t,n]=$j(e[0],e[1]);i=t*n}const o=function(e,t){const n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error("Unknown internal format ".concat(t))}(n,r);return i*o}function bU(e,t){if(e===Zj.UPLOAD)return Jj.PACKED_2X2_FLOAT32;if(e===Zj.RENDER||null==e)return function(e){return eh().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?Jj.PACKED_2X2_FLOAT32:Jj.UNPACKED_FLOAT32:e?Jj.PACKED_2X2_FLOAT16:Jj.UNPACKED_FLOAT16}(t);if(e===Zj.DOWNLOAD||e===Zj.PIXELS)return Jj.PACKED_4X1_UNSIGNED_BYTE;throw new Error("Unknown logical texture type ".concat(e))}function xU(e,t,n){return"".concat(e[0],"_").concat(e[1],"_").concat(t,"_").concat(n)}class vU{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=JW(this.outputShape.length),this.userCode="\n      float unaryOperation(float x) {\n        ".concat(t,"\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ")}}const wU="if (isnan(x)) return x;",kU="return abs(x);";const SU=wU+"\n  return (x < 0.0) ? 0.0 : x;\n",CU=wU+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",IU="return x;";class NU{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=JW(this.outputShape.length),this.userCode="\n      vec4 unaryOperation(vec4 x) {\n        ".concat(t,"\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ")}}class TU{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=JW(this.outputShape.length);const t=e.length,n=pU("rc",t),a=GW(t),s=function(e,t){if(1===e)return"rc";let n="";for(let a=0;a<e;a++)n+=t[a],a<e-1&&(n+=",");return n}(t,n),r=n.slice(-2),i=t<=1?"rc":"vec2(".concat(r.join(","),")");this.userCode="\n      void main() {\n        ".concat(a," rc = getOutputCoords();\n        vec4 packedInput = getA(").concat(s,");\n\n        setOutput(getChannel(packedInput, ").concat(i,"));\n      }\n    ")}}const EU=Sk,RU={};const _U=eh().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");class AU extends hu{nextDataId(){return AU.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!eh().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(null!=e){if(e instanceof gV)t=e;else{const n=Yj(eh().getNumber("WEBGL_VERSION"),e);t=new gV(n)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const e=Yj(eh().getNumber("WEBGL_VERSION"));t=new gV(e),this.binaryCache=((n=eh().getNumber("WEBGL_VERSION"))in RU||(RU[n]={}),RU[n]),this.gpgpuCreatedLocally=!0}var n;this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new gU(this.gpgpu),this.numMBBeforeWarning=null==eh().global.screen?1024:eh().global.screen.height*eh().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new uu(this,qm())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,n,a,s,r){const i=this.makeTensorInfo(t,n),o=this.texData.get(i.dataId);o.isPacked=!1,o.texture={texture:e,texShape:[a,s]},o.texShape=[a,s];const c=bW(t),l=new sV(c,!1,r),u=this.runWebGLProgram(l,[i],n,[[a,s]]);return u.shape=t,o.texture=null,this.disposeIntermediateTensorInfo(i),u.dataId}write(e,t,n){if((eh().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||eh().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const a={id:this.nextDataId()};return this.texData.set(a,{shape:t,dtype:n,values:e,usage:Zj.UPLOAD,refCount:1}),a}refCount(e){if(this.texData.has(e)){return this.texData.get(e).refCount}return 0}incRef(e){this.texData.get(e).refCount++}decRef(e){if(this.texData.has(e)){this.texData.get(e).refCount--}}move(e,t,n,a,s){if(eh().getBool("DEBUG")&&this.checkNumericalProblems(t),"complex64"===a)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:a,values:t,usage:Zj.UPLOAD,refCount:s})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:n,dtype:a,complexTensorInfos:s,slice:r,shape:i,isPacked:o}=t;if(null!=r){let t;t=o?new NU(i,IU):new vU(i,IU);const n=this.runWebGLProgram(t,[{dataId:e,shape:i,dtype:a}],a),s=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),s}if(null!=n)return this.convertAndCacheOnCPU(e);if("string"===a)return n;const c=null!=this.activeTimers;let l,u;if(c&&(l=Hf()),"complex64"===a){u=kC(this.readSync(s.real.dataId),this.readSync(s.imag.dataId))}else u=this.getValuesFromTexture(e);return c&&(this.downloadWaitMs+=Hf()-l),this.convertAndCacheOnCPU(e,u)}async read(e){if(this.pendingRead.has(e)){const t=this.pendingRead.get(e);return new Promise(e=>t.push(e))}const t=this.texData.get(e),{values:n,shape:a,slice:s,dtype:r,complexTensorInfos:i,isPacked:o}=t;if(null!=s){let t;t=o?new NU(a,IU):new vU(a,IU);const n=this.runWebGLProgram(t,[{dataId:e,shape:a,dtype:r}],r),s=this.read(n.dataId);return this.disposeIntermediateTensorInfo(n),s}if(null!=n)return this.convertAndCacheOnCPU(e);if(eh().getBool("DEBUG")&&!eh().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===eh().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let c,l,u=null;if("complex64"!==r&&eh().get("WEBGL_BUFFER_SUPPORTED")){c=this.decode(e);const t=this.texData.get(c.dataId);u=this.gpgpu.createBufferFromTexture(t.texture.texture,...eW(a))}if(this.pendingRead.set(e,[]),"complex64"!==r&&await this.gpgpu.createAndWaitForFence(),"complex64"===r){const e=await Promise.all([this.read(i.real.dataId),this.read(i.imag.dataId)]);l=kC(e[0],e[1])}else if(null==u)l=this.getValuesFromTexture(e);else{const e=wu(a);l=this.gpgpu.downloadFloat32MatrixFromBuffer(u,e)}if(null!=c&&this.disposeIntermediateTensorInfo(c),null!=u){const e=this.gpgpu.gl;aW(e,()=>e.deleteBuffer(u))}const h=this.convertAndCacheOnCPU(e,l),d=this.pendingRead.get(e);return this.pendingRead.delete(e),d.forEach(e=>e(h)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&qm().removeDataId(e,this),this.pendingDeletes--),h}readToGPU(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=this.texData.get(e),{values:a,shape:s,slice:r,dtype:i,isPacked:o,texture:c}=n;if("complex64"===i)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=r){let n;n=o?new NU(s,IU):new vU(s,IU);const a=this.runWebGLProgram(n,[{dataId:e,shape:s,dtype:i}],i),r=this.readToGPU(a,t);return this.disposeIntermediateTensorInfo(a),r}if(null==c)throw null!=a?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const l=this.decode(e,t.customTexShape),u=qm().makeTensorFromTensorInfo(l),h=this.texData.get(l.dataId);return Object.assign({tensorRef:u},h.texture)}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map(e=>qf(e));return ny(e.shape,e.dtype,n)}catch(n){throw new Error("Failed to decode encoded string bytes into utf-8")}return ny(e.shape,e.dtype,t)}checkNumericalProblems(e){if(null!=e)for(let t=0;t<e.length;t++){const n=e[t];if(!sW(n)){if(eh().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error("The value ".concat(n," cannot be represented with your ")+"current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'");throw Error("The value ".concat(n," cannot be represented on this device."))}}}getValuesFromTexture(e){const{shape:t,dtype:n,isPacked:a}=this.texData.get(e),s=wu(t);if(eh().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(e),a=this.texData.get(n.dataId),r=this.gpgpu.downloadMatrixFromPackedTexture(a.texture.texture,...eW(t)).subarray(0,s);return this.disposeIntermediateTensorInfo(n),r}const r=eh().getBool("WEBGL_PACK")&&!0===a,i=r?bW(t):t,o=r?new nV(i):new tV(i),c=this.runWebGLProgram(o,[{shape:i,dtype:n,dataId:e}],"float32"),l=this.texData.get(c.dataId),u=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(l.texture.texture,l.texShape[0],l.texShape[1]).subarray(0,s);return this.disposeIntermediateTensorInfo(c),u}timerAvailable(){return eh().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,n=[];let a=!1;null==this.programTimersStack?(this.programTimersStack=n,a=!0):this.activeTimers.push(n),this.activeTimers=n,e();const s=Xf(this.activeTimers.map(e=>e.query)).filter(e=>null!=e),r=Xf(this.activeTimers.map(e=>e.name)).filter(e=>null!=e);this.activeTimers=t,a&&(this.programTimersStack=null);const i={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(eh().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const e=await Promise.all(s);i.kernelMs=yu(e),i.getExtraProfileInfo=()=>e.map((e,t)=>({name:r[t],ms:e})).map(e=>"".concat(e.name,": ").concat(e.ms)).join(", ")}else i.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,i})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return eh().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:Hf(),endMs:null}}endTimer(e){return eh().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=Hf(),e)}async getQueryTime(e){if(eh().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:n}=this.texData.get(e);return null!=n&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:n,texShape:a,usage:s,isPacked:r,slice:i}=this.texData.get(e),o=i&&i.origDataId||e,c=this.dataRefCount.get(o);c>1?this.dataRefCount.set(o,c-1):(this.dataRefCount.delete(o),null!=t&&(this.numBytesInGPU-=this.computeBytes(a,n),this.textureManager.releaseTexture(t,a,s,r)));const l=this.texData.get(e);l.texture=null,l.texShape=null,l.isPacked=!1,l.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:_U;return eh().getBool("WEBGL_CPU_FORWARD")&&e.every(e=>null==this.texData.get(e.dataId).texture&&wu(e.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){yf("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return EU(e.shape,t)}packedUnaryOp(e,t,n){const a=new NU(e.shape,t),s=this.compileAndRun(a,[e],n);return qm().makeTensorFromTensorInfo(s)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const t=QV(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,t)}if(eh().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,kU,e.dtype);const t=new vU(e.shape,kU),n=this.compileAndRun(t,[e]);return qm().makeTensorFromTensorInfo(n)}makeTensorInfo(e,t,n){let a;if("string"===t&&null!=n&&n.length>0&&Ou(n[0])){const s=n.map(e=>Gf(e));a=this.write(s,e,t)}else a=this.write(n,e,t);return this.texData.get(a).usage=null,{dataId:a,shape:e,dtype:t}}makeOutput(e,t,n){return qm().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,n),this)}unpackTensor(e){const t=new TU(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new fU(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const n=[gW(e.shape),...yW(e.shape)],a={dtype:e.dtype,shape:n,dataId:e.dataId},s=[gW(t),...yW(t)],r=new mU(s,n),i=[n],o=this.runWebGLProgram(r,[a],e.dtype,i,!0);return{dataId:o.dataId,shape:t,dtype:o.dtype}}decode(e,t){const n=this.texData.get(e),{isPacked:a,shape:s,dtype:r}=n;if(null!=t){bu(wu(s)<=t[0]*t[1]*4,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const i=bW(s);let o;o=a?new eV(i):new $W(i);const c=[null!=t?t:eW(i)];return{dtype:r,shape:s,dataId:this.runWebGLProgram(o,[{shape:i,dtype:r,dataId:e}],r,c,!0,t).dataId}}runWebGLProgram(e,t,n,a){let s=arguments.length>4&&void 0!==arguments[4]&&arguments[4],r=arguments.length>5?arguments[5]:void 0;const i=this.makeTensorInfo(e.outputShape,n),o=this.texData.get(i.dataId);if(e.packedOutput&&(o.isPacked=!0),e.outPackingScheme===Qj.DENSE){const t=null!=r?r:eW(e.outputShape);o.texShape=t.map(e=>2*e)}if(null!=e.outTexUsage&&(o.usage=e.outTexUsage),0===wu(i.shape))return o.values=Au(i.dtype,0),i;const c=[],l=t.map(t=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(t.dataId);if(null==n.texture){if(!e.packedInputs&&wu(t.shape)<=eh().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:t.shape,texData:null,isUniform:!0,uniformValues:n.values};e.packedInputs&&(n.isPacked=!0,n.shape=t.shape)}if(this.uploadToGPU(t.dataId),!!n.isPacked!==!!e.packedInputs)t=n.isPacked?this.unpackTensor(t):this.packTensor(t),c.push(t),n=this.texData.get(t.dataId);else if(n.isPacked&&!vW(n.shape,t.shape)){const e=t,a=t.shape;t.shape=n.shape,t=this.packedReshape(t,a),c.push(t),n=this.texData.get(t.dataId),e.shape=a}return{shape:t.shape,texData:n,isUniform:!1}});this.uploadToGPU(i.dataId);const u={shape:i.shape,texData:o,isUniform:!1},h=function(e,t,n){let a="";t.concat(n).forEach(t=>{const s=null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!t.isUniform){const r=t.texData.texShape,{useSqueezeShape:i,uniformShape:o,keptDims:c}=qW(e.packedInputs,t.shape,r);let l="",u="",h="";if(1===o.length&&e.packedInputs){const e=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];l="".concat(e[0]>1,"_").concat(e[1]>1)}else if(2!==o.length||e.packedInputs){if(o.length>2&&!e.packedInputs){const e=ju(o);h="".concat(e[0]===r[1],"_").concat(e[e.length-1]===r[1])}}else u="".concat(o[0]>1,"_").concat(o[1]>1);const d=t.shape.length,p=2===o.length&&Su(t.shape,r),f=1===wu(t.shape),m=Ey(t.shape,n.shape),g=!e.packedInputs&&d===n.shape.length&&Su(r,n.texData.texShape),y=e.packedInputs||o.length>2?"":"".concat(r[0]>1,"_").concat(r[1]>1);a+="".concat(d,"_").concat(g,"_").concat(i?c:"","_").concat(o.length,"_").concat(f,"_").concat(m,"_").concat(p,"_").concat(l,"_").concat(u,"_").concat(h,"_").concat(y,"_").concat(s)}else{const e=t.isUniform?"uniform":t.texData.texShape;a+="".concat(t.shape,"_").concat(e,"_").concat(s)}});const s=e.userCode;let r=e.constructor.name;return r+="_"+a+"_"+s+"".concat(eh().getNumber("WEBGL_VERSION")),r}(e,l,u),d=this.getAndSaveBinary(h,()=>YW(this.gpgpu,e,l,u)),p=null!=this.activeTimers;let f;p&&(f=this.startTimer()),eh().get("ENGINE_COMPILE_ONLY")||function(e,t,n,a,s){t.program.enableShapeUniforms||(ZW(t.inShapeInfos,n),ZW([t.outShapeInfo],[a]));const r=a.texData.texture,i=a.texData.texShape;a.texData.isPacked?e.setOutputPackedMatrixTexture(r.texture,i[0],i[1]):e.setOutputMatrixTexture(r.texture,i[0],i[1]),e.setProgram(t.webGLProgram),e.bindVertexArray(t.webGLProgram.vao),1===eh().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&e.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&e.gl.uniform1f(t.nanLoc,NaN);for(let c=0;c<n.length;++c){const a=n[c],{uniform:s,offset:r,shape:i,texShape:o}=t.variablesLocations[c];if(i){const{uniformShape:n}=qW(t.program.packedInputs,a.shape,a.texData.texShape);switch(n.length){case 1:e.gl.uniform1iv(i,new Int32Array(n));break;case 2:e.gl.uniform2iv(i,new Int32Array(n));break;case 3:e.gl.uniform3iv(i,new Int32Array(n));break;case 4:e.gl.uniform4iv(i,new Int32Array(n))}}if(o&&e.gl.uniform2i(o,a.texData.texShape[0],a.texData.texShape[1]),null!=s)if(a.isUniform)if(wu(a.shape)<2)e.gl.uniform1f(s,a.uniformValues[0]);else{let t=a.uniformValues;t instanceof Float32Array||(t=new Float32Array(t)),e.gl.uniform1fv(s,t)}else null!=a.texData.slice&&null!=r&&e.gl.uniform1i(r,a.texData.slice.flatOffset),e.setInputMatrixTexture(a.texData.texture.texture,s,c)}const o=t.outShapeLocation;if(o)switch(a.shape.length){case 1:e.gl.uniform1iv(o,new Int32Array(a.shape));break;case 2:e.gl.uniform2iv(o,new Int32Array(a.shape));break;case 3:e.gl.uniform3iv(o,new Int32Array(a.shape));break;case 4:e.gl.uniform4iv(o,new Int32Array(a.shape))}if(t.outShapeStridesLocation){const n=ju(a.shape);switch(a.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(n));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(n));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(n))}}if(t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,a.texData.texShape[0],a.texData.texShape[1]),t.program.customUniforms&&s)for(let c=0;c<t.program.customUniforms.length;++c){const n=t.program.customUniforms[c],a=t.customUniformLocations[c],r=s[c];if("float"===n.type)e.gl.uniform1fv(a,r);else if("vec2"===n.type)e.gl.uniform2fv(a,r);else if("vec3"===n.type)e.gl.uniform3fv(a,r);else if("vec4"===n.type)e.gl.uniform4fv(a,r);else if("int"===n.type)e.gl.uniform1iv(a,r);else if("ivec2"===n.type)e.gl.uniform2iv(a,r);else if("ivec3"===n.type)e.gl.uniform3iv(a,r);else{if("ivec4"!==n.type)throw Error("uniform type ".concat(n.type," is not supported yet."));e.gl.uniform4iv(a,r)}}e.executeProgram()}(this.gpgpu,d,l,u,a),c.forEach(e=>this.disposeIntermediateTensorInfo(e)),p&&(f=this.endTimer(f),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(f)}));const m=eh().getNumber("WEBGL_FLUSH_THRESHOLD");if(m>0){const e=Hf();e-this.lastGlFlushTime>m&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=e)}if(!eh().getBool("WEBGL_LAZILY_UNPACK")&&o.isPacked&&!1===s){const e=this.unpackTensor(i);return this.disposeIntermediateTensorInfo(i),e}return i}compileAndRun(e,t,n,a){let s=arguments.length>4&&void 0!==arguments[4]&&arguments[4];n=n||t[0].dtype;return this.runWebGLProgram(e,t,n,a,s)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){if(!this.disposed){if(!eh().getBool("IS_TEST")){Object.keys(this.binaryCache).forEach(e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]})}this.textureManager.dispose(),null!=this.canvas&&"undefined"!==typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0}}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=Xm(()=>{if(!eh().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=eh().getBool("DEBUG");eh().set("DEBUG",!1);const t=this.abs(fy(1e-8)).dataSync()[0];if(eh().set("DEBUG",e),t>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const t=this.texData.get(e),{shape:n,dtype:a,values:s,texture:r,usage:i,isPacked:o}=t;if(null!=r)return;const c=null!=this.activeTimers;let l;c&&(l=Hf());let u=t.texShape;if(null==u&&(u=function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=eh().getNumber("WEBGL_MAX_TEXTURE_SIZE"),a=eh().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");if(a===1/0&&eh().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(a=n/2),t&&(n*=2,a*=2,1===(e=e.map((t,n)=>n>=e.length-2?mu(e[n]):e[n])).length&&(e=[2,e[0]])),2!==e.length){const t=_u(e);e=t.newShape}let s=wu(e),r=null;e.length<=1&&s<=n?r=[1,s]:2===e.length&&e[0]<=n&&e[1]<=n?r=e:3===e.length&&e[0]*e[1]<=n&&e[2]<=n?r=[e[0]*e[1],e[2]]:3===e.length&&e[0]<=n&&e[1]*e[2]<=n?r=[e[0],e[1]*e[2]]:4===e.length&&e[0]*e[1]*e[2]<=n&&e[3]<=n?r=[e[0]*e[1]*e[2],e[3]]:4===e.length&&e[0]<=n&&e[1]*e[2]*e[3]<=n&&(r=[e[0],e[1]*e[2]*e[3]]);const i=null!=r&&Math.max(...r)>a&&Math.min(...r)<=(t?2:1)&&Math.min(...r)>0;if(null==r||i)if(t){const t=gW(e);let n=2,a=2;e.length&&([n,a]=yW(e)),s=t*(n/2)*(a/2),r=Iu(s).map(e=>2*e)}else r=Iu(s);return r}(n,o),t.texShape=u),null!=s){const e=bW(n);let r,i=u[1],h=u[0];const d=s instanceof Uint8Array||s instanceof Uint8ClampedArray;!o&&d||([i,h]=tW(u[0],u[1])),r=o?new rV(e,d):new sV(e,d);const p=d?[h,i]:u,f=this.makeTensorInfo(p,a),m=this.texData.get(f.dataId);m.usage=d?Zj.PIXELS:Zj.UPLOAD,m.texShape=p,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(f.dataId),i,h,s);const g=[[h,i]],y=!0,b=this.runWebGLProgram(r,[f],a,g,y),x=this.texData.get(b.dataId);t.texShape=x.texShape,t.isPacked=x.isPacked,t.usage=x.usage,eh().get("ENGINE_COMPILE_ONLY")?this.disposeData(b.dataId):(t.texture=x.texture,t.values=null,this.texData.delete(b.dataId)),this.disposeIntermediateTensorInfo(f),c&&(this.uploadWaitMs+=Hf()-l)}else{const e=this.acquireTexture(u,i,a,o);t.texture=e}}convertAndCacheOnCPU(e,t){const n=this.texData.get(e),{dtype:a}=n;return null!=t&&(n.values=function(e,t){if("float32"===t||"complex64"===t)return e;if("int32"===t||"bool"===t){const n="int32"===t?new Int32Array(e.length):new Uint8Array(e.length);for(let t=0;t<n.length;++t)n[t]=Math.round(e[t]);return n}throw new Error("Unknown dtype ".concat(t))}(t,a)),n.values}acquireTexture(e,t,n,a){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const e=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn("High memory usage in GPU: ".concat(e," MB, ")+"most likely due to a memory leak")}return this.textureManager.acquireTexture(e,t,a)}computeBytes(e,t){return e[0]*e[1]*Du(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}for(const[,t]of Object.entries(this.binaryCache)){const n=new Promise(e=>{try{this.checkCompletion_(t),e(!0)}catch(n){throw n}});e.push(n)}return Promise.all(e)}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await ZS(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)){if(console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS))throw oW(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.");throw new Error("Failed to link vertex and fragment shaders.")}return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:t,customUniformLocations:n,infLoc:a,nanLoc:s,outShapeLocation:r,outShapeStridesLocation:i,outTexShapeLocation:o}=QW(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=n,e.infLoc=a,e.nanLoc=s,e.outShapeLocation=r,e.outShapeStridesLocation=i,e.outTexShapeLocation=o}}createTensorFromGPUData(e,t,n){e.channels=e.channels||"RGBA";const{texture:a,height:s,width:r,channels:i}=e,o=qm().backend;if(!o.gpgpu.gl.isTexture(a))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const c=o.writeTexture(a,t,n,s,r,i);return qm().makeTensorFromDataId(c,t,n,o)}}AU.nextDataId=0;Mm()&&Jm("webgl",()=>new AU,2);const MU="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n";class PU{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=_y(t,n),this.enableShapeUniforms=JW(this.outputShape.length),this.userCode="\n      float binaryOperation(float a, float b) {\n        ".concat(e,"\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    ")}}const DU="\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n";class OU{constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=_y(t,n);const s=this.outputShape.length;this.enableShapeUniforms=JW(s);let r="";if(a)if(0===s||1===wu(this.outputShape))r="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else{const e=GW(s);if(r="\n          ".concat(e," coords = getOutputCoords();\n        "),1===s)this.enableShapeUniforms?r+="\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":r+="\n            result.y = (coords + 1) >= ".concat(this.outputShape[0]," ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ");else{const e=pU("coords",s);this.enableShapeUniforms?r+="\n            bool nextRowOutOfBounds =\n              (".concat(e[s-2]," + 1) >= outShape[").concat(s," - 2];\n            bool nextColOutOfBounds =\n              (").concat(e[s-1]," + 1) >= outShape[").concat(s," - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          "):r+="\n            bool nextRowOutOfBounds =\n              (".concat(e[s-2]," + 1) >= ").concat(this.outputShape[s-2],";\n            bool nextColOutOfBounds =\n              (").concat(e[s-1]," + 1) >= ").concat(this.outputShape[s-1],";\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          ")}}this.userCode="\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ".concat(e,"\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ").concat(r,"\n\n        setOutput(result);\n      }\n    ")}}function FU(e){const{inputs:t,backend:n}=e,{x:a}=t;return n.incRef(a.dataId),{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}const LU={kernelName:vd,backendName:"webgl",kernelFunc:FU};function zU(e){const{inputs:t,backend:n}=e,{real:a,imag:s}=t,r=n.makeTensorInfo(a.shape,"complex64"),i=n.texData.get(r.dataId),o=FU({inputs:{x:a},backend:n}),c=FU({inputs:{x:s},backend:n});return i.complexTensorInfos={real:o,imag:c},r}const BU={kernelName:Ah,backendName:"webgl",kernelFunc:zU},jU="return (a < 0.) ? b * a : a;",WU="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";const VU={kernelName:Nd,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{alpha:r}=a,i=n.makeTensorInfo([],"float32",Vf(r,"float32")),o=eh().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new OU(WU,s.shape,i.shape):new PU(jU,s.shape,i.shape),c=n.runWebGLProgram(o,[s,i],"float32");return n.disposeIntermediateTensorInfo(i),c}},UU="return (a < 0.) ? b * a : a;",HU="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";const GU={kernelName:op,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a,alpha:s}=t,r=eh().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new OU(HU,a.shape,s.shape):new PU(UU,a.shape,s.shape);return n.runWebGLProgram(r,[a,s],"float32")}},qU="if (isnan(x)) return x;";function KU(e){let{opSnippet:t,packedOpSnippet:n,cpuKernelImpl:a,dtype:s}=e;return e=>{let{inputs:r,backend:i}=e;const{x:o}=r,c=i,l=s||o.dtype;if(c.shouldExecuteOnCPU([o])&&null!=a){const e=c.texData.get(o.dataId),t=a(e.values,l);return c.makeTensorInfo(o.shape,l,t)}let u;return u=eh().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=n?new NU(o.shape,n):new vU(o.shape,t),c.runWebGLProgram(u,[o],l)}}function XU(e){let{opSnippet:t,packedOpSnippet:n,checkOutOfBounds:a=!1,supportsComplex:s=!1,cpuKernelImpl:r,dtype:i}=e;return e=>{let{inputs:o,backend:c}=e;const{a:l,b:u}=o,h=c;if(s&&"complex64"===l.dtype){const e=h.texData.get(l.dataId),n=h.texData.get(u.dataId),[a,s]=[[e.complexTensorInfos.real,n.complexTensorInfos.real],[e.complexTensorInfos.imag,n.complexTensorInfos.imag]].map(e=>{const[n,a]=e,s={dataId:n.dataId,dtype:n.dtype,shape:l.shape},r={dataId:a.dataId,dtype:a.dtype,shape:u.shape},i=new PU(t,l.shape,u.shape);return h.runWebGLProgram(i,[s,r],gm(n.dtype,a.dtype))}),r=zU({inputs:{real:a,imag:s},backend:h});return h.disposeIntermediateTensorInfo(a),h.disposeIntermediateTensorInfo(s),r}const d=i||gm(l.dtype,u.dtype);if(("string"===l.dtype||"string"===u.dtype||h.shouldExecuteOnCPU([l,u]))&&null!=r){const e=h.texData.get(l.dataId).values,t=h.texData.get(u.dataId).values,n="string"===l.dtype?nI(e):e,a="string"===l.dtype?nI(t):t,[s,i]=r(l.shape,u.shape,n,a,d),o=h.makeTensorInfo(i,d);return h.texData.get(o.dataId).values=s,o}let p;return p=eh().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=n?new OU(n,l.shape,u.shape,a):new PU(t,l.shape,u.shape),h.runWebGLProgram(p,[l,u],d)}}function YU(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if("linear"===e)return"return x;";if("relu"===e)return t?"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":SU;if("elu"===e)return t?"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n":"return (x >= 0.0) ? x : (exp(x) - 1.0);";if("relu6"===e)return t?"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":CU;if("prelu"===e)return t?HU:UU;if("leakyrelu"===e)return t?WU:jU;if("sigmoid"===e)return"return 1.0 / (1.0 + exp(-1.0 * x));";throw new Error("Activation ".concat(e," has not been implemented for the WebGL backend."))}class QU{constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=arguments.length>4&&void 0!==arguments[4]&&arguments[4],r=arguments.length>5&&void 0!==arguments[5]&&arguments[5],i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,o=arguments.length>7&&void 0!==arguments[7]&&arguments[7],c=arguments.length>8&&void 0!==arguments[8]&&arguments[8];this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=JW(this.outputShape.length);const l=a?e[1]:e[2],u=Math.ceil(l/2),h=a?"i * 2, rc.y":"rc.y, i * 2",d=s?"rc.z, i * 2":"i * 2, rc.z",p=a?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],f=s?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let m="",g="";i&&(m=o?"vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ".concat(i,"\n        }"):c?"vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ".concat(i,"\n        }"):"vec4 activation(vec4 x) {\n          ".concat(i,"\n        }"),g="result = activation(result);");const y=r?"result += getBiasAtOutCoords();":"";r&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),c&&this.variableNames.push("leakyreluAlpha");let b="rc.x",x="rc.x";e[0]<t[0]?b="imod(rc.x, ".concat(e[0],")"):t[0]<e[0]&&(x="imod(rc.x, ".concat(t[0],")")),this.userCode="\n      ".concat(m,"\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ").concat(u,".0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        int batchA = ").concat(b,";\n        int batchB = ").concat(x,";\n        for (int i = 0; i < ").concat(u,"; i++) {\n          vec4 a = getMatrixA(batchA, ").concat(h,");\n          vec4 b = getMatrixB(batchB, ").concat(d,");\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (").concat(p[0]," * ").concat(f[0],");\n          result += (").concat(p[1]," * ").concat(f[1],");\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ").concat(y,"\n\n        ").concat(g,"\n\n        setOutput(result);\n      }\n    ")}}const ZU="return areal * breal - aimag * bimag;",JU="return areal * bimag + aimag * breal;";class $U{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=_y(t,n),this.userCode="\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ".concat(e,"\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    ")}}const eH="return a * b;";function tH(e){const{inputs:t,backend:n}=e,{a:a,b:s}=t,r=gm(a.dtype,s.dtype);if("complex64"===a.dtype){const e=n.texData.get(a.dataId),t=n.texData.get(s.dataId),r=new $U(ZU,a.shape,s.shape),i=new $U(JU,a.shape,s.shape),o=[{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:a.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:a.shape},{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:s.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:s.shape}],c=n.runWebGLProgram(r,o,"float32"),l=n.runWebGLProgram(i,o,"float32"),u=zU({inputs:{real:c,imag:l},backend:n});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(l),u}if(n.shouldExecuteOnCPU([a,s])){const e=n.texData.get(a.dataId),t=n.texData.get(s.dataId),[i,o]=BV(a.shape,s.shape,e.values,t.values,r),c=n.makeTensorInfo(o,r);return n.texData.get(c.dataId).values=i,c}let i;return i=eh().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new OU(eH,a.shape,s.shape):new PU(eH,a.shape,s.shape),n.runWebGLProgram(i,[a,s],r)}const nH={kernelName:Qd,backendName:"webgl",kernelFunc:tH};function aH(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{shape:r}=a,i=n,o=wu(s.shape),c=Eu(r,o),l=wu(c);bu(o===l,()=>"The new shape (".concat(c,") has ").concat(l," elements and the old ")+"shape (".concat(s.shape,") has ").concat(o," elements. The new shape and old ")+"shape must have the same number of elements.");const u=i.texData.get(s.dataId);return!u.isPacked||vW(s.shape,c)||null!==u.texture&&vW(u.shape,c)?(i.incRef(s.dataId),{dataId:s.dataId,shape:c,dtype:s.dtype}):function(e,t,n){const a=[gW(e.shape),...yW(e.shape)],s={dtype:e.dtype,shape:a,dataId:e.dataId},r=[gW(t),...yW(t)],i=new mU(r,a),o=[a],c=n.runWebGLProgram(i,[s],e.dtype,o,!0);return{dataId:c.dataId,shape:t,dtype:c.dtype}}(s,c,i)}const sH={kernelName:gp,backendName:"webgl",kernelFunc:aH};class rH{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:a,inSize:s,outSize:r}=e;this.outputShape=[a,r];const i=4*Math.floor(n/4),o=n%4;let c="sumValue += dot(values, ones);";if(null!=t){const e=1/t;c="sumValue += dot(values * ".concat(Cu(e)?e.toPrecision(2):e,", ones);")}let l="";s%n>0&&(l="\n        if (inIdx < 0 || inIdx >= ".concat(s,") {\n          return 0.0;\n        }\n      ")),this.userCode="\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ".concat(l,"\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ").concat(n,";\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ").concat(i,"; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ").concat(c,"\n        }\n\n        int inIdx = inOffset + ").concat(i,";\n        if (").concat(1===o,") {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ").concat(c,"\n        } else if (").concat(2===o,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ").concat(c,"\n        } else if (").concat(3===o,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ").concat(c,"\n        }\n        setOutput(sumValue);\n      }\n    ")}}class iH{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:a,inSize:s,outSize:r}=e;this.outputShape=[a,r];let i="0.0",o="";"prod"===t?i="1.0":"min"===t?(i="1.0 / 1e-20",o="min"):"max"===t&&(i="-1.0 / 1e-20",o="max");let c="".concat(t,"(").concat(t,"(").concat(t,"(")+"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"sum"===t?c="sumValue":"prod"===t?c="prodValue":"all"===t?c="allValue":"any"===t&&(c="anyValue");const l=4*Math.floor(n/4),u=n%4;let h="\n      if (".concat("sum"===t,") {\n        sumValue += dot(values, ones);\n      } else if (").concat("prod"===t,") {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ").concat(o,"(values, minMaxValue);\n        if (").concat("min"===t," || ").concat("max"===t,") {\n          minMaxValue = ").concat(o,"(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    "),d="vec4";"all"===t?(i="1.0",h="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",d="bvec4"):"any"===t&&(i="0.0",h="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",d="bvec4");let p="";s%n>0&&(p="\n        if (inIdx < 0 || inIdx >= ".concat(s,") {\n          return initializationValue;\n        }\n      ")),this.userCode="\n      const float initializationValue = ".concat(i,";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ").concat(p,"\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ").concat(n,";\n\n        vec4 minMaxValue = vec4(").concat(i,");\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ").concat(l,"; i += 4) {\n          int inIdx = inOffset + i;\n          ").concat(d," values = ").concat(d,"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ").concat(h,"\n        }\n\n        int inIdx = inOffset + ").concat(l,";\n        if (").concat(1===u,") {\n          ").concat(d," values = ").concat(d,"(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ").concat(h,"\n        } else if (").concat(2===u,") {\n          ").concat(d," values = ").concat(d,"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ").concat(h,"\n        } else if (").concat(3===u,") {\n          ").concat(d," values = ").concat(d,"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ").concat(h,"\n        }\n        setOutput(").concat(c,");\n      }\n    ")}}function oH(e,t,n,a){const s=function(e){const t=[];for(;0===t.length||1!==t[t.length-1].outSize;){const n=t.length?t[t.length-1].outSize:e[1],a=iC(n);t.push({inSize:n,windowSize:a,outSize:Math.ceil(n/a)})}return t}(e.shape);let r=e;for(let i=0;i<s.length;i++){const{inSize:o,windowSize:c,outSize:l}=s[i];let u,h;u="mean"===n?0===i?new rH({windowSize:c,inSize:o,batchSize:e.shape[0],outSize:l},o):new rH({windowSize:c,inSize:o,batchSize:e.shape[0],outSize:l}):new iH({windowSize:c,inSize:o,batchSize:e.shape[0],outSize:l},n),h=r,r=a.runWebGLProgram(u,[r],t),h.dataId!==e.dataId&&a.disposeIntermediateTensorInfo(h)}return r}class cH{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];this.outputShape=n,this.rank=n.length;const a=GW(this.rank),s=function(e){const t=e.length;if(t>6)throw Error("Transpose for rank ".concat(t," is not yet supported"));const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],a=new Array(t);for(let s=0;s<e.length;s++)a[e[s]]=n[s];return a.join()}(t);this.userCode="\n    void main() {\n      ".concat(a," resRC = getOutputCoords();\n      setOutput(getA(").concat(s,"));\n    }\n    ")}}class lH{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(e.length);for(let l=0;l<n.length;l++)n[l]=e[t[l]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error("Packed transpose for rank ".concat(this.rank," is not yet supported."));const a=GW(this.rank),s=dU("rc",this.rank),r=new Array(this.rank);for(let l=0;l<t.length;l++)r[t[l]]=s[l];const i="vec2(".concat(r.slice(-2).join(),")"),o="++".concat(s[this.rank-1]," < ").concat(n[this.rank-1]),c="getChannel(getA(".concat(r.join(),"), ").concat(i,")");this.userCode="\n    void main() {\n      ".concat(a," rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ").concat(c,";\n      if(").concat(o,") {\n        result[1] = ").concat(c,";\n      }\n      --").concat(s[this.rank-1],";\n      if(++").concat(s[this.rank-2]," < ").concat(n[this.rank-2],") {\n        result[2] = ").concat(c,";\n        if(").concat(o,") {\n          result[3] = ").concat(c,";\n        }\n      }\n      setOutput(result);\n    }\n    ")}}function uH(e,t,n){const a=eh().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new lH(e.shape,t):new cH(e.shape,t);return n.runWebGLProgram(a,[e],e.dtype)}function hH(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{axis:r,keepDims:i}=a;return function(e,t,n,a){const s=t,r=e.shape.length,i=Ru(s,e.shape);let o=i;const c=tv(o,r),l=null!=c;let u=e;l&&(u=uH(e,c,a),o=av(o.length,r)),ev("sum",o,r);const[h,d]=Jx(u.shape,o);let p=h;n&&(p=$x(h,i));const f=wu(d),m=aH({inputs:{x:u},attrs:{shape:[wu(e.shape)/f,f]},backend:a}),g=oH(m,ym(e.dtype),"sum",a),y=aH({inputs:{x:g},attrs:{shape:p},backend:a});return a.disposeIntermediateTensorInfo(m),a.disposeIntermediateTensorInfo(g),l&&a.disposeIntermediateTensorInfo(u),y}(s,r,i,n)}const dH={kernelName:Lp,backendName:"webgl",kernelFunc:hH};function pH(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{perm:r}=a,i=n,o=s.shape.length,c=new Array(o);for(let u=0;u<c.length;u++)c[u]=s.shape[r[u]];let l;if(i.shouldExecuteOnCPU([s])){const e=i.texData.get(s.dataId).values,t=uU(e,s.shape,s.dtype,r,c);l=i.makeTensorInfo(c,s.dtype);i.texData.get(l.dataId).values=t}else l=uH(s,r,i);return l}const fH={kernelName:rf,backendName:"webgl",kernelFunc:pH};function mH(e){let{a:t,b:n,transposeA:a,transposeB:s,backend:r,bias:i=null,preluActivationWeights:o=null,leakyreluAlpha:c=0,activation:l=null}=e;const u=t.shape.length,h=n.shape.length,d=a?t.shape[u-2]:t.shape[u-1],p=s?n.shape[h-1]:n.shape[h-2],f=a?t.shape[u-1]:t.shape[u-2],m=s?n.shape[h-2]:n.shape[h-1],g=t.shape.slice(0,-2),y=n.shape.slice(0,-2),b=wu(g),x=wu(y),v=_y(t.shape.slice(0,-2),n.shape.slice(0,-2)).concat([f,m]);bu(d===p,()=>"Error in matMul: inner shapes (".concat(d,") and (")+"".concat(p,") of Tensors with shapes ").concat(t.shape," and ")+"".concat(n.shape," and transposeA=").concat(a)+" and transposeB=".concat(s," must match."));const w=a?[b,d,f]:[b,f,d],k=s?[x,m,p]:[x,p,m],S=aH({inputs:{x:t},backend:r,attrs:{shape:w}}),C=aH({inputs:{x:n},backend:r,attrs:{shape:k}}),I=[S,C],N=Math.max(b,x),T=a?S.shape[1]:S.shape[2],E=null!=i,R=null!=o,_="leakyrelu"===l,A=null!=l?YU(l,!0):null;let M;if((1===f||1===m)&&T>1e3&&!1===(E||R||_||null!=A)){let e=S,t=C;a&&(e=pH({inputs:{x:S},backend:r,attrs:{perm:[0,2,1]}}),I.push(e)),s&&(t=pH({inputs:{x:C},backend:r,attrs:{perm:[0,2,1]}}),I.push(t));const n=1===m;let i=e;1!==m&&(i=aH({inputs:{x:e},backend:r,attrs:{shape:[N,T,1]}}),I.push(i));const o=1===m?2:1;let c=t;n&&(c=aH({inputs:{x:t},backend:r,attrs:{shape:[N,1,T]}}),I.push(c));const l=tH({inputs:{a:i,b:c},backend:r});M=hH({inputs:{x:l},backend:r,attrs:{axis:o,keepDims:!0}}),I.push(l)}else{const e=gm(t.dtype,n.dtype),l=new QU(w,k,[N,f,m],a,s,E,A,R,_),u=[S,C];if(null!=i&&u.push(i),R&&u.push(o),_){const e=r.makeTensorInfo([],"float32",Vf(c,"float32"));u.push(e),I.push(e)}M=r.runWebGLProgram(l,u,e)}const P=aH({inputs:{x:M},backend:r,attrs:{shape:v}});I.push(M);for(const D of I)r.disposeIntermediateTensorInfo(D);return P}const gH={kernelName:ff,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{a:s,b:r,bias:i,preluActivationWeights:o}=t,{transposeA:c,transposeB:l,activation:u,leakyreluAlpha:h}=a;return mH({a:s,b:r,transposeA:c,transposeB:l,backend:n,bias:i,preluActivationWeights:o,leakyreluAlpha:h,activation:u})}},yH="return abs(x);";const bH={kernelName:rh,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t;if(n.shouldExecuteOnCPU([a])&&"complex64"!==a.dtype){const e=n.texData.get(a.dataId),t=QV(e.values);return n.makeTensorInfo(a.shape,a.dtype,t)}let s;return s=eh().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new NU(a.shape,yH):new vU(a.shape,yH),n.runWebGLProgram(s,[a],a.dtype)}},xH=KU({opSnippet:wU+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),vH={kernelName:ih,backendName:"webgl",kernelFunc:xH},wH=KU({opSnippet:wU+"\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),kH={kernelName:oh,backendName:"webgl",kernelFunc:wH},SH="return a + b;",CH=XU({opSnippet:SH,packedOpSnippet:SH,supportsComplex:!0,cpuKernelImpl:yV}),IH={kernelName:ch,backendName:"webgl",kernelFunc:CH};class NH{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((e,t)=>"T".concat(t));const n=[];this.variableNames.forEach(e=>{n.push("float v".concat(e," = get").concat(e,"AtOutCoords();"))});const a=this.variableNames.map(e=>"v".concat(e)).join(" + ");this.userCode="\n      void main() {\n        ".concat(n.join("\n        "),"\n\n        float result = ").concat(a,";\n        setOutput(result);\n      }\n    ")}}class TH{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((e,t)=>"T".concat(t));const n=[];this.variableNames.forEach(e=>{n.push("vec4 v".concat(e," = get").concat(e,"AtOutCoords();"))});const a=this.variableNames.map(e=>"v".concat(e)).join(" + ");this.userCode="\n      void main() {\n        ".concat(n.join("\n        "),"\n\n        vec4 result = ").concat(a,";\n        setOutput(result);\n      }\n    ")}}const EH={kernelName:lh,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:a}=t,s=n;if(1===s.length)return FU({inputs:{x:s[0]},backend:a});if(s.length>eh().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const t=Math.floor(s.length/2),n=e({inputs:s.slice(0,t),backend:a}),r=e({inputs:s.slice(t),backend:a});return e({inputs:[n,r],backend:a})}const r=s.map(e=>e.dtype).reduce((e,t)=>gm(e,t)),i=s.map(e=>e.shape),o=eh().getBool("WEBGL_PACK")?new TH(s[0].shape,i):new NH(s[0].shape,i);return a.runWebGLProgram(o,s,r)}};const RH={kernelName:uh,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{axis:r,keepDims:i}=a,o=s.shape.length,c=Ru(r,s.shape);let l=c;const u=tv(l,o);let h=s;null!=u&&(h=pH({inputs:{x:s},backend:n,attrs:{perm:u}}),l=av(l.length,o)),ev("all",l,o);const[d,p]=Jx(h.shape,l),f=aH({inputs:{x:h},backend:n,attrs:{shape:[-1,wu(p)]}}),m=oH(f,f.dtype,"all",n);let g;if(i){g=aH({inputs:{x:m},backend:n,attrs:{shape:$x(d,c)}})}else g=aH({inputs:{x:m},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=u&&n.disposeIntermediateTensorInfo(h),g}};const _H={kernelName:hh,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{axis:r,keepDims:i}=a,o=s.shape.length,c=Ru(r,s.shape);let l=c;const u=tv(l,o);let h=s;null!=u&&(h=pH({inputs:{x:s},backend:n,attrs:{perm:u}}),l=av(l.length,o)),ev("any",l,o);const[d,p]=Jx(h.shape,l),f=aH({inputs:{x:h},backend:n,attrs:{shape:[-1,wu(p)]}}),m=oH(f,f.dtype,"any",n);let g;if(i){g=aH({inputs:{x:m},backend:n,attrs:{shape:$x(d,c)}})}else g=aH({inputs:{x:m},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=u&&n.disposeIntermediateTensorInfo(h),g}};class AH{constructor(e,t,n){this.variableNames=["A"];const{windowSize:a,batchSize:s,outSize:r}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[s,r];const i="max"===t?">":"<",o=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ".concat(a,";\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ").concat(a,"; i++) {\n          int inIdx = ").concat(o,";\n          float candidate = getA(batch, inIdx);\n          if (candidate ").concat(i," bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    ")}}class MH{constructor(e,t,n,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,bu(e.length>2,()=>"Packed arg".concat(n.charAt(0).toUpperCase()+n.slice(1)," supports only inputs with rank above 2."));const s=e[e.length-1],r=Math.ceil(s/t);this.outputShape=e.slice(0,-1),r>1&&this.outputShape.push(r),a||this.variableNames.push("bestIndicesA");const i=this.outputShape,o=i.length,c=GW(o),l=pU("coords",o);let u,h;if(1===r){h=o+1;const e=GW(h);u="\n        ".concat(e," sourceLocR = ").concat(e,"(").concat(l.join(),", 0);\n        ++").concat(l[o-1],";\n        ").concat(e," sourceLocG = ").concat(e,"(").concat(l.join(),", 0);\n        ++").concat(l[o-2],";\n        ").concat(e," sourceLocA = ").concat(e,"(").concat(l.join(),", 0);\n        --").concat(l[o-1],";\n        ").concat(e," sourceLocB = ").concat(e,"(").concat(l.join(),", 0);\n        --").concat(l[o-2],";")}else h=o,u="\n        ".concat(c," sourceLocR = coords;\n        ++").concat(l[o-1],";\n        ").concat(c," sourceLocG = coords;\n        ++").concat(l[o-2],";\n        ").concat(c," sourceLocA = coords;\n        --").concat(l[o-1],";\n        ").concat(c," sourceLocB = coords;\n        --").concat(l[o-2],";");const d=["x","y","z","w","u","v"].slice(0,h),p="."+d[h-1],f=d.map(e=>"int "+e),m=pU("sourceLocR",h-1).concat("inIdx.r"),g=pU("sourceLocG",h-1).concat("inIdx.g"),y=pU("sourceLocB",h-1).concat("inIdx.b"),b=pU("sourceLocA",h-1).concat("inIdx.a"),x="max"===n?"greaterThan":"lessThan",v=a?"":"\n          inIdx = round(vec4(getBestIndicesAChannel(".concat(m.join(),"),\n                             getBestIndicesAChannel(").concat(g.join(),"),\n                             getBestIndicesAChannel(").concat(y.join(),"),\n                             getBestIndicesAChannel(").concat(b.join(),")));"),w="vec4(\n            getAChannel(".concat(m.join(),"),\n            hasNextCol ? getAChannel(").concat(g.join(),") : 0.,\n            hasNextRow ? getAChannel(").concat(y.join(),") : 0.,\n            hasNextRow && hasNextCol ? getAChannel(").concat(b.join(),") : 0.)"),k=a?"":"\n      float getBestIndicesAChannel(".concat(f.join(),") {\n        return getChannel(getBestIndicesA(").concat(d.join(),"),\n                                          vec2(").concat(d.slice(-2).join(),"));\n      }");this.userCode="\n      float getAChannel(".concat(f.join(),") {\n        return getChannel(getA(").concat(d.join(),"),\n                               vec2(").concat(d.slice(-2).join(),"));\n      }\n      ").concat(k,"\n      void main() {\n        ").concat(c," coords = getOutputCoords();\n        bool hasNextCol = ").concat(l[o-1]," < ").concat(i[o-1]-1,";\n        bool hasNextRow = ").concat(l[o-2]," < ").concat(i[o-2]-1,";\n        ").concat(u,"\n        ivec4 srcIdx = ivec4(sourceLocR").concat(p,", sourceLocG").concat(p,",\n          sourceLocB").concat(p,", sourceLocA").concat(p,") * ").concat(t,";\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ").concat(w,";\n\n        for (int i = 0; i < ").concat(t,"; i++) {\n          inIdx = srcIdx;\n          ").concat(v,"\n          vec4 candidate = ").concat(w,";\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(").concat(x,"(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    ")}}function PH(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,s=t.shape[0],r=t.shape[1];null!=a&&(s=a.shape[0],r=a.shape[1]);const i=iC(r),o={windowSize:i,inSize:r,batchSize:s,outSize:Math.ceil(r/i)},c=new AH(o,n,null==a),l=[t];null!=a&&l.push(a);const u=e.runWebGLProgram(c,l,"int32");if(1===u.shape[1])return u;const h=PH(e,t,n,u);return e.disposeIntermediateTensorInfo(u),h}function DH(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const s=null!=a?a.shape:t.shape,r=iC(s[s.length-1]),i=new MH(s,r,n,null==a),o=null==a?[t]:[t,a],c=e.runWebGLProgram(i,o,"int32");if(c.shape.length===t.shape.length){const a=DH(e,t,n,c);return e.disposeIntermediateTensorInfo(c),a}return c}function OH(e,t,n,a){const s=[n];if(ev("arg"+a.charAt(0).toUpperCase()+a.slice(1),s,t.shape.length),!eh().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const n=[],r=e.texData.get(t.dataId);let i=t;null!==r&&r.isPacked&&(i=e.unpackTensor(t),n.push(i));const[o,c]=Jx(i.shape,s),l=wu(c),u=aH({inputs:{x:i},backend:e,attrs:{shape:[-1,l]}});n.push(u);const h=PH(e,u,a);n.push(h);const d=aH({inputs:{x:h},backend:e,attrs:{shape:o}});return n.forEach(t=>e.disposeIntermediateTensorInfo(t)),d}return DH(e,t,a)}const FH={kernelName:dh,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{axis:r}=a;let i=Ru(r,s.shape);const o=tv(i,s.shape.length);let c=s;const l=[];null!=o&&(c=pH({inputs:{x:s},backend:n,attrs:{perm:o}}),l.push(c),i=av(i.length,c.shape.length)),ev("argMax",[i[0]],c.shape.length);const u=OH(n,c,i[0],"max");return l.forEach(e=>n.disposeIntermediateTensorInfo(e)),u}};const LH={kernelName:ph,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{axis:r}=a;let i=Ru(r,s.shape);const o=tv(i,s.shape.length);let c=s;const l=[];null!=o&&(c=pH({inputs:{x:s},backend:n,attrs:{perm:o}}),l.push(c),i=av(i.length,c.shape.length)),ev("argMin",[i[0]],c.shape.length);const u=OH(n,c,i[0],"min");return l.forEach(e=>n.disposeIntermediateTensorInfo(e)),u}},zH=KU({opSnippet:wU+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),BH={kernelName:fh,backendName:"webgl",kernelFunc:zH},jH=KU({opSnippet:wU+"return log(x + sqrt(x * x + 1.0));"}),WH={kernelName:mh,backendName:"webgl",kernelFunc:jH},VH=KU({opSnippet:wU+"\n  return atan(x);\n"}),UH={kernelName:gh,backendName:"webgl",kernelFunc:VH},HH=XU({opSnippet:MU+"\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+DU+"\n  return result;\n"}),GH={kernelName:bh,backendName:"webgl",kernelFunc:HH},qH=KU({opSnippet:wU+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),KH={kernelName:yh,backendName:"webgl",kernelFunc:qH};class XH{constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const r=e.filterWidth,i=e.strideHeight,o=e.strideWidth,c=e.dilationHeight,l=e.dilationWidth,u=e.effectiveFilterHeight,h=e.effectiveFilterWidth,d=e.padInfo.top,p=e.padInfo.left;this.outputShape=e.outShape;const f="avg"===t,m="((batch  * ".concat(e.inHeight," + xR) * ").concat(e.inWidth," + xC) * ").concat(e.inChannels," + d"),g="(xR * ".concat(e.inWidth," + xC) * ").concat(e.inChannels," + d");let y="0.0";if(f||(y="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode="\n        const ivec2 strides = ivec2(".concat(i,", ").concat(o,");\n        const ivec2 pads = ivec2(").concat(d,", ").concat(p,");\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ").concat(u,";\n              wR += ").concat(c,") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ").concat(e.inHeight,") {\n              continue;\n            }\n\n            for (int wC = 0; wC < ").concat(h,";\n                wC += ").concat(l,") {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ").concat(t," currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ").concat(a?s?m:g:"wR * ".concat(h," + wC"),";\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      "))}let b="".concat(t,"(").concat(t,"(").concat(t,"(")+"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"avg"===t&&(b="avgValue / max(count, 1.0)");const x=4*Math.floor(r/4),v=r%4,w="\n      if (".concat(f,") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ").concat("max","(values, minMaxValue);\n      }\n    ");this.userCode="\n      const ivec2 strides = ivec2(".concat(i,", ").concat(o,");\n      const ivec2 pads = ivec2(").concat(d,", ").concat(p,");\n      const float initializationValue = ").concat(y,";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ").concat(e.inWidth,") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(").concat(y,");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ").concat(u,";\n            wR += ").concat(c,") {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ").concat(e.inHeight,") {\n            continue;\n          }\n\n          for (int wC = 0; wC < ").concat(x,"; wC += 4) {\n            int xC = xCCorner + wC * ").concat(l,";\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ").concat(l,", d),\n              getValue(batch, xR, xC + 2 * ").concat(l,", d),\n              getValue(batch, xR, xC + 3 * ").concat(l,", d)\n            );\n\n            ").concat(w,"\n          }\n\n          int xC = xCCorner + ").concat(x,";\n          if (").concat(1===v,") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ").concat(w,"\n          } else if (").concat(2===v,") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ").concat(l,", d),\n              initializationValue,\n              initializationValue\n            );\n\n            ").concat(w,"\n          } else if (").concat(3===v,") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ").concat(l,", d),\n              getValue(batch, xR, xC + 2 * ").concat(l,", d),\n              initializationValue\n            );\n\n            ").concat(w,"\n          }\n        }\n        setOutput(").concat(b,");\n      }\n    ")}}class YH{constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const r=e.filterWidth,i=e.strideDepth,o=e.strideHeight,c=e.strideWidth,l=e.dilationDepth,u=e.dilationHeight,h=e.dilationWidth,d=e.effectiveFilterDepth,p=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=e.padInfo.front,g=e.padInfo.top,y=e.padInfo.left;this.outputShape=e.outShape;const b="avg"===t;let x="0.0";if(b||(x="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode="\n        const ivec3 strides =\n            ivec3(".concat(i,", ").concat(o,", ").concat(c,");\n        const ivec3 pads = ivec3(").concat(m,", ").concat(g,", ").concat(y,");\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ").concat(d,";\n              wD += ").concat(l,") {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ").concat(e.inDepth,") {\n              continue;\n            }\n\n            for (int wR = 0; wR < ").concat(p,";\n                wR += ").concat(u,") {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ").concat(e.inHeight,") {\n                continue;\n              }\n\n              for (int wC = 0; wC < ").concat(f,";\n                  wC += ").concat(h,") {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ").concat(t," currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ").concat(a?s?"(((batch * ".concat(e.inDepth," + xD) * ").concat(e.inHeight," + xR) * ").concat(e.inWidth," + xC) * ").concat(e.inChannels," + ch"):"((xD * ".concat(e.inHeight," + xR) * ").concat(e.inWidth," + xC) * ").concat(e.inChannels," + ch"):"wD * ".concat(p," * ").concat(f," +\n                      wR * ").concat(f," + wC"),";\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      "))}let v="".concat(t,"(").concat(t,"(").concat(t,"(")+"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"avg"===t&&(v="avgValue / max(count, 1.0)");const w=4*Math.floor(r/4),k=r%4,S="\n      if (".concat(b,") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ").concat("max","(values, minMaxValue);\n      }\n    ");this.userCode="\n      const ivec3 strides =\n        ivec3(".concat(i,", ").concat(o,", ").concat(c,");\n      const ivec3 pads = ivec3(").concat(m,", ").concat(g,", ").concat(y,");\n      const float initializationValue = ").concat(x,";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ").concat(e.inWidth,") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(").concat(x,");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ").concat(d,";\n            wD += ").concat(l,") {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ").concat(e.inDepth,") {\n            continue;\n          }\n\n          for (int wR = 0; wR < ").concat(p,";\n            wR += ").concat(u,") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ").concat(e.inHeight,") {\n              continue;\n            }\n\n            for (int wC = 0; wC < ").concat(w,"; wC += 4) {\n              int xC = xCCorner + wC * ").concat(h,";\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ").concat(h,", ch),\n                getValue(batch, xD, xR, xC + 2 * ").concat(h,", ch),\n                getValue(batch, xD, xR, xC + 3 * ").concat(h,", ch)\n              );\n\n              ").concat(S,"\n            }\n\n            int xC = xCCorner + ").concat(w,";\n            if (").concat(1===k,") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ").concat(S,"\n            } else if (").concat(2===k,") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ").concat(h,", ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ").concat(S,"\n            } else if (").concat(3===k,") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ").concat(h,", ch),\n                getValue(batch, xD, xR, xC + 2 * ").concat(h,", ch),\n                initializationValue\n              );\n\n              ").concat(S,"\n            }\n          }\n        }\n        setOutput(").concat(v,");\n      }\n    ")}}const QH={kernelName:xh,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t;TW(s,"avgPool");const{filterSize:r,strides:i,pad:o,dimRoundingMode:c}=a;bu(Jb(i,1),()=>"Error in avgPool: Either strides or dilations must be 1. "+"Got strides ".concat(i," and dilations '").concat(1,"'"));const l=Vb(s.shape,r,i,1,o,c);if(1===l.filterWidth&&1===l.filterHeight&&Su(l.inShape,l.outShape))return FU({inputs:{x:s},backend:n});const u=new XH(l,"avg",!1);return n.runWebGLProgram(u,[s],"float32")}};const ZH={kernelName:wh,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{filterSize:r,strides:i,pad:o,dimRoundingMode:c,dataFormat:l}=a,u=Ub(s.shape,r,i,[1,1,1],o,c,l),h=new YH(u,"avg",!1);return n.runWebGLProgram(h,[s],"float32")}};class JH{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,a=e.strideHeight,s=e.strideWidth,r=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterHeight,c=e.effectiveFilterWidth,l=o-1-e.padInfo.top,u=c-1-e.padInfo.left,h=1/(t*n);this.userCode="\n      const ivec2 pads = ivec2(".concat(l,", ").concat(u,");\n      const float avgMultiplier = float(").concat(h,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(o,";\n            wR += ").concat(r,") {\n          float dyR = float(dyRCorner + wR) / ").concat(a,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ").concat(c,";\n            wC+= ").concat(i,") {\n            float dyC = float(dyCCorner + wC) / ").concat(s,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class $H{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,a=e.filterWidth,s=e.strideDepth,r=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,c=e.dilationHeight,l=e.dilationWidth,u=e.effectiveFilterDepth,h=e.effectiveFilterHeight,d=e.effectiveFilterWidth,p=u-1-e.padInfo.front,f=h-1-e.padInfo.top,m=d-1-e.padInfo.left,g=1/(t*n*a);this.userCode="\n      const ivec3 pads = ivec3(".concat(p,", ").concat(f,", ").concat(m,");\n      const float avgMultiplier = float(").concat(g,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ").concat(u,";\n            wD += ").concat(o,") {\n          float dyD = float(dyDCorner + wD) / ").concat(s,".0;\n\n          if (dyD < 0.0 || dyD >= ").concat(e.outDepth,".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ").concat(h,";\n              wR += ").concat(c,") {\n            float dyR = float(dyRCorner + wR) / ").concat(r,".0;\n\n            if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ").concat(d,";\n                wC += ").concat(l,") {\n              float dyC = float(dyCCorner + wC) / ").concat(i,".0;\n\n              if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}const eG={kernelName:kh,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:s,input:r}=t,i=r,{filterSize:o,strides:c,pad:l,dimRoundingMode:u}=a,h=Ub(i.shape,o,c,[1,1,1],l,u),d=new $H(h);return n.runWebGLProgram(d,[s],i.dtype)}};const tG={kernelName:vh,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:s,input:r}=t,i=r;TW([s,r],"avgPoolGrad");const{filterSize:o,strides:c,pad:l}=a,u=Vb(i.shape,o,c,1,l),h=new JH(u);return n.runWebGLProgram(h,[s],i.dtype)}};const nG={kernelName:Sh,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{a:s,b:r}=t,{transposeA:i,transposeB:o}=a;return mH({a:s,b:r,transposeA:i,transposeB:o,backend:n})}};class aG{constructor(e,t,n,a,s,r){this.outputShape=[],this.variableNames=["x","mean","variance"],_y(e,t),_y(e,n);let i="0.0";null!=a&&(_y(e,a),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="1.0";null!=s&&(_y(e,s),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode="\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ".concat(i,";\n        float scale = ").concat(o,";\n        float inv = scale * inversesqrt(variance + float(").concat(r,"));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    ")}}class sG{constructor(e,t,n,a,s,r){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],_y(e,t),_y(e,n);let i="vec4(0.0)";null!=a&&(_y(e,a),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="vec4(1.0)";null!=s&&(_y(e,s),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode="\n      void main() {\n        vec4 offset = ".concat(i,";\n        vec4 scale = ").concat(o,";\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(").concat(r,"));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    ")}}const rG={kernelName:md,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:a}=e;const{x:s,mean:r,variance:i,offset:o,scale:c}=t;bu(r.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),bu(null==o||r.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),bu(null==c||r.shape.length===c.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=a;null==l&&(l=.001);const u=[s,r,i];let h=null;null!=o&&(h=o.shape,u.push(o));let d=null;null!=c&&(d=c.shape,u.push(c));const p=eh().getBool("WEBGL_PACK_NORMALIZATION")?new sG(s.shape,r.shape,i.shape,h,d,l):new aG(s.shape,r.shape,i.shape,h,d,l);return n.runWebGLProgram(p,u,u[0].dtype)}};class iG{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=GW(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=function(e){if(1===e)return"sourceLoc";if(e<=6)return oG.slice(0,e).map(e=>"sourceLoc."+e).join(",");throw Error("Slicing for rank ".concat(e," is not yet supported"))}(this.rank);let a;const s=e.map((e,t)=>"sourceLoc.".concat(oG[t]," = start[").concat(t,"] + coords.").concat(oG[t],";"));a="\n        ".concat(t," sourceLoc;\n        ").concat(t," coords = getOutputCoords();\n        ").concat(s.join("\n"),"\n      "),this.userCode="\n      void main() {\n        ".concat(a,"\n        setOutput(getSource(").concat(n,"));\n      }\n    ")}}const oG=["x","y","z","w","u","v"];class cG{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=GW(this.rank),n=pU("coords",this.rank),a=pU("sourceLoc",this.rank),s=1===this.rank?"sourceLoc":"vec2(".concat(a.slice(-2).join(),")"),r="getChannel(getSource(".concat(a.join(),"), ").concat(s,")"),i="\n      result.x = ".concat(r,";\n      if (++").concat(n[this.rank-1]," < ").concat(e[this.rank-1],") {\n        ++").concat(a[this.rank-1],";\n        result.y = ").concat(r,";\n        --").concat(a[this.rank-1],";\n      }\n    "),o=1===this.rank?"":"\n      --".concat(n[this.rank-1],";\n      if (++").concat(n[this.rank-2]," < ").concat(e[this.rank-2],") {\n        ++").concat(a[this.rank-2],";\n        result.z = ").concat(r,";\n        if (++").concat(n[this.rank-1]," < ").concat(e[this.rank-1],") {\n          ++").concat(a[this.rank-1],";\n          result.w = ").concat(r,";\n        }\n      }\n    "),c=this.rank<=4?"sourceLoc = coords +\n            ".concat(t,"(").concat(e.map((e,t)=>"start[".concat(t,"]")).join(),");"):e.map((e,t)=>"".concat(a[t]," = ").concat(n[t]," + start[").concat(t,"];")).join("\n");this.userCode="\n      void main() {\n        ".concat(t," coords = getOutputCoords();\n        ").concat(t," sourceLoc;\n        ").concat(c,"\n        vec4 result = vec4(0.);\n        ").concat(i,"\n        ").concat(o,"\n        setOutput(result);\n      }\n    ")}}function lG(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{begin:r,size:i}=a,[o,c]=Nb(s,r,i);if(db(s,o,c),0===wu(c))return n.makeTensorInfo(c,s.dtype,[]);if(n.shouldExecuteOnCPU([s])||"string"===s.dtype){const e=n.texData.get(s.dataId),t=ZV(e.values,o,c,s.shape,s.dtype);return n.makeTensorInfo(c,s.dtype,t)}const{isPacked:l}=n.texData.get(s.dataId),u=Cb(s.shape,o,c);if(l||!u){const e=eh().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new cG(c):new iG(c),t=[o];return n.runWebGLProgram(e,[s],s.dtype,t)}return n.uploadToGPU(s.dataId),function(e,t,n,a){const s=a.texData.get(e.dataId),r=a.makeTensorInfo(n,e.dtype),i=a.texData.get(r.dataId);Object.assign(i,s),i.refCount=1,i.shape=n,i.dtype=e.dtype;let o=Ib(t,ju(e.shape));s.slice&&(o+=s.slice.flatOffset),i.slice={flatOffset:o,origDataId:s.slice&&s.slice.origDataId||e.dataId};const c=a.dataRefCount.get(i.slice.origDataId)||1;return a.dataRefCount.set(i.slice.origDataId,c+1),r}(s,o,c,n)}const uG={kernelName:_p,backendName:"webgl",kernelFunc:lG},hG={kernelName:Ch,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{blockShape:r,crops:i}=a;bu(s.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const o=r.reduce((e,t)=>e*t),c=cC(s.shape,r,o),l=lC(c.length,r.length),u=uC(s.shape,r,o),h=hC(i,r.length),d=dC(u,i,r.length),p=[],f=aH({inputs:{x:s},backend:n,attrs:{shape:c}}),m=pH({inputs:{x:f},backend:n,attrs:{perm:l}}),g=aH({inputs:{x:m},backend:n,attrs:{shape:u}}),y=lG({inputs:{x:g},backend:n,attrs:{begin:h,size:d}});return p.push(f),p.push(m),p.push(g),p.forEach(e=>n.disposeIntermediateTensorInfo(e)),y}};const dG={kernelName:Ih,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,weights:r}=t,{size:i}=a,o=n.readSync(s.dataId),c=n.readSync(r.dataId),l=bV(o,c,r.dtype,r.shape,i);return n.makeTensorInfo([i],r.dtype,l)}};const pG={kernelName:Nh,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{a:a,b:s}=t,r=eh().getBool("WEBGL_PACK_BINARY_OPERATIONS"),i=eh().getNumber("WEBGL_VERSION");if(n.shouldExecuteOnCPU([a,s])||1===i){const e=n.texData.get(a.dataId).values,t=n.texData.get(s.dataId).values,[r,i]=vV(a.shape,s.shape,e,t,a.dtype),o=n.makeTensorInfo(i,a.dtype);return n.texData.get(o.dataId).values=r,o}let o;return o=r?new OU("\n  int r = int(a.r) & int(b.r);\n  int g = int(a.g) & int(b.g);\n  int rb = int(a.b) & int(b.b);\n  int ra = int(a.a) & int(b.a);\n  return vec4(r, g, rb, ra);\n",a.shape,s.shape,!1):new PU("\n  return float(int(a.r) & int(b.r));\n",a.shape,s.shape),n.runWebGLProgram(o,[a,s],a.dtype)}};const fG={kernelName:Th,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{s0:a,s1:s}=t,r=n.readSync(a.dataId),i=n.readSync(s.dataId),o=_y(Array.from(r),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}},mG=XU({opSnippet:"return float(a != b);",cpuKernelImpl:WV,dtype:"bool"}),gG={kernelName:Jd,backendName:"webgl",kernelFunc:mG};function yG(e){const{inputs:t,backend:n}=e,{input:a}=t;return FU({inputs:{x:n.texData.get(a.dataId).complexTensorInfos.real},backend:n})}const bG={kernelName:pp,backendName:"webgl",kernelFunc:yG};const xG={kernelName:Eh,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:a,attrs:s}=t,{x:r}=n,{dtype:i}=s;if("complex64"===i){if("complex64"===r.dtype)return FU({inputs:{x:r},backend:a});const t=qv(r.shape),n=e({inputs:{x:r},backend:a,attrs:{dtype:"float32"}}),s=zU({inputs:{real:n,imag:t},backend:a});return t.dispose(),a.disposeIntermediateTensorInfo(n),s}if("complex64"===r.dtype){const t=yG({inputs:{input:r},backend:a}),n=e({inputs:{x:t},backend:a,attrs:{dtype:i}});return a.disposeIntermediateTensorInfo(t),n}if(!Pu(r.dtype,i)){const e=FU({inputs:{x:r},backend:a});return{dataId:e.dataId,shape:e.shape,dtype:i}}if(a.shouldExecuteOnCPU([r])){const e=a.texData.get(r.dataId).values,[t,n,s]=wV(e,r.shape,r.dtype,i);return a.makeTensorInfo(t,n,s)}if("int32"===i)return function(e,t){const n=new vU(e.shape,"return float(int(x));"),a=t.runWebGLProgram(n,[e],"int32");return{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}(r,a);if("bool"===i){const e=a.makeTensorInfo([],"bool",Au("bool",1)),t=mG({inputs:{a:r,b:e},backend:a});return a.disposeIntermediateTensorInfo(e),t}throw new Error("Error in Cast: failed to cast ".concat(r.dtype," to ").concat(i))}},vG="return ceil(x);",wG=KU({opSnippet:vG,packedOpSnippet:vG,cpuKernelImpl:kV}),kG={kernelName:Rh,backendName:"webgl",kernelFunc:wG};class SG{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}class CG{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}const IG={kernelName:_h,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{clipValueMin:r,clipValueMax:i}=a;let o;o=eh().getBool("WEBGL_PACK_CLIP")?new CG(s.shape):new SG(s.shape);const c=[[r],[i]];return n.runWebGLProgram(o,[s],s.dtype,c)}};class NG{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function TG(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}const EG={kernelName:Mh,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t,s=n.texData.get(a.dataId),r=new NG(a.shape),i=[TG(a,s.complexTensorInfos.real),TG(a,s.complexTensorInfos.imag)];return n.runWebGLProgram(r,i,i[0].dtype)}};class RG{constructor(e){this.outputShape=[],this.outputShape=$S(e,1),this.variableNames=e.map((e,t)=>"T".concat(t));const t=new Array(e.length-1);t[0]=e[0][1];for(let r=1;r<t.length;r++)t[r]=t[r-1]+e[r][1];const n=["if (yC < ".concat(t[0],") setOutput(getT0(yR, yC));")];for(let r=1;r<t.length;r++){const e=t[r-1];n.push("else if (yC < ".concat(t[r],") ")+"setOutput(getT".concat(r,"(yR, yC-").concat(e,"));"))}const a=t.length,s=t[t.length-1];n.push("else setOutput(getT".concat(a,"(yR, yC-").concat(s,"));")),this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ".concat(n.join("\n        "),"\n      }\n    ")}}class _G{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=$S(e,t);const n=this.outputShape,a=n.length,s=GW(a),r=pU("coords",a),i=["x","y","z","w","u","v"].slice(0,a);this.variableNames=e.map((e,t)=>"T".concat(t));const o=new Array(e.length-1);o[0]=e[0][t];for(let f=1;f<o.length;f++)o[f]=o[f-1]+e[f][t];const c=i[t],l=i.slice(-2),u=i.join();let h="if (".concat(c," < ").concat(o[0],") {\n        return getChannel(\n            getT0(").concat(u,"), vec2(").concat(l.join(),"));\n        }");for(let f=1;f<o.length;f++){const e=o[f-1];h+="\n        if (".concat(c," < ").concat(o[f],"  && ").concat(c," >= ").concat(o[f-1],") {\n          return getChannel(\n            getT").concat(f,"(").concat(AG(i,c,e),"),\n            vec2(").concat(AG(l,c,e),"));\n        }")}const d=o.length,p=o[o.length-1];h+="\n        return getChannel(\n          getT".concat(d,"(").concat(AG(i,c,p),"),\n          vec2(").concat(AG(l,c,p),"));"),this.userCode="\n      float getValue(".concat(i.map(e=>"int "+e),") {\n        ").concat(h,"\n      }\n\n      void main() {\n        ").concat(s," coords = getOutputCoords();\n        vec4 result = vec4(getValue(").concat(r,"), 0., 0., 0.);\n\n        ").concat(r[a-1]," = ").concat(r[a-1]," + 1;\n        if (").concat(r[a-1]," < ").concat(n[a-1],") {\n          result.g = getValue(").concat(r,");\n        }\n\n        ").concat(r[a-2]," = ").concat(r[a-2]," + 1;\n        if (").concat(r[a-2]," < ").concat(n[a-2],") {\n          result.a = getValue(").concat(r,");\n        }\n\n        ").concat(r[a-1]," = ").concat(r[a-1]," - 1;\n        if (").concat(r[a-2]," < ").concat(n[a-2]," &&\n            ").concat(r[a-1]," < ").concat(n[a-1],") {\n          result.b = getValue(").concat(r,");\n        }\n        setOutput(result);\n      }\n    ")}}function AG(e,t,n){const a=e.indexOf(t);return e.map((e,t)=>t===a?"".concat(e," - ").concat(n):e).join()}function MG(e){const{inputs:t,backend:n}=e,{input:a}=t;return FU({inputs:{x:n.texData.get(a.dataId).complexTensorInfos.imag},backend:n})}const PG={kernelName:kd,backendName:"webgl",kernelFunc:MG};function DG(e,t,n){const a=e[0].dtype;if("complex64"===a){const a=e.map(e=>yG({inputs:{input:e},backend:n})),s=e.map(e=>MG({inputs:{input:e},backend:n})),r=DG(a,t,n),i=DG(s,t,n),o=zU({inputs:{real:r,imag:i},backend:n});return a.forEach(e=>n.disposeIntermediateTensorInfo(e)),s.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(i),o}let s=n.shouldExecuteOnCPU(e);if("string"===a&&(s=!0),s){const s=e.map(e=>{const a=wu(e.shape.slice(t));return aH({inputs:{x:e},backend:n,attrs:{shape:[-1,a]}})}),r=s.map(e=>({vals:n.readSync(e.dataId),shape:e.shape})),i=$S(s.map(e=>e.shape),1),o=1===s[0].shape[0],c=SV(r,i,a,o),l=$S(e.map(e=>e.shape),t),u=n.makeTensorInfo(l,a,c);return s.forEach(e=>n.disposeIntermediateTensorInfo(e)),u}const r=e.filter(e=>wu(e.shape)>0),i=eh().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&r[0].shape.length>1;if(1===r.length){const t=i?new vU(e[0].shape,IU):new NU(e[0].shape,IU);return n.runWebGLProgram(t,e,a)}const o=eh().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(r.length>o){const e=[];for(let s=0;s<r.length;s+=o){const a=r.slice(s,s+o);e.push(DG(a,t,n))}const a=DG(e,t,n);for(const t of e)n.disposeIntermediateTensorInfo(t);return a}if(i){const e=new _G(r.map(e=>e.shape),t);return n.runWebGLProgram(e,r,a)}const{tensors2D:c,outShape:l}=function(e,t,n){const a=$S(e.map(e=>e.shape),t),s=e.map(e=>aH({inputs:{x:e},attrs:{shape:[-1,wu(e.shape.slice(t))]},backend:n}));return{tensors2D:s,outShape:a}}(r,t,n),u=new RG(c.map(e=>e.shape)),h=n.runWebGLProgram(u,c,a);c.forEach(e=>n.disposeIntermediateTensorInfo(e));const d=aH({inputs:{x:h},attrs:{shape:l},backend:n});return n.disposeIntermediateTensorInfo(h),d}function OG(e){const{inputs:t,backend:n,attrs:a}=e,{axis:s}=a,r=Ru(s,t[0].shape)[0];JS(t.map(e=>e.shape),r);const i=$S(t.map(e=>e.shape),r);if(0===wu(i))return n.makeTensorInfo(i,t[0].dtype,[]);const o=t.filter(e=>wu(e.shape)>0);return 1===o.length?FU({inputs:{x:o[0]},backend:n}):DG(o,r,n)}const FG={kernelName:Ph,backendName:"webgl",kernelFunc:OG};class LG{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.outputShape=e.outShape;const r=e.padInfo.top,i=e.padInfo.left,o=e.strideHeight,c=e.strideWidth,l=e.dilationHeight,u=e.dilationWidth,h=e.filterHeight,d=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4,m="channelsLast"===e.dataFormat,g=m?1:2,y=m?2:3,b=m?3:1;let x="",v="";n&&(x=a?"float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ".concat(n,"\n        }"):s?"float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ".concat(n,"\n        }"):"\n          float activation(float x) {\n            ".concat(n,"\n          }\n        "),v="result = activation(result);");const w=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n      ".concat(x,"\n\n      const ivec2 strides = ivec2(").concat(o,", ").concat(c,");\n      const ivec2 pads = ivec2(").concat(r,", ").concat(i,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[").concat(b,"];\n\n        ivec2 xRCCorner =\n            ivec2(coords[").concat(g,"], coords[").concat(y,"]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(h,"; wR++) {\n          int xR = xRCorner + wR * ").concat(l,";\n\n          if (xR < 0 || xR >= ").concat(e.inHeight,") {\n            continue;\n          }\n\n          for (int wC = 0; wC < ").concat(d,"; wC++) {\n            int xC = xCCorner + wC * ").concat(u,";\n\n            if (xC < 0 || xC >= ").concat(e.inWidth,") {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ").concat(p,"; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (").concat(m,") {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (").concat(1===f,") {\n\n              if (").concat(m,") {\n                dotProd +=\n                    getX(batch, xR, xC, ").concat(p,") *\n                    getW(wR, wC, ").concat(p,", d2);\n              } else {\n                dotProd +=\n                    getX(batch, ").concat(p,", xR, xC) *\n                    getW(wR, wC, ").concat(p,", d2);\n              }\n\n            } else if (").concat(2===f,") {\n              vec2 wValues = vec2(\n                getW(wR, wC, ").concat(p,", d2),\n                getW(wR, wC, ").concat(p," + 1, d2)\n              );\n\n              if (").concat(m,") {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ").concat(p,"),\n                  getX(batch, xR, xC, ").concat(p," + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ").concat(p,", xR, xC),\n                  getX(batch, ").concat(p," + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (").concat(3===f,") {\n              vec3 wValues = vec3(\n                getW(wR, wC, ").concat(p,", d2),\n                getW(wR, wC, ").concat(p," + 1, d2),\n                getW(wR, wC, ").concat(p," + 2, d2)\n              );\n\n              if (").concat(m,") {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ").concat(p,"),\n                  getX(batch, xR, xC, ").concat(p," + 1),\n                  getX(batch, xR, xC, ").concat(p," + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ").concat(p,", xR, xC),\n                  getX(batch, ").concat(p," + 1, xR, xC),\n                  getX(batch, ").concat(p," + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ").concat(w,"\n        ").concat(v,"\n        setOutput(result);\n      }\n    ")}}class zG{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,n=e.padInfo.top,a=e.padInfo.left,s=e.strideDepth,r=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,c=e.dilationHeight,l=e.dilationWidth,u=e.filterDepth,h=e.filterHeight,d=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4;this.userCode="\n      const ivec3 strides = ivec3(".concat(s,", ").concat(r,", ").concat(i,");\n      const ivec3 pads = ivec3(").concat(t,", ").concat(n,", ").concat(a,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ").concat(u,"; wF++) {\n          int xF = xFCorner + wF * ").concat(o,";\n\n          if (xF < 0 || xF >= ").concat(e.inDepth,") {\n            continue;\n          }\n\n          for (int wR = 0; wR < ").concat(h,"; wR++) {\n            int xR = xRCorner + wR * ").concat(c,";\n\n            if (xR < 0 || xR >= ").concat(e.inHeight,") {\n              continue;\n            }\n\n            for (int wC = 0; wC < ").concat(d,"; wC++) {\n              int xC = xCCorner + wC * ").concat(l,";\n\n              if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ").concat(p,"; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (").concat(1===f,") {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ").concat(p,") *\n                  getW(wF, wR, wC, ").concat(p,", d2);\n              } else if (").concat(2===f,") {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ").concat(p,"),\n                  getX(batch, xF, xR, xC, ").concat(p," + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ").concat(p,", d2),\n                  getW(wF, wR, wC, ").concat(p," + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (").concat(3===f,") {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ").concat(p,"),\n                  getX(batch, xF, xR, xC, ").concat(p," + 1),\n                  getX(batch, xF, xR, xC, ").concat(p," + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ").concat(p,", d2),\n                  getW(wF, wR, wC, ").concat(p," + 1, d2),\n                  getW(wF, wR, wC, ").concat(p," + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class BG{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=JW(this.outputShape.length);const r=e.padInfo.left,i=e.strideWidth,o=e.dilationWidth,c=e.filterHeight,l=e.filterWidth,u=l;let h="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let m=0;m<l;m++)h+="\n           vec4 xTexelC".concat(2*m,";\n           int xTexelC").concat(2*m,"Ready;\n           vec4 xTexelC").concat(2*m+1,";\n           int xTexelC").concat(2*m+1,"Ready;\n           vec4 xC").concat(m,";");h+="\n     for (int r = 0; r < ".concat(c,"; r++) {\n      for (int d1 = 0; d1 < ").concat(e.inChannels,"; d1 += 2) {\n       ");for(let m=0;m<l;m++)h+="\n           xTexelC".concat(2*m," = vec4(0.0);\n           xTexelC").concat(2*m,"Ready = 0;\n           xTexelC").concat(2*m+1," = vec4(0.0);\n           xTexelC").concat(2*m+1,"Ready = 0;\n           xC").concat(m," = vec4(0.0);");h+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let m=0;m<(u+1)/2;m++){const t=2*m;if(h+="\n           xC = xCCorner + ".concat(t*o,";\n           "),1===i){if(t<l&&(r%2===1?(h+="\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(t,"Ready == 0) {\n                   xTexelC").concat(t," = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC").concat(t,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(t,"Ready = 1;\n                 }\n               "),h+=1===o&&t>0?"\n                 xC".concat(t," = vec4(xTexelC").concat(t-2,".zw, xTexelC").concat(t,".xy);\n                 "):"\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC".concat(t," = vec4(previous.zw, xTexelC").concat(t,".xy);\n                   } else {\n                     xC").concat(t," = vec4(0.0, 0.0, xTexelC").concat(t,".xy);\n                   }\n                   ")):h+="\n                 if (xC >= 0 && xC < inDims[1] && xTexelC".concat(t,"Ready == 0) {\n                   xTexelC").concat(t," = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC").concat(t,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(t,"Ready = 1;\n                 }\n\n                 xC").concat(t," = xTexelC").concat(t,";\n                 "),t+1<l)){const e=r%2===0?mu(o):o;o%2===0&&r%2===1||o%2!==0&&r%2!==1?(h+="\n                   xCOffset = xC + imod(pads[1], 2) + ".concat(e,";\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(t+1,"Ready == 0) {\n                     xTexelC").concat(t+1," = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC").concat(t+1,".zw = vec2(0.0);\n                     }\n                     xTexelC").concat(t+1,"Ready = 1;\n                   }\n                   "),h+=o>1?"\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC".concat(t+1," = vec4(previous.zw, xTexelC").concat(t+1,".xy);\n                     } else {\n                      xC").concat(t+1," = vec4(0.0, 0.0, xTexelC").concat(t+1,".xy);\n                     }\n                     "):"\n                     xC".concat(t+1," = vec4(xTexelC").concat(t,".zw, xTexelC").concat(t+1,".xy);\n                     ")):h+=1===e?"\n                     xC".concat(t+1," = xTexelC").concat(t,";\n                     "):"\n                     xCOffset = xC + ".concat(e,";\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(t+1,"Ready == 0) {\n                       xTexelC").concat(t+1," = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC").concat(t+1,".zw = vec2(0.0);\n                       }\n                       xTexelC").concat(t+1,"Ready = 1;\n                     }\n\n                     xC").concat(t+1," = xTexelC").concat(t+1,";\n                     ")}}else t<l&&(r%2===1?(h+="\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(t,"Ready == 0) {\n                   xTexelC").concat(t," = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC").concat(t,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(t,"Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC").concat(t+1,"Ready == 0) {\n                   xTexelC").concat(t+1," = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC").concat(t+1,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(t+1,"Ready = 1;\n                 }\n\n                 xC").concat(t," = vec4(xTexelC").concat(t,".zw, xTexelC").concat(t+1,".zw);\n               "),t+1<l&&(h+="\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC".concat(t+1," = vec4(xTexelC").concat(t+1,".xy, final.xy);\n                 "))):(h+="\n                 if(xC >= 0 && xC < inDims[1] && xTexelC".concat(t,"Ready == 0) {\n                   xTexelC").concat(t," = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC").concat(t,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(t,"Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(t+1,"Ready == 0) {\n                   xTexelC").concat(t+1," = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC").concat(t+1,".zw = vec2(0.);\n                   }\n                   xTexelC").concat(t+1,"Ready = 1;\n                 }\n\n                 xC").concat(t," = vec4(\n                   xTexelC").concat(t,".xy, xTexelC").concat(t+1,".xy);\n               "),t+1<l&&(h+="\n                   xC".concat(t+1," = vec4(xTexelC").concat(t,".zw, xTexelC").concat(t+1,".zw);\n                 "))));t<l&&(h+="\n             wTexel = getW(r, ".concat(t,", d1, d2);\n             dotProd += xC").concat(t,".xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ").concat(e.inChannels,") {\n               dotProd += xC").concat(t,".yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           "),t+1<l&&(h+="\n               wTexel = getW(r, ".concat(t+1,", d1, d2);\n               dotProd += xC").concat(t+1,".xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ").concat(e.inChannels,") {\n                 dotProd += xC").concat(t+1,".yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             ")))}h+="\n     }\n   ",h+="\n     }\n   ",h+="\n     }\n   ";let d="",p="";n&&(d=a?"vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ".concat(n,"\n         }"):s?"vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ".concat(n,"\n         }"):"vec4 activation(vec4 x) {\n           ".concat(n,"\n         }"),p="result = activation(result);");const f=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n       ".concat(d,"\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ").concat(h,"\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ").concat(f,"\n         ").concat(p,"\n         setOutput(result);\n       }\n     ")}}class jG{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=JW(this.outputShape.length);const{dataFormat:n}=t,a=RW(),s="channelsLast"===n,r=s?1:2,i=s?2:3,o=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":"if(blockIndex < ".concat(e[2]," && pos < ").concat(e[1],") {");let c="";for(let l=0;l<=1;l++)for(let e=0;e<=1;e++)c+="\n          blockIndex = rc.z + ".concat(e,";\n          pos = rc.y + ").concat(l,";\n\n          ").concat(o,"\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[").concat(r,"] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[").concat(i,"] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (").concat(s,") {\n                  innerDims = vec2(d1, ch);\n                  result[").concat(2*l+e,"] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[").concat(2*l+e,"] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        ");this.userCode="\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ".concat(c,"\n\n        ").concat(a.output," = result;\n      }\n    ")}}function WG(e,t){const n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&1===n&&e[0]>1?[e[0],1]:null}function VG(e){let{x:t,filter:n,convInfo:a,backend:s,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:c=null}=e;const l=t.shape,u=s.texData.get(t.dataId),h=a.inChannels,d=l[0]*l[1]*l[2],p=a.outChannels,f="channelsLast"===a.dataFormat,m=!1;let g;const y=[];if(null!=i){const e=WG(i.shape,f);null!=e&&(i=aH({inputs:{x:i},backend:s,attrs:{shape:e}}),y.push(i))}if(null!=r){const e=WG(r.shape,f);null!=e&&(r=aH({inputs:{x:r},backend:s,attrs:{shape:e}}),y.push(r))}if(!((1===d||1===p)&&h>1e3)&&u.isPacked&&f&&null!=u.texture&&l[2]%2!==0&&Su(u.shape.slice(-3),l.slice(-3))){const e=l[0]*l[1]*(l[2]+1),h={dataId:t.dataId,shape:[1,e,a.inChannels],dtype:t.dtype},d=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,bu(vW(u.shape,h.shape),()=>"packed reshape ".concat(u.shape," to ").concat(h.shape," isn't free"));const p=aH({inputs:{x:n},backend:s,attrs:{shape:[1,a.inChannels,a.outChannels]}});y.push(p);const f=mH({a:h,b:p,backend:s,transposeA:false,transposeB:m,bias:r,activation:c,preluActivationWeights:i,leakyreluAlpha:o}),b=s.texData.get(f.dataId);bu(b.isPacked,()=>"batchMatMul result is expected to be packed"),u.shape=d,b.shape=a.outShape,g=FU({inputs:{x:f},backend:s}),g.shape=a.outShape,y.push(f)}else{const e=a.outHeight*a.outWidth,l=aH({inputs:{x:t},backend:s,attrs:{shape:f?[a.batchSize,e,a.inChannels]:[a.batchSize,a.inChannels,e]}}),u=aH({inputs:{x:n},backend:s,attrs:{shape:[1,a.inChannels,a.outChannels]}}),h=mH({a:f?l:u,b:f?u:l,transposeA:!f,transposeB:m,backend:s,bias:r,activation:c,preluActivationWeights:i,leakyreluAlpha:o});g=aH({inputs:{x:h},backend:s,attrs:{shape:a.outShape}}),y.push(l),y.push(u),y.push(h)}for(const b of y)s.disposeIntermediateTensorInfo(b);return g}function UG(e){let{x:t,filter:n,convInfo:a,backend:s,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:c=null}=e;const{filterWidth:l,filterHeight:u,inChannels:h,outWidth:d,outHeight:p,dataFormat:f}=a,m="channelsLast"===f,g=l*u*h,y=p*d,b=[a.batchSize,g,y],x=[];if(null!=i){const e=WG(i.shape,m);null!=e&&(i=aH({inputs:{x:i},backend:s,attrs:{shape:e}}),x.push(i))}if(null!=r){const e=WG(r.shape,m);null!=e&&(r=aH({inputs:{x:r},backend:s,attrs:{shape:e}}),x.push(r))}const v=aH({inputs:{x:n},backend:s,attrs:{shape:[1,g,wu(n.shape)/g]}});x.push(v);const w=new jG(b,a),k=[t.shape,[a.padInfo.top,a.padInfo.left],[a.strideHeight,a.strideWidth],[a.dilationHeight,a.dilationWidth],[a.inChannels],[a.filterWidth*a.inChannels],[a.outWidth]],S=s.runWebGLProgram(w,[t],"float32",k),C=aH({inputs:{x:S},backend:s,attrs:{shape:b}});x.push(S),x.push(C);const I=null!=r,N=null!=i,T="leakyrelu"===c,E=c?YU(c,!0):null,R=new QU(m?C.shape:v.shape,m?v.shape:C.shape,m?[a.batchSize,y,a.outChannels]:[a.batchSize,a.outChannels,y],!0,!1,I,E,N,T),_=m?[C,v]:[v,C];if(r&&_.push(r),N&&_.push(i),T){const e=s.makeTensorInfo([],"float32",Vf(o,"float32"));_.push(e),x.push(e)}const A=s.runWebGLProgram(R,_,"float32"),M=aH({inputs:{x:A},backend:s,attrs:{shape:a.outShape}});x.push(A);for(const P of x)s.disposeIntermediateTensorInfo(P);return M}const HG={kernelName:Dh,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,filter:r}=t,{strides:i,pad:o,dataFormat:c,dilations:l,dimRoundingMode:u}=a,h=ex(c),d=Hb(s.shape,r.shape,i,l,o,u,!1,h);let p;if(1!==d.filterHeight||1!==d.filterWidth||1!==d.dilationHeight||1!==d.dilationWidth||1!==d.strideHeight||1!==d.strideWidth||"SAME"!==d.padInfo.type&&"VALID"!==d.padInfo.type)if(d.strideWidth<=2&&"channelsLast"===h&&eh().getBool("WEBGL_EXP_CONV")){const e=new BG(d),t=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];p=n.runWebGLProgram(e,[s,r],"float32",t)}else if(eh().getBool("WEBGL_CONV_IM2COL"))p=UG({x:s,filter:r,convInfo:d,backend:n});else{const e=new LG(d);p=n.runWebGLProgram(e,[s,r],"float32")}else p=VG({x:s,filter:r,convInfo:d,backend:n});const f=aH({inputs:{x:p},backend:n,attrs:{shape:d.outShape}});return n.disposeIntermediateTensorInfo(p),f}};class GG{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,a=e.padInfo.top,s=e.padInfo.left,r="channelsLast"===e.dataFormat;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ".concat(e.batchSize,"; b++) {\n          for (int yR = 0; yR < ").concat(e.outHeight,"; yR++) {\n            int xR = wR + yR * ").concat(t," - ").concat(a,";\n\n            if (xR < 0 || xR >= ").concat(e.inHeight,") {\n              continue;\n            }\n\n            for (int yC = 0; yC < ").concat(e.outWidth,"; yC++) {\n              int xC = wC + yC * ").concat(n," - ").concat(s,";\n\n              if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                continue;\n              }\n\n              ").concat(r?"float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);":"float dyValue = getDy(b, d2, yR, yC);\n              float xValue = getX(b, d1, xR, xC);\n              dotProd += (xValue * dyValue);","\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class qG{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,a=e.strideHeight,s=e.strideWidth,r="channelsLast"===e.dataFormat,i=t-1-e.padInfo.top,o=n-1-e.padInfo.left,c=r?1:2,l=r?2:3,u=r?3:1;this.userCode="\n      const ivec2 pads = ivec2(".concat(i,", ").concat(o,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[").concat(u,"];\n\n        ivec2 dyCorner = ivec2(coords[").concat(c,"], coords[").concat(l,"]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(t,"; wR++) {\n          float dyR = float(dyRCorner + wR) / ").concat(a,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ").concat(t," - 1 - wR;\n\n          for (int wC = 0; wC < ").concat(n,"; wC++) {\n            float dyC = float(dyCCorner + wC) / ").concat(s,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ").concat(n," - 1 - wC;\n\n            for (int d2 = 0; d2 < ").concat(e.outChannels,"; d2++) {\n\n              if (").concat(r,") {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class KG{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,n=e.strideHeight,a=e.strideWidth,s=e.padInfo.front,r=e.padInfo.top,i=e.padInfo.left;this.userCode="\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ".concat(e.batchSize,"; b++) {\n          for (int yF = 0; yF < ").concat(e.outDepth,"; yF++) {\n            int xF = wF + yF * ").concat(t," - ").concat(s,";\n\n            if (xF < 0 || xF >= ").concat(e.inDepth,") {\n              continue;\n            }\n\n            for (int yR = 0; yR < ").concat(e.outHeight,"; yR++) {\n              int xR = wR + yR * ").concat(n," - ").concat(r,";\n\n              if (xR < 0 || xR >= ").concat(e.inHeight,") {\n                continue;\n              }\n\n              for (int yC = 0; yC < ").concat(e.outWidth,"; yC++) {\n                int xC = wC + yC * ").concat(a," - ").concat(i,";\n\n                if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class XG{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,a=e.filterWidth,s=e.strideDepth,r=e.strideHeight,i=e.strideWidth,o=t-1-e.padInfo.front,c=n-1-e.padInfo.top,l=a-1-e.padInfo.left;this.userCode="\n      const ivec3 pads = ivec3(".concat(o,", ").concat(c,", ").concat(l,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ").concat(t,"; wF++) {\n          float dyF = float(dyFCorner + wF) / ").concat(s,".0;\n\n          if (dyF < 0.0 || dyF >= ").concat(e.outDepth,".0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ").concat(t," - 1 - wF;\n\n          for (int wR = 0; wR < ").concat(n,"; wR++) {\n            float dyR = float(dyRCorner + wR) / ").concat(r,".0;\n\n            if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ").concat(n," - 1 - wR;\n\n            for (int wC = 0; wC < ").concat(a,"; wC++) {\n              float dyC = float(dyCCorner + wC) / ").concat(i,".0;\n\n              if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ").concat(a," - 1 - wC;\n\n              for (int d2 = 0; d2 < ").concat(e.outChannels,"; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}const YG={kernelName:Oh,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,dy:r}=t,{strides:i,pad:o,dataFormat:c,dimRoundingMode:l,filterShape:u}=a,h=ex(c),d=Hb(s.shape,u,i,1,o,l,!1,h),p=new GG(d);return n.runWebGLProgram(p,[s,r],"float32")}};class QG{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=JW(this.outputShape.length);const t=e.filterHeight,n=e.filterWidth,a=t-1-e.padInfo.top,s=n-1-e.padInfo.left;this.userCode="\n      const ivec2 pads = ivec2(".concat(a,", ").concat(s,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        vec4 result = vec4(0.);\n        for (int wR = 0; wR < ").concat(t,"; wR++) {\n          float dyR = float(dyRCorner + wR) / strides[0];\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n          int wRPerm = ").concat(t," - 1 - wR;\n\n          for (int wC = 0; wC < ").concat(n,"; wC++) {\n            int wCPerm = ").concat(n," - 1 - wC;\n\n            float dyC = float(dyCCorner + wC) / strides[1];\n            bool idyCVal = (dyC >= 0.0) && (dyC < ").concat(e.outWidth,".0)\n              && (fract(dyC) == 0.0);\n            int idyC = int(dyC);\n\n            float dyC2 = float(dyCCorner + wC + 1) / strides[1];\n            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ").concat(e.outWidth,".0)\n              && (fract(dyC2) == 0.0);\n            int idyC2 = int(dyC2);\n\n            if (idyCVal && idyCVal2) {\n              for (int d2 = 0; d2 < ").concat(e.outChannels,"; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?\n                  dySample : getDy(batch, idyR, idyC2, d2);\n\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n\n                dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample2.xy : dySample2.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal) {\n              for (int d2 = 0; d2 < ").concat(e.outChannels,"; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal2) {\n              for (int d2 = 0; d2 < ").concat(e.outChannels,"; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC2, d2);\n                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            }\n          }\n        }\n        setOutput(result);\n      }\n    ")}}const ZG={kernelName:Fh,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:s,filter:r}=t,{inputShape:i,strides:o,pad:c,dataFormat:l,dimRoundingMode:u}=a,h=ex(l),d=Hb(i,r.shape,o,1,c,u,!1,h);if(eh().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&"channelsLast"===h){const e=[[d.strideHeight,d.strideWidth]],t=new QG(d);return n.runWebGLProgram(t,[s,r],"float32",e)}{const e=new qG(d);return n.runWebGLProgram(e,[s,r],"float32")}}};const JG={kernelName:Lh,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,filter:r}=t,{strides:i,pad:o,dilations:c}=a,l=Gb(s.shape,r.shape,i,c,o),u=new zG(l);return n.runWebGLProgram(u,[s,r],"float32")}};const $G={kernelName:zh,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,dy:r}=t,{strides:i,pad:o,filterShape:c}=a,l=Gb(s.shape,c,i,1,o),u=new KG(l);return n.runWebGLProgram(u,[s,r],"float32")}};const eq={kernelName:Bh,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:s,filter:r}=t,{pad:i,strides:o,inputShape:c}=a,l=Gb(c,r.shape,o,1,i),u=new XG(l);return n.runWebGLProgram(u,[s,r],"float32")}},tq=KU({opSnippet:qU+"\n  return cos(x);\n",packedOpSnippet:"\n  vec4 result = cos(x);\n  bvec4 isNaN = isnan(x);\n  ".concat(DU,"\n  return result;\n")}),nq={kernelName:jh,backendName:"webgl",kernelFunc:tq},aq=KU({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),sq={kernelName:Wh,backendName:"webgl",kernelFunc:aq};class rq{constructor(e,t,n,a,s){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[r,i,o,c]=e,[l]=t,[u,h]=n;this.outputShape=[l,u,h,c];const d="bilinear"===a?1:0,[p,f]=["".concat(i-1,".0"),"".concat(o-1,".0")],[m,g,y]=u>1?["".concat((i-1)/(u-1)),"(y2-y1) * height_ratio","y1*".concat(p," + float(y)*(height_scale)")]:["0.0","0.0","0.5 * (y1+y2) * ".concat(p)],[b,x,v]=h>1?["".concat((o-1)/(h-1)),"(x2-x1) * width_ratio","x1*".concat(f," + float(x)*(width_scale)")]:["0.0","0.0","0.5 * (x1+x2) * ".concat(f)];this.userCode="\n      const float height_ratio = float(".concat(m,");\n      const float width_ratio = float(").concat(b,");\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ").concat(r,") {\n          return;\n        }\n\n        float height_scale = ").concat(g,";\n        float width_scale = ").concat(x,";\n\n        float in_y = ").concat(y,";\n        if( in_y < 0.0 || in_y > ").concat(p," ) {\n          setOutput(float(").concat(s,"));\n          return;\n        }\n        float in_x = ").concat(v,";\n        if( in_x < 0.0 || in_x > ").concat(f," ) {\n          setOutput(float(").concat(s,"));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(").concat(d," == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    ")}}const iq={kernelName:Hh,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{image:s,boxes:r,boxInd:i}=t,{cropSize:o,method:c,extrapolationValue:l}=a,u=new rq(s.shape,r.shape,o,c,l);return n.runWebGLProgram(u,[s,r,i],"float32")}};var oq;!function(e){e.Prod="*",e.Sum="+"}(oq||(oq={}));class cq{constructor(e,t,n,a){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const s=this.outputShape.length,r=this.op===oq.Prod?"1.0":"0.0",i=n?r:"getX(".concat(lq(s,"coords",this.op),")"),o=this.outputShape[this.outputShape.length-1];let c="",l="";n?(c=a?"end != ".concat(o-1):"end != 0",l=a?"end + 1":"end - 1"):(c=a?"end + pow2 < ".concat(o):"end >= pow2",l=a?"end + pow2":"end - pow2"),this.userCode="\n      void main() {\n        ".concat(GW(s)," coords = getOutputCoords();\n        int end = ").concat(uq(s,"coords",this.op),";\n        float val = ").concat(i,";\n        int pow2 = int(pow(2.0, index));\n        if (").concat(c,") {\n          int idx = ").concat(l,";\n          ").concat(uq(s,"coords",this.op)," = idx;\n          val ").concat(this.op,"= getX(").concat(lq(s,"coords",this.op),");\n        }\n        setOutput(val);\n      }\n    ")}}function lq(e,t,n){if(1===e)return"".concat(t);if(2===e)return"".concat(t,".x, ").concat(t,".y");if(3===e)return"".concat(t,".x, ").concat(t,".y, ").concat(t,".z");if(4===e)return"".concat(t,".x, ").concat(t,".y, ").concat(t,".z, ").concat(t,".w");throw new Error("Cumulative ".concat(n," for rank ").concat(e," is not yet supported"))}function uq(e,t,n){if(1===e)return"".concat(t);if(2===e)return"".concat(t,".y");if(3===e)return"".concat(t,".z");if(4===e)return"".concat(t,".w");throw new Error("Cumulative ".concat(n," for rank ").concat(e," is not yet supported"))}function hq(e,t,n,a,s,r){const i=t.shape.length,o=tv([a],i);let c=t;null!=o&&(c=pH({inputs:{x:t},backend:n,attrs:{perm:o}}));const l=av(1,i)[0];if(l!==i-1)throw new Error("WebGL cumprod shader expects an inner-most axis=".concat(t.shape.length-1," ")+"but got axis=".concat(a));const u=c.shape[l];let h=FU({inputs:{x:c},backend:n});for(let d=0;d<=Math.ceil(Math.log2(u))-1;d++){const t=new cq(e,c.shape,!1,r),a=[[d]],s=h;h=n.runWebGLProgram(t,[h],h.dtype,a),n.disposeIntermediateTensorInfo(s)}if(s){const t=new cq(e,c.shape,s,r),a=h;h=n.runWebGLProgram(t,[h],h.dtype),n.disposeIntermediateTensorInfo(a)}if(null!=o){const e=pH({inputs:{x:h},backend:n,attrs:{perm:nv(o)}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(c),e}return h}const dq={kernelName:Vh,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{axis:r,exclusive:i,reverse:o}=a;return hq(oq.Prod,s,n,r,i,o)}};const pq={kernelName:Uh,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{axis:r,exclusive:i,reverse:o}=a;return hq(oq.Sum,s,n,r,i,o)}};const fq={kernelName:Gh,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,weights:r}=t,{size:i,binaryOutput:o}=a;if(1===s.shape.length){const e=n.readSync(s.dataId),t=n.readSync(r.dataId),a=bV(e,t,r.dtype,r.shape,i);return n.makeTensorInfo([i],r.dtype,a)}if(2===s.shape.length){const e=n.bufferSync(s),t=n.bufferSync(r),a=xV(e,t,i,o);return n.makeTensorInfo(a.shape,r.dtype,a.values)}throw new Error("Error in denseBincount: input must be at most rank 2, but got rank"+"".concat(s.shape.length,"."))}};class mq{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode="\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ".concat(this.getHeightCoordString(),";\n      int w = ").concat(this.getWidthCoordString(),";\n      int d = ").concat(this.getDepthCoordString(),";\n\n      int in_h = h / ").concat(t,";\n      int offset_h = imod(h, ").concat(t,");\n      int in_w = w / ").concat(t,";\n      int offset_w = imod(w, ").concat(t,");\n      int offset_d = (offset_h * ").concat(t," + offset_w) *\n        ").concat(this.getOutputDepthSize(),";\n      int in_d = d + offset_d;\n\n      float result = ").concat(this.getInputSamplingString(),";\n      setOutput(result);\n    }\n  ")}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const gq={kernelName:qh,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{blockSize:r,dataFormat:i}=a,o=s.shape[0],c=("NHWC"===i?s.shape[1]:s.shape[2])*r,l=("NHWC"===i?s.shape[2]:s.shape[3])*r,u=("NHWC"===i?s.shape[3]:s.shape[1])/(r*r),h=new mq("NHWC"===i?[o,c,l,u]:[o,u,c,l],r,i);return n.runWebGLProgram(h,[s],s.dtype)}};class yq{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=JW(this.outputShape.length);const r=e.filterHeight,i=e.filterWidth,o=e.outChannels/e.inChannels;let c="",l="";n&&(c=a?"float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ".concat(n,"\n        }"):s?"float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ".concat(n,"\n        }"):"\n          float activation(float x) {\n            ".concat(n,"\n          }\n        "),l="result = activation(result);");const u=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n      ".concat(c,"\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ").concat(o,";\n        int q = d2 - d1 * ").concat(o,";\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ").concat(r,"; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ").concat(i,"; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ").concat(u,"\n        ").concat(l,"\n        setOutput(result);\n      }\n    ")}}class bq{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=JW(this.outputShape.length);const r=e.outChannels/e.inChannels,i=e.padInfo.left,o=e.strideWidth,c=e.dilationWidth,l=e.filterHeight,u=e.filterWidth,h=u;let d="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let g=0;g<u;g++)d+="\n          vec4 xTexelC".concat(2*g,";\n          int xTexelC").concat(2*g,"Ready;\n          vec4 xTexelC").concat(2*g+1,";\n          int xTexelC").concat(2*g+1,"Ready;\n          vec4 xC").concat(g,";");d+="\n    for (int r = 0; r < ".concat(l,"; r++) {\n      ");for(let g=0;g<u;g++)d+="\n          xTexelC".concat(2*g," = vec4(0.0);\n          xTexelC").concat(2*g,"Ready = 0;\n          xTexelC").concat(2*g+1," = vec4(0.0);\n          xTexelC").concat(2*g+1,"Ready = 0;\n          xC").concat(g," = vec4(0.0);");d+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let g=0;g<(h+1)/2;g++){const e=2*g;if(d+="\n          xC = xCCorner + ".concat(e*c,";\n          "),1===o){if(e<u&&(i%2===1?(d+="\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(e,"Ready == 0) {\n                  xTexelC").concat(e," = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC").concat(e,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(e,"Ready = 1;\n                }\n              "),d+=1===c&&e>0?"\n                xC".concat(e," = vec4(xTexelC").concat(e-2,".zw, xTexelC").concat(e,".xy);\n                "):"\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC".concat(e," = vec4(previous.zw, xTexelC").concat(e,".xy);\n                  } else {\n                    xC").concat(e," = vec4(0.0, 0.0, xTexelC").concat(e,".xy);\n                  }\n                  ")):d+="\n                if (xC >= 0 && xC < inDims[1] && xTexelC".concat(e,"Ready == 0) {\n                  xTexelC").concat(e," = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC").concat(e,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(e,"Ready = 1;\n                }\n\n                xC").concat(e," = xTexelC").concat(e,";\n                "),e+1<u)){const t=i%2===0?mu(c):c;c%2===0&&i%2===1||c%2!==0&&i%2!==1?(d+="\n                  xCOffset = xC + imod(pads[1], 2) + ".concat(t,";\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(e+1,"Ready == 0) {\n                    xTexelC").concat(e+1," = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC").concat(e+1,".zw = vec2(0.0);\n                    }\n                    xTexelC").concat(e+1,"Ready = 1;\n                  }\n                  "),d+=c>1?"\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC".concat(e+1," = vec4(previous.zw, xTexelC").concat(e+1,".xy);\n                    } else {\n                     xC").concat(e+1," = vec4(0.0, 0.0, xTexelC").concat(e+1,".xy);\n                    }\n                    "):"\n                    xC".concat(e+1," = vec4(xTexelC").concat(e,".zw, xTexelC").concat(e+1,".xy);\n                    ")):d+=1===t?"\n                    xC".concat(e+1," = xTexelC").concat(e,";\n                    "):"\n                    xCOffset = xC + ".concat(t,";\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(e+1,"Ready == 0) {\n                      xTexelC").concat(e+1," = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC").concat(e+1,".zw = vec2(0.0);\n                      }\n                      xTexelC").concat(e+1,"Ready = 1;\n                    }\n\n                    xC").concat(e+1," = xTexelC").concat(e+1,";\n                    ")}}else e<u&&(i%2===1?(d+="\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(e,"Ready == 0) {\n                  xTexelC").concat(e," = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC").concat(e,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(e,"Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC").concat(e+1,"Ready == 0) {\n                  xTexelC").concat(e+1," = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC").concat(e+1,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(e+1,"Ready = 1;\n                }\n\n                xC").concat(e," = vec4(xTexelC").concat(e,".zw, xTexelC").concat(e+1,".zw);\n              "),e+1<u&&(d+="\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC".concat(e+1," = vec4(xTexelC").concat(e+1,".xy, final.xy);\n                "))):(d+="\n                if(xC >= 0 && xC < inDims[1] && xTexelC".concat(e,"Ready == 0) {\n                  xTexelC").concat(e," = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC").concat(e,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(e,"Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(e+1,"Ready == 0) {\n                  xTexelC").concat(e+1," = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC").concat(e+1,".zw = vec2(0.);\n                  }\n                  xTexelC").concat(e+1,"Ready = 1;\n                }\n\n                xC").concat(e," = vec4(\n                  xTexelC").concat(e,".xy, xTexelC").concat(e+1,".xy);\n              "),e+1<u&&(d+="\n                  xC".concat(e+1," = vec4(xTexelC").concat(e,".zw, xTexelC").concat(e+1,".zw);\n                "))));e<u&&(d+="\n            wTexel = getW(r, ".concat(e,", d1, q);\n            dotProd += xC").concat(e," * vec4(wTexel.xz, wTexel.xz);\n          "),e+1<u&&(d+="\n              wTexel = getW(r, ".concat(e+1,", d1, q);\n              dotProd += xC").concat(e+1," * vec4(wTexel.xz, wTexel.xz);\n            ")))}d+="\n    }\n  ",d+="\n      }\n    ";let p="",f="";n&&(p=a?"vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ".concat(n,"\n        }"):s?"vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ".concat(n,"\n        }"):"vec4 activation(vec4 x) {\n          ".concat(n,"\n        }"),f="result = activation(result);");const m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n      ".concat(p,"\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ").concat(r,";\n        int q = d2 - d1 * ").concat(r,";\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ").concat(d,"\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ").concat(m,"\n        ").concat(f,"\n        setOutput(result);\n      }\n    ")}}const xq={kernelName:Kh,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,filter:r}=t,{strides:i,pad:o,dilations:c,dimRoundingMode:l}=a;let u=c;null==u&&(u=[1,1]),bu(Jb(i,u),()=>"Error in depthwiseConv2d: Either strides or dilations must be "+"1. Got strides ".concat(i," and dilations '").concat(u,"'"));const h=Hb(s.shape,r.shape,i,u,o,l,!0);let d;d=eh().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels===1?new bq(h):new yq(h);const p=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];return n.runWebGLProgram(d,[s,r],"float32",p)}};class vq{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,a=e.padInfo.top,s=e.padInfo.left,r=e.outChannels/e.inChannels;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ".concat(r," + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ").concat(e.batchSize,"; b++) {\n          for (int yR = 0; yR < ").concat(e.outHeight,"; yR++) {\n            int xR = wR + yR * ").concat(t," - ").concat(a,";\n\n            if (xR < 0 || xR >= ").concat(e.inHeight,") {\n              continue;\n            }\n\n            for (int yC = 0; yC < ").concat(e.outWidth,"; yC++) {\n              int xC = wC + yC * ").concat(n," - ").concat(s,";\n\n              if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class wq{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,a=e.strideHeight,s=e.strideWidth,r=t-1-e.padInfo.top,i=n-1-e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode="\n      const ivec2 pads = ivec2(".concat(r,", ").concat(i,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ").concat(t,"; wR++) {\n          float dyR = float(dyRCorner + wR) / ").concat(a,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ").concat(t," - 1 - wR;\n\n          for (int wC = 0; wC < ").concat(n,"; wC++) {\n            float dyC = float(dyCCorner + wC) / ").concat(s,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ").concat(n," - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ").concat(o,"; dm++) {\n              int d2 = d1 * ").concat(o," + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}const kq={kernelName:Xh,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,dy:r}=t,{strides:i,dilations:o,pad:c,dimRoundingMode:l,filterShape:u}=a,h=Hb(s.shape,u,i,o,c,l,!0),d=new vq(h);return n.runWebGLProgram(d,[s,r],"float32")}};const Sq={kernelName:Yh,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:s,filter:r}=t,{strides:i,dilations:o,pad:c,dimRoundingMode:l,inputShape:u}=a,h=Hb(u,r.shape,i,o,c,l,!0),d=new wq(h);return n.runWebGLProgram(d,[s,r],"float32")}};class Cq{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const Iq={kernelName:Qh,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t,s=[...a.shape,...a.shape],r=wu(a.shape),i=aH({inputs:{x:a},backend:n,attrs:{shape:[r]}}),o=new Cq(r),c=n.runWebGLProgram(o,[i],i.dtype),l=aH({inputs:{x:c},backend:n,attrs:{shape:s}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(c),l}};class Nq{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:n,padInfo:a,strideHeight:s,strideWidth:r,filterHeight:i,filterWidth:o,dilationHeight:c,dilationWidth:l}=e,{top:u,left:h}=a;this.userCode="\n      const ivec2 strides = ivec2(".concat(s,", ").concat(r,");\n      const ivec2 pads = ivec2(").concat(u,", ").concat(h,");\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ").concat(i,"; h++) {\n          int hIn = hBeg + h * ").concat(c,";\n\n          if (hIn >= 0 && hIn < ").concat(t,") {\n            for (int w = 0; w < ").concat(o,"; w++) {\n              int wIn = wBeg + w * ").concat(l,";\n\n              if (wIn >= 0 && wIn < ").concat(n,") {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    ")}}const Tq={kernelName:Zh,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,filter:r}=t,{strides:i,pad:o,dilations:c}=a,l=Wb(s.shape,r.shape,i,o,"NHWC",c);let u;const h=new Nq(l);u=n.runWebGLProgram(h,[s,r],"float32");const d=aH({inputs:{x:u},backend:n,attrs:{shape:l.outShape}});return n.disposeIntermediateTensorInfo(u),d}};const Eq={kernelName:nd,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{equation:s}=a,r=t,{allDims:i,summedDims:o,idDims:c}=DC(s,r.length);FC(i.length,c,r);const{path:l,steps:u}=LC(o,c),h=u.length;let d=null,p=i.length;const f=[];for(let m=0;m<h;++m){for(const e of u[m]){const{permutationIndices:t,expandDims:a}=OC(p,c[e]);let s;zC(t)?s=r[e]:(s=pH({inputs:{x:r[e]},backend:n,attrs:{perm:t}}),f.push(s));const i=s.shape.slice();for(let e=0;e<a.length;++e)i.splice(a[e],0,1);Su(s.shape,i)||(s=aH({inputs:{x:s},backend:n,attrs:{shape:i}}),f.push(s)),null===d?d=s:(d=tH({inputs:{a:s,b:d},backend:n}),f.push(d))}m<h-1&&(l[m]>=0&&(d=hH({inputs:{x:d},backend:n,attrs:{axis:l[m]-(i.length-p),keepDims:!1}}),f.push(d)),p--)}for(const m of f)m!==d&&n.disposeIntermediateTensorInfo(m);return d}},Rq=KU({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),_q={kernelName:ad,backendName:"webgl",kernelFunc:Rq},Aq={kernelName:sd,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n}=e,{dy:a,y:s}=t,r=eh().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new OU("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",a.shape,s.shape):new PU("return (b >= 0.0) ? a : a * (b + 1.0);",a.shape,s.shape);return n.runWebGLProgram(r,[a,s],a.dtype)}},Mq=XU({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:CV}),Pq={kernelName:id,backendName:"webgl",kernelFunc:Mq},Dq=KU({opSnippet:'\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = '.concat(gC,";\n  float a1 = ").concat(yC,";\n  float a2 = ").concat(bC,";\n  float a3 = ").concat(xC,";\n  float a4 = ").concat(vC,";\n  float a5 = ").concat(wC,";\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n")}),Oq={kernelName:rd,backendName:"webgl",kernelFunc:Dq},Fq=KU({opSnippet:qU+"\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:IV,dtype:"float32"}),Lq={kernelName:od,backendName:"webgl",kernelFunc:Fq};function zq(e){const{inputs:t,attrs:n,backend:a}=e,{dim:s}=n,{input:r}=t,i=r.shape.length,o=r.shape.slice();let c=s;return s<0&&(bu(-(i+1)<=s,()=>"Axis must be in the interval [".concat(-(i+1),", ").concat(i,"]")),c=i+s+1),o.splice(c,0,1),aH({inputs:{x:r},backend:a,attrs:{shape:o}})}const Bq={kernelName:cd,backendName:"webgl",kernelFunc:zq},jq="return exp(x) - 1.0;",Wq=KU({opSnippet:jq,packedOpSnippet:jq,cpuKernelImpl:NV}),Vq={kernelName:ld,backendName:"webgl",kernelFunc:Wq};class Uq{constructor(e,t,n){this.variableNames=["real","imag"];const a=t[1];this.outputShape=t;const s=n?"2.0 * ".concat(Math.PI):"-2.0 * ".concat(Math.PI),r=n?"".concat(a,".0"):"1.0";let i;if("real"===e)i="return real * expR - imag * expI;";else{if("imag"!==e)throw new Error('FFT component must be either "real" or "imag", got '.concat(e,"."));i="return real * expI + imag * expR;"}this.userCode="\n      const float exponentMultiplier = ".concat(s,";\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ").concat(i,"\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(").concat(a,");\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ").concat(a,"; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ").concat(r,";\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    ")}}function Hq(e,t,n){const a=n.texData.get(e.dataId),s=wu(e.shape),r=e.shape[e.shape.length-1],i=aH({inputs:{x:e},backend:n,attrs:{shape:[s/r,r]}}),o=i.shape,c=new Uq("real",o,t),l=new Uq("imag",o,t),u=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:o},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:o}],h=n.runWebGLProgram(c,u,"float32"),d=n.runWebGLProgram(l,u,"float32"),p=zU({inputs:{real:h,imag:d},backend:n});n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d);const f=aH({inputs:{x:p},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(p),f}const Gq={kernelName:ud,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:a}=t;return Hq(a,!1,n)}};class qq{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}function Kq(e){const{backend:t,attrs:n}=e,{shape:a,value:s}=n;let{dtype:r}=n;if(r=r||Lu(s),"string"===r){const e=Mu(r,wu(a));return e.fill(s),t.makeTensorInfo(a,r,e)}{const e=new qq(a,s),n=[[s]];return t.runWebGLProgram(e,[],r,n)}}const Xq={kernelName:hd,backendName:"webgl",kernelFunc:Kq};class Yq{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode="\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ".concat(t," - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ").concat(t,") {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    ")}}const Qq={kernelName:dd,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n}=e;const{image:a}=t,s=n,r=new Yq(a.shape);return s.runWebGLProgram(r,[a],a.dtype)}},Zq="return floor(x);",Jq=KU({opSnippet:Zq,packedOpSnippet:Zq,cpuKernelImpl:TV}),$q={kernelName:pd,backendName:"webgl",kernelFunc:Jq},eK=XU({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),tK={kernelName:fd,backendName:"webgl",kernelFunc:eK};class nK{constructor(e){this.variableNames=["A"];const t=RW(),[n,a]=e;this.outputShape=e,this.userCode="\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(".concat(a,".0, ").concat(n,".0);\n\n        vec4 values = ").concat(t.texture2D,"(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    ")}}class aK{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=RW(),[n,a]=e;this.outputShape=e,this.userCode="\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(".concat(a,".0, ").concat(n,".0);\n            vec4 values = ").concat(t.texture2D,"(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ").concat(t.output," = result;\n      }\n    ")}}const sK={kernelName:df,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e;let{pixels:s}=t;const{numChannels:r}=a,i="undefined"!==typeof HTMLVideoElement&&s instanceof HTMLVideoElement,o="undefined"!==typeof HTMLImageElement&&s instanceof HTMLImageElement,[c,l]=i?[s.videoWidth,s.videoHeight]:[s.width,s.height],u=[l,c],h=[l,c,r];if(o||i){const e=eh().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");null!=rK&&e===iK||(iK=e,rK=document.createElement("canvas").getContext("2d",{willReadFrequently:iK})),rK.canvas.width=c,rK.canvas.height=l,rK.drawImage(s,0,0,c,l),s=rK.canvas}const d=n.makeTensorInfo(u,"int32");n.texData.get(d.dataId).usage=Zj.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(d.dataId),s);const p=eh().getBool("WEBGL_PACK")?new aK(h):new nK(h),f=n.runWebGLProgram(p,[d],"int32");return n.disposeData(d.dataId),f}};let rK,iK=eh().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");const oK={kernelName:mf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,filter:r,bias:i,preluActivationWeights:o}=t,{strides:c,pad:l,dataFormat:u,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=a,m=ex(u),g=Hb(s.shape,r.shape,c,h,l,d,!1,m);let y;const b=[],x=null!=i,v=null!=o,w="leakyrelu"===p,k=()=>{const e=[s,r],t=(e,t)=>{if("NCHW"===t&&1===e.shape.length&&1!==e.shape[0]){const t=aH({inputs:{x:e},backend:n,attrs:{shape:[e.shape[0],1,1]}});return b.push(t),t}return e};if(x&&e.push(t(i,u)),v&&e.push(t(o,u)),w){const t=n.makeTensorInfo([],"float32",Vf(f,"float32"));e.push(t),b.push(t)}return e};if(1!==g.filterHeight||1!==g.filterWidth||1!==g.dilationHeight||1!==g.dilationWidth||1!==g.strideHeight||1!==g.strideWidth||"SAME"!==g.padInfo.type&&"VALID"!==g.padInfo.type)if(g.strideWidth<=2&&"channelsLast"===m&&eh().getBool("WEBGL_EXP_CONV")){const e=p?YU(p,!0):null,t=new BG(g,x,e,v,w),a=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],s=k();y=n.runWebGLProgram(t,s,"float32",a)}else if(eh().getBool("WEBGL_CONV_IM2COL"))y=UG({x:s,filter:r,convInfo:g,backend:n,bias:i,activation:p,preluActivationWeights:o,leakyreluAlpha:f});else{const e=p?YU(p,!1):null,t=new LG(g,x,e,v,w),a=k();y=n.runWebGLProgram(t,a,"float32")}else y=VG({x:s,filter:r,convInfo:g,backend:n,bias:i,activation:p,preluActivationWeights:o,leakyreluAlpha:f});const S=aH({inputs:{x:y},backend:n,attrs:{shape:g.outShape}});return b.push(y),b.forEach(e=>n.disposeIntermediateTensorInfo(e)),S}};const cK={kernelName:gf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,filter:r,bias:i,preluActivationWeights:o}=t,{strides:c,pad:l,dilations:u,dimRoundingMode:h,activation:d,leakyreluAlpha:p}=a,f=[];let m=u;null==m&&(m=[1,1]),bu(Jb(c,m),()=>"Error in depthwiseConv2d: Either strides or dilations must be "+"1. Got strides ".concat(c," and dilations '").concat(m,"'"));const g=Hb(s.shape,r.shape,c,m,l,h,!0),y=eh().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels===1,b=d?YU(d,y):null,x=[s,r],v=null!=i,w=null!=o,k="leakyrelu"===d;if(v&&x.push(i),w&&x.push(o),k){const e=n.makeTensorInfo([],"float32",Vf(p,"float32"));x.push(e),f.push(e)}let S;S=y?new bq(g,v,b,w,k):new yq(g,v,b,w,k);const C=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],I=n.runWebGLProgram(S,x,"float32",C);return f.forEach(e=>n.disposeIntermediateTensorInfo(e)),I}};class lK{constructor(e,t,n,a){this.sliceDim=e,this.strides=t,this.paramsShape=a,this.variableNames=["x","indices"],this.outputShape=n;const s=GW(n.length);let r="\n    int index;";for(let i=0;i<this.sliceDim;i++)r+="\n          index = round(getIndices(coords[0], ".concat(i,"));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ").concat(this.paramsShape[i],";\n          flattenIndex += index * ").concat(this.strides[i],";");this.userCode="\n         void main() {\n          ".concat(s," coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ").concat(r,"\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      ")}}const uK={kernelName:yd,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:a,indices:s}=t,r=s.shape,i=r[r.length-1],o=wu(a.shape),[c,l,u,h]=pC(a,s),d=aH({inputs:{x:s},backend:n,attrs:{shape:[l,i]}}),p=aH({inputs:{x:a},backend:n,attrs:{shape:[wu(a.shape)/u,u]}});if(n.shouldExecuteOnCPU([a,s])||"string"===a.dtype){const e=n.readSync(s.dataId),t=n.bufferSync(a),r=EV(e,t,a.dtype,l,i,u,h,a.shape,o);return n.makeTensorInfo(c,a.dtype,r.values)}const f=new lK(i,h,[l,u],a.shape),m=n.runWebGLProgram(f,[p,d],p.dtype),g=aH({inputs:{x:m},backend:n,attrs:{shape:c}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m),g}};class hK{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const n=GW(this.rank),a=function(e){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let a=0;a<e.length;a++)2===a?n.push("index"):n.push("".concat(t[a]));return n.join()}(e);this.userCode="\n      void main() {\n        ".concat(n," resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ").concat(e[2],") ? 1.0 : 0.0;\n        setOutput(inBounds * getA(").concat(a,"));\n      }\n    ")}}function dK(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,indices:r}=t,{axis:i,batchDims:o}=a,c=Ru(i,s.shape)[0];if(eh().get("DEBUG")){const e=n.readSync(r.dataId),t=s.shape[c];for(let n=0;n<e.length;++n){const a=e[n];bu(a<=t-1&&a>=0,()=>"GatherV2: the index value ".concat(a," is not in [0, ").concat(t-1,"]"))}}const l=tI(s,r,c,o),u=wu(r.shape),h=[],d=aH({inputs:{x:s},backend:n,attrs:{shape:[l.batchSize,l.outerSize,l.dimSize,l.sliceSize]}}),p=aH({inputs:{x:r},backend:n,attrs:{shape:[l.batchSize,u/l.batchSize]}});h.push(d),h.push(p);const f=[l.batchSize,l.outerSize,u/l.batchSize,l.sliceSize];if(n.shouldExecuteOnCPU([s,r])||"string"===s.dtype){const e=n.bufferSync(p),t=n.bufferSync(d),a=RV(t,e,f);return h.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.makeTensorInfo(l.outputShape,a.dtype,a.values)}const m=new hK(d.shape,f),g=n.runWebGLProgram(m,[d,p],d.dtype);h.push(g);const y=aH({inputs:{x:g},backend:n,attrs:{shape:l.outputShape}});return h.forEach(e=>n.disposeIntermediateTensorInfo(e)),y}const pK={kernelName:gd,backendName:"webgl",kernelFunc:dK},fK=XU({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:_V,dtype:"bool"}),mK={kernelName:bd,backendName:"webgl",kernelFunc:fK},gK=XU({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:AV}),yK={kernelName:xd,backendName:"webgl",kernelFunc:gK};const bK={kernelName:wd,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:a}=t;return Hq(a,!0,n)}},xK=KU({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),vK={kernelName:Sd,backendName:"webgl",kernelFunc:xK},wK=KU({opSnippet:"return float(isinf(x));",dtype:"bool"}),kK={kernelName:Cd,backendName:"webgl",kernelFunc:wK},SK=KU({opSnippet:"return float(isnan(x));",dtype:"bool"}),CK={kernelName:Id,backendName:"webgl",kernelFunc:SK},IK=XU({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:MV,dtype:"bool"}),NK={kernelName:Td,backendName:"webgl",kernelFunc:IK},TK=XU({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:PV,dtype:"bool"}),EK={kernelName:Ed,backendName:"webgl",kernelFunc:TK};const RK={kernelName:Rd,backendName:"webgl",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:a,stop:s,num:r}=n,i=DV(a,s,r);return t.makeTensorInfo([i.length],"float32",i)}},_K=KU({opSnippet:qU+"\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:OV}),AK={kernelName:_d,backendName:"webgl",kernelFunc:_K},MK=KU({opSnippet:qU+"\n  return log(1.0 + x);\n"}),PK={kernelName:Ad,backendName:"webgl",kernelFunc:MK},DK=XU({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),OK={kernelName:Md,backendName:"webgl",kernelFunc:DK},FK=KU({opSnippet:"return float(!(x >= 1.0));"}),LK={kernelName:Pd,backendName:"webgl",kernelFunc:FK},zK=XU({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),BK={kernelName:Dd,backendName:"webgl",kernelFunc:zK};class jK{constructor(e,t,n,a,s){this.variableNames=["x"],this.outputShape=[];const r=t,i=e[3]-1;let o;this.outputShape=e;const c="float(".concat(n,") + float(").concat(a,") * sum");o=.5===s?"inversesqrt(".concat(c,")"):1===s?"1.0/(".concat(c,")"):"exp(log(".concat(c,") * float(-").concat(s,"));"),this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -".concat(r,"; j <= ").concat(r,"; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ").concat(i,") {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ").concat(o,";\n        setOutput(val);\n      }\n    ")}}class WK{constructor(e,t,n,a,s){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const r=t,i=e[3]-1;let o;this.outputShape=e;const c="float(".concat(n,") + float(").concat(a,") * sum");o=.5===s?"inversesqrt(".concat(c,")"):1===s?"1.0/(".concat(c,")"):"exp(log(".concat(c,") * float(-").concat(s,"));"),this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ".concat(this.outputShape[3],";\n        bool hasNextRow = c < ").concat(this.outputShape[2],";\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ").concat(r,";\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ").concat(r,"; j <= ").concat(r,"; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(").concat(i,"));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ").concat(o,";\n        setOutput(result);\n      }\n    ")}}const VK={kernelName:Od,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{depthRadius:r,bias:i,alpha:o,beta:c}=a,l=eh().getBool("WEBGL_PACK_NORMALIZATION")?new WK(s.shape,r,i,o,c):new jK(s.shape,r,i,o,c);return n.runWebGLProgram(l,[s],s.dtype)}};class UK{constructor(e,t,n,a,s){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=a,this.beta=s,this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ".concat(this.depth,"; ++d) {\n          int depthBegin = int(max(0.0, float(d - ").concat(t,")));\n          int depthEnd = int(min(float(").concat(this.depth,"),\n              float(d + ").concat(t," + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ").concat(this.depth,";\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(").concat(a,") * norm + float(").concat(n,");\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(").concat(a,")\n                * float(").concat(s,")\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ").concat(s,");\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    ")}}const HK={kernelName:Fd,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{x:s,y:r,dy:i}=t,{depthRadius:o,bias:c,alpha:l,beta:u}=a,h=new UK(s.shape,o,c,l,u);return n.runWebGLProgram(h,[s,r,i],s.dtype)}};function GK(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{reductionIndices:r,keepDims:i}=a,o=s.shape.length,c=Ru(r,s.shape);let l=c;const u=tv(l,o),h=null!=u,d=n.shouldExecuteOnCPU([s]);let p=s;if(h){if(d){const e=n.texData.get(p.dataId).values,t=new Array(o);for(let n=0;n<t.length;n++)t[n]=s.shape[u[n]];const a=uU(e,s.shape,s.dtype,u,t);p=n.makeTensorInfo(t,s.dtype);n.texData.get(p.dataId).values=a}else p=uH(s,u,n);l=av(l.length,o)}ev("max",l,o);const[f,m]=Jx(p.shape,l);let g,y=f;if(i&&(y=$x(f,c)),d){const e=n.texData.get(p.dataId).values,t=FV(e,wu(m),y,s.dtype);g=n.makeTensorInfo(y,s.dtype);n.texData.get(g.dataId).values=t}else g=function(e,t,n,a){const s=wu(t),r=aH({inputs:{x:e},attrs:{shape:[wu(e.shape)/s,s]},backend:a}),i=oH(r,e.dtype,"max",a),o=aH({inputs:{x:i},attrs:{shape:n},backend:a});return a.disposeIntermediateTensorInfo(r),a.disposeIntermediateTensorInfo(i),o}(p,m,y,n);return h&&n.disposeIntermediateTensorInfo(p),g}const qK={kernelName:Ld,backendName:"webgl",kernelFunc:GK},KK=XU({opSnippet:MU+"\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+DU+"\n  return result;\n",cpuKernelImpl:LV}),XK={kernelName:zd,backendName:"webgl",kernelFunc:KK};const YK={kernelName:Bd,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t;TW(s,"maxPool");const{filterSize:r,strides:i,pad:o,dimRoundingMode:c}=a;bu(Jb(i,1),()=>"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(i," and dilations '").concat(1,"'"));const l=Vb(s.shape,r,i,1,o,c);if(1===l.filterWidth&&1===l.filterHeight&&Su(l.inShape,l.outShape))return FU({inputs:{x:s},backend:n});const u=new XH(l,"max",!1);return n.runWebGLProgram(u,[s],s.dtype)}};const QK={kernelName:Wd,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{filterSize:r,strides:i,pad:o,dataFormat:c,dimRoundingMode:l}=a,u=Ub(s.shape,r,i,[1,1,1],o,l,c),h=new YH(u,"max",!1);return n.runWebGLProgram(h,[s],s.dtype)}};class ZK{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,n=e.strideWidth,a=e.dilationHeight,s=e.effectiveFilterHeight,r=e.effectiveFilterWidth,i=s-1-e.padInfo.top,o=r-1-e.padInfo.left,c=s*r-1;this.userCode="\n      const ivec2 pads = ivec2(".concat(i,", ").concat(o,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(s,";\n          wR += ").concat(a,") {\n          float dyR = float(dyRCorner + wR) / ").concat(t,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ").concat(r,"; wC++) {\n            float dyC = float(dyCCorner + wC) / ").concat(n,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ").concat(c," - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ").concat(r," + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class JK{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,n=e.strideHeight,a=e.strideWidth,s=e.dilationDepth,r=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterDepth,c=e.effectiveFilterHeight,l=e.effectiveFilterWidth,u=o-1-e.padInfo.front,h=c-1-e.padInfo.top,d=l-1-e.padInfo.left,p=o*c*l-1;this.userCode="\n      const ivec3 pads = ivec3(".concat(u,", ").concat(h,", ").concat(d,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ").concat(o,";\n           wD += ").concat(s,") {\n          float dyD = float(dyDCorner + wD) / ").concat(t,".0;\n\n          if (dyD < 0.0 || dyD >= ").concat(e.outDepth,".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ").concat(c,";\n              wR += ").concat(r,") {\n            float dyR = float(dyRCorner + wR) / ").concat(n,".0;\n\n            if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ").concat(l,";\n                wC += ").concat(i,") {\n              float dyC = float(dyCCorner + wC) / ").concat(a,".0;\n\n              if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ").concat(p," -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ").concat(c," * ").concat(l," +\n                  wR * ").concat(l," + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}const $K={kernelName:Vd,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:s,input:r}=t,i=r,{filterSize:o,strides:c,pad:l,dimRoundingMode:u}=a,h=Ub(i.shape,o,c,[1,1,1],l,u),d=new YH(h,"max",!0),p=n.runWebGLProgram(d,[i],i.dtype),f=new JK(h),m=n.runWebGLProgram(f,[s,p],i.dtype);return n.disposeIntermediateTensorInfo(p),m}};const eX={kernelName:jd,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:s,input:r,output:i}=t,o=r;TW([r,i],"maxPoolGrad");const{filterSize:c,strides:l,pad:u,dimRoundingMode:h}=a,d=Vb(o.shape,c,l,1,u,h),p=new XH(d,"max",!0),f=n.runWebGLProgram(p,[o],o.dtype),m=new ZK(d),g=n.runWebGLProgram(m,[s,f],o.dtype);return n.disposeIntermediateTensorInfo(f),g}};const tX={kernelName:Ud,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e;const{x:s}=t,{filterSize:r,strides:i,pad:o,includeBatchInIndex:c}=n,l=a;bu(4===s.shape.length,()=>"Error in maxPool: input must be rank 4 but got rank ".concat(s.shape.length,"."));const u=[1,1];bu(Jb(i,u),()=>"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(i," and dilations '").concat(u,"'"));const h=Vb(s.shape,r,i,u,o),[d,p]=function(e,t,n,a){let s=new XH(n,"max",!1);const r=a.runWebGLProgram(s,[e],"float32");return s=new XH(n,"max",!0,!0,t),[r,a.runWebGLProgram(s,[e],"float32")]}(s,c,h,l);return[d,p]}};const nX={kernelName:Hd,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e;const{x:s}=t,{keepDims:r,axis:i}=n,o=a,c=s.shape.length,l=Ru(i,s.shape);let u=l;const h=tv(u,c),d=null!=h,p=o.shouldExecuteOnCPU([s]),f=[];let m=s;if(d){if(p){const e=o.texData.get(m.dataId).values,t=new Array(c);for(let a=0;a<t.length;a++)t[a]=s.shape[h[a]];const n=uU(e,s.shape,s.dtype,h,t);m=o.makeTensorInfo(t,s.dtype);o.texData.get(m.dataId).values=n}else m=uH(s,h,o);f.push(m),u=av(u.length,c)}ev("sum",u,c);const[g,y]=Jx(m.shape,u);let b=g;r&&(b=$x(g,l));const x=function(e,t,n,a){const s=wu(t),r=aH({inputs:{x:e},attrs:{shape:[wu(e.shape)/s,s]},backend:a}),i=oH(r,"float32","mean",a),o=aH({inputs:{x:i},attrs:{shape:n},backend:a});return a.disposeIntermediateTensorInfo(r),a.disposeIntermediateTensorInfo(i),o}(m,y,b,o);for(const v of f)o.disposeIntermediateTensorInfo(v);return x}};const aX={kernelName:Gd,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{axis:r,keepDims:i}=a,o=s.shape.length,c=Ru(r,s.shape);let l=c;const u=tv(l,o);let h=s;null!=u&&(h=pH({inputs:{x:s},backend:n,attrs:{perm:u}}),l=av(l.length,s.shape.length)),ev("min",l,o);const[d,p]=Jx(h.shape,l),f=aH({inputs:{x:h},backend:n,attrs:{shape:[-1,wu(p)]}}),m=oH(f,f.dtype,"min",n);let g;if(i){g=aH({inputs:{x:m},backend:n,attrs:{shape:$x(d,c)}})}else g=aH({inputs:{x:m},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=u&&n.disposeIntermediateTensorInfo(h),g}},sX=XU({opSnippet:MU+"\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+DU+"\n  return result;\n",cpuKernelImpl:zV}),rX={kernelName:qd,backendName:"webgl",kernelFunc:sX};class iX{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map((t,n)=>t[0]+e[n]+t[1]);const a=e.length,s=GW(a),r=t.map(e=>e[0]).join(","),i=t.map((t,n)=>t[0]+e[n]).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,a),c="reflect"===n?0:1;this.userCode=1!==a?"\n      ".concat(s," start = ").concat(s,"(").concat(r,");\n      ").concat(s," end = ").concat(s,"(").concat(i,");\n\n      void main() {\n        ").concat(s," outC = getOutputCoords();\n        for (int i = 0; i < ").concat(a,"; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ").concat(c,";\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ").concat(c,";\n          }\n        }\n        ").concat(s," coords = outC - start;\n        setOutput(getX(").concat(o,"));\n      }\n    "):"\n        int start = ".concat(r,";\n        int end = ").concat(i,";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ").concat(c,";\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ").concat(c,";\n          }\n          setOutput(getX(outC - start));\n        }\n      ")}}class oX{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((t,n)=>t[0]+e[n]+t[1]);const a=e.length,s=GW(a),r=t.map(e=>e[0]).join(","),i=t.map((t,n)=>t[0]+e[n]).join(","),o=pU("rc",a),c=pU("source",a),l="".concat(o[a-1]," < ").concat(this.outputShape[a-1]),u=1===a?"source":"vec2(".concat(c.slice(-2).join(),")"),h="reflect"===n?0:1;let d="";if(1===a){const e="\n        ".concat(s," source = rc;\n        if (source < start) {\n          source = start * 2 - source - ").concat(h,";\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ").concat(h,";\n        }\n        source -= start;\n      ");d="\n        ".concat(s," rc = outputLoc;\n        ").concat(e,"\n        result[0] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n        ").concat(o[a-1]," += 1;\n        if(").concat(l,") {\n          ").concat(e,"\n          result[1] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n        }\n      ")}else{const e="\n        ".concat(s," source = rc;\n        ").concat(s," lt = ").concat(s,"(lessThan(source, start));\n        ").concat(s," gte = ").concat(s,"(greaterThanEqual(source, end));\n        ").concat(s," orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ").concat(h,") +\n                gte * ((end - 1) * 2 - source + ").concat(h,");\n        source -= start;\n      ");d="\n        ".concat(s," rc = outputLoc;\n        ").concat(e,"\n        result[0] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n        ").concat(o[a-1]," += 1;\n        if(").concat(l,") {\n          ").concat(e,"\n          result[1] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n        }\n        rc = outputLoc;\n        ").concat(o[a-2]," += 1;\n        if(").concat(o[a-2]," < ").concat(this.outputShape[a-2],") {\n          ").concat(e,"\n          result[2] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n          ").concat(o[a-1]," += 1;\n          if(").concat(l,") {\n            ").concat(e,"\n            result[3] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n          }\n        }\n      ")}this.userCode="\n      const ".concat(s," start = ").concat(s,"(").concat(r,");\n      const ").concat(s," end = ").concat(s,"(").concat(i,");\n\n      void main() {\n        ").concat(s," outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ").concat(d,"\n        setOutput(result);\n      }\n    ")}}const cX={kernelName:Kd,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:a}=e;const{x:s}=t,{paddings:r,mode:i}=a,o=eh().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new oX(s.shape,r,i):new iX(s.shape,r,i);return n.runWebGLProgram(o,[s],s.dtype)}},lX=XU({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  "+DU+"\n  return result;\n"}),uX={kernelName:Xd,backendName:"webgl",kernelFunc:lX};class hX{constructor(e,t,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,n],this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ".concat(t-1,"; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(").concat(t-1,"));\n      }\n    ")}}const dX=XU({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),pX={kernelName:td,backendName:"webgl",kernelFunc:dX},fX="return a - b;",mX=XU({opSnippet:fX,packedOpSnippet:fX,supportsComplex:!0,cpuKernelImpl:oU}),gX={kernelName:$p,backendName:"webgl",kernelFunc:mX};function yX(e){const{inputs:t,backend:n,attrs:a}=e,{logits:s}=t,{dim:r}=a,i=Ru([r],s.shape),o=GK({inputs:{x:s},backend:n,attrs:{reductionIndices:i,keepDims:!1}}),c=$x(o.shape,i),l=aH({inputs:{x:o},backend:n,attrs:{shape:c}}),u=mX({inputs:{a:s,b:l},backend:n}),h=Fq({inputs:{x:u},backend:n}),d=hH({inputs:{x:h},backend:n,attrs:{axis:i,keepDims:!1}}),p=aH({inputs:{x:d},backend:n,attrs:{shape:c}}),f=dX({inputs:{a:h,b:p},backend:n});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),f}const bX={kernelName:jp,backendName:"webgl",kernelFunc:yX};const xX={kernelName:Yd,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{logits:s}=t,{numSamples:r,seed:i,normalized:o}=a,c=o?s:yX({inputs:{logits:s},backend:n,attrs:{dim:s.shape.length-1}}),l=c.shape[0],u=c.shape[1],h=new hX(l,u,r),d=[[i]],p=n.runWebGLProgram(h,[c],"int32",d);return o||n.disposeIntermediateTensorInfo(c),p}},vX=wU+"\n  return -x;\n";const wX={kernelName:Zd,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t;if(n.shouldExecuteOnCPU([a])){const e=n.texData.get(a.dataId),[t,s]=jV(e.values,a.shape,a.dtype);return n.makeTensorInfo(s,a.dtype,t)}let s;return s=eh().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new NU(a.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new vU(a.shape,vX),n.runWebGLProgram(s,[a],a.dtype)}},kX=sS;const SX={kernelName:$d,backendName:"webgl",kernelFunc:function(e){yf("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:a}=e,{boxes:s,scores:r}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:c}=a,l=n.readSync(s.dataId),u=n.readSync(r.dataId),{selectedIndices:h}=kX(l,u,i,o,c);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}},CX=rS;const IX={kernelName:ep,backendName:"webgl",kernelFunc:function(e){yf("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:a}=e,{boxes:s,scores:r}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:c,padToMaxOutputSize:l}=a,u=n.readSync(s.dataId),h=n.readSync(r.dataId),{selectedIndices:d,validOutputs:p}=CX(u,h,i,o,c,l);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},NX=iS;const TX={kernelName:tp,backendName:"webgl",kernelFunc:function(e){yf("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:a}=e,{boxes:s,scores:r}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:c,softNmsSigma:l}=a,u=n.readSync(s.dataId),h=n.readSync(r.dataId),d=i,p=o,f=c,m=l,{selectedIndices:g,selectedScores:y}=NX(u,h,d,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}};class EX{constructor(e,t,n,a){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(".concat(a,"), float(").concat(n,"),\n                      float(index == coords.y)));\n      }\n    ")}}const RX={kernelName:ap,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{indices:s}=t,{dtype:r,depth:i,onValue:o,offValue:c}=a,l=wu(s.shape),u=new EX(l,i,o,c),h=aH({inputs:{x:s},backend:n,attrs:{shape:[l]}}),d=n.runWebGLProgram(u,[h],r);n.disposeIntermediateTensorInfo(h);const p=aH({inputs:{x:d},backend:n,attrs:{shape:[...s.shape,i]}});return n.disposeIntermediateTensorInfo(d),p}};function _X(e){const{inputs:t,backend:n}=e,{x:a}=t;if("complex64"===a.dtype){const e=yG({inputs:{input:a},backend:n}),t=_X({inputs:{x:e},backend:n}),s=MG({inputs:{input:a},backend:n}),r=_X({inputs:{x:s},backend:n}),i=zU({inputs:{real:t,imag:r},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(r),i}return Kq({attrs:{shape:a.shape,dtype:a.dtype,value:"string"===a.dtype?"":0},backend:n})}const AX={kernelName:uf,backendName:"webgl",kernelFunc:_X};const MX={kernelName:np,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:a}=t,{x:s}=n;if("string"===s.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===s.dtype){const t=yG({inputs:{input:s},backend:a}),n=e({inputs:{x:t},backend:a}),r=MG({inputs:{input:s},backend:a}),i=_X({inputs:{x:r},backend:a}),o=zU({inputs:{real:n,imag:i},backend:a});return a.disposeIntermediateTensorInfo(t),a.disposeIntermediateTensorInfo(n),a.disposeIntermediateTensorInfo(r),a.disposeIntermediateTensorInfo(i),o}return Kq({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:a})}};const PX={kernelName:sp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{axis:s}=a;if(1===t.length)return zq({inputs:{input:t[0]},backend:n,attrs:{dim:s}});const r=t[0].shape,i=t[0].dtype;t.forEach(e=>{xu(r,e.shape,"All tensors passed to stack must have matching shapes"),bu(i===e.dtype,()=>"All tensors passed to stack must have matching dtypes")});const o=[],c=OG({inputs:t.map(e=>{const t=zq({inputs:{input:e},backend:n,attrs:{dim:s}});return o.push(t),t}),backend:n,attrs:{axis:s}});return o.forEach(e=>n.disposeIntermediateTensorInfo(e)),c}};class DX{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((t,n)=>t[0]+e[n]+t[1]);const a=e.length,s=GW(a),r=t.map(e=>e[0]).join(","),i=t.map((t,n)=>t[0]+e[n]).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,a);this.userCode=1!==a?"\n      ".concat(s," start = ").concat(s,"(").concat(r,");\n      ").concat(s," end = ").concat(s,"(").concat(i,");\n\n      void main() {\n        ").concat(s," outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ").concat(s," coords = outC - start;\n          setOutput(getX(").concat(o,"));\n        }\n      }\n    "):"\n        int start = ".concat(r,";\n        int end = ").concat(i,";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      ")}}class OX{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((t,n)=>t[0]+e[n]+t[1]);const a=e.length,s=GW(a),r=t.map(e=>e[0]).join(","),i=t.map((t,n)=>t[0]+e[n]).join(","),o=pU("rc",a),c=pU("source",a),l="".concat(o[a-1]," < ").concat(this.outputShape[a-1]),u=1===a?"source":"vec2(".concat(c.slice(-2).join(),")"),h=["".concat(s," rc = outputLoc;"),"".concat(o[a-1]," += 1;\n       if(").concat(l,") {\n      "),1===a?"":"}\n       rc = outputLoc;\n       ".concat(o[a-2]," += 1;\n       if(").concat(o[a-2]," < ").concat(this.outputShape[a-2],") {"),1===a?"":"  ".concat(o[a-1]," += 1;\n         if(").concat(l,") {")],d=1===a?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let p="";for(let f=0,m=1===a?2:4;f<m;f++)p+="\n        ".concat(h[f],"\n        if (").concat(d,") {\n          result[").concat(f,"] = float(value);\n        } else {\n          ").concat(s," source = rc - start;\n          result[").concat(f,"] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n        }\n      ");p+=1===a?"} ":"}}",this.userCode="\n      const ".concat(s," start = ").concat(s,"(").concat(r,");\n      const ").concat(s," end = ").concat(s,"(").concat(i,");\n\n      void main() {\n        ").concat(s," outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ").concat(p,"\n        setOutput(result);\n      }\n    ")}}const FX=e=>{const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{paddings:r,constantValue:i}=a;if(0===wu(s.shape)){const e=r.map((e,t)=>e[0]+s.shape[t]+e[1]);return Kq({backend:n,attrs:{shape:e,value:i,dtype:s.dtype}})}const o=eh().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new OX(s.shape,r,i):new DX(s.shape,r,i),c=[[i]];return n.runWebGLProgram(o,[s],s.dtype,c)},LX={kernelName:rp,backendName:"webgl",kernelFunc:FX},zX=XU({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  "+DU+"\n  return result;\n"}),BX={kernelName:ip,backendName:"webgl",kernelFunc:zX};const jX={kernelName:cp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{axis:r,keepDims:i}=a,o=s.shape.length,c=[],l=Ru(r,s.shape);let u=l;const h=tv(u,o);let d,p=s;if(null!=h&&(p=pH({inputs:{x:s},backend:n,attrs:{perm:h}}),u=av(u.length,o),c.push(p)),ev("prod",u,o),n.shouldExecuteOnCPU([p])){const e=n.texData.get(p.dataId).values,{outVals:t,outShape:a,outDtype:s}=VV(p.shape,p.dtype,e,u);d=n.makeTensorInfo(a,s,t)}else{const[e,t]=Jx(p.shape,u),a=wu(t),r=aH({inputs:{x:p},backend:n,attrs:{shape:[-1,a]}}),i=oH(r,ym(s.dtype),"prod",n);d=aH({inputs:{x:i},backend:n,attrs:{shape:e}}),c.push(r),c.push(i)}if(i){c.push(d);const e=$x(d.shape,l);d=aH({inputs:{x:d},backend:n,attrs:{shape:e}})}return c.forEach(e=>n.disposeIntermediateTensorInfo(e)),d}};const WX={kernelName:lp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{paramsNestedSplits:s,paramsDenseValues:r,indices:i}=t,{outputRaggedRank:o}=a,c=s.map(e=>n.readSync(e.dataId)),l=s.map(e=>e.shape),u=n.readSync(r.dataId),h=n.readSync(i.dataId),[d,p,f]=UV(c,l,u,r.shape,r.dtype,h,i.shape,o),m=d.map(e=>n.makeTensorInfo([e.length],"int32",e)),g=n.makeTensorInfo(f,r.dtype,p);return m.concat([g])}};const VX={kernelName:up,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{starts:a,limits:s,deltas:r}=t,i=n.readSync(a.dataId),o=n.readSync(s.dataId),c=n.readSync(r.dataId),[l,u]=HV(i,a.shape,a.dtype,o,s.shape,c,r.shape);return[n.makeTensorInfo([l.length],"int32",l),n.makeTensorInfo([u.length],a.dtype,u)]}};const UX={kernelName:hp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{shape:s,values:r,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:c}=a,l=n.readSync(s.dataId),u=n.readSync(r.dataId),h=n.readSync(i.dataId),d=o.map(e=>n.readSync(e.dataId)),p=o.map(e=>e.shape),[f,m]=GV(l,s.shape,u,r.shape,r.dtype,h,i.shape,d,p,c);return n.makeTensorInfo(f,r.dtype,m)}},HX=e=>{const{backend:t,attrs:n}=e,{start:a,stop:s,step:r,dtype:i}=n,o=qV(a,s,r,i);return t.makeTensorInfo([o.length],i,o)},GX={kernelName:dp,backendName:"webgl",kernelFunc:HX},qX=KU({opSnippet:"return 1.0 / x;"}),KX={kernelName:fp,backendName:"webgl",kernelFunc:qX},XX=KU({opSnippet:wU+"\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),YX={kernelName:mp,backendName:"webgl",kernelFunc:XX},QX=KU({opSnippet:wU+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),ZX={kernelName:wp,backendName:"webgl",kernelFunc:QX};class JX{constructor(e,t,n,a,s){this.variableNames=["A"],this.outputShape=[];const[r,i,o,c]=e;this.outputShape=[r,t,n,c];const l=[a&&t>1?i-1:i,a&&n>1?o-1:o],u=[a&&t>1?t-1:t,a&&n>1?n-1:n];let h;h=s?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode="\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ".concat(l[0]/u[0],",\n          ").concat(l[1]/u[1],");\n      const vec2 inputShapeRC = vec2(").concat(i,".0, ").concat(o,".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ").concat(h,";\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    ")}}class $X{constructor(e,t,n,a,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[r,i,o,c]=e;this.outputShape=[r,t,n,c];const l=[a&&t>1?i-1:i,a&&n>1?o-1:o],u=[a&&t>1?t-1:t,a&&n>1?n-1:n];let h;h=s?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode="\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ".concat(l[0]/u[0],",\n          ").concat(l[1]/u[1],",\n          ").concat(l[1]/u[1],");\n      const vec3 inputShapeRC = vec3(").concat(i,".0, ").concat(o,".0,\n                                     ").concat(o,".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ").concat(h,";\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ").concat(c-1,";\n        bool hasNextRow = coords.z < ").concat(n-1,";\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    ")}}const eY={kernelName:xp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:s}=t,{alignCorners:r,halfPixelCenters:i,size:o}=a,[c,l]=o,u=eh().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new $X(s.shape,c,l,r,i):new JX(s.shape,c,l,r,i);return n.runWebGLProgram(u,[s],"float32")}};class tY{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,a,s]=t,[,r,i]=e,o=[n&&r>1?a-1:a,n&&i>1?s-1:s],c=[n&&r>1?r-1:r,n&&i>1?i-1:i],l=o[0]/c[0],u=o[1]/c[1],h=1/l,d=1/u,p=2*Math.ceil(h)+2,f=2*Math.ceil(d)+2;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(".concat(l,");\n        const float widthScale = float(").concat(u,");\n\n        const float invHeightScale = float(").concat(h,");\n        const float invWidthScale = float(").concat(d,");\n\n        const int winHeight = int(").concat(p,");\n        const int winWidth = int(").concat(f,");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ").concat(r,") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ").concat(i,") {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ").concat(a-1,".0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ").concat(s-1,".0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ")}}const nY={kernelName:vp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:s,dy:r}=t,{alignCorners:i}=a,o=new tY(r.shape,s.shape,i);return n.runWebGLProgram(o,[r],r.dtype)}};class aY{constructor(e,t,n,a,s){this.variableNames=["A"],this.outputShape=[];const[r,i,o,c]=e;this.outputShape=[r,t,n,c];const l=[a&&t>1?i-1:i,a&&n>1?o-1:o],u=[a&&t>1?t-1:t,a&&n>1?n-1:n],h=a?"0.5":"0.0";let d;d=s?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode="\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ".concat(l[0]/u[0],",\n          ").concat(l[1]/u[1],");\n      const vec2 inputShapeRC = vec2(").concat(i,".0, ").concat(o,".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ").concat(d,";\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ").concat(h,")));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    ")}}class sY{constructor(e,t,n,a,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[r,i,o,c]=e;this.outputShape=[r,t,n,c];const l=[a&&t>1?i-1:i,a&&n>1?o-1:o],u=[a&&t>1?t-1:t,a&&n>1?n-1:n],h=a?"0.5":"0.0";let d;d=s?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode="\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ".concat(l[0]/u[0],",\n          ").concat(l[1]/u[1],",\n          ").concat(l[1]/u[1],");\n      const vec3 inputShapeRC = vec3(").concat(i,".0, ").concat(o,".0,\n                                     ").concat(o,".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ").concat(d,";\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ").concat(h,")));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ").concat(c-1,";\n        bool hasNextRow = coords.z < ").concat(n-1,";\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    ")}}const rY={kernelName:yp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:s}=t,{alignCorners:r,halfPixelCenters:i,size:o}=a,[c,l]=o,u=eh().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new sY(s.shape,c,l,r,i):new aY(s.shape,c,l,r,i);return n.runWebGLProgram(u,[s],s.dtype)}};class iY{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,a,s]=t,[,r,i]=e,o=[n&&r>1?a-1:a,n&&i>1?s-1:s],c=[n&&r>1?r-1:r,n&&i>1?i-1:i],l=o[0]/c[0],u=o[1]/c[1],h=1/l,d=1/u,p=2*Math.ceil(h)+2,f=2*Math.ceil(d)+2;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(".concat(l,");\n        const float widthScale = float(").concat(u,");\n\n        const float invHeightScale = float(").concat(h,");\n        const float invWidthScale = float(").concat(d,");\n\n        const int winHeight = int(").concat(p,");\n        const int winWidth = int(").concat(f,");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ").concat(r,") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ").concat(i,") {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(").concat(o[0],") *\n                (float(dyR) / float(").concat(c[0],"));\n\n            float sourceFracCol =\n                float(").concat(o[1],") *\n                  (float(dyC) / float(").concat(c[1],"));\n\n            int sourceNearestRow = int(min(\n                float(int(").concat(a,") - 1),\n                ").concat(n," ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(").concat(s,") - 1),\n                ").concat(n," ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ")}}const oY={kernelName:bp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:s,dy:r}=t,{alignCorners:i}=a,o=new iY(r.shape,s.shape,i);return n.runWebGLProgram(o,[r],r.dtype)}};class cY{constructor(e,t){this.variableNames=["x"];const n=e.length;if(n>4)throw new Error("WebGL backend: Reverse of rank-".concat(n," tensor is not yet supported"));if(this.outputShape=e,1===n)return void(this.userCode="\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(".concat(e[0]," - coord - 1));\n        }\n      "));const a=e.map((n,a)=>(n=>-1!==t.indexOf(n)&&1!==e[n]?"".concat(e[n]," - coords[").concat(n,"] - 1"):"coords[".concat(n,"]"))(a)).join(","),s=GW(n);this.userCode="\n      void main() {\n        ".concat(s," coords = getOutputCoords();\n        setOutput(getX(").concat(a,"));\n      }\n    ")}}class lY{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const n=e.length;if(n>4)throw new Error("WebGL backend: Reverse of rank-".concat(n," tensor is not yet supported"));this.outputShape=e;const a=pU("rc",n),s="".concat(a[n-1]," + 1 < ").concat(this.outputShape[n-1]),r="".concat(a[n-2]," + 1 < ").concat(this.outputShape[n-2]),i=GW(n);function o(n){const a=e.map((a,s)=>function(n,a){return-1!==t.indexOf(n)&&1!==e[n]?"".concat(e[n]," - ").concat(a[n]," - 1"):"".concat(a[n])}(s,n)),s=a.join(","),r=a.slice(-2).join(",");return"getChannel(getX(".concat(s,"), vec2(").concat(r,"))")}this.userCode=1===n?"\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(".concat(e[0]," - rc - 1),\n            ").concat(e[0]," - rc - 1);\n          if(").concat(s,"){\n              result.g = getChannel(getX(").concat(e[0]," - (rc  + 1) - 1),\n                ").concat(e[0]," - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      "):"\n        void main() {\n          ".concat(i," rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ").concat(function(e){return o(e)}(a.slice()),";\n          if(").concat(s,"){\n            result.g = ").concat(function(e){return e[n-1]="("+e[n-1]+" + 1)",o(e)}(a.slice()),";\n          }\n          if(").concat(r,") {\n            result.b = ").concat(function(e){return e[n-2]="("+e[n-2]+" + 1)",o(e)}(a.slice()),";\n            if(").concat(s,") {\n              result.a = ").concat(function(e){return e[n-1]="("+e[n-1]+" + 1)",e[n-2]="("+e[n-2]+" + 1)",o(e)}(a.slice()),";\n            }\n          }\n          setOutput(result);\n        }\n    ")}}const uY={kernelName:kp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{dims:r}=a,i=s.shape.length,o=Ru(r,s.shape);if(0===i)return FU({inputs:{x:s},backend:n});const c=eh().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new lY(s.shape,o):new cY(s.shape,o);return n.runWebGLProgram(c,[s],s.dtype)}};class hY{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const n=e[1],a=e[2];this.outputShape=e;let s="";s="number"===typeof t?"float outputValue = ".concat(t.toFixed(2),";"):"\n        vec3 fill = vec3(".concat(t.join(","),");\n        float outputValue = fill[coords[3]];"),this.userCode="\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ".concat(s,"\n          if(coordX >= 0 && coordX < ").concat(a," && coordY >= 0 && coordY < ").concat(n,") {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    ")}}const dY={kernelName:pf,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e;const{image:s}=t,{radians:r,fillValue:i,center:o}=n,c=a,l=new hY(s.shape,i),[u,h]=oC(o,s.shape[1],s.shape[2]),d=[[u,h,Math.sin(r),Math.cos(r)]];return c.runWebGLProgram(l,[s],s.dtype,d)}},pY=KU({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),fY={kernelName:Sp,backendName:"webgl",kernelFunc:pY},mY=KU({opSnippet:"return inversesqrt(x);",cpuKernelImpl:KV}),gY={kernelName:Cp,backendName:"webgl",kernelFunc:mY};class yY{constructor(e,t,n,a,s,r){let i=arguments.length>7&&void 0!==arguments[7]&&arguments[7];this.variableNames=["updates","indices","defaultValue"],this.outputShape=r;const o=GW(s.length),c=GW(r.length);let l="";1===n?l="i":2===n&&(l="i, j");const u="getIndices(".concat(l,")");let h="";1===a?h="i":2===a&&(h="i, coords[1]");const d="getUpdates(".concat(h,")");let p="";i&&(p="coords[0], coords[1]");const f="getDefaultValue(".concat(p,")"),m=t>1?"strides[j]":"strides";this.userCode="\n        ".concat(o," strides = ").concat(o,"(").concat(s,");\n\n        void main() {\n          ").concat(c," coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ").concat(e,"; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ").concat(t,"; j++) {\n              int index = round(").concat(u,");\n              flattenedIndex += index * ").concat(m,";\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ").concat(d,";\n              found = true;\n            }\n          }\n          setOutput(mix(").concat(f,", sum, float(found)));\n        }\n      ")}}class bY{constructor(e,t,n,a,s,r){let i=arguments.length>7&&void 0!==arguments[7]&&arguments[7];this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=r;const o=GW(s.length),c=GW(r.length);let l="";1===n?l="i":2===n&&(l="i, j");const u="getIndices(".concat(l,")");let h="";1===a?h="i":2===a&&(h="i, coords[1]");const d="getUpdates(".concat(h,")");let p="";i&&(p="coords[0], coords[1]");const f="getDefaultValue(".concat(p,")"),m=t>1?"strides[j]":"strides",g=t>1?"strides[j + 1]":"strides";this.userCode="\n        ".concat(o," strides = ").concat(o,"(").concat(s,");\n\n        void main() {\n          ").concat(c," coords = getOutputCoords();\n          vec4 sum = vec4(0.);\n          vec4 found = vec4(0.);\n          for (int i = 0; i < ").concat(e,"; i+=2) {\n            ivec2 flattenedIndex = ivec2(0);\n            for (int j = 0; j < ").concat(t,"; j+=2) {\n              ivec4 index = round(").concat(u,");\n              flattenedIndex += index.xz * ").concat(m,";\n              if (j + 1 < ").concat(t,") {\n                flattenedIndex += index.yw * ").concat(g,";\n              }\n            }\n            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||\n                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {\n              vec4 updVals = ").concat(d,";\n              if (flattenedIndex[0] == coords[0]) {\n                sum.xy += updVals.xy;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[0] == coords[0] + 1) {\n                sum.zw += updVals.xy;\n                found.zw = vec2(1.);\n              }\n              if (flattenedIndex[1] == coords[0]) {\n                sum.xy += updVals.zw;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[1] == coords[0] + 1) {\n                sum.zw += updVals.zw;\n                found.zw = vec2(1.);\n              }\n            }\n          }\n          setOutput(mix(").concat(f,", sum, found));\n        }\n      ")}}const xY={kernelName:Ip,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{indices:s,updates:r}=t,{shape:i}=a,{sliceRank:o,numUpdates:c,sliceSize:l,strides:u,outputSize:h}=fk(0,s,i),d=[h/l,l];if(0===h)return n.makeTensorInfo(i,s.dtype);const p=aH({inputs:{x:s},backend:n,attrs:{shape:[c,o]}}),f=aH({inputs:{x:r},backend:n,attrs:{shape:[c,l]}}),m=n.makeTensorInfo([],"float32",new Float32Array([0]));let g;g=eh().getBool("WEBGL_PACK")?new bY(c,o,p.shape.length,f.shape.length,u,d):new yY(c,o,p.shape.length,f.shape.length,u,d);const y=n.runWebGLProgram(g,[f,p,m],f.dtype),b=aH({inputs:{x:y},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(m),b}};class vY{constructor(e,t,n,a){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,n];const s="for (int i = 0; i < ".concat(Math.ceil(Math.log2(t+1)),"; ++i) { if (left >= right) break;"),r=2===eh().getNumber("WEBGL_VERSION")?"while (left < right) {":s,i="left"===a?"<":"<=";this.userCode="\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ".concat(r,"\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ").concat(i," value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     ")}}const wY={kernelName:Tp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{sortedSequence:s,values:r}=t,{side:i}=a,o=new vY(s.shape[0],s.shape[1],r.shape[1],i),c=[[s.shape[1]]];return n.runWebGLProgram(o,[s,r],"int32",c)}};class kY{constructor(e,t,n){let a,s;if(this.variableNames=["c","a","b"],this.outputShape=t,n>4)throw Error("Where for rank ".concat(n," is not yet supported"));if(1===n)s="resRC",a="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[],i=[];for(let a=0;a<t.length;a++)i.push("".concat(n[a])),a<e&&r.push("".concat(n[a]));a=r.join(),s=i.join()}const r=GW(n);this.userCode="\n      void main() {\n        ".concat(r," resRC = getOutputCoords();\n        float cVal = getC(").concat(a,");\n        if (cVal >= 1.0) {\n          setOutput(getA(").concat(s,"));\n        } else {\n          setOutput(getB(").concat(s,"));\n        }\n      }\n    ")}}const SY={kernelName:Ep,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:a,t:s,e:r}=t,i=new kY(a.shape.length,s.shape,s.shape.length);return n.runWebGLProgram(i,[a,s,r],gm(s.dtype,r.dtype))}},CY=KU({opSnippet:"\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ".concat(fC,";\n  float scale = ").concat(mC,";\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n")}),IY={kernelName:Rp,backendName:"webgl",kernelFunc:CY},NY=KU({opSnippet:qU+"\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:YV}),TY={kernelName:Dp,backendName:"webgl",kernelFunc:NY},EY=KU({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),RY={kernelName:Pp,backendName:"webgl",kernelFunc:EY},_Y=KU({opSnippet:qU+"\n  return sin(x);\n",packedOpSnippet:"\n  vec4 result = sin(x);\n  bvec4 isNaN = isnan(x);\n  ".concat(DU,"\n  return result;\n")}),AY={kernelName:Ap,backendName:"webgl",kernelFunc:_Y},MY=KU({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),PY={kernelName:Mp,backendName:"webgl",kernelFunc:MY},DY=KU({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),OY={kernelName:Op,backendName:"webgl",kernelFunc:DY},FY={kernelName:zp,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{blockShape:r,paddings:i}=a;bu(s.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const o=r.reduce((e,t)=>e*t),c=[[0,0]];c.push(...i);for(let y=1+r.length;y<s.shape.length;++y)c.push([0,0]);const l=[],u=FX({inputs:{x:s},backend:n,attrs:{paddings:c,constantValue:0}}),h=cC(u.shape,r,o,!1),d=lC(h.length,r.length,!1),p=uC(u.shape,r,o,!1),f=aH({inputs:{x:u},backend:n,attrs:{shape:h}}),m=pH({inputs:{x:f},backend:n,attrs:{perm:d}}),g=aH({inputs:{x:m},backend:n,attrs:{shape:p}});return l.push(u),l.push(f),l.push(m),l.forEach(e=>n.disposeIntermediateTensorInfo(e)),g}};const LY={kernelName:Wp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:a,values:s,denseShape:r,defaultValue:i}=t;if(1!==r.shape.length)throw new Error("Dense shape must be a vector, saw:\n         ".concat(r.shape));if(2!==a.shape.length)throw new Error("Indices must be a matrix, saw:\n         ".concat(a.shape));if(1!==s.shape.length)throw new Error("Values must be a vector, saw:\n         ".concat(s.shape));if(0!==i.shape.length)throw new Error("Default value must be a scalar, saw:\n        ".concat(i.shape));const o=n.readSync(a.dataId),c=n.readSync(s.dataId),l=n.readSync(r.dataId),u=n.readSync(i.dataId)[0],[h,d,p,f,m]=JV(o,a.shape,a.dtype,c,s.dtype,l,u);return[n.makeTensorInfo(d,a.dtype,h),n.makeTensorInfo([d[0]],s.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(e=>Number(e)))),n.makeTensorInfo([m.length],a.dtype,new Int32Array(m))]}};const zY={kernelName:Vp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:a,inputShape:s,newShape:r}=t;if(2!==a.shape.length)throw new Error("Input indices should be a matrix but received shape ".concat(a.shape));if(1!==s.shape.length)throw new Error("Input shape should be a vector but received shape ".concat(s.shape));if(1!==r.shape.length)throw new Error("Target shape should be a vector but received shape ".concat(r.shape));const i=Array.from(n.readSync(s.dataId)),o=n.readSync(a.dataId),c=Array.from(n.readSync(r.dataId)),[l,u,h]=$V(o,a.shape,a.dtype,i,c);return[n.makeTensorInfo(u,a.dtype,l),n.makeTensorInfo([h.length],r.dtype,new Int32Array(h))]}};const BY={kernelName:Up,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:a,indices:s,segmentIds:r}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error("Indices should be a vector but received shape\n              ".concat(s.shape));if(1!==r.shape.length)throw new Error("Segment ids should be a vector but received shape\n              ".concat(r.shape));const i=n.readSync(a.dataId),o=n.readSync(s.dataId),c=n.readSync(r.dataId),[l,u]=eU(i,a.shape,a.dtype,o,c,!0);return n.makeTensorInfo(u,a.dtype,l)}};const jY={kernelName:Hp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:a,indices:s,segmentIds:r}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error("Indices should be a vector but received shape\n             ".concat(s.shape));if(1!==r.shape.length)throw new Error("Segment ids should be a vector but received shape\n             ".concat(r.shape));const i=n.readSync(a.dataId),o=n.readSync(s.dataId),c=n.readSync(r.dataId),[l,u]=eU(i,a.shape,a.dtype,o,c);return n.makeTensorInfo(u,a.dtype,l)}};const WY={kernelName:Gp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{sparseIndices:s,sparseValues:r,defaultValue:i}=t,{outputShape:o}=a,{sliceRank:c,numUpdates:l,sliceSize:u,strides:h,outputSize:d}=fk(0,s,o),p=!1;if("string"===r.dtype){const e=n.bufferSync(s),t=n.bufferSync(r),a=qf(n.readSync(i.dataId)[0]),f=XV(e,t,o,d,u,l,c,h,a,p);return n.makeTensorInfo(o,f.dtype,f.values)}const f=new yY(l,c,s.shape.length,r.shape.length,h,[d,1],p),m=n.runWebGLProgram(f,[r,s,i],r.dtype),g=aH({inputs:{x:m},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(m),g}};const VY={kernelName:Bp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{numOrSizeSplits:r,axis:i}=a,o=Ru(i,s.shape)[0],c=jC(s,r,o),l=s.shape.length,u=new Array(l).fill(0),h=s.shape.slice();return c.map(e=>{const t=[...h];t[o]=e;const a=lG({inputs:{x:s},backend:n,attrs:{begin:u,size:t}});return u[o]+=e,a})}},UY="return sqrt(x);",HY=KU({opSnippet:UY,packedOpSnippet:UY,cpuKernelImpl:tU}),GY={kernelName:Fp,backendName:"webgl",kernelFunc:HY},qY={kernelName:Kp,backendName:"webgl",kernelFunc:KU({opSnippet:"return x * x;"})},KY="return (a - b) * (a - b);",XY=XU({opSnippet:KY,packedOpSnippet:KY}),YY={kernelName:qp,backendName:"webgl",kernelFunc:XY};const QY={kernelName:Xp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");const r=nI(n.readSync(s.dataId)),i=nU(r,"string",a);return n.makeTensorInfo(s.shape,"string",i)}};const ZY={kernelName:hf,backendName:"webgl",kernelFunc:function(e){let{inputs:t,attrs:n,backend:a}=e;const{x:s}=t,r=wU+"\n    return x > 0.0 ? 1.0 : float(".concat(n.alpha,");\n  "),i=new vU(s.shape,r);return a.runWebGLProgram(i,[s],s.dtype)}};class JY{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;const a=n.length,s=GW(n.length),r=GW(n.length);let i="";if(1===a)i="coords * strides + begin";else{let e=0;i=n.map((t,a)=>(e++,1===n.length?"coords * strides[".concat(a,"] + begin[").concat(a,"]"):"coords[".concat(e-1,"] * strides[").concat(a,"] + begin[").concat(a,"]"))).join(",")}this.userCode="\n      ".concat(s," begin = ").concat(s,"(").concat(e,");\n      ").concat(s," strides = ").concat(s,"(").concat(t,");\n\n      void main() {\n        ").concat(r," coords = getOutputCoords();\n        setOutput(getX(").concat(i,"));\n      }\n    ")}}const $Y={kernelName:Yp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{begin:r,end:i,strides:o,beginMask:c,endMask:l,ellipsisMask:u,newAxisMask:h,shrinkAxisMask:d}=a,{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:x,strides:v}=Tb(s.shape,r,i,o,c,l,u,h,d);let w;if(m)w=aH({inputs:{x:s},backend:n,attrs:{shape:f}});else if(g||y){bu(s.shape.length>=1,()=>"Input must have rank at least 1, got: ".concat(s.shape.length));const e=fb(b,x,v),t=lG({inputs:{x:s},backend:n,attrs:{begin:b,size:e}});w=aH({inputs:{x:t},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(t)}else{if(n.shouldExecuteOnCPU([s])){const e=n.readSync(s.dataId),t=ny(s.shape,s.dtype,e),a=aU(p,t,v,b);w=n.makeTensorInfo(f,s.dtype,a.values)}else{const e=new JY(b,v,p);w=n.runWebGLProgram(e,[s],s.dtype)}}const k=aH({inputs:{x:w},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(w),k}};const eQ={kernelName:Qp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{separator:s,nGramWidths:r,leftPad:i,rightPad:o,padWidth:c,preserveShortSequences:l}=a,{data:u,dataSplits:h}=t,d=n.readSync(u.dataId),p=n.readSync(h.dataId),[f,m]=sU(d,p,s,r,i,o,c,l);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(h.shape,"int32",m)]}};const tQ={kernelName:Zp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{skipEmpty:s}=a,{input:r,delimiter:i}=t;if("string"!==r.dtype)throw new Error("Input must be of datatype string");if(1!==r.shape.length)throw new Error("Input must be a vector, got shape: ".concat(r.shape));if(0!==i.shape.length)throw new Error("Delimiter must be a scalar, got shape: ".concat(i.shape));const o=n.readSync(r.dataId),c=n.readSync(i.dataId)[0],[l,u,h]=rU(o,c,s),d=u.length;return[n.makeTensorInfo([d,2],"int32",l),n.makeTensorInfo([d],"string",u),n.makeTensorInfo([2],"int32",new Int32Array(h))]}};const nQ={kernelName:Jp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{numBuckets:s}=a,{input:r}=t;if("string"!==r.dtype)throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const i=n.readSync(r.dataId),o=iU(i,s);return n.makeTensorInfo(r.shape,"int32",o)}},aQ=KU({opSnippet:"return tan(x);"}),sQ={kernelName:ef,backendName:"webgl",kernelFunc:aQ},rQ=KU({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),iQ={kernelName:tf,backendName:"webgl",kernelFunc:rQ};const oQ={kernelName:Np,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{tensor:s,indices:r,updates:i}=t,{}=a,{sliceRank:o,numUpdates:c,sliceSize:l,strides:u,outputSize:h}=fk(0,r,s.shape),d=[h/l,l];if(0===h)return n.makeTensorInfo(s.shape,r.dtype);const p=aH({inputs:{x:r},backend:n,attrs:{shape:[c,o]}}),f=aH({inputs:{x:i},backend:n,attrs:{shape:[c,l]}}),m=aH({inputs:{x:s},backend:n,attrs:{shape:d}}),g=new yY(c,o,p.shape.length,f.shape.length,u,d,!1,!0),y=n.runWebGLProgram(g,[f,p,m],m.dtype),b=aH({inputs:{x:y},backend:n,attrs:{shape:s.shape}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(y),b}};class cQ{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[r]*t[r];this.outputShape=n,this.rank=n.length;const a=GW(this.rank),s=function(e){const t=e.length;if(t>5)throw Error("Tile for rank ".concat(t," is not yet supported"));if(1===t)return"imod(resRC, ".concat(e[0],")");const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],a=[];for(let s=0;s<e.length;s++)a.push("imod(".concat(n[s],", ").concat(e[s],")"));return a.join()}(e);this.userCode="\n      void main() {\n        ".concat(a," resRC = getOutputCoords();\n        setOutput(getA(").concat(s,"));\n      }\n    ")}}function lQ(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{reps:r}=a;if("string"===s.dtype||s.shape.length>5){const e=n.readSync(s.dataId),t="string"===s.dtype?e.map(e=>qf(e)):e,a=ny(s.shape,s.dtype,t),i=cU(a,r);return n.makeTensorInfo(i.shape,i.dtype,i.values)}const i=new cQ(s.shape,r);return n.runWebGLProgram(i,[s],s.dtype)}const uQ={kernelName:nf,backendName:"webgl",kernelFunc:lQ};class hQ{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class dQ{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}function pQ(e,t){null!==t&&e.disposeIntermediateTensorInfo(t)}function fQ(e){let t=1;for(;t<e;)t*=2;return t}const mQ={kernelName:af,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{k:r,sorted:i}=a,o=eh().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),c=eh().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),l=s.shape,u=l[l.length-1];if(n.shouldExecuteOnCPU([s])||u<o||r>c){const e=n.readSync(s.dataId),[t,a]=lU(e,l,s.dtype,r,i);return[n.makeTensorInfo(t.shape,t.dtype,t.values),n.makeTensorInfo(a.shape,a.dtype,a.values)]}if(0===r)return l[l.length-1]=0,[n.makeTensorInfo(l,s.dtype,[]),n.makeTensorInfo(l,"int32",[])];if(1===u)return[s,Kq({attrs:{shape:l,dtype:"int32",value:0},backend:n})];const h=n.texData.get(s.dataId),d=null!==h&&h.isPacked,p=d?n.unpackTensor(s):s,f=wu(l)/u,m=aH({inputs:{x:p},attrs:{shape:[f,u]},backend:n});d&&pQ(n,p);const g=fQ(r),y=fQ(u);let b=null;const x=()=>null===b?[m,m]:[m,b],v=(e,t,a)=>{const s=x(),r=new hQ(a),i=[[u],[null===b?1:0],[Number.NEGATIVE_INFINITY],[e],[t]],o=b;b=n.runWebGLProgram(r,s,"int32",i),pQ(n,o)};for(let I=1;I<g;I*=2){const e=2*I;for(let t=I;t>=1;t/=2)v(e,t,[f,y])}for(let I=y;I>g;I/=2){const e=x(),t=new dQ([f,I/2]),a=[[u],[null===b?1:0],[g]],s=b;b=n.runWebGLProgram(t,e,"int32",a),pQ(n,s);const r=g/2,i=2*r;for(let n=r;n>=1;n/=2)v(i,n,b.shape)}let w=b;b=lG({inputs:{x:b},backend:n,attrs:{begin:0,size:[f,r]}}),pQ(n,w);let k=dK({inputs:{x:m,indices:b},backend:n,attrs:{axis:1,batchDims:1}});pQ(n,m);const S=l.slice(0,-1);S.push(r),w=b,b=aH({inputs:{x:b},attrs:{shape:S},backend:n}),pQ(n,w);const C=k;return k=aH({inputs:{x:k},attrs:{shape:S},backend:n}),pQ(n,C),[k,b]}};class gQ{constructor(e,t,n,a,s,r){this.variableNames=["Image","Transforms"],this.outputShape=r;const i="nearest"===n?1:2;let o;switch(a){case"constant":default:o=1;break;case"reflect":o=2;break;case"wrap":o=3;break;case"nearest":o=4}this.userCode="\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(".concat(o," == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (").concat(o," == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (").concat(o," == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ").concat(e," && 0 <= coordX && coordX < ").concat(t,") {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(").concat(s,");\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(").concat(s,");\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(").concat(t,"));\n                float mapY = mapCoord(inY, float(").concat(e,"));\n\n                if (").concat(i," == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        ")}}const yQ={kernelName:sf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{image:s,transforms:r}=t,{interpolation:i,fillMode:o,fillValue:c,outputShape:l}=a,[u,h,d,p]=s.shape,[f,m]=null!=l?l:[h,d],g=new gQ(h,d,i,o,c,[u,f,m,p]);return n.runWebGLProgram(g,[s,r],"float32")}};const bQ={kernelName:of,backendName:"webgl",kernelFunc:function(e){const{inputs:t,attrs:n,backend:a}=e,{axis:s}=n,{x:r}=t;TW(r,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const i=a.readSync(r.dataId),{outputValues:o,outputShape:c,indices:l}=hU(i,s,r.shape,r.dtype);return[a.makeTensorInfo(c,r.dtype,o),a.makeTensorInfo([l.length],"int32",l)]}};const xQ={kernelName:cf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{value:s}=t;let{axis:r}=a;r<0&&(r+=s.shape.length);const i=s,o=i.shape.length,c=s.shape[r],l=new Array(o-1);let u=0;for(let m=0;m<o;m++)m!==r&&(l[u++]=i.shape[m]);const h=[],d=new Array(o).fill(0),p=i.shape.slice();p[r]=1;const f=new Array(c);for(let m=0;m<f.length;m++){d[r]=m;const e=lG({inputs:{x:i},backend:n,attrs:{begin:d,size:p}}),t=aH({inputs:{x:e},backend:n,attrs:{shape:l}});f[m]=t,h.push(e)}return h.forEach(e=>n.disposeIntermediateTensorInfo(e)),f}};class vQ{constructor(e,t){this.variableNames=["x","segmentIds"];const n=e.windowSize,a=e.batchSize,s=e.inSize,r=e.numSegments,i=r*Math.ceil(s/n);this.outputShape=[a,i];const o=4*Math.floor(n/4),c=n%4,l="\n        sumValue += dot(values, segFilter);\n    ";let u="";s%n>0&&(u="\n        if (inIdx < 0 || inIdx >= ".concat(s,") {\n          return initializationValue;\n        }\n      "));let h="";s%n>0&&(h="\n        if (inIdx < 0 || inIdx >= ".concat(s,") {\n          return -1.0;\n        }\n      ")),this.userCode="\n      const float initializationValue = ".concat("0.0",";\n\n      float getValue(int batch, int inIdx) {\n        ").concat(u,"\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ").concat(h,"\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ").concat(r,")) * float(").concat(n,"));\n        int currentSeg = int(mod(float(outIdx), float(").concat(r,")));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ").concat(o,"; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ").concat(l,"\n        }\n\n        int inIdx = inOffset + ").concat(o,";\n        if (").concat(1===c,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ").concat(l,"\n        } else if (").concat(2===c,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ").concat(l,"\n        } else if (").concat(3===c,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ").concat(l,"\n        }\n        setOutput(").concat("sumValue",");\n      }\n    ")}}const wQ={kernelName:lf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,segmentIds:r}=t,{numSegments:i}=a,o=s.shape.length,c=[];let l=0;const u=tv([l],o);let h=s;null!=u&&(h=pH({inputs:{x:s},backend:n,attrs:{perm:u}}),c.push(h),l=av(1,o)[0]);const d=eI(h.shape,l,i),p=wu([h.shape[l]]),f=aH({inputs:{x:h},backend:n,attrs:{shape:[-1,p]}});c.push(f);const m=ym(s.dtype),g=(e,t,a,s,r)=>{const i=e.shape[0],o=e.shape[1],l=$C(o,r),u=new vQ({windowSize:l,inSize:o,batchSize:i,numSegments:r},t),h=n.compileAndRun(u,[e,a],s);if(c.push(h),h.shape[1]===r)return h;const d=HX({backend:n,attrs:{start:0,stop:r,step:1,dtype:"float32"}}),p=lQ({inputs:{x:d},backend:n,attrs:{reps:[o/l]}});c.push(d),c.push(p);return g(h,t,p,s,r)},y=aH({inputs:{x:g(f,"unsortedSegmentSum",r,m,i)},backend:n,attrs:{shape:d}});let b=y;if(null!=u){c.push(y);const e=nv(u);b=pH({inputs:{x:b},backend:n,attrs:{perm:e}})}return c.forEach(e=>n.disposeIntermediateTensorInfo(e)),b}},kQ=[gH,bH,vH,kH,IH,EH,RH,_H,FH,LH,BH,WH,UH,GH,KH,QH,ZH,eG,tG,nG,rG,hG,dG,pG,fG,xG,kG,IG,BU,EG,FG,HG,YG,ZG,JG,$G,eq,nq,sq,iq,dq,pq,fq,gq,xq,kq,Sq,Iq,Tq,Eq,_q,Aq,Pq,Oq,Lq,Bq,Vq,Gq,Xq,Qq,$q,tK,sK,oK,cK,uK,pK,mK,yK,LU,bK,PG,vK,kK,CK,VU,NK,EK,RK,AK,PK,OK,LK,BK,VK,HK,qK,XK,YK,QK,$K,eX,tX,nX,aX,rX,cX,uX,xX,nH,wX,SX,IX,TX,gG,RX,MX,PX,LX,BX,GU,jX,WX,VX,UX,GX,bG,pX,KX,YX,ZX,sH,eY,nY,rY,oY,uY,dY,fY,gY,xY,wY,SY,IY,TY,RY,AY,PY,uG,bX,OY,FY,LY,zY,BY,jY,WY,VY,GY,qY,YY,QY,ZY,$Y,eQ,tQ,nQ,gX,dH,sQ,iQ,oQ,uQ,mQ,yQ,fH,bQ,xQ,wQ,AX];for(const n of kQ)Cf(n);var SQ=n(879);const CQ=eh();CQ.registerFlag("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE",()=>15),CQ.registerFlag("WEBGPU_CPU_FORWARD",()=>!0),CQ.registerFlag("WEBGPU_MATMUL_PROGRAM_TYPE",()=>-1),CQ.registerFlag("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE",()=>!0),CQ.registerFlag("WEBGPU_USE_LOW_POWER_GPU",()=>!1),CQ.registerFlag("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e3),CQ.registerFlag("WEBGPU_USE_PROFILE_TOOL",()=>!1),CQ.registerFlag("WEBGPU_IMPORT_EXTERNAL_TEXTURE",()=>!0),CQ.registerFlag("WEBGPU_USE_NAIVE_CONV2D_DEBUG",()=>!1),CQ.registerFlag("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL",()=>-1),CQ.registerFlag("WEBGPU_CONV_SEPARATE_IM2COL_SHADER",()=>!1),CQ.registerFlag("WEBGPU_PRINT_SHADER",()=>""),CQ.registerFlag("WEBGPU_ENGINE_COMPILE_ONLY",()=>!1);class IQ{constructor(e){e&&(this.vendor=e.vendor,this.architecture=e.architecture,this.intelGPUGeneration=this.getIntelGPUGeneration())}getIntelGPUGeneration(){if(this.isIntel()){if(this.architecture.startsWith("gen"))return Number(this.architecture.match(/\d+/));if(this.architecture.startsWith("xe"))return 12}return 0}isIntel(){return"intel"===this.vendor}}class NQ{constructor(e){this.device=e,this.numUsedBuffers=0,this.numFreeBuffers=0,this.freeBuffers=new Map,this.usedBuffers=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireBuffer(e,t){let n,a=arguments.length>2&&void 0!==arguments[2]&&arguments[2],s=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];const r=TQ(e,t);return s?(this.freeBuffers.has(r)||this.freeBuffers.set(r,[]),this.freeBuffers.get(r).length>0?(n=this.freeBuffers.get(r).pop(),this.numFreeBuffers--):(n=this.device.createBuffer({size:e,usage:t,mappedAtCreation:a}),this.numBytesAllocated+=e)):(n=this.device.createBuffer({size:e,usage:t,mappedAtCreation:a}),this.numBytesAllocated+=e),this.usedBuffers.has(r)||this.usedBuffers.set(r,[]),this.usedBuffers.get(r).push(n),this.numUsedBuffers++,this.numBytesUsed+=e,n}releaseBuffer(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];if(0===this.freeBuffers.size)return;const n=e.size,a=TQ(n,e.usage),s=this.usedBuffers.get(a),r=s.indexOf(e);if(r<0)throw new Error("Cannot find the buffer in buffer manager");s[r]=s[s.length-1],s.pop(),this.numUsedBuffers--,this.numBytesUsed-=n,t?(this.freeBuffers.get(a).push(e),this.numFreeBuffers++):(e.destroy(),this.numBytesAllocated-=n)}getNumUsedBuffers(){return this.numUsedBuffers}getNumFreeBuffers(){return this.numFreeBuffers}dispose(){this.freeBuffers.forEach((e,t)=>{e.forEach(e=>{e.destroy()})}),this.usedBuffers.forEach((e,t)=>{e.forEach(e=>{e.destroy()})}),this.freeBuffers=new Map,this.usedBuffers=new Map,this.numUsedBuffers=0,this.numFreeBuffers=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function TQ(e,t){return"".concat(e,"_").concat(t)}class EQ{constructor(e){this.device=e,this.numUsedTextures=0,this.numFreeTextures=0,this.freeTextures=new Map,this.usedTextures=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireTexture(e,t,n,a){const s=e*t*_Q(n),r=RQ(e,t,n,a);if(this.freeTextures.has(r)||this.freeTextures.set(r,[]),this.usedTextures.has(r)||this.usedTextures.set(r,[]),this.numBytesUsed+=s,this.numUsedTextures++,this.freeTextures.get(r).length>0){this.numFreeTextures--;const e=this.freeTextures.get(r).shift();return this.usedTextures.get(r).push(e),e}this.numBytesAllocated+=s;const i=this.device.createTexture({size:[e,t],format:n,usage:a});return this.usedTextures.get(r).push(i),i}releaseTexture(e){if(0===this.freeTextures.size)return;const t=e.width,n=e.height,a=e.format,s=RQ(t,n,a,e.usage);this.freeTextures.has(s)||this.freeTextures.set(s,[]),this.freeTextures.get(s).push(e),this.numFreeTextures++,this.numUsedTextures--;const r=this.usedTextures.get(s),i=r.indexOf(e);if(i<0)throw new Error("Cannot release a texture that was never provided by this texture manager");r.splice(i,1);const o=t*n*_Q(a);this.numBytesUsed-=o}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){this.freeTextures.forEach((e,t)=>{e.forEach(e=>{e.destroy()})}),this.usedTextures.forEach((e,t)=>{e.forEach(e=>{e.destroy()})}),this.freeTextures=new Map,this.usedTextures=new Map,this.numUsedTextures=0,this.numFreeTextures=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function RQ(e,t,n,a){return"".concat(e,"_").concat(t,"_").concat(n,"_").concat(a)}function _Q(e){if("rgba8unorm"===e)return 16;throw new Error("".concat(e," is not supported!"))}function AQ(e,t){if(Math.max(...e)>5)throw new Error("Cannot symbolically compute strides for rank > 6 tensor.");const n=e.length,a=e.map(e=>"".concat(t,".").concat("xyzwuv"[e])),s=new Array(n-1);s[n-2]=a[n-1];for(let r=n-3;r>=0;--r)s[r]="(".concat(s[r+1]," * ").concat(a[r+1],")");return s}const MQ=(e,t,n)=>"int32"===n?"atomicAdd(".concat(e,", bitcast<i32>(").concat(t,"));"):"\n          {\n            var oldValue = 0;\n            loop {\n              let newValueF32 = bitcast<f32>(oldValue) + (".concat(t,");\n              let newValue = bitcast<i32>(newValueF32);\n              let res = atomicCompareExchangeWeak(").concat(e,", oldValue, newValue);\n              if res.exchanged {\n                break;\n              }\n              oldValue = res.old_value;\n            }\n          }");var PQ;!function(e){e[e.FROM_PIXELS=0]="FROM_PIXELS",e[e.DRAW=1]="DRAW"}(PQ||(PQ={}));const DQ=(e,t,n,a,s)=>{const r=function(e,t,n){const a=[],s=n.workgroupSize[0]*n.workgroupSize[1]*n.workgroupSize[2];if(n.outputComponent=n.outputComponent?n.outputComponent:1,a.push("\n\n      var<private> localId: vec3<u32>;\n      var<private> localIndex: u32;\n      var<private> globalId: vec3<u32>;\n      var<private> numWorkgroups: vec3<u32>;\n      var<private> workgroupId: vec3<u32>;\n\n      // Only used when the y/z dimension of workgroup size is 1.\n      fn getGlobalIndex() -> i32 {\n        ".concat(HQ(n)?"  return i32(globalId.x);":"  return i32((workgroupId.z * numWorkgroups.x * numWorkgroups.y +\n                workgroupId.y * numWorkgroups.x + workgroupId.x) * ".concat(s,"u +\n                localIndex);\n        "),"\n      }\n    ")),null!=n.pixelsOpType){const s=n.pixelsOpType===PQ.FROM_PIXELS?"@group(0) @binding(0) var<storage, read_write> result: array<".concat(GQ(t.dtype,n.outputComponent),">;"):"@group(0) @binding(1) var<storage, read> inBuf : array<".concat(GQ(e[0].dtype,n.outputComponent),">;"),r=3===t.shape.length?"vec2<i32>":"i32";a.push("\n        struct Uniform {\n          outShapeStrides : ".concat(r,",\n          size            : i32,\n          numChannels     : i32,\n          alpha           : f32,\n        };\n\n        ").concat(s,"\n        @group(0) @binding(2) var<uniform> uniforms: Uniform;\n      "));const i=qQ(n);return[jQ,a.join("\n"),VQ(t.shape),n.getUserCode(),BQ(i,n)].join("\n")}let r,i,o="struct Uniforms { NAN : f32, INFINITY : f32, ";n.variableNames.forEach((t,n)=>{const a=FQ(e[n].shape.length);o+="".concat(t.charAt(0).toLowerCase()+t.slice(1),"Shape : ").concat(a,", "),r=e[n].shape.length-1,i=FQ(r),o+="".concat(t.charAt(0).toLowerCase()+t.slice(1),"ShapeStrides: ").concat(i,", ")});const c=FQ(t.shape.length);o+="outShape : ".concat(c,", "),r=t.shape.length-1,i=FQ(r),o+="\n         outShapeStrides: ".concat(i,", "),n.size&&(o+="size : i32, ");n.uniforms&&(o+=n.uniforms);o+="};",o=function(e){const t=/(\w+)\s*:\s*vec(5|6)/g;e=e.replace(t,e=>"@align(16) "+e);const n=/vec(5|6)\s*,\s*(\w+)/g;return e=e.replace(n,(e,t,n)=>"vec".concat(t,", @align(16) ").concat(n))}(o),a.push(o),n.atomic?a.push("\n      @group(0) @binding(0) var<storage, read_write> result: array<atomic<i32>>;\n    "):a.push("\n      @group(0) @binding(0) var<storage, read_write> result: array<".concat(GQ(t.dtype,n.outputComponent),">;\n    "));n.variableNames.forEach((t,s)=>{a.push("\n      @group(0) @binding(".concat(1+s,") var<storage, read> ").concat(t,": array<").concat(n.variableComponents?GQ(e[s].dtype,n.variableComponents[s]):GQ(e[s].dtype,n.outputComponent),">;\n        "))}),""!==o&&a.push("\n      @group(0) @binding(".concat(1+n.variableNames.length,") var<uniform> uniforms: Uniforms;\n      "));const l=function(e,t){const{x:n,y:a=[],z:s=[]}=t,r=e.length,i=n.length+a.length+s.length;if(i!==r)return"";if(n.length===r){const e=FQ(r);return"fn getOutputCoords() -> ".concat(e,"{\n    let globalIndex = getGlobalIndex();\n    return getCoordsFromIndex(globalIndex);\n  }\n  ")}let o="";const c=[n,a,s];for(let d=0;d<c.length;d++){const e=c[d];if(0!==e.length)if(1===e.length)o+="let d".concat(e[0]," = i32(globalId[").concat(d,"]);");else{const t=AQ(e,"uniforms.outShape");o+="var index".concat(d," = i32(globalId[").concat(d,"]);");for(let n=0;n<t.length;n++)o+="let d".concat(e[n]," = index").concat(d," / ").concat(t[n],";"),n===t.length-1?o+="let d".concat(e[n+1]," = ")+"index".concat(d," - d").concat(e[n]," * ").concat(t[n],";"):o+="index".concat(d," = index").concat(d," - d").concat(e[n]," * ").concat(t[n],";")}}const l=[];for(let d=0;d<i;d++)l.push("d".concat(d));const u=FQ(i);let h="fn getOutputCoords() -> ".concat(u," {\n  ").concat(o,"\n");0===l.length?h+="return ".concat(u,"(0); }"):h+="return ".concat(u,"(").concat(l.join(","),"); }");return h}(t.shape,n.dispatchLayout),u=[jQ,a.join("\n")+WQ,VQ(t.shape),l,UQ(t.shape.length)];n.atomic||u.push(function(e,t,n){const a=e.length,s=GQ(t,n);let r="fn setOutputAtIndex(flatIndex : i32, value : ".concat(OQ(n),") {\n      result[flatIndex] = ").concat(s,"(value);\n    }\n\n    fn setOutputAtIndexI32(flatIndex : i32, value : ").concat(OQ(n,"i32"),") {\n      result[flatIndex] = ").concat(s,"(value);\n    }\n    ");if(a>=2){const e=["d0","d1","d2","d3","d4","d5"].slice(0,a),t=FQ(a);r+="\n      fn setOutputAtCoords(".concat(e.map(e=>"".concat(e," : i32")).join(", "),", value : ").concat(OQ(n),") {\n        let flatIndex = getOutputIndexFromCoords(").concat(t,"(").concat(e.join(", "),"));\n        setOutputAtIndex(flatIndex").concat(1===n?"":" / ".concat(n),", value);\n      }\n      fn setOutputAtCoordsI32(").concat(e.map(e=>"".concat(e," : i32")).join(", "),", value : ").concat(OQ(n,"i32"),") {\n        let flatIndex = getOutputIndexFromCoords(").concat(t,"(").concat(e.join(", "),"));\n        setOutputAtIndexI32(flatIndex").concat(1===n?"":" / ".concat(n),", value);\n      }\n    ")}return r}(t.shape,t.dtype,n.outputComponent));n.variableNames.forEach((t,n)=>{u.push("".concat(VQ(e[n].shape,t)))});const h=e.map((e,a)=>function(e,t,n,a){let s=function(e,t){const n=e.name,a=e.shape.length,s=FQ(a),r="get"+n.charAt(0).toUpperCase()+n.slice(1),i=["d0","d1","d2","d3","d4","d5"].slice(0,a),o=i.map(e=>"".concat(e," : i32")).join(", ");if(a<1)return"\n      fn ".concat(r,"() -> ").concat(OQ(t)," {\n        return ").concat(OQ(t),"(").concat(n,"[0]);\n      }\n    ");const c="uniforms.".concat(n.charAt(0).toLowerCase()+n.slice(1),"Shape");let l="".concat(a,"D");0===a&&(l="1D");return"\n    fn ".concat(r,"(").concat(o,") -> ").concat(OQ(t)," {\n      return ").concat(OQ(t),"(").concat(n,"[getIndexFromCoords").concat(l,"(").concat(s,"(").concat(i.join(","),"),\n        ").concat(c,")").concat(1===t?"":" / ".concat(t),"]);\n    }\n   ")}(e,n);const r=e.shape;r.length<=t.length&&(s+=function(e,t,n,a){const s=e.name,r=s.charAt(0).toUpperCase()+s.slice(1),i="get"+r+"ByOutput",o=e.shape.length,c=t.length,l=FQ(c);if(Su(e.shape,t)&&a)return"\n    fn ".concat(i,"Index(globalIndex : i32) -> ").concat(OQ(n)," {\n      return ").concat(OQ(n),"(").concat(s,"[globalIndex]);\n    }\n\n    fn ").concat(i,"Coords(coords : ").concat(l,") -> ").concat(OQ(n)," {\n      return ").concat(OQ(n),"(").concat(s,"[").concat(c>1?"getOutputIndexFromCoords(coords)":"coords").concat(1===n?"":" / ".concat(n),"]);\n    }\n    ");const u=Ey(e.shape,t),h=c-o;let d="";if(0===o)return"\n    fn ".concat(i,"Index(globalIndex : i32) -> ").concat(OQ(n),"{\n      return get").concat(r,"();\n    }\n\n    fn ").concat(i,"Coords(coords : ").concat(l,") -> ").concat(OQ(n),"{\n      return get").concat(r,"();\n    }\n  ");d=c<2&&u.length>=1?"coords = 0;":u.map(e=>"coords.".concat(LQ(e+h)," = 0;")).join("\n");let p="";if(c<2&&o>0)p="coords";else if(c>1){const t=FQ(o),n=e.shape.map((e,t)=>"coords.".concat(LQ(t+h))).join(", ");p="".concat(t,"(").concat(n,")")}else p="coords";const f="uniforms.".concat(s.charAt(0).toLowerCase()+s.slice(1),"Shape"),m="".concat(o,"D");return"\n  fn ".concat(i,"Index(globalIndex : i32) -> ").concat(OQ(n)," {\n    var coords = getCoordsFromIndex(globalIndex);\n    ").concat(d,"\n    return ").concat(OQ(n),"(").concat(s,"[getIndexFromCoords").concat(m,"(").concat(p,", ").concat(f,")").concat(1===n?"":" / ".concat(n),"]);\n  }\n\n  fn ").concat(i,"Coords(coordsIn : ").concat(l,") -> ").concat(OQ(n)," {\n    var coords = coordsIn;\n    ").concat(d,"\n    return ").concat(OQ(n),"(").concat(s,"[getIndexFromCoords").concat(m,"(").concat(p,", ").concat(f,")").concat(1===n?"":" / ".concat(n),"]);\n  }\n")}(e,t,n,a));return s}(e,t.shape,n.variableComponents?n.variableComponents[a]:n.outputComponent,n.dispatchLayout.x.length===t.shape.length)).join("\n");u.push(h),u.push(n.getUserCode());const d=qQ(n);u.push(BQ(d,n));const p=u.join("\n");return p}(n,{dtype:a.dtype,shape:a.shape},t),i=e.createShaderModule({code:r,label:t.constructor.name});let o=eh().get("WEBGPU_PRINT_SHADER");if(""!==o){o=o.toLowerCase();const e=o.split(",");("all"===o||e.some(e=>t.shaderKey.toLowerCase().includes(e)))&&(console.group(t.shaderKey),console.debug(r),console.groupEnd())}return s?e.createComputePipelineAsync({compute:{module:i,entryPoint:"_start"},label:t.constructor.name,layout:"auto"}):e.createComputePipeline({compute:{module:i,entryPoint:"_start"},label:t.constructor.name,layout:"auto"})},OQ=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"f32";switch(e){case 1:return"".concat(t);case 2:return"vec2<".concat(t,">");case 3:return"vec3<".concat(t,">");case 4:return"vec4<".concat(t,">");default:throw new Error("".concat(e,"-component ").concat(t," is not supported."))}};function FQ(e){if(e<=1)return"i32";if(2===e)return"vec2<i32>";if(3===e)return"vec3<i32>";if(4===e)return"vec4<i32>";if(5===e)return"vec5";if(6===e)return"vec6";throw Error("GPU for rank ".concat(e," is not yet supported"))}function LQ(e){if(0===e)return"x";if(1===e)return"y";if(2===e)return"z";if(3===e)return"w";if(4===e)return"u";if(5===e)return"v";throw Error("Index ".concat(e," is not yet supported"))}function zQ(){let e;switch(arguments.length){case 0:e="\n        fn main()\n      ";break;case 1:e="\n        fn main(".concat(arguments.length<=0?void 0:arguments[0]," : i32)\n      ");break;default:throw Error("Unreachable")}return e}function BQ(e,t){let n;return n="\n     ".concat(function(e){return"\n  @compute @workgroup_size(".concat(e.workgroupSize[0],", ").concat(e.workgroupSize[1],", ").concat(e.workgroupSize[2],")\n")}(t),"\n      fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,\n                @builtin(global_invocation_id) GlobalId : vec3<u32>,\n                @builtin(local_invocation_index) LocalIndex: u32,\n                @builtin(workgroup_id) WorkgroupId : vec3<u32>,\n                @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {\n        localId = LocalId;\n        localIndex = LocalIndex;\n        globalId = GlobalId;\n        numWorkgroups = NumWorkgroups;\n        workgroupId = WorkgroupId;\n        ").concat(e?"main(getGlobalIndex());":"main();",";\n      }\n    "),n}const jQ="\n  struct vec5 {x: i32, y: i32, z: i32, w: i32, u: i32};\n  struct vec6 {x: i32, y: i32, z: i32, w: i32, u: i32, v: i32};\n\n  // Checks whether coordinates lie within the bounds of the shape.\n  fn coordsInBounds2D(coord : vec2<i32>, shape : vec2<i32>) -> bool {\n    return all(coord >= vec2<i32>(0)) && all(coord < shape);\n  }\n  fn coordsInBounds3D(coord : vec3<i32>, shape : vec3<i32>) -> bool {\n    return all(coord >= vec3<i32>(0)) && all(coord < shape);\n  }\n  fn coordsInBounds4D(coord : vec4<i32>, shape : vec4<i32>) -> bool {\n    return all(coord >= vec4<i32>(0)) && all(coord < shape);\n  }\n\n  fn getIndexFromCoords1D(coord : i32, shape : i32) -> i32 {\n    return coord;\n  }\n  fn getIndexFromCoords2D(coords : vec2<i32>, shape : vec2<i32>) -> i32 {\n    return dot(coords, vec2<i32>(shape.y, 1));\n  }\n  fn getIndexFromCoords3D(coords : vec3<i32>, shape : vec3<i32>) -> i32 {\n    return dot(coords, vec3<i32>(shape.y * shape.z, shape.z, 1));\n  }\n  fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\n    return dot(coords, vec4<i32>(\n        shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\n  }\n  fn getIndexFromCoords5D(coords : vec5, shape : vec5) -> i32 {\n    let shapeStrides: vec5 = vec5(shape.y * shape.z * shape.w * shape.u, shape.z * shape.w * shape.u, shape.w * shape.u, shape.u, 1);\n    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u;\n  }\n  fn getIndexFromCoords6D(coords : vec6, shape : vec6) -> i32 {\n    let shapeStrides: vec6 = vec6(shape.y * shape.z * shape.w * shape.u * shape.v, shape.z * shape.w * shape.u * shape.v, shape.w * shape.u * shape.v, shape.u * shape.v, shape.v, 1);\n    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u + coords.v*shapeStrides.v;\n  }\n\n  // NaN defination in IEEE 754-1985 is :\n  //   - sign = either 0 or 1.\n  //   - biased exponent = all 1 bits.\n  //   - fraction = anything except all 0 bits (since all 0 bits represents infinity).\n  // https://en.wikipedia.org/wiki/IEEE_754-1985#Representation_of_non-numbers\n  fn isnan(val: f32) -> bool {\n    let floatToUint: u32 = bitcast<u32>(val);\n    return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n  }\n  fn isnanVec4(val : vec4<f32>) -> vec4<bool> {\n    let floatToUint: vec4<u32> = bitcast<vec4<u32>>(val);\n    return (floatToUint & vec4<u32>(0x7fffffffu)) > vec4<u32>(0x7f800000u);\n  }\n",WQ="\n  fn isinf(val: f32) -> bool {\n    return abs(val) == uniforms.INFINITY;\n  }\n";function VQ(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"";const n=e.length,a=""!==t?"get".concat(t.charAt(0).toUpperCase()+t.slice(1),"CoordsFromIndex"):"getCoordsFromIndex",s=""!==t?"".concat(t.charAt(0).toLowerCase()+t.slice(1),"ShapeStrides"):"outShapeStrides";if(n<=1)return"fn ".concat(a,"(index : i32) -> i32 { return index; }");const r=ju(e),i=FQ(n),o=[];for(let l=0;l<n;l++)o.push("d".concat(l));if(1===r.length)return"    fn ".concat(a,"(index : i32) -> vec2<i32> {\n      let d0 = index / uniforms.").concat(s,"; let d1 = index - d0 * uniforms.").concat(s,";\n      return vec2<i32>(d0, d1);\n    }");let c;return c="var index2 = index;"+r.map((e,t)=>{const n="let ".concat(o[t]," = index2 / uniforms.").concat(s,".").concat(LQ(t)),a=t===r.length-1?"let ".concat(o[t+1]," = index2 - ").concat(o[t]," * uniforms.").concat(s,".").concat(LQ(t)):"index2 = index2 - ".concat(o[t]," * uniforms.").concat(s,".").concat(LQ(t));return"".concat(n,"; ").concat(a,";")}).join(""),"\n    fn ".concat(a,"(index : i32) -> ").concat(i," {\n      ").concat(c,"\n      return ").concat(i,"(").concat(o.join(","),");\n    }\n  ")}function UQ(e){let t="";switch(e){case 0:case 1:t+="\n        fn getOutputIndexFromCoords(coords : i32) -> i32 {\n          return coords;\n        }\n        ";break;case 2:t+="\n        fn getOutputIndexFromCoords(coords : vec2<i32>) -> i32 {\n          return dot(coords, vec2<i32>(uniforms.outShapeStrides, 1));\n        }\n        ";break;case 3:t+="\n        fn getOutputIndexFromCoords(coords : vec3<i32>) -> i32 {\n          return dot(coords, vec3<i32>(uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, 1));\n        }\n        ";break;case 4:t+="\n        fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\n          return dot(coords, vec4<i32>(\n            uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, uniforms.outShapeStrides.z, 1));\n        }\n        ";break;case 5:t+="\n        fn getOutputIndexFromCoords(coords : vec5) -> i32 {\n          return coords.x * uniforms.outShapeStrides.x +\n              coords.y * uniforms.outShapeStrides.y +\n              coords.z * uniforms.outShapeStrides.z +\n              coords.w * uniforms.outShapeStrides.w +\n              coords.u;\n        }\n        ";break;case 6:t+="\n        fn getOutputIndexFromCoords(coords : vec6) -> i32 {\n          return coords.x * uniforms.outShapeStrides.x +\n              coords.y * uniforms.outShapeStrides.y +\n              coords.z * uniforms.outShapeStrides.z +\n              coords.w * uniforms.outShapeStrides.w +\n              coords.u * uniforms.outShapeStrides.u +\n              coords.v;\n        }\n        ";break;default:bu(!1,()=>"Unsupported ".concat(e,"D shape"))}return t}function HQ(e){return 1===e.dispatch[1]&&1===e.dispatch[2]}function GQ(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if("float32"===e)return OQ(t,"f32");if("int32"===e||"bool"===e)return OQ(t,"i32");throw new Error("type ".concat(e," is not supported."))}function qQ(e){return(!e.dispatchLayout.hasOwnProperty("y")||0===e.dispatchLayout.y.length)&&(!e.dispatchLayout.hasOwnProperty("z")||0===e.dispatchLayout.z.length)}const KQ=e=>{let t=1;for(let n=0;n<e.length;n++)t*=e[n];return t};function XQ(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[1,1,1],a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[1,1,1];const[s,r,i]=[Math.ceil(KQ(e.x.map(e=>t[e]))/(n[0]*a[0])),e.y?Math.ceil(KQ(e.y.map(e=>t[e]))/(n[1]*a[1])):1,e.z?Math.ceil(KQ(e.z.map(e=>t[e]))/(n[2]*a[2])):1];return[s,r,i]}function YQ(e,t){if(arguments.length>2&&void 0!==arguments[2]&&arguments[2])return[8,8,1];const n=KQ(e.x.map(e=>t[e])),a=KQ(e.y.map(e=>t[e]));return n<=4?[4,16,1]:a<=4?[16,4,1]:[16,16,1]}function QQ(e,t){if(arguments.length>2&&void 0!==arguments[2]&&arguments[2])return[4,4,1];const n=KQ(e.x.map(e=>t[e])),a=KQ(e.y.map(e=>t[e]));return n<=4?[1,2,1]:a<=4?[2,1,1]:[2,2,1]}function ZQ(e){return{x:e.map((e,t)=>t)}}function JQ(e){if("float32"===e||"int32"===e||"bool"===e||"string"===e)return 4;if("complex64"===e)return 8;throw new Error("Unknown dtype ".concat(e))}function $Q(){return!("undefined"===typeof globalThis||!globalThis.navigator||!globalThis.navigator.gpu)}function eZ(e,t){Array.isArray(e)||(e=[e]),e.forEach(e=>{null!=e&&bu("complex64"!==e.dtype,()=>"".concat(t," does not support complex64 tensors ")+"in the WebGPU backend.")})}var tZ;!function(e){e[e.MatMulReduceProgram=0]="MatMulReduceProgram",e[e.MatMulSplitKProgram=1]="MatMulSplitKProgram",e[e.MatMulSmallOutputSizeProgram=2]="MatMulSmallOutputSizeProgram",e[e.MatMulPackedProgram=3]="MatMulPackedProgram",e[e.MatMulMax=4]="MatMulMax"}(tZ||(tZ={}));const nZ=eh().getNumber("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD");class aZ extends hu{nextDataId(){return aZ.nextDataId++}constructor(e,t){if(super(),this.commandQueueOwnedIds=new WeakSet,this.dispatchCountInPass=0,this.disposed=!1,this.downloadWaitMs=0,this.tensorDataPendingDisposal=[],this.queryResolveBuffer=null,this.querySet=null,this.querySetCount=2,this.stagingPendingDisposal=[],this.uniformPendingDisposal=[],this.uploadWaitMs=0,this.hasReadSyncWarned=!1,this.hasTimestampQueryWarned=!1,!$Q())throw new Error("WebGPU is not supported on this device");this.pipelineCache={},this.device=e,this.queue=e.queue,this.commandEncoder=null,this.computePassEncoder=null,this.adapterInfo=new IQ(t),this.supportTimestampQuery=this.device.features.has("timestamp-query"),this.thresholdToIncreaseWorkgroups=this.adapterInfo.intelGPUGeneration>=12?16:8,this.bufferManager=new NQ(this.device),this.textureManager=new EQ(this.device),this.tensorMap=new uu(this,qm()),eh().getBool("WEBGPU_USE_PROFILE_TOOL")&&(this.dummyCanvas=document.createElement("canvas"),this.dummyCanvas.width=1,this.dummyCanvas.height=1,this.dummyContext=this.dummyCanvas.getContext("webgpu"),this.dummyContext.configure({device:e,format:"bgra8unorm"}),document.body.appendChild(this.dummyCanvas))}floatPrecision(){return 32}disposeData(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this.tensorMap.has(e))return!0;const n=this.tensorMap.get(e);return t?n.refCount=0:n.refCount--,!(n.refCount>0)&&(null!=n.complexTensorInfos&&(this.disposeData(n.complexTensorInfos.real.dataId),this.disposeData(n.complexTensorInfos.imag.dataId)),this.commandQueueOwnedIds.has(e)?(this.tensorDataPendingDisposal.push(e),!0):(this.releaseResource(e),this.tensorMap.delete(e),!0))}memory(){return{numBytesInGPU:this.bufferManager.numBytesUsed,numBytesAllocatedInGPU:this.bufferManager.numBytesAllocated,unreliable:!1}}releaseResource(e){const t=this.tensorMap.get(e);t&&t.resource&&(t.external||(t.resource instanceof GPUBuffer?this.bufferManager.releaseBuffer(t.resource):t.resource instanceof GPUTexture&&this.textureManager.releaseTexture(t.resource)),t.resource=null)}refCount(e){if(this.tensorMap.has(e)){return this.tensorMap.get(e).refCount}return 0}incRef(e){this.tensorMap.get(e).refCount++}decRef(e){if(this.tensorMap.has(e)){this.tensorMap.get(e).refCount--}}write(e,t,n){if("complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const a={id:this.nextDataId()};return this.tensorMap.set(a,{dtype:n,shape:t,values:e,refCount:1}),a}move(e,t,n,a,s){if("complex64"===a)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.tensorMap.set(e,{dtype:a,shape:n,values:t,refCount:s})}submitQueue(){this.queue.submit([this.commandEncoder.finish()]),this.commandEncoder=null,this.dispatchCountInPass=0,this.commandQueueOwnedIds=new WeakSet,this.tensorDataPendingDisposal.forEach(e=>{this.releaseResource(e),this.tensorMap.delete(e)}),this.uniformPendingDisposal.forEach(e=>this.bufferManager.releaseBuffer(e)),this.stagingPendingDisposal.forEach(e=>this.bufferManager.releaseBuffer(e,!1)),this.tensorDataPendingDisposal=[],this.uniformPendingDisposal=[],this.stagingPendingDisposal=[]}ensureCommandEncoderReady(){this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder())}endComputePassEncoder(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}async checkCompileCompletionAsync(){let e;try{e=await Promise.all(Object.values(this.pipelineCache))}catch(q5){throw new Error(q5.message)}Object.keys(this.pipelineCache).map((t,n)=>{this.pipelineCache[t]=e[n]})}async getBufferData(e){if(eh().getBool("WEBGPU_ENGINE_COMPILE_ONLY"))return console.warn("The data may be invalid since WEBGPU_ENGINE_COMPILE_ONLY is true, this can only be called when WEBGPU_ENGINE_COMPILE_ONLY is false"),null;const t=e.size,n=this.bufferManager.acquireBuffer(t,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ);this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(e,0,n,0,t),this.submitQueue(),await n.mapAsync(GPUMapMode.READ);const a=n.getMappedRange().slice(0);return n.unmap(),null!=n&&this.bufferManager.releaseBuffer(n),eh().getBool("WEBGPU_USE_PROFILE_TOOL")&&(bu(void 0!==this.dummyContext,()=>"Fail to get context for profiling tool"),this.dummyContext.getCurrentTexture()),a}convertAndCacheOnCPU(e,t){const n=this.tensorMap.get(e);return n.values=t,n.values}readSync(e){const t=this.tensorMap.get(e),{values:n,complexTensorInfos:a}=t;if(null!=n||"string"===t.dtype)return n;if("complex64"===t.dtype){const t=Uu(kC(this.readSync(a.real.dataId),this.readSync(a.imag.dataId)).buffer,"float32");return this.convertAndCacheOnCPU(e,t),t}this.hasReadSyncWarned||(this.hasReadSyncWarned=!0,console.warn("The performance of synchronously reading data from GPU to CPU is poor on the webgpu backend, please use asynchronous APIs instead."));const s=["opaque","premultiplied"],r=t.resource,i=r.size;bu(i%4===0,()=>"Because there is 4 bytes for one pixel, buffer size must be multiple of 4.");const o=i/4,c=new ArrayBuffer(i),l=256,u=256,h=s.map(e=>new OffscreenCanvas(l,u)),d=new OffscreenCanvas(l,u);this.endComputePassEncoder(),h.map((e,t)=>{const n=e.getContext("webgpu");return n.configure({device:this.device,format:"bgra8unorm",usage:GPUTextureUsage.COPY_DST,alphaMode:s[t]}),n.getCurrentTexture()}).map((e,t)=>{const n=(n,a,i)=>{this.ensureCommandEncoderReady(),this.commandEncoder.copyBufferToTexture({buffer:r,bytesPerRow:1024,offset:i},{texture:e},{width:n,height:a}),this.submitQueue();const o=d.getContext("2d",{willReadFrequently:!0});o.clearRect(0,0,n,a),o.drawImage(h[t],0,0);const l=o.getImageData(0,0,n,a).data,u=s[t],p=new Uint8ClampedArray(c,i,n*a*4);for(let e=0;e<p.length;e+=4)if("premultiplied"===u)p[e+3]=l[e+3];else{const t=l[e];p[e]=l[e+2],p[e+1]=l[e+1],p[e+2]=t}},a=Math.floor(o/65536);let i=l,p=u,f=0;for(let s=0;s<a;s++)n(i,p,f),f+=262144;const m=o%65536;p=Math.floor(m/l),p>0&&(n(i,p,f),f+=1024*p),i=m%l,i>0&&n(i,1,f)});const p=Uu(c,t.dtype);return this.convertAndCacheOnCPU(e,p),p}async read(e){if(!this.tensorMap.has(e))throw new Error("Tensor ".concat(e," was not registered!"));const t=this.tensorMap.get(e),{values:n}=t;if(null!=n)return n;let a;if("complex64"===t.dtype){const e=await Promise.all([this.read(t.complexTensorInfos.real.dataId),this.read(t.complexTensorInfos.imag.dataId)]);a=kC(e[0],e[1])}else{a=Uu(await this.getBufferData(t.resource),t.dtype)}return this.convertAndCacheOnCPU(e,a),a}copyBuffer(e){const t=e.size,n=e.usage,a=this.bufferManager.acquireBuffer(t,n);return this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(e,0,a,0,t),this.submitQueue(),a}createTensorFromGPUData(e,t,n){let a=e.buffer;if("complex64"===n)throw new Error("Cannot write to a complex64 dtype. ");const s={id:this.nextDataId()};this.tensorMap.set(s,{dtype:n,shape:t,values:null,refCount:1,external:e.zeroCopy});const r=this.tensorMap.get(s),i=JQ(r.dtype)*wu(r.shape);if(e.buffer.size<i)throw new Error("GPUBuffer size(".concat(e.buffer.size,") is smaller than tensor size(").concat(i,")!"));if((e.buffer.usage&(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))!==(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))throw new Error("GPUBuffer.usage should include GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC!");return!0!==e.zeroCopy&&(a=this.copyBuffer(a)),r.resource=a,qm().makeTensorFromDataId(s,t,n,this)}readToGPU(e){const t=this.tensorMap.get(e),{values:n,dtype:a,shape:s,resource:r}=t;if("complex64"===a)throw new Error("Does not support reading buffer for complex64 dtype.");if(null==r)throw null!=n?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const i=r,o=i.size,c=i.usage,l=this.bufferManager.acquireBuffer(o,c);this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(r,0,l,0,o),this.submitQueue();const u=this.makeTensorInfo(s,a),h=qm().makeTensorFromTensorInfo(u);return this.tensorMap.get(u.dataId).resource=l,{tensorRef:h,buffer:l}}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map(e=>qf(e));return ny(e.shape,e.dtype,n)}catch(n){throw new Error("Failed to decode encoded string bytes into utf-8")}return ny(e.shape,e.dtype,t)}async time(e){this.supportTimestampQuery||this.hasTimestampQueryWarned||(console.warn("This device doesn't support timestamp-query extension. Start Chrome browser with flag --enable-dawn-features=allow_unsafe_apis to try it again. Otherwise, zero will be shown for the kernel time when profiling mode is enabled."),this.hasTimestampQueryWarned=!0);const t=this.activeTimers,n=[];let a=!1;null==this.programTimersStack?(this.programTimersStack=n,a=!0):this.activeTimers.push(n),this.activeTimers=n,e();const s=Xf(this.activeTimers.map(e=>e.query)).filter(e=>null!=e),r=Xf(this.activeTimers.map(e=>e.name)).filter(e=>null!=e);this.activeTimers=t,a&&(this.programTimersStack=null);const i={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null},o=await Promise.all(s);return i.kernelMs=yu(o),i.getExtraProfileInfo=()=>o.map((e,t)=>({name:r[t],ms:e})).map(e=>"".concat(e.name,": ").concat(e.ms)).join(", "),this.uploadWaitMs=0,this.downloadWaitMs=0,i}makeTensorInfo(e,t,n){"string"===t&&null!=n&&n.length>0&&Ou(n[0])&&(n=n.map(e=>Gf(e)));return{dataId:this.write(n,e,t),shape:e,dtype:t}}tensorToBinding(e){if(!e)return null;const t=this.tensorMap.get(e.dataId).resource;return t instanceof GPUBuffer?{buffer:t}:t instanceof GPUTexture?t.createView():t}uploadToGPU(e){const t=this.tensorMap.get(e);if(null!=t.resource)return;const n=JQ(t.dtype)*wu(t.shape);let a;const s=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST;if(t.values){if(a=this.bufferManager.acquireBuffer(n,s,!0),"unmapped"===a.mapState){const e=this.bufferManager.acquireBuffer(n,GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC,!0,!1),s=e.getMappedRange();"int32"===t.dtype||"bool"===t.dtype?new Int32Array(s).set(t.values):new Float32Array(s).set(t.values),e.unmap(),this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(e,0,a,0,n),this.stagingPendingDisposal.push(e)}else{const e=a.getMappedRange();"int32"===t.dtype||"bool"===t.dtype?new Int32Array(e).set(t.values):new Float32Array(e).set(t.values),a.unmap()}t.values=null}else a=this.bufferManager.acquireBuffer(n,s);t.resource=a}makeUniforms(e){let t=0,n=0;const a=[];let s=1;e.forEach(e=>{let r;switch(0===e.data.length&&(e.data=[1]),e.data.length){case 1:r=4;break;case 2:r=8;break;case 3:case 4:case 5:case 6:r=16;break;default:bu(!1,()=>"Unsupported ".concat(e.data.length,"D shape"))}5!==n&&6!==n||(r=16),r>s&&(s=r),t=Math.ceil(t/r)*r,n=e.data.length,a.push(t),t+=4*e.data.length}),t=Math.ceil(t/s)*s;const r=new ArrayBuffer(t);e.forEach((e,t)=>{const n=a[t];"int32"===e.type?new Int32Array(r,n,e.data.length).set(e.data):"uint32"===e.type?new Uint32Array(r,n,e.data.length).set(e.data):new Float32Array(r,n,e.data.length).set(e.data)});const i=this.bufferManager.acquireBuffer(t,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);return this.queue.writeBuffer(i,0,r,0,t),this.uniformPendingDisposal.push(i),{offset:0,size:t,buffer:i}}runWebGPUProgram(e,t,n,a,s){if(s||(s=this.makeTensorInfo(e.outputShape,n)),0===wu(s.shape))return this.tensorMap.get(s.dataId).values=Au(s.dtype,0),s;this.uploadToGPU(s.dataId),e.dispatch=((e,t)=>{const n=e.limits.maxComputeWorkgroupsPerDimension,a=t.dispatchLayout,s=t.dispatch;if(s.every(e=>e<=n))return s;bu(s[0]>n&&void 0===a.y&&void 0===a.z,()=>"Dispatch size exceeds WebGPU limits in Y or Z dimension.");let r=Math.ceil(Math.sqrt(s[0]));return r>n?(r=Math.ceil(Math.cbrt(s[0])),bu(r<=n,()=>"Total dispatch size exceeds WebGPU maximum."),[r,r,r]):[r,r,1]})(this.device,e);const r=t.map((t,n)=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");return this.uploadToGPU(t.dataId),{dtype:this.tensorMap.get(t.dataId).dtype,shape:t.shape,name:e.variableNames[n]}});e.shaderKey=function(e,t,n){let a=e.shaderKey;if(null!=e.pixelsOpType)return a;const s=[],r=[];t.forEach(e=>{s.push(e.shape),r.push(e.dtype)}),s.push(n.shape),r.push(n.dtype);const i=t.map(e=>Ey(e.shape,n.shape)),o=t.map(e=>Su(e.shape,n.shape)).join("_"),c=i.map(e=>e.join("_")).join(";"),l=HQ(e)?"flatDispatch":"";return a+="_"+(e.workgroupSize?e.workgroupSize.join(","):"")+s.map(e=>e.length).join(",")+r.join(",")+e.variableNames.join(",")+c+o+l,a}(e,r,s);const i=eh().getBool("WEBGPU_ENGINE_COMPILE_ONLY");return e.shaderKey in this.pipelineCache||(this.pipelineCache[e.shaderKey]=DQ(this.device,e,r,s,i)),e.pipeline=this.pipelineCache[e.shaderKey],i||this.recordAndSubmit(e,s,t,a),s}recordAndSubmit(e,t,n,a){if(e.pipeline instanceof Promise)throw new Error("Please call checkCompileCompletionAsync to ensure parallel compilation is done!");let s=[],r=[];const i="int32";if(null==e.pixelsOpType){s.push({type:"float32",data:[NaN]},{type:"float32",data:[1/0]}),r=n.concat(t).map(e=>e.shape);const e="int32";r.map(t=>{s.push({type:e,data:t});const n=ju(t);s.push({type:e,data:n})})}else{const e=ju(t.shape);s.push({type:i,data:e})}if(e.size){const t=wu(e.outputShape);s.push({type:i,data:[e.outputComponent?t/e.outputComponent:t]})}a&&(s=[...s,...a]);const o=[this.tensorToBinding(t),...n.map(e=>this.tensorToBinding(e)),this.makeUniforms(s)];n.forEach(e=>{this.commandQueueOwnedIds.add(e.dataId)}),this.commandQueueOwnedIds.add(t.dataId);const c=this.device.createBindGroup({layout:e.pipeline.getBindGroupLayout(0),entries:o.map((e,t)=>({binding:t,resource:e}))}),l=null!=this.activeTimers;this.ensureCommandEncoderReady();const u={};l&&this.supportTimestampQuery?(this.endComputePassEncoder(),null==this.querySet&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.querySetCount})),u.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:0,endOfPassWriteIndex:1},this.computePassEncoder=this.commandEncoder.beginComputePass(u)):this.computePassEncoder||(this.computePassEncoder=this.commandEncoder.beginComputePass(u)),this.computePassEncoder.setPipeline(e.pipeline),this.computePassEncoder.setBindGroup(0,c),this.computePassEncoder.dispatchWorkgroups(e.dispatch[0],e.dispatch[1],e.dispatch[2]),this.dispatchCountInPass++,(l||eh().get("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE")<=this.dispatchCountInPass||e.pixelsOpType===PQ.DRAW)&&(this.endComputePassEncoder(),l?this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime()}):this.submitQueue())}async getQueryTime(){if(!this.supportTimestampQuery)return 0;null==this.queryResolveBuffer&&(this.queryResolveBuffer=this.bufferManager.acquireBuffer(8*this.querySetCount,GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST|GPUBufferUsage.QUERY_RESOLVE)),this.commandEncoder.resolveQuerySet(this.querySet,0,this.querySetCount,this.queryResolveBuffer,0);const e=this.bufferManager.acquireBuffer(8*this.querySetCount,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,e,0,8*this.querySetCount),this.submitQueue(),await e.mapAsync(GPUMapMode.READ);const t=new BigUint64Array(e.getMappedRange()),n=Number(t[1]-t[0])/1e6;return e.unmap(),this.bufferManager.releaseBuffer(e),n}shouldExecuteOnCPU(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:nZ;return eh().getBool("WEBGPU_CPU_FORWARD")&&e.every(e=>null==this.tensorMap.get(e.dataId).resource&&wu(e.shape)<t)}numDataIds(){return this.tensorMap.numDataIds()-this.tensorDataPendingDisposal.length}dispose(){this.disposed||(null!=this.querySet&&this.querySet.destroy(),this.bufferManager.dispose(),this.textureManager.dispose(),this.disposed=!0)}}var sZ;aZ.nextDataId=0,$Q()&&Jm("webgpu",async()=>{const e={powerPreference:eh().get("WEBGPU_USE_LOW_POWER_GPU")?"low-power":"high-performance"},t=await navigator.gpu.requestAdapter(e),n={},a=[];t.features.has("timestamp-query")&&a.push("timestamp-query"),t.features.has("bgra8unorm-storage")&&a.push(["bgra8unorm-storage"]),n.requiredFeatures=a;const s=t.limits;n.requiredLimits={maxComputeWorkgroupStorageSize:s.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:s.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:s.maxStorageBufferBindingSize,maxBufferSize:s.maxBufferSize,maxComputeWorkgroupSizeX:s.maxComputeWorkgroupSizeX,maxComputeInvocationsPerWorkgroup:s.maxComputeInvocationsPerWorkgroup};const r=await t.requestDevice(n),i="info"in t?t.info:"requestAdapterInfo"in t?await t.requestAdapterInfo():void 0;return new aZ(r,i)},3),function(e){e[e.ADD=0]="ADD",e[e.ATAN2=1]="ATAN2",e[e.COMPLEX_MULTIPLY_IMAG=2]="COMPLEX_MULTIPLY_IMAG",e[e.COMPLEX_MULTIPLY_REAL=3]="COMPLEX_MULTIPLY_REAL",e[e.DIV=4]="DIV",e[e.ELU_DER=5]="ELU_DER",e[e.EQUAL=6]="EQUAL",e[e.FLOOR_DIV=7]="FLOOR_DIV",e[e.GREATER=8]="GREATER",e[e.GREATER_EQUAL=9]="GREATER_EQUAL",e[e.LESS=10]="LESS",e[e.LESS_EQUAL=11]="LESS_EQUAL",e[e.LOGICAL_AND=12]="LOGICAL_AND",e[e.LOGICAL_OR=13]="LOGICAL_OR",e[e.MAX=14]="MAX",e[e.MIN=15]="MIN",e[e.MOD=16]="MOD",e[e.MUL=17]="MUL",e[e.NOT_EQUAL=18]="NOT_EQUAL",e[e.POW=19]="POW",e[e.PRELU=20]="PRELU",e[e.SQUARED_DIFFERENCE=21]="SQUARED_DIFFERENCE",e[e.SUB=22]="SUB"}(sZ||(sZ={}));function rZ(e,t){let n;do{switch(e){case sZ.ATAN2:n="let resultTemp = atan2(a, b);";break;case sZ.MAX:n="let resultTemp = max(a, b);";break;case sZ.MIN:n="let resultTemp = min(a, b);";break;case sZ.MOD:n=t?"\n  let isNaN = !vec4<bool>(b);\n  var resultTemp = vec4<f32>(a % b);\n  if (!((a[0] < 0. && b[0] < 0.) || (a[0] >= 0. && b[0] > 0.))) {\n    resultTemp[0] = (resultTemp[0] + b[0]) % b[0];\n  }\n  if (!((a[1] < 0. && b[1] < 0.) || (a[1] >= 0. && b[1] > 0.))) {\n    resultTemp[1] = (resultTemp[1] + b[1]) % b[1];\n  }\n  if (!((a[2] < 0. && b[2] < 0.) || (a[2] >= 0. && b[2] > 0.))) {\n    resultTemp[2] = (resultTemp[2] + b[2]) % b[2];\n  }\n  if (!((a[3] < 0. && b[3] < 0.) || (a[3] >= 0. && b[3] > 0.))) {\n    resultTemp[3] = (resultTemp[3] + b[3]) % b[3];\n  }\n":"\n  let isNaN = b == 0.;\n  var resultTemp = a % b;\n  resultTemp = select((resultTemp + b) % b, resultTemp,\n      (a < 0. && b < 0.) || (a >= 0. && b > 0.));\n";break;case sZ.NOT_EQUAL:n=t?"\n  var resultTemp = vec4<f32>(a != b);\n  let valueForNaN = 1.0;\n":"\n  var resultTemp = f32(a != b);\n  let valueForNaN = 1.0;\n";break;case sZ.POW:n=t?"\n  let isModRound1Bool = vec4<i32>(round(abs(b) % vec4<f32>(2.0))) == vec4<i32>(1);\n  let isModRound1 = vec4<f32>(isModRound1Bool);\n  let multiplier = sign(a) * isModRound1 + (vec4<f32>(1.0) - isModRound1);\n  var resultTemp = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  let isExpZero = b == vec4<f32>(0.0);\n  if (isExpZero.r) {\n    resultTemp.r = 1.0;\n  }\n  if (isExpZero.g) {\n    resultTemp.g = 1.0;\n  }\n  if (isExpZero.b) {\n    resultTemp.b = 1.0;\n  }\n  if (isExpZero.a) {\n    resultTemp.a = 1.0;\n  }\n  let isNaN = (a < vec4<f32>(0.0)) & (floor(b) < b);\n":"\n  let isNaN = a < 0.0 && floor(b) < b;\n  if (b == 0.0) {\n    return 1.0;\n  }\n  var resultTemp = select(sign(a) * pow(abs(a), b), pow(abs(a), b),\n      round(abs(b) % 2.0) != 1.0);\n";break;default:continue}let a,s,r;return t?(a="isnanVec4",s="vec4<f32>",r="vec4<bool>"):(a="isnan",s="f32",r="bool"),"\n      let aIsNaN = ".concat(a,"(a);\n      let aPostLegalization = select(a, ").concat(s,"(42), aIsNaN);\n      let bIsNaN = ").concat(a,"(b);\n      let bPostLegalization = select(b, ").concat(s,"(42), bIsNaN);\n      let isNaN = false;\n      let valueForNaN = uniforms.NAN;\n      {\n        let a = aPostLegalization;\n        let b = bPostLegalization;\n        ").concat(n,"\n        return select(\n            resultTemp, ").concat(s,"(valueForNaN),\n            ").concat(r,"(isNaN) | aIsNaN | bIsNaN);\n      }\n    ")}while(0);switch(e){case sZ.ADD:n="let resultTemp = a + b;";break;case sZ.COMPLEX_MULTIPLY_IMAG:n="let resultTemp = areal * bimag + aimag * breal;";break;case sZ.COMPLEX_MULTIPLY_REAL:n="let resultTemp = areal * breal - aimag * bimag;";break;case sZ.DIV:n="let resultTemp = a / b;";break;case sZ.ELU_DER:n="let resultTemp = select(a * (b + 1.0), a, b >= b - b);";break;case sZ.EQUAL:n="\n  let zero = sign(a) * 0 + 0;\n  let one = sign(b) * 0 + 1;\n  let resultTemp = select(zero, one, a == b);\n";break;case sZ.FLOOR_DIV:n="\n  let remainder =\n      select(a % b, round(a % b), (round(a) == a) & (round(b) == b));\n  let quotient = (a - remainder) / b;\n  let resultTemp =\n      round(select(quotient, quotient - 1, sign(remainder) == -sign(b)));\n";break;case sZ.GREATER:n="\n  let zero = sign(a) * 0 + 0;\n  let one = sign(b) * 0 + 1;\n  let resultTemp = select(zero, one, a > b);\n";break;case sZ.GREATER_EQUAL:n="\n  let zero = sign(a) * 0 + 0;\n  let one = sign(b) * 0 + 1;\n  let resultTemp = select(zero, one, a >= b);\n";break;case sZ.LESS:n="\n  let zero = sign(a) * 0 + 0;\n  let one = sign(b) * 0 + 1;\n  let resultTemp = select(zero, one, a < b);\n";break;case sZ.LESS_EQUAL:n="\n  let zero = sign(a) * 0 + 0;\n  let one = sign(b) * 0 + 1;\n  let resultTemp = select(zero, one, a <= b);\n";break;case sZ.LOGICAL_AND:return t?"return (vec4<f32>(a >= vec4<f32>(1.0)) *\n  vec4<f32>(b >= vec4<f32>(1.0)));":"return f32(a >= 1.0 && b >= 1.0);";case sZ.LOGICAL_OR:return t?"return min(vec4<f32>(a >= vec4<f32>(1.0)) +\n  vec4<f32>(b >= vec4<f32>(1.0)), vec4<f32>(1.0));":"return f32(a >= 1.0 || b >= 1.0);";case sZ.MUL:n="let resultTemp = a * b;";break;case sZ.PRELU:return t?"\n  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));\n  return (aLessThanZero * (b * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);\n":"if (a < 0.0) { return b * a; }  return a;";case sZ.SQUARED_DIFFERENCE:n="let resultTemp = (a - b) * (a - b);";break;case sZ.SUB:n="let resultTemp = a - b;"}return"\n    ".concat(n,"\n    return resultTemp;\n  ")}var iZ;!function(e){e[e.ABS=0]="ABS",e[e.ACOS=1]="ACOS",e[e.ACOSH=2]="ACOSH",e[e.ASIN=3]="ASIN",e[e.ASINH=4]="ASINH",e[e.ATAN=5]="ATAN",e[e.ATANH=6]="ATANH",e[e.CEIL=7]="CEIL",e[e.COS=8]="COS",e[e.COSH=9]="COSH",e[e.ELU=10]="ELU",e[e.ERF=11]="ERF",e[e.EXP=12]="EXP",e[e.EXPM1=13]="EXPM1",e[e.FLOOR=14]="FLOOR",e[e.IS_FINITE=15]="IS_FINITE",e[e.IS_INF=16]="IS_INF",e[e.IS_NAN=17]="IS_NAN",e[e.LINEAR=18]="LINEAR",e[e.LOG=19]="LOG",e[e.LOG1P=20]="LOG1P",e[e.LOGICAL_NOT=21]="LOGICAL_NOT",e[e.NEG=22]="NEG",e[e.RELU=23]="RELU",e[e.RELU6=24]="RELU6",e[e.LEAKYRELU=25]="LEAKYRELU",e[e.RECIPROCAL=26]="RECIPROCAL",e[e.ROUND=27]="ROUND",e[e.RSQRT=28]="RSQRT",e[e.SELU=29]="SELU",e[e.SIGMOID=30]="SIGMOID",e[e.SIGN=31]="SIGN",e[e.SIN=32]="SIN",e[e.SINH=33]="SINH",e[e.SOFTPLUS=34]="SOFTPLUS",e[e.SQRT=35]="SQRT",e[e.SQUARE=36]="SQUARE",e[e.STEP=37]="STEP",e[e.TAN=38]="TAN",e[e.TANH=39]="TANH",e[e.TO_INT=40]="TO_INT"}(iZ||(iZ={}));const oZ='\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  let p = '.concat(gC,";\n  let a1 = ").concat(yC,";\n  let a2 = ").concat(bC,";\n  let a3 = ").concat(xC,";\n  let a4 = ").concat(vC,";\n  let a5 = ").concat(wC,";\n\n  let sign = sign(a);\n  let absA = abs(a);\n  let t = 1.0 / (1.0 + p * absA);\n  return sign * (1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * exp(-absA * absA));\n"),cZ="\n  if (a >= 0.0) {\n    return ".concat(mC," * a;\n  } else {\n    return ").concat(fC," * (exp(a) - 1.0);\n  }\n");function lZ(e,t){switch(e){case iZ.ABS:return"return abs(a);";case iZ.ACOS:return"\n  if (abs(a) > 1.) {\n    return uniforms.NAN;\n  }\n  return acos(a);\n";case iZ.ACOSH:return"\n  if (a < 1.) {\n    return uniforms.NAN;\n  }\n  return acosh(a);\n";case iZ.ASIN:return"\n  if (abs(a) > 1.) {\n    return uniforms.NAN;\n  }\n  return asin(a);\n";case iZ.ASINH:return"return asinh(a);";case iZ.ATAN:return"\n  if (isnan(a)) {\n    return uniforms.NAN;\n  }\n  return atan(a);\n";case iZ.ATANH:return"\n  if (abs(a) > 1.) {\n    return uniforms.NAN;\n  }\n  if (a == 1.) {\n    return uniforms.INFINITY;\n  }\n  if (a == -1.) {\n    return -uniforms.INFINITY;\n  }\n  return atanh(a);\n";case iZ.COS:return"return cos(a);";case iZ.COSH:return"\n  let e2x = exp(-a);\n  return (e2x + 1.0 / e2x) / 2.0;\n";case iZ.CEIL:return"return ceil(a);";case iZ.ELU:return t?"\n  var resFloat = exp(a) - vec4<f32>(1.0);\n  if (a.r >= 0.0) {\n    resFloat.r = a.r;\n  }\n  if (a.g >= 0.0) {\n    resFloat.g = a.g;\n  }\n  if (a.b >= 0.0) {\n    resFloat.b = a.b;\n  }\n  if (a.a >= 0.0) {\n    resFloat.a = a.a;\n  }\n  return resFloat;\n":"if (a >= 0.0) { return a; }  return (exp(a) - 1.0);";case iZ.ERF:return oZ;case iZ.EXP:return"return exp(a);";case iZ.EXPM1:return"return exp(a) - 1.0;";case iZ.FLOOR:return"return floor(a);";case iZ.IS_FINITE:return"return f32(!isnan(a) && !isinf(a));";case iZ.IS_INF:return"return f32(isinf(a));";case iZ.IS_NAN:return"return f32(isnan(a));";case iZ.LINEAR:return"return a;";case iZ.LOG:return"if (a < 0.0) { return uniforms.NAN; }\n  return log(a);";case iZ.LOG1P:return"\n  if (isnan(a)) { return a; }\n  return log(1.0 + a);\n";case iZ.LOGICAL_NOT:return"return f32(!(a >= 1.0));";case iZ.NEG:return"return -a;";case iZ.LEAKYRELU:return t?"\n  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));\n  return (aLessThanZero * (uniforms.alpha * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);\n":"if (a < 0.0) { return uniforms.alpha * a; } return a;";case iZ.RECIPROCAL:return"return 1.0 / a;";case iZ.RELU:return t?"\n  return select(a, vec4<f32>(0.0), a < vec4<f32>(0.0));\n":"return select(a, 0.0, a < 0.0);";case iZ.RELU6:return t?"return clamp(a, vec4<f32>(0.0, 0.0, 0.0, 0.0), vec4<f32>(6.0, 6.0, 6.0, 6.0));":"return clamp(a, 0.0, 6.0);";case iZ.ROUND:return"return round(a);";case iZ.RSQRT:return"return inverseSqrt(a);";case iZ.SELU:return cZ;case iZ.SIGMOID:return"return 1.0 / (1.0 + exp(-1.0 * a));";case iZ.SIGN:return"return sign(a);";case iZ.SIN:return"return sin(a);";case iZ.SINH:return"\n  let e2x = exp(a);\n  return (e2x - 1.0 / e2x) / 2.0;\n";case iZ.SOFTPLUS:return"\n  let epsilon = 1.1920928955078125e-7;\n  let threshold = log(epsilon) + 2.0;\n\n  let too_large = a > -threshold;\n  let too_small = a < threshold;\n  let exp_a = exp(a);\n\n  if (too_large) {\n    return a;\n  } else if (too_small) {\n    return exp_a;\n  } else {\n    return log(exp_a + 1.0);\n  }\n";case iZ.SQRT:return"return sqrt(a);";case iZ.SQUARE:return"return a * a;";case iZ.STEP:return"\n  if (isnan(a)) {\n    return a;\n  }\n\n  return select(uniforms.stepAlpha, 1.0, a > 0.0);\n";case iZ.TAN:return"return tan(a);";case iZ.TANH:return"\n  let e2x = exp(-2.0 * abs(a));\n  return sign(a) * (1.0 - e2x) / (1.0 + e2x);\n";case iZ.TO_INT:return"return f32(i32((a)));";default:throw new Error("BinaryType ".concat(e," is not implemented!"))}}function uZ(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:3;if(null===e)return"";let s="";if("linear"===e)s=lZ(iZ.LINEAR);else if("relu"===e)s=lZ(iZ.RELU,n);else if("elu"===e)s=lZ(iZ.ELU,n);else if("relu6"===e)s=lZ(iZ.RELU6,n);else if("prelu"===e)s=rZ(sZ.PRELU,n);else if("sigmoid"===e)s=lZ(iZ.SIGMOID,n);else{if("leakyrelu"!==e)throw new Error("Activation ".concat(e," has not been implemented for the WebGPU backend."));s=lZ(iZ.LEAKYRELU,n)}const r=OQ(n?4:1);let i="";return i=t?"\n      fn activation(a : ".concat(r,", coords : vec").concat(a,"<i32>) -> ").concat(r," {\n        let b = getPreluActivationWeightsByOutputCoords(coords);\n        ").concat(s,"\n      }"):"\n      fn activation(a : ".concat(r,", coords : vec").concat(a,"<i32>) -> ").concat(r," {\n        ").concat(s,"\n      }"),i}function hZ(e,t){return"\n      ".concat(e?"value = value + getBiasByOutputCoords(coords);":"","\n      ").concat(t?"value = activation(value, coords);":"","\n      ")}function dZ(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4],s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;bu(e&&1===s||!e,()=>"transposeA ".concat(e," is not compatible with component size ").concat(s));const r="\n      ".concat(e?"value = getA(batch, col, row);":"value = getA(batch, row, col);","\n\n    "),i=t?"value = getB(batch, col, row);":"value = getB(batch, row, col);";return"\n  fn mm_readA(batch: i32, row: i32, col: i32) -> ".concat(OQ(s)," {\n    var value = ").concat(OQ(s),"(0.0);\n    ").concat(n&&a?r:"\n    ".concat(e?"if(row < uniforms.dimAOuter && col < uniforms.dimInner)":"if(row < uniforms.aShape[1] && col < uniforms.aShape[2])","\n    {\n      ").concat(r,"\n    }\n    "),"\n    return value;\n  }\n\n  fn mm_readB(batch: i32, row: i32, col: i32) -> ").concat(OQ(s)," {\n    var value = ").concat(OQ(s),"(0.0);\n    ").concat(i,"\n    return value;\n  }\n  ")}function pZ(e,t,n,a){let s=arguments.length>4&&void 0!==arguments[4]&&arguments[4],r=arguments.length>5&&void 0!==arguments[5]&&arguments[5],i=arguments.length>7&&void 0!==arguments[7]?arguments[7]:1;return"\n  ".concat(dZ(n,a,s,r,arguments.length>6&&void 0!==arguments[6]&&arguments[6],i),"\n  fn mm_write(batch: i32, row: i32, col: i32, valueIn: ").concat(OQ(i),") {\n    ").concat(s&&r?"":"if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)","\n    {\n      var value = valueIn;\n      let coords = vec3<i32>(batch, row, col);\n      ").concat(hZ(e,t),"\n      setOutputAtCoords(coords[0], coords[1], coords[2], value);\n    }\n  }\n  ")}function fZ(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:32,s=arguments.length>4&&void 0!==arguments[4]&&arguments[4],r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:32,i=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const o=t[1]*e[1],c=t[0]*e[0],l=n?o:a,u=n?a:o,h=l/t[0],d=a/t[1],p=e[1],f=e[0];return bu((n&&4===h&&4===e[1]||!n&&(3===h||4===h))&&l%t[0]===0&&a%t[1]===0&&4===e[0],()=>"If transposeA ".concat(n," is true, innerElementSize ").concat(h," and workPerThread[1] ").concat(e[1]," must be 4.\n          Otherwise, innerElementSize ").concat(h," must be 3 or 4.\n      tileAWidth ").concat(l," must be divisible by workgroupSize[0]").concat(t[0],". tileInner ").concat(a," must be divisible by workgroupSize[1] ").concat(t[1],". colPerThread ").concat(e[0]," must be 4.")),"\n  var<workgroup> mm_Asub : array<array<vec".concat(h,"<f32>, ").concat(l/h,">, ").concat(u,">;\n  var<workgroup> mm_Bsub : array<array<vec4<f32>, ").concat(c/e[0],">, ").concat(a,">;\n\n  ").concat(zQ()," {\n    let localRow = i32(localId.y);\n    let tileRow = localRow * ").concat(p,";\n    let tileCol = i32(localId.x);\n\n    let globalRow = i32(globalId.y) * ").concat(p,";\n    let globalCol = i32(globalId.x) * ").concat(f,";\n    let batch = ").concat(s?"0":"i32(globalId.z)",";\n    let batchA = ").concat(s||!i?"batch":"batch % uniforms.aShape[0]",";\n    let batchB = ").concat(s||!i?"batch":"batch % uniforms.bShape[0]",";\n    let globalRowStart = i32(workgroupId.y) * ").concat(o,";\n\n    let numTiles = ").concat(s?"".concat(Math.ceil(r/a)):"(uniforms.dimInner - 1) / ".concat(a," + 1"),";\n    var kStart = ").concat(s?"i32(globalId.z) * ".concat(r):"0",";\n\n    var acc: array<vec4<f32>, ").concat(p,">;\n\n    // Loop over shared dimension.\n    let tileRowB = localRow * ").concat(d,";\n    for (var t = 0; t < numTiles; t++) {\n        // Load one tile of A into local memory.\n        for (var innerRow = 0; innerRow < ").concat(p,"; innerRow++) {\n            let inputRow = tileRow + innerRow;\n            let inputCol = tileCol;\n            ").concat(((e,t)=>e?"\n        mm_Asub[inputRow][inputCol] = mm_readA(batchA,\n          kStart + inputRow,\n          globalRowStart + inputCol * ".concat(t,");\n        "):"\n        mm_Asub[inputRow][inputCol] = mm_readA(batchA,\n          globalRow + innerRow,\n          kStart + inputCol * ".concat(t,");\n        "))(n,h),"\n        }\n\n        // Load one tile of B into local memory.\n        for (var innerRow = 0; innerRow < ").concat(d,"; innerRow++) {\n            let inputRow = tileRowB + innerRow;\n            let inputCol = tileCol;\n            mm_Bsub[inputRow][inputCol] = mm_readB(batchB, kStart + inputRow, globalCol);\n        }\n        kStart = kStart + ").concat(a,";\n        workgroupBarrier();\n\n        // Compute acc values for a single thread.\n        ").concat(((e,t,n,a)=>{if(e)return"\n      for (var k = 0; k < ".concat(a,"; k++) {\n        let BCached0 = mm_Bsub[k][tileCol];\n        let ACached0 = mm_Asub[k][localRow];\n        for (var i = 0; i < ").concat(n,"; i++) {\n          acc[i] = fma(BCached0, vec4<f32>(ACached0[i]), acc[i]);\n        }\n      }");{let e="",s="";for(let n=0;n<t;n++)e+="let BCached".concat(n," = mm_Bsub[k * ").concat(t," + ").concat(n,"][tileCol];"),s+="acc[i] = fma(BCached".concat(n,", vec4<f32>(ACached[").concat(n,"]), acc[i]);");return"\n      for (var k = 0; k < ".concat(a/t,"; k++) {\n        ").concat(e,"\n        for (var i = 0; i < ").concat(n,"; i++) {\n          let ACached = mm_Asub[tileRow + i][k];\n          ").concat(s,"\n        }\n      }")}})(n,h,p,a),"\n        workgroupBarrier();\n    }\n\n    for (var innerRow = 0; innerRow < ").concat(p,"; innerRow++) {\n        mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);\n    }\n  }")}const mZ=e=>e?"\n        mm_Asub[inputRow][inputCol] = mm_readA(batchA,\n          kStart + inputRow,\n          globalRowStart + inputCol);\n        ":"\n        mm_Asub[inputRow][inputCol] = mm_readA(batchA,\n          globalRowStart + inputRow,\n          kStart + inputCol);\n        ";function gZ(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:32,s=arguments.length>4&&void 0!==arguments[4]&&arguments[4],r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:32,i=arguments.length>6&&void 0!==arguments[6]&&arguments[6],o=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const c=e[1]*t[1],l=e[0]*t[0],u=n?c:a,h=n?a:c;bu(h%t[1]===0&&u%t[0]===0&&a%t[1]===0,()=>"tileAHight ".concat(h," must be divisible by workgroupSize[1]").concat(t[1],", tileAWidth ").concat(u," must be divisible by workgroupSize[0]").concat(t[0],", tileInner ").concat(a," must be divisible by workgroupSize[1]").concat(t[1]));const d=h/t[1],p=u/t[0],f=a/t[1],m=e[1],g=e[0],y=i?"\n      let localRow = i32(localId.y);\n      let localCol = i32(localId.x);\n      let globalRowStart = i32(workgroupId.y) * ".concat(c,";\n      let globalColStart = i32(workgroupId.x) * ").concat(l,";\n\n      // Loop over shared dimension.\n      for (var t = 0; t < numTiles; t++) {\n        // Load one tile of A into local memory.\n        for (var inputRow = localRow; inputRow < ").concat(h,"; inputRow = inputRow + ").concat(t[1],") {\n          for (var inputCol = localCol; inputCol < ").concat(u,"; inputCol = inputCol + ").concat(t[0],") {\n            ").concat(mZ(n),"\n          }\n        }\n        // Load one tile of B into local memory.\n        for (var inputRow = localRow; inputRow < ").concat(a,"; inputRow = inputRow + ").concat(t[1],") {\n              for (var inputCol = localCol; inputCol < ").concat(l,"; inputCol = inputCol + ").concat(t[0],") {\n            mm_Bsub[inputRow][inputCol] = mm_readB(batchB,\n              kStart + inputRow,\n              globalColStart + inputCol);\n          }\n        }\n        kStart = kStart + ").concat(a,";\n        workgroupBarrier();\n\n        // Compute acc values for a single thread.\n        var BCached : array<f32, ").concat(g,">;\n        for (var k = 0; k < ").concat(a,"; k++) {\n          for (var inner = 0; inner < ").concat(g,"; inner++) {\n            BCached[inner] = mm_Bsub[k][localCol + inner * ").concat(t[0],"];\n          }\n          for (var innerRow = 0; innerRow < ").concat(m,"; innerRow++) {\n            let ACached = ").concat(n?"mm_Asub[k][localRow + innerRow * ".concat(t[1],"];"):"mm_Asub[localRow + innerRow * ".concat(t[1],"][k];"),"\n            for (var innerCol = 0; innerCol < ").concat(g,"; innerCol++) {\n              acc[innerRow][innerCol] =\n                  fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);\n            }\n          }\n        }\n        workgroupBarrier();\n      }\n      for (var innerRow = 0; innerRow < ").concat(m,"; innerRow++) {\n        let gRow = globalRowStart + localRow + innerRow * ").concat(t[1],";\n        for (var innerCol = 0; innerCol < ").concat(g,"; innerCol++) {\n          let gCol = globalColStart + localCol + innerCol * ").concat(t[0],";\n          mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);\n        }\n      }\n      "):"\n  let tileRow = i32(localId.y) * ".concat(m,";\n  let tileCol = i32(localId.x) * ").concat(g,";\n\n  let globalRow = i32(globalId.y) * ").concat(m,";\n  let globalCol = i32(globalId.x) * ").concat(g,";\n  let globalRowStart = i32(workgroupId.y) * ").concat(c,";\n\n  let tileRowA = i32(localId.y) * ").concat(d,";\n  let tileColA = i32(localId.x) * ").concat(p,";\n  let tileRowB = i32(localId.y) * ").concat(f,";\n  // Loop over shared dimension.\n  for (var t = 0; t < numTiles; t++) {\n    // Load one tile of A into local memory.\n    for (var innerRow = 0; innerRow < ").concat(d,"; innerRow++) {\n      for (var innerCol = 0; innerCol < ").concat(p,"; innerCol++) {\n        let inputRow = tileRowA + innerRow;\n        let inputCol = tileColA + innerCol;\n        ").concat(mZ(n),"\n      }\n    }\n\n    // Load one tile of B into local memory.\n    for (var innerRow = 0; innerRow < ").concat(f,"; innerRow++) {\n      for (var innerCol = 0; innerCol < ").concat(g,"; innerCol++) {\n        let inputRow = tileRowB + innerRow;\n        let inputCol = tileCol + innerCol;\n        mm_Bsub[inputRow][inputCol] = mm_readB(batchB,\n          kStart + inputRow,\n          globalCol + innerCol);\n      }\n    }\n    kStart = kStart + ").concat(a,";\n    workgroupBarrier();\n\n    // Compute acc values for a single thread.\n    var BCached : array<f32, ").concat(g,">;\n    for (var k = 0; k < ").concat(a,"; k++) {\n      for (var inner = 0; inner < ").concat(g,"; inner++) {\n        BCached[inner] = mm_Bsub[k][tileCol + inner];\n      }\n\n      for (var innerRow = 0; innerRow < ").concat(m,"; innerRow++) {\n        ").concat((e=>e?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];")(n),"\n        for (var innerCol = 0; innerCol < ").concat(g,"; innerCol++) {\n          acc[innerRow][innerCol] =\n              fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);\n        }\n      }\n    }\n\n    workgroupBarrier();\n  }\n\n  for (var innerRow = 0; innerRow < ").concat(m,"; innerRow++) {\n    for (var innerCol = 0; innerCol < ").concat(g,"; innerCol++) {\n      mm_write(batch, globalRow + innerRow, globalCol + innerCol,\n          acc[innerRow][innerCol]);\n    }\n  }\n  ");return"\n    var<workgroup> mm_Asub : array<array<f32, ".concat(u,">, ").concat(h,">;\n    var<workgroup> mm_Bsub : array<array<f32, ").concat(l,">, ").concat(a,">;\n\n    ").concat(zQ()," {\n      let batch = ").concat(s?"0":"i32(globalId.z)",";\n      let batchA = ").concat(s||!o?"batch":"batch % uniforms.aShape[0]",";\n      let batchB = ").concat(s||!o?"batch":"batch % uniforms.bShape[0]",";\n      let numTiles = ").concat(s?"".concat(Math.ceil(r/a)):"(uniforms.dimInner - 1) / ".concat(a," + 1"),";\n      var kStart = ").concat(s?"i32(globalId.z) * ".concat(r):"0",";\n\n      var acc : array<array<f32, ").concat(g,">, ").concat(m,">;\n\n      // Without this initialization strange values show up in acc.\n      for (var innerRow = 0; innerRow < ").concat(m,"; innerRow++) {\n        for (var innerCol = 0; innerCol < ").concat(g,"; innerCol++) {\n          acc[innerRow][innerCol] = 0.0;\n        }\n      }\n      ").concat(y,"\n    }\n  ")}class yZ{constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,o=arguments.length>7&&void 0!==arguments[7]&&arguments[7];this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=t,this.dispatchLayout={x:[2],y:[1],z:[0]};const c=n?e[1]:e[2];if(this.isVec4=(c%4===0&&!n||t[1]%4===0&&n)&&t[2]%4===0&&!a,this.outputComponent=this.isVec4?4:1,this.isVectorA=1===t[1]&&!n,!this.isVec4&&this.isVectorA)this.elementsPerThread=[1,1,1],this.workgroupSize=[32,1,1];else{const e=function(e,t,n){const a=[8,8,1],s=[4,4,1];return arguments.length>3&&void 0!==arguments[3]&&arguments[3]||(e<=8&&(s[1]=1),t<=16&&n<=16&&(a[0]=4)),{workgroupSize:a,elementsPerThread:s}}(t[1],c,t[2],n);this.workgroupSize=e.workgroupSize,this.elementsPerThread=e.elementsPerThread}this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread);const l=null!=s,u=null!=i;l&&this.variableNames.push("bias"),u&&this.variableNames.push("preluActivationWeights"),this.sequentialAccessByThreads=o,this.transposeA=n,this.transposeB=a,this.addBias=l,this.activation=r,this.hasPreluActivationWeights=u,[this.fitAOuter,this.fitBOuter,this.fitInner]=this.getShapeFit(t[1],t[2],c),this.shaderKey="matMulPacked_".concat(this.elementsPerThread,"_").concat(n,"_").concat(a,"_").concat(this.activation,"_").concat(this.fitAOuter,"_").concat(this.fitBOuter,"_").concat(this.fitInner,"_").concat(this.isVec4,"_").concat(this.isVectorA,"_").concat(this.sequentialAccessByThreads)}getShapeFit(e,t,n){const a=this.workgroupSize[1]*this.elementsPerThread[1],s=this.workgroupSize[0]*this.elementsPerThread[0];!this.isVec4&&this.isVectorA?this.tileInner=4*this.workgroupSize[0]:this.tileInner=s;return[e%a===0,t%s===0,n%this.tileInner===0]}getUserCode(){const e="\n      ".concat(uZ(this.activation,this.hasPreluActivationWeights,this.isVec4),"\n      ").concat(pZ(this.addBias,this.activation,!1,this.transposeB,this.fitAOuter,this.fitBOuter,this.fitInner,this.isVec4?4:1),"\n      ").concat(this.isVec4?fZ(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,!0):this.isVectorA?function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];bu(1===e[1]&&1===e[2],()=>"A linear work group size is required. But got ".concat(e,"."));const n=4*e[0];return"\n    var<workgroup> mm_Asub : array<vec4<f32>, ".concat(e[0],">;\n\n    ").concat(zQ()," {\n      let tileCol = i32(localId.x);\n      let globalCol = i32(globalId.x);\n      let globalRow = i32(globalId.y);\n\n      let numTiles = (uniforms.dimInner - 1) / ").concat(n," + 1;\n      let batch = i32(globalId.z);\n      let batchA = batch % uniforms.aShape[0];\n      let batchB = batch % uniforms.bShape[0];\n      // Without this initialization strange values show up in acc.\n      var acc = 0.0;\n\n      // Loop over shared dimension.\n      for (var t = 0; t < numTiles; t++) {\n        // Load one tile of A into local memory.\n        let colA = t * ").concat(n," + tileCol * 4;\n        mm_Asub[tileCol] = vec4<f32>(").concat((e=>e?"\n      mm_readA(batchA, colA, globalRow),\n      mm_readA(batchA, colA + 1, globalRow),\n      mm_readA(batchA, colA + 2, globalRow),\n      mm_readA(batchA, colA + 3, globalRow)\n  ":"\n      mm_readA(batchA, globalRow, colA),\n      mm_readA(batchA, globalRow, colA + 1),\n      mm_readA(batchA, globalRow, colA + 2),\n      mm_readA(batchA, globalRow, colA + 3)\n  ")(t),");\n        workgroupBarrier();\n\n        // Compute acc values for a single thread.\n        for (var k = 0; k < ").concat(n/4,"; k++) {\n          let rowB = t * ").concat(n," + k * 4;\n          let BCached = vec4<f32>(mm_readB(batchB, rowB, globalCol),\n                              mm_readB(batchB, rowB + 1, globalCol),\n                              mm_readB(batchB, rowB + 2, globalCol),\n                              mm_readB(batchB, rowB + 3, globalCol));\n\n          let ACached = mm_Asub[k];\n          acc = acc + dot(ACached, BCached);\n        }\n\n        workgroupBarrier();\n      }\n\n      mm_write(batch, globalRow, globalCol, acc);\n    }\n  ")}(this.workgroupSize,this.transposeA):gZ(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,this.sequentialAccessByThreads,!0),"\n    ");return e}}class bZ{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null;this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout={x:[],y:[1,2],z:[0]},this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize);const i=null!=a,o=null!=r;i&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),this.transposeA=t,this.transposeB=n,this.addBias=i,this.activation=s,this.hasPreluActivationWeights=o,this.shaderKey="matMulReduce_".concat(this.activation,"_").concat(t,"_").concat(n)}getUserCode(){var e;return"\n      ".concat(uZ(this.activation,this.hasPreluActivationWeights),"\n      ").concat(pZ(this.addBias,this.activation,this.transposeA,this.transposeB),"\n      ").concat((e=this.workgroupSize[0],"\n    var<workgroup> sumValues : array<f32, ".concat(e,">;\n    ").concat(zQ()," {\n      let coords = getOutputCoords();\n      let batch = coords[0];\n      let batchA = batch % uniforms.aShape[0];\n      let batchB = batch % uniforms.bShape[0];\n      let row = coords[1];\n      let col = coords[2];\n      var sum = 0.0;\n      let Length = uniforms.dimInner;\n      for (var k = i32(localId.x); k < Length; k = k + ").concat(e,") {\n        let dataA = mm_readA(batchA, row, k);\n        let dataB = mm_readB(batchB, k, col);\n        sum = sum + dataA * dataB;\n      }\n      sumValues[localId.x] = sum;\n      workgroupBarrier();\n\n      for(var currentSize = ").concat(e/2,"u; currentSize > 1u;\n          currentSize = currentSize / 2u) {\n        if (localId.x < currentSize)\n        {\n          sumValues[localId.x] = sumValues[localId.x] + sumValues[localId.x + currentSize];\n        }\n        workgroupBarrier();\n      }\n\n      if (localId.x == 0u) {\n        sum = sumValues[0] + sumValues[1];\n        mm_write(batch, row, col, sum);\n      }\n    }\n  ")),"\n    ")}}class xZ{constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=arguments.length>4&&void 0!==arguments[4]&&arguments[4],r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null;this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[16,8,1],this.outputShape=n,this.dispatchLayout={x:[2],y:[1],z:[0]},this.dispatch=[Math.ceil(n[2]/this.workgroupSize[0]),Math.ceil(n[1]/this.workgroupSize[1]),n[0]];const c=null!=r;c&&this.variableNames.push("bias");const l=null!=o;l&&this.variableNames.push("preluActivationWeights"),this.transposeA=a,this.transposeB=s,this.addBias=c,this.activation=i,this.hasPreluActivationWeights=l,this.shaderKey="matMulSmallOutputSize_".concat(this.activation,"_").concat(a,"_").concat(s)}getUserCode(){return"\n      ".concat(uZ(this.activation,this.hasPreluActivationWeights),"\n      ").concat(pZ(this.addBias,this.activation,this.transposeA,this.transposeB),"\n      ").concat(function(e){const t=e[1],n=e[0],a=t>n?t:n;return"\n  var<workgroup> mm_Asub : array<array<f32, ".concat(a,">, ").concat(t,">;\n  var<workgroup> mm_Bsub : array<array<f32, ").concat(n,">, ").concat(a,">;\n\n  // If the output size is small for matrix multiplication, avoid to use vec4\n  // and handle some elements per thread to optimally utilize the ALU.\n  // Read data from global memory to registers firstly, then store them into\n  // shared memory, so it is instruction-Level parallelism for arithmetic\n  // operations and others handle IO operations between barrier api, makes ALU\n  // and load/store units work simultaneously, could improves the performance.\n  ").concat(zQ()," {\n    let tileRow = i32(localId.y);\n    let tileCol = i32(localId.x);\n    let globalRow = i32(globalId.y);\n    let globalCol = i32(globalId.x);\n    let batch = i32(globalId.z);\n    let batchA = batch % uniforms.aShape[0];\n    let batchB = batch % uniforms.bShape[0];\n\n    // uniforms.dimInner should be greater than 0.\n    let numTiles = (uniforms.dimInner - 1) / ").concat(a," + 1;\n    var acc = 0.0;\n\n    var globalColA = tileCol;\n    var globalRowB = 0;\n    var regA = mm_readA(batchA, globalRow, globalColA);\n    var regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);\n    var regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);\n    globalColA = globalColA + ").concat(a,";\n    globalRowB = globalRowB + ").concat(a,";\n\n    for (var t = 0; t < numTiles; t = t + 1) {\n      mm_Asub[tileRow][tileCol] = regA;\n      mm_Bsub[2 * tileRow][tileCol] = regB0;\n      mm_Bsub[2 * tileRow + 1][tileCol] = regB1;\n\n      workgroupBarrier();\n\n      regA = mm_readA(batchA, globalRow, globalColA);\n      regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);\n      regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);\n      globalColA = globalColA + ").concat(a,";\n      globalRowB = globalRowB + ").concat(a,";\n\n      for (var k = 0; k < ").concat(a,"; k = k + 1) {\n        acc = acc + mm_Asub[tileRow][k] * mm_Bsub[k][tileCol];\n      }\n      workgroupBarrier();\n    }\n\n    mm_write(batch, globalRow, globalCol, acc);\n  }\n  ")}(this.workgroupSize),"\n    ")}}class vZ{constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[8,8,1],this.atomic=!0,this.splitedDimInner=128,bu(1===e[0],()=>"MatMulSplitKProgram only supports batch = 1."),this.outputShape=e,this.dispatchLayout={x:[2],y:[1],z:[0,3]};const s=(n&&this.outputShape[1]%4===0||!n&&t%4===0)&&this.outputShape[2]%4===0;this.elementsPerThread=[4,4,this.splitedDimInner],this.outputComponent=s?4:1,s||(this.outputShape[1]<16&&(this.elementsPerThread[1]=1),this.outputShape[2]<16&&(this.elementsPerThread[0]=1)),this.dispatch=XQ(this.dispatchLayout,[this.outputShape[0],this.outputShape[1],this.outputShape[2],t],this.workgroupSize,this.elementsPerThread),this.transposeA=n,this.transposeB=a,this.shaderKey="matMulSplitK_".concat(n,"_").concat(a,"_").concat(this.elementsPerThread,"_").concat(this.outputComponent)}getUserCode(){const e=this.outputComponent;return"\n      ".concat(dZ(!1,this.transposeB,!1,!1,!1,e),"\n      fn mm_write(batch: i32, row : i32, col : i32, value : ").concat(OQ(e),") {\n        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {\n          let coords = vec3<i32>(batch, row, col);\n          let flatIndex = getOutputIndexFromCoords(coords);\n          // The problem is that we should initialize output to zero before using.\n          // Otherwise, the original value will be added to the result.\n          for (var i = 0; i < ").concat(e,"; i = i + 1) {\n            ").concat(MQ("&result[flatIndex + i]","".concat(e>1?"value[i]":"value"),"float32"),"\n          }\n        }\n      }\n      ").concat(4===e?fZ(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner):gZ(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner),"\n    ")}}class wZ{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=ZQ(this.outputShape),this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=null!=t,this.hasPreluActivationWeights=null!=a,this.activation=n,this.addBias&&this.variableNames.push("bias"),this.hasPreluActivationWeights&&this.variableNames.push("preluActivationWeights"),this.shaderKey="biasActivation_".concat(n)}getUserCode(){return"\n    ".concat(uZ(this.activation,this.hasPreluActivationWeights),"\n    ").concat(zQ("index")," {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        var value = getXByOutputIndex(index);\n        ").concat(hZ(this.addBias,this.activation),"\n        setOutputAtIndex(index, value);\n      }\n    }\n    ")}}class kZ{constructor(e){this.variableNames=[],this.outputShape=[],this.uniforms="value : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=ZQ(this.outputShape),this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="fill"}getUserCode(){return"\n    ".concat(zQ("index")," {\n      if (index < uniforms.size) {\n        setOutputAtIndex(index, uniforms.value);\n      }\n    }\n  ")}}function SZ(e){const{backend:t,attrs:n}=e,{shape:a,value:s}=n;let{dtype:r}=n;if(r=r||Lu(s),"string"===r){const e=Mu(r,wu(a));return e.fill(s),t.makeTensorInfo(a,r,e)}{const e=new kZ(a),n=[{type:"float32",data:[s]}];return t.runWebGPUProgram(e,[],r,n)}}const CZ={kernelName:hd,backendName:"webgpu",kernelFunc:SZ};function IZ(e){const{inputs:t,attrs:n}=e,{x:a}=t,{shape:s}=n,r=wu(a.shape),i=Eu(s,r),o=wu(i);return bu(r===o,()=>"The new shape (".concat(i,") has ").concat(o," elements and the old ")+"shape (".concat(a.shape,") has ").concat(r," elements. The new shape and old ")+"shape must have the same number of elements."),e.backend.incRef(a.dataId),{dataId:a.dataId,shape:i,dtype:a.dtype}}const NZ={kernelName:gp,backendName:"webgpu",kernelFunc:IZ};function TZ(e){let{a:t,b:n,transposeA:a,transposeB:s,backend:r,bias:i=null,preluActivationWeights:o=null,leakyreluAlpha:c=0,activation:l=null}=e;const u=t.shape.length,h=n.shape.length,d=a?t.shape[u-2]:t.shape[u-1],p=s?n.shape[h-1]:n.shape[h-2],f=a?t.shape[u-1]:t.shape[u-2],m=s?n.shape[h-2]:n.shape[h-1],g=t.shape.slice(0,-2),y=n.shape.slice(0,-2),b=wu(g),x=wu(y),v=_y(t.shape.slice(0,-2),n.shape.slice(0,-2)).concat([f,m]);bu(d===p,()=>"Error in matMul: inner shapes (".concat(d,") and (")+"".concat(p,") of Tensors with shapes ").concat(t.shape," and ")+"".concat(n.shape," and transposeA=").concat(a)+" and transposeB=".concat(s," must match."));const w=a?[b,d,f]:[b,f,d],k=s?[x,m,p]:[x,p,m],S=IZ({inputs:{x:t},backend:r,attrs:{shape:w}}),C=IZ({inputs:{x:n},backend:r,attrs:{shape:k}}),I=[S,C],N=Math.max(b,x),T=[S,C],E=[{type:"int32",data:[f]},{type:"int32",data:[m]},{type:"int32",data:[d]}];let R,_;const A=[N,f,m];let M=eh().get("WEBGPU_MATMUL_PROGRAM_TYPE");if(M<0){const e=eh().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),t=e>0?e:r.thresholdToIncreaseWorkgroups,n=N*Math.ceil(f/32)*Math.ceil(m/32);M=n<=t||f<=8&&n<=2*t?N*f*m<=128?tZ.MatMulReduceProgram:1===N&&p>=2e3?tZ.MatMulSplitKProgram:tZ.MatMulSmallOutputSizeProgram:tZ.MatMulPackedProgram}switch(M){case tZ.MatMulReduceProgram:R=new bZ(A,a,s,i,l,o);break;case tZ.MatMulSplitKProgram:if(_=SZ({backend:r,attrs:{shape:A,value:0,dtype:t.dtype}}),R=new vZ(A,p,a,s),i||l){_=r.runWebGPUProgram(R,T,t.dtype,E,_);const e=new wZ(_.shape,i,l,o);let n=null;const a=[_];i&&a.push(i),o&&a.push(o),"leakyrelu"===l&&(n=[{type:"float32",data:[c]}],e.uniforms+=" alpha : f32,");const s=r.runWebGPUProgram(e,a,_.dtype,n);I.push(_);const u=IZ({inputs:{x:s},backend:r,attrs:{shape:v}});I.push(s);for(const t of I)r.disposeData(t.dataId);return u}break;case tZ.MatMulSmallOutputSizeProgram:R=new xZ(w,k,A,a,s,i,l,o);break;case tZ.MatMulPackedProgram:const e=r.adapterInfo.isIntel();R=new yZ(w,A,a,s,i,l,o,e);break;default:throw new Error("Unsupported MatMulProgramType ".concat(M,"."))}i&&T.push(i),o&&T.push(o),"leakyrelu"===l&&(E.push({type:"float32",data:[c]}),R.uniforms+=" alpha : f32,"),_=r.runWebGPUProgram(R,T,t.dtype,E,_);const P=IZ({inputs:{x:_},backend:r,attrs:{shape:v}});I.push(_);for(const D of I)r.disposeData(D.dataId);return P}const EZ={kernelName:ff,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{a:s,b:r,bias:i,preluActivationWeights:o}=t,{transposeA:c,transposeB:l,activation:u,leakyreluAlpha:h}=a;return TZ({a:s,b:r,transposeA:c,transposeB:l,backend:n,bias:i,preluActivationWeights:o,leakyreluAlpha:h,activation:u})}};class RZ{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.workgroupSize=[128,1,1],this.size=!0,this.outputShape=_y(t,n),this.dispatchLayout=ZQ(this.outputShape),this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="binaryOpComplex_".concat(e),this.op=e}getUserCode(){const e=rZ(this.op,!1);return"\n      fn binaryOpComplex(\n          areal : f32, aimag : f32, breal : f32, bimag : f32) -> f32 {\n        ".concat(e,"\n      }\n\n      ").concat(zQ("index")," {\n        if(index < uniforms.size) {\n          let areal = getARealByOutputIndex(index);\n          let aimag = getAImagByOutputIndex(index);\n          let breal = getBRealByOutputIndex(index);\n          let bimag = getBImagByOutputIndex(index);\n          setOutputAtIndex(index, binaryOpComplex(areal, aimag, breal, bimag));\n        }\n      }\n    ")}}class _Z{constructor(e,t,n){if(this.size=!0,this.variableNames=["A","B"],this.outputShape=_y(t,n),this.dispatchLayout=ZQ(this.outputShape),this.op=e,this.useSharedMemoryWithA=t.length<=1&&n.length>1&&t[0]<128,this.useSharedMemoryWithB=n.length<=1&&t.length>1&&n[0]<128,this.useSharedMemoryWithA||this.useSharedMemoryWithB)this.outputComponent=1,this.variableComponents=[1,1],this.lastDimensionSize=this.useSharedMemoryWithB?n[0]:t[0],this.shaderKey="binary_".concat(e,"_").concat(this.lastDimensionSize),this.type="shared",this.workgroupSize=[256,1,1];else{const a=t.length>0&&t[t.length-1]%4===0,s=n.length>0&&n[n.length-1]%4===0;a&&s?(this.outputComponent=4,this.variableComponents=[4,4]):a&&(ku(n)||1===n[n.length-1])||s&&(ku(t)||1===t[t.length-1])?(this.outputComponent=4,this.variableComponents=a?[4,1]:[1,4]):(this.outputComponent=1,this.variableComponents=[1,1]),this.type="nonshared",this.shaderKey="binary_".concat(e,"_").concat(this.variableComponents),this.workgroupSize=[128,1,1]}this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.outputComponent,1,1])}getUserCode(){let e;const t=4===this.outputComponent?"vec4<f32>":"f32",n="\n    fn binaryOperation(a : ".concat(t,", b : ").concat(t,") -> ").concat(t," {\n      ").concat(rZ(this.op,4===this.outputComponent),"\n    };\n    ");if("shared"===this.type){const t=this.lastDimensionSize>1?"coords[".concat(this.outputShape.length-1,"]"):"0",a=this.useSharedMemoryWithB?"let a = getAByOutputIndex(index);\n          let b = sharedBuf[".concat(t,"];"):"let a = sharedBuf[".concat(t,"];\n          let b = getBByOutputIndex(index);");e="\n        ".concat(n,"\n        var<workgroup> sharedBuf : array<f32, ").concat(this.lastDimensionSize,">;\n        ").concat(zQ("index")," {\n          // Fill in the shared memory buffer.\n          let localIndex = i32(localId.x);\n          if(localIndex < ").concat(this.lastDimensionSize,") {\n            sharedBuf[localIndex] = f32(").concat(this.useSharedMemoryWithB?"B":"A","[localIndex]);\n          }\n          workgroupBarrier();\n\n          if(index < uniforms.size) {\n            let coords = getCoordsFromIndex(index);\n            ").concat(a,"\n            setOutputAtIndex(index, binaryOperation(a, b));\n          }\n        }\n        ")}else e="\n       ".concat(n,"\n       ").concat(zQ("index")," {\n         if (index < uniforms.size) {\n           let coords = getCoordsFromIndex(index * ").concat(this.outputComponent,");\n           let a = ").concat(t,"(getAByOutputCoords(coords));\n           let b = ").concat(t,"(getBByOutputCoords(coords));\n           setOutputAtIndex(index, binaryOperation(a, b));\n         }\n       }\n       ");return e}}function AZ(e){const{inputs:t}=e,{x:n}=t;return e.backend.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}const MZ={kernelName:vd,backendName:"webgpu",kernelFunc:AZ};function PZ(e){const{inputs:t,backend:n}=e,{real:a,imag:s}=t,r=n.makeTensorInfo(a.shape,"complex64"),i=n.tensorMap.get(r.dataId),o=AZ({inputs:{x:a},backend:n}),c=AZ({inputs:{x:s},backend:n});return i.complexTensorInfos={real:o,imag:c},r}const DZ={kernelName:Ah,backendName:"webgpu",kernelFunc:PZ};class OZ{constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";this.variableNames=["A"],this.size=!0;this.workgroupSize=[128,1,1],this.outputShape=e,this.dispatchLayout=ZQ(this.outputShape),this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.op=t,""!==n&&(this.uniforms=n),this.shaderKey="unary_".concat(t)}getUserCode(){return"\n      fn unaryOperation(a : f32) -> f32 {\n        ".concat(lZ(this.op,!1),"\n      }\n      ").concat(zQ("index")," {\n        if (index < uniforms.size) {\n          let a = getAByOutputIndex(index);\n          setOutputAtIndex(index, unaryOperation(a));\n        }\n      }\n      ")}}function FZ(e){let{opType:t,cpuKernelImpl:n,dtype:a}=e;return e=>{let{inputs:s,backend:r}=e;const{x:i}=s,o=r,c=a||i.dtype;if(o.shouldExecuteOnCPU([i])&&null!=n){const e=o.tensorMap.get(i.dataId),t=n(e.values,c);return o.makeTensorInfo(i.shape,c,t)}const l=new OZ(i.shape,t);return o.runWebGPUProgram(l,[i],c)}}function LZ(e){let{opType:t,cpuKernelImpl:n,supportsComplex:a=!1,dtype:s}=e;return e=>{let{inputs:r,backend:i}=e;const{a:o,b:c}=r,l=i;if(a&&"complex64"===o.dtype){const e=l.tensorMap.get(o.dataId),n=l.tensorMap.get(c.dataId);let a,s;if(t!==sZ.MUL)[a,s]=[[e.complexTensorInfos.real,n.complexTensorInfos.real],[e.complexTensorInfos.imag,n.complexTensorInfos.imag]].map(e=>{const[n,a]=e,s={dataId:n.dataId,dtype:n.dtype,shape:o.shape},r={dataId:a.dataId,dtype:a.dtype,shape:c.shape},i=new _Z(t,o.shape,c.shape);return l.runWebGPUProgram(i,[s,r],gm(n.dtype,a.dtype))});else{const t=new RZ(sZ.COMPLEX_MULTIPLY_REAL,o.shape,c.shape),r=new RZ(sZ.COMPLEX_MULTIPLY_IMAG,o.shape,c.shape),i=[{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:o.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:o.shape},{dataId:n.complexTensorInfos.real.dataId,dtype:n.complexTensorInfos.real.dtype,shape:c.shape},{dataId:n.complexTensorInfos.imag.dataId,dtype:n.complexTensorInfos.imag.dtype,shape:c.shape}];a=l.runWebGPUProgram(t,i,"float32"),s=l.runWebGPUProgram(r,i,"float32")}const r=PZ({inputs:{real:a,imag:s},backend:l});return l.disposeData(a.dataId),l.disposeData(s.dataId),r}const u=s||gm(o.dtype,c.dtype);if(("string"===o.dtype||"string"===c.dtype||l.shouldExecuteOnCPU([o,c]))&&null!=n){const e=l.tensorMap.get(o.dataId).values,t=l.tensorMap.get(c.dataId).values,a="string"===o.dtype?nI(e):e,s="string"===o.dtype?nI(t):t,[r,i]=n(o.shape,c.shape,a,s,u);return l.makeTensorInfo(i,u,r)}const h=new _Z(t,o.shape,c.shape);return l.runWebGPUProgram(h,[o,c],u)}}const{mx:zZ,ct:BZ,YG:jZ,hH:WZ,z3:VZ,sG:UZ,uM:HZ,vS:GZ,C1:qZ,qB:KZ,GG:XZ,lg:YZ,rq:QZ,cu:ZZ,WR:JZ,px:$Z,jC:eJ,He:tJ,hE:nJ,BF:aJ,Dk:sJ,cl:rJ,_B:iJ,qy:oJ,Zy:cJ,bu:lJ,dH:uJ,HS:hJ,eW:dJ,GK:pJ,dl:fJ,Dw:mJ,xT:gJ,_X:yJ,wz:bJ}=N,xJ=FZ({opType:iZ.ABS,cpuKernelImpl:uJ}),vJ={kernelName:rh,backendName:"webgpu",kernelFunc:xJ},wJ=FZ({opType:iZ.ACOS}),kJ={kernelName:ih,backendName:"webgpu",kernelFunc:wJ},SJ=FZ({opType:iZ.ACOSH}),CJ={kernelName:oh,backendName:"webgpu",kernelFunc:SJ},IJ=LZ({opType:sZ.ADD,cpuKernelImpl:zZ,supportsComplex:!0}),NJ={kernelName:ch,backendName:"webgpu",kernelFunc:IJ};class TJ{constructor(e){this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e[0],this.variableNames=e.map((e,t)=>"T".concat(t)),this.dispatchLayout=ZQ(this.outputShape),this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="addN"}getUserCode(){const e=[];this.variableNames.forEach(t=>{e.push("let v".concat(t," = get").concat(t,"ByOutputCoords(coords);"))});const t=this.variableNames.map(e=>"v".concat(e)).join(" + ");return"\n      ".concat(zQ("index")," {\n        for (var i = 0; i < ").concat(this.workPerThread,"; i = i + 1) {\n          let flatIndex = index * ").concat(this.workPerThread," + i;\n          if (flatIndex < uniforms.size) {\n            let coords = getCoordsFromIndex(flatIndex);\n            ").concat(e.join("\n        "),"\n            setOutputAtIndex(flatIndex, ").concat(t,");\n          }\n        }\n      }\n    ")}}const EJ={kernelName:lh,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,a=t;if(1===a.length)return AZ({inputs:{x:a[0]},backend:n});const s=a.map(e=>e.dtype).reduce((e,t)=>gm(e,t)),r=a.map(e=>e.shape),i=new TJ(r);return n.runWebGPUProgram(i,a,s)}};class RJ{constructor(e,t){this.variableNames=["A"],this.workgroupSize=[16,16,1];const n=new Array(e.length);for(let a=0;a<n.length;a++)n[a]=e[t[a]];this.outputShape=n,this.dispatchLayout={x:[0],y:[1]},this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize,[1,1,1]),this.shaderKey="transposeShared"}getUserCode(){bu(this.workgroupSize[0]===this.workgroupSize[1],()=>"Must be a square tile, current tile shape is ".concat(this.workgroupSize[0]," x ").concat(this.workgroupSize[1]));const e=this.workgroupSize[0];return"\n      var<workgroup> tile : array<array<f32, ".concat(this.workgroupSize[0]+1,">, ").concat(this.workgroupSize[0],">;\n      ").concat(zQ()," {\n        var x = i32(workgroupId.x) * ").concat(e," + i32(localId.x);\n        var y = i32(workgroupId.y) * ").concat(e," + i32(localId.y);\n        let width = uniforms.outShape[0];\n        let height = uniforms.outShape[1];\n        if (x < width && y < height) {\n          tile[localId.y][localId.x] = f32(A[y * width + x]);\n        }\n        workgroupBarrier();\n\n        x = i32(workgroupId.y) * ").concat(e," + i32(localId.x);\n        y = i32(workgroupId.x) * ").concat(e," + i32(localId.y);\n        if (x < height && y < width) {\n          setOutputAtIndex((y * height + x), tile[localId.x]\n            [localId.y]);\n        }\n      }\n    ")}}class _J{constructor(e,t){this.variableNames=["A"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0;const n=new Array(e.length);for(let a=0;a<n.length;a++)n[a]=e[t[a]];this.outputShape=n,this.dispatchLayout=ZQ(this.outputShape),this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.newDim=t,this.shaderKey="transpose_".concat(t)}getUserCode(){const e=FQ(this.outputShape.length),t=AJ(this.newDim);return"\n      ".concat(zQ("index")," {\n        for(var i = 0; i < ").concat(this.workPerThread,"; i = i + 1) {\n          let flatIndex = index * ").concat(this.workPerThread," + i;\n          if(flatIndex < uniforms.size) {\n            let coords = getCoordsFromIndex(flatIndex);\n            setOutputAtIndex(flatIndex, A[getIndexFromCoords").concat(this.outputShape.length,"D(\n              ").concat(e,"(").concat(t,"), uniforms.aShape)]);\n          }\n        }\n      }\n    ")}}function AJ(e){const t=e.length;if(t>6)throw Error("Transpose for rank ".concat(t," is not yet supported"));const n=new Array(t);for(let a=0;a<e.length;a++)n[e[a]]="coords.".concat(LQ(a));return n.join()}function MJ(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{perm:r}=a,i=n,o=s.shape.length,c=new Array(o);for(let u=0;u<c.length;u++)c[u]=s.shape[r[u]];if(n.shouldExecuteOnCPU([s])){const e=i.tensorMap.get(s.dataId).values,t=yJ(e,s.shape,s.dtype,r,c);return n.makeTensorInfo(c,s.dtype,t)}if(2===s.shape.length&&Su(r,[1,0])){const e=new RJ(s.shape,r);return i.runWebGPUProgram(e,[s],s.dtype)}const l=new _J(s.shape,r);return i.runWebGPUProgram(l,[s],s.dtype)}const PJ={kernelName:rf,backendName:"webgpu",kernelFunc:MJ};class DJ{constructor(e,t,n){this.variableNames=["x"],this.uniforms="reduceSize : i32,",this.size=!0,this.inputShape=[e.batchSize,e.inSize];const[a]=Jx(this.inputShape,[1]);this.outputShape=0===a.length?[1]:a,e.inSize>=32768&&n>=512?this.workgroupSize=[512,1,1]:e.inSize>=4096?this.workgroupSize=[256,1,1]:this.workgroupSize=[64,1,1],this.dispatchLayout=ZQ(this.outputShape),this.dispatch=XQ(this.dispatchLayout,this.outputShape,[1,1,1]),this.reduceType=t,this.shaderKey="reduce_".concat(t)}getUserCode(){let e="",t="0.0";const n=this.workgroupSize[0];"min"===this.reduceType||"max"===this.reduceType?(e="\n         if (isnan(candidate)) {\n          bestValue = uniforms.NAN;\n         } else if (!isnan(bestValue) && candidate ".concat("min"===this.reduceType?"<":">"," bestValue)\n           {  bestValue = candidate; }"),t="f32(x[offset])"):"sum"===this.reduceType||"mean"===this.reduceType?e=" bestValue = bestValue + candidate; ":"prod"===this.reduceType?(e=" bestValue = bestValue * candidate; ",t="1.0"):"all"===this.reduceType?(e=" bestValue = f32(bestValue >= 1.0 && candidate >= 1.0); ",t="1.0"):"any"===this.reduceType&&(e=" bestValue = f32(bestValue >= 1.0 || candidate >= 1.0); ",t="0.0");const a="mean"===this.reduceType?"setOutputAtIndex(outputIndex, bestValue / f32(uniforms.reduceSize));":"setOutputAtIndex(outputIndex, bestValue);",s="\n         var<workgroup> xBestValues : array<f32, ".concat(n,">;\n       ");return"\n       fn DIV_CEIL(a : u32, b : u32) -> u32 {\n        return ((a - 1u) / b + 1u);\n       }\n\n       ".concat(s,"\n       fn getOffset(outputIndex : i32) -> i32 {\n         let outputCoords = getCoordsFromIndex(outputIndex);\n         let offset = ").concat(1===this.outputShape.length?"outputCoords":"outputCoords[0]"," * uniforms.reduceSize;\n          return offset;\n       }\n       ").concat(zQ("index")," {\n         let outputIndex = index / ").concat(n,";\n         let offset = getOffset(outputIndex);\n         var bestValue = ").concat(t,";\n         let Length = uniforms.reduceSize;\n         let WorkPerThread = DIV_CEIL(u32(Length), ").concat(n,"u);\n         for (var k = i32(localId.x); k < Length && outputIndex < uniforms.size;\n             k = k + ").concat(n,") {\n           let candidate = f32(x[offset + k]);\n           ").concat(e,"\n         }\n         xBestValues[localId.x] = bestValue;\n         workgroupBarrier();\n\n         var reduceSize = min(u32(Length), ").concat(n,"u);\n         for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n             currentSize = reduceSize / 2u) {\n           let interval = DIV_CEIL(reduceSize, 2u);\n           if (localId.x < currentSize) {\n            let candidate = xBestValues[localId.x + interval];\n            ").concat(e,"\n            xBestValues[localId.x] = bestValue;\n           }\n           reduceSize = interval;\n           workgroupBarrier();\n         }\n\n         if (localId.x == 0u && outputIndex < uniforms.size) {\n          ").concat(a,"\n        }\n       }\n     ")}}const OJ={mean:"float32",all:"bool",any:"bool"};function FJ(e,t,n,a,s){const r=e.shape.length,i=[],o=Ru(t,e.shape);let c=o;const l=tv(c,r);let u=e;null!=l&&(u=MJ({inputs:{x:e},attrs:{perm:l},backend:s}),c=av(c.length,r),i.push(u)),ev(a,c,r);const[h,d]=Jx(u.shape,c);let p,f=h;if(n&&(f=$x(h,o)),"max"!==a&&"prod"!==a||!s.shouldExecuteOnCPU([u])){const t=wu(d),n={windowSize:t,inSize:t,batchSize:wu(u.shape)/t,outSize:1},r=OJ[a]||ym(e.dtype),o=[{type:"int32",data:[t]}],c=new DJ(n,a,s.device.limits.maxComputeWorkgroupSizeX),l=s.runWebGPUProgram(c,[u],r,o);i.push(l),p=IZ({inputs:{x:l},attrs:{shape:f},backend:s})}else{const t=s.tensorMap.get(u.dataId).values;switch(a){case"max":const n=eJ(t,wu(d),f,e.dtype);p=s.makeTensorInfo(f,e.dtype,n);break;case"prod":const{outVals:r,outShape:i,outDtype:o}=iJ(u.shape,u.dtype,t,c);p=s.makeTensorInfo(i,o,r);break;default:throw new Error("".concat(a," CPU implementation is not yet supported."))}}return i.forEach(e=>s.disposeData(e.dataId)),p}const LJ={kernelName:uh,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{keepDims:r,axis:i}=a;return FJ(s,i,r,"all",n)}};const zJ={kernelName:hh,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{keepDims:r,axis:i}=a;return FJ(s,i,r,"any",n)}};class BJ{constructor(e,t,n){this.workgroupSize=[64,1,1],this.variableNames=["x"],this.uniforms="infinityValue : f32,",this.size=!0;const a=[t];this.op="min"===n?"<":">";const[s,r]=Jx(e,a);this.outputShape=0===s.length?[1]:s,this.dispatchLayout=ZQ(this.outputShape),wu(r)<32?(this.type="plain",this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize)):(this.type="shared",this.dispatch=XQ(this.dispatchLayout,this.outputShape,[1,1,1])),this.inputShape=e,this.shaderKey="argMinMax_".concat(this.op,"_").concat(this.type)}getUserCode(){const e=this.workgroupSize[0],t=()=>1===this.inputShape.length?"uniforms.xShape":"uniforms.xShape.".concat(LQ(this.inputShape.length-1)),n=()=>{let e="";if(1===this.outputShape.length)1!==this.inputShape.length&&(e+="outputCoords,");else for(let t=0;t<this.outputShape.length;t++)e+="outputCoords.".concat(LQ(t),",");return e};if("shared"===this.type){const a="\n      var<workgroup> xBestIndices : array<i32, ".concat(e,">;\n      var<workgroup> xBestValues : array<f32, ").concat(e,">;\n    ");return"\n      fn DIV_CEIL(a : u32, b : u32) -> u32 {\n        return ((a - 1u) / b + 1u);\n      }\n\n      ".concat(a,"\n\n      ").concat(zQ("index")," {\n        let outputIndex = index / ").concat(e,";\n        let reduceLength = ").concat(t(),";\n\n        var bestIndex = i32(localId.x);\n        var bestValue = uniforms.infinityValue;\n        let outputCoords = getCoordsFromIndex(outputIndex);\n        for (var k = i32(localId.x); k < reduceLength && outputIndex < uniforms.size;\n            k = k + ").concat(e,") {\n          let candidate = getX(").concat(n()," k);\n          if (!isnan(candidate) && candidate ").concat(this.op," bestValue) {\n            bestValue = candidate;\n            bestIndex = k;\n          }\n        }\n        xBestValues[localId.x] = bestValue;\n        xBestIndices[localId.x] = bestIndex;\n        workgroupBarrier();\n\n        var reduceSize = min(u32(reduceLength), ").concat(e,"u);\n        for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n            currentSize = reduceSize / 2u) {\n          let interval = DIV_CEIL(reduceSize, 2u);\n          if (localId.x < currentSize) {\n            let candidate = xBestValues[localId.x + interval];\n            if (candidate ").concat(this.op," bestValue) {\n              bestValue = candidate;\n              xBestValues[localId.x] = bestValue;\n              xBestIndices[localId.x] = xBestIndices[localId.x + interval];\n            }\n          }\n          reduceSize = interval;\n          workgroupBarrier();\n        }\n\n        if (localId.x == 0u && outputIndex < uniforms.size) {\n          setOutputAtIndexI32(outputIndex, xBestIndices[localId.x]);\n        }\n      }\n    ")}return"\n      ".concat(zQ("index")," {\n        if (index < uniforms.size) {\n          let outputCoords = getCoordsFromIndex(index);\n          var bestIndex = 0;\n          var bestValue = getX(").concat(n()," 0);\n          let reduceLength = ").concat(t(),";\n          for (var i = 1; i < reduceLength; i++) {\n            let candidate = getX(").concat(n()," i);\n            if (candidate ").concat(this.op," bestValue) {\n              bestValue = candidate;\n              bestIndex = i;\n            }\n          }\n          setOutputAtIndexI32(index, bestIndex);\n        }\n      }\n      ")}}const jJ={kernelName:dh,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{axis:r}=a;let i=Ru(r,s.shape);const o=tv(i,s.shape.length);let c=s;const l=[];null!=o&&(c=MJ({inputs:{x:s},backend:n,attrs:{perm:o}}),l.push(c),i=av(i.length,c.shape.length)),ev("argMax",[i[0]],c.shape.length);const u=new BJ(c.shape,i[0],"max"),h=[{type:"float32",data:[Number.NEGATIVE_INFINITY]}],d=n.runWebGPUProgram(u,[c],"int32",h);return l.forEach(e=>n.disposeData(e.dataId)),d}};const WJ={kernelName:ph,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{axis:r}=a;let i=Ru(r,s.shape);const o=tv(i,s.shape.length);let c=s;const l=[];null!=o&&(c=MJ({inputs:{x:s},backend:n,attrs:{perm:o}}),l.push(c),i=av(i.length,c.shape.length)),ev("argMin",[i[0]],c.shape.length);const u=new BJ(c.shape,i[0],"min"),h=[{type:"float32",data:[Number.POSITIVE_INFINITY]}],d=n.runWebGPUProgram(u,[c],"int32",h);return l.forEach(e=>n.disposeData(e.dataId)),d}},VJ=FZ({opType:iZ.ASIN}),UJ={kernelName:fh,backendName:"webgpu",kernelFunc:VJ},HJ=FZ({opType:iZ.ASINH}),GJ={kernelName:mh,backendName:"webgpu",kernelFunc:HJ},qJ=FZ({opType:iZ.ATAN}),KJ={kernelName:gh,backendName:"webgpu",kernelFunc:qJ},XJ=LZ({opType:sZ.ATAN2}),YJ={kernelName:bh,backendName:"webgpu",kernelFunc:XJ},QJ=FZ({opType:iZ.ATANH}),ZJ={kernelName:yh,backendName:"webgpu",kernelFunc:QJ};class JJ{constructor(e){this.variableNames=["x"],this.uniforms="strides : vec2<i32>,",this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=ZQ(this.outputShape),this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="poolWithFilterSizeEqualsOne"}getUserCode(){return"\n      ".concat(zQ("index")," {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let batch = coords[0];\n          let d = coords[3];\n\n          let xRCCorner = coords.yz * uniforms.strides;\n          let xRCorner = xRCCorner.x;\n          let xCCorner = xRCCorner.y;\n\n          let value = getX(batch, xRCorner, xCCorner, d);\n          setOutputAtIndex(index, value);\n        }\n      }\n    ")}}class $J{constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(this.variableNames=["x"],this.uniforms="strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, convDims : vec2<i32>, filterDims : vec2<i32>,",this.workgroupSize=[128,1,1],this.size=!0,"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");this.outputShape=e.outShape,this.dispatchLayout=ZQ(this.outputShape),this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.poolType=t,this.computePositions=n,this.flattenPositions=a,this.includeBatchIndex=s,this.shaderKey="pool2D_".concat(t,"_").concat(n,"_").concat(a,"_").concat(s)}getUserCode(){let e;if("avg"===this.poolType)e="resultValue = resultValue + value; count = count + 1.0;";else if(this.computePositions){const t=this.flattenPositions?this.includeBatchIndex?"((batch * uniforms.xShape[1] + xR) * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d":"(xR * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d":"wR * uniforms.filterDims.y + wC";e="let currMaxValue = mix(value, maxValue, maxValueFound);\n      if (value >= currMaxValue) {\n        maxValue = value;\n        maxValueFound = 1.0;\n        maxPosition = ".concat(t,";\n      }")}else e="resultValue = max(value, resultValue);";let t="resultValue";"avg"===this.poolType&&(t="resultValue / max(count, 1.0)");return"\n      ".concat(zQ("index")," {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n          let batch = coords[0];\n          let d = coords[3];\n          let xRCCorner = vec2<i32>(coords.yz) * uniforms.strides - uniforms.pads;\n          let xRCorner = xRCCorner.x;\n          let xCCorner = xRCCorner.y;\n\n          ").concat(this.computePositions?"var maxValue = 0.0;\n            var maxValueFound = 0.0;\n            var maxPosition = 0;":"var resultValue = ".concat("avg"===this.poolType?"0.0":"-1.0 / pow(10.0, -20.0)",";"),"\n\n          var count = 0.0;\n          for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + uniforms.dilations.x) {\n            let xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= uniforms.convDims.x) {\n              continue;\n            }\n\n            for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + uniforms.dilations.y) {\n              let xC = xCCorner + wC;\n              if (xC < 0 || xC >= uniforms.convDims.y) {\n                continue;\n              }\n\n              let value = getX(batch, xR, xC, d);\n              ").concat(e,"\n            }\n          }\n\n          ").concat(this.computePositions?"setOutputAtIndexI32(index, maxPosition);":"setOutputAtIndex(index, ".concat(t,");"),"\n        }\n      }\n    ")}}class e${constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(this.variableNames=["x"],this.uniforms="strides : vec3<i32>, pads : vec3<i32>, convDims : vec3<i32>, filterDims : vec3<i32>,",this.workgroupSize=[128,1,1],this.size=!0,"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");this.outputShape=e.outShape,this.dispatchLayout=ZQ(this.outputShape),this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.poolType=t,this.computePositions=n,this.flattenPositions=a,this.includeBatchIndex=s,this.shaderKey="pool3D_".concat(t,"_").concat(n,"_").concat(a,"_").concat(s)}getUserCode(){let e;if("avg"===this.poolType)e="resultValue += value; count += 1.0;";else if(this.computePositions){const t=this.flattenPositions?this.includeBatchIndex?"(((batch * uniforms.xShape.y + xD) * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch":"((xD * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch":"wD * uniforms.filterDims.y * uniforms.filterDims.y + wR * uniforms.filterDims.z + wC";e="let currMaxValue = mix(value, maxValue, maxValueFound);\n      if (value >= currMaxValue) {\n        maxValue = value;\n        maxValueFound = 1.0;\n        maxPosition = ".concat(t,";\n      }")}else e="resultValue = max(value, resultValue);";let t="resultValue";"avg"===this.poolType&&(t="resultValue / max(count, 1.0)");return"\n      ".concat(zQ("index")," {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let batch = coords.x;\n          let ch = coords.u;\n\n          let xCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;\n          let xDCorner = xCorner.x;\n          let xRCorner = xCorner.y;\n          let xCCorner = xCorner.z;\n\n          ").concat(this.computePositions?"var maxValue = 0.0;\n            var maxValueFound = 0.0;\n            var maxPosition = 0;":"var resultValue = ".concat("avg"===this.poolType?"0.0":"-1.0 / pow(10.0, -20.0)",";"),"\n\n          var count = 0.0;\n          for (var wD = 0; wD < uniforms.filterDims.x; wD++) {\n            let xD = xDCorner + wD;\n            if (xD < 0 || xD >= uniforms.convDims.x) {\n              continue;\n            }\n\n            for (var wR = 0; wR < uniforms.filterDims.y; wR++) {\n              let xR = xRCorner + wR;\n              if (xR < 0 || xR >= uniforms.convDims.y) {\n                continue;\n              }\n\n              for (var wC = 0; wC < uniforms.filterDims.z; wC++) {\n                let xC = xCCorner + wC;\n                if (xC < 0 || xC >= uniforms.convDims.z) {\n                  continue;\n                }\n\n                let value = getX(batch, xD, xR, xC, ch);\n                ").concat(e,"\n              }\n            }\n          }\n\n          ").concat(this.computePositions?"setOutputAtIndexI32(index, maxPosition);":"setOutputAtIndex(index, ".concat(t,");"),"\n        }\n      }\n    ")}}function t$(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{reductionIndices:r,keepDims:i}=a;return FJ(s,r,i,"max",n)}const n$={kernelName:Ld,backendName:"webgpu",kernelFunc:t$};function a$(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{keepDims:r,axis:i}=a;return FJ(s,i,r,"mean",n)}const s$={kernelName:Hd,backendName:"webgpu",kernelFunc:a$};function r$(e,t,n,a){if(1===t.filterWidth&&1===t.filterHeight&&Su(t.inShape,t.outShape))return AZ({inputs:{x:e},backend:a});if(t.filterWidth===t.inWidth&&t.filterHeight===t.inHeight&&1===t.batchSize&&"VALID"===t.padInfo.type){const s=e.shape.length,r=IZ({inputs:{x:e},backend:a,attrs:{shape:[e.shape[s-3]*e.shape[s-2],e.shape[s-1]]}});let i;"avg"===n?i=a$({inputs:{x:r},backend:a,attrs:{axis:0,keepDims:!1}}):(bu("max"===n,()=>"Invalid pool type ".concat(n)),i=t$({inputs:{x:r},backend:a,attrs:{reductionIndices:0,keepDims:!1}}));const o=IZ({inputs:{x:i},backend:a,attrs:{shape:t.outShape}});return a.disposeData(r.dataId),a.disposeData(i.dataId),o}let s;const r=[{type:"int32",data:[t.strideHeight,t.strideWidth]}];return 1===t.filterHeight&&1===t.filterWidth?s=new JJ(t):("avg"===n?s=new $J(t,"avg"):(bu("max"===n,()=>"Invalid pool type ".concat(n)),s=new $J(t,"max")),r.push({type:"int32",data:[t.padInfo.top,t.padInfo.left]},{type:"int32",data:[t.dilationHeight,t.dilationWidth]},{type:"int32",data:[t.inHeight,t.inWidth]},{type:"int32",data:[t.effectiveFilterHeight,t.effectiveFilterWidth]})),a.runWebGPUProgram(s,[e],e.dtype,r)}const i$={kernelName:xh,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{filterSize:r,strides:i,pad:o,dimRoundingMode:c}=a;return r$(s,Vb(s.shape,r,i,1,o,c),"avg",n)}};const o$={kernelName:wh,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{filterSize:r,strides:i,pad:o,dataFormat:c,dimRoundingMode:l}=a,u=Ub(s.shape,r,i,[1,1,1],o,l,c),h=new e$(u,"avg"),d=[{type:"int32",data:[u.strideDepth,u.strideHeight,u.strideWidth]},{type:"int32",data:[u.padInfo.front,u.padInfo.top,u.padInfo.left]},{type:"int32",data:[u.inDepth,u.inHeight,u.inWidth]},{type:"int32",data:[u.effectiveFilterDepth,u.effectiveFilterHeight,u.effectiveFilterWidth]}];return n.runWebGPUProgram(h,[s],s.dtype,d)}};class c${constructor(e){this.variableNames=["dy"],this.uniforms="strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,\n       outHeight : i32, outWidth : i32, avgMultiplier : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=ZQ(this.outputShape),this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avgPool2DBackprop"}getUserCode(){return"\n      ".concat(zQ("index")," {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords[0];\n        let d = coords[3];\n\n        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;\n        let dyRCorner = dyRCCorner.x;\n        let dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        for (var wR = 0; wR < uniforms.filterDims[0]; wR = wR + uniforms.dilations[0]) {\n          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);\n\n          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {\n            continue;\n          }\n          let idyR = i32(dyR);\n\n          for (var wC = 0; wC < uniforms.filterDims[1]; wC = wC + uniforms.dilations[1]) {\n            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);\n\n            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {\n              continue;\n            }\n            let idyC = i32(dyC);\n\n            let dyValue = getDy(batch, idyR, idyC, d);\n\n            dotProd = dotProd + dyValue * uniforms.avgMultiplier;\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n    ")}}class l${constructor(e){this.variableNames=["dy"],this.uniforms="strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,\n       outDepth : i32, outHeight : i32, outWidth : i32, avgMultiplier : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=ZQ(this.outputShape),this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avgPool3DBackprop"}getUserCode(){return"\n      ".concat(zQ("index")," {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords.x;\n        let ch = coords.u;\n\n        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;\n        let dyDCorner = dyCorner.x;\n        let dyRCorner = dyCorner.y;\n        let dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {\n          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);\n\n          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {\n            continue;\n          }\n          let idyD = i32(dyD);\n\n          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {\n            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);\n\n            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {\n              continue;\n            }\n            let idyR = i32(dyR);\n\n            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {\n              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);\n\n              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {\n                continue;\n              }\n              let idyC = i32(dyC);\n\n              let dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              dotProd += dyValue * uniforms.avgMultiplier;\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n    ")}}const u$={kernelName:kh,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:s,input:r}=t,i=r,{filterSize:o,strides:c,pad:l,dimRoundingMode:u}=a,h=Ub(i.shape,o,c,1,l,u),d=new l$(h),p=1/(h.filterDepth*h.filterHeight*h.filterWidth),f=[{type:"int32",data:[h.strideDepth,h.strideHeight,h.strideWidth]},{type:"int32",data:[h.effectiveFilterDepth-1-h.padInfo.front,h.effectiveFilterHeight-1-h.padInfo.top,h.effectiveFilterWidth-1-h.padInfo.left]},{type:"int32",data:[h.effectiveFilterDepth,h.effectiveFilterHeight,h.effectiveFilterWidth]},{type:"int32",data:[h.outDepth]},{type:"int32",data:[h.outHeight]},{type:"int32",data:[h.outWidth]},{type:"float32",data:[p]}];return n.runWebGPUProgram(d,[s],i.dtype,f)}};const h$={kernelName:vh,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:s,input:r}=t,i=r;eZ([s,r],"avgPoolGrad");const{filterSize:o,strides:c,pad:l}=a,u=Vb(i.shape,o,c,1,l),h=new c$(u),d=1/(u.filterHeight*u.filterWidth),p=[{type:"int32",data:[u.strideHeight,u.strideWidth]},{type:"int32",data:[u.effectiveFilterHeight-1-u.padInfo.top,u.effectiveFilterWidth-1-u.padInfo.left]},{type:"int32",data:[u.dilationHeight,u.dilationWidth]},{type:"int32",data:[u.effectiveFilterHeight,u.effectiveFilterWidth]},{type:"int32",data:[u.outHeight]},{type:"int32",data:[u.outWidth]},{type:"float32",data:[d]}];return n.runWebGPUProgram(h,[s],i.dtype,p)}};const d$={kernelName:Sh,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{a:s,b:r}=t,{transposeA:i,transposeB:o}=a;return TZ({a:s,b:r,transposeA:i,transposeB:o,backend:n})}};class p${constructor(e,t){this.variableNames=["source"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.rank=t.length,this.dispatchLayout=ZQ(this.outputShape),this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.start=e,this.uniforms="start : ".concat(FQ(e.length),", "),this.shaderKey="slice"}getUserCode(){const e=FQ(this.rank),t=function(e){if(1===e)return"sourceLoc";if(e<=6)return f$.slice(0,e).map(e=>"sourceLoc.".concat(e)).join(",");throw Error("Slicing for rank ".concat(e," is not yet supported"))}(this.rank);let n;n=1===this.start.length?this.outputShape.map((e,t)=>"sourceLoc = uniforms.start + coords;"):this.outputShape.map((e,t)=>"sourceLoc.".concat(f$[t]," = uniforms.start.").concat(LQ(t)," + coords.").concat(f$[t],";"));return"\n      ".concat(zQ("index")," {\n        if (index < uniforms.size) {\n          var sourceLoc : ").concat(e,";\n          let coords = getCoordsFromIndex(index);\n          ").concat(n.join("\n"),"\n          setOutputAtIndex(index, getSource(").concat(t,"));\n        }\n      }\n    ")}}const f$=["x","y","z","w","u","v"];function m$(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{begin:r,size:i}=a,[o,c]=Nb(s,r,i);if(db(s,o,c),n.shouldExecuteOnCPU([s])||"string"===s.dtype){const e=n.tensorMap.get(s.dataId),t=hJ(e.values,o,c,s.shape,s.dtype);return n.makeTensorInfo(c,s.dtype,t)}if(0===wu(c))return n.makeTensorInfo(c,s.dtype,[]);const l=new p$(o,c),u=[{type:"int32",data:o}];return n.runWebGPUProgram(l,[s],s.dtype,u)}const g$={kernelName:_p,backendName:"webgpu",kernelFunc:m$},y$={kernelName:Ch,backendName:"webgpu",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{blockShape:r,crops:i}=a;bu(s.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGPU backend not implemented yet");const o=r.reduce((e,t)=>e*t),c=cC(s.shape,r,o),l=lC(c.length,r.length),u=uC(s.shape,r,o),h=hC(i,r.length),d=dC(u,i,r.length),p=[],f=IZ({inputs:{x:s},backend:n,attrs:{shape:c}}),m=MJ({inputs:{x:f},backend:n,attrs:{perm:l}}),g=IZ({inputs:{x:m},backend:n,attrs:{shape:u}}),y=m$({inputs:{x:g},backend:n,attrs:{begin:h,size:d}});return p.push(f),p.push(m),p.push(g),p.forEach(e=>n.disposeData(e.dataId)),y}},b$="\n  fn bincount_write(index: i32, value: f32) {\n    ".concat(MQ("&result[index]","value","float32"),"\n  }\n");class x${constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];this.outputShape=[],this.variableNames=["x"],this.uniforms="binCountSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.hasWeights=!0,this.binaryOutput=!1,this.outputShape=e,this.rank=e.length,this.dispatchLayout=ZQ(this.outputShape),this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.binaryOutput=n,n&&(this.atomic=!1),this.hasWeights=t,this.hasWeights&&this.variableNames.push("w"),this.shaderKey="bincount_".concat(this.hasWeights,"_").concat(this.binaryOutput,"_").concat(this.rank)}getUserCode(){return"\n    ".concat(this.binaryOutput?"\n  fn bincount_write(index: i32, value: f32) {\n    atomicStore(&result[index], bitcast<i32>(value));\n  }\n":b$,"\n  ").concat(zQ("index")," {\n    ").concat(1===this.rank?"if (index < uniforms.xShape) {\n      let indexVal = i32(getX(index));\n      if (indexVal < uniforms.binCountSize) {\n        let value = ".concat(this.binaryOutput?1:this.hasWeights?"getW(index)":"1.",";\n        bincount_write(indexVal, value);\n      }\n    }"):"let coord = getCoordsFromIndex(index);\n    if (coordsInBounds2D(coord, uniforms.xShape)) {\n      let indexVal = i32(getX(coord[0], coord[1]));\n      if (indexVal < uniforms.binCountSize) {\n        let value = ".concat(this.binaryOutput?1:this.hasWeights?"getW(coord[0], coord[1])":"1.",";\n        bincount_write(coord.x * uniforms.binCountSize + indexVal, value);\n      }\n    }"),"\n  }\n  ")}}const v$={kernelName:Ih,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,weights:r}=t,{size:i}=a,o=wu(s.shape),c=wu(r.shape)>0,l=[i],u=r.dtype,h=SZ({backend:n,attrs:{shape:l,value:0,dtype:u}}),d=new x$([o],c),p=[{type:"int32",data:[i]}],f=c?[s,r]:[s];return n.runWebGPUProgram(d,f,u,p,h)}};class w${constructor(e){this.outputShape=[],this.variableNames=["s0","s1"],this.uniforms="s0Size : i32, s1Size : i32, ",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e],this.dispatchLayout=ZQ(this.outputShape),this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="broadcastArgs"}getUserCode(){return"\n  ".concat(zQ("index")," {\n    if (index < uniforms.size) {\n      var s0 = 1.0;\n      var s1 = 1.0;\n      let indexS0 = index - uniforms.size + uniforms.s0Size;\n      let indexS1 = index - uniforms.size + uniforms.s1Size;\n      if (indexS0 >= 0) {\n        s0 = getS0(indexS0);\n      }\n      if (indexS1 >= 0) {\n        s1 = getS1(indexS1);\n      }\n\n      if (s0 == 1.0) {\n        setOutputAtIndex(index, s1);\n      } else if (s1 == 1.0) {\n        setOutputAtIndex(index, s0);\n      } else if (s0 != s1) {\n        setOutputAtIndex(index, uniforms.NAN);\n      } else {\n        setOutputAtIndex(index, s0);\n      }\n    }\n  }\n  ")}}const k$={kernelName:Th,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{s0:a,s1:s}=t;if(n.shouldExecuteOnCPU([a,s])){const e=n.tensorMap.get(a.dataId),t=n.tensorMap.get(s.dataId),r=e.values,i=t.values,o=_y(Array.from(r),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}const r=wu(a.shape),i=wu(s.shape),o=Math.max(r,i),c=new w$(o),l=[{type:"int32",data:[r]},{type:"int32",data:[i]}];return n.runWebGPUProgram(c,[a,s],"int32",l)}},S$=LZ({opType:sZ.NOT_EQUAL,dtype:"bool",cpuKernelImpl:rJ}),C$={kernelName:Jd,backendName:"webgpu",kernelFunc:S$};function I$(e){const{inputs:t,backend:n}=e,{input:a}=t;return AZ({inputs:{x:n.tensorMap.get(a.dataId).complexTensorInfos.real},backend:n})}const N$={kernelName:pp,backendName:"webgpu",kernelFunc:I$};const T$={kernelName:Eh,backendName:"webgpu",kernelFunc:function e(t){const{inputs:n,backend:a,attrs:s}=t,{x:r}=n,{dtype:i}=s;if("complex64"===i){if("complex64"===r.dtype)return AZ({inputs:{x:r},backend:a});const t=qv(r.shape),n=e({inputs:{x:r},backend:a,attrs:{dtype:"float32"}}),s=PZ({inputs:{real:n,imag:t},backend:a});return t.dispose(),a.disposeData(n.dataId),s}if("complex64"===r.dtype){const t=I$({inputs:{input:r},backend:a}),n=e({inputs:{x:t},backend:a,attrs:{dtype:i}});return a.disposeData(t.dataId),n}if(!Pu(r.dtype,i)){const e=AZ({inputs:{x:r},backend:a});return{dataId:e.dataId,shape:e.shape,dtype:i}}if(a.shouldExecuteOnCPU([r])){const e=a.tensorMap.get(r.dataId).values,[t,n,s]=BZ(e,r.shape,r.dtype,i);return a.makeTensorInfo(t,n,s)}if("int32"===i)return function(e,t){const n=new OZ(e.shape,iZ.TO_INT),a=t.runWebGPUProgram(n,[e],"int32");return{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}(r,a);if("bool"===i){const e=a.makeTensorInfo([],"bool",Au("bool",1)),t=S$({inputs:{a:r,b:e},backend:a});return a.disposeData(e.dataId),t}throw new Error("Error in Cast: failed to cast ".concat(r.dtype," to ").concat(i))}},E$=FZ({opType:iZ.CEIL,cpuKernelImpl:jZ}),R$={kernelName:Rh,backendName:"webgpu",kernelFunc:E$};class _${constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workPerThread=4,this.workgroupSize=[64,1,1],this.outputComponent=4,this.size=!0,this.outputShape=e,this.dispatchLayout=ZQ(this.outputShape),this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="clipVec4"}getUserCode(){return"\n      ".concat(zQ("index")," {\n        if(index < uniforms.size) {\n          let value = getAByOutputIndex(index);\n          var clampedValue = clamp(\n              value, vec4<f32>(uniforms.minVal), vec4<f32>(uniforms.maxVal));\n          clampedValue = select(clampedValue, value, isnanVec4(value));\n          setOutputAtIndex(index, clampedValue);\n        }\n      }\n    ")}}class A${constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=ZQ(this.outputShape),this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="clip"}getUserCode(){return"\n      ".concat(zQ("index")," {\n        if(index < uniforms.size) {\n          let value = getAByOutputIndex(index);\n          if (isnan(value)) {\n            setOutputAtIndex(index, value);\n            return;\n          }\n          setOutputAtIndex(index, clamp(value, uniforms.minVal, uniforms.maxVal));\n        }\n      }\n    ")}}const M$={kernelName:_h,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{clipValueMin:r,clipValueMax:i}=a;let o;const c=[{type:"float32",data:[r]},{type:"float32",data:[i]}];return o=wu(s.shape)%4===0?new _$(s.shape):new A$(s.shape),n.runWebGPUProgram(o,[s],s.dtype,c)}};class P${constructor(e){this.outputShape=[],this.variableNames=["real","imag"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=ZQ(this.outputShape),this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="complexAbs"}getUserCode(){return"\n    ".concat(zQ("index")," {\n      if (index < uniforms.size) {\n        let re = abs(getRealByOutputIndex(index));\n        let im = abs(getImagByOutputIndex(index));\n        let mx = max(re, im);\n\n        // The length function in wgsl may be not underflow-safe on some GPUs.\n        // So the safe solution is to ensure underflow-safety in all cases.\n        setOutputAtIndex(index, select(mx * length(vec2<f32>(1, min(re, im)/mx)), 0.0, mx == 0.0));\n      }\n    }\n  ")}}function D$(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}const O$={kernelName:Mh,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t,s=n.tensorMap.get(a.dataId),r=new P$(a.shape),i=[D$(a,s.complexTensorInfos.real),D$(a,s.complexTensorInfos.imag)];return n.runWebGPUProgram(r,i,i[0].dtype)}};class F${constructor(e){this.uniforms="",this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=$S(e,1),this.variableNames=e.map((e,t)=>"T".concat(t)),this.dispatchLayout=ZQ(this.outputShape),this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.offsetLength=e.length-1;for(let t=0;t<this.offsetLength;t++)this.uniforms+="offset".concat(t," : i32,");this.shaderKey="concat"}getUserCode(){const e=[];if(this.offsetLength>0){e.push("if (yC < uniforms.offset0){ setOutputAtCoords(coords.x, coords.y, getT0(yR, yC)); }");for(let a=1;a<this.offsetLength;a++)e.push("else if (yC < uniforms.offset".concat([a],"){ ")+"setOutputAtCoords(coords.x, coords.y, getT".concat(a,"(yR, yC - uniforms.offset").concat(a-1,")); }"));const t=this.offsetLength,n=this.offsetLength-1;e.push("else { setOutputAtCoords(coords.x, coords.y, getT".concat(t,"(yR, yC - uniforms.offset").concat(n,")); }"))}else e.push("setOutputAtCoords(coords.x, coords.y, getT0(yR, yC));");return"\n      ".concat(zQ("index")," {\n        for(var i = 0; i < ").concat(this.workPerThread,"; i = i + 1) {\n          let flatIndex = index * ").concat(this.workPerThread," + i;\n          if(flatIndex < uniforms.size) {\n            let coords = getCoordsFromIndex(flatIndex);\n            let yR = coords.x;\n            let yC = coords.y;\n\n            ").concat(e.join("\n        "),"\n          }\n        }\n      }\n    ")}}function L$(e){const{inputs:t,backend:n}=e,{input:a}=t;return AZ({inputs:{x:n.tensorMap.get(a.dataId).complexTensorInfos.imag},backend:n})}const z$={kernelName:kd,backendName:"webgpu",kernelFunc:L$};function B$(e,t,n){const a=e[0].dtype;if("complex64"===a){const a=e.map(e=>I$({inputs:{input:e},backend:n})),s=e.map(e=>L$({inputs:{input:e},backend:n})),r=B$(a,t,n),i=B$(s,t,n),o=PZ({inputs:{real:r,imag:i},backend:n});return a.forEach(e=>n.disposeData(e.dataId)),s.forEach(e=>n.disposeData(e.dataId)),n.disposeData(r.dataId),n.disposeData(i.dataId),o}let s=n.shouldExecuteOnCPU(e);if("string"===a&&(s=!0),s){const s=e.map(e=>{const a=wu(e.shape.slice(t));return IZ({inputs:{x:e},backend:n,attrs:{shape:[-1,a]}})}),r=s.map(e=>({vals:n.readSync(e.dataId),shape:e.shape})),i=$S(s.map(e=>e.shape),1),o=1===s[0].shape[0],c=WZ(r,i,a,o),l=$S(e.map(e=>e.shape),t),u=n.makeTensorInfo(l,a,c);return s.forEach(e=>n.disposeData(e.dataId)),u}const r=n.device.limits.maxStorageBuffersPerShaderStage-1;if(e.length>r){const a=[];for(let i=0;i<e.length;i+=r){const s=e.slice(i,i+r);a.push(B$(s,t,n))}const s=B$(a,t,n);for(const e of a)n.disposeData(e.dataId);return s}const{tensors2D:i,outShape:o}=function(e,t,n){const a=$S(e.map(e=>e.shape),t),s=e.map(e=>IZ({inputs:{x:e},backend:n,attrs:{shape:[wu(e.shape.slice(0,t)),wu(e.shape.slice(t))]}}));return{tensors2D:s,outShape:a}}(e,t,n),c=i.map(e=>e.shape),l=new F$(c),u=[],h=new Array(c.length-1);if(h.length>0){h[0]=c[0][1],u.push({type:"int32",data:[h[0]]});for(let e=1;e<h.length;e++)h[e]=h[e-1]+c[e][1],u.push({type:"int32",data:[h[e]]})}const d=n.runWebGPUProgram(l,i,i[0].dtype,u);i.forEach(e=>n.disposeData(e.dataId));const p=IZ({inputs:{x:d},backend:n,attrs:{shape:o}});return n.disposeData(d.dataId),p}function j$(e){const{inputs:t,backend:n,attrs:a}=e,{axis:s}=a,r=Ru(s,t[0].shape)[0];JS(t.map(e=>e.shape),r);const i=$S(t.map(e=>e.shape),r);if(0===wu(i))return n.makeTensorInfo(i,t[0].dtype,[]);const o=t.filter(e=>wu(e.shape)>0);return 1===o.length?AZ({inputs:{x:o[0]},backend:n}):B$(o,r,n)}const W$={kernelName:Ph,backendName:"webgpu",kernelFunc:j$};class V${constructor(e,t,n,a){let s=arguments.length>4&&void 0!==arguments[4]&&arguments[4],r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,i=arguments.length>6&&void 0!==arguments[6]&&arguments[6],o=arguments.length>7&&void 0!==arguments[7]&&arguments[7];this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.outShape,this.isChannelsLast="channelsLast"===e.dataFormat,this.isVec4=((e.inChannels%4===0||e.inChannels%3===0)&&this.isChannelsLast||e.outWidth%4===0&&!this.isChannelsLast)&&e.outChannels%4===0,this.dispatchLayout=this.isChannelsLast?{x:[3],y:[1,2],z:[0]}:{x:[2,3],y:[1],z:[0]},this.workgroupSize=YQ(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=QQ(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4?(this.outputComponent=4,this.isChannelsLast&&e.inChannels%4!==0?(this.innerElementSize=3,this.variableComponents=[1,4]):(this.innerElementSize=4,this.variableComponents=[4,4]),s&&(this.variableNames.push("bias"),this.variableComponents.push(4)),i&&(this.variableNames.push("preluActivationWeights"),this.variableComponents.push(4))):(this.innerElementSize=this.elementsPerThread[0],s&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights")),this.sequentialAccessByThreads=o,this.addBias=s,this.activation=r,this.hasPreluActivationWeights=i,this.tileAOuter=this.workgroupSize[1]*this.elementsPerThread[1],this.tileBOuter=this.workgroupSize[0]*this.elementsPerThread[0],this.tileInner=Math.max(this.workgroupSize[0]*this.innerElementSize,this.workgroupSize[1]),this.fitAOuter=t%this.tileAOuter===0,this.fitBOuter=n%this.tileBOuter===0,this.fitInner=a%this.tileInner===0,this.shaderKey="conv2DMM_".concat(this.elementsPerThread,"_").concat(this.activation,"}_").concat(this.fitAOuter,"_").concat(this.fitBOuter,"_").concat(this.fitInner,"_").concat(this.isVec4,"_").concat(this.innerElementSize,"_").concat(this.isChannelsLast,"_").concat(this.sequentialAccessByThreads)}getUserCode(){const e=this.isVec4?fZ(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner):gZ(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner,!1,null,this.sequentialAccessByThreads),t=this.isVec4?[this.innerElementSize,4,4]:[1,1,1],n="\n    ".concat(function(e,t,n,a){let s=arguments.length>4&&void 0!==arguments[4]&&arguments[4],r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,i=arguments.length>6&&void 0!==arguments[6]&&arguments[6],o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:4,c=arguments.length>8&&void 0!==arguments[8]?arguments[8]:4,l=arguments.length>9&&void 0!==arguments[9]?arguments[9]:4;const u=e?"\n      let coord = vec4<i32>(batch, xRow, xCol, xCh);\n      ":"\n      let coord = vec4<i32>(batch, xCh, xRow, xCol);\n      ",h=e?"\n      let coords = vec4<i32>(\n        batch,\n        row / outWidth,\n        row % outWidth,\n        col);\n      ":"\n      let coords = vec4<i32>(\n        batch,\n        row,\n        col / outWidth,\n        col % outWidth);\n      ",d=e?"uniforms.xShape[1]":"uniforms.xShape[2]",p=e?"uniforms.xShape[2]":"uniforms.xShape[3]",f=e?"row":"col",m=e?"col":"row",g="\n      let inChannels = uniforms.wShape[2];\n      let outWidth = ".concat(e?"uniforms.outShape[2]":"uniforms.outShape[3]",";\n      let outRow = ").concat(f," / outWidth;\n      let outCol = ").concat(f," % outWidth;\n\n      let WRow = ").concat(m," / (uniforms.filterDims[1] * inChannels);\n      let WCol = ").concat(m," / inChannels % uniforms.filterDims[1];\n      let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * WRow - uniforms.pads[0];\n      let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * WCol - uniforms.pads[1];\n      let xCh = ").concat(m," % inChannels;\n      var resData = ").concat(OQ(o),"(0.0);\n      // The bounds checking is always needed since we use it to pad zero for\n      // the 'same' padding type.\n      if (xRow >= 0 && xRow < ").concat(d," && xCol >= 0 && xCol < ").concat(p,") {\n        ").concat(u,"\n        let xIndex = getIndexFromCoords4D(coord, uniforms.xShape);\n        ").concat((e=>{switch(e){case 1:return"resData = f32(x[xIndex]);";case 3:return"resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);";case 4:return"resData = vec4<f32>(x[xIndex / 4]);";default:throw new Error("innerElementSize ".concat(e," is not supported."))}})(o),"\n      }\n      return resData;"),y=e?t&&a?"\n      ".concat(g):"\n      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {\n        ".concat(g,"\n      }\n      return ").concat(OQ(o),"(0.0);"):a&&n?"\n      ".concat(g):"\n      if (row < uniforms.dimInner && col < uniforms.dimBOuter) {\n        ".concat(g,"\n      }\n      return ").concat(OQ(o),"(0.0);"),b="".concat((e=>{switch(e){case 1:return"return f32(W[row * uniforms.wShape[3] + col]);";case 4:return"return vec4<f32>(W[(row * uniforms.wShape[3] + col) / 4]);";default:throw new Error("innerElementSize ".concat(e," is not supported."))}})(c)),x=OQ(l),v=OQ(e?o:c),w=OQ(e?c:o);return"\n      ".concat(uZ(r,i,4===l,4),"\n      fn mm_readA(batch: i32, row : i32, col : i32) -> ").concat(v," {\n        ").concat(e?y:b,"\n      }\n\n      fn mm_readB(batch: i32, row : i32, col : i32) -> ").concat(w," {\n        ").concat(e?b:y,"\n      }\n\n      fn mm_write(batch: i32, row : i32, col : i32, valueIn : ").concat(x,") {\n        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)\n        {\n        var value = valueIn;\n        let outWidth = ").concat(e?"uniforms.outShape[2]":"uniforms.outShape[3]",";\n        ").concat(h,"\n        ").concat(hZ(s,r),"\n        setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n        }\n      }")}(this.isChannelsLast,this.fitAOuter,this.fitBOuter,this.fitInner,this.addBias,this.activation,this.hasPreluActivationWeights,t[0],t[1],t[2]),"\n    ").concat(e,"\n  ");return n}}class U${constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];this.variableNames=["x","W"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>,",this.workgroupSize=[4,4,8],this.outputShape=e.outShape,this.isChannelsLast="channelsLast"===e.dataFormat,this.dispatchLayout=this.isChannelsLast?{x:[2],y:[1],z:[0,3]}:{x:[3],y:[2],z:[0,1]},this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=t,this.activation=n,this.hasPreluActivationWeights=a,t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),this.shaderKey="conv2dnaive_".concat(this.activation,"_").concat(this.isChannelsLast)}getUserCode(){return"\n       ".concat(uZ(this.activation,this.hasPreluActivationWeights,!1,4),"\n       fn readInp(batch : i32, row : i32, col : i32, chan : i32) -> f32{\n         let coords = vec4<i32>(batch, row, col, chan);\n         if (coordsInBounds4D(coords, uniforms.xShape)) {\n           return  getX(batch, row, col, chan);\n         } else {\n          return 0.0;\n         }\n       }\n       fn readFilt(row : i32, col : i32, xChannel : i32, outChannel : i32) -> f32{\n         let coords = vec4<i32>(row, col, xChannel, outChannel);\n         if(coordsInBounds4D(coords, uniforms.wShape)) {\n           return getW(row, col, xChannel, outChannel);\n          } else {\n            return 0.0;\n          }\n       }\n       fn writeResult(batch : i32, row : i32, col : i32, chan : i32, valueIn : f32) {\n         let coords = ").concat(this.isChannelsLast?"vec4<i32>(batch, row, col, chan);":"vec4<i32>(batch, chan, row, col);","\n         if (coordsInBounds4D(coords, uniforms.outShape)) {\n           var value = valueIn;\n           ").concat(hZ(this.addBias,this.activation),"\n           setOutputAtCoords(coords.x, coords.y, coords.z, coords.w, value);\n         }\n       }\n       ").concat(zQ("index")," {\n         let coords = getOutputCoords();\n         let batch = coords[0];\n         let outChannel = ").concat(this.isChannelsLast?"coords[3];":"coords[1];","\n         let outRow = ").concat(this.isChannelsLast?"coords[1];":"coords[2];","\n         let outCol = ").concat(this.isChannelsLast?"coords[2];":"coords[3];","\n         var acc : f32 = 0.0;\n         for (var row = 0; row < uniforms.filterDims[0]; row = row + 1) {\n           for (var col = 0; col < uniforms.filterDims[1]; col = col + 1) {\n             let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * row - uniforms.pads[0];\n             let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * col - uniforms.pads[1];\n             for (var xChannel = 0; xChannel < ").concat(this.isChannelsLast?"uniforms.xShape[3];":"uniforms.xShape[1];"," xChannel = xChannel + 1) {\n               ").concat(this.isChannelsLast?"let v = readInp(batch, xRow, xCol, xChannel);":"let v = readInp(batch, xChannel, xRow, xCol);","\n               let f = readFilt(row, col, xChannel, outChannel);\n               acc = acc + v * f;\n             }\n           }\n         }\n         writeResult(batch, outRow, outCol, outChannel, acc);\n       }\n     ")}}class H${constructor(e,t){this.variableNames=["x"],this.uniforms="pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, outWidth : i32, itemsPerBlockRow : i32,\n       inChannels : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=ZQ(this.outputShape),this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=t,this.shaderKey="im2col_".concat(this.isChannelsLast)}getUserCode(){const e=this.isChannelsLast?1:2,t=this.isChannelsLast?2:3,n=this.isChannelsLast?"coords[1]":"coords[2]",a=this.isChannelsLast?"coords[2]":"coords[1]",s=this.isChannelsLast?"getX(batch, xRow, xCol, ch)":"getX(batch, ch, xRow, xCol)";return"\n    ".concat(zQ("index")," {\n      let coords = getCoordsFromIndex(index);\n      if(index < uniforms.size) {\n        let batch = coords[0];\n        let row = ").concat(n,";\n        let col = ").concat(a,";\n        let offsetY = (row / uniforms.outWidth) * uniforms.strides[0] - uniforms.pads[0];\n        let xRow = offsetY + uniforms.dilations[0] * (col / uniforms.itemsPerBlockRow);\n        var value = 0.0;\n        if(xRow < uniforms.xShape[").concat(e,"] && xRow >= 0) {\n          let offsetX = (row % uniforms.outWidth) * uniforms.strides[1] -\n              uniforms.pads[1];\n          let xCol = offsetX + uniforms.dilations[1] * ((col %\n              uniforms.itemsPerBlockRow) / uniforms.inChannels);\n          let ch = col % uniforms.inChannels;\n          if(xCol < uniforms.xShape[").concat(t,"] && xCol >= 0) {\n            value = ").concat(s,";\n          }\n        }\n        setOutputAtIndex(index, value);\n      }\n    }\n   ")}}function G$(e,t){const n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&1===n&&e[0]>1?[e[0],1]:null}function q$(e){let{x:t,filter:n,convInfo:a,backend:s,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:c=null}=e;const l=null!=r,u=null!=i,h="channelsLast"===a.dataFormat,d=h&&a.filterHeight===a.inHeight&&a.filterWidth===a.inWidth&&"VALID"===a.padInfo.type,p=eh().getBool("WEBGPU_USE_NAIVE_CONV2D_DEBUG");if(!p&&(d||1===a.filterHeight&&1===a.filterWidth&&1===a.dilationHeight&&1===a.dilationWidth&&1===a.strideHeight&&1===a.strideWidth&&("SAME"===a.padInfo.type||"VALID"===a.padInfo.type)))return function(e){let{x:t,filter:n,convInfo:a,backend:s,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:c=null}=e;const l="channelsLast"===a.dataFormat,u=!l,h=[];let d,p;if(l&&a.filterHeight===a.inHeight&&a.filterWidth===a.inWidth&&"VALID"===a.padInfo.type){const e=a.inHeight*a.inWidth*a.inChannels;d=IZ({inputs:{x:t},backend:s,attrs:{shape:[1,a.batchSize,e]}}),p=IZ({inputs:{x:n},backend:s,attrs:{shape:[1,e,a.outChannels]}})}else d=IZ({inputs:{x:t},backend:s,attrs:{shape:l?[a.batchSize,a.inHeight*a.inWidth,a.inChannels]:[a.batchSize,a.inChannels,a.inHeight*a.inWidth]}}),p=IZ({inputs:{x:n},backend:s,attrs:{shape:[1,a.inChannels,a.outChannels]}});if(h.push(d),h.push(p),null!=i){const e=G$(i.shape,l);null!=e&&(i=IZ({inputs:{x:i},backend:s,attrs:{shape:e}}),h.push(i))}if(null!=r){const e=G$(r.shape,l);null!=e&&(r=IZ({inputs:{x:r},backend:s,attrs:{shape:e}}),h.push(r))}const f=TZ({a:l?d:p,b:l?p:d,transposeA:u,transposeB:!1,backend:s,bias:r,activation:c,preluActivationWeights:i,leakyreluAlpha:o}),m=IZ({inputs:{x:f},backend:s,attrs:{shape:a.outShape}});h.push(f);for(const g of h)s.disposeData(g.dataId);return m}({x:t,filter:n,convInfo:a,backend:s,bias:r,activation:c,preluActivationWeights:i,leakyreluAlpha:o});const f=eh().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),m=f>-1?f:s.thresholdToIncreaseWorkgroups,g=a.batchSize*Math.ceil(a.outHeight*a.outWidth/32)*Math.ceil(a.outChannels/32);if(eh().getBool("WEBGPU_CONV_SEPARATE_IM2COL_SHADER")||g<=m)return function(e){let{x:t,filter:n,convInfo:a,backend:s,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:c=null}=e;const{filterWidth:l,filterHeight:u,inChannels:h,strideWidth:d,strideHeight:p,padInfo:f,outWidth:m,outHeight:g,dilationWidth:y,dilationHeight:b,dataFormat:x}=a,v="channelsLast"===x,w=l*u*h,k=g*m,S=v?[a.batchSize,k,w]:[a.batchSize,w,k],C=new H$(S,v),I=[{type:"int32",data:[f.top,f.left]},{type:"int32",data:[p,d]},{type:"int32",data:[b,y]},{type:"int32",data:[m]},{type:"int32",data:[h*l]},{type:"int32",data:[h]}],N=s.runWebGPUProgram(C,[t],t.dtype,I),T=[];T.push(N);const E=IZ({inputs:{x:n},backend:s,attrs:{shape:[1,w,-1]}});if(T.push(E),null!=i){const e=G$(i.shape,v);null!=e&&(i=IZ({inputs:{x:i},backend:s,attrs:{shape:e}}),T.push(i))}if(null!=r){const e=G$(r.shape,v);null!=e&&(r=IZ({inputs:{x:r},backend:s,attrs:{shape:e}}),T.push(r))}const R=TZ({a:v?N:E,b:v?E:N,transposeA:!v,transposeB:!1,backend:s,bias:r,activation:c,preluActivationWeights:i,leakyreluAlpha:o}),_=IZ({inputs:{x:R},backend:s,attrs:{shape:a.outShape}});T.push(R);for(const A of T)s.disposeData(A.dataId);return _}({x:t,filter:n,convInfo:a,backend:s,bias:r,preluActivationWeights:i,leakyreluAlpha:o,activation:c});let y;const b=[a.padInfo.top,a.padInfo.left],x=[{type:"int32",data:[a.filterHeight,a.filterWidth]},{type:"int32",data:[...b]},{type:"int32",data:[a.strideHeight,a.strideWidth]},{type:"int32",data:[a.dilationHeight,a.dilationWidth]}];if(p)y=new U$(a,l,c,u);else{const e=h?a.outHeight*a.outWidth:a.outChannels,t=h?a.outChannels:a.outHeight*a.outWidth,n=a.filterHeight*a.filterWidth*a.inChannels;x.push({type:"int32",data:[e]},{type:"int32",data:[t]},{type:"int32",data:[n]});const r=s.adapterInfo.isIntel();y=new V$(a,e,t,n,l,c,u,r)}const v=[],w=[t,n];l&&(h||1!==r.shape.length||(r=IZ({inputs:{x:r},backend:s,attrs:{shape:[r.shape[0],1,1]}}),v.push(r)),w.push(r)),u&&(h||1!==i.shape.length||(i=IZ({inputs:{x:i},backend:s,attrs:{shape:[i.shape[0],1,1]}}),v.push(i)),w.push(i)),"leakyrelu"===c&&(x.push({type:"float32",data:[o]}),y.uniforms+=" alpha : f32,");const k=s.runWebGPUProgram(y,w,t.dtype,x);for(const S of v)s.disposeData(S.dataId);return k}const K$={kernelName:Dh,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:a}=e,{x:s,filter:r}=t,{strides:i,pad:o,dataFormat:c,dilations:l,dimRoundingMode:u}=n,h=ex(c);return q$({x:s,filter:r,convInfo:Hb(s.shape,r.shape,i,l,o,u,!1,h),backend:a})}};class X${constructor(e){this.variableNames=["dy","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>,",this.workgroupSize=[64,1,1],this.size=!1,this.isVec4=!1,this.workPerThread=1,this.outputShape=e.inShape,this.isChannelsLast="channelsLast"===e.dataFormat,this.isVec4=this.isChannelsLast&&e.outChannels%4===0&&e.inChannels%4===0,this.isVec4?(this.workPerThread=2,this.outputComponent=4,this.workgroupSize=[4,4,4],this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize,[4,this.workPerThread,1])):(this.size=!0,this.workPerThread=1,this.workgroupSize=[64,1,1],this.dispatchLayout=ZQ(this.outputShape),this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize)),this.shaderKey="conv2DDerInput_".concat(this.isChannelsLast,"_").concat(this.isVec4,"_").concat(this.workPerThread)}getUserCode(){const e=this.isChannelsLast?1:2,t=this.isChannelsLast?2:3,n=this.isChannelsLast?3:1,a="\n    ".concat(zQ()," {\n      let batch = i32(globalId.z) / uniforms.outShape[1];\n      let r = i32(globalId.z) % uniforms.outShape[1];\n      let c = i32(globalId.y) * ").concat(this.workPerThread,";\n      let d1 = i32(globalId.x) * 4;\n\n      let dyCorner = vec2<i32>(r, c) - uniforms.pads;\n\n      // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n      // ? = to be determined. : = across all values in that axis.\n      var dotProd: array<vec4<f32>, ").concat(this.workPerThread,">;\n      for (var i = 0; i < ").concat(this.workPerThread,"; i++) {\n        dotProd[i] = vec4<f32>(0.0);\n      }\n      for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {\n        let dyR = f32(dyCorner.x + wR) / f32(uniforms.strides.x);\n        let wRPerm = uniforms.filterDims.x - 1 - wR;\n        if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) ||\n            fract(dyR) > 0.0) {\n          continue;\n        }\n        let idyR = i32(dyR);\n\n        for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {\n          let dyC = f32(dyCorner.y + wC) / f32(uniforms.strides.y);\n          let dyC2 = f32(dyCorner.y + 1 + wC) / f32(uniforms.strides.y);\n          let wCPerm = uniforms.filterDims.y - 1 - wC;\n          var bDyCVal = true;\n          var bDyCVal2 = true;\n          if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||\n              fract(dyC) > 0.0) {\n            bDyCVal = false;\n          }\n          if (dyC2 < 0.0 || dyC2 >= f32(uniforms.outBackprop[2]) ||\n              fract(dyC2) > 0.0) {\n            bDyCVal2 = false;\n          }\n\n          let idyC = i32(dyC);\n          let idyC2 = i32(dyC2);\n          if (bDyCVal && bDyCVal2) {\n            let d2Length = uniforms.outBackprop[3];\n            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {\n              let wValue0 = getW(wRPerm, wCPerm, d1, d2);\n              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);\n              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);\n              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);\n              var xValue =  getDy(batch, idyR, idyC, d2);\n              let tmpval = vec4<f32>(dot(xValue, wValue0),\n                                     dot(xValue, wValue1),\n                                     dot(xValue, wValue2),\n                                     dot(xValue, wValue3));\n              dotProd[0] = dotProd[0] + tmpval;\n              xValue = getDy(batch, idyR, idyC2, d2);\n              dotProd[1] = dotProd[1] + vec4<f32>(dot(xValue, wValue0),\n                                                  dot(xValue, wValue1),\n                                                  dot(xValue, wValue2),\n                                                  dot(xValue, wValue3));\n            }\n          } else if (bDyCVal) {\n            let d2Length = uniforms.outBackprop[3];\n            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {\n              let wValue0 = getW(wRPerm, wCPerm, d1, d2);\n              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);\n              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);\n              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);\n              var xValue =  getDy(batch, idyR, idyC, d2);\n              let tmpval = vec4<f32>(dot(xValue, wValue0),\n                                     dot(xValue, wValue1),\n                                     dot(xValue, wValue2),\n                                     dot(xValue, wValue3));\n              dotProd[0] = dotProd[0] + tmpval;\n            }\n          } else if (bDyCVal2) {\n            let d2Length = uniforms.outBackprop[3];\n            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {\n              let wValue0 = getW(wRPerm, wCPerm, d1, d2);\n              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);\n              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);\n              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);\n              var xValue =  getDy(batch, idyR, idyC2, d2);\n              let tmpval = vec4<f32>(dot(xValue, wValue0),\n                                     dot(xValue, wValue1),\n                                     dot(xValue, wValue2),\n                                     dot(xValue, wValue3));\n              dotProd[1] = dotProd[1] + tmpval;\n            }\n          }\n        }\n      }\n\n      for (var i = 0; i < ").concat(this.workPerThread,"; i = i + 1) {\n        let coords = vec4<i32>(batch, r, c + i, d1);\n        if (coordsInBounds4D(coords, uniforms.outShape)) {\n          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], dotProd[i]);\n        }\n      }\n    }\n    ");return this.isVec4?"\n    ".concat(a,"\n    "):"\n    ".concat(zQ("index")," {\n      if(index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords[0];\n        let d1 = coords[").concat(n,"];\n\n        let dyCorner = vec2<i32>(coords[").concat(e,"], coords[").concat(t,"]) - uniforms.pads;\n        let dyRCorner = dyCorner.x;\n        let dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {\n          let dyR = (f32(dyRCorner) + f32(wR)) / f32(uniforms.strides.x);\n          let wRPerm = uniforms.filterDims.x - 1 - wR;\n          if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) || fract(dyR) > 0.0 ||\n              wRPerm < 0) {\n            continue;\n          }\n          let idyR = i32(dyR);\n\n          for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {\n            let dyC = (f32(dyCCorner) + f32(wC)) / f32(uniforms.strides.y);\n            let wCPerm = uniforms.filterDims.y - 1 - wC;\n            if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||\n                fract(dyC) > 0.0 || wCPerm < 0) {\n              continue;\n            }\n            let idyC = i32(dyC);\n\n            for (var d2 = 0; d2 < uniforms.outBackprop[3]; d2 = d2 + 1) {\n              let xValue = ").concat(this.isChannelsLast?"getDy(batch, idyR, idyC, d2)":"getDy(batch, d2, idyR, idyC)",";\n              let wValue = getW(wRPerm, wCPerm, d1, d2);\n              dotProd = dotProd + xValue * wValue;\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n  ")}}class Y${constructor(e){this.variableNames=["x","dy"],this.uniforms="pads : vec2<i32>, strides : vec2<i32>, batchSize : i32, outHeight : i32, outWidth : i32, inHeight : i32, inWidth : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=ZQ(this.outputShape),this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast="channelsLast"===e.dataFormat,this.shaderKey="conv2DDerFilter_".concat(this.isChannelsLast)}getUserCode(){return"\n    ".concat(zQ("index")," {\n      if(index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let wR = coords[0];\n        let wC = coords[1];\n        let d1 = coords[2];\n        let d2 = coords[3];\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        for (var b = 0; b < uniforms.batchSize; b = b + 1) {\n          for (var yR = 0; yR < uniforms.outHeight; yR = yR + 1) {\n            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];\n            if (xR < 0 || xR >= uniforms.inHeight) {\n              continue;\n            }\n\n            for (var yC = 0; yC < uniforms.outWidth; yC = yC + 1) {\n              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];\n\n              if (xC < 0 || xC >= uniforms.inWidth) {\n                continue;\n              }\n\n              if (").concat(this.isChannelsLast,") {\n                let dyValue = getDy(b, yR, yC, d2);\n                let xValue = getX(b, xR, xC, d1);\n                dotProd = dotProd + xValue * dyValue;\n              } else {\n                let dyValue = getDy(b, d2, yR, yC);\n                let xValue = getX(b, d1, xR, xC);\n                dotProd = dotProd + xValue * dyValue;\n              }\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n  ")}}class Q${constructor(e){this.variableNames=["x","dy"],this.uniforms="pads : vec3<i32>, strides : vec3<i32>, batchSize : i32, outDepth : i32,\n       outHeight : i32, outWidth : i32, inDepth : i32, inHeight : i32, inWidth : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=ZQ(this.outputShape),this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3DDerFilter"}getUserCode(){return"\n    ".concat(zQ("index")," {\n      if(index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let wF = coords.x;\n        let wR = coords.y;\n        let wC = coords.z;\n        let d1 = coords.w;\n        let d2 = coords.u;\n\n        var dotProd = 0.0;\n        for (var b = 0; b < uniforms.batchSize; b++) {\n          for (var yF = 0; yF < uniforms.outDepth; yF++) {\n            let xF = wF + yF * uniforms.strides[0] - uniforms.pads[0];\n            if (xF < 0 || xF >= uniforms.inDepth) {\n              continue;\n            }\n\n            for (var yR = 0; yR < uniforms.outHeight; yR++) {\n              let xR = wR + yR * uniforms.strides[1] - uniforms.pads[1];\n              if (xR < 0 || xR >= uniforms.inHeight) {\n                continue;\n              }\n\n              for (var yC = 0; yC < uniforms.outWidth; yC++) {\n                let xC = wC + yC * uniforms.strides[2] - uniforms.pads[2];\n                if (xC < 0 || xC >= uniforms.inWidth) {\n                  continue;\n                }\n\n                let dyValue = getDy(b, yF, yR, yC, d2);\n                let xValue = getX(b, xF, xR, xC, d1);\n                dotProd += xValue * dyValue;\n              }\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n  ")}}class Z${constructor(e){this.variableNames=["dy","W"],this.uniforms="filterDims : vec3<i32>, pads : vec3<i32>, strides : vec3<i32>,\n      outDepth : i32, outHeight : i32, outWidth : i32, outChannels : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=ZQ(this.outputShape),this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3DDerInput"}getUserCode(){return"\n    ".concat(zQ("index")," {\n      if(index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords.x;\n        let d1 = coords.u;\n\n        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;\n        let dyFCorner = dyCorner.x;\n        let dyRCorner = dyCorner.y;\n        let dyCCorner = dyCorner.z;\n\n        var dotProd = 0.0;\n        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {\n          let dyF = f32(dyFCorner + wF) / f32(uniforms.strides[0]);\n          if (dyF < 0.0 || dyF >= f32(uniforms.outDepth) || fract(dyF) > 0.0) {\n            continue;\n          }\n          let idyF = i32(dyF);\n\n          let wFPerm = uniforms.filterDims[0] - 1 - wF;\n\n          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {\n            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);\n\n            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {\n              continue;\n            }\n            let idyR = i32(dyR);\n\n            let wRPerm = uniforms.filterDims[1] - 1 - wR;\n\n            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {\n              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);\n\n              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {\n                continue;\n              }\n              let idyC = i32(dyC);\n\n              let wCPerm = uniforms.filterDims[2] - 1 - wC;\n\n              for (var d2 = 0; d2 < uniforms.outChannels; d2++) {\n                let xValue = getDy(batch, idyF, idyR, idyC, d2);\n                let wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n  ")}}const J$={kernelName:Oh,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,dy:r}=t,{strides:i,pad:o,dataFormat:c,dimRoundingMode:l,filterShape:u}=a,h=ex(c),d=Hb(s.shape,u,i,1,o,l,!1,h),p=new Y$(d),f=[{type:"int32",data:[d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.batchSize]},{type:"int32",data:[d.outHeight]},{type:"int32",data:[d.outWidth]},{type:"int32",data:[d.inHeight]},{type:"int32",data:[d.inWidth]}];return n.runWebGPUProgram(p,[s,r],s.dtype,f)}};class $${constructor(e){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.inShape,bu("channelsLast"===e.dataFormat,()=>"TODO: NCHW is unimplemented"),this.isVec4=e.inChannels%4===0&&e.outChannels%4===0,this.dispatchLayout={x:[3],y:[1,2],z:[0]},this.workgroupSize=YQ(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=QQ(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4&&(this.outputComponent=4,this.variableComponents=[4,1]),this.shaderKey="conv2DDerInputMM_".concat(this.isVec4,"_").concat(this.elementsPerThread)}getUserCode(){const e=this.isVec4?fZ(this.elementsPerThread,this.workgroupSize):gZ(this.elementsPerThread,this.workgroupSize),t="\n    ".concat(function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:4;const t="\n      let outRow = row / uniforms.outShape[2];\n      let outCol = row % uniforms.outShape[2];\n\n      let WRow = col / (uniforms.filterDims[1] * uniforms.outBackprop[3]);\n      let WCol = col / uniforms.outBackprop[3] % uniforms.filterDims[1];\n      let xR = f32(outRow - uniforms.pads[0] + WRow) / f32(uniforms.strides[0]);\n      let xC = f32(outCol - uniforms.pads[1] + WCol) / f32(uniforms.strides[1]);\n      if (xR < 0.0 || xR >= f32(uniforms.outBackprop[1]) || fract(xR) > 0.0) {\n        return ".concat(OQ(e),"(0.0);\n      }\n      if (xC < 0.0 || xC >= f32(uniforms.outBackprop[2]) || fract(xC) > 0.0) {\n        return ").concat(OQ(e),"(0.0);\n      }\n      let coord = vec4<i32>(\n          batch,\n          i32(xR),\n          i32(xC),\n          col % uniforms.outBackprop[3]);\n      return x[getIndexFromCoords4D(coord, uniforms.xShape)/").concat(e,"];"),n="if (row < uniforms.dimAOuter && col < uniforms.dimInner) {\n        ".concat(t,"\n      }\n      return ").concat(OQ(e),"(0.0);");return"\n  fn mm_readA(batch: i32, row : i32, col : i32) -> ".concat(OQ(e)," {\n    ").concat(n,"\n  }\n\n  fn mm_readB(batch: i32, row : i32, col : i32) -> ").concat(OQ(e)," {\n    let coordX = uniforms.filterDims.x - 1 -\n        row / (uniforms.filterDims[1] * uniforms.outBackprop[3]);\n    let coordY = uniforms.filterDims.y - 1 -\n        (row / uniforms.outBackprop[3]) % uniforms.filterDims[1];\n    if (row < uniforms.dimInner && col < uniforms.dimBOuter &&\n        coordX >= 0 && coordY >= 0) {\n      let rowInner = row % uniforms.outBackprop[3];\n      let coord = vec4<i32>(coordX, coordY, col, rowInner);\n      ").concat((e=>{switch(e){case 1:return"return W[getIndexFromCoords4D(coord, uniforms.wShape)];";case 4:return"\n            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);\n            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);\n            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);\n            let v0 = W[getIndexFromCoords4D(coord, uniforms.wShape)];\n            let v1 = W[getIndexFromCoords4D(coord1, uniforms.wShape)];\n            let v2 = W[getIndexFromCoords4D(coord2, uniforms.wShape)];\n            let v3 = W[getIndexFromCoords4D(coord3, uniforms.wShape)];\n            return vec4<f32>(v0, v1, v2, v3);\n            ";default:throw new Error("innerElementSize ".concat(e," is not supported."))}})(e),"\n    }\n    return ").concat(OQ(e),"(0.0);\n  }\n\n  fn mm_write(batch: i32, row : i32, col : i32, valueInput : ").concat(OQ(e),") {\n    if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {\n      var value = valueInput;\n      let outCoord = vec4<i32>(\n          batch,\n          row / uniforms.outShape[2],\n          row % uniforms.outShape[2],\n          col);\n      result[getIndexFromCoords4D(outCoord, uniforms.outShape)/").concat(e,"] = value;\n    }\n  }")}(this.isVec4?4:1),"\n    ").concat(e,"\n    ");return t}}const e0={kernelName:Fh,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:s,filter:r}=t,{inputShape:i,strides:o,pad:c,dataFormat:l,dimRoundingMode:u}=a,h=ex(l),d=Hb(i,r.shape,o,1,c,u,!1,h),p=[{type:"int32",data:[d.filterHeight,d.filterWidth]},{type:"int32",data:[d.filterHeight-1-d.padInfo.top,d.filterWidth-1-d.padInfo.left]},{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.batchSize,d.outHeight,d.outWidth,d.outChannels]}];let f;if(eh().getBool("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE")||"channelsLast"!==d.dataFormat)f=new X$(d);else{f=new $$(d);const e=d.inHeight*d.inWidth,t=d.inChannels,n=d.filterHeight*d.filterWidth*d.outChannels;p.push({type:"uint32",data:[e]},{type:"uint32",data:[t]},{type:"uint32",data:[n]})}return n.runWebGPUProgram(f,[s,r],"float32",p)}};class t0{constructor(e){this.variableNames=["x","W"],this.uniforms="filterDims: vec3<i32>, pads: vec3<i32>, strides: vec3<i32>, dilations: vec3<i32>,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=ZQ(this.outputShape),this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3dnaive"}getUserCode(){return"\n    ".concat(zQ("index")," {\n      if (index < uniforms.size) {\n        let coords = getOutputCoords();\n        let batch = coords.x;\n        let d2 = coords.u;\n\n        let xFRCCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;\n        let xFCorner = xFRCCorner.x;\n        let xRCorner = xFRCCorner.y;\n        let xCCorner = xFRCCorner.z;\n\n        let inputDepthNearestVec4 = (uniforms.xShape.u / 4) * 4;\n        let inputDepthVec4Remainder = uniforms.xShape.u % 4;\n\n        var dotProd = 0.0;\n        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {\n          let xF = xFCorner + wF * uniforms.dilations[0];\n          if (xF < 0 || xF >= uniforms.xShape.y) {\n            continue;\n          }\n\n          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {\n            let xR = xRCorner + wR * uniforms.dilations[1];\n            if (xR < 0 || xR >= uniforms.xShape.z) {\n              continue;\n            }\n\n            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {\n              let xC = xCCorner + wC * uniforms.dilations[2];\n              if (xC < 0 || xC >= uniforms.xShape.w) {\n                continue;\n              }\n\n              for (var d1 = 0; d1 < inputDepthNearestVec4; d1 += 4) {\n                let xValues = vec4<f32>(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                let wValues = vec4<f32>(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (inputDepthVec4Remainder == 1) {\n                dotProd += getX(batch, xF, xR, xC, inputDepthNearestVec4) *\n                  getW(wF, wR, wC, inputDepthNearestVec4, d2);\n              } else if (inputDepthVec4Remainder == 2) {\n                let xValues = vec2<f32>(\n                  getX(batch, xF, xR, xC, inputDepthNearestVec4),\n                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1)\n                );\n                let wValues = vec2<f32>(\n                  getW(wF, wR, wC, inputDepthNearestVec4, d2),\n                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (inputDepthVec4Remainder == 3) {\n                let xValues = vec3<f32>(\n                  getX(batch, xF, xR, xC, inputDepthNearestVec4),\n                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),\n                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2)\n                );\n                let wValues = vec3<f32>(\n                  getW(wF, wR, wC, inputDepthNearestVec4, d2),\n                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2),\n                  getW(wF, wR, wC, inputDepthNearestVec4 + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }")}}const n0={kernelName:Lh,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,filter:r}=t,{strides:i,pad:o,dilations:c}=a,l=Gb(s.shape,r.shape,i,c,o),u=[l.padInfo.front,l.padInfo.top,l.padInfo.left],h=[{type:"int32",data:[l.filterDepth,l.filterHeight,l.filterWidth]},{type:"int32",data:[...u]},{type:"int32",data:[l.strideDepth,l.strideHeight,l.strideWidth]},{type:"int32",data:[l.dilationDepth,l.dilationHeight,l.dilationWidth]}],d=new t0(l),p=gm(s.dtype,r.dtype);return n.runWebGPUProgram(d,[s,r],p,h)}};const a0={kernelName:zh,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,dy:r}=t,{strides:i,pad:o,filterShape:c}=a,l=Gb(s.shape,c,i,1,o),u=new Q$(l),h=[{type:"int32",data:[l.padInfo.front,l.padInfo.top,l.padInfo.left]},{type:"int32",data:[l.strideDepth,l.strideHeight,l.strideWidth]},{type:"int32",data:[l.batchSize]},{type:"int32",data:[l.outDepth]},{type:"int32",data:[l.outHeight]},{type:"int32",data:[l.outWidth]},{type:"int32",data:[l.inDepth]},{type:"int32",data:[l.inHeight]},{type:"int32",data:[l.inWidth]}];return n.runWebGPUProgram(u,[s,r],r.dtype,h)}};const s0={kernelName:Bh,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:s,filter:r}=t,{strides:i,pad:o,inputShape:c}=a,l=Gb(c,r.shape,i,1,o),u=new Z$(l),h=[{type:"int32",data:[l.filterDepth,l.filterHeight,l.filterWidth]},{type:"int32",data:[l.filterDepth-1-l.padInfo.front,l.filterHeight-1-l.padInfo.top,l.filterWidth-1-l.padInfo.left]},{type:"int32",data:[l.strideDepth,l.strideHeight,l.strideWidth]},{type:"int32",data:[l.outDepth]},{type:"int32",data:[l.outHeight]},{type:"int32",data:[l.outWidth]},{type:"int32",data:[l.outChannels]}];return n.runWebGPUProgram(u,[s,r],s.dtype,h)}},r0=FZ({opType:iZ.COS}),i0={kernelName:jh,backendName:"webgpu",kernelFunc:r0},o0=FZ({opType:iZ.COSH}),c0={kernelName:Wh,backendName:"webgpu",kernelFunc:o0};class l0{constructor(e,t,n,a){this.variableNames=["Image","Boxes","BoxInd"],this.uniforms="extrapolationValue : f32,",this.workgroupSize=[64,1,1],this.size=!0;const[s]=t;this.outputShape=[s,n[0],n[1],e],this.dispatchLayout=ZQ(this.outputShape),this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.methodId="bilinear"===a?1:0,this.cropHeightBiggerThan1=this.outputShape[1]>1,this.cropWidthBiggerThan1=this.outputShape[2]>1,this.shaderKey="cropAndResize_".concat(this.methodId,"_").concat(this.cropHeightBiggerThan1,"_").concat(this.cropWidthBiggerThan1)}getUserCode(){const[e,t]=["f32(uniforms.imageShape[1] - 1)","f32(uniforms.imageShape[2] - 1)"],[n,a,s]=this.cropHeightBiggerThan1?["(".concat(e," / f32(uniforms.outShape[1] - 1))"),"(y2-y1) * height_ratio","y1*".concat(e," + f32(y)*(height_scale)")]:["0.0","0.0","0.5 * (y1+y2) * ".concat(e)],[r,i,o]=this.cropWidthBiggerThan1?["(".concat(t," / f32(uniforms.outShape[2] - 1))"),"(x2-x1) * width_ratio","x1*".concat(t," + f32(x)*(width_scale)")]:["0.0","0.0","0.5 * (x1+x2) * ".concat(t)];return"\n    ".concat(zQ("index")," {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let height_ratio = f32(").concat(n,");\n        let width_ratio = f32(").concat(r,");\n        let b = coords[0];\n        let y = coords[1];\n        let x = coords[2];\n        let d = coords[3];\n        // get box vals\n        let y1 = getBoxes(b, 0);\n        let x1 = getBoxes(b, 1);\n        let y2 = getBoxes(b, 2);\n        let x2 = getBoxes(b, 3);\n        // get image in batch index\n        let bInd = i32(round(getBoxInd(b)));\n        if(bInd < 0 || bInd >= uniforms.outShape[0]) {\n          return;\n        }\n        let height_scale = ").concat(a,";\n        let width_scale = ").concat(i,";\n        let in_y = ").concat(s,";\n        if( in_y < 0.0 || in_y > ").concat(e," ) {\n          setOutputAtIndex(index, uniforms.extrapolationValue);\n          return;\n        }\n        let in_x = ").concat(o,";\n        if( in_x < 0.0 || in_x > ").concat(t," ) {\n          setOutputAtIndex(index, uniforms.extrapolationValue);\n          return;\n        }\n        let sourceFracIndexCR = vec2<f32>(in_x,in_y);\n        if(").concat(this.methodId," == 1) {\n          // Compute the four integer indices.\n          let sourceFloorCR = vec2<i32>(sourceFracIndexCR);\n          let sourceCeilCR = vec2<i32>(ceil(sourceFracIndexCR));\n          let topLeft = getImage(bInd, sourceFloorCR.y, sourceFloorCR.x, d);\n          let bottomLeft = getImage(bInd, sourceCeilCR.y, sourceFloorCR.x, d);\n          let topRight = getImage(bInd, sourceFloorCR.y, sourceCeilCR.x, d);\n          let bottomRight = getImage(bInd, sourceCeilCR.y, sourceCeilCR.x, d);\n          let fracCR = sourceFracIndexCR - vec2<f32>(sourceFloorCR);\n          let top = topLeft + (topRight - topLeft) * fracCR.x;\n          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          let newValue = top + (bottom - top) * fracCR.y;\n          setOutputAtIndex(index, newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          let sourceNearestCR = vec2<i32>(floor(\n            sourceFracIndexCR + vec2<f32>(0.5,0.5)));\n          let newValue = getImage(\n            bInd, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutputAtIndex(index, newValue);\n        }\n      }\n    }\n    ")}}const u0={kernelName:Hh,backendName:"webgpu",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{image:s,boxes:r,boxInd:i}=t,{cropSize:o,method:c,extrapolationValue:l}=a,u=new l0(s.shape[3],r.shape,o,c),h=[{type:"float32",data:[l]}];return n.runWebGPUProgram(u,[s,r,i],"float32",h)}};var h0;!function(e){e.Prod="*",e.Sum="+"}(h0||(h0={}));class d0{constructor(e,t,n,a){this.variableNames=["x"],this.uniforms="index : f32,",this.size=!0,this.workgroupSize=[128,1,1],this.outputShape=t,this.dispatchLayout=ZQ(this.outputShape),this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.exclusive=n,this.reverse=a,this.op=e,this.shaderKey="cum_".concat(this.op,"_").concat(this.exclusive,"_").concat(this.reverse)}getUserCode(){const e=this.outputShape.length,t=this.op===h0.Prod?"1.0":"0.0",n=this.exclusive?t:"getX(".concat(p0(e,"coords",this.op),")"),a=this.outputShape[this.outputShape.length-1];let s="",r="";return this.exclusive?(s=this.reverse?"end != ".concat(a-1):"end != 0",r=this.reverse?"end + 1":"end - 1"):(s=this.reverse?"end + pow2 < ".concat(a):"end >= pow2",r=this.reverse?"end + pow2":"end - pow2"),"\n      ".concat(zQ("index")," {\n       if (index < uniforms.size) {\n         var coords = getCoordsFromIndex(index);\n\n         let end = ").concat(f0(e,"coords",this.op),";\n         var val = ").concat(n,";\n         let pow2 = i32(pow(2.0, uniforms.index));\n         if (").concat(s,") {\n           let idx = ").concat(r,";\n           ").concat(f0(e,"coords",this.op)," = idx;\n           val ").concat(this.op,"= getX(").concat(p0(e,"coords",this.op),");\n         }\n         setOutputAtIndex(index, val);\n       }\n      }\n    ")}}function p0(e,t,n){if(1===e)return"".concat(t);if(2===e)return"".concat(t,".x, ").concat(t,".y");if(3===e)return"".concat(t,".x, ").concat(t,".y, ").concat(t,".z");if(4===e)return"".concat(t,".x, ").concat(t,".y, ").concat(t,".z, ").concat(t,".w");throw Error("Cumulative ".concat(n," for rank ").concat(e," is not yet supported"))}function f0(e,t,n){if(1===e)return"".concat(t);if(2===e)return"".concat(t,".y");if(3===e)return"".concat(t,".z");if(4===e)return"".concat(t,".w");throw Error("Cumulative ".concat(n," for rank ").concat(e," is not yet supported"))}function m0(e,t,n,a,s,r){const i=t.shape.length,o=tv([a],i);let c=t;null!=o&&(c=MJ({inputs:{x:t},backend:n,attrs:{perm:o}}));const l=av(1,i)[0];if(l!==i-1)throw new Error("WebGPU cumprod shader expects an inner-most axis=".concat(t.shape.length-1," ")+"but got axis=".concat(a));const u=c.shape[l];let h=AZ({inputs:{x:c},backend:n});for(let d=0;d<=Math.ceil(Math.log2(u))-1;d++){const t=new d0(e,c.shape,!1,r),a=h,s=[{type:"float32",data:[d]}];h=n.runWebGPUProgram(t,[h],h.dtype,s),n.disposeData(a.dataId)}if(s){const t=new d0(e,c.shape,s,r),a=h,i=[{type:"float32",data:[0]}];h=n.runWebGPUProgram(t,[h],h.dtype,i),n.disposeData(a.dataId)}if(null!=o){const e=MJ({inputs:{x:h},backend:n,attrs:{perm:nv(o)}});return n.disposeData(h.dataId),n.disposeData(c.dataId),e}return h}const g0={kernelName:Vh,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{axis:r,exclusive:i,reverse:o}=a;return m0(h0.Prod,s,n,r,i,o)}};const y0={kernelName:Uh,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{axis:r,exclusive:i,reverse:o}=a;return m0(h0.Sum,s,n,r,i,o)}};const b0={kernelName:Gh,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,weights:r}=t,{size:i,binaryOutput:o}=a,c=1===s.shape.length,l=wu(r.shape)>0,u=r.dtype,h=c?[s.shape[0]]:[s.shape[0],s.shape[1]],d=SZ({backend:n,attrs:{shape:c?[i]:[s.shape[0],i],value:0,dtype:u}}),p=new x$(h,l,o),f=[{type:"int32",data:[i]}],m=l?[s,r]:[s];return n.runWebGPUProgram(p,m,u,f,d)}};class x0{constructor(e,t){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.uniforms="blockSize : i32,",this.outputShape=e,this.dispatchLayout=ZQ(this.outputShape),this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthToSpace_".concat(t),this.dataFormat=t}getUserCode(){return"\n      ".concat(zQ("index")," {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let b = coords[0];\n          let h = ").concat(this.getHeightCoordString(),";\n          let w = ").concat(this.getWidthCoordString(),";\n          let d = ").concat(this.getDepthCoordString(),";\n\n          let in_h = h / uniforms.blockSize;\n          let offset_h = h % uniforms.blockSize;\n          let in_w = w / uniforms.blockSize;\n          let offset_w = w % uniforms.blockSize;\n          let offset_d = (offset_h * uniforms.blockSize + offset_w) *\n            ").concat(this.getOutputDepthSize(),";\n          let in_d = d + offset_d;\n\n          let rlt = ").concat(this.getInputSamplingString(),";\n          setOutputAtIndex(index, rlt);\n        }\n      }")}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?"uniforms.outShape[3]":"uniforms.outShape[1]"}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const v0={kernelName:qh,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{blockSize:r,dataFormat:i}=a,o=s.shape[0],c=("NHWC"===i?s.shape[1]:s.shape[2])*r,l=("NHWC"===i?s.shape[2]:s.shape[3])*r,u=("NHWC"===i?s.shape[3]:s.shape[1])/(r*r),h=[{type:"int32",data:[r]}],d=new x0("NHWC"===i?[o,c,l,u]:[o,u,c,l],i);return n.runWebGPUProgram(d,[s],s.dtype,h)}};class w0{constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,r=arguments.length>5&&void 0!==arguments[5]&&arguments[5];this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>,",this.workgroupSize=[16,16,1],this.outputShape=e,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize),a&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.addBias=a,this.activation=s,this.hasPreluActivation=r,this.filterHeight=t,this.filterWidth=n,this.shaderKey="depthwiseNCHW_".concat(this.activation,"_").concat(this.filterHeight,"_").concat(this.filterWidth)}getUserCode(){const e=this.filterWidth*this.filterHeight,t=this.workgroupSize[0]*this.workgroupSize[1]*this.workgroupSize[2],n=this.workgroupSize[1]+this.filterHeight-1,a=this.workgroupSize[0]+this.filterWidth-1;return"\n      ".concat(uZ(this.activation,this.hasPreluActivation,!1,4),"\n\n      var<workgroup> mm_Asub : array<array<f32, ").concat(a,">, ").concat(n,">;\n      var<workgroup> mm_Bsub : array<array<f32, ").concat(this.filterWidth,">, ").concat(this.filterHeight,">;\n      fn readX(batch : i32, channel : i32, row : i32, col : i32) -> f32 {\n        var value = 0.0;\n        if (row >=0 && row < uniforms.inDims[0] && col >=0 && col < uniforms.inDims[1])\n        {\n          value = getX(batch, channel, row, col);\n        }\n        return value;\n      }\n\n      ").concat(zQ()," {\n        let coords = getOutputCoords();\n        let batch = coords[0];\n        let xRCCorner = vec2<i32>(coords.zw) - uniforms.pads;\n        let channelMul = uniforms.wShape[3];\n        let d1 = coords[1] / channelMul;\n        let q = coords[1] % channelMul;\n\n        let inputRowStart = xRCCorner.x;\n        let inputColStart = xRCCorner.y;\n\n        let localRow = i32(localId.y);\n        let localCol = i32(localId.x);\n\n        // Load one tile of X into local memory.\n        for (var inputRow = localRow; inputRow < ").concat(n,"; inputRow = inputRow + ").concat(this.workgroupSize[1],") {\n          for (var inputCol = localCol; inputCol < ").concat(a,"; inputCol = inputCol + ").concat(this.workgroupSize[0],") {\n            let rowOffset = inputRow - localRow;\n            let colOffset = inputCol - localCol;\n            mm_Asub[inputRow][inputCol] = readX(batch, d1, inputRowStart + rowOffset, inputColStart + colOffset);\n          }\n        }\n\n        // Load one tile of W into local memory.\n        var wIndex = i32(localIndex);\n        ").concat(e<t?"if (wIndex < ".concat(e,")"):"for(; wIndex < ".concat(e,"; wIndex = wIndex + ").concat(t,")"),"\n\n        {\n          let wRow = wIndex / ").concat(this.filterWidth,";\n          let wCol = wIndex % ").concat(this.filterWidth,";\n          mm_Bsub[wRow][wCol] = getW(wRow, wCol, d1, q);\n        }\n\n        workgroupBarrier();\n\n        var value = 0.0;\n        for (var wR = 0; wR < ").concat(this.filterHeight,"; wR = wR + 1) {\n          for (var wC = 0; wC < ").concat(this.filterWidth,"; wC = wC + 1) {\n            let xVal = mm_Asub[localRow + wR][localCol + wC];\n            let wVal = mm_Bsub[wR][wC];\n            value = fma(xVal, wVal, value);\n          }\n        }\n        ").concat(hZ(this.addBias,this.activation),"\n        if (coordsInBounds4D(coords, uniforms.outShape)) {\n          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n        }\n      }\n    ")}}class k0{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>, virtualWidth : i32,",this.workgroupSize=[64,1,1],this.workPerThread=4,this.outputComponent=4,this.outputShape=e.outShape,this.virtualWidth=Math.ceil(this.outputShape[2]/this.workPerThread)*this.workPerThread;const s=[this.outputShape[0],this.outputShape[1],this.virtualWidth,this.outputShape[3]];this.dispatchLayout=ZQ(s),this.dispatch=XQ(this.dispatchLayout,s,this.workgroupSize,[this.outputComponent*this.workPerThread,1,1]),bu("channelsLast"===e.dataFormat,()=>"TODO: NCHW is unimplemented"),t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=n,this.hasPreluActivation=a,this.shaderKey="depthwiseVec4_".concat(n,"_").concat(this.convInfo.filterHeight,"_").concat(this.convInfo.filterWidth,"_").concat(this.convInfo.strideHeight,"_").concat(this.convInfo.strideWidth,"_").concat(this.workPerThread)}getUserCode(){const e=(this.workPerThread-1)*this.convInfo.strideWidth+this.convInfo.filterWidth,t=this.convInfo.strideHeight,n=this.convInfo.strideWidth;return"\n      ".concat(uZ(this.activation,this.hasPreluActivation,!0,4),"\n      fn readX(batch : i32, row : i32, col : i32, channel : i32) -> vec4<f32> {\n        var value = vec4<f32>(0.0);\n        if (col >=0 && col < uniforms.inDims[1]) {\n          value = getX(batch, row, col, channel);\n        }\n        return value;\n      }\n\n      ").concat(zQ("index")," {\n        let width0 = uniforms.outShape[3] / ").concat(this.outputComponent,";\n        let d1 = (index % width0) * ").concat(this.outputComponent,";\n        var index1 = index / width0;\n        let width1 = uniforms.virtualWidth / ").concat(this.workPerThread,";\n        let c = (index1 % width1) * ").concat(this.workPerThread,";\n        index1 = index1 / width1;\n        let r = index1 % uniforms.outShape[1];\n        let batch = index1 / uniforms.outShape[1];\n\n        let xRCCorner = vec2<i32>(r, c) * vec2<i32>(").concat(t,", ").concat(n,") - uniforms.pads;\n\n        let xRCorner = xRCCorner.x;\n        let xCCorner = xRCCorner.y;\n        var xVals : array<vec4<f32>, ").concat(e,">;\n        var dotProd : array<vec4<f32>, ").concat(this.workPerThread,">;\n        for (var i = 0; i < ").concat(this.workPerThread,"; i++) {\n          dotProd[i] = vec4<f32>(0.0);\n        }\n\n        // Use constant instead of uniform can give better performance.\n        for (var wR = 0; wR < ").concat(this.convInfo.filterHeight,"; wR = wR + 1) {\n          let xR = xRCorner + wR;\n          if (xR >=0 && xR < uniforms.inDims[0]) {\n            for (var i = 0; i < ").concat(e,"; i++) {\n              xVals[i] = readX(batch, xR, xCCorner + i, d1);\n            }\n            for (var wC = 0; wC < ").concat(this.convInfo.filterWidth,"; wC = wC + 1) {\n              let wValue = getW(wR, wC, d1, 0);\n              for (var i = 0; i < ").concat(this.workPerThread,"; i++) {\n                dotProd[i] = fma(xVals[i * ").concat(n," + wC], wValue, dotProd[i]);\n              }\n            }\n          }\n        }\n\n        for (var i = 0; i < ").concat(this.workPerThread,"; i = i + 1) {\n          let coords = vec4<i32>(batch, r, c + i, d1);\n          if (coordsInBounds4D(coords, uniforms.outShape)) {\n            var value = dotProd[i];\n            ").concat(hZ(this.addBias,this.activation),"\n            setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n          }\n        }\n      }\n    ")}}class S0{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>, filterHeight : i32,\n      filterWidth : i32, strides : vec2<i32>, dilations : vec2<i32>,",this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=ZQ(this.outputShape),this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast="channelsLast"===e.dataFormat,t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=n,this.hasPreluActivation=a,this.shaderKey="depthwise_".concat(this.activation,"_").concat(this.isChannelsLast)}getUserCode(){const e=this.isChannelsLast?"getX(batch, xR, xC, d1);":"getX(batch, d1, xR, xC);";return"\n      ".concat(uZ(this.activation,this.hasPreluActivation,!1,4),"\n\n      ").concat(zQ("index")," {\n        if (index < uniforms.size) {\n          let coords = getOutputCoords();\n          let batch = coords[0];\n          let xRCCorner = vec2<i32>(coords.").concat(this.isChannelsLast?"yz":"zw",") * uniforms.strides - uniforms.pads;\n          let d2 = coords[").concat(this.isChannelsLast?3:1,"];\n          let channelMul = uniforms.wShape[3];\n          let d1 = d2 / channelMul;\n          let q = d2 % channelMul;\n\n          let inputRowStart = xRCCorner.x;\n          let inputColStart = xRCCorner.y;\n          let inputRowEnd = inputRowStart + uniforms.filterHeight *\n              uniforms.dilations[0];\n          let inputColEnd = inputColStart + uniforms.filterWidth *\n              uniforms.dilations[1];\n\n          // Convolve x(?, ?, d1)|x(d1, ?, ?) with w(:, :, d1, q) to get\n          // y(yR, yC, d2)|y(d2, yR, yC). ? = to be determined. : = across all\n          // values in that axis. x(?, ?, d1) and y(yR, yC, d2) is for NHWC.\n          // x(d1, ?, ?) and y(d2, yR, yC) is for NCHW.\n          var value = 0.0;\n\n          // Extract if checking out of for loop for performance.\n          if (inputRowStart >= 0 && inputColStart >= 0 &&\n            inputRowEnd < uniforms.inDims[0] &&\n                inputColEnd < uniforms.inDims[1]) {\n              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {\n                let xR = inputRowStart + wR * uniforms.dilations[0];\n\n                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {\n                  let xC = inputColStart + wC * uniforms.dilations[1];\n\n                  let xVal = ").concat(e,";\n                  let wVal = getW(wR, wC, d1, q);\n                  value = value + xVal * wVal;\n                }\n              }\n            } else {\n              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {\n                let xR = inputRowStart + wR * uniforms.dilations[0];\n\n                if (xR < 0 || xR >= uniforms.inDims[0]) {\n                  continue;\n                }\n\n                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {\n                  let xC = inputColStart + wC * uniforms.dilations[1];\n\n                  if (xC < 0 || xC >= uniforms.inDims[1]) {\n                    continue;\n                  }\n\n                  let xVal = ").concat(e,";\n                  let wVal = getW(wR, wC, d1, q);\n                  value = value + xVal * wVal;\n                }\n              }\n            }\n            ").concat(hZ(this.addBias,this.activation),"\n          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n        }\n      }\n    ")}}const C0={kernelName:Kh,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,filter:r}=t,{strides:i,pad:o,dataFormat:c,dilations:l,dimRoundingMode:u}=a,h=ex(c);let d=l;null==d&&(d=[1,1]);const p=Hb(s.shape,r.shape,i,d,o,u,!0,h),f=[{type:"int32",data:[p.padInfo.top,p.padInfo.left]},{type:"int32",data:[p.inHeight,p.inWidth]}],m="channelsLast"===p.dataFormat;let g;return!m&&p.inHeight>16&&p.inWidth>16&&1===p.strideHeight&&1===p.strideWidth&&1===p.dilationWidth&&1===p.dilationHeight&&p.inChannels===p.outChannels?g=new w0(p.outShape,p.filterHeight,p.filterWidth):m&&p.outHeight>4&&p.outWidth>4&&p.strideWidth<=2&&p.inChannels===p.outChannels&&1===p.dilationHeight&&1===p.dilationWidth&&p.inChannels%4===0?(g=new k0(p),f.push({type:"int32",data:[g.virtualWidth]})):(g=new S0(p),f.push({type:"int32",data:[p.filterHeight]},{type:"int32",data:[p.filterWidth]},{type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.dilationHeight,p.dilationWidth]})),n.runWebGPUProgram(g,[s,r],s.dtype,f)}};class I0{constructor(e){this.variableNames=["x","dy"],this.uniforms="strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>, outHeight : i32,\n      outWidth : i32, inHeight : i32, inWidth : i32, batchSize : i32, channelMul : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=ZQ(this.outputShape),this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthwise_conv2d_backprop_filter"}getUserCode(){return"\n      ".concat(zQ("index")," {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let wR = coords[0];\n        let wC = coords[1];\n        let d1 = coords[2];\n        let dm = coords[3];\n        let d2 = d1 * uniforms.channelMul + dm;\n\n        var dotProd = 0.0;\n        for (var b = 0; b < uniforms.batchSize; b++) {\n          for (var yR = 0; yR < uniforms.outHeight; yR++) {\n            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];\n\n            if (xR < 0 || xR >= uniforms.inHeight) {\n              continue;\n            }\n\n            for (var yC = 0; yC < uniforms.outWidth; yC++) {\n              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];\n\n              if (xC < 0 || xC >= uniforms.inWidth) {\n                continue;\n              }\n\n              let dyValue = getDy(b, yR, yC, d2);\n              let xValue = getX(b, xR, xC, d1);\n              dotProd += xValue * dyValue;\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n    ")}}class N0{constructor(e){this.variableNames=["dy","W"],this.uniforms="strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>,\n       outHeight : i32, outWidth : i32, channelMul : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=ZQ(this.outputShape),this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthwise_conv2d_backprop_input"}getUserCode(){return"\n      ".concat(zQ("index")," {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords[0];\n        let d1 = coords[3];\n        let dyCorner = coords.yz - uniforms.pads;\n        let dyRCorner = dyCorner.x;\n        let dyCCorner = dyCorner.y;\n\n        var dotProd = 0.0;\n        for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {\n          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);\n\n          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {\n            continue;\n          }\n\n          let idyR = i32(dyR);\n          let wRPerm = uniforms.filterDims[0] - 1 - wR;\n\n          for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {\n            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);\n\n            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {\n              continue;\n            }\n\n            let idyC = i32(dyC);\n            let wCPerm = uniforms.filterDims[1] - 1 - wC;\n\n            for (var dm = 0; dm < uniforms.channelMul; dm++) {\n              let d2 = d1 * uniforms.channelMul + dm;\n              let xValue = getDy(batch, idyR, idyC, d2);\n              let wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n    ")}}const T0={kernelName:Xh,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,dy:r}=t,{strides:i,dilations:o,pad:c,dimRoundingMode:l,filterShape:u}=a,h=Hb(s.shape,u,i,o,c,l,!0),d=new I0(h),p=[{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.filterHeight,h.filterWidth]},{type:"int32",data:[h.outHeight]},{type:"int32",data:[h.outWidth]},{type:"int32",data:[h.inHeight]},{type:"int32",data:[h.inWidth]},{type:"int32",data:[h.batchSize]},{type:"int32",data:[h.outChannels/h.inChannels]}];return n.runWebGPUProgram(d,[s,r],"float32",p)}};const E0={kernelName:Yh,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:s,filter:r}=t,{strides:i,dilations:o,pad:c,dimRoundingMode:l,inputShape:u}=a,h=Hb(u,r.shape,i,o,c,l,!0),d=new N0(h),p=[{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.filterHeight-1-h.padInfo.top,h.filterWidth-1-h.padInfo.left]},{type:"int32",data:[h.filterHeight,h.filterWidth]},{type:"int32",data:[h.outHeight]},{type:"int32",data:[h.outWidth]},{type:"int32",data:[h.outChannels/h.inChannels]}];return n.runWebGPUProgram(d,[s,r],s.dtype,p)}};class R0{constructor(e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,e],this.dispatchLayout=ZQ(this.outputShape),this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="diag"}getUserCode(){return"\n      ".concat(zQ("index")," {\n        if (index < uniforms.size) {\n          let coords = getOutputCoords();\n          let value = select(0.0, getX(coords[0]), coords[0] == coords[1]);\n          setOutputAtIndex(index, value);\n        }\n      }\n    ")}}const _0={kernelName:Qh,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t,s=[...a.shape,...a.shape],r=wu(a.shape),i=IZ({inputs:{x:a},backend:n,attrs:{shape:[r]}}),o=new R0(r),c=n.runWebGPUProgram(o,[i],i.dtype),l=IZ({inputs:{x:c},backend:n,attrs:{shape:s}});return n.disposeData(i.dataId),n.disposeData(c.dataId),l}};class A0{constructor(e){this.variableNames=["x","w"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=ZQ(this.outputShape),this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="dilation2d"}getUserCode(){return"\n       ".concat(zQ("index")," {\n         if (index < uniforms.size) {\n           let neg_infinity = -3.4e38;\n           let coords = getOutputCoords();\n           let batch = coords.x;\n           let d1 = coords.w;\n           let outTopLeftCorner = coords.yz * uniforms.strides - uniforms.pads;\n           let hBeg = outTopLeftCorner.x;\n           let wBeg = outTopLeftCorner.y;\n\n           var curVal = neg_infinity;\n           for (var h = 0; h < uniforms.filterDims[0]; h = h + 1) {\n             let hIn = hBeg + h * uniforms.dilations[0];\n\n             if (hIn >= 0 && hIn < uniforms.xShape[1]) {\n               for (var w = 0; w < uniforms.filterDims[1]; w = w + 1) {\n                 let wIn = wBeg + w * uniforms.dilations[1];\n\n                 if (wIn >= 0 && wIn < uniforms.xShape[2]) {\n                   let val = getX(batch, hIn, wIn, d1) + getW(h, w, d1);\n                   if (val > curVal) {\n                     curVal = val;\n                   }\n                 }\n               }\n             }\n           }\n\n           setOutputAtIndex(index, curVal);\n         }\n       }\n     ")}}const M0={kernelName:Zh,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,filter:r}=t,{strides:i,pad:o,dilations:c}=a,l=Wb(s.shape,r.shape,i,o,"NHWC",c),u=[l.padInfo.top,l.padInfo.left],h=[{type:"int32",data:[l.filterHeight,l.filterWidth]},{type:"int32",data:[...u]},{type:"int32",data:[l.strideHeight,l.strideWidth]},{type:"int32",data:[l.dilationHeight,l.dilationWidth]}],d=new A0(l);return n.runWebGPUProgram(d,[s,r],s.dtype,h)}};class P0{constructor(e,t){if(this.variableNames=["x","w","dy"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e.inShape,this.dispatchLayout=ZQ(e.outShape),this.dispatch=XQ(this.dispatchLayout,e.outShape,this.workgroupSize),"float32"!==t&&"int32"!==t)throw new Error("Dilation2DBackpropInput only supports float32 and int32\n          types, does not support ".concat(t," type."));this.type=t,this.shaderKey="dilation2DBackpropInput"}getUserCode(){return"\n       ".concat(zQ("index")," {\n         if (index < uniforms.dySize) {\n           let coords = getDyCoordsFromIndex(index);\n           let b = coords[0];\n           let r = coords[1];\n           let c = coords[2];\n           let d = coords[3];\n\n           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;\n           var curVal = -3.4e38;  // neg_infinity\n           var xRMax = 0;\n           var xCMax = 0;\n\n           // In the case of multiple argmax branches, we only back-propagate\n           // along the last branch, i.e., the one with largest value of\n           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling\n           // backward routines.\n           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {\n             let xR = dyCorner.x + wR * uniforms.dilations[0];\n\n             if (xR >= 0 && xR < uniforms.xShape[1]) {\n               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {\n                 let xC = dyCorner.y + wC * uniforms.dilations[1];\n\n                 if (xC >= 0 && xC < uniforms.xShape[2]) {\n                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);\n                   if (val > curVal) {\n                     curVal = val;\n                     xRMax = xR;\n                     xCMax = xC;\n                   }\n                 }\n               }\n             }\n           }\n\n           let flatIndexIn = d + uniforms.xShape[3] *\n               (xCMax + uniforms.xShape[2] * (xRMax + uniforms.xShape[1] * b));\n           let value = getDy(b, r, c, d);\n           ").concat(MQ("&result[flatIndexIn]","value",this.type),"\n         }\n       }\n     ")}}class D0{constructor(e,t,n){if(this.variableNames=["x","w","dy"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e.filterShape,this.dispatchLayout=ZQ(e.outShape),this.dispatch=XQ(this.dispatchLayout,e.outShape,this.workgroupSize),"float32"!==n&&"int32"!==n)throw new Error("Dilation2DBackpropFilter only supports float32 and int32\n          types, does not support ".concat(n," type."));this.type=n,this.shaderKey="dilation2DBackpropFilter"}getUserCode(){return"\n       ".concat(zQ("index")," {\n         if (index < uniforms.dySize) {\n           let coords = getDyCoordsFromIndex(index);\n           let b = coords[0];\n           let r = coords[1];\n           let c = coords[2];\n           let d = coords[3];\n\n           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;\n           var curVal = -3.4e38;  // neg_infinity\n           var wRMax = 0;\n           var wCMax = 0;\n\n           // In the case of multiple argmax branches, we only back-propagate\n           // along the last branch, i.e., the one with largest value of\n           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling\n           // backward routines.\n           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {\n             let xR = dyCorner.x + wR * uniforms.dilations[0];\n\n             if (xR >= 0 && xR < uniforms.xShape[1]) {\n               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {\n                 let xC = dyCorner.y + wC * uniforms.dilations[1];\n\n                 if (xC >= 0 && xC < uniforms.xShape[2]) {\n                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);\n                   if (val > curVal) {\n                     curVal = val;\n                     wRMax = wR;\n                     wCMax = wC;\n                   }\n                 }\n               }\n             }\n           }\n\n           let flatIndexIn = d + uniforms.wShape[2] * (wCMax + wRMax * uniforms.wShape[1]);\n           let value = getDy(b, r, c, d);\n           ").concat(MQ("&result[flatIndexIn]","value",this.type),"\n         }\n       }\n     ")}}const O0={kernelName:$h,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,filter:r,dy:i}=t,{strides:o,pad:c,dilations:l}=a,u=Wb(s.shape,r.shape,o,c,"NHWC",l),h=r.dtype,d=new D0(u,r.shape,h),p=[{type:"int32",data:[u.filterHeight,u.filterWidth]},{type:"int32",data:[u.padInfo.top,u.padInfo.left]},{type:"int32",data:[u.strideHeight,u.strideWidth]},{type:"int32",data:[u.dilationHeight,u.dilationWidth]},{type:"int32",data:[wu(u.outShape)]}],f=SZ({backend:n,attrs:{shape:r.shape,value:0,dtype:h}});return n.runWebGPUProgram(d,[s,r,i],h,p,f)}};const F0={kernelName:Jh,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,filter:r,dy:i}=t,{strides:o,pad:c,dilations:l}=a,u=Wb(s.shape,r.shape,o,c,"NHWC",l),h=s.dtype,d=new P0(u,h),p=[{type:"int32",data:[u.filterHeight,u.filterWidth]},{type:"int32",data:[u.padInfo.top,u.padInfo.left]},{type:"int32",data:[u.strideHeight,u.strideWidth]},{type:"int32",data:[u.dilationHeight,u.dilationWidth]},{type:"int32",data:[wu(u.outShape)]}],f=SZ({backend:n,attrs:{shape:u.inShape,value:0,dtype:h}});return n.runWebGPUProgram(d,[s,r,i],h,p,f)}};class L0{constructor(e,t,n){this.variableNames=["Image"],this.uniforms="alpha: f32,",this.workgroupSize=[64,1,1],this.pixelsOpType=PQ.DRAW,this.size=!0,this.outputShape=e,this.dispatchLayout=ZQ(this.outputShape),this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.type=t,this.textureFormat=n,this.shaderKey="draw_".concat(t,"_").concat(n)}getUserCode(){let e;const t="float32"===this.type?"value":"value / 255.0";e="\n      if (uniforms.numChannels == 1) {\n        rgba[0] = ".concat(t,";\n        rgba[1] = ").concat(t,";\n        rgba[2] = ").concat(t,";\n      } else {\n        rgba[d] = ").concat(t,";\n      }");return"\n       @group(0) @binding(0) var outImage : texture_storage_2d<".concat(this.textureFormat,", write>;\n       ").concat(zQ("index")," {\n         if (index < uniforms.size) {\n           var rgba = vec4<f32>(0.0, 0.0, 0.0, uniforms.alpha);\n           for (var d = 0; d < uniforms.numChannels; d = d + 1) {\n             let value = f32(inBuf[index * uniforms.numChannels + d]);\n             ").concat(e,"\n           }\n           rgba.x = rgba.x * rgba.w;\n           rgba.y = rgba.y * rgba.w;\n           rgba.z = rgba.z * rgba.w;\n           let coords = getCoordsFromIndex(index);\n           textureStore(outImage, vec2<i32>(coords.yx), rgba);\n         }\n       }\n      ")}}const z0={kernelName:ed,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{image:s}=t,{canvas:r,options:i}=a,[o,c]=s.shape.slice(0,2),{imageOptions:l}=i||{},u=(null===l||void 0===l?void 0:l.alpha)||1,h=n.device.features.has("bgra8unorm-storage")?"bgra8unorm":"rgba8unorm",d=[o,c],p=new L0(d,s.dtype,h);r.width=c,r.height=o;const f="webgpu";let m,g=r.getContext(f);g||(m=new OffscreenCanvas(c,o),g=m.getContext(f));const y=3===s.shape.length?s.shape[2]:1;g.configure({device:n.device,format:h,usage:GPUTextureUsage.STORAGE_BINDING,alphaMode:"premultiplied"});const b="int32",x=n.makeTensorInfo(d,b),v=n.tensorMap.get(x.dataId);v.resource=g.getCurrentTexture(),v.external=!0;const w=[{type:"uint32",data:[y]},{type:"float32",data:[u]}];if(n.runWebGPUProgram(p,[s],b,w,x),m){const e=r.getContext("2d");if(!e)throw new Error("Please make sure this canvas has only been used for 2d or webgpu context!");e.drawImage(m,0,0)}return n.disposeData(x.dataId),s}},B0=LZ({opType:sZ.MUL,cpuKernelImpl:aJ,supportsComplex:!0}),j0={kernelName:Qd,backendName:"webgpu",kernelFunc:B0};function W0(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{axis:r,keepDims:i}=a;return FJ(s,r,i,"sum",n)}const V0={kernelName:Lp,backendName:"webgpu",kernelFunc:W0};const U0={kernelName:nd,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{equation:s}=a,r=t,{allDims:i,summedDims:o,idDims:c}=DC(s,r.length);FC(i.length,c,r);const{path:l,steps:u}=LC(o,c),h=u.length;let d=null,p=i.length;const f=[];for(let m=0;m<h;++m){for(const e of u[m]){const{permutationIndices:t,expandDims:a}=OC(p,c[e]);let s;zC(t)?s=r[e]:(s=MJ({inputs:{x:r[e]},backend:n,attrs:{perm:t}}),f.push(s));const i=s.shape.slice();for(let e=0;e<a.length;++e)i.splice(a[e],0,1);Su(s.shape,i)||(s=IZ({inputs:{x:s},backend:n,attrs:{shape:i}}),f.push(s)),null===d?d=s:(d=B0({inputs:{a:s,b:d},backend:n}),f.push(d))}m<h-1&&(l[m]>=0&&(d=W0({inputs:{x:d},backend:n,attrs:{axis:l[m]-(i.length-p),keepDims:!1}}),f.push(d)),p--)}for(const m of f)m!==d&&n.disposeData(m.dataId);return d}},H0=FZ({opType:iZ.ELU}),G0={kernelName:ad,backendName:"webgpu",kernelFunc:H0},q0={kernelName:sd,backendName:"webgpu",kernelFunc:e=>{const{inputs:t,backend:n}=e,{dy:a,y:s}=t,r=new _Z(sZ.ELU_DER,a.shape,s.shape);return n.runWebGPUProgram(r,[a,s],a.dtype)}},K0=LZ({opType:sZ.EQUAL,dtype:"bool",cpuKernelImpl:VZ}),X0={kernelName:id,backendName:"webgpu",kernelFunc:K0},Y0=FZ({opType:iZ.ERF}),Q0={kernelName:rd,backendName:"webgpu",kernelFunc:Y0},Z0=FZ({opType:iZ.EXP,cpuKernelImpl:UZ,dtype:"float32"}),J0={kernelName:od,backendName:"webgpu",kernelFunc:Z0};function $0(e){const{inputs:t,attrs:n,backend:a}=e,{dim:s}=n,{input:r}=t,i=r.shape.length,o=r.shape.slice();let c=s;return s<0&&(bu(-(i+1)<=s,()=>"Axis must be in the interval [".concat(-(i+1),", ").concat(i,"]")),c=i+s+1),o.splice(c,0,1),IZ({inputs:{x:r},backend:a,attrs:{shape:o}})}const e1={kernelName:cd,backendName:"webgpu",kernelFunc:$0},t1=FZ({opType:iZ.EXPM1,cpuKernelImpl:HZ}),n1={kernelName:ld,backendName:"webgpu",kernelFunc:t1};class a1{constructor(e,t){this.variableNames=["real","imag"],this.outputShape=[],this.uniforms="exponentMultiplier : f32, denominator: f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=ZQ(this.outputShape),this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.component=e,this.shaderKey="fft_".concat(e)}getUserCode(){const e="real"===this.component?"return real * expR - imag * expI;":"return real * expI + imag * expR;";return"\n    fn unaryOpComplex(real: f32, expR: f32, imag: f32, expI: f32) -> f32 {\n      ".concat(e,"\n    }\n\n    fn mulMatDFT(batch: i32, index: i32) -> f32 {\n      let indexRatio = f32(index) / f32(uniforms.realShape[1]);\n      let exponentMultiplierTimesIndexRatio =\n          uniforms.exponentMultiplier * indexRatio;\n\n      var result = 0.0;\n\n      for (var i = 0; i < uniforms.realShape[1]; i = i + 1) {\n        // x = (-2|2 * PI / N) * index * i;\n        let x = exponentMultiplierTimesIndexRatio * f32(i);\n        let expR = cos(x);\n        let expI = sin(x);\n        let real = getReal(batch, i);\n        let imag = getImag(batch, i);\n\n        result = result +\n            unaryOpComplex(real, expR, imag, expI) / uniforms.denominator;\n      }\n\n      return result;\n    }\n\n    ").concat(zQ("index")," {\n      if (index < uniforms.size) {\n        let coords = getOutputCoords();\n        setOutputAtIndex(index, mulMatDFT(coords[0], coords[1]));\n      }\n    }\n  ")}}function s1(e,t,n){const a=n.tensorMap.get(e.dataId),s=wu(e.shape),r=e.shape[e.shape.length-1],i=[],o=IZ({inputs:{x:e},backend:n,attrs:{shape:[s/r,r]}});i.push(o);const c=o.shape,l=new a1("real",c),u=new a1("imag",c),h=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:c},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:c}],d=[{type:"float32",data:[t?2*Math.PI:-2*Math.PI]},{type:"float32",data:[t?c[1]:1]}],p=n.runWebGPUProgram(l,h,"float32",d);i.push(p);const f=n.runWebGPUProgram(u,h,"float32",d);i.push(f);const m=PZ({inputs:{real:p,imag:f},backend:n});i.push(m);const g=IZ({inputs:{x:m},backend:n,attrs:{shape:e.shape}});return i.forEach(e=>n.disposeData(e.dataId)),g}const r1={kernelName:ud,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:a}=t;return s1(a,!1,n)}};class i1{constructor(e){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=ZQ(this.outputShape),this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="flipLeftRight"}getUserCode(){return"\n      ".concat(zQ("index")," {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let coordX = uniforms.xShape[2] - coords[2] - 1;\n          let outputValue = getX(coords[0], coords[1], coordX, coords[3]);\n          setOutputAtIndex(index, outputValue);\n        }\n      }\n    ")}}const o1={kernelName:dd,backendName:"webgpu",kernelFunc:e=>{let{inputs:t,backend:n}=e;const{image:a}=t,s=n,r=new i1(a.shape);return s.runWebGPUProgram(r,[a],a.dtype)}},c1=FZ({opType:iZ.FLOOR,cpuKernelImpl:GZ}),l1={kernelName:pd,backendName:"webgpu",kernelFunc:c1},u1=LZ({opType:sZ.FLOOR_DIV,cpuKernelImpl:qZ,dtype:"int32"}),h1={kernelName:fd,backendName:"webgpu",kernelFunc:u1};class d1{constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];this.pixelsOpType=PQ.FROM_PIXELS,this.outputShape=[0],this.variableNames=[],this.workgroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout=ZQ(this.outputShape),this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize,[t,1,1]),this.importVideo=n,this.shaderKey="fromPixels_".concat(this.importVideo)}getUserCode(){const e=this.importVideo?"textureLoad(src, vec2<i32>(coords.yx));":"textureLoad(src, vec2<i32>(coords.yx), 0)",t=this.importVideo?"texture_external":"texture_2d<f32>";return"\n      @binding(1) @group(0) var src: ".concat(t,";\n      ").concat(zQ("index")," {\n        let flatIndex = index * uniforms.numChannels;\n        if (flatIndex < uniforms.size) {\n          let coords = getCoordsFromIndex(flatIndex);\n          let values = ").concat(e,";\n          for (var i = 0; i < uniforms.numChannels; i = i + 1) {\n            result[flatIndex + i] = i32(floor(255.0 * values[i]));\n          }\n        }\n      }\n  ")}}const p1={kernelName:df,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e;let{pixels:s}=t;const{numChannels:r}=a;if(null==s)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");const i="undefined"!==typeof HTMLVideoElement&&s instanceof HTMLVideoElement,o="undefined"!==typeof HTMLImageElement&&s instanceof HTMLImageElement,c="undefined"!==typeof HTMLCanvasElement&&s instanceof HTMLCanvasElement||"undefined"!==typeof OffscreenCanvas&&s instanceof OffscreenCanvas,l="undefined"!==typeof ImageBitmap&&s instanceof ImageBitmap,[u,h]=i?[s.videoWidth,s.videoHeight]:[s.width,s.height],d=[h,u,r],p=eh().getBool("WEBGPU_IMPORT_EXTERNAL_TEXTURE")&&i,f=i||o;if(l||c||f){let e;if(p)e=n.device.importExternalTexture({source:s});else{if(f){const e=eh().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");null!=f1&&e===m1||(m1=e,f1=document.createElement("canvas").getContext("2d",{willReadFrequently:m1})),f1.canvas.width=u,f1.canvas.height=h,f1.drawImage(s,0,0,u,h),s=f1.canvas}const t=GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,a="rgba8unorm",r=n.textureManager.acquireTexture(d[1],d[0],a,t);n.queue.copyExternalImageToTexture({source:s},{texture:r},[d[1],d[0]]),e=r}const t=wu(d),a=ju(d),i=new d1(d,r,p),o=[{type:"uint32",data:[t]},{type:"uint32",data:[r]},{type:"uint32",data:[...a]}],c=n.makeTensorInfo([h,u],"int32");n.tensorMap.get(c.dataId).resource=e;const l=n.runWebGPUProgram(i,[c],"int32",o);return n.disposeData(c.dataId),l}const m=s.data;let g=m;if(null!=r&&4!==r){g=new Uint8Array(s.width*s.height*r);const e=m.length;let t=0;for(let n=0;n<e;n++)n%4<r&&(g[t++]=m[n])}const y=n.makeTensorInfo(d,"int32",new Int32Array(g));return n.uploadToGPU(y.dataId),y}};let f1,m1=eh().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");class g1{constructor(e,t,n,a,s){this.uniforms="varianceEpsilon : f32,",this.workgroupSize=[128,1,1],this.size=!0,this.variableNames=["x","mean","variance"],_y(e,t),_y(e,n),this.outputShape=e,this.dispatchLayout=ZQ(this.outputShape),this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize),null!=a&&(_y(e,a),this.variableNames.push("offset")),null!=s&&(_y(e,s),this.variableNames.push("scale")),this.offsetShape=a,this.scaleShape=s,this.shaderKey="batchNorm"}getUserCode(){let e="0.0";null!=this.offsetShape&&(e="getOffsetByOutputIndex(index)");let t="1.0";null!=this.scaleShape&&(t="getScaleByOutputIndex(index)");return"\n      ".concat(zQ("index")," {\n        if (index < uniforms.size)\n        {\n          let xValue = getXByOutputIndex(index);\n          let meanValue = getMeanByOutputIndex(index);\n          let varianValue = getVarianceByOutputIndex(index);\n          let offsetValue = ").concat(e,";\n          let scaleValue = ").concat(t,";\n          let inv = scaleValue * inverseSqrt(varianValue + f32(uniforms.varianceEpsilon));\n          setOutputAtIndex(index,dot(vec3<f32>(xValue, -meanValue, offsetValue), vec3<f32>(inv, inv, 1.0)));\n        }\n      }\n  ")}}const y1={kernelName:md,backendName:"webgpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e;const{x:s,scale:r,offset:i,mean:o,variance:c}=t,{varianceEpsilon:l}=n,u=a,h=[s,o,c];let d=null;null!=i&&(d=i.shape,h.push(i));let p=null;null!=r&&(p=r.shape,h.push(r));const f=new g1(s.shape,o.shape,c.shape,d,p),m=[{type:"float32",data:[l]}];return u.runWebGPUProgram(f,h,s.dtype,m)}};const b1={kernelName:mf,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,filter:r,bias:i,preluActivationWeights:o}=t,{strides:c,pad:l,dataFormat:u,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=a,m=ex(u);return q$({x:s,filter:r,convInfo:Hb(s.shape,r.shape,c,h,l,d,!1,m),backend:n,bias:i,preluActivationWeights:o,leakyreluAlpha:f,activation:p})}};const x1={kernelName:gf,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,filter:r,bias:i,preluActivationWeights:o}=t,{strides:c,pad:l,dilations:u,dimRoundingMode:h,activation:d,leakyreluAlpha:p}=a;let f=u;null==f&&(f=[1,1]),bu(Jb(c,f),()=>"Error in depthwiseConv2d: Either strides or dilations must be "+"1. Got strides ".concat(c," and dilations '").concat(f,"'"));const m=Hb(s.shape,r.shape,c,f,l,h,!0),g=[s,r],y=null!=i,b=null!=o;y&&g.push(i),b&&g.push(o);const x=[{type:"int32",data:[m.padInfo.top,m.padInfo.left]},{type:"int32",data:[m.inHeight,m.inWidth]}];let v;return m.outHeight>4&&m.outWidth>4&&m.strideWidth<=2&&m.inChannels===m.outChannels&&1===m.dilationHeight&&1===m.dilationWidth&&m.inChannels%4===0?(v=new k0(m,y,d,b),x.push({type:"int32",data:[v.virtualWidth]})):(v=new S0(m,y,d,b),x.push({type:"int32",data:[m.filterHeight]},{type:"int32",data:[m.filterWidth]},{type:"int32",data:[m.strideHeight,m.strideWidth]},{type:"int32",data:[m.dilationHeight,m.dilationWidth]})),"leakyrelu"===d&&(x.push({type:"float32",data:[p]}),v.uniforms+=" alpha : f32,"),n.runWebGPUProgram(v,g,"float32",x)}};class v1{constructor(e,t){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=ZQ(this.outputShape),this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="gathernd_".concat(e),this.sliceDim=e,this.uniforms="sliceDim : i32, strides : ".concat(FQ(e),",")}getUserCode(){let e;e=this.sliceDim>1?"uniforms.strides[j]":"uniforms.strides";return"\n      ".concat(zQ("index")," {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          var flattenIndex = 0;\n          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {\n            let indexTemp = i32(round(getIndices(coords[0], j)));\n            let strideNum = ").concat(e,";\n            flattenIndex = flattenIndex + indexTemp * strideNum;\n          }\n\n          setOutputAtIndex(index, getA(flattenIndex, coords[1]));\n        }\n      }\n      ")}}const w1={kernelName:yd,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:a,indices:s}=t,r=s.shape,i=r[r.length-1],o=wu(a.shape),[c,l,u,h]=pC(a,s),d=IZ({inputs:{x:s},backend:n,attrs:{shape:[l,i]}}),p=IZ({inputs:{x:a},backend:n,attrs:{shape:[wu(a.shape)/u,u]}});if(n.shouldExecuteOnCPU([a,s])||"string"===a.dtype){const e=n.readSync(s.dataId),t=n.bufferSync(a),r=KZ(e,t,a.dtype,l,i,u,h,a.shape,o);return n.makeTensorInfo(c,a.dtype,r.values)}const f=new v1(i,[l,u]),m=[{type:"int32",data:[i]},{type:"int32",data:h}],g=n.runWebGPUProgram(f,[p,d],p.dtype,m),y=IZ({inputs:{x:g},backend:n,attrs:{shape:c}});return n.disposeData(d.dataId),n.disposeData(p.dataId),n.disposeData(g.dataId),y}};class k1{constructor(e,t){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.slice(),this.aShape=e,this.outputShape=t,this.dispatchLayout=ZQ(this.outputShape),this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="gather"}getUserCode(){const e=function(e){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let a=0;a<e.length;a++)2===a?n.push("indexZ"):n.push("".concat(t[a]));return n.join()}(this.aShape);return"\n      ".concat(zQ("index")," {\n        if (index < uniforms.size) {\n          let resRC = getCoordsFromIndex(index);\n          let indexZ = i32(getIndices(resRC.x, resRC.z));\n          let inBounds = select(0.0, 1.0, indexZ >= 0 && indexZ < uniforms.aShape[2]);\n          setOutputAtIndex(index, inBounds * getA(").concat(e,"));\n        }\n      }\n    ")}}function S1(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,indices:r}=t,{axis:i,batchDims:o}=a,c=tI(s,r,Ru(i,s.shape)[0],o),l=wu(r.shape),u=[],h=IZ({inputs:{x:s},backend:n,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),d=IZ({inputs:{x:r},backend:n,attrs:{shape:[c.batchSize,l/c.batchSize]}});u.push(h),u.push(d);const p=[c.batchSize,c.outerSize,l/c.batchSize,c.sliceSize];if(n.shouldExecuteOnCPU([s,r])){const e=n.tensorMap.get(d.dataId).values,t=ny(d.shape,d.dtype,e),a=n.tensorMap.get(h.dataId).values,s=ny(h.shape,h.dtype,a),r=XZ(s,t,p);return u.forEach(e=>n.disposeData(e.dataId)),n.makeTensorInfo(c.outputShape,r.dtype,r.values)}const f=new k1(h.shape,p),m=n.runWebGPUProgram(f,[h,d],h.dtype);u.push(m);const g=IZ({inputs:{x:m},backend:n,attrs:{shape:c.outputShape}});return u.forEach(e=>n.disposeData(e.dataId)),g}const C1={kernelName:gd,backendName:"webgpu",kernelFunc:S1},I1=LZ({opType:sZ.GREATER,cpuKernelImpl:QZ,dtype:"bool"}),N1={kernelName:bd,backendName:"webgpu",kernelFunc:I1},T1=LZ({opType:sZ.GREATER_EQUAL,dtype:"bool",cpuKernelImpl:YZ}),E1={kernelName:xd,backendName:"webgpu",kernelFunc:T1};const R1={kernelName:wd,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:a}=t;return s1(a,!0,n)}},_1=FZ({opType:iZ.IS_FINITE,dtype:"bool"}),A1={kernelName:Sd,backendName:"webgpu",kernelFunc:_1},M1=FZ({opType:iZ.IS_INF,dtype:"bool"}),P1={kernelName:Cd,backendName:"webgpu",kernelFunc:M1},D1=FZ({opType:iZ.IS_NAN,dtype:"bool"}),O1={kernelName:Id,backendName:"webgpu",kernelFunc:D1};const F1={kernelName:Nd,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{alpha:r}=a,i=[{type:"float32",data:[r]}],o=new OZ(s.shape,iZ.LEAKYRELU,"alpha : f32,");return n.runWebGPUProgram(o,[s],"float32",i)}},L1=LZ({opType:sZ.LESS,dtype:"bool",cpuKernelImpl:JZ}),z1={kernelName:Td,backendName:"webgpu",kernelFunc:L1},B1=LZ({opType:sZ.LESS_EQUAL,dtype:"bool",cpuKernelImpl:ZZ}),j1={kernelName:Ed,backendName:"webgpu",kernelFunc:B1};class W1{constructor(e){this.variableNames=[],this.outputShape=[],this.uniforms="start : f32, step : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e],this.dispatchLayout=ZQ(this.outputShape),this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="linSpace"}getUserCode(){return"\n      ".concat(zQ("index")," {\n        if (index < uniforms.size) {\n          setOutputAtIndex(index, uniforms.start + f32(index) * uniforms.step);\n        }\n      }\n    ")}}const V1={kernelName:Rd,backendName:"webgpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:a,stop:s,num:r}=n,i=(s-a)/(r-1),o=new W1(r),c=[{type:"float32",data:[a]},{type:"float32",data:[i]}];return t.runWebGPUProgram(o,[],"float32",c)}},U1=FZ({opType:iZ.LOG,cpuKernelImpl:$Z}),H1={kernelName:_d,backendName:"webgpu",kernelFunc:U1},G1=FZ({opType:iZ.LOG1P}),q1={kernelName:Ad,backendName:"webgpu",kernelFunc:G1},K1=LZ({opType:sZ.LOGICAL_AND,dtype:"bool"}),X1={kernelName:Md,backendName:"webgpu",kernelFunc:K1},Y1=FZ({opType:iZ.LOGICAL_NOT}),Q1={kernelName:Pd,backendName:"webgpu",kernelFunc:Y1},Z1=LZ({opType:sZ.LOGICAL_OR}),J1={kernelName:Dd,backendName:"webgpu",kernelFunc:Z1},$1="\n  var powValue = 0.0;\n  let basis = uniforms.bias + uniforms.alpha * sum;\n  if (uniforms.beta == 0.5) {\n    powValue = inverseSqrt(basis);\n  } else if (uniforms.beta == 1.0) {\n    powValue = 1.0 / basis;\n  } else {\n    powValue = exp(log(basis) * (-uniforms.beta));\n  }\n";class e2{constructor(e){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=ZQ(this.outputShape),this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn"}getUserCode(){return"\n    ".concat(zQ("index")," {\n      if (index < uniforms.size) {\n        let coords = getOutputCoords();\n        let b = coords[0];\n        let r = coords[1];\n        let c = coords[2];\n        let d = coords[3];\n\n        let x = getX(b, r, c, d);\n        var sum = 0.0;\n        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {\n          let idx = d + i;\n          if (idx >= 0 && idx < uniforms.xShape[3]) {\n            let z = getX(b, r, c, idx);\n            sum = sum + z * z;\n          }\n        }\n        ").concat($1,"\n\n        setOutputAtIndex(index, x * powValue);\n      }\n    }\n  ")}}class t2{constructor(e,t){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[256,1,1],this.maxAllowRadius=16,bu(t<=this.maxAllowRadius,()=>"Radius must be less than or equal to ".concat(this.maxAllowRadius,", current radius is ").concat(t)),this.outputShape=e,this.elementsPerWorkgroup=this.workgroupSize[0]-2*this.maxAllowRadius,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=XQ(this.dispatchLayout,this.outputShape,[this.elementsPerWorkgroup,this.workgroupSize[1],this.workgroupSize[2]]),this.shaderKey="lrn_shared"}getUserCode(){return"\n    var <workgroup>lrnSub: array<f32, ".concat(this.workgroupSize[0],">;\n    const elementsPerWorkgroup = ").concat(this.elementsPerWorkgroup,";\n    const maxAllowRadius = ").concat(this.maxAllowRadius,";\n\n    ").concat(zQ()," {\n      let localDepth = i32(localId.x);\n      let workgroupDepth = i32(workgroupId.x) * elementsPerWorkgroup;\n      let xDepth = workgroupDepth + localDepth - maxAllowRadius;\n      let b = i32(globalId.z) / uniforms.xShape[1];\n      let r = i32(globalId.z) - b * uniforms.xShape[1];\n      let c = i32(globalId.y);\n      let d = workgroupDepth + localDepth;\n\n      var x = 0.0;\n      if (xDepth >= 0 && xDepth < uniforms.xShape[3]) {\n        x = getX(b, r, c, xDepth);\n      }\n      lrnSub[localDepth] = x;\n      workgroupBarrier();\n\n      if (localDepth < elementsPerWorkgroup && d < uniforms.outShape[3]) {\n        var sum = 0.0;\n        let index = localDepth + maxAllowRadius;\n        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {\n          let z = lrnSub[index + i];\n          sum = sum + z * z;\n        }\n        ").concat($1,"\n\n        setOutputAtCoords(b, r, c, d, lrnSub[index] * powValue);\n      }\n    } ")}}const n2={kernelName:Od,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{depthRadius:r,bias:i,alpha:o,beta:c}=a;let l;l=r>16?new e2(s.shape):new t2(s.shape,r);const u=[{type:"int32",data:[r]},{type:"float32",data:[i]},{type:"float32",data:[o]},{type:"float32",data:[c]}];return n.runWebGPUProgram(l,[s],s.dtype,u)}};class a2{constructor(e){this.outputShape=[],this.variableNames=["inputImage","outputImage","dy"],this.uniforms="depthRadius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=ZQ(this.outputShape),this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn_grad"}getUserCode(){return"\n    ".concat(zQ("index")," {\n      if (index < uniforms.size) {\n        let coords = getOutputCoords();\n        let b = coords[0];\n        let r = coords[1];\n        let c = coords[2];\n\n        let MIN_DEPTH_BEGIN = 0;\n        let MAX_DEPTH_END = uniforms.outShape[3];\n        var result = 0.0;\n        for (var d = MIN_DEPTH_BEGIN; d < MAX_DEPTH_END; d++) {\n          let depthBegin = max(MIN_DEPTH_BEGIN, d - uniforms.depthRadius);\n          let depthEnd = min(MAX_DEPTH_END, d + uniforms.depthRadius + 1);\n\n          var norm = 0.0;\n          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {\n            if (k < depthBegin) {\n              continue;\n            } else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            } else {\n              break;\n            }\n          }\n\n          norm = uniforms.alpha * norm + uniforms.bias;\n\n          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {\n            if (k < depthBegin) {\n              continue;\n            } else if (k >= depthBegin && k < depthEnd) {\n              var dyi = -2.0 * uniforms.alpha * uniforms.beta\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d) / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * uniforms.beta);\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            } else {\n              break;\n            }\n          }\n        }\n\n        setOutputAtIndex(index, result);\n      }\n    }\n  ")}}const s2={kernelName:Fd,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,y:r,dy:i}=t,{depthRadius:o,bias:c,alpha:l,beta:u}=a,h=new a2(s.shape),d=[{type:"int32",data:[o]},{type:"float32",data:[c]},{type:"float32",data:[l]},{type:"float32",data:[u]}];return n.runWebGPUProgram(h,[s,r,i],s.dtype,d)}},r2=LZ({opType:sZ.MAX,cpuKernelImpl:tJ}),i2={kernelName:zd,backendName:"webgpu",kernelFunc:r2};const o2={kernelName:Bd,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{filterSize:r,strides:i,pad:o,dimRoundingMode:c}=a;return r$(s,Vb(s.shape,r,i,1,o,c),"max",n)}};const c2={kernelName:Wd,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{filterSize:r,strides:i,pad:o,dataFormat:c,dimRoundingMode:l}=a,u=Ub(s.shape,r,i,[1,1,1],o,l,c),h=new e$(u,"max"),d=[{type:"int32",data:[u.strideDepth,u.strideHeight,u.strideWidth]},{type:"int32",data:[u.padInfo.front,u.padInfo.top,u.padInfo.left]},{type:"int32",data:[u.inDepth,u.inHeight,u.inWidth]},{type:"int32",data:[u.effectiveFilterDepth,u.effectiveFilterHeight,u.effectiveFilterWidth]}];return n.runWebGPUProgram(h,[s],s.dtype,d)}};class l2{constructor(e){this.variableNames=["dy","maxPos"],this.uniforms="strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,\n       outHeight : i32, outWidth : i32",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=ZQ(this.outputShape),this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="maxPool2DBackprop"}getUserCode(){return"\n      ".concat(zQ("index")," {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords[0];\n        let d = coords[3];\n\n        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;\n        let dyRCorner = dyRCCorner.x;\n        let dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] - 1;\n        for (var wR = 0; wR < uniforms.filterDims[0]; wR += uniforms.dilations[0]) {\n          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);\n\n          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {\n            continue;\n          }\n          let idyR = i32(dyR);\n\n          for (var wC = 0; wC < uniforms.filterDims[1]; wC += uniforms.dilations[1]) {\n            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);\n\n            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {\n              continue;\n            }\n            let idyC = i32(dyC);\n\n            let dyValue = getDy(batch, idyR, idyC, d);\n            let maxPosValue = lastIndex - i32(getMaxPos(batch, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            let curPosValue = wR * uniforms.filterDims[1] + wC;\n            let mask = select(0.0, 1.0, maxPosValue == curPosValue);\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n    ")}}class u2{constructor(e){this.variableNames=["dy","maxPos"],this.uniforms="strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,\n      outDepth : i32, outHeight : i32, outWidth : i32",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=ZQ(this.outputShape),this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="maxPool3DBackprop"}getUserCode(){return"\n      ".concat(zQ("index")," {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords.x;\n        let ch = coords.u;\n\n        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;\n        let dyDCorner = dyCorner.x;\n        let dyRCorner = dyCorner.y;\n        let dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] * uniforms.filterDims[2] - 1;\n\n        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {\n          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);\n\n          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {\n            continue;\n          }\n          let idyD = i32(dyD);\n\n          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {\n            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);\n\n            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {\n              continue;\n            }\n            let idyR = i32(dyR);\n\n            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {\n              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);\n\n              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {\n                continue;\n              }\n              let idyC = i32(dyC);\n\n              let dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              let maxPosValue = lastIndex - i32(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              let curPosValue = wD * uniforms.filterDims[1] * uniforms.filterDims[2] + wR * uniforms.filterDims[2] + wC;\n              let mask = select(0.0, 1.0, maxPosValue == curPosValue);\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n    ")}}const h2={kernelName:Vd,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:s,input:r}=t,i=r,{filterSize:o,strides:c,pad:l,dimRoundingMode:u}=a,h=Ub(i.shape,o,c,[1,1,1],l,u),d=new e$(h,"max",!0);let p=[{type:"int32",data:[h.strideDepth,h.strideHeight,h.strideWidth]},{type:"int32",data:[h.padInfo.front,h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.inDepth,h.inHeight,h.inWidth]},{type:"int32",data:[h.effectiveFilterDepth,h.effectiveFilterHeight,h.effectiveFilterWidth]}];const f=n.runWebGPUProgram(d,[i],"int32",p),m=new u2(h);p=[{type:"int32",data:[h.strideDepth,h.strideHeight,h.strideWidth]},{type:"int32",data:[h.effectiveFilterDepth-1-h.padInfo.front,h.effectiveFilterHeight-1-h.padInfo.top,h.effectiveFilterWidth-1-h.padInfo.left]},{type:"int32",data:[h.effectiveFilterDepth,h.effectiveFilterHeight,h.effectiveFilterWidth]},{type:"int32",data:[h.outDepth]},{type:"int32",data:[h.outHeight]},{type:"int32",data:[h.outWidth]}];const g=n.runWebGPUProgram(m,[s,f],i.dtype,p);return n.disposeData(f.dataId),g}};const d2={kernelName:jd,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:s,input:r,output:i}=t,o=r;eZ([r,i],"maxPoolGrad");const{filterSize:c,strides:l,pad:u,dimRoundingMode:h}=a,d=Vb(o.shape,c,l,1,u,h),p=new $J(d,"max",!0);let f=[{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]},{type:"int32",data:[d.inHeight,d.inWidth]},{type:"int32",data:[d.effectiveFilterHeight,d.effectiveFilterWidth]}];const m=n.runWebGPUProgram(p,[o],"int32",f),g=new l2(d);f=[{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.effectiveFilterHeight-1-d.padInfo.top,d.effectiveFilterWidth-1-d.padInfo.left]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]},{type:"int32",data:[d.effectiveFilterHeight,d.effectiveFilterWidth]},{type:"int32",data:[d.outHeight]},{type:"int32",data:[d.outWidth]}];const y=n.runWebGPUProgram(g,[s,m],o.dtype,f);return n.disposeData(m.dataId),y}};const p2={kernelName:Ud,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{filterSize:s,strides:r,pad:i,includeBatchInIndex:o}=a,{x:c}=t;bu(4===c.shape.length,()=>"Error in maxPool: input must be rank 4 but got rank ".concat(c.shape.length,"."));const l=[1,1];bu(Jb(r,l),()=>"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(r," and dilations '").concat(l,"'"));const u=Vb(c.shape,s,r,l,i),h=[{type:"int32",data:[u.strideHeight,u.strideWidth]},{type:"int32",data:[u.padInfo.top,u.padInfo.left]},{type:"int32",data:[u.dilationHeight,u.dilationWidth]},{type:"int32",data:[u.inHeight,u.inWidth]},{type:"int32",data:[u.effectiveFilterHeight,u.effectiveFilterWidth]}];let d=new $J(u,"max",!1);const p=n.runWebGPUProgram(d,[c],c.dtype,h);return d=new $J(u,"max",!0,!0,o),[p,n.runWebGPUProgram(d,[c],"int32",h)]}};const f2={kernelName:Gd,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{axis:r,keepDims:i}=a;return FJ(s,r,i,"min",n)}},m2=LZ({opType:sZ.MIN,cpuKernelImpl:nJ}),g2={kernelName:qd,backendName:"webgpu",kernelFunc:m2};class y2{constructor(e,t,n){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.map((t,n)=>t[0]+e[n]+t[1]),this.dispatchLayout=ZQ(this.outputShape),this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=e,t.map((e,t)=>{this.uniforms+=" pad".concat(t," : vec2<i32>,")}),this.offset="reflect"===n?0:1,this.shaderKey="mirrorPad_".concat(n)}getUserCode(){const e=this.xShape.length,t=this.xShape.map((e,t)=>"uniforms.pad".concat(t,"[0]")).join(","),n=this.xShape.map((t,n)=>"uniforms.pad".concat(n,"[0] + uniforms.xShape").concat(e>1?"[".concat(n,"]"):"")).join(","),a=1===e?"start":"start[i]",s=1===e?"end":"end[i]",r=1===e?"outC":"outC[i]",i=FQ(e),o=e>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e):"coords";return"\n      ".concat(zQ("index")," {\n        if (index < uniforms.size) {\n          let start = ").concat(i,"(").concat(t,");\n          let end = ").concat(i,"(").concat(n,");\n          var outC = getCoordsFromIndex(index);\n          for (var i = 0; i < ").concat(e,"; i = i + 1) {\n            if (").concat(r," < ").concat(a,") {\n              ").concat(r," = ").concat(a," * 2 - ").concat(r," - ").concat(this.offset,";\n            } else if(").concat(r," >= ").concat(s,") {\n              ").concat(r," = (").concat(s," - 1) * 2 - ").concat(r," + ").concat(this.offset,";\n            }\n          }\n          let coords = outC - start;\n          setOutputAtIndex(index, getX(").concat(o,"));\n        }\n      }\n    ")}}const b2={kernelName:Kd,backendName:"webgpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e;const{x:s}=t,{paddings:r,mode:i}=n,o=a,c=r.map(e=>({type:"int32",data:[e[0],e[1]]})),l=new y2(s.shape,r,i);return o.runWebGPUProgram(l,[s],s.dtype,c)}},x2=LZ({opType:sZ.MOD}),v2={kernelName:Xd,backendName:"webgpu",kernelFunc:x2};class w2{constructor(e,t){this.variableNames=["probs"],this.outputShape=[],this.uniforms="seed : f32, numOutcomes: i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,t],this.dispatchLayout=ZQ(this.outputShape),this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="multinomial"}getUserCode(){return"\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    fn random (seed : f32, resultUV : vec2<f32>) -> f32 {\n      let HASHSCALE1 = 443.8975;\n      let p = resultUV * seed;\n      var p3  = fract(vec3<f32>(p.xyx) * HASHSCALE1);\n      p3 = p3 + dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ".concat(zQ("index")," {\n      if (index < uniforms.size) {\n        let coords = getOutputCoords();\n        let batch = coords[0];\n\n        let resUV = vec2<f32>(f32(coords[1]) / f32(uniforms.outShape[1]),\n            f32(coords[0]) / f32(uniforms.outShape[0]));\n        let r = random(uniforms.seed, resUV);\n        var cdf = 0.0;\n        for (var i = 0; i < uniforms.numOutcomes - 1; i = i + 1) {\n          cdf = cdf + getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutputAtIndexI32(index, i);\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutputAtIndexI32(index, uniforms.numOutcomes - 1);\n      }\n    }\n  ")}}class k2{constructor(e){this.variableNames=["logits"],this.outputShape=e,this.dispatchLayout=ZQ(this.outputShape),this.dispatch=[this.outputShape[0],1,1],this.outputShape[1]>=4096?this.workgroupSize=[256,1,1]:this.workgroupSize=[64,1,1],this.shaderKey="softmax"}getUserCode(){return"\n    var<workgroup> buf : array<f32, ".concat(this.workgroupSize[0],">;\n    var<workgroup> rowMaxShared : f32;\n    var<workgroup> rowSumShared : f32;\n    const blockSize = ").concat(this.workgroupSize[0],";\n    ").concat(zQ("index")," {\n      let row = index / blockSize;\n      let tid = i32(localId.x);\n      let cols = uniforms.outShape[1];\n\n      var threadMax = -3.402823e+38f;\n      for (var col = tid; col < cols; col += blockSize) {\n        let value = getLogits(row, col);\n        threadMax = max(threadMax, value);\n      }\n      if (tid < cols) {\n        buf[tid] = threadMax;\n      }\n      workgroupBarrier();\n\n      var reduceSize = min(cols, blockSize);\n      for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {\n        reduceSize = currSize + (reduceSize & 1);\n        if (tid < currSize) {\n          buf[tid] = max(buf[tid], buf[tid + reduceSize]);\n        }\n        workgroupBarrier();\n      }\n\n      if (tid == 0) {\n        rowMaxShared = buf[0];\n      }\n      workgroupBarrier();\n\n      var threadSum = 0.0;\n      for (var col = tid; col < cols; col += blockSize) {\n        let subExp = exp(getLogits(row, col) - rowMaxShared);\n        threadSum += subExp;\n      }\n      buf[tid] = threadSum;\n      workgroupBarrier();\n\n      for (var currSize = blockSize >> 1;  currSize > 0; currSize = currSize >> 1) {\n        if (tid < currSize) {\n          buf[tid] = buf[tid] + buf[tid + currSize];\n        }\n        workgroupBarrier();\n      }\n\n      if (tid == 0) {\n        rowSumShared = buf[0];\n      }\n      workgroupBarrier();\n\n      for (var col = tid; col < cols; col += blockSize) {\n        let value = exp(getLogits(row, col) - rowMaxShared) / rowSumShared;\n        setOutputAtCoords(row, col, value);\n      }\n  }\n    ")}}function S2(e){const{inputs:t,backend:n,attrs:a}=e,{logits:s}=t,{dim:r}=a,i=IZ({inputs:{x:s},backend:n,attrs:{shape:[wu(s.shape)/s.shape[r],s.shape[r]]}}),o=new k2(i.shape),c=n.runWebGPUProgram(o,[i],s.dtype),l=IZ({inputs:{x:c},backend:n,attrs:{shape:s.shape}});return n.disposeData(i.dataId),n.disposeData(c.dataId),l}const C2={kernelName:jp,backendName:"webgpu",kernelFunc:S2};const I2={kernelName:Yd,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{logits:s}=t,{numSamples:r,seed:i,normalized:o}=a,c=o?s:S2({inputs:{logits:s},backend:n,attrs:{dim:s.shape.length-1}}),l=c.shape[0],u=c.shape[1],h=new w2(l,r),d=[{type:"float32",data:[i]},{type:"int32",data:[u]}],p=n.runWebGPUProgram(h,[c],"int32",d);return o||n.disposeData(c.dataId),p}};const N2={kernelName:Zd,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t;if(n.shouldExecuteOnCPU([a])){const e=n.tensorMap.get(a.dataId),[t,s]=sJ(e.values,a.shape,a.dtype);return n.makeTensorInfo(s,a.dtype,t)}const s=new OZ(a.shape,iZ.NEG);return n.runWebGPUProgram(s,[a],a.dtype)}};const T2={kernelName:$d,backendName:"webgpu",kernelFunc:function(e){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:a}=e,{boxes:s,scores:r}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:c}=a,l=n.readSync(s.dataId),u=n.readSync(r.dataId),{selectedIndices:h}=sS(l,u,i,o,c);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}};const E2={kernelName:tp,backendName:"webgpu",kernelFunc:function(e){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:a}=e,{boxes:s,scores:r}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:c,softNmsSigma:l}=a,u=n.readSync(s.dataId),h=n.readSync(r.dataId),d=i,p=o,f=c,m=l,{selectedIndices:g,selectedScores:y}=iS(u,h,d,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}};class R2{constructor(e,t){this.variableNames=["x"],this.uniforms="onValue : f32, offValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,t],this.dispatchLayout=ZQ(this.outputShape),this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="onehot"}getUserCode(){return"\n      ".concat(zQ("index")," {\n        if(index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          setOutputAtIndex(index, mix(uniforms.offValue, uniforms.onValue,\n                                      f32(i32(round(getX(coords.x))) == coords.y)));\n        }\n      }\n    ")}}const _2={kernelName:ap,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{indices:s}=t,{dtype:r,depth:i,onValue:o,offValue:c}=a,l=wu(s.shape),u=new R2(l,i),h=IZ({inputs:{x:s},backend:n,attrs:{shape:[l]}}),d=[{type:"float32",data:[o]},{type:"float32",data:[c]}],p=n.runWebGPUProgram(u,[h],r,d);n.disposeData(h.dataId);const f=IZ({inputs:{x:p},backend:n,attrs:{shape:[...s.shape,i]}});return n.disposeData(p.dataId),f}};function A2(e){const{inputs:t,backend:n}=e,{x:a}=t;if("complex64"===a.dtype){const e=I$({inputs:{input:a},backend:n}),t=A2({inputs:{x:e},backend:n}),s=L$({inputs:{input:a},backend:n}),r=A2({inputs:{x:s},backend:n}),i=PZ({inputs:{real:t,imag:r},backend:n});return n.disposeData(e.dataId),n.disposeData(t.dataId),n.disposeData(s.dataId),n.disposeData(r.dataId),i}return SZ({attrs:{shape:a.shape,dtype:a.dtype,value:"string"===a.dtype?"":0},backend:n})}const M2={kernelName:uf,backendName:"webgpu",kernelFunc:A2};const P2={kernelName:np,backendName:"webgpu",kernelFunc:function e(t){const{inputs:n,backend:a}=t,{x:s}=n;if("string"===s.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===s.dtype){const t=I$({inputs:{input:s},backend:a}),n=e({inputs:{x:t},backend:a}),r=L$({inputs:{input:s},backend:a}),i=A2({inputs:{x:r},backend:a}),o=PZ({inputs:{real:n,imag:i},backend:a});return a.disposeData(t.dataId),a.disposeData(n.dataId),a.disposeData(r.dataId),a.disposeData(i.dataId),o}return SZ({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:a})}};const D2={kernelName:sp,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{axis:s}=a;if(1===t.length)return $0({inputs:{input:t[0]},backend:n,attrs:{dim:s}});const r=t[0].shape,i=t[0].dtype;t.forEach(e=>{xu(r,e.shape,"All tensors passed to stack must have matching shapes"),bu(i===e.dtype,()=>"All tensors passed to stack must have matching dtypes")});const o=[],c=j$({inputs:t.map(e=>{const t=$0({inputs:{input:e},backend:n,attrs:{dim:s}});return o.push(t),t}),backend:n,attrs:{axis:s}});return o.forEach(e=>n.disposeData(e.dataId)),c}};function O2(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const n=e.length,a=FQ(n),s=e.map((e,t)=>"uniforms.pad".concat(t,"[0]")).join(","),r=e.map((e,t)=>"uniforms.pad".concat(t,"[0] + uniforms.xShape").concat(n>1?"[".concat(t,"]"):"")).join(","),i=n>1?"".concat(a,"(").concat(s,")"):"".concat(s),o=n>1?"".concat(a,"(").concat(r,")"):"".concat(r),c=n>1?"any(paddedCoords < start)":"paddedCoords < start",l=n>1?"any(paddedCoords >= end)":"paddedCoords >= end",u=n>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,n):"coords";return"\n        let start = ".concat(i,";\n        let end = ").concat(o,";\n        if (").concat(c," || ").concat(l,") {\n          setOutputAtIndex(index, ").concat(t?0:"uniforms.constantValue",");\n        } else {\n          let coords = paddedCoords - start;\n          setOutputAtIndex(index, getX(").concat(u,"));\n        }\n  ")}class F2{constructor(e,t){this.variableNames=["x"],this.uniforms="constantValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.map((t,n)=>t[0]+e[n]+t[1]),this.dispatchLayout=ZQ(this.outputShape),this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize),t.map((e,t)=>{this.uniforms+=" pad".concat(t," : vec2<i32>,")}),this.xShape=e,this.shaderKey="pad"}getUserCode(){return"\n      ".concat(zQ("index")," {\n        if (index < uniforms.size) {\n          let paddedCoords = getCoordsFromIndex(index);\n          ").concat(O2(this.xShape),"\n        }\n      }\n    ")}}const L2={kernelName:rp,backendName:"webgpu",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{paddings:r,constantValue:i}=a;if(r.every(e=>Su(e,[0,0])))return AZ({inputs:{x:s},backend:n});if(0===wu(s.shape)){const e=r.map((e,t)=>e[0]+s.shape[t]+e[1]);return SZ({backend:n,attrs:{shape:e,value:i,dtype:s.dtype}})}const o=[{type:"float32",data:[i]}];r.map(e=>o.push({type:"int32",data:[e[0],e[1]]}));const c=new F2(s.shape,r);return n.runWebGPUProgram(c,[s],s.dtype,o)}},z2=LZ({opType:sZ.POW}),B2={kernelName:ip,backendName:"webgpu",kernelFunc:z2};const j2={kernelName:op,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a,alpha:s}=t,r=new _Z(sZ.PRELU,a.shape,s.shape);return n.runWebGPUProgram(r,[a,s],"float32")}};const W2={kernelName:cp,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{axis:r,keepDims:i}=a;return FJ(s,r,i,"prod",n)}},V2={kernelName:dp,backendName:"webgpu",kernelFunc:e=>{const{backend:t,attrs:n}=e,{start:a,stop:s,step:r,dtype:i}=n,o=oJ(a,s,r,i);return t.makeTensorInfo([o.length],i,o)}},U2=LZ({opType:sZ.DIV}),H2={kernelName:td,backendName:"webgpu",kernelFunc:U2},G2=FZ({opType:iZ.RECIPROCAL}),q2={kernelName:fp,backendName:"webgpu",kernelFunc:G2},K2=FZ({opType:iZ.RELU}),X2={kernelName:mp,backendName:"webgpu",kernelFunc:K2},Y2=FZ({opType:iZ.RELU6}),Q2={kernelName:wp,backendName:"webgpu",kernelFunc:Y2};class Z2{constructor(e,t,n){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, halfPixelCenters : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],t,n,e[3]],this.dispatchLayout=ZQ(this.outputShape),this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="resizeBilinear"}getUserCode(){return"\n      ".concat(zQ("index")," {\n        if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n          let b = coords[0];\n          let d = coords[3];\n          let rc = coords.yz;\n\n          let effectiveInSize = vec2<f32>(\n            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveOutSize = vec2<f32>(\n            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveInputOverOutputRatioRC =\n              effectiveInSize / effectiveOutSize;\n\n          // Fractional source index\n          let sourceFracIndexRC =\n            (vec2<f32>(rc) + vec2<f32>(uniforms.halfPixelCenters)) *\n            effectiveInputOverOutputRatioRC - vec2<f32>(uniforms.halfPixelCenters);\n\n          // Compute the four integer indices.\n          let sourceFloorRC = vec2<i32>(sourceFracIndexRC);\n          let sourceCeilRC = vec2<i32>(\n            min(vec2<f32>(uniforms.xShape.yz) - vec2<f32>(1.0), ceil(sourceFracIndexRC)));\n\n          let topLeft = getX(b, sourceFloorRC.x, sourceFloorRC.y, d);\n          let bottomLeft = getX(b, sourceCeilRC.x, sourceFloorRC.y, d);\n          let topRight = getX(b, sourceFloorRC.x, sourceCeilRC.y, d);\n          let bottomRight = getX(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n          let fracRC = sourceFracIndexRC - vec2<f32>(sourceFloorRC);\n\n          let top = topLeft + (topRight - topLeft) * fracRC.y;\n          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n          let newValue = top + (bottom - top) * fracRC.x;\n\n          setOutputAtIndex(index, newValue);\n        }\n      }\n    ")}}const J2={kernelName:xp,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:s}=t,{alignCorners:r,size:i,halfPixelCenters:o}=a,[c,l]=i,u=[{type:"float32",data:[r&&c>1?1:0,r&&l>1?1:0]},{type:"float32",data:[o?.5:0]}],h=new Z2(s.shape,c,l);return n.runWebGPUProgram(h,[s],"float32",u)}};class $2{constructor(e,t){this.variableNames=["dy"],this.uniforms="effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, heightScale : f32, widthScale : f32,\n       invHeightScale : f32, invWidthScale : f32, winHeight : i32, winWidth : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=ZQ(this.outputShape),this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.alignCorners=t,this.shaderKey="resizeBilinearBackprop_".concat(t)}getUserCode(){return"\n      ".concat(zQ("index")," {\n        if (index < uniforms.size) {\n          let coords = getOutputCoords();\n          let b = coords[0];\n          let d = coords[3];\n          let r = coords[1];\n          let c = coords[2];\n\n          var accumulator = 0.0;\n\n          // Compute bounds for where in dy we will look\n          let startRLerp = floor(f32(r) * uniforms.invHeightScale);\n          let startDyR = i32(startRLerp - f32(uniforms.winHeight / 2));\n\n          let startCLerp = floor(f32(c) * uniforms.invWidthScale);\n          let startDyC = i32(startCLerp - f32(uniforms.winWidth / 2));\n\n          // Loop over dy\n          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {\n            let dyR = startDyR + dyROffset;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {\n              continue;\n            }\n\n            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {\n              let dyC = startDyC + dyCOffset;\n\n              // Guard against the window exceeding the bounds of dy\n              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {\n                continue;\n              }\n\n              let dxR = f32(dyR) * uniforms.heightScale;\n              let topDxRIndex = i32(floor(dxR));\n              let bottomDxRIndex = i32(min(ceil(dxR), f32(uniforms.outShape[1] - 1)));\n              let dxRLerp = dxR - f32(topDxRIndex);\n              let inverseDxRLerp = 1.0 - dxRLerp;\n\n              let dxC = f32(dyC) * uniforms.widthScale;\n              let leftDxCIndex = i32(floor(dxC));\n              let rightDxCIndex = i32(min(ceil(dxC), f32(uniforms.outShape[2] - 1)));\n              let dxCLerp = dxC - f32(leftDxCIndex);\n              let inverseDxCLerp = 1.0 - dxCLerp;\n\n              if (r == topDxRIndex && c == leftDxCIndex) {\n                // topLeft\n                accumulator +=\n                  getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n              }\n\n              if (r == topDxRIndex && c == rightDxCIndex) {\n                // topRight\n                accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n              }\n\n              if (r == bottomDxRIndex && c == leftDxCIndex) {\n                // bottomLeft\n                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n              }\n\n              if (r == bottomDxRIndex && c == rightDxCIndex) {\n                // bottomRight\n                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n              }\n            }\n          }\n          // End loop over dy\n\n          setOutputAtIndex(index, accumulator);\n        }\n      }\n    ")}}const e3={kernelName:vp,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:s,dy:r}=t,{alignCorners:i}=a,[,o,c]=s.shape,[,l,u]=r.shape,h=[i&&l>1?o-1:o,i&&u>1?c-1:c],d=[i&&l>1?l-1:l,i&&u>1?u-1:u],p=h[0]/d[0],f=h[1]/d[1],m=1/p,g=1/f,y=2*Math.ceil(m)+2,b=2*Math.ceil(g)+2,x=new $2(s.shape,i),v=[{type:"int32",data:h},{type:"int32",data:d},{type:"float32",data:[p]},{type:"float32",data:[f]},{type:"float32",data:[m]},{type:"float32",data:[g]},{type:"int32",data:[y]},{type:"int32",data:[b]}];return n.runWebGPUProgram(x,[r],r.dtype,v)}};class t3{constructor(e,t,n,a){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, roundBase : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],t,n,e[3]],this.dispatchLayout=ZQ(this.outputShape),this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.halfPixelCenters=a,this.shaderKey="resizeNearest_".concat(a)}getUserCode(){let e;e=this.halfPixelCenters?"max((vec2<f32>(rc) + vec2<f32>(0.5)) * effectiveInputOverOutputRatioRC, vec2<f32>(0.0))":"vec2<f32>(rc) * effectiveInputOverOutputRatioRC";return"\n      ".concat(zQ("index")," {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let b = coords[0];\n          let d = coords[3];\n          let rc = coords.yz;\n\n          let effectiveInSize = vec2<f32>(\n            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveOutSize = vec2<f32>(\n            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveInputOverOutputRatioRC =\n              effectiveInSize / effectiveOutSize;\n\n          // Fractional source index\n          let sourceFracIndexRC = ").concat(e,";\n\n          // Compute the coordinators of nearest neighbor point.\n          let inputShapeRC = vec2<f32>(f32(uniforms.xShape.y), f32(uniforms.xShape.z));\n          let sourceNearestRC = vec2<i32>(\n            min(inputShapeRC - 1.0, floor(sourceFracIndexRC + uniforms.roundBase)));\n          let newValue = getX(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n          setOutputAtIndex(index, newValue);\n        }\n      }\n    ")}}const n3={kernelName:yp,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:s}=t,{alignCorners:r,halfPixelCenters:i,size:o}=a,[c,l]=o,u=[{type:"float32",data:[r&&c>1?1:0,r&&l>1?1:0]},{type:"float32",data:[r?.5:0]}],h=new t3(s.shape,c,l,i);return n.runWebGPUProgram(h,[s],s.dtype,u)}};class a3{constructor(e,t){this.variableNames=["dy"],this.uniforms="effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, invHeightScale : f32, invWidthScale : f32,\n       winHeight : i32, winWidth : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=ZQ(this.outputShape),this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.alignCorners=t,this.shaderKey="resizeNearestNeigborBackprop_".concat(t)}getUserCode(){return"\n      ".concat(zQ("index")," {\n        if (index < uniforms.size) {\n          let coords = getOutputCoords();\n          let b = coords[0];\n          let d = coords[3];\n          let r = coords[1];\n          let c = coords[2];\n\n          var accumulator = 0.0;\n\n          // Compute bounds for where in dy we will look\n          let startRLerp = floor(f32(r) * uniforms.invHeightScale);\n          let startDyR = i32(floor(startRLerp - f32(uniforms.winHeight / 2)));\n\n          let startCLerp = floor(f32(c) * uniforms.invWidthScale);\n          let startDyC = i32(floor(startCLerp - f32(uniforms.winWidth / 2)));\n\n          // Loop over dy\n          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {\n            let dyR = startDyR + dyROffset;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {\n              continue;\n            }\n\n            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {\n              let dyC = startDyC + dyCOffset;\n\n              // Guard against the window exceeding the bounds of dy\n              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {\n                continue;\n              }\n\n              let sourceFracRow = f32(uniforms.effectiveXSize[0]) *\n                  (f32(dyR) / f32(uniforms.effectiveYSize[0]));\n\n              let sourceFracCol = f32(uniforms.effectiveXSize[1]) *\n                  (f32(dyC) / f32(uniforms.effectiveYSize[1]));\n\n              let sourceNearestRow =\n                  i32(min(f32(uniforms.outShape[1] - 1),\n                  ").concat(this.alignCorners?"floor(sourceFracRow + 0.5)":"floor(sourceFracRow)","));\n\n              let sourceNearestCol =\n                  i32(min(f32(uniforms.outShape[2] - 1),\n                  ").concat(this.alignCorners?"floor(sourceFracCol + 0.5)":"floor(sourceFracCol)","));\n\n              if (r == sourceNearestRow && c == sourceNearestCol) {\n                accumulator += getDy(b, dyR, dyC, d);\n              }\n            }\n          }\n          // End loop over dy\n\n          setOutputAtIndex(index, accumulator);\n        }\n      }\n    ")}}const s3={kernelName:bp,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:s,dy:r}=t,{alignCorners:i}=a,[,o,c]=s.shape,[,l,u]=r.shape,h=[i&&l>1?o-1:o,i&&u>1?c-1:c],d=[i&&l>1?l-1:l,i&&u>1?u-1:u],p=1/(h[0]/d[0]),f=1/(h[1]/d[1]),m=2*Math.ceil(p)+2,g=2*Math.ceil(f)+2,y=new a3(s.shape,i),b=[{type:"int32",data:h},{type:"int32",data:d},{type:"float32",data:[p]},{type:"float32",data:[f]},{type:"int32",data:[m]},{type:"int32",data:[g]}];return n.runWebGPUProgram(y,[r],r.dtype,b)}};class r3{constructor(e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=ZQ(this.outputShape),this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=" axis : vec4<i32>,",this.shaderKey="reverse"}getUserCode(){return"\n      ".concat("\n      // Using uniform variables as judging conditions, so the function has\n      // coherent execution within all threads.\n      fn getReverseCoords(coords : vec4<i32>) -> vec4<i32> {\n        var reverseCoords = coords;\n        if (uniforms.axis[0] == 1) {\n          reverseCoords[0] = uniforms.xShape[0] - coords[0] - 1;\n        }\n        if (uniforms.axis[1] == 1) {\n          reverseCoords[1] = uniforms.xShape[1] - coords[1] - 1;\n        }\n        if (uniforms.axis[2] == 1) {\n          reverseCoords[2] = uniforms.xShape[2] - coords[2] - 1;\n        }\n        if (uniforms.axis[3] == 1) {\n          reverseCoords[3] = uniforms.xShape[3] - coords[3] - 1;\n        }\n\n        return reverseCoords;\n      }\n    ","\n      ").concat(zQ("index")," {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let reverseCoords = getReverseCoords(coords);\n          setOutputAtIndex(index, getX(reverseCoords[0],\n              reverseCoords[1], reverseCoords[2], reverseCoords[3]));\n        }\n      }\n    ")}}const i3={kernelName:kp,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{dims:r}=a,i=s.shape.length;if(0===i)return AZ({inputs:{x:s},backend:n});const o=s.shape,c=[1,1,1,1];o.forEach((e,t)=>{c[t+4-i]=e});const l=Ru(r,s.shape),u=[0,0,0,0];l.forEach(e=>{u[e+4-i]=1});const h=[{type:"int32",data:u}],d=IZ({inputs:{x:s},backend:n,attrs:{shape:c}}),p=new r3(c),f=n.runWebGPUProgram(p,[d],d.dtype,h);n.disposeData(d.dataId);const m=IZ({inputs:{x:f},backend:n,attrs:{shape:o}});return n.disposeData(f.dataId),m}};class o3{constructor(e,t){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=ZQ(this.outputShape),this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms="centerX : f32, centerY : f32, sinRadians : f32,\n          cosRadians : f32,",this.shaderKey="rotate",this.outputShape=e,"number"===typeof t?(this.uniforms+=" fillValue : f32,",this.fillSnippet="var outputValue = uniforms.fillValue;",this.shaderKey+="_float"):(this.uniforms+=" fillValue : vec3<f32>,",this.fillSnippet="var outputValue = uniforms.fillValue[coords[3]];",this.shaderKey+="_vec3")}getUserCode(){return"\n        ".concat(zQ("index")," {\n          if (index < uniforms.size) {\n            let coords = getCoordsFromIndex(index);\n            let coordXFloat = (f32(coords[2]) - uniforms.centerX) *\n                uniforms.cosRadians - (f32(coords[1]) - uniforms.centerY) *\n                uniforms.sinRadians;\n            let coordYFloat = (f32(coords[2]) - uniforms.centerX) *\n                uniforms.sinRadians + (f32(coords[1]) - uniforms.centerY) *\n                uniforms.cosRadians;\n            let coordX = i32(round(coordXFloat + uniforms.centerX));\n            let coordY = i32(round(coordYFloat + uniforms.centerY));\n            ").concat(this.fillSnippet,"\n            if(coordX >= 0 && coordX < uniforms.xShape[2] && coordY >= 0 &&\n                coordY < uniforms.xShape[1]) {\n              outputValue = getX(coords[0], coordY, coordX, coords[3]);\n            }\n            setOutputAtIndex(index, outputValue);\n          }\n        }\n      ")}}const c3={kernelName:pf,backendName:"webgpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e;const{image:s}=t,{radians:r,fillValue:i,center:o}=n,c=a,l=new o3(s.shape,i),[u,h]=oC(o,s.shape[1],s.shape[2]),d=[{type:"float32",data:[u]},{type:"float32",data:[h]},{type:"float32",data:[Math.sin(r)]},{type:"float32",data:[Math.cos(r)]}];"number"===typeof i?d.push({type:"float32",data:[Number.parseFloat(i.toFixed(2))]}):d.push({type:"float32",data:i});return c.runWebGPUProgram(l,[s],s.dtype,d)}},l3=FZ({opType:iZ.ROUND}),u3={kernelName:Sp,backendName:"webgpu",kernelFunc:l3},h3=FZ({opType:iZ.RSQRT,cpuKernelImpl:cJ}),d3={kernelName:Cp,backendName:"webgpu",kernelFunc:h3};class p3{constructor(e,t,n,a,s,r,i){let o=!(arguments.length>7&&void 0!==arguments[7])||arguments[7];this.variableNames=["updates","indices"],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=r,this.type=i,this.sumDupeIndices=o,this.dispatchLayout=ZQ(e),this.dispatch=XQ(this.dispatchLayout,e,this.workgroupSize),this.sliceDimGreaterThanOne=t>1,this.shaderKey="scatter_".concat(n,"_").concat(a,"_").concat(this.sliceDimGreaterThanOne,"_").concat(i,"_").concat(o,"_").concat(s.length);const c=FQ(s.length);this.uniforms="sliceDim : i32, strides: ".concat(c,", updatesSize: i32,"),this.updatesRank=a,this.indicesRank=n}getUserCode(){let e="";1===this.indicesRank?e="coords[0]":2===this.indicesRank&&(e="coords[0], j");const t="getIndices(".concat(e,")"),n=this.sliceDimGreaterThanOne?"uniforms.strides[j]":"uniforms.strides";let a="",s="";1===this.dispatchLayout.x.length?(a="flattenedIndex",s="\n      fn getUpdatesCoordsFromFlatIndex(index : i32) -> i32 {\n        return index;\n      }\n      "):2===this.dispatchLayout.x.length&&(a="vec2<i32>(flattenedIndex, coords[1])",s="\n      fn getUpdatesCoordsFromFlatIndex(index : i32) -> vec2<i32> {\n        // N.B. |updates| could be a scalar tensor, conceptually representing a\n        // 2D tensor with all values equal to that. By design, its size must be\n        // the same as |outShape[1]| in one dimension, and |indicesShape[0]|\n        // gives the other.\n        let sliceSize = uniforms.outShape[1];\n        let d0 = index / sliceSize;\n        let d1 = index - d0 * sliceSize;\n        return vec2<i32>(d0, d1);\n      }\n      ");const r=Array.from({length:this.updatesRank},(e,t)=>"coords[".concat(t,"]")),i="getUpdates(".concat(r.join(", "),")");return"\n    ".concat(s,"\n      ").concat(zQ("index")," {\n        if (index < uniforms.updatesSize) {\n          let coords = getUpdatesCoordsFromFlatIndex(index);\n          var flattenedIndex = 0;\n          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {\n            let indexInside = i32(round(").concat(t,"));\n            flattenedIndex = flattenedIndex + indexInside * ").concat(n,";\n          }\n          let updateValue =\n              ").concat(GQ(this.type),"(").concat(i,");\n          let flatIndex = getOutputIndexFromCoords(").concat(a,");\n\n          ").concat(this.sumDupeIndices?MQ("&result[flatIndex]","updateValue",this.type):"atomicStore(&result[flatIndex], bitcast<i32>(updateValue));","\n        }\n      }")}}const f3={kernelName:Ip,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{indices:s,updates:r}=t,{shape:i}=a,{sliceRank:o,numUpdates:c,sliceSize:l,strides:u,outputSize:h}=fk(0,s,i),d=[h/l,l];if(0===h)return n.makeTensorInfo(i,s.dtype);const p=IZ({inputs:{x:s},backend:n,attrs:{shape:[c,o]}}),f=IZ({inputs:{x:r},backend:n,attrs:{shape:[c,l]}}),m=f.dtype,g=SZ({backend:n,attrs:{shape:d,value:0,dtype:m}}),y=[{type:"int32",data:[o]},{type:"int32",data:u},{type:"int32",data:[wu(f.shape)]}],b=new p3(f.shape,o,p.shape.length,f.shape.length,u,d,m),x=n.runWebGPUProgram(b,[f,p],m,y,g),v=IZ({inputs:{x:x},backend:n,attrs:{shape:i}});return n.disposeData(p.dataId),n.disposeData(f.dataId),n.disposeData(x.dataId),v}};class m3{constructor(e,t){this.outputShape=[],this.variableNames=["sortedSequence","values"],this.uniforms="numInputs : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=ZQ(this.outputShape),this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.side=t,this.shaderKey="search_sorted_".concat(t)}getUserCode(){const e="left"===this.side?"<":"<=";return"\n      fn findBound(batch: i32, value: f32) -> i32 {\n        var left = i32(0);\n        var right = uniforms.numInputs;\n        while (left < right) {\n          var mid = (left + right) / 2;\n          if (getSortedSequence(batch, mid) ".concat(e," value) {\n            left = mid + 1;\n          } else {\n            right = mid;\n          }\n        }\n        return right;\n      }\n\n      ").concat(zQ("index")," {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let value = getValuesByOutputIndex(index);\n          setOutputAtIndexI32(index, findBound(coords[0], value));\n        }\n      }\n    ")}}const g3={kernelName:Tp,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{sortedSequence:s,values:r}=t,{side:i}=a,o=new m3([r.shape[0],r.shape[1]],i),c=[{type:"int32",data:[s.shape[1]]}];return n.runWebGPUProgram(o,[s,r],"int32",c)}};class y3{constructor(e,t,n){this.variableNames=["c","a","b"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=ZQ(this.outputShape),this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.cRank=e,this.rank=n,this.shaderKey="select"}getUserCode(){let e,t;if(this.rank>4)throw Error("Where for rank ".concat(this.rank," is not yet supported"));if(1===this.rank)t="resRC",e="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],a=[],s=[];for(let e=0;e<this.outputShape.length;e++)s.push("".concat(n[e])),e<this.cRank&&a.push("".concat(n[e]));e=a.join(),t=s.join()}return"\n      ".concat(zQ("index")," {\n        if (index < uniforms.size) {\n          let resRC = getCoordsFromIndex(index);\n          let cVal = getC(").concat(e,");\n          if (cVal >= 1.0) {\n            setOutputAtIndex(index, getA(").concat(t,"));\n          } else {\n            setOutputAtIndex(index, getB(").concat(t,"));\n          }\n        }\n      }\n    ")}}const b3={kernelName:Ep,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:a,t:s,e:r}=t,i=new y3(a.shape.length,s.shape,s.shape.length);return n.runWebGPUProgram(i,[a,s,r],gm(s.dtype,r.dtype))}},x3=FZ({opType:iZ.SELU}),v3={kernelName:Rp,backendName:"webgpu",kernelFunc:x3},w3=FZ({opType:iZ.SIGMOID}),k3={kernelName:Dp,backendName:"webgpu",kernelFunc:w3},S3=FZ({opType:iZ.SIGN}),C3={kernelName:Pp,backendName:"webgpu",kernelFunc:S3},I3=FZ({opType:iZ.SIN}),N3={kernelName:Ap,backendName:"webgpu",kernelFunc:I3},T3=FZ({opType:iZ.SINH}),E3={kernelName:Mp,backendName:"webgpu",kernelFunc:T3},R3=FZ({opType:iZ.SOFTPLUS}),_3={kernelName:Op,backendName:"webgpu",kernelFunc:R3};class A3{constructor(e,t,n,a,s,r){this.variableNames=["x"],this.outputShape=[],this.uniforms="",this.workgroupSize=[64,1,1],this.size=!0;const i=new Array(a.length);for(let o=0;o<i.length;o++)i[o]=a[s[o]];this.outputShape=i,this.newDim=s,this.dispatchLayout=ZQ(this.outputShape),this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=e,this.paddedXShape=t,this.uniforms+="reshapedPaddedXShape : ".concat(FQ(a.length),", paddedXShapeStrides : ").concat(FQ(r),", "),n.map((e,t)=>{this.uniforms+=" pad".concat(t," : vec2<i32>,")}),this.shaderKey="spaceToBatchND_".concat(s)}getUserCode(){const e=FQ(this.outputShape.length),t=AJ(this.newDim);return"\n      ".concat(VQ(this.paddedXShape,"PaddedX"),"\n      ").concat(zQ("index")," {\n        if(index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let switchedIndex = getIndexFromCoords").concat(this.outputShape.length,"D(").concat(e,"(").concat(t,"), uniforms.reshapedPaddedXShape);\n          let paddedCoords = getPaddedXCoordsFromIndex(switchedIndex);\n          ").concat(O2(this.xShape,!0),"\n        }\n      }\n    ")}}const M3={kernelName:zp,backendName:"webgpu",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{blockShape:r,paddings:i}=a;bu(s.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGPU backend not implemented yet");const o=r.reduce((e,t)=>e*t),c=[[0,0]];c.push(...i);for(let b=1+r.length;b<s.shape.length;++b)c.push([0,0]);const l=c.map((e,t)=>e[0]+s.shape[t]+e[1]),u=cC(l,r,o,!1),h=lC(u.length,r.length,!1),d=uC(l,r,o,!1),p=ju(l),f=new A3(s.shape,l,c,u,h,p.length),m=[{type:"int32",data:u},{type:"int32",data:p}];c.map(e=>m.push({type:"int32",data:[e[0],e[1]]}));const g=n.runWebGPUProgram(f,[s],s.dtype,m),y=IZ({inputs:{x:g},backend:n,attrs:{shape:d}});return n.disposeData(g.dataId),y}};class P3{constructor(e,t,n){this.variableNames=["input","indices","segmentIds"],this.outputShape=[],this.uniforms="segmentSize : i32, sparseSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e,this.type=n,this.dispatchLayout=ZQ([t]),this.dispatch=XQ(this.dispatchLayout,[t],this.workgroupSize),this.shaderKey="sparseSegmentSum"}getUserCode(){return"\n    ".concat(zQ("index")," {\n      if (index < uniforms.sparseSize) {\n        let indexInSegmentIds = index / uniforms.segmentSize;\n        let indexInSegment = index % uniforms.segmentSize;\n        let indexInInput = indices[indexInSegmentIds];\n        let segmentId = segmentIds[indexInSegmentIds];\n\n        let value = input[indexInInput * uniforms.segmentSize + indexInSegment];\n        let outIndex = segmentId * uniforms.segmentSize + indexInSegment;\n        ").concat(MQ("&result[outIndex]","value",this.type),"\n      }\n    }\n  ")}}class D3{constructor(e,t){this.variableNames=["segmentIds"],this.outputShape=[],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=[e],this.dispatchLayout=ZQ(t),this.dispatch=XQ(this.dispatchLayout,t,this.workgroupSize),this.shaderKey="sparseSegmentIdCountProgram"}getUserCode(){return"\n    ".concat(zQ("index")," {\n      if (index < uniforms.segmentIdsShape) {\n        let segmentId = segmentIds[index];\n        ").concat(MQ("&result[segmentId]","1","int32"),"\n      }\n    }\n  ")}}class O3{constructor(e,t){this.variableNames=["segmentSum","sameSegmentIdCount"],this.outputShape=[],this.uniforms="segmentSize : i32",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.type=t,this.dispatchLayout=ZQ(e),this.dispatch=XQ(this.dispatchLayout,e,this.workgroupSize),this.shaderKey="sparseSegmentMean"}getUserCode(){return"\n    ".concat(zQ("index")," {\n      if (index < uniforms.size) {\n        let segmentId = index / uniforms.segmentSize;\n        let count = sameSegmentIdCount[segmentId];\n        if (count != 0) {\n          ").concat("float32"===this.type?"setOutputAtIndex(index, segmentSum[index] / f32(count));":"setOutputAtIndexI32(index, segmentSum[index] / count);","\n        }\n      }\n    }\n  ")}}function F3(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=arguments.length>4?arguments[4]:void 0;const r=wu(e.shape)/e.shape[0],i=e.dtype,o=wu(t.shape),c=s.readSync(n.dataId),l=o>0?c[o-1]+1:0;let u;const h=e.shape.slice();h[0]=l;const d=o*r,p=SZ({backend:s,attrs:{shape:h,value:0,dtype:i}});u=new P3(h,d,i);let f=[{type:"int32",data:[r]},{type:"int32",data:[d]}];const m=s.runWebGPUProgram(u,[e,t,n],i,f,p);if(a)return m;const g=SZ({backend:s,attrs:{shape:[l],value:0,dtype:"int32"}});u=new D3(l,n.shape);const y=s.runWebGPUProgram(u,[n],"int32",null,g),b=SZ({backend:s,attrs:{shape:h,value:0,dtype:i}});u=new O3(h,i),f=[{type:"int32",data:[r]}];const x=s.runWebGPUProgram(u,[m,y],i,f,b);return s.disposeData(m.dataId),s.disposeData(y.dataId),x}const L3={kernelName:Up,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:a,indices:s,segmentIds:r}=t;return F3(a,s,r,!1,n)}};const z3={kernelName:Hp,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:a,indices:s,segmentIds:r}=t;return F3(a,s,r,!0,n)}};class B3{constructor(e,t){this.variableNames=["A"],this.workgroupSize=[64,1,1],this.size=!0;const n=new Array(e.length);for(let a=0;a<n.length;a++)n[a]=e[a]*t[a];this.outputShape=n,this.dispatchLayout=ZQ(this.outputShape),this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.rank=this.outputShape.length,this.shaderKey="tile"}getUserCode(){const e=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"";if(e>=5)throw Error("Tile for rank ".concat(e," is not yet supported"));if(1===e)return"(resRC % ".concat(t,"aShape)");const n=["resRC.x","resRC.y","resRC.z","resRC.w"],a=[];for(let s=0;s<e;s++)a.push("(".concat(n[s]," % ").concat(t,"aShape[").concat(s,"])"));return a.join()}(this.rank,"uniforms.");return"\n      ".concat(zQ("index")," {\n        if (index < uniforms.size) {\n          let resRC = getCoordsFromIndex(index);\n          setOutputAtIndex(index, getA(").concat(e,"));\n        }\n      }\n    ")}}function j3(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{reps:r}=a;if(n.shouldExecuteOnCPU([s])||"string"===s.dtype||s.shape.length>=5){const e=n.readSync(s.dataId),t="string"===s.dtype?e.map(e=>qf(e)):e,a=ny(s.shape,s.dtype,t),i=mJ(a,r);return n.makeTensorInfo(i.shape,i.dtype,i.values)}const i=new B3(s.shape,r);return n.runWebGPUProgram(i,[s],s.dtype)}const W3={kernelName:nf,backendName:"webgpu",kernelFunc:j3};const V3={kernelName:Gp,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{sparseIndices:s,sparseValues:r,defaultValue:i}=t,{outputShape:o}=a,{sliceRank:c,numUpdates:l,sliceSize:u,strides:h,outputSize:d}=fk(0,s,o),p=!1;if("string"===r.dtype){const e=n.bufferSync(s),t=n.bufferSync(r),a=qf(n.readSync(i.dataId)[0]),f=lJ(e,t,o,d,u,l,c,h,a,p);return n.makeTensorInfo(o,f.dtype,f.values)}const f=[d/u,u],m=IZ({inputs:{x:s},backend:n,attrs:{shape:[l,c]}}),g=r.shape.length?IZ({inputs:{x:r},backend:n,attrs:{shape:[l,u]}}):AZ({inputs:{x:r},backend:n}),y=g.dtype,b=n.makeTensorInfo([],y,Gu(1,y)),x=IZ({inputs:{x:i},backend:n,attrs:{shape:Array(f.length).fill(1)}}),v=j3({inputs:{x:x},backend:n,attrs:{reps:f}}),w=[{type:"int32",data:[c]},{type:"int32",data:h},{type:"int32",data:[wu([l,u])]}];switch(l){case 0:break;case 1:{const e=new p3([l,u],c,m.shape.length,g.shape.length,h,f,y,p);n.runWebGPUProgram(e,[g,m],y,w,v)}break;default:{const e=new p3([l,u],c,m.shape.length,b.shape.length,h,f,y,p);n.runWebGPUProgram(e,[b,m],y,w,v)}{const e=new p3([l,u],c,m.shape.length,g.shape.length,h,f,y);n.runWebGPUProgram(e,[g,m],y,w,v)}}const k=IZ({inputs:{x:v},backend:n,attrs:{shape:o}});return n.disposeData(m.dataId),n.disposeData(g.dataId),n.disposeData(x.dataId),n.disposeData(b.dataId),n.disposeData(v.dataId),k}};const U3={kernelName:Bp,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{numOrSizeSplits:r,axis:i}=a,o=Ru(i,s.shape)[0],c=jC(s,r,o),l=s.shape.length,u=new Array(l).fill(0),h=s.shape.slice();return c.map(e=>{const t=[...h];t[o]=e;const a=m$({inputs:{x:s},backend:n,attrs:{begin:u,size:t}});return u[o]+=e,a})}},H3=FZ({opType:iZ.SQRT}),G3={kernelName:Fp,backendName:"webgpu",kernelFunc:H3},q3={kernelName:Kp,backendName:"webgpu",kernelFunc:e=>{let{inputs:t,backend:n}=e;const{x:a}=t,s=n,r=new OZ(a.shape,iZ.SQUARE);return s.runWebGPUProgram(r,[a],a.dtype)}},K3=LZ({opType:sZ.SQUARED_DIFFERENCE}),X3={kernelName:qp,backendName:"webgpu",kernelFunc:K3};const Y3={kernelName:hf,backendName:"webgpu",kernelFunc:function(e){let{inputs:t,attrs:n,backend:a}=e;const{x:s}=t,r=new OZ(s.shape,iZ.STEP,"stepAlpha : f32,"),i=[{type:"float32",data:[n.alpha]}];return a.runWebGPUProgram(r,[s],s.dtype,i)}};class Q3{constructor(e){this.variableNames=["x"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=ZQ(this.outputShape),this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]);const t=FQ(this.outputShape.length);this.uniforms="begin : ".concat(t,",  strides : ").concat(t,", "),this.shaderKey="stridedSlice"}getUserCode(){let e="";if(1===this.outputShape.length)e="coords * uniforms.strides + uniforms.begin";else{let t=0;e=this.outputShape.map((e,n)=>(t++,1===this.outputShape.length?"coords * uniforms.strides[".concat(n,"] + uniforms.begin[").concat(n,"]"):"coords[".concat(t-1,"] * uniforms.strides[").concat(n,"] + uniforms.begin[").concat(n,"]"))).join(",")}return"\n       ".concat(zQ("index")," {\n         if (index < uniforms.size) {\n           let coords = getCoordsFromIndex(index);\n           setOutputAtIndex(index, getX(").concat(e,"));\n         }\n       }\n     ")}}const Z3={kernelName:Yp,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{begin:r,end:i,strides:o,beginMask:c,endMask:l,ellipsisMask:u,newAxisMask:h,shrinkAxisMask:d}=a,{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:x,strides:v}=Tb(s.shape,r,i,o,c,l,u,h,d);let w;if(m)w=IZ({inputs:{x:s},backend:n,attrs:{shape:f}});else if(g||y){bu(s.shape.length>=1,()=>"Input must have rank at least 1, got: ".concat(s.shape.length));const e=fb(b,x,v),t=m$({inputs:{x:s},backend:n,attrs:{begin:b,size:e}});w=IZ({inputs:{x:t},backend:n,attrs:{shape:f}}),n.disposeData(t.dataId)}else{if(n.shouldExecuteOnCPU([s])){const e=n.readSync(s.dataId),t=ny(s.shape,s.dtype,e),a=dJ(p,t,v,b);w=n.makeTensorInfo(f,s.dtype,a.values)}else{const e=new Q3(p),t=[{type:"int32",data:b},{type:"int32",data:v}],a=n.runWebGPUProgram(e,[s],s.dtype,t);w=IZ({inputs:{x:a},backend:n,attrs:{shape:f}}),n.disposeData(a.dataId)}}return w}};const J3={kernelName:Qp,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{separator:s,nGramWidths:r,leftPad:i,rightPad:o,padWidth:c,preserveShortSequences:l}=a,{data:u,dataSplits:h}=t,d=n.readSync(u.dataId),p=n.readSync(h.dataId),[f,m]=pJ(d,p,s,r,i,o,c,l);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(h.shape,"int32",m)]}},$3=LZ({opType:sZ.SUB,cpuKernelImpl:fJ,supportsComplex:!0}),e4={kernelName:$p,backendName:"webgpu",kernelFunc:$3},t4=FZ({opType:iZ.TAN}),n4={kernelName:ef,backendName:"webgpu",kernelFunc:t4},a4=FZ({opType:iZ.TANH}),s4={kernelName:tf,backendName:"webgpu",kernelFunc:a4};const r4={kernelName:Np,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{tensor:s,indices:r,updates:i}=t,{}=a,{sliceRank:o,numUpdates:c,sliceSize:l,strides:u,outputSize:h}=fk(0,r,s.shape),d=[h/l,l];if(0===h)return n.makeTensorInfo(s.shape,r.dtype);const p=[],f=IZ({inputs:{x:r},backend:n,attrs:{shape:[c,o]}});p.push(f);const m=IZ({inputs:{x:i},backend:n,attrs:{shape:[c,l]}});p.push(m);const g=IZ({inputs:{x:s},backend:n,attrs:{shape:d}});p.push(g);const y=j3({inputs:{x:g},backend:n,attrs:{reps:Array(d.length).fill(1)}}),b=new p3([c,l],o,f.shape.length,m.shape.length,u,d,s.dtype,!1),x=[{type:"int32",data:[o]},{type:"int32",data:u},{type:"int32",data:[wu([c,l])]}],v=n.runWebGPUProgram(b,[m,f],g.dtype,x,y);p.push(v);const w=IZ({inputs:{x:v},backend:n,attrs:{shape:s.shape}});return p.forEach(e=>n.disposeData(e.dataId)),w}};class i4{constructor(e){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=ZQ(this.outputShape),this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms="inputSize : i32, firstPass : i32, negativeInf : f32,\n        dir : i32, inc : i32,",this.shaderKey="swap"}getUserCode(){return"\n        ".concat(zQ("index")," {\n          if (index < uniforms.size) {\n            let outC = getCoordsFromIndex(index);\n            let batch = outC[0];\n            let elemIdx = outC[1];\n            // We compare elements pair-wise within a group of size 2 * inc.\n            // The comparing rule for each group alternates between ascending\n            // and descending. Within each group, we compare each pair at\n            // positions i and i+inc. To decide whether an element at position i\n            // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n            // inc, it is in the first half of the group, we denote it as x0,\n            // otherwise we denote it as x1.\n            // For example, as shown in the Bitonic top K paper referenced\n            // above, Figure5(a) shows that element[1] is in the second half of\n            // the group when group size is 2, but it is in the first half of\n            // the group when group size is 4.\n            let isFirstInPair = elemIdx % (2 * uniforms.inc) < uniforms.inc;\n            var i = 0;\n            if (isFirstInPair) {\n              i = elemIdx;\n            } else {\n              i = elemIdx - uniforms.inc;\n            }\n\n            var i0 = 0;\n            if (uniforms.firstPass == 1) {\n              i0 = i;\n            } else {\n              i0 = i32(getIndices(batch, i));\n            }\n\n            var i1 = 0;\n            if (uniforms.firstPass == 1) {\n              i1 = i + uniforms.inc;\n            } else {\n              i1 = i32(getIndices(batch, i + uniforms.inc));\n            }\n\n            var x0 = f32(0.0);\n            var x1 = f32(0.0);\n            if (i0 < uniforms.inputSize) {\n              x0 = getX(batch, i0);\n            } else {\n              x0 = uniforms.negativeInf;\n            }\n            if (i1 < uniforms.inputSize) {\n              x1 = getX(batch, i1);\n            } else {\n              x1 = uniforms.negativeInf;\n            }\n\n            let reverse = elemIdx % (2 * uniforms.dir) >= uniforms.dir;\n            let isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n            if (reverse == isGreater) {\n              // Elements in opposite order of direction\n              let iTemp = i0;\n              i0 = i1;\n              i1 = iTemp;\n            }\n            if (isFirstInPair) {\n              setOutputAtIndex(index, f32(i0));\n            } else {\n              setOutputAtIndex(index, f32(i1));\n            }\n          }\n        }\n      ")}}class o4{constructor(e){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=ZQ(this.outputShape),this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms="inputSize : i32, firstPass : i32, k : i32,",this.shaderKey="merge"}getUserCode(){return"\n        ".concat(zQ("index")," {\n          if (index < uniforms.size) {\n            let outC = getCoordsFromIndex(index);\n            let batch = outC[0];\n            let elemIdx = outC[1];\n            // The output size is half of the previous size.\n            // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _\n            // (k=4), we only need to output the indices at positions |, the\n            // indices at positions _ can be thrown away, see Figure5(b) After\n            // Phase 2 (Merge phase) in the Bitonic Top K paper referenced\n            // above.\n            // For example, the paper shows we only need to output the orange\n            // bars. The output sequence should look like this | | | | | | | |.\n            // Because the sequence is halved, to map the output index back to\n            // the previous sequence to find the corresponding value, we need\n            // to double the index. When we double the index, we basically\n            // interpolate a position, so 2i looks like\n            // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k\n            // position of each 2k positions by - elemIdx % k. E.g. for output\n            // at index 4,5,6,7, we want to get the corresponding element at\n            // original index 8,9,10,11, for output at index 8,9,10,11,\n            // we want to get the corresponding element at original index\n            // 16,17,18,19, so on and so forth.\n\n            var i = 0;\n            if (elemIdx < uniforms.k) {\n              i = elemIdx;\n            } else {\n              i = elemIdx * 2 - elemIdx % uniforms.k;\n            }\n            var i0 = 0;\n            if (uniforms.firstPass == 1) {\n              i0 = i;\n            } else {\n              i0 = i32(getIndices(batch, i));\n            }\n            var i1 = 0;\n            if (uniforms.firstPass == 1) {\n              i1 = i + uniforms.k;\n            } else {\n              i1 = i32(getIndices(batch, i + uniforms.k));\n            }\n\n            let x0 = getX(batch, i0);\n            var x1 = f32(0.0);\n            if (i1 < uniforms.inputSize) {\n              x1 = getX(batch, i1);\n            } else {\n              x1 = x0;\n            }\n\n            if (x0 >= x1) {\n              setOutputAtIndex(index, f32(i0));\n            } else {\n              setOutputAtIndex(index, f32(i1));\n            }\n          }\n        }\n      ")}}function c4(e,t){null!==t&&e.disposeData(t.dataId)}function l4(e){let t=1;for(;t<e;)t*=2;return t}const u4={kernelName:af,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s}=t,{k:r,sorted:i}=a,o=s.shape,c=o[o.length-1];if(n.shouldExecuteOnCPU([s])){const e=n.readSync(s.dataId),[t,a]=gJ(e,o,s.dtype,r,i);return[n.makeTensorInfo(t.shape,t.dtype,t.values),n.makeTensorInfo(a.shape,a.dtype,a.values)]}if(0===r)return o[o.length-1]=0,[n.makeTensorInfo(o,s.dtype,[]),n.makeTensorInfo(o,"int32",[])];if(1===c)return[s,SZ({attrs:{shape:o,dtype:"int32",value:0},backend:n})];const l=wu(o)/c,u=IZ({inputs:{x:s},attrs:{shape:[l,c]},backend:n}),h=l4(r),d=l4(c);let p=null;const f=()=>null===p?[u,u]:[u,p],m=(e,t,a)=>{const s=f(),r=new i4(a),i=[{type:"int32",data:[c]},{type:"int32",data:[null===p?1:0]},{type:"float32",data:[Number.NEGATIVE_INFINITY]},{type:"int32",data:[e]},{type:"int32",data:[t]}],o=p;p=n.runWebGPUProgram(r,s,"int32",i),c4(n,o)};for(let v=1;v<h;v*=2){const e=2*v;for(let t=v;t>=1;t/=2)m(e,t,[l,d])}for(let v=d;v>h;v/=2){const e=f(),t=new o4([l,v/2]),a=[{type:"int32",data:[c]},{type:"int32",data:[null===p?1:0]},{type:"int32",data:[h]}],s=p;p=n.runWebGPUProgram(t,e,"int32",a),c4(n,s);const r=h/2,i=2*r;for(let n=r;n>=1;n/=2)m(i,n,p.shape)}let g=p;p=m$({inputs:{x:p},backend:n,attrs:{begin:0,size:[l,r]}}),c4(n,g);let y=S1({inputs:{x:u,indices:p},backend:n,attrs:{axis:1,batchDims:1}});c4(n,u);const b=o.slice(0,-1);b.push(r),g=p,p=IZ({inputs:{x:p},attrs:{shape:b},backend:n}),c4(n,g);const x=y;return y=IZ({inputs:{x:y},attrs:{shape:b},backend:n}),c4(n,x),[y,p]}};class h4{constructor(e){this.variableNames=["Image","Transforms"],this.uniforms="interpolationModeId : i32, fillModeId : i32, fillValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=ZQ(this.outputShape),this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="transform"}getUserCode(){return"\n          fn mapCoord(outCoord : f32, len : f32) -> f32{\n            var inCoord = outCoord;\n            if(uniforms.fillModeId == 2) {\n              if (inCoord < 0.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz2 = 2.0 * len;\n                  if (inCoord < sz2) {\n                    inCoord = sz2 * f32(i32(f32(-inCoord / sz2))) +\n                    inCoord;\n                  }\n                  if (inCoord < -len) {\n                    inCoord = inCoord + sz2;\n                  } else {\n                    inCoord = -inCoord - 1.0;\n                  }\n                }\n              } else if (inCoord > len - 1.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz2 = 2.0 * len;\n                  inCoord = inCoord - sz2 * f32(i32(f32(inCoord / sz2)));\n                  if (inCoord >= len) {\n                    inCoord = sz2 - inCoord - 1.0;\n                  }\n                }\n              }\n              return clamp(inCoord, 0.0, len - 1.0);\n            } else if (uniforms.fillModeId == 3) {\n              if (inCoord < 0.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz = len - 1.0;\n                  inCoord = inCoord + len * (f32(i32(f32(-inCoord / sz))) + 1.0);\n                }\n              } else if (inCoord > len - 1.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz = len - 1.0;\n                  inCoord = inCoord - len * f32(i32(f32(inCoord / sz)));\n                }\n              }\n              return clamp(inCoord, 0.0, len - 1.0);\n            } else if (uniforms.fillModeId == 4) {\n              return clamp(outCoord, 0.0, len - 1.0);\n            }\n            return outCoord;\n          }\n          fn readWithFillValue(batch : i32, coordY : i32, coordX : i32,\n            channel : i32) -> f32 {\n            var outputValue : f32;\n            if (0 <= coordY && coordY < uniforms.imageShape[1] && 0 <= coordX && coordX < uniforms.imageShape[2]) {\n                outputValue = getImage(batch, coordY, coordX, channel);\n            } else {\n              outputValue = uniforms.fillValue;\n            }\n            return outputValue;\n          }\n\n          ".concat(zQ("index")," {\n            if (index < uniforms.size) {\n              let coords = getCoordsFromIndex(index);\n              var outputValue : f32;\n              let batch = coords[0];\n              let x = coords[2];\n              let y = coords[1];\n              let channel = coords[3];\n              let xf = f32(x);\n              let yf = f32(y);\n              let a1 = getTransforms(batch, 0);\n              let a2 = getTransforms(batch, 1);\n              let a3 = getTransforms(batch, 2);\n              let b1 = getTransforms(batch, 3);\n              let b2 = getTransforms(batch, 4);\n              let b3 = getTransforms(batch, 5);\n              let c1 = getTransforms(batch, 6);\n              let c2 = getTransforms(batch, 7);\n              let projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = uniforms.fillValue;\n              } else {\n                let inX = (a1 * xf + a2 * yf + a3) / projection;\n                let inY = (b1 * xf + b2 * yf + b3) / projection;\n                let mapX = mapCoord(inX, f32(uniforms.imageShape[2]));\n                let mapY = mapCoord(inY, f32(uniforms.imageShape[1]));\n\n                if (uniforms.interpolationModeId == 1) {\n                  let coordY = i32(round(mapY));\n                  let coordX = i32(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  let yFloor = floor(mapY);\n                  let xFloor = floor(mapX);\n                  let yCeil = yFloor + 1.0;\n                  let xCeil = xFloor + 1.0;\n                  let valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, i32(yFloor), i32(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, i32(yFloor), i32(xCeil), channel);\n                  let valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, i32(yCeil), i32(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, i32(yCeil), i32(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutputAtIndex(index, outputValue);\n            }\n          }\n        ")}}const d4={kernelName:sf,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{image:s,transforms:r}=t,{interpolation:i,fillMode:o,fillValue:c,outputShape:l}=a,[u,h,d,p]=s.shape,[f,m]=null!=l?l:[h,d],g=new h4([u,f,m,p]),y="nearest"===i?1:2;let b;switch(o){case"constant":default:b=1;break;case"reflect":b=2;break;case"wrap":b=3;break;case"nearest":b=4}const x=[{type:"int32",data:[y]},{type:"int32",data:[b]},{type:"float32",data:[c]}];return n.runWebGPUProgram(g,[s,r],"float32",x)}};const p4={kernelName:cf,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{value:s}=t;let{axis:r}=a;r<0&&(r+=s.shape.length);const i=s,o=i.shape.length,c=s.shape[r],l=new Array(o-1);let u=0;for(let m=0;m<o;m++)m!==r&&(l[u++]=i.shape[m]);const h=[],d=new Array(o).fill(0),p=i.shape.slice();p[r]=1;const f=new Array(c);for(let m=0;m<f.length;m++){d[r]=m;const e=m$({inputs:{x:i},backend:n,attrs:{begin:d,size:p}}),t=IZ({inputs:{x:e},backend:n,attrs:{shape:l}});f[m]=t,h.push(e)}return h.forEach(e=>n.disposeData(e.dataId)),f}};class f4{constructor(e,t,n){if(this.outputShape=[],this.variableNames=["x","segmentIds"],this.uniforms="numSegments : i32, xSize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=t,this.dispatchLayout=ZQ(e),this.dispatch=XQ(this.dispatchLayout,e,this.workgroupSize),"float32"!==n&&"int32"!==n)throw new Error("UnsortedSegmentSum only supports float32 and int32\n              types, does not support ".concat(n," type."));this.type=n,this.shaderKey="unsortedSegmentSum"}getUserCode(){return"\n    ".concat(zQ("index")," {\n      if (index < uniforms.xSize) {\n        let coords = getXCoordsFromIndex(index);\n        let b = coords[0];\n        let inCol = coords[1];\n\n        let segmentId = i32(getSegmentIds(inCol));\n        if (segmentId >= 0) {\n          let flatIndex = b * uniforms.numSegments + segmentId % uniforms.numSegments;\n          let value = getX(b, inCol);\n\n          ").concat(MQ("&result[flatIndex]","value",this.type),"\n        }\n      }\n    }\n  ")}}const m4={kernelName:lf,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:s,segmentIds:r}=t,{numSegments:i}=a,o=s.shape.length,c=[];let l=0;const u=tv([l],o);let h=s;null!=u&&(h=MJ({inputs:{x:s},backend:n,attrs:{perm:u}}),c.push(h),l=av(1,o)[0]);const d=eI(h.shape,l,i),p=wu([h.shape[l]]),f=IZ({inputs:{x:h},backend:n,attrs:{shape:[-1,p]}});c.push(f);const m=s.dtype,g=[f.shape[0],i],y=SZ({backend:n,attrs:{shape:g,value:0,dtype:m}}),b=new f4(f.shape,g,m),x=[{type:"int32",data:[i]},{type:"int32",data:[wu(f.shape)]}],v=n.runWebGPUProgram(b,[f,r],m,x,y),w=IZ({inputs:{x:v},backend:n,attrs:{shape:d}});c.push(v);let k=w;if(null!=u){c.push(w);const e=nv(u);k=MJ({inputs:{x:k},backend:n,attrs:{perm:e}})}return c.forEach(e=>n.disposeData(e.dataId)),k}},g4=[EZ,vJ,kJ,CJ,NJ,EJ,LJ,zJ,jJ,WJ,UJ,GJ,KJ,YJ,ZJ,i$,o$,u$,h$,d$,y$,v$,k$,T$,R$,M$,DZ,O$,W$,K$,J$,e0,n0,a0,s0,i0,c0,u0,g0,y0,b0,v0,T0,E0,C0,_0,M0,O0,F0,z0,U0,G0,q0,X0,Q0,J0,e1,n1,r1,CZ,o1,p1,l1,h1,y1,b1,x1,w1,C1,N1,E1,MZ,R1,z$,A1,P1,O1,F1,z1,j1,V1,q1,H1,X1,Q1,J1,n2,s2,n$,i2,o2,d2,c2,h2,p2,s$,f2,g2,b2,v2,I2,j0,N2,T2,E2,C$,_2,P2,D2,L2,B2,j2,W2,V2,N$,H2,q2,X2,Q2,NZ,J2,e3,n3,s3,i3,c3,u3,d3,f3,g3,b3,v3,k3,C3,N3,E3,g$,Y3,Z3,J3,C2,_3,M3,L3,z3,V3,U3,G3,q3,X3,e4,V0,n4,s4,r4,W3,u4,d4,PJ,p4,m4,M2];for(const n of g4)Cf(n);var y4=function(e,t){return(y4=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])})(e,t)};function b4(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Class extends value "+String(t)+" is not a constructor or null");function n(){this.constructor=e}y4(e,t),e.prototype=null===t?Object.create(t):(n.prototype=t.prototype,new n)}var x4=function(){return(x4=Object.assign||function(e){for(var t,n=1,a=arguments.length;n<a;n++)for(var s in t=arguments[n])Object.prototype.hasOwnProperty.call(t,s)&&(e[s]=t[s]);return e}).apply(this,arguments)};function v4(e,t,n,a){return new(n||(n=Promise))(function(s,r){function i(e){try{c(a.next(e))}catch(e){r(e)}}function o(e){try{c(a.throw(e))}catch(e){r(e)}}function c(e){var t;e.done?s(e.value):(t=e.value,t instanceof n?t:new n(function(e){e(t)})).then(i,o)}c((a=a.apply(e,t||[])).next())})}function w4(e,t){var n,a,s,r,i={label:0,sent:function(){if(1&s[0])throw s[1];return s[1]},trys:[],ops:[]};return r={next:o(0),throw:o(1),return:o(2)},"function"==typeof Symbol&&(r[Symbol.iterator]=function(){return this}),r;function o(r){return function(o){return function(r){if(n)throw new TypeError("Generator is already executing.");for(;i;)try{if(n=1,a&&(s=2&r[0]?a.return:r[0]?a.throw||((s=a.return)&&s.call(a),0):a.next)&&!(s=s.call(a,r[1])).done)return s;switch(a=0,s&&(r=[2&r[0],s.value]),r[0]){case 0:case 1:s=r;break;case 4:return i.label++,{value:r[1],done:!1};case 5:i.label++,a=r[1],r=[0];continue;case 7:r=i.ops.pop(),i.trys.pop();continue;default:if(!((s=(s=i.trys).length>0&&s[s.length-1])||6!==r[0]&&2!==r[0])){i=0;continue}if(3===r[0]&&(!s||r[1]>s[0]&&r[1]<s[3])){i.label=r[1];break}if(6===r[0]&&i.label<s[1]){i.label=s[1],s=r;break}if(s&&i.label<s[2]){i.label=s[2],i.ops.push(r);break}s[2]&&i.ops.pop(),i.trys.pop();continue}r=t.call(e,i)}catch(e){r=[6,e],a=0}finally{n=s=0}if(5&r[0])throw r[1];return{value:r[0]?r[1]:void 0,done:!0}}([r,o])}}}function k4(e,t,n){if(n||2===arguments.length)for(var a,s=0,r=t.length;s<r;s++)!a&&s in t||(a||(a=Array.prototype.slice.call(t,0,s)),a[s]=t[s]);return e.concat(a||Array.prototype.slice.call(t))}var S4=["nose","left_eye","right_eye","left_ear","right_ear","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle"],C4=["nose","left_eye_inner","left_eye","left_eye_outer","right_eye_inner","right_eye","right_eye_outer","left_ear","right_ear","mouth_left","mouth_right","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_pinky","right_pinky","left_index","right_index","left_thumb","right_thumb","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle","left_heel","right_heel","left_foot_index","right_foot_index"],I4={left:[1,2,3,7,9,11,13,15,17,19,21,23,25,27,29,31],right:[4,5,6,8,10,12,14,16,18,20,22,24,26,28,30,32],middle:[0]},N4={left:[1,3,5,7,9,11,13,15],right:[2,4,6,8,10,12,14,16],middle:[0]},T4=[[0,1],[0,2],[1,3],[2,4],[5,6],[5,7],[5,11],[6,8],[6,12],[7,9],[8,10],[11,12],[11,13],[12,14],[13,15],[14,16]],E4=[[0,1],[0,4],[1,2],[2,3],[3,7],[4,5],[5,6],[6,8],[9,10],[11,12],[11,13],[11,23],[12,14],[14,16],[12,24],[13,15],[15,17],[16,18],[16,20],[15,17],[15,19],[15,21],[16,22],[17,19],[18,20],[23,25],[23,24],[24,26],[25,27],[26,28],[27,29],[28,30],[27,31],[28,32],[29,31],[30,32]];function R4(e){return e instanceof SVGAnimatedLength?e.baseVal.value:e}function _4(e){return v4(this,void 0,void 0,function(){var t,n;return w4(this,function(a){switch(a.label){case 0:return t=document.createElement("canvas"),e instanceof om?[4,cb(e,t)]:[3,2];case 1:return a.sent(),[3,3];case 2:t.width=R4(e.width),t.height=R4(e.height),n=t.getContext("2d"),e instanceof ImageData?n.putImageData(e,0,0):n.drawImage(e,0,0),a.label=3;case 3:return[2,t]}})})}function A4(e){return v4(this,void 0,void 0,function(){var t,n,a,s,r,i;return w4(this,function(o){switch(o.label){case 0:return e instanceof om?(t=e.shape.slice(0,2),n=t[0],a=t[1],s=ImageData.bind,[4,cb(e)]):[3,2];case 1:return[2,new(s.apply(ImageData,[void 0,o.sent(),a,n]))];case 2:return r=document.createElement("canvas"),i=r.getContext("2d"),r.width=R4(e.width),r.height=R4(e.height),i.drawImage(e,0,0),[2,i.getImageData(0,0,r.width,r.height)]}})})}function M4(e){return v4(this,void 0,void 0,function(){var t;return w4(this,function(n){switch(n.label){case 0:return e instanceof SVGImageElement||e instanceof OffscreenCanvas?[4,_4(e)]:[3,2];case 1:return t=n.sent(),[3,3];case 2:t=e,n.label=3;case 3:return[2,lb(t,4)]}})})}function P4(e){if(e<0||e>=256)throw new Error("Mask value must be in range [0, 255] but got ".concat(e));if(!Number.isInteger(e))throw new Error("Mask value must be an integer but got ".concat(e))}var D4={runtime:"mediapipe",enableSmoothing:!0,enableSegmentation:!1,smoothSegmentation:!0,modelType:"full"},O4=function(){function e(e){this.mask=e}return e.prototype.toCanvasImageSource=function(){return v4(this,void 0,void 0,function(){return w4(this,function(e){return[2,this.mask]})})},e.prototype.toImageData=function(){return v4(this,void 0,void 0,function(){return w4(this,function(e){return[2,A4(this.mask)]})})},e.prototype.toTensor=function(){return v4(this,void 0,void 0,function(){return w4(this,function(e){return[2,M4(this.mask)]})})},e.prototype.getUnderlyingType=function(){return"canvasimagesource"},e}();function F4(e){return P4(e),"person"}var L4=function(){function e(e){var t,n=this;switch(this.width=0,this.height=0,this.selfieMode=!1,this.poseSolution=new SQ.Pose({locateFile:function(t,n){if(e.solutionPath){var a=e.solutionPath.replace(/\/+$/,"");return"".concat(a,"/").concat(t)}return"".concat(n,"/").concat(t)}}),e.modelType){case"lite":t=0;break;case"heavy":t=2;break;default:t=1}this.poseSolution.setOptions({modelComplexity:t,smoothLandmarks:e.enableSmoothing,enableSegmentation:e.enableSegmentation,smoothSegmentation:e.smoothSegmentation,selfieMode:this.selfieMode}),this.poseSolution.onResults(function(e){if(n.height=e.image.height,n.width=e.image.width,null==e.poseLandmarks)n.poses=[];else{var t=n.translateOutput(e.poseLandmarks,e.poseWorldLandmarks);e.segmentationMask&&(t.segmentation={maskValueToLabel:F4,mask:new O4(e.segmentationMask)}),n.poses=[t]}})}return e.prototype.translateOutput=function(e,t){var n=this,a={keypoints:e.map(function(e,t){return{x:e.x*n.width,y:e.y*n.height,z:e.z,score:e.visibility,name:C4[t]}})};return null!=t&&(a.keypoints3D=t.map(function(e,t){return{x:e.x,y:e.y,z:e.z,score:e.visibility,name:C4[t]}})),a},e.prototype.estimatePoses=function(e,t,n){return v4(this,void 0,void 0,function(){var a,s;return w4(this,function(r){switch(r.label){case 0:return t&&t.flipHorizontal&&t.flipHorizontal!==this.selfieMode&&(this.selfieMode=t.flipHorizontal,this.poseSolution.setOptions({selfieMode:this.selfieMode})),e instanceof om?(s=ImageData.bind,[4,cb(e)]):[3,2];case 1:return a=new(s.apply(ImageData,[void 0,r.sent(),e.shape[1],e.shape[0]])),[3,3];case 2:a=e,r.label=3;case 3:return e=a,[4,this.poseSolution.send({image:e},n)];case 4:return r.sent(),[2,this.poses]}})})},e.prototype.dispose=function(){this.poseSolution.close()},e.prototype.reset=function(){this.poseSolution.reset()},e.prototype.initialize=function(){return this.poseSolution.initialize()},e}();function z4(e){return v4(this,void 0,void 0,function(){var t,n;return w4(this,function(a){switch(a.label){case 0:return t=function(e){if(null==e)return x4({},D4);var t=x4({},e);return t.runtime="mediapipe",null==t.enableSegmentation&&(t.enableSegmentation=D4.enableSegmentation),null==t.enableSmoothing&&(t.enableSmoothing=D4.enableSmoothing),null==t.smoothSegmentation&&(t.smoothSegmentation=D4.smoothSegmentation),null==t.modelType&&(t.modelType=D4.modelType),t}(e),[4,(n=new L4(t)).initialize()];case 1:return a.sent(),[2,n]}})})}function B4(e){return e instanceof om?{height:e.shape[0],width:e.shape[1]}:{height:e.height,width:e.width}}function j4(e){return e-2*Math.PI*Math.floor((e+Math.PI)/(2*Math.PI))}function W4(e){return e instanceof om?e:lb(e)}function V4(e,t,n){return U4(n,"inputResolution"),[1/n.width*e[0][0]*t.width,1/n.height*e[0][1]*t.width,e[0][3]*t.width,1/n.width*e[1][0]*t.height,1/n.height*e[1][1]*t.height,e[1][3]*t.height,0,0]}function U4(e,t){bu(0!==e.width,function(){return"".concat(t," width cannot be 0.")}),bu(0!==e.height,function(){return"".concat(t," height cannot be 0.")})}function H4(e,t,n){var a=n.rotationVectorStartKeypointIndex,s=n.rotationVectorEndKeypointIndex,r=e.locationData,i=r.relativeKeypoints[a].x*t.width,o=r.relativeKeypoints[a].y*t.height,c=r.relativeKeypoints[s].x*t.width,l=r.relativeKeypoints[s].y*t.height,u=2*Math.sqrt((c-i)*(c-i)+(l-o)*(l-o)),h=function(e,t,n){var a,s=e.locationData,r=n.rotationVectorStartKeypointIndex,i=n.rotationVectorEndKeypointIndex;a=n.rotationVectorTargetAngle?n.rotationVectorTargetAngle:Math.PI*n.rotationVectorTargetAngleDegree/180;var o=s.relativeKeypoints[r].x*t.width,c=s.relativeKeypoints[r].y*t.height,l=s.relativeKeypoints[i].x*t.width,u=s.relativeKeypoints[i].y*t.height;return j4(a-Math.atan2(-(u-c),l-o))}(e,t,n);return{xCenter:i/t.width,yCenter:o/t.height,width:u/t.width,height:u/t.height,rotation:h}}function G4(e){if(16!==e.length)throw new Error("Array length must be 16 but got ".concat(e.length));return[[e[0],e[1],e[2],e[3]],[e[4],e[5],e[6],e[7]],[e[8],e[9],e[10],e[11]],[e[12],e[13],e[14],e[15]]]}function q4(e,t,n,a,s,r,i){return e[t][s]*(e[n][r]*e[a][i]-e[n][i]*e[a][r])}function K4(e,t,n){var a=(t+1)%4,s=(t+2)%4,r=(t+3)%4,i=(n+1)%4,o=(n+2)%4,c=(n+3)%4;return q4(e,a,s,r,i,o,c)+q4(e,s,r,a,i,o,c)+q4(e,r,a,s,i,o,c)}function X4(e,t,n){void 0===n&&(n={ignoreRotation:!1});for(var a=[],s=0,r=e;s<r.length;s++){var i=r[s],o=i.x-.5,c=i.y-.5,l=n.ignoreRotation?0:t.rotation,u=Math.cos(l)*o-Math.sin(l)*c,h=Math.sin(l)*o+Math.cos(l)*c;u=u*t.width+t.xCenter,h=h*t.height+t.yCenter;var d=i.z*t.width,p=x4({},i);p.x=u,p.y=h,p.z=d,a.push(p)}return a}function Y4(e,t){var n=function(e,t,n,a){var s=(a-n)/255;return{scale:s,offset:n-0*s}}(0,0,t[0],t[1]);return Xm(function(){return iy(ly(e,n.scale),n.offset)})}function Q4(e,t,n){var a,s,r,i,o,c,l,u,h,d,p,f,m=t.outputTensorSize,g=t.keepAspectRatio,y=t.borderMode,b=t.outputTensorFloatRange,x=B4(e),v=function(e,t){return t?{xCenter:t.xCenter*e.width,yCenter:t.yCenter*e.height,width:t.width*e.width,height:t.height*e.height,rotation:t.rotation}:{xCenter:.5*e.width,yCenter:.5*e.height,width:e.width,height:e.height,rotation:0}}(x,n),w=function(e,t,n){if(void 0===n&&(n=!1),!n)return{top:0,left:0,right:0,bottom:0};var a=t.height,s=t.width;U4(t,"targetSize"),U4(e,"roi");var r,i,o=a/s,c=e.height/e.width,l=0,u=0;return o>c?(r=e.width,i=e.width*o,u=(1-c/o)/2):(r=e.height/o,i=e.height,l=(1-o/c)/2),e.width=r,e.height=i,{top:u,left:l,right:l,bottom:u}}(v,m,g),k=(a=v,s=x.width,r=x.height,i=a.width,o=a.height,c=Math.cos(a.rotation),l=Math.sin(a.rotation),u=a.xCenter,h=a.yCenter,d=1/s,p=1/r,(f=new Array(16))[0]=i*c*1*d,f[1]=-o*l*d,f[2]=0,f[3]=(-.5*i*c*1+.5*o*l+u)*d,f[4]=i*l*1*p,f[5]=o*c*p,f[6]=0,f[7]=(-.5*o*c-.5*i*l*1+h)*p,f[8]=0,f[9]=0,f[10]=i*d,f[11]=0,f[12]=0,f[13]=0,f[14]=0,f[15]=1,G4(f));return{imageTensor:Xm(function(){var t=W4(e),n=ck(V4(k,x,m),[1,8]),a="zero"===y?"constant":"nearest",s=HS.transform(hv(ay(t,"float32")),n,"bilinear",a,0,[m.height,m.width]);return null!=b?Y4(s,b):s}),padding:w,transformationMatrix:k}}function Z4(e,t,n,a){return 1===a?.5*(e+t):e+(t-e)*n/(a-1)}function J4(e){return null!=e&&null!=e.currentTime}function $4(e){for(var t={locationData:{relativeKeypoints:[]}},n=Number.MAX_SAFE_INTEGER,a=Number.MIN_SAFE_INTEGER,s=Number.MAX_SAFE_INTEGER,r=Number.MIN_SAFE_INTEGER,i=0;i<e.length;++i){var o=e[i];n=Math.min(n,o.x),a=Math.max(a,o.x),s=Math.min(s,o.y),r=Math.max(r,o.y),t.locationData.relativeKeypoints.push({x:o.x,y:o.y})}return t.locationData.relativeBoundingBox={xMin:n,yMin:s,xMax:a,yMax:r,width:a-n,height:r-s},t}function e6(e,t,n,a){return v4(this,void 0,void 0,function(){var a,s,r,i,o;return w4(this,function(c){switch(c.label){case 0:return e.sort(function(e,t){return Math.max.apply(Math,t.score)-Math.max.apply(Math,e.score)}),a=ck(e.map(function(e){return[e.locationData.relativeBoundingBox.yMin,e.locationData.relativeBoundingBox.xMin,e.locationData.relativeBoundingBox.yMax,e.locationData.relativeBoundingBox.xMax]})),s=ok(e.map(function(e){return e.score[0]})),[4,HS.nonMaxSuppressionAsync(a,s,t,n)];case 1:return[4,(r=c.sent()).array()];case 2:return i=c.sent(),o=e.filter(function(e,t){return i.indexOf(t)>-1}),Ym([a,s,r]),[2,o]}})})}function t6(e,t){return e.map(function(e){var n=x4(x4({},e),{x:e.x*t.width,y:e.y*t.height});return null!=e.z&&(n.z=e.z*t.width),n})}function n6(e,t,n){return v4(this,void 0,void 0,function(){var a,s,r,i,o,c,l,u,h,d,p,f,m,g,y,b,x,v,w,k,S,C,I,N;return w4(this,function(T){switch(T.label){case 0:if(a=nk(t,[0]),s=a.shape,r=s[0],i=s[1],o=s[2],e.length!==o)throw new Error("Expected heatmap to have same number of channels as the number of landmarks. But got landmarks length: "+"".concat(e.length,", heatmap length: ").concat(o));return c=[],[4,a.buffer()];case 1:for(l=T.sent(),u=0;u<e.length;u++)if(h=e[u],d=x4({},h),c.push(d),p=Math.trunc(d.x*i),f=Math.trunc(d.y*r),!(p<0||p>=i||f<0||p>=r)){for(m=Math.trunc((n.kernelSize-1)/2),g=Math.max(0,p-m),y=Math.min(i,p+m+1),b=Math.max(0,f-m),x=Math.min(r,f+m+1),v=0,w=0,k=0,S=0,C=b;C<x;++C)for(I=g;I<y;++I)N=l.get(C,I,u),v+=N,S=Math.max(S,N),w+=I*N,k+=C*N;S>=n.minConfidenceToRefine&&v>0&&(d.x=w/i/v,d.y=k/r/v)}return a.dispose(),[2,c]}})})}function a6(e,t){var n=t.left,a=t.top,s=t.left+t.right,r=t.top+t.bottom;return e.map(function(e){return x4(x4({},e),{x:(e.x-n)/(1-s),y:(e.y-a)/(1-r),z:e.z/(1-s)})})}function s6(e,t,n){return v4(this,void 0,void 0,function(){var a,s,r,i,o;return w4(this,function(c){switch(c.label){case 0:return a=e[0],s=e[1],r=function(e,t,n){return Xm(function(){var a,s,r,i;n.reverseOutputOrder?(s=nk(cx(e,[0,n.boxCoordOffset+0],[-1,1])),a=nk(cx(e,[0,n.boxCoordOffset+1],[-1,1])),i=nk(cx(e,[0,n.boxCoordOffset+2],[-1,1])),r=nk(cx(e,[0,n.boxCoordOffset+3],[-1,1]))):(a=nk(cx(e,[0,n.boxCoordOffset+0],[-1,1])),s=nk(cx(e,[0,n.boxCoordOffset+1],[-1,1])),r=nk(cx(e,[0,n.boxCoordOffset+2],[-1,1])),i=nk(cx(e,[0,n.boxCoordOffset+3],[-1,1]))),s=iy(ly(cy(s,n.xScale),t.w),t.x),a=iy(ly(cy(a,n.yScale),t.h),t.y),n.applyExponentialOnBoxSize?(r=ly(uv(cy(r,n.hScale)),t.h),i=ly(uv(cy(i,n.wScale)),t.w)):(r=ly(cy(r,n.hScale),t.h),i=ly(cy(i,n.wScale),t.h));var o=Iy(a,cy(r,2)),c=Iy(s,cy(i,2)),l=iy(a,cy(r,2)),u=iy(s,cy(i,2)),h=rx([nx(o,[n.numBoxes,1]),nx(c,[n.numBoxes,1]),nx(l,[n.numBoxes,1]),nx(u,[n.numBoxes,1])],1);if(n.numKeypoints)for(var d=0;d<n.numKeypoints;++d){var p=n.keypointCoordOffset+d*n.numValuesPerKeypoint,f=void 0,m=void 0;n.reverseOutputOrder?(f=nk(cx(e,[0,p],[-1,1])),m=nk(cx(e,[0,p+1],[-1,1]))):(m=nk(cx(e,[0,p],[-1,1])),f=nk(cx(e,[0,p+1],[-1,1])));var g=iy(ly(cy(f,n.xScale),t.w),t.x),y=iy(ly(cy(m,n.yScale),t.h),t.y);h=rx([h,nx(g,[n.numBoxes,1]),nx(y,[n.numBoxes,1])],1)}return h})}(s,t,n),i=Xm(function(){var e=a;return n.sigmoidScore?(null!=n.scoreClippingThresh&&(e=wx(a,-n.scoreClippingThresh,n.scoreClippingThresh)),e=ox(e)):e}),[4,r6(r,i,n)];case 1:return o=c.sent(),Ym([r,i]),[2,o]}})})}function r6(e,t,n){return v4(this,void 0,void 0,function(){var a,s,r,i,o,c,l,u,h,d,p,f;return w4(this,function(m){switch(m.label){case 0:return a=[],[4,e.data()];case 1:return s=m.sent(),[4,t.data()];case 2:for(r=m.sent(),i=0;i<n.numBoxes;++i)if(!(null!=n.minScoreThresh&&r[i]<n.minScoreThresh||(o=i*n.numCoords,c=i6(s[o+0],s[o+1],s[o+2],s[o+3],r[i],n.flipVertically,i),(l=c.locationData.relativeBoundingBox).width<0||l.height<0))){if(n.numKeypoints>0)for((u=c.locationData).relativeKeypoints=[],h=n.numKeypoints*n.numValuesPerKeypoint,d=0;d<h;d+=n.numValuesPerKeypoint)p=o+n.keypointCoordOffset+d,f={x:s[p+0],y:n.flipVertically?1-s[p+1]:s[p+1]},u.relativeKeypoints.push(f);a.push(c)}return[2,a]}})})}function i6(e,t,n,a,s,r,i){return{score:[s],ind:i,locationData:{relativeBoundingBox:{xMin:t,yMin:r?1-n:e,xMax:a,yMax:r?1-e:n,width:a-t,height:n-e}}}}function o6(e,t){return"none"===e?t:function(e){return 1/(1+Math.exp(-e))}(t)}function c6(e,t,n,a){return v4(this,void 0,void 0,function(){var s,r,i,o,c,l,u,h;return w4(this,function(d){switch(d.label){case 0:return n=n||t.flipHorizontally||!1,a=a||t.flipVertically||!1,s=e.size,r=s/t.numLandmarks,[4,e.data()];case 1:for(i=d.sent(),o=[],c=0;c<t.numLandmarks;++c)l=c*r,(h={x:0,y:0}).x=n?t.inputImageWidth-i[l]:i[l],r>1&&(h.y=a?t.inputImageHeight-i[l+1]:i[l+1]),r>2&&(h.z=i[l+2]),r>3&&(h.score=o6(t.visibilityActivation,i[l+3])),o.push(h);for(u=0;u<o.length;++u)(h=o[u]).x=h.x/t.inputImageWidth,h.y=h.y/t.inputImageHeight,h.z=h.z/t.inputImageWidth/(t.normalizeZ||1);return[2,o]}})})}function l6(e,t,n){var a=e.width,s=e.height,r=e.rotation;if(null==n.rotation&&null==n.rotationDegree||(r=function(e,t){return null!=t.rotation?e+=t.rotation:null!=t.rotationDegree&&(e+=Math.PI*t.rotationDegree/180),j4(e)}(r,n)),0===r)e.xCenter=e.xCenter+a*n.shiftX,e.yCenter=e.yCenter+s*n.shiftY;else{var i=(t.width*a*n.shiftX*Math.cos(r)-t.height*s*n.shiftY*Math.sin(r))/t.width,o=(t.width*a*n.shiftX*Math.sin(r)+t.height*s*n.shiftY*Math.cos(r))/t.height;e.xCenter=e.xCenter+i,e.yCenter=e.yCenter+o}if(n.squareLong){var c=Math.max(a*t.width,s*t.height);a=c/t.width,s=c/t.height}else if(n.squareShort){var l=Math.min(a*t.width,s*t.height);a=l/t.width,s=l/t.height}return e.width=a*n.scaleX,e.height=s*n.scaleY,e}function u6(e,t){return e.map(function(e){var n=x4(x4({},e),{x:e.x/t.width,y:e.y/t.height});return null!=e.z&&(e.z=e.z/t.width),n})}var h6=function(){function e(e){this.alpha=e,this.initialized=!1}return e.prototype.apply=function(e,t){var n;return this.initialized?n=null==t?this.storedValue+this.alpha*(e-this.storedValue):this.storedValue+this.alpha*t*Math.asinh((e-this.storedValue)/t):(n=e,this.initialized=!0),this.rawValue=e,this.storedValue=n,n},e.prototype.applyWithAlpha=function(e,t,n){return this.alpha=t,this.apply(e,n)},e.prototype.hasLastRawValue=function(){return this.initialized},e.prototype.lastRawValue=function(){return this.rawValue},e.prototype.reset=function(){this.initialized=!1},e}(),d6=function(){function e(e){this.frequency=e.frequency,this.minCutOff=e.minCutOff,this.beta=e.beta,this.thresholdCutOff=e.thresholdCutOff,this.thresholdBeta=e.thresholdBeta,this.derivateCutOff=e.derivateCutOff,this.x=new h6(this.getAlpha(this.minCutOff)),this.dx=new h6(this.getAlpha(this.derivateCutOff)),this.lastTimestamp=0}return e.prototype.apply=function(e,t,n){if(null==e)return e;var a=Math.trunc(t);if(this.lastTimestamp>=a)return e;0!==this.lastTimestamp&&0!==a&&(this.frequency=1/(1e-6*(a-this.lastTimestamp))),this.lastTimestamp=a;var s=this.x.hasLastRawValue()?(e-this.x.lastRawValue())*n*this.frequency:0,r=this.dx.applyWithAlpha(s,this.getAlpha(this.derivateCutOff)),i=this.minCutOff+this.beta*Math.abs(r),o=null!=this.thresholdCutOff?this.thresholdCutOff+this.thresholdBeta*Math.abs(r):null;return this.x.applyWithAlpha(e,this.getAlpha(i),o)},e.prototype.getAlpha=function(e){return 1/(1+this.frequency/(2*Math.PI*e))},e}(),p6=function(){function e(e){this.config=e}return e.prototype.apply=function(e,t,n){var a=this;if(null==e)return this.reset(),null;this.initializeFiltersIfEmpty(e);var s=1;if(!this.config.disableValueScaling){if(n<this.config.minAllowedObjectScale)return k4([],e,!0);s=1/n}return e.map(function(e,n){var r=x4(x4({},e),{x:a.xFilters[n].apply(e.x,t,s),y:a.yFilters[n].apply(e.y,t,s)});return null!=e.z&&(r.z=a.zFilters[n].apply(e.z,t,s)),r})},e.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},e.prototype.initializeFiltersIfEmpty=function(e){var t=this;null!=this.xFilters&&this.xFilters.length===e.length||(this.xFilters=e.map(function(e){return new d6(t.config)}),this.yFilters=e.map(function(e){return new d6(t.config)}),this.zFilters=e.map(function(e){return new d6(t.config)}))},e}(),f6=function(){function e(e){this.config=e,this.window=[],this.lowPassFilter=new h6(1),this.lastValue=0,this.lastValueScale=1,this.lastTimestamp=-1}return e.prototype.apply=function(e,t,n){if(null==e)return e;var a,s=Math.trunc(t);if(this.lastTimestamp>=s)return e;if(-1===this.lastTimestamp)a=1;else{for(var r=e*n-this.lastValue*this.lastValueScale,i=s-this.lastTimestamp,o=r,c=i,l=(1+this.window.length)*(1e6/30),u=0,h=this.window;u<h.length;u++){var d=h[u];if(c+d.duration>l)break;o+=d.distance,c+=d.duration}var p=o/(1e-6*c);a=1-1/(1+this.config.velocityScale*Math.abs(p)),this.window.unshift({distance:r,duration:i}),this.window.length>this.config.windowSize&&this.window.pop()}return this.lastValue=e,this.lastValueScale=n,this.lastTimestamp=s,this.lowPassFilter.applyWithAlpha(e,a)},e}(),m6=function(){function e(e){this.config=e}return e.prototype.apply=function(e,t,n){var a=this;if(null==e)return this.reset(),null;var s=1;if(!this.config.disableValueScaling){if(n<this.config.minAllowedObjectScale)return k4([],e,!0);s=1/n}return this.initializeFiltersIfEmpty(e),e.map(function(e,n){var r=x4(x4({},e),{x:a.xFilters[n].apply(e.x,t,s),y:a.yFilters[n].apply(e.y,t,s)});return null!=e.z&&(r.z=a.zFilters[n].apply(e.z,t,s)),r})},e.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},e.prototype.initializeFiltersIfEmpty=function(e){var t=this;null!=this.xFilters&&this.xFilters.length===e.length||(this.xFilters=e.map(function(e){return new f6(t.config)}),this.yFilters=e.map(function(e){return new f6(t.config)}),this.zFilters=e.map(function(e){return new f6(t.config)}))},e}(),g6=function(){function e(e){if(null!=e.velocityFilter)this.keypointsFilter=new m6(e.velocityFilter);else{if(null==e.oneEuroFilter)throw new Error("Either configure velocityFilter or oneEuroFilter, but got "+"".concat(e,"."));this.keypointsFilter=new p6(e.oneEuroFilter)}}return e.prototype.apply=function(e,t,n,a,s){if(void 0===a&&(a=!1),null==e)return this.keypointsFilter.reset(),null;var r=null!=s?function(e,t){return(e.width*t.width+e.height*t.height)/2}(s,n):1,i=a?t6(e,n):e,o=this.keypointsFilter.apply(i,t,r);return a?u6(o,n):o},e}(),y6=function(){function e(e){this.alpha=e.alpha}return e.prototype.apply=function(e){var t=this;if(null==e)return this.visibilityFilters=null,null;null!=this.visibilityFilters&&this.visibilityFilters.length===e.length||(this.visibilityFilters=e.map(function(e){return new h6(t.alpha)}));for(var n=[],a=0;a<e.length;++a){var s=e[a],r=x4({},s);r.score=this.visibilityFilters[a].apply(s.score),n.push(r)}return n},e}(),b6={reduceBoxesInLowestlayer:!1,interpolatedScaleAspectRatio:1,featureMapHeight:[],featureMapWidth:[],numLayers:5,minScale:.1484375,maxScale:.75,inputSizeHeight:224,inputSizeWidth:224,anchorOffsetX:.5,anchorOffsetY:.5,strides:[8,16,32,32,32],aspectRatios:[1],fixedAnchorSize:!0},x6={runtime:"tfjs",modelType:"full",enableSmoothing:!0,enableSegmentation:!1,smoothSegmentation:!0,detectorModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/detector/1",landmarkModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/full/2"},v6={maxPoses:1,flipHorizontal:!1},w6={applyExponentialOnBoxSize:!1,flipVertically:!1,ignoreClasses:[],numClasses:1,numBoxes:2254,numCoords:12,boxCoordOffset:0,keypointCoordOffset:4,numKeypoints:4,numValuesPerKeypoint:2,sigmoidScore:!0,scoreClippingThresh:100,reverseOutputOrder:!0,xScale:224,yScale:224,hScale:224,wScale:224,minScoreThresh:.5},k6={shiftX:0,shiftY:0,scaleX:1.25,scaleY:1.25,squareLong:!0},S6={outputTensorSize:{width:224,height:224},keepAspectRatio:!0,outputTensorFloatRange:[-1,1],borderMode:"zero"},C6={outputTensorSize:{width:256,height:256},keepAspectRatio:!0,outputTensorFloatRange:[0,1],borderMode:"zero"},I6={numLandmarks:39,inputImageWidth:256,inputImageHeight:256,visibilityActivation:"sigmoid",flipHorizontally:!1,flipVertically:!1},N6={numLandmarks:39,inputImageWidth:1,inputImageHeight:1,visibilityActivation:"sigmoid",flipHorizontally:!1,flipVertically:!1},T6={kernelSize:7,minConfidenceToRefine:.5},E6={alpha:.1},R6={oneEuroFilter:{frequency:30,minCutOff:.05,beta:80,derivateCutOff:1,minAllowedObjectScale:1e-6}},_6={oneEuroFilter:{frequency:30,minCutOff:.01,beta:10,derivateCutOff:1,minAllowedObjectScale:1e-6}},A6={oneEuroFilter:{frequency:30,minCutOff:.1,beta:40,derivateCutOff:1,minAllowedObjectScale:1e-6,disableValueScaling:!0}},M6={activation:"none"},P6={combineWithPreviousRatio:.7},D6=function(){function e(e){this.mask=e}return e.prototype.toCanvasImageSource=function(){return v4(this,void 0,void 0,function(){return w4(this,function(e){return[2,_4(this.mask)]})})},e.prototype.toImageData=function(){return v4(this,void 0,void 0,function(){return w4(this,function(e){return[2,A4(this.mask)]})})},e.prototype.toTensor=function(){return v4(this,void 0,void 0,function(){return w4(this,function(e){return[2,this.mask]})})},e.prototype.getUnderlyingType=function(){return"tensor"},e}();function O6(e){return P4(e),"person"}var F6=function(){function e(e,t,n,a,s,r){this.detectorModel=e,this.landmarkModel=t,this.enableSmoothing=n,this.enableSegmentation=a,this.smoothSegmentation=s,this.modelType=r,this.regionOfInterest=null,this.prevFilteredSegmentationMask=null,this.anchors=function(e){null==e.reduceBoxesInLowestLayer&&(e.reduceBoxesInLowestLayer=!1),null==e.interpolatedScaleAspectRatio&&(e.interpolatedScaleAspectRatio=1),null==e.fixedAnchorSize&&(e.fixedAnchorSize=!1);for(var t=[],n=0;n<e.numLayers;){for(var a=[],s=[],r=[],i=[],o=n;o<e.strides.length&&e.strides[o]===e.strides[n];){var c=Z4(e.minScale,e.maxScale,o,e.strides.length);if(0===o&&e.reduceBoxesInLowestLayer)r.push(1),r.push(2),r.push(.5),i.push(.1),i.push(c),i.push(c);else{for(var l=0;l<e.aspectRatios.length;++l)r.push(e.aspectRatios[l]),i.push(c);if(e.interpolatedScaleAspectRatio>0){var u=o===e.strides.length-1?1:Z4(e.minScale,e.maxScale,o+1,e.strides.length);i.push(Math.sqrt(c*u)),r.push(e.interpolatedScaleAspectRatio)}}o++}for(var h=0;h<r.length;++h){var d=Math.sqrt(r[h]);a.push(i[h]/d),s.push(i[h]*d)}var p=0,f=0;if(e.featureMapHeight.length>0)p=e.featureMapHeight[n],f=e.featureMapWidth[n];else{var m=e.strides[n];p=Math.ceil(e.inputSizeHeight/m),f=Math.ceil(e.inputSizeWidth/m)}for(var g=0;g<p;++g)for(var y=0;y<f;++y)for(var b=0;b<a.length;++b){var x={xCenter:(y+e.anchorOffsetX)/f,yCenter:(g+e.anchorOffsetY)/p,width:0,height:0};e.fixedAnchorSize?(x.width=1,x.height=1):(x.width=s[b],x.height=a[b]),t.push(x)}n=o}return t}(b6);var i=ok(this.anchors.map(function(e){return e.width})),o=ok(this.anchors.map(function(e){return e.height})),c=ok(this.anchors.map(function(e){return e.xCenter})),l=ok(this.anchors.map(function(e){return e.yCenter}));this.anchorTensor={x:c,y:l,w:i,h:o},this.prevFilteredSegmentationMask=this.enableSegmentation?ck([],[0,0]):null}return e.prototype.estimatePoses=function(e,t,n){return v4(this,void 0,void 0,function(){var a,s,r,i,o,c,l,u,h,d,p,f,m,g,y,b,x,v,w,k,S,C,I;return w4(this,function(N){switch(N.label){case 0:return a=function(e){var t;if(null==(t=null==e?v6:x4({},e)).maxPoses&&(t.maxPoses=1),t.maxPoses<=0)throw new Error("Invalid maxPoses ".concat(t.maxPoses,". Should be > 0."));if(t.maxPoses>1)throw new Error("Multi-pose detection is not implemented yet. Please set maxPoses to 1.");return t}(t),null==e?(this.reset(),[2,[]]):(this.maxPoses=a.maxPoses,this.timestamp=null!=n?1e3*n:J4(e)?1e6*e.currentTime:null,s=B4(e),r=Xm(function(){return ay(W4(e),"float32")}),null!=(i=this.regionOfInterest)?[3,2]:[4,this.detectPose(r)]);case 1:if(0===(o=N.sent()).length)return this.reset(),r.dispose(),[2,[]];c=o[0],i=this.poseDetectionToRoi(c,s),N.label=2;case 2:return[4,this.poseLandmarksByRoi(i,r)];case 3:return l=N.sent(),r.dispose(),null==l?(this.reset(),[2,[]]):(u=l.landmarks,h=l.auxiliaryLandmarks,d=l.poseScore,p=l.worldLandmarks,f=l.segmentationMask,m=this.poseLandmarkFiltering(u,h,p,s),g=m.actualLandmarksFiltered,y=m.auxiliaryLandmarksFiltered,b=m.actualWorldLandmarksFiltered,x=this.poseLandmarksToRoi(y,s),this.regionOfInterest=x,v=this.smoothSegmentation&&null!=f?this.poseSegmentationFiltering(f):f,null!=(w=null!=g?t6(g,s):null)&&w.forEach(function(e,t){e.name=C4[t]}),null!=(k=b)&&k.forEach(function(e,t){e.name=C4[t]}),S={score:d,keypoints:w,keypoints3D:k},null!==v&&(C=Xm(function(){var e=hv(v,2),t=rw(e,[[0,0],[0,0],[0,1]]);return Qv(t,[[0,0],[0,0],[0,2]],"symmetric")}),this.smoothSegmentation||Ym(v),I={maskValueToLabel:O6,mask:new D6(C)},S.segmentation=I),[2,[S]])}})})},e.prototype.poseSegmentationFiltering=function(e){var t=this.prevFilteredSegmentationMask;return 0===t.size?this.prevFilteredSegmentationMask=e:(this.prevFilteredSegmentationMask=function(e,t,n){return"webgl"===Zm()?function(e,t,n){var a=n.combineWithPreviousRatio.toFixed(2),s={variableNames:["prevMask","newMask"],outputShape:e.shape,userCode:"\n  void main() {\n      ivec2 coords = getOutputCoords();\n      int height = coords[0];\n      int width = coords[1];\n\n      float prevMaskValue = getPrevMask(height, width);\n      float newMaskValue = getNewMask(height, width);\n\n      /*\n      * Assume p := newMaskValue\n      * H(p) := 1 + (p * log(p) + (1-p) * log(1-p)) / log(2)\n      * uncertainty alpha(p) =\n      *   Clamp(1 - (1 - H(p)) * (1 - H(p)), 0, 1) [squaring the\n      * uncertainty]\n      *\n      * The following polynomial approximates uncertainty alpha as a\n      * function of (p + 0.5):\n      */\n      const float c1 = 5.68842;\n      const float c2 = -0.748699;\n      const float c3 = -57.8051;\n      const float c4 = 291.309;\n      const float c5 = -624.717;\n      float t = newMaskValue - 0.5;\n      float x = t * t;\n\n      float uncertainty =\n        1.0 - min(1.0, x * (c1 + x * (c2 + x * (c3 + x * (c4 + x * c5)))));\n\n      float outputValue = newMaskValue + (prevMaskValue - newMaskValue) *\n                             (uncertainty * ".concat(a,");\n\n      setOutput(outputValue);\n    }\n")},r=$m();return Xm(function(){var n=r.compileAndRun(s,[e,t]);return qm().makeTensorFromDataId(n.dataId,n.shape,n.dtype)})}(e,t,n):Xm(function(){var a=Iy(t,.5),s=hy(a),r=Iy(1,Yv(1,ly(s,iy(5.68842,ly(s,iy(-.748699,ly(s,iy(-57.8051,ly(s,iy(291.309,ly(s,-624.717)))))))))));return iy(t,ly(Iy(e,t),ly(r,n.combineWithPreviousRatio)))})}(t,e,P6),Ym(e)),Ym(t),this.prevFilteredSegmentationMask},e.prototype.dispose=function(){this.detectorModel.dispose(),this.landmarkModel.dispose(),Ym([this.anchorTensor.x,this.anchorTensor.y,this.anchorTensor.w,this.anchorTensor.h,this.prevFilteredSegmentationMask])},e.prototype.reset=function(){this.regionOfInterest=null,this.enableSegmentation&&(Ym(this.prevFilteredSegmentationMask),this.prevFilteredSegmentationMask=ck([],[0,0])),this.visibilitySmoothingFilterActual=null,this.visibilitySmoothingFilterAuxiliary=null,this.landmarksSmoothingFilterActual=null,this.landmarksSmoothingFilterAuxiliary=null},e.prototype.detectPose=function(e){return v4(this,void 0,void 0,function(){var t,n,a,s,r,i,o,c,l,u;return w4(this,function(h){switch(h.label){case 0:return t=Q4(e,S6),n=t.imageTensor,a=t.padding,s=this.detectorModel.predict(n),r=function(e){return Xm(function(){var t=function(e){return Xm(function(){return[cx(e,[0,0,0],[1,-1,1]),cx(e,[0,0,1],[1,-1,-1])]})}(e),n=t[0],a=t[1];return{boxes:nk(a),logits:nk(n)}})}(s),i=r.boxes,[4,s6([o=r.logits,i],this.anchorTensor,w6)];case 1:return 0===(c=h.sent()).length?(Ym([n,s,o,i]),[2,c]):[4,e6(c,this.maxPoses,.3)];case 2:return l=h.sent(),u=function(e,t){void 0===e&&(e=[]);for(var n=t.left,a=t.top,s=t.left+t.right,r=t.top+t.bottom,i=0;i<e.length;i++){var o=e[i],c=o.locationData.relativeBoundingBox,l=(c.xMin-n)/(1-s),u=(c.yMin-a)/(1-r),h=c.width/(1-s),d=c.height/(1-r);c.xMin=l,c.yMin=u,c.width=h,c.height=d,c.xMax=l+h,c.yMax=u+d;var p=o.locationData.relativeKeypoints;p&&p.forEach(function(e){var t=(e.x-n)/(1-s),i=(e.y-a)/(1-r);e.x=t,e.y=i})}return e}(l,a),Ym([n,s,o,i]),[2,u]}})})},e.prototype.poseDetectionToRoi=function(e,t){return l6(H4(e,t,{rotationVectorEndKeypointIndex:1,rotationVectorStartKeypointIndex:0,rotationVectorTargetAngleDegree:90}),t,k6)},e.prototype.poseLandmarksByRoi=function(e,t){return v4(this,void 0,void 0,function(){var n,a,s,r,i,o,c,l,u,h,d,p,f,m;return w4(this,function(g){switch(g.label){case 0:if(n=B4(t),a=Q4(t,C6,e),s=a.imageTensor,r=a.padding,i=a.transformationMatrix,"lite"!==this.modelType&&"full"!==this.modelType&&"heavy"!==this.modelType)throw new Error("Model type must be one of lite, full or heavy,"+"but got ".concat(this.modelType));return o=["ld_3d","output_poseflag","activation_heatmap","world_3d"],this.enableSegmentation&&o.push("activation_segmentation"),c=this.landmarkModel.execute(s,o),[4,this.tensorsToPoseLandmarksAndSegmentation(c)];case 1:return null==(l=g.sent())?(Ym(c),Ym(s),[2,null]):(u=l.landmarks,h=l.auxiliaryLandmarks,d=l.poseScore,p=l.worldLandmarks,f=l.segmentationMask,[4,this.poseLandmarksAndSegmentationInverseProjection(n,e,r,i,u,h,p,f)]);case 2:return m=g.sent(),Ym(c),Ym(s),[2,x4({poseScore:d},m)]}})})},e.prototype.poseLandmarksAndSegmentationInverseProjection=function(e,t,n,a,s,r,i,o){return v4(this,void 0,void 0,function(){var c,l,u,h,d,p;return w4(this,function(f){return c=a6(s,n),l=a6(r,n),u=X4(c,t),h=X4(l,t),d=function(e,t){for(var n=[],a=0,s=e;a<s.length;a++){var r=s[a],i=r.x,o=r.y,c=t.rotation,l=Math.cos(c)*i-Math.sin(c)*o,u=Math.sin(c)*i+Math.cos(c)*o,h=x4({},r);h.x=l,h.y=u,n.push(h)}return n}(i,t),p=null,this.enableSegmentation&&(p=Xm(function(){var t=o.shape,n=t[0],s=t[1],r=function(e){var t=G4(new Array(16).fill(0));t[0][0]=K4(e,0,0),t[1][0]=-K4(e,0,1),t[2][0]=K4(e,0,2),t[3][0]=-K4(e,0,3),t[0][2]=K4(e,2,0),t[1][2]=-K4(e,2,1),t[2][2]=K4(e,2,2),t[3][2]=-K4(e,2,3),t[0][1]=-K4(e,1,0),t[1][1]=K4(e,1,1),t[2][1]=-K4(e,1,2),t[3][1]=K4(e,1,3),t[0][3]=-K4(e,3,0),t[1][3]=K4(e,3,1),t[2][3]=-K4(e,3,2),t[3][3]=K4(e,3,3);for(var n=e[0][0]*t[0][0]+e[1][0]*t[0][1]+e[2][0]*t[0][2]+e[3][0]*t[0][3],a=0;a<t.length;a++)for(var s=0;s<t.length;s++)t[a][s]/=n;return t}(a),i=ck(V4(r,{width:s,height:n},e),[1,8]),c=[1,n,s,1];return nk(HS.transform(nx(o,c),i,"bilinear","constant",0,[e.height,e.width]),[0,3])}),Ym(o)),[2,{landmarks:u,auxiliaryLandmarks:h,worldLandmarks:d,segmentationMask:p}]})})},e.prototype.tensorsToPoseLandmarksAndSegmentation=function(e){return v4(this,void 0,void 0,function(){var t,n,a,s,r,i,o,c,l,u,h,d,p;return w4(this,function(f){switch(f.label){case 0:return t=e[0],n=e[1],a=e[2],s=e[3],r=this.enableSegmentation?e[4]:null,[4,n.data()];case 1:return(i=f.sent()[0])<.5?[2,null]:[4,c6(t,I6)];case 2:return[4,n6(f.sent(),a,T6)];case 3:return o=f.sent(),c=o.slice(0,33),l=o.slice(33,35),[4,c6(s,N6)];case 4:return u=f.sent(),h=u.slice(0,33),d=function(e,t,n){void 0===n&&(n=!0);for(var a=[],s=0;s<e.length;s++){var r=x4({},t[s]);n&&(r.score=e[s].score),a.push(r)}return a}(c,h,!0),p=this.enableSegmentation?function(e,t){return Xm(function(){var n=nk(e,[0]),a=n.shape[2];if(1===a){var s=n;switch(t.activation){case"none":break;case"sigmoid":s=ox(s);break;case"softmax":throw new Error("Softmax activation requires two channels.");default:throw new Error("Activation not supported (".concat(t.activation,")"))}return nk(s,[2])}throw new Error("Unsupported number of tensor channels ".concat(a))})}(r,M6):null,[2,{landmarks:c,auxiliaryLandmarks:l,poseScore:i,worldLandmarks:d,segmentationMask:p}]}})})},e.prototype.poseLandmarksToRoi=function(e,t){return l6(H4($4(e),t,{rotationVectorStartKeypointIndex:0,rotationVectorEndKeypointIndex:1,rotationVectorTargetAngleDegree:90}),t,k6)},e.prototype.poseLandmarkFiltering=function(e,t,n,a){var s,r,i;if(null!=this.timestamp&&this.enableSmoothing){var o=H4($4(t),a,{rotationVectorEndKeypointIndex:0,rotationVectorStartKeypointIndex:1,rotationVectorTargetAngleDegree:90});null==this.visibilitySmoothingFilterActual&&(this.visibilitySmoothingFilterActual=new y6(E6)),s=this.visibilitySmoothingFilterActual.apply(e),null==this.visibilitySmoothingFilterAuxiliary&&(this.visibilitySmoothingFilterAuxiliary=new y6(E6)),r=this.visibilitySmoothingFilterAuxiliary.apply(t),i=this.visibilitySmoothingFilterActual.apply(n),null==this.landmarksSmoothingFilterActual&&(this.landmarksSmoothingFilterActual=new g6(R6)),s=this.landmarksSmoothingFilterActual.apply(s,this.timestamp,a,!0,o),null==this.landmarksSmoothingFilterAuxiliary&&(this.landmarksSmoothingFilterAuxiliary=new g6(_6)),r=this.landmarksSmoothingFilterAuxiliary.apply(r,this.timestamp,a,!0,o),null==this.worldLandmarksSmoothingFilterActual&&(this.worldLandmarksSmoothingFilterActual=new g6(A6)),i=this.worldLandmarksSmoothingFilterActual.apply(n,this.timestamp)}else s=e,r=t,i=n;return{actualLandmarksFiltered:s,auxiliaryLandmarksFiltered:r,actualWorldLandmarksFiltered:i}},e}();function L6(e){return v4(this,void 0,void 0,function(){var t,n,a,s,r,i;return w4(this,function(o){switch(o.label){case 0:return t=function(e){var t=x4({},null==e?x6:e);if(null==t.enableSmoothing&&(t.enableSmoothing=x6.enableSmoothing),null==t.enableSegmentation&&(t.enableSegmentation=x6.enableSegmentation),null==t.smoothSegmentation&&(t.smoothSegmentation=x6.smoothSegmentation),null==t.modelType&&(t.modelType=x6.modelType),null==t.detectorModelUrl&&(t.detectorModelUrl=x6.detectorModelUrl),null==t.landmarkModelUrl)switch(t.modelType){case"lite":t.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/lite/2";break;case"heavy":t.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/heavy/2";break;default:t.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/full/2"}return t}(e),n="string"==typeof t.detectorModelUrl&&t.detectorModelUrl.indexOf("https://tfhub.dev")>-1,a="string"==typeof t.landmarkModelUrl&&t.landmarkModelUrl.indexOf("https://tfhub.dev")>-1,[4,Promise.all([OP(t.detectorModelUrl,{fromTFHub:n}),OP(t.landmarkModelUrl,{fromTFHub:a})])];case 1:return s=o.sent(),r=s[0],i=s[1],[2,new F6(r,i,t.enableSmoothing,t.enableSegmentation,t.smoothSegmentation,t.modelType)]}})})}var z6,B6,j6,W6=function(){function e(e){!function(e){if(e.maxTracks<1)throw new Error("Must specify 'maxTracks' to be at least 1, but "+"encountered ".concat(e.maxTracks));if(e.maxAge<=0)throw new Error("Must specify 'maxAge' to be positive, but "+"encountered ".concat(e.maxAge));if(void 0!==e.keypointTrackerParams){if(e.keypointTrackerParams.keypointConfidenceThreshold<0||e.keypointTrackerParams.keypointConfidenceThreshold>1)throw new Error("Must specify 'keypointConfidenceThreshold' to be in the range [0, 1], but encountered "+"".concat(e.keypointTrackerParams.keypointConfidenceThreshold));if(e.keypointTrackerParams.minNumberOfKeypoints<1)throw new Error("Must specify 'minNumberOfKeypoints' to be at least 1, but "+"encountered ".concat(e.keypointTrackerParams.minNumberOfKeypoints));for(var t=0,n=e.keypointTrackerParams.keypointFalloff;t<n.length;t++){var a=n[t];if(a<=0)throw new Error("Must specify each keypoint falloff parameterto be positive "+"but encountered ".concat(a))}}}(e),this.tracks=[],this.maxTracks=e.maxTracks,this.maxAge=1e3*e.maxAge,this.minSimilarity=e.minSimilarity,this.nextID=1}return e.prototype.apply=function(e,t){this.filterOldTracks(t);var n=this.computeSimilarity(e);return this.assignTracks(e,n,t),this.updateTracks(t),e},e.prototype.getTracks=function(){return this.tracks.slice()},e.prototype.getTrackIDs=function(){return new Set(this.tracks.map(function(e){return e.id}))},e.prototype.filterOldTracks=function(e){var t=this;this.tracks=this.tracks.filter(function(n){return e-n.lastTimestamp<=t.maxAge})},e.prototype.assignTracks=function(e,t,n){for(var a=Array.from(Array(t[0].length).keys()),s=[],r=0,i=Array.from(Array(e.length).keys());r<i.length;r++){var o=i[r];if(0!==a.length){for(var c=-1,l=-1,u=0,h=a;u<h.length;u++){var d=h[u],p=t[o][d];p>=this.minSimilarity&&p>l&&(c=d,l=p)}if(c>=0){var f=this.tracks[c];f=Object.assign(f,this.createTrack(e[o],n,f.id)),e[o].id=f.id;var m=a.indexOf(c);a.splice(m,1)}else s.push(o)}else s.push(o)}for(var g=0,y=s;g<y.length;g++){o=y[g];var b=this.createTrack(e[o],n);this.tracks.push(b),e[o].id=b.id}},e.prototype.updateTracks=function(e){this.tracks.sort(function(e,t){return t.lastTimestamp-e.lastTimestamp}),this.tracks=this.tracks.slice(0,this.maxTracks)},e.prototype.createTrack=function(e,t,n){var a={id:n||this.nextTrackID(),lastTimestamp:t,keypoints:k4([],e.keypoints,!0).map(function(e){return x4({},e)})};return void 0!==e.box&&(a.box=x4({},e.box)),a},e.prototype.nextTrackID=function(){var e=this.nextID;return this.nextID+=1,e},e.prototype.remove=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];this.tracks=this.tracks.filter(function(t){return!e.includes(t.id)})},e.prototype.reset=function(){this.tracks=[]},e}(),V6=function(e){function t(t){return e.call(this,t)||this}return b4(t,e),t.prototype.computeSimilarity=function(e){var t=this;return 0===e.length||0===this.tracks.length?[[]]:e.map(function(e){return t.tracks.map(function(n){return t.iou(e,n)})})},t.prototype.iou=function(e,t){var n=Math.max(e.box.xMin,t.box.xMin),a=Math.max(e.box.yMin,t.box.yMin),s=Math.min(e.box.xMax,t.box.xMax),r=Math.min(e.box.yMax,t.box.yMax);if(n>=s||a>=r)return 0;var i=(s-n)*(r-a);return i/(e.box.width*e.box.height+t.box.width*t.box.height-i)},t}(W6),U6=function(e){function t(t){var n=e.call(this,t)||this;return n.keypointThreshold=t.keypointTrackerParams.keypointConfidenceThreshold,n.keypointFalloff=t.keypointTrackerParams.keypointFalloff,n.minNumKeyoints=t.keypointTrackerParams.minNumberOfKeypoints,n}return b4(t,e),t.prototype.computeSimilarity=function(e){if(0===e.length||0===this.tracks.length)return[[]];for(var t=[],n=0,a=e;n<a.length;n++){for(var s=a[n],r=[],i=0,o=this.tracks;i<o.length;i++){var c=o[i];r.push(this.oks(s,c))}t.push(r)}return t},t.prototype.oks=function(e,t){for(var n=this.area(t.keypoints)+1e-6,a=0,s=0,r=0;r<e.keypoints.length;++r){var i=e.keypoints[r],o=t.keypoints[r];if(!(i.score<this.keypointThreshold||o.score<this.keypointThreshold)){s+=1;var c=Math.pow(i.x-o.x,2)+Math.pow(i.y-o.y,2),l=2*this.keypointFalloff[r];a+=Math.exp(-1*c/(2*n*Math.pow(l,2)))}}return s<this.minNumKeyoints?0:a/s},t.prototype.area=function(e){var t=this,n=e.filter(function(e){return e.score>t.keypointThreshold}),a=Math.min.apply(Math,k4([1],n.map(function(e){return e.x}),!1)),s=Math.max.apply(Math,k4([0],n.map(function(e){return e.x}),!1)),r=Math.min.apply(Math,k4([1],n.map(function(e){return e.y}),!1));return(s-a)*(Math.max.apply(Math,k4([0],n.map(function(e){return e.y}),!1))-r)},t}(W6);function H6(e){switch(e){case B6.BlazePose:return C4.reduce(function(e,t,n){return e[t]=n,e},{});case B6.PoseNet:case B6.MoveNet:return S4.reduce(function(e,t,n){return e[t]=n,e},{});default:throw new Error("Model ".concat(e," is not supported."))}}(j6=z6||(z6={})).Keypoint="keypoint",j6.BoundingBox="boundingBox",function(e){e.MoveNet="MoveNet",e.BlazePose="BlazePose",e.PoseNet="PoseNet"}(B6||(B6={}));Object.freeze({__proto__:null,getKeypointIndexBySide:function(e){switch(e){case B6.BlazePose:return I4;case B6.PoseNet:case B6.MoveNet:return N4;default:throw new Error("Model ".concat(e," is not supported."))}},getAdjacentPairs:function(e){switch(e){case B6.BlazePose:return E4;case B6.PoseNet:case B6.MoveNet:return T4;default:throw new Error("Model ".concat(e," is not supported."))}},getKeypointIndexByName:H6});var G6=["SinglePose.Lightning","SinglePose.Thunder","MultiPose.Lightning"],q6={modelType:"SinglePose.Lightning",enableSmoothing:!0},K6={},X6={frequency:30,minCutOff:2.5,beta:300,derivateCutOff:2.5,thresholdCutOff:.5,thresholdBeta:5,disableValueScaling:!0},Y6={maxTracks:18,maxAge:1e3,minSimilarity:.2,keypointTrackerParams:{keypointConfidenceThreshold:.3,keypointFalloff:[.026,.025,.025,.035,.035,.079,.079,.072,.072,.062,.062,.107,.107,.087,.087,.089,.089],minNumberOfKeypoints:4}},Q6={maxTracks:18,maxAge:1e3,minSimilarity:.15,trackerParams:{}};function Z6(e,t){var n,a,s,r;return e?t.width>t.height?(n=1,a=t.height/t.width,s=0,r=(t.width/2-t.height/2)/t.width):(n=t.width/t.height,a=1,s=(t.height/2-t.width/2)/t.height,r=0):t.width>t.height?(n=t.width/t.height,a=1,s=(t.height/2-t.width/2)/t.height,r=0):(n=1,a=t.height/t.width,s=0,r=(t.width/2-t.height/2)/t.width),{yMin:s,xMin:r,yMax:s+n,xMax:r+a,height:n,width:a}}function J6(e,t){var n={maxTracks:e.maxTracks,maxAge:e.maxAge,minSimilarity:e.minSimilarity};return null!=t.maxTracks&&(n.maxTracks=t.maxTracks),null!=t.maxAge&&(n.maxAge=t.maxAge),null!=t.minSimilarity&&(n.minSimilarity=t.minSimilarity),n}var $6=function(){function e(e,t){this.moveNetModel=e,this.modelInputResolution={height:0,width:0},this.keypointIndexByName=H6(B6.MoveNet),"SinglePose.Lightning"===t.modelType?(this.modelInputResolution.width=192,this.modelInputResolution.height=192):"SinglePose.Thunder"===t.modelType&&(this.modelInputResolution.width=256,this.modelInputResolution.height=256),this.multiPoseModel="MultiPose.Lightning"===t.modelType,this.multiPoseModel||(this.keypointFilter=new p6(X6),this.cropRegionFilterYMin=new h6(.9),this.cropRegionFilterXMin=new h6(.9),this.cropRegionFilterYMax=new h6(.9),this.cropRegionFilterXMax=new h6(.9)),this.enableSmoothing=t.enableSmoothing,t.minPoseScore?this.minPoseScore=t.minPoseScore:this.minPoseScore=.25,t.multiPoseMaxDimension?this.multiPoseMaxDimension=t.multiPoseMaxDimension:this.multiPoseMaxDimension=256,this.enableTracking=t.enableTracking,this.multiPoseModel&&this.enableTracking&&(t.trackerType===z6.Keypoint?this.tracker=new U6(t.trackerConfig):t.trackerType===z6.BoundingBox&&(this.tracker=new V6(t.trackerConfig)),this.enableSmoothing&&(this.keypointFilterMap=new Map))}return e.prototype.runSinglePersonPoseModel=function(e){return v4(this,void 0,void 0,function(){var t,n,a,s,r;return w4(this,function(i){switch(i.label){case 0:if(4!==(t=this.moveNetModel.execute(e)).shape.length||1!==t.shape[0]||1!==t.shape[1]||17!==t.shape[2]||3!==t.shape[3])throw t.dispose(),new Error("Unexpected output shape from model: [".concat(t.shape,"]"));return"webgpu"===Zm()?[3,1]:(n=t.dataSync(),[3,3]);case 1:return[4,t.data()];case 2:n=i.sent(),i.label=3;case 3:for(t.dispose(),a={keypoints:[],score:0},s=0,r=0;r<17;++r)a.keypoints[r]={y:n[3*r],x:n[3*r+1],score:n[3*r+2]},a.keypoints[r].score>.2&&(++s,a.score+=a.keypoints[r].score);return s>0&&(a.score/=s),[2,a]}})})},e.prototype.runMultiPersonPoseModel=function(e){return v4(this,void 0,void 0,function(){var t,n,a,s,r,i,o,c;return w4(this,function(l){switch(l.label){case 0:if(3!==(t=this.moveNetModel.execute(e)).shape.length||1!==t.shape[0]||56!==t.shape[2])throw t.dispose(),new Error("Unexpected output shape from model: [".concat(t.shape,"]"));return"webgpu"===Zm()?[3,1]:(n=t.dataSync(),[3,3]);case 1:return[4,t.data()];case 2:n=l.sent(),l.label=3;case 3:for(t.dispose(),a=[],s=n.length/56,r=0;r<s;++r)for(a[r]={keypoints:[]},i=56*r+51,a[r].box={yMin:n[i],xMin:n[i+1],yMax:n[i+2],xMax:n[i+3],width:n[i+3]-n[i+1],height:n[i+2]-n[i]},o=56*r+55,a[r].score=n[o],a[r].keypoints=[],c=0;c<17;++c)a[r].keypoints[c]={y:n[56*r+3*c],x:n[56*r+3*c+1],score:n[56*r+3*c+2]};return[2,a]}})})},e.prototype.estimatePoses=function(e,t,n){return void 0===t&&(t=K6),v4(this,void 0,void 0,function(){var a,s,r,i,o,c;return w4(this,function(l){switch(l.label){case 0:return t=function(e){return null==e?K6:x4({},e)}(t),null==e?(this.reset(),[2,[]]):(null==n?J4(e)&&(n=1e6*e.currentTime):n*=1e3,a=W4(e),s=B4(a),r=hv(a,0),e instanceof om||a.dispose(),i=[],this.multiPoseModel?[3,2]:[4,this.estimateSinglePose(r,s,n)]);case 1:return i=l.sent(),[3,4];case 2:return[4,this.estimateMultiplePoses(r,s,n)];case 3:i=l.sent(),l.label=4;case 4:for(o=0;o<i.length;++o)for(c=0;c<i[o].keypoints.length;++c)i[o].keypoints[c].name=S4[c],i[o].keypoints[c].y*=s.height,i[o].keypoints[c].x*=s.width;return[2,i]}})})},e.prototype.estimateSinglePose=function(e,t,n){return v4(this,void 0,void 0,function(){var a,s,r,i,o=this;return w4(this,function(c){switch(c.label){case 0:return this.cropRegion||(this.cropRegion=Z6(null==this.cropRegion,t)),a=Xm(function(){var t=ck([[o.cropRegion.yMin,o.cropRegion.xMin,o.cropRegion.yMax,o.cropRegion.xMax]]),n=qv([1],"int32"),a=[o.modelInputResolution.height,o.modelInputResolution.width];return ay(HS.cropAndResize(e,t,n,a,"bilinear",0),"int32")}),e.dispose(),[4,this.runSinglePersonPoseModel(a)];case 1:if(s=c.sent(),a.dispose(),s.score<this.minPoseScore)return this.reset(),[2,[]];for(r=0;r<s.keypoints.length;++r)s.keypoints[r].y=this.cropRegion.yMin+s.keypoints[r].y*this.cropRegion.height,s.keypoints[r].x=this.cropRegion.xMin+s.keypoints[r].x*this.cropRegion.width;return null!=n&&this.enableSmoothing&&(s.keypoints=this.keypointFilter.apply(s.keypoints,n,1)),i=function(e,t,n,a){for(var s={},r=0,i=S4;r<i.length;r++){var o=i[r];s[o]=[t[n[o]].y*a.height,t[n[o]].x*a.width]}if(function(e,t){return(e[t.left_hip].score>.2||e[t.right_hip].score>.2)&&(e[t.left_shoulder].score>.2||e[t.right_shoulder].score>.2)}(t,n)){var c=(s.left_hip[0]+s.right_hip[0])/2,l=(s.left_hip[1]+s.right_hip[1])/2,u=function(e,t,n,a,s){for(var r=["left_shoulder","right_shoulder","left_hip","right_hip"],i=0,o=0,c=0;c<r.length;c++)(p=Math.abs(a-n[r[c]][0]))>i&&(i=p),(f=Math.abs(s-n[r[c]][1]))>o&&(o=f);for(var l=0,u=0,h=0,d=Object.keys(n);h<d.length;h++){var p,f,m=d[h];e[t[m]].score<.2||((p=Math.abs(a-n[m][0]))>l&&(l=p),(f=Math.abs(s-n[m][1]))>u&&(u=f))}return[i,o,l,u]}(t,n,s,c,l),h=u[0],d=u[1],p=u[2],f=u[3],m=Math.max(1.9*d,1.9*h,1.2*p,1.2*f),g=[c-(m=Math.min(m,Math.max(l,a.width-l,c,a.height-c))),l-m];if(m>Math.max(a.width,a.height)/2)return Z6(null==e,a);var y=2*m;return{yMin:g[0]/a.height,xMin:g[1]/a.width,yMax:(g[0]+y)/a.height,xMax:(g[1]+y)/a.width,height:(g[0]+y)/a.height-g[0]/a.height,width:(g[1]+y)/a.width-g[1]/a.width}}return Z6(null==e,a)}(this.cropRegion,s.keypoints,this.keypointIndexByName,t),this.cropRegion=this.filterCropRegion(i),[2,[s]]}})})},e.prototype.estimateMultiplePoses=function(e,t,n){return v4(this,void 0,void 0,function(){var a,s,r,i,o,c,l,u,h,d,p,f=this;return w4(this,function(m){switch(m.label){case 0:return t.width>t.height?(s=this.multiPoseMaxDimension,r=Math.round(this.multiPoseMaxDimension*t.height/t.width),a=HS.resizeBilinear(e,[r,s]),o=s,c=32*Math.ceil(r/32),i=rw(a,[[0,0],[0,c-r],[0,0],[0,0]])):(s=Math.round(this.multiPoseMaxDimension*t.width/t.height),r=this.multiPoseMaxDimension,a=HS.resizeBilinear(e,[r,s]),o=32*Math.ceil(s/32),c=r,i=rw(a,[[0,0],[0,0],[0,o-s],[0,0]])),a.dispose(),e.dispose(),l=ay(i,"int32"),i.dispose(),[4,this.runMultiPersonPoseModel(l)];case 1:for(u=m.sent(),l.dispose(),u=u.filter(function(e){return e.score>=f.minPoseScore}),d=0;d<u.length;++d)for(h=0;h<u[d].keypoints.length;++h)u[d].keypoints[h].y*=c/r,u[d].keypoints[h].x*=o/s;if(this.enableTracking&&(this.tracker.apply(u,n),this.enableSmoothing)){for(d=0;d<u.length;++d)this.keypointFilterMap.has(u[d].id)||this.keypointFilterMap.set(u[d].id,new p6(X6)),u[d].keypoints=this.keypointFilterMap.get(u[d].id).apply(u[d].keypoints,n,1);p=this.tracker.getTrackIDs(),this.keypointFilterMap.forEach(function(e,t){p.has(t)||f.keypointFilterMap.delete(t)})}return[2,u]}})})},e.prototype.filterCropRegion=function(e){if(e){var t=this.cropRegionFilterYMin.apply(e.yMin),n=this.cropRegionFilterXMin.apply(e.xMin),a=this.cropRegionFilterYMax.apply(e.yMax),s=this.cropRegionFilterXMax.apply(e.xMax);return{yMin:t,xMin:n,yMax:a,xMax:s,height:a-t,width:s-n}}return this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset(),null},e.prototype.dispose=function(){this.moveNetModel.dispose()},e.prototype.reset=function(){this.cropRegion=null,this.resetFilters()},e.prototype.resetFilters=function(){this.keypointFilter.reset(),this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset()},e}();function e5(e){return void 0===e&&(e=q6),v4(this,void 0,void 0,function(){var t,n,a,s;return w4(this,function(r){switch(r.label){case 0:return t=function(e){var t,n=null==e?q6:x4({},e);if(null==n.modelType)n.modelType="SinglePose.Lightning";else if(G6.indexOf(n.modelType)<0)throw new Error("Invalid architecture ".concat(n.modelType,". ")+"Should be one of ".concat(G6));if(null==n.enableSmoothing&&(n.enableSmoothing=!0),null!=n.minPoseScore&&(n.minPoseScore<0||n.minPoseScore>1))throw new Error("minPoseScore should be between 0.0 and 1.0");if(null!=n.multiPoseMaxDimension&&(n.multiPoseMaxDimension%32!=0||n.multiPoseMaxDimension<32))throw new Error("multiPoseMaxDimension must be a multiple of 32 and higher than 0");if("MultiPose.Lightning"===n.modelType&&null==n.enableTracking&&(n.enableTracking=!0),"MultiPose.Lightning"===n.modelType&&!0===n.enableTracking)if(null==n.trackerType&&(n.trackerType=z6.BoundingBox),n.trackerType===z6.Keypoint)null!=n.trackerConfig?n.trackerConfig=function(e){var t=J6(Y6,e);return t.keypointTrackerParams=x4({},Y6.keypointTrackerParams),null!=e.keypointTrackerParams&&(null!=e.keypointTrackerParams.keypointConfidenceThreshold&&(t.keypointTrackerParams.keypointConfidenceThreshold=e.keypointTrackerParams.keypointConfidenceThreshold),null!=e.keypointTrackerParams.keypointFalloff&&(t.keypointTrackerParams.keypointFalloff=e.keypointTrackerParams.keypointFalloff),null!=e.keypointTrackerParams.minNumberOfKeypoints&&(t.keypointTrackerParams.minNumberOfKeypoints=e.keypointTrackerParams.minNumberOfKeypoints)),t}(n.trackerConfig):n.trackerConfig=Y6;else{if(n.trackerType!==z6.BoundingBox)throw new Error("Tracker type not supported by MoveNet");null!=n.trackerConfig?n.trackerConfig=(t=n.trackerConfig,J6(Q6,t)):n.trackerConfig=Q6}return n}(e),a=!0,t.modelUrl?(a="string"==typeof t.modelUrl&&t.modelUrl.indexOf("https://tfhub.dev")>-1,[4,OP(t.modelUrl,{fromTFHub:a})]):[3,2];case 1:return n=r.sent(),[3,4];case 2:return s=void 0,"SinglePose.Lightning"===t.modelType?s="https://tfhub.dev/google/tfjs-model/movenet/singlepose/lightning/4":"SinglePose.Thunder"===t.modelType?s="https://tfhub.dev/google/tfjs-model/movenet/singlepose/thunder/4":"MultiPose.Lightning"===t.modelType&&(s="https://tfhub.dev/google/tfjs-model/movenet/multipose/lightning/1"),[4,OP(s,{fromTFHub:a})];case 3:n=r.sent(),r.label=4;case 4:return"webgl"===Zm()&&eh().set("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",0),[2,new $6(n,t)]}})})}var t5={architecture:"MobileNetV1",outputStride:16,multiplier:.75,inputResolution:{height:257,width:257}},n5=["MobileNetV1","ResNet50"],a5={MobileNetV1:[8,16],ResNet50:[16]},s5=[8,16,32],r5={MobileNetV1:[.5,.75,1],ResNet50:[1]},i5=[1,2,4],o5={maxPoses:1,flipHorizontal:!1},c5={maxPoses:5,flipHorizontal:!1,scoreThreshold:.5,nmsRadius:20},l5=[-123.15,-115.9,-103.06];function u5(e){return Math.floor(e/2)}var h5=function(){function e(e,t){this.priorityQueue=new Array(e),this.numberOfElements=-1,this.getElementValue=t}return e.prototype.enqueue=function(e){this.priorityQueue[++this.numberOfElements]=e,this.swim(this.numberOfElements)},e.prototype.dequeue=function(){var e=this.priorityQueue[0];return this.exchange(0,this.numberOfElements--),this.sink(0),this.priorityQueue[this.numberOfElements+1]=null,e},e.prototype.empty=function(){return-1===this.numberOfElements},e.prototype.size=function(){return this.numberOfElements+1},e.prototype.all=function(){return this.priorityQueue.slice(0,this.numberOfElements+1)},e.prototype.max=function(){return this.priorityQueue[0]},e.prototype.swim=function(e){for(;e>0&&this.less(u5(e),e);)this.exchange(e,u5(e)),e=u5(e)},e.prototype.sink=function(e){for(;2*e<=this.numberOfElements;){var t=2*e;if(t<this.numberOfElements&&this.less(t,t+1)&&t++,!this.less(e,t))break;this.exchange(e,t),e=t}},e.prototype.getValueAt=function(e){return this.getElementValue(this.priorityQueue[e])},e.prototype.less=function(e,t){return this.getValueAt(e)<this.getValueAt(t)},e.prototype.exchange=function(e,t){var n=this.priorityQueue[e];this.priorityQueue[e]=this.priorityQueue[t],this.priorityQueue[t]=n},e}();function d5(e,t,n,a,s,r){for(var i=r.shape,o=i[0],c=i[1],l=!0,u=Math.max(n-s,0),h=Math.min(n+s+1,o),d=u;d<h;++d){for(var p=Math.max(a-s,0),f=Math.min(a+s+1,c),m=p;m<f;++m)if(r.get(d,m,e)>t){l=!1;break}if(!l)break}return l}function p5(e){return v4(this,void 0,void 0,function(){return w4(this,function(t){return[2,Promise.all(e.map(function(e){return e.buffer()}))]})})}function f5(e,t,n,a){return{y:a.get(e,t,n),x:a.get(e,t,n+17)}}function m5(e,t,n){var a=f5(e.heatmapY,e.heatmapX,e.id,n),s=a.y,r=a.x;return{x:e.heatmapX*t+r,y:e.heatmapY*t+s}}function g5(e,t,n,a){var s=n.x,r=n.y;return e.some(function(e){var n,i,o,c,l=e.keypoints;return n=r,i=s,(o=l[a].y-n)*o+(c=l[a].x-i)*c<=t})}var y5=S4.reduce(function(e,t,n){return e[t]=n,e},{}),b5=[["nose","left_eye"],["left_eye","left_ear"],["nose","right_eye"],["right_eye","right_ear"],["nose","left_shoulder"],["left_shoulder","left_elbow"],["left_elbow","left_wrist"],["left_shoulder","left_hip"],["left_hip","left_knee"],["left_knee","left_ankle"],["nose","right_shoulder"],["right_shoulder","right_elbow"],["right_elbow","right_wrist"],["right_shoulder","right_hip"],["right_hip","right_knee"],["right_knee","right_ankle"]].map(function(e){var t=e[0],n=e[1];return[y5[t],y5[n]]}),x5=b5.map(function(e){return e[1]}),v5=b5.map(function(e){return e[0]});function w5(e,t,n){return e<t?t:e>n?n:e}function k5(e,t,n,a){return{y:w5(Math.round(e.y/t),0,n-1),x:w5(Math.round(e.x/t),0,a-1)}}function S5(e,t){return{x:e.x+t.x,y:e.y+t.y}}function C5(e,t,n,a,s,r,i,o){void 0===o&&(o=2);for(var c=a.shape,l=c[0],u=c[1],h={y:t.y,x:t.x},d=S5(h,function(e,t,n){var a=n.shape[2]/2;return{y:n.get(t.y,t.x,e),x:n.get(t.y,t.x,a+e)}}(e,k5(h,r,l,u),i)),p=0;p<o;p++){var f=k5(d,r,l,u),m=f5(f.y,f.x,n,s);d=S5({x:f.x*r,y:f.y*r},{x:m.x,y:m.y})}var g=k5(d,r,l,u),y=a.get(g.y,g.x,n);return{y:d.y,x:d.x,name:S4[n],score:y}}function I5(e,t,n,a,s,r){var i=t.shape[2],o=x5.length,c=new Array(i),l=e.part,u=e.score,h=m5(l,a,n);c[l.id]={score:u,name:S4[l.id],y:h.y,x:h.x};for(var d=o-1;d>=0;--d){var p=x5[d],f=v5[d];c[p]&&!c[f]&&(c[f]=C5(d,c[p],f,t,n,a,r))}for(d=0;d<o;++d)p=v5[d],f=x5[d],c[p]&&!c[f]&&(c[f]=C5(d,c[p],f,t,n,a,s));return c}function N5(e,t,n){return n.reduce(function(n,a,s){var r=a.y,i=a.x,o=a.score;return g5(e,t,{y:r,x:i},s)||(n+=o),n},0)/n.length}function T5(e,t,n,a,s,r,i,o){return void 0===i&&(i=.5),void 0===o&&(o=20),v4(this,void 0,void 0,function(){var c,l,u,h,d,p,f,m,g,y,b,x;return w4(this,function(v){switch(v.label){case 0:return[4,p5([e,t,n,a])];case 1:for(c=v.sent(),l=c[0],u=c[1],h=c[2],d=c[3],p=[],f=function(e,t,n){for(var a=n.shape,s=a[0],r=a[1],i=a[2],o=new h5(s*r*i,function(e){return e.score}),c=0;c<s;++c)for(var l=0;l<r;++l)for(var u=0;u<i;++u){var h=n.get(c,l,u);h<e||d5(u,h,c,l,1,n)&&o.enqueue({score:h,part:{heatmapY:c,heatmapX:l,id:u}})}return o}(i,0,l),m=o*o;p.length<r&&!f.empty();)g=f.dequeue(),y=m5(g.part,s,u),g5(p,m,y,g.part.id)||(b=I5(g,l,u,s,h,d),x=N5(p,m,b),p.push({keypoints:b,score:x}));return[2,p]}})})}function E5(){for(var e,t=[],n=0;n<arguments.length;n++)t[n]=arguments[n];switch(t.length){case 0:e="fn main() ";break;case 1:e="fn main(".concat(t[0]," : i32)");break;default:throw Error("Unreachable")}return e}var R5=function(){function e(e){this.variableNames=["A","B"],this.size=!0,this.workgroupSize=[32,1,1],this.outputShape=[e[0],1],this.dispatchLayout=ZQ(this.outputShape),this.dispatch=XQ(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="getpointsConfidenceOp"}return e.prototype.getUserCode=function(){return"\n        ".concat(E5("index")," {\n          if (index < uniforms.size) {\n            let y = B[index * 2];\n            let x = B[index * 2 + 1];\n            let outIndex = y * uniforms.aShape.x * uniforms.aShape.z + x * uniforms.aShape.z + index;\n            result[index] = A[outIndex];\n          }\n        }\n        ")},e}();var _5=function(){function e(e){if(this.variableNames=["A","B"],this.size=!0,this.supportedLastDimension=2,2!==e.length||e[1]!==this.supportedLastDimension)throw new Error("GetOffsetVectorsProgram only supports shape of [x, ".concat(this.supportedLastDimension,"], but current shape is ").concat(e));this.workgroupSize=[32,1,1],this.outputShape=e;var t=[e[0],1];this.dispatchLayout=ZQ(t),this.dispatch=XQ(this.dispatchLayout,t,this.workgroupSize),this.shaderKey="GetOffsetVectors"}return e.prototype.getUserCode=function(){return"\n    fn getOffsetPoint(y: i32, x: i32, index: i32) -> vec2<i32> {\n      let outIndexY = y * uniforms.bShape.x * uniforms.bShape.y + x * uniforms.bShape.y + index;\n      let outIndexX = outIndexY + uniforms.bShape.z;\n      let outY = i32(B[outIndexY]);\n      let outX = i32(B[outIndexX]);\n      return vec2<i32>(outY, outX);\n    }\n\n    ".concat(E5("index")," {\n      if (index < uniforms.size) {\n        let indexY = index * ").concat(this.supportedLastDimension,";\n        let indexX = indexY + 1;\n        let heatmapY = A[indexY];\n        let heatmapX = A[indexX];\n        let out = getOffsetPoint(i32(heatmapY), i32(heatmapX), index);\n        result[indexY] = f32(out[0]);\n        result[indexX] = f32(out[1]);\n      }\n    }\n    ")},e}();function A5(e){var t=e.shape,n=t[0],a=t[1],s=t[2];return Xm(function(){var t,r,i=nx(e,[n*a,s]),o=Db(i,0),c=hv(cy(o,fy(a,"int32")),1),l=hv((t=o,r=a,Xm(function(){var e=cy(t,fy(r,"int32"));return Iy(t,ly(e,fy(r,"int32")))})),1);return rx([c,l],1)})}function M5(e,t,n){return Xm(function(){var a=function(e,t){for(var n=[],a=0;a<S4.length;a++){var s=P5(e.get(a,0).valueOf(),e.get(a,1).valueOf(),a,t),r=s.x,i=s.y;n.push(i),n.push(r)}return ck(n,[S4.length,2])}(e,n);return iy(ay(ly(e.toTensor(),fy(t,"int32")),"float32"),a)})}function P5(e,t,n,a){return{y:a.get(e,t,n),x:a.get(e,t,n+S4.length)}}function D5(e,t,n){return v4(this,void 0,void 0,function(){var a,s,r,i,o,c,l,u,h,d;return w4(this,function(p){switch(p.label){case 0:return a=0,s=A5(e),[4,Promise.all([e.buffer(),t.buffer(),s.buffer()])];case 1:return r=p.sent(),i=r[0],o=r[1],c=r[2],[4,(l=M5(c,n,o)).buffer()];case 2:return u=p.sent(),h=Array.from(function(e,t){for(var n=t.shape[0],a=new Float32Array(n),s=0;s<n;s++){var r=t.get(s,0),i=t.get(s,1);a[s]=e.get(r,i,s)}return a}(i,c)),d=h.map(function(e,t){return a+=e,{y:u.get(t,0),x:u.get(t,1),score:e,name:S4[t]}}),s.dispose(),l.dispose(),[2,{keypoints:d,score:a/d.length}]}})})}function O5(e,t,n){return v4(this,void 0,void 0,function(){var a,s,r;return w4(this,function(i){return a=A5(e),s=function(e,t,n){return Xm(function(){var a=function(e,t){if($m()instanceof aZ)return function(e,t){var n=$m(),a=new _5(e.shape),s=n.runWebGPUProgram(a,[e,t],"float32");return qm().makeTensorFromTensorInfo(s)}(e,t);throw new Error("getOffsetVectorsGPU is not supported in this backend!")}(e,n);return iy(ay(ly(e,fy(t,"int32")),"float32"),a)})}(a,n,t),r=function(e,t){if($m()instanceof aZ)return function(e,t){var n=$m(),a=new R5(t.shape),s=n.runWebGPUProgram(a,[e,t],"float32");return qm().makeTensorFromTensorInfo(s)}(e,t);throw new Error("getPointsConfidenceWebGPU is not supported in this backend!")}(e,a),[2,[s,r]]})})}function F5(e,t){return(e-1)%t==0}var L5="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/mobilenet/",z5="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/resnet50/";function B5(e,t){return function(e,t){return(e-1)%t==0}(e,t)?e:Math.floor(e/t)*t+1}var j5=function(){function e(e,t){this.posenetModel=e;var n=this.posenetModel.inputs[0].shape;bu(-1===n[1]&&-1===n[2],function(){return"Input shape [".concat(n[1],", ").concat(n[2],"] ")+"must both be equal to or -1"});var a,s,r=(a=t.inputResolution,s=t.outputStride,{height:B5(a.height,s),width:B5(a.width,s)});!function(e){bu(s5.indexOf(e)>=0,function(){return"outputStride of ".concat(e," is invalid. ")+"It must be either 8 or 16."})}(t.outputStride),function(e,t){bu(F5(e.height,t),function(){return"height of ".concat(e.height," is invalid for output stride ")+"".concat(t,".")}),bu(F5(e.width,t),function(){return"width of ".concat(e.width," is invalid for output stride ")+"".concat(t,".")})}(r,t.outputStride),this.inputResolution=r,this.outputStride=t.outputStride,this.architecture=t.architecture}return e.prototype.estimatePoses=function(e,t){return void 0===t&&(t=o5),v4(this,void 0,void 0,function(){return w4(this,function(n){return[2,this.estimatePosesGPU(e,t,!1)]})})},e.prototype.estimatePosesGPU=function(e,t,n){return void 0===t&&(t=o5),void 0===n&&(n=!1),v4(this,void 0,void 0,function(){var a,s,r,i,o,c,l,u,h,d,p,f,m,g,y,b,x,v;return w4(this,function(w){switch(w.label){case 0:return a=function(e){var t=e;if(null==t.maxPoses&&(t.maxPoses=1),t.maxPoses<=0)throw new Error("Invalid maxPoses ".concat(t.maxPoses,". Should be > 0."));if(t.maxPoses>1){if((t=x4(x4({},c5),t)).scoreThreshold<0||t.scoreThreshold>1)throw new Error("Invalid scoreThreshold ".concat(t.scoreThreshold,". ")+"Should be in range [0.0, 1.0]");if(t.nmsRadius<=0)throw new Error("Invalid nmsRadius ".concat(t.nmsRadius,"."))}return t}(t),null==e?[2,n?[[],[]]:[]]:(this.maxPoses=a.maxPoses,s=Q4(e,{outputTensorSize:this.inputResolution,keepAspectRatio:!0,borderMode:"replicate"}),r=s.imageTensor,i=s.padding,o="ResNet50"===this.architecture?iy(r,l5):Y4(r,[-1,1]),c=this.posenetModel.predict(o),"ResNet50"===this.architecture?(l=nk(c[2],[0]),u=nk(c[3],[0]),h=nk(c[0],[0]),d=nk(c[1],[0])):(l=nk(c[0],[0]),u=nk(c[1],[0]),h=nk(c[2],[0]),d=nk(c[3],[0])),p=ox(u),1!==this.maxPoses?[3,5]:n?[4,O5(p,l,this.outputStride)]:[3,2]);case 1:return m=w.sent(),y=m[0],g=m[1],f=[y,g],[3,4];case 2:return[4,D5(p,l,this.outputStride)];case 3:y=w.sent(),f=[y],w.label=4;case 4:return[3,7];case 5:if(n)throw new Error("GPU renderer only supports single pose!");return[4,T5(p,l,h,d,this.outputStride,this.maxPoses,a.scoreThreshold,a.nmsRadius)];case 6:f=w.sent(),w.label=7;case 7:if(n){if(!0===a.flipHorizontal)throw new Error("flipHorizontal is not supported!");b=this.getCanvasInfo(B4(e),this.inputResolution,i)}else v=B4(e),x=function(e,t,n,a){var s=t.height,r=t.width,i=s/(n.height*(1-a.top-a.bottom)),o=r/(n.width*(1-a.left-a.right)),c=-a.top*n.height,l=-a.left*n.width;if(1===o&&1===i&&0===c&&0===l)return e;for(var u=0,h=e;u<h.length;u++)for(var d=0,p=h[u].keypoints;d<p.length;d++){var f=p[d];f.x=(f.x+l)*o,f.y=(f.y+c)*i}return e}(f,v,this.inputResolution,i),a.flipHorizontal&&(x=function(e,t){for(var n=0,a=e;n<a.length;n++)for(var s=0,r=a[n].keypoints;s<r.length;s++){var i=r[s];i.x=t.width-1-i.x}return e}(x,v));return r.dispose(),o.dispose(),Ym(c),l.dispose(),u.dispose(),h.dispose(),d.dispose(),p.dispose(),[2,n?[f,b]:x]}})})},e.prototype.getCanvasInfo=function(e,t,n){var a=e.height,s=e.width,r=a/(t.height*(1-n.top-n.bottom)),i=s/(t.width*(1-n.left-n.right)),o=-n.top*t.height;return[-n.left*t.width,o,i,r,e.width,e.height]},e.prototype.dispose=function(){this.posenetModel.dispose()},e.prototype.reset=function(){},e}();function W5(e){return void 0===e&&(e=t5),v4(this,void 0,void 0,function(){var t,n,a,s,r;return w4(this,function(i){switch(i.label){case 0:return"ResNet50"!==(t=function(e){var t=e||t5;if(null==t.architecture&&(t.architecture="MobileNetV1"),n5.indexOf(t.architecture)<0)throw new Error("Invalid architecture ".concat(t.architecture,". ")+"Should be one of ".concat(n5));if(null==t.inputResolution&&(t.inputResolution={height:257,width:257}),null==t.outputStride&&(t.outputStride=16),a5[t.architecture].indexOf(t.outputStride)<0)throw new Error("Invalid outputStride ".concat(t.outputStride,". ")+"Should be one of ".concat(a5[t.architecture]," ")+"for architecture ".concat(t.architecture,"."));if(null==t.multiplier&&(t.multiplier=1),r5[t.architecture].indexOf(t.multiplier)<0)throw new Error("Invalid multiplier ".concat(t.multiplier,". ")+"Should be one of ".concat(r5[t.architecture]," ")+"for architecture ".concat(t.architecture,"."));if(null==t.quantBytes&&(t.quantBytes=4),i5.indexOf(t.quantBytes)<0)throw new Error("Invalid quantBytes ".concat(t.quantBytes,". ")+"Should be one of ".concat(i5," ")+"for architecture ".concat(t.architecture,"."));if("MobileNetV1"===t.architecture&&32===t.outputStride&&1!==t.multiplier)throw new Error("When using an output stride of 32, you must select 1 as the multiplier.");return t}(e)).architecture?[3,2]:(o=t.outputStride,c=t.quantBytes,l="model-stride".concat(o,".json"),n=4===c?z5+"float/"+l:z5+"quant".concat(c,"/")+l,[4,OP(t.modelUrl||n)]);case 1:return a=i.sent(),[2,new j5(a,t)];case 2:return s=function(e,t,n){var a={1:"100",.75:"075",.5:"050"},s="model-stride".concat(e,".json");return 4===n?L5+"float/".concat(a[t],"/")+s:L5+"quant".concat(n,"/").concat(a[t],"/")+s}(t.outputStride,t.multiplier,t.quantBytes),[4,OP(t.modelUrl||s)];case 3:return r=i.sent(),[2,new j5(r,t)]}var o,c,l})})}function V5(e,t){return v4(this,void 0,void 0,function(){var n,a;return w4(this,function(s){switch(e){case B6.PoseNet:return[2,W5(t)];case B6.BlazePose:if(a=void 0,null!=(n=t)){if("tfjs"===n.runtime)return[2,L6(t)];if("mediapipe"===n.runtime)return[2,z4(t)];a=n.runtime}throw new Error("Expect modelConfig.runtime to be either 'tfjs' "+"or 'mediapipe', but got ".concat(a));case B6.MoveNet:return[2,e5(t)];default:throw new Error("".concat(e," is not a supported model name."))}})})}var U5={modelType:{SINGLEPOSE_LIGHTNING:"SinglePose.Lightning",SINGLEPOSE_THUNDER:"SinglePose.Thunder",MULTIPOSE_LIGHTNING:"MultiPose.Lightning"}};const H5=()=>{const{poseId:e}=_e(),t=Te(),n=Re(),a=(0,E.useRef)(null),s=(0,E.useRef)(null),r=(0,E.useRef)(null),[i,o]=(0,E.useState)(null),[c,l]=(0,E.useState)(!1),[u,h]=(0,E.useState)(null),[d,p]=(0,E.useState)(null),[f,m]=(0,E.useState)(0),[g,y]=(0,E.useState)([]),[b,x]=(0,E.useState)(!1);(0,E.useEffect)(()=>{var e;null!==(e=t.state)&&void 0!==e&&e.pose?o(t.state.pose):n("/pose-detection")},[t.state,n]),(0,E.useEffect)(()=>{(async()=>{x(!0);try{await(e="webgl",Em.setBackend(e)),await Em.ready(),console.log("TensorFlow.js backend initialized:",Zm());const r=B6.MoveNet;let i=null,o=null;try{if(!U5||!U5.modelType)throw new Error("movenet.modelType not available");{const e={modelType:U5.modelType.SINGLEPOSE_LIGHTNING};i=await V5(r,e),console.log("MoveNet Lightning (enum) loaded successfully")}}catch(t){console.warn("MoveNet Lightning (enum) failed:",t.message),o=t;try{const e={modelType:"lightning"};i=await V5(r,e),console.log("MoveNet Lightning (string) loaded successfully")}catch(n){console.warn("MoveNet Lightning (string) failed:",n.message),o=n;try{const e={modelType:"thunder"};i=await V5(r,e),console.log("MoveNet Thunder loaded successfully")}catch(a){console.warn("MoveNet Thunder failed:",a.message),o=a;try{i=await V5(r),console.log("MoveNet (default) loaded successfully")}catch(s){throw new Error("All MoveNet variants failed. Last error: ".concat(s.message))}}}}if(!i)throw new Error("Failed to create detector");p(i)}catch(r){console.error("Error loading pose detection model:",r),console.error("Error details:",r.message);try{console.log("Attempting to load BlazePose as fallback...");const e=B6.BlazePose,t={runtime:"tfjs",modelType:"lite",enableSmoothing:!0},n=await V5(e,t);p(n),console.log("BlazePose model loaded successfully as fallback")}catch(i){console.error("All models failed to load:",i),y(["Error loading pose detection model.","Please check your internet connection and refresh the page.","The model needs to be downloaded on first use.","Error: ".concat(r.message||"Unknown error")])}}finally{x(!1)}var e})()},[]);const v=(0,E.useCallback)(()=>{h(!0)},[]),w=(0,E.useCallback)(()=>{h(!1),y(["Camera access denied. Please enable camera permissions."])},[]),k=(e,t,n,a,s,r)=>{if(!e||!t||e.score<.5||t.score<.5)return!1;const i=((e,t)=>{if(!e||!t)return 1/0;const n=e.x-t.x,a=e.y-t.y;return Math.sqrt(n*n+a*a)})(e,t);return!(i>.6*Math.max(s,r))&&(!((5===n&&7===a||6===n&&8===a)&&i>.4*s)&&!((11===n&&13===a||12===n&&14===a)&&i>.5*r))},S=(0,E.useCallback)(async()=>{if(!a.current||!s.current||!d)return;const e=a.current.video,t=s.current,n=t.getContext("2d");if(e&&4===e.readyState){const a=e.videoWidth,s=e.videoHeight;t.width=a,t.height=s,n.clearRect(0,0,a,s);try{const t=await d.estimatePoses(e);if(t&&t.length>0){let e=t[0].keypoints;e=e.map(e=>zn(zn({},e),{},{x:a-e.x}));const r=[...e];[r[5],r[6]]=[r[6],r[5]],[r[7],r[8]]=[r[8],r[7]],[r[9],r[10]]=[r[10],r[9]],[r[11],r[12]]=[r[12],r[11]],[r[13],r[14]]=[r[14],r[13]],[r[15],r[16]]=[r[16],r[15]],[r[1],r[2]]=[r[2],r[1]],[r[3],r[4]]=[r[4],r[3]],e=r;const i=(e=>{if(!e||0===e.length)return m(0),y(["No pose detected. Please ensure your full body is visible."]),0;const t=e.filter(e=>e&&e.score>.5).length/e.length*100;let n=0;const a=[],s=e[5],r=e[6],i=e[11],o=e[12];if(e[7],e[8],e[13],e[14],s&&r&&s.score>.5&&r.score>.5){const e=Math.abs(s.y-r.y);e<20?n+=20:e<40?(n+=10,a.push("Keep your shoulders more level")):a.push("Keep your shoulders level")}if(i&&o&&i.score>.5&&o.score>.5){const e=Math.abs(i.y-o.y);e<20?n+=20:e<40?(n+=10,a.push("Align your hips better")):a.push("Align your hips")}const c=[s,r,i,o].filter(e=>e&&e.score>.3).length;if(c>=4?n+=20:c>=3?(n+=10,a.push("Ensure your full body is visible in the frame")):a.push("Ensure your full body is visible in the frame"),s&&r&&i&&o){const e=s.score>.5&&i.score>.5,t=r.score>.5&&o.score>.5;e&&t?n+=20:a.push("Try to show both sides of your body")}const l=e.reduce((e,t)=>e+((null===t||void 0===t?void 0:t.score)||0),0)/e.length;l>.7?n+=20:l>.5&&(n+=10);const u=Math.min(100,.3*t+.7*n),h=Math.round(u);return m(h),u>=90?0===a.length&&a.push("Excellent pose! Perfect alignment - Green lines indicate correct form"):u>=70?0===a.length&&a.push("Good form! Minor adjustments needed to reach 90% accuracy"):0===a.length&&a.push("Adjust your pose for better alignment - Aim for 90% accuracy for green lines"),y(a),h})(e);((e,t,n,a,s)=>{if(!e||0===e.length)return;const r=s>=90,i=r?"#00ff00":"#ff0000",o=r?"#00ff00":"#ff0000",c=r?4:3;[[5,6],[5,7],[7,9],[6,8],[8,10],[5,11],[6,12],[11,12],[11,13],[13,15],[12,14],[14,16]].forEach(s=>{let[r,o]=s;if(r<e.length&&o<e.length){const s=e[r],l=e[o];k(s,l,r,o,n,a)&&(t.beginPath(),t.moveTo(s.x,s.y),t.lineTo(l.x,l.y),t.strokeStyle=i,t.lineWidth=c,t.lineCap="round",t.lineJoin="round",t.stroke())}}),e.forEach((s,r)=>{if(((e,t,n,a,s)=>{if(!e||e.score<.5)return!1;const r=e.x,i=e.y;if(r<0||r>a||i<0||i>s)return!1;const o=n[5],c=n[6],l=n[11],u=n[12];return!((5===t||7===t||9===t||11===t||13===t||15===t)&&c&&c.score>.5&&r>c.x+50)&&!((6===t||8===t||10===t||12===t||14===t||16===t)&&o&&o.score>.5&&r<o.x-50)&&!(13===t&&l&&l.score>.5&&i<l.y-20)&&!(14===t&&u&&u.score>.5&&i<u.y-20)&&!(15===t&&n[13]&&n[13].score>.5&&i<n[13].y-20)&&!(16===t&&n[14]&&n[14].score>.5&&i<n[14].y-20)})(s,r,e,n,a)){const e=s.x,n=s.y;t.beginPath(),t.arc(e,n,8,0,2*Math.PI),t.fillStyle="#ffffff",t.fill(),t.beginPath(),t.arc(e,n,6,0,2*Math.PI),t.fillStyle=o,t.fill(),t.beginPath(),t.arc(e,n,2,0,2*Math.PI),t.fillStyle="#ffffff",t.fill()}})})(e,n,a,s,i)}else m(0),y(["No pose detected. Please ensure your full body is visible."]),n.clearRect(0,0,a,s)}catch(i){console.error("Error detecting pose:",i)}}c&&(r.current=requestAnimationFrame(S))},[d,c]);(0,E.useEffect)(()=>{if(c&&d)S();else if(r.current&&cancelAnimationFrame(r.current),s.current){s.current.getContext("2d").clearRect(0,0,s.current.width,s.current.height)}return()=>{r.current&&cancelAnimationFrame(r.current)}},[c,d,S]);return i?(0,wn.jsx)("div",{className:"pose-detail-page",children:(0,wn.jsxs)("div",{className:"container",children:[(0,wn.jsxs)("button",{className:"back-button",onClick:()=>n("/pose-detection"),children:[(0,wn.jsx)(It,{})," Back to Poses"]}),(0,wn.jsx)("section",{className:"pose-info-section",children:(0,wn.jsxs)("div",{className:"pose-header",children:[(0,wn.jsxs)("div",{className:"pose-image-large",children:[(0,wn.jsx)("img",{src:i.image,alt:i.name,loading:"eager",onError:e=>{var t,n,a;const s=(null===(t=i.name.split("(")[1])||void 0===t||null===(n=t.split(")")[0])||void 0===n?void 0:n.trim())||(null===(a=i.name.split("-")[1])||void 0===a?void 0:a.trim())||"yoga pose";let r,o=s.toLowerCase().replace(/\s+/g,"%20").replace(/[^a-z0-9%]/g,"");r=s.toLowerCase().includes("warrior")||s.toLowerCase().includes("virabhadrasana")?"https://images.unsplash.com/photo-1758599878236-47f6a918aed2?w=600&h=400&fit=crop&auto=format&q=80":s.toLowerCase().includes("cobra")||s.toLowerCase().includes("bhujangasana")?"https://images.unsplash.com/photo-1717821552922-61e18814a44a?w=600&h=400&fit=crop&auto=format&q=80":s.toLowerCase().includes("cat")||s.toLowerCase().includes("cow")||s.toLowerCase().includes("marjariasana")?"https://images.unsplash.com/photo-1758599881262-7b79a56ac284?w=600&h=400&fit=crop&auto=format&q=80":s.toLowerCase().includes("bridge")||s.toLowerCase().includes("setu")||s.toLowerCase().includes("bandhasana")?"https://images.unsplash.com/photo-1767611086180-6b1176976371?w=600&h=400&fit=crop&auto=format&q=80":s.toLowerCase().includes("triangle")||s.toLowerCase().includes("trikonasana")?"https://images.unsplash.com/photo-1767611090899-163209a4ead1?w=600&h=400&fit=crop&auto=format&q=80":s.toLowerCase().includes("downward")||s.toLowerCase().includes("dog")||s.toLowerCase().includes("svanasana")||s.toLowerCase().includes("adho")?"https://images.unsplash.com/photo-1767611121194-3cb554c9a9ec?w=600&h=400&fit=crop&auto=format&q=80":s.toLowerCase().includes("sun")||s.toLowerCase().includes("salutation")||s.toLowerCase().includes("surya")||s.toLowerCase().includes("namaskar")?"https://images.unsplash.com/photo-1606663368493-131f4f97c095?w=600&h=400&fit=crop&auto=format&q=80":s.toLowerCase().includes("child")||s.toLowerCase().includes("balasana")?"https://images.unsplash.com/photo-1767611118672-d3887038786c?w=600&h=400&fit=crop&auto=format&q=80":s.toLowerCase().includes("lotus")||s.toLowerCase().includes("padmasana")?"https://images.unsplash.com/photo-1577344718665-3e7c0c1ecf6b?w=600&h=400&fit=crop&auto=format&q=80":s.toLowerCase().includes("thunderbolt")||s.toLowerCase().includes("vajrasana")?"https://images.unsplash.com/photo-1697274834392-04ff3b76ef20?w=600&h=400&fit=crop&auto=format&q=80":s.toLowerCase().includes("tree")||s.toLowerCase().includes("vrikshasana")?"https://images.unsplash.com/photo-1758274525911-402f99afec14?w=600&h=400&fit=crop&auto=format&q=80":"https://images.unsplash.com/600x400/?yoga%20".concat(o,"&sig=").concat(i.id);let c=0;e.target.onerror=()=>{c++,e.target.src=c>=2?"https://images.unsplash.com/photo-1506126613408-eca07ce68773?w=600&h=400&fit=crop&auto=format&q=80":r},e.target.src=r}}),(0,wn.jsx)("span",{className:"pose-difficulty-badge-large ".concat(i.difficulty.toLowerCase()),children:i.difficulty})]}),(0,wn.jsxs)("div",{className:"pose-details",children:[(0,wn.jsx)("h1",{children:i.name}),(0,wn.jsx)("p",{className:"pose-description-large",children:i.description}),(0,wn.jsxs)("div",{className:"pose-meta-large",children:[(0,wn.jsxs)("span",{children:["\u23f1 Duration: ",i.duration]}),(0,wn.jsxs)("span",{children:["\ud83d\udcc2 Category: ",i.category]})]})]})]})}),(0,wn.jsx)("section",{className:"pose-detection-section",children:(0,wn.jsxs)("div",{className:"detection-container",children:[(0,wn.jsx)("div",{className:"webcam-wrapper-detection",children:!1===u?(0,wn.jsxs)("div",{className:"permission-denied",children:[(0,wn.jsx)(Kt,{}),(0,wn.jsx)("h3",{children:"Camera Access Denied"}),(0,wn.jsx)("p",{children:"Please enable camera permissions to use pose detection."})]}):(0,wn.jsxs)(wn.Fragment,{children:[(0,wn.jsxs)("div",{className:"webcam-container-detection",children:[(0,wn.jsx)(lu(),{ref:a,audio:!1,mirrored:!0,onUserMedia:v,onUserMediaError:w,className:"webcam-video-detection",videoConstraints:{width:640,height:480,facingMode:"user"}}),(0,wn.jsx)("canvas",{ref:s,className:"pose-canvas-detection"}),c&&(0,wn.jsx)("div",{className:"pose-overlay-detection",children:(0,wn.jsxs)("div",{className:"accuracy-display-detection",children:[(0,wn.jsx)("div",{className:"accuracy-circle-detection",style:{borderColor:f>=90?"#00ff00":"#ff0000",color:f>=90?"#00ff00":"#ff0000"},children:(0,wn.jsxs)("span",{children:[f,"%"]})}),(0,wn.jsxs)("p",{children:["Accuracy ",f>=90?"\u2713":"\u26a0"]}),(0,wn.jsx)("p",{className:"accuracy-hint",children:f>=90?"Green lines = Correct!":"Aim for 90% for green lines"})]})})]}),(0,wn.jsxs)("div",{className:"detection-controls",children:[c?(0,wn.jsxs)("button",{className:"btn btn-danger stop-detection-btn",onClick:()=>{l(!1),m(0),y([])},children:[(0,wn.jsx)(fn,{})," Stop Detection"]}):(0,wn.jsxs)("button",{className:"btn btn-primary start-detection-btn",onClick:()=>{d?(l(!0),y([])):y(["Pose detection model is still loading. Please wait..."])},disabled:!1===u||b||!d,children:[(0,wn.jsx)(cn,{})," ",b?"Loading Model...":d?"Start Pose Detection":"Model Not Ready"]}),b&&(0,wn.jsx)("p",{className:"model-loading-message",children:"Loading pose detection model... This may take a moment on first use."})]})]})}),(0,wn.jsxs)("div",{className:"detection-feedback-panel",children:[(0,wn.jsxs)("h3",{children:[(0,wn.jsx)(Jt,{})," Real-time Feedback"]}),g.length>0?(0,wn.jsx)("ul",{className:"feedback-list-detection",children:g.map((e,t)=>(0,wn.jsxs)("li",{className:f>=90?"success":"warning",children:[f>=90?(0,wn.jsx)(Dt,{}):(0,wn.jsx)(Kt,{}),(0,wn.jsx)("span",{children:e})]},t))}):(0,wn.jsx)("p",{className:"no-feedback-detection",children:c?"Position yourself in the camera frame to start detection...":'Click "Start Pose Detection" to begin practicing with real-time feedback.'})]})]})})]})}):(0,wn.jsx)("div",{className:"pose-detail-page",children:(0,wn.jsx)("div",{className:"container",children:(0,wn.jsx)("p",{children:"Loading pose details..."})})})},G5=()=>(0,wn.jsxs)("div",{className:"App",children:[(0,wn.jsx)(kn,{}),(0,wn.jsx)("main",{children:(0,wn.jsxs)(Ke,{children:[(0,wn.jsx)(Ge,{path:"/",element:(0,wn.jsx)(Cn,{})}),(0,wn.jsx)(Ge,{path:"/about",element:(0,wn.jsx)(In,{})}),(0,wn.jsx)(Ge,{path:"/features",element:(0,wn.jsx)(Nn,{})}),(0,wn.jsx)(Ge,{path:"/how-it-works",element:(0,wn.jsx)(Tn,{})}),(0,wn.jsx)(Ge,{path:"/pose-detection",element:(0,wn.jsx)(En,{})}),(0,wn.jsx)(Ge,{path:"/pose/:poseId",element:(0,wn.jsx)(H5,{})}),(0,wn.jsx)(Ge,{path:"/tech-stack",element:(0,wn.jsx)(Pn,{})}),(0,wn.jsx)(Ge,{path:"/results",element:(0,wn.jsx)(eu,{})}),(0,wn.jsx)(Ge,{path:"/team",element:(0,wn.jsx)(tu,{})}),(0,wn.jsx)(Ge,{path:"/contact",element:(0,wn.jsx)(nu,{})}),(0,wn.jsx)(Ge,{path:"/login",element:(0,wn.jsx)(ru,{})}),(0,wn.jsx)(Ge,{path:"/profile",element:(0,wn.jsx)(iu,{})}),(0,wn.jsx)(Ge,{path:"/category/:categoryId",element:(0,wn.jsx)(ou,{})})]})}),(0,wn.jsx)(Sn,{})]});_.createRoot(document.getElementById("root")).render((0,wn.jsx)(E.StrictMode,{children:(0,wn.jsx)($e,{children:(0,wn.jsx)(G5,{})})}))})()})();
//# sourceMappingURL=main.40f39987.js.map